use std::{mem::offset_of, any::Any, option::Option, sync::Arc};
use tokio::sync::Mutex;

use glacier_reflect::{
    member::MemberInfoFlags,
    type_info::{
        ClassInfoData, ValueTypeInfoData, FieldInfoData, TypeInfo, TypeInfoData, TypeObject, TypeFunctions,
    }, type_registry::TypeRegistry,
};

pub(crate) fn register_soldier_shared_types(registry: &mut TypeRegistry) {
    registry.register_type(ZEROINGWEAPONDATA_TYPE_INFO);
    registry.register_type(ZEROINGWEAPONDATA_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONZEROINGCOMPONENTDATA_TYPE_INFO);
    registry.register_type(WEAPONZEROINGCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONZEROINGMODIFIER_TYPE_INFO);
    registry.register_type(WEAPONZEROINGMODIFIER_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONZEROINGENTRY_TYPE_INFO);
    registry.register_type(WEAPONZEROINGENTRY_ARRAY_TYPE_INFO);
    registry.register_type(GUNSWAYDATA_TYPE_INFO);
    registry.register_type(GUNSWAYDATA_ARRAY_TYPE_INFO);
    registry.register_type(GUNSWAYMODIFIERUNLOCK_TYPE_INFO);
    registry.register_type(GUNSWAYMODIFIERUNLOCK_ARRAY_TYPE_INFO);
    registry.register_type(GUNSWAYMODIFIERDATA_TYPE_INFO);
    registry.register_type(GUNSWAYMODIFIERDATA_ARRAY_TYPE_INFO);
    registry.register_type(GUNSWAYSTANCEZOOMMODIFIERDATA_TYPE_INFO);
    registry.register_type(GUNSWAYSTANCEZOOMMODIFIERDATA_ARRAY_TYPE_INFO);
    registry.register_type(GUNSWAYCROUCHPRONEDATA_TYPE_INFO);
    registry.register_type(GUNSWAYCROUCHPRONEDATA_ARRAY_TYPE_INFO);
    registry.register_type(GUNSWAYSTANDDATA_TYPE_INFO);
    registry.register_type(GUNSWAYSTANDDATA_ARRAY_TYPE_INFO);
    registry.register_type(GUNSWAYBASEMOVEJUMPDATA_TYPE_INFO);
    registry.register_type(GUNSWAYBASEMOVEJUMPDATA_ARRAY_TYPE_INFO);
    registry.register_type(GUNSWAYZOOMLEVEL_TYPE_INFO);
    registry.register_type(GUNSWAYZOOMLEVEL_ARRAY_TYPE_INFO);
    registry.register_type(GUNSWAYDISPERSIONACTION_TYPE_INFO);
    registry.register_type(GUNSWAYDISPERSIONACTION_ARRAY_TYPE_INFO);
    registry.register_type(GUNSWAYBASEMOVEDATA_TYPE_INFO);
    registry.register_type(GUNSWAYBASEMOVEDATA_ARRAY_TYPE_INFO);
    registry.register_type(GUNSWAYBASEDATA_TYPE_INFO);
    registry.register_type(GUNSWAYBASEDATA_ARRAY_TYPE_INFO);
    registry.register_type(GUNSWAYSTANCETRANSITION_TYPE_INFO);
    registry.register_type(GUNSWAYSTANCETRANSITION_ARRAY_TYPE_INFO);
    registry.register_type(GUNSWAYRECOILMODDATA_TYPE_INFO);
    registry.register_type(GUNSWAYRECOILMODDATA_ARRAY_TYPE_INFO);
    registry.register_type(GUNSWAYRECOILDATA_TYPE_INFO);
    registry.register_type(GUNSWAYRECOILDATA_ARRAY_TYPE_INFO);
    registry.register_type(CAMERARECOILDATA_TYPE_INFO);
    registry.register_type(CAMERARECOILDATA_ARRAY_TYPE_INFO);
    registry.register_type(GUNSWAYDISPERSIONMODDATA_TYPE_INFO);
    registry.register_type(GUNSWAYDISPERSIONMODDATA_ARRAY_TYPE_INFO);
    registry.register_type(GUNSWAYDISPERSIONDATA_TYPE_INFO);
    registry.register_type(GUNSWAYDISPERSIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONMODIFIERNETSTATEDATA_TYPE_INFO);
    registry.register_type(WEAPONMODIFIERNETSTATEDATA_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONSWITCHINGNETSTATE_TYPE_INFO);
    registry.register_type(WEAPONSWITCHINGNETSTATE_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONSNETSTATE_TYPE_INFO);
    registry.register_type(WEAPONSNETSTATE_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERWEAPONSNETSTATE_TYPE_INFO);
    registry.register_type(SOLDIERWEAPONSNETSTATE_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONLAGENTITYDATA_TYPE_INFO);
    registry.register_type(WEAPONLAGENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONLAGBINDING_TYPE_INFO);
    registry.register_type(WEAPONLAGBINDING_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERWEAPONHUDDATA_TYPE_INFO);
    registry.register_type(SOLDIERWEAPONHUDDATA_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONSTATEDATA1P_TYPE_INFO);
    registry.register_type(WEAPONSTATEDATA1P_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONMESH1P_TYPE_INFO);
    registry.register_type(WEAPONMESH1P_ARRAY_TYPE_INFO);
    registry.register_type(EXPLOSIONPACKTRIPWIRETRIGGER_TYPE_INFO);
    registry.register_type(EXPLOSIONPACKTRIPWIRETRIGGER_ARRAY_TYPE_INFO);
    registry.register_type(TRIPWIREENTITYDATA_TYPE_INFO);
    registry.register_type(TRIPWIREENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERWEAPONBLUEPRINTBUNDLE_TYPE_INFO);
    registry.register_type(SOLDIERWEAPONBLUEPRINTBUNDLE_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONSKINNEDSOCKETOBJECTDATA_TYPE_INFO);
    registry.register_type(WEAPONSKINNEDSOCKETOBJECTDATA_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONREGULARSOCKETOBJECTDATA_TYPE_INFO);
    registry.register_type(WEAPONREGULARSOCKETOBJECTDATA_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONSOCKETOBJECTDATA_TYPE_INFO);
    registry.register_type(WEAPONSOCKETOBJECTDATA_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONMODIFIERDATA_TYPE_INFO);
    registry.register_type(WEAPONMODIFIERDATA_ARRAY_TYPE_INFO);
    registry.register_type(CLIENTSOLDIERWEAPONWEAPONMODIFIERCHANGEDMESSAGE_TYPE_INFO);
    registry.register_type(SERVERSOLDIERWEAPONWEAPONMODIFIERCHANGEDMESSAGE_TYPE_INFO);
    registry.register_type(WEAPONAIDATAMODIFIER_TYPE_INFO);
    registry.register_type(WEAPONAIDATAMODIFIER_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONSPRINTSETTINGSMODIFIER_TYPE_INFO);
    registry.register_type(WEAPONSPRINTSETTINGSMODIFIER_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONSOCKETMODIFIER_TYPE_INFO);
    registry.register_type(WEAPONSOCKETMODIFIER_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONANIMBASEMODIFIER_TYPE_INFO);
    registry.register_type(WEAPONANIMBASEMODIFIER_ARRAY_TYPE_INFO);
    registry.register_type(CUSTOMWEAPONTYPEMODIFIER_TYPE_INFO);
    registry.register_type(CUSTOMWEAPONTYPEMODIFIER_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONZOOMLEVELMODIFIER_TYPE_INFO);
    registry.register_type(WEAPONZOOMLEVELMODIFIER_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONZOOMMODIFIER_TYPE_INFO);
    registry.register_type(WEAPONZOOMMODIFIER_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONCLASSMODIFIER_TYPE_INFO);
    registry.register_type(WEAPONCLASSMODIFIER_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONANIMATEDFIRETYPEMODIFIER_TYPE_INFO);
    registry.register_type(WEAPONANIMATEDFIRETYPEMODIFIER_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONANIMTYPEMODIFIER_TYPE_INFO);
    registry.register_type(WEAPONANIMTYPEMODIFIER_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONANIMTYPE_TYPE_INFO);
    registry.register_type(WEAPONANIMTYPE_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONANIMATIONCONFIGURATIONMODIFIER_TYPE_INFO);
    registry.register_type(WEAPONANIMATIONCONFIGURATIONMODIFIER_ARRAY_TYPE_INFO);
    registry.register_type(GRENADEENTITYDATA_TYPE_INFO);
    registry.register_type(GRENADEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(GRENADETYPE_TYPE_INFO);
    registry.register_type(GRENADETYPE_ARRAY_TYPE_INFO);
    registry.register_type(SUPPLYSPHEREWEAPONDATA_TYPE_INFO);
    registry.register_type(SUPPLYSPHEREWEAPONDATA_ARRAY_TYPE_INFO);
    registry.register_type(SUPPLYDATA_TYPE_INFO);
    registry.register_type(SUPPLYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AMMOSUPPLYUNITSPHEREDATA_TYPE_INFO);
    registry.register_type(AMMOSUPPLYUNITSPHEREDATA_ARRAY_TYPE_INFO);
    registry.register_type(HEALINGSUPPLYUNITSPHEREDATA_TYPE_INFO);
    registry.register_type(HEALINGSUPPLYUNITSPHEREDATA_ARRAY_TYPE_INFO);
    registry.register_type(SUPPLYUNITSPHEREDATA_TYPE_INFO);
    registry.register_type(SUPPLYUNITSPHEREDATA_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONAIMINGSIMULATIONMODIFIER_TYPE_INFO);
    registry.register_type(WEAPONAIMINGSIMULATIONMODIFIER_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERAIMINGSIMULATIONDATA_TYPE_INFO);
    registry.register_type(SOLDIERAIMINGSIMULATIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(ZOOMLEVELDATA_TYPE_INFO);
    registry.register_type(ZOOMLEVELDATA_ARRAY_TYPE_INFO);
    registry.register_type(ZOOMLEVELACTIVATEEVENTTYPE_TYPE_INFO);
    registry.register_type(ZOOMLEVELACTIVATEEVENTTYPE_ARRAY_TYPE_INFO);
    registry.register_type(PLATFORMAIMASSISTDATA_TYPE_INFO);
    registry.register_type(PLATFORMAIMASSISTDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERAIMASSISTDATA_TYPE_INFO);
    registry.register_type(SOLDIERAIMASSISTDATA_ARRAY_TYPE_INFO);
    registry.register_type(THROWATTARGETWEAPONDATA_TYPE_INFO);
    registry.register_type(THROWATTARGETWEAPONDATA_ARRAY_TYPE_INFO);
    registry.register_type(MELEEWEAPONDATA_TYPE_INFO);
    registry.register_type(MELEEWEAPONDATA_ARRAY_TYPE_INFO);
    registry.register_type(FLASHLIGHTWEAPONDATA_TYPE_INFO);
    registry.register_type(FLASHLIGHTWEAPONDATA_ARRAY_TYPE_INFO);
    registry.register_type(NETWORKDEFIBRILLATORREVIVEMESSAGE_TYPE_INFO);
    registry.register_type(DEFIBRILLATORWEAPONDATA_TYPE_INFO);
    registry.register_type(DEFIBRILLATORWEAPONDATA_ARRAY_TYPE_INFO);
    registry.register_type(DEFIBRILLATORUPGRADEWEAPONDATA_TYPE_INFO);
    registry.register_type(DEFIBRILLATORUPGRADEWEAPONDATA_ARRAY_TYPE_INFO);
    registry.register_type(REPAIRTOOLWEAPONDATA_TYPE_INFO);
    registry.register_type(REPAIRTOOLWEAPONDATA_ARRAY_TYPE_INFO);
    registry.register_type(POWERTOOLWEAPONDATA_TYPE_INFO);
    registry.register_type(POWERTOOLWEAPONDATA_ARRAY_TYPE_INFO);
    registry.register_type(MEDICBAGHEALINGSPHEREWEAPONDATA_TYPE_INFO);
    registry.register_type(MEDICBAGHEALINGSPHEREWEAPONDATA_ARRAY_TYPE_INFO);
    registry.register_type(MEDKITWEAPONDATA_TYPE_INFO);
    registry.register_type(MEDKITWEAPONDATA_ARRAY_TYPE_INFO);
    registry.register_type(DETONATEDWEAPONDATA_TYPE_INFO);
    registry.register_type(DETONATEDWEAPONDATA_ARRAY_TYPE_INFO);
    registry.register_type(MISSILEHEALTHCOMPONENTDATA_TYPE_INFO);
    registry.register_type(MISSILEHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(EXPLOSIONPACKHEALTHCOMPONENTDATA_TYPE_INFO);
    registry.register_type(EXPLOSIONPACKHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(EXPLOSIONPACKPHYSICSCOMPONENTDATA_TYPE_INFO);
    registry.register_type(EXPLOSIONPACKPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(EXPLOSIONPACKENTITYDATA_TYPE_INFO);
    registry.register_type(EXPLOSIONPACKENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(EXPLOSIONPACKREMOTEDETONATORTRIGGER_TYPE_INFO);
    registry.register_type(EXPLOSIONPACKREMOTEDETONATORTRIGGER_ARRAY_TYPE_INFO);
    registry.register_type(EXPLOSIONPACKINFANTRYTRIGGER_TYPE_INFO);
    registry.register_type(EXPLOSIONPACKINFANTRYTRIGGER_ARRAY_TYPE_INFO);
    registry.register_type(EXPLOSIONPACKVEHICLERAYTRIGGER_TYPE_INFO);
    registry.register_type(EXPLOSIONPACKVEHICLERAYTRIGGER_ARRAY_TYPE_INFO);
    registry.register_type(EXPLOSIONPACKVEHICLEPROXIMITYTRIGGER_TYPE_INFO);
    registry.register_type(EXPLOSIONPACKVEHICLEPROXIMITYTRIGGER_ARRAY_TYPE_INFO);
    registry.register_type(EXPLOSIONPACKTRIGGER_TYPE_INFO);
    registry.register_type(EXPLOSIONPACKTRIGGER_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERDETONATIONDATA_TYPE_INFO);
    registry.register_type(SOLDIERDETONATIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(NETWORKSETACTIVEWEAPONSLOTMESSAGE_TYPE_INFO);
    registry.register_type(EXPLOSIONTOCHARACTERCOMPONENTSHITMESSAGE_TYPE_INFO);
    registry.register_type(BULLETTOCHARACTERCOMPONENTSHITMESSAGE_TYPE_INFO);
    registry.register_type(EXPLOSIONHITINFO_TYPE_INFO);
    registry.register_type(EXPLOSIONHITINFO_ARRAY_TYPE_INFO);
    registry.register_type(BULLETHITINFO_TYPE_INFO);
    registry.register_type(BULLETHITINFO_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERWEAPONDATA_TYPE_INFO);
    registry.register_type(SOLDIERWEAPONDATA_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONSPRINTSETTINGS_TYPE_INFO);
    registry.register_type(WEAPONSPRINTSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(CLIENTSOLDIERWEAPONSPAWNEDMESSAGE_TYPE_INFO);
    registry.register_type(SERVERSOLDIERWEAPONSPAWNEDMESSAGE_TYPE_INFO);
    registry.register_type(CUSTOMIZATIONACCESSORYPIVOTS_TYPE_INFO);
    registry.register_type(CUSTOMIZATIONACCESSORYPIVOTS_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONZOOMLEVELDATA_TYPE_INFO);
    registry.register_type(WEAPONZOOMLEVELDATA_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONANIMATIONSETTINGSDATA_TYPE_INFO);
    registry.register_type(WEAPONANIMATIONSETTINGSDATA_ARRAY_TYPE_INFO);
    registry.register_type(SIGHTTYPE_TYPE_INFO);
    registry.register_type(SIGHTTYPE_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONOVERRIDEDATA_TYPE_INFO);
    registry.register_type(WEAPONOVERRIDEDATA_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONOVERRIDEVALUE_TYPE_INFO);
    registry.register_type(WEAPONOVERRIDEVALUE_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONOVERRIDEVALUETYPE_TYPE_INFO);
    registry.register_type(WEAPONOVERRIDEVALUETYPE_ARRAY_TYPE_INFO);
    registry.register_type(QUICKTHROWTYPEENUM_TYPE_INFO);
    registry.register_type(QUICKTHROWTYPEENUM_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONENTITYDATA_TYPE_INFO);
    registry.register_type(WEAPONENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERWEAPONSPREVIEWCOMPONENTDATA_TYPE_INFO);
    registry.register_type(SOLDIERWEAPONSPREVIEWCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERWEAPONSCOMPONENTDATA_TYPE_INFO);
    registry.register_type(SOLDIERWEAPONSCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANIMBASESETTOANTWEAPONTYPE_TYPE_INFO);
    registry.register_type(ANIMBASESETTOANTWEAPONTYPE_ARRAY_TYPE_INFO);
    registry.register_type(PICKUPSETTINGSDATA_TYPE_INFO);
    registry.register_type(PICKUPSETTINGSDATA_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONCLASSENUM_TYPE_INFO);
    registry.register_type(WEAPONCLASSENUM_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONANIMBASESETENUM_TYPE_INFO);
    registry.register_type(WEAPONANIMBASESETENUM_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONSTATEDATA_TYPE_INFO);
    registry.register_type(WEAPONSTATEDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANIMATEDAIMINGENUM_TYPE_INFO);
    registry.register_type(ANIMATEDAIMINGENUM_ARRAY_TYPE_INFO);
    registry.register_type(ANIMATEDFIREENUM_TYPE_INFO);
    registry.register_type(ANIMATEDFIREENUM_ARRAY_TYPE_INFO);
    registry.register_type(FIRSTPERSONCAMERADATA_TYPE_INFO);
    registry.register_type(FIRSTPERSONCAMERADATA_ARRAY_TYPE_INFO);
    registry.register_type(ZOOMLEVELSPECIFICTRANSITIONTIME_TYPE_INFO);
    registry.register_type(ZOOMLEVELSPECIFICTRANSITIONTIME_ARRAY_TYPE_INFO);
    registry.register_type(AIMINGPOSEDATA_TYPE_INFO);
    registry.register_type(AIMINGPOSEDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIMERMODIFIERDATA_TYPE_INFO);
    registry.register_type(AIMERMODIFIERDATA_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVEROBJECTREADERWATCHERENTITYDATA_TYPE_INFO);
    registry.register_type(VOICEOVEROBJECTREADERWATCHERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVEROBJECTREADERENTITYDATA_TYPE_INFO);
    registry.register_type(VOICEOVEROBJECTREADERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VOOBJECTPROPERTIESREADER_TYPE_INFO);
    registry.register_type(VOOBJECTPROPERTIESREADER_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVEROBJECTTYPE_TYPE_INFO);
    registry.register_type(VOICEOVEROBJECTTYPE_ARRAY_TYPE_INFO);
    registry.register_type(UNLOCKDYNAMICTOGGLEMESSAGE_TYPE_INFO);
    registry.register_type(SOLDIERWEAPONCUSTOMIZATIONASSET_TYPE_INFO);
    registry.register_type(SOLDIERWEAPONCUSTOMIZATIONASSET_ARRAY_TYPE_INFO);
    registry.register_type(UNLOCKWEAPONANDSLOT_TYPE_INFO);
    registry.register_type(UNLOCKWEAPONANDSLOT_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERWEAPONUNLOCKASSET_TYPE_INFO);
    registry.register_type(SOLDIERWEAPONUNLOCKASSET_ARRAY_TYPE_INFO);
    registry.register_type(UNLOCKTOBLUEPRINTBUNDLE_TYPE_INFO);
    registry.register_type(UNLOCKTOBLUEPRINTBUNDLE_ARRAY_TYPE_INFO);
    registry.register_type(STOREDWEAPONDATA_TYPE_INFO);
    registry.register_type(STOREDWEAPONDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERWEAPONMULTIUNLOCK_TYPE_INFO);
    registry.register_type(SOLDIERWEAPONMULTIUNLOCK_ARRAY_TYPE_INFO);
    registry.register_type(TRIPWIRENETDATA_TYPE_INFO);
    registry.register_type(TRIPWIRENETDATA_ARRAY_TYPE_INFO);
    registry.register_type(TRIGGERMOVEENTITYDATA_TYPE_INFO);
    registry.register_type(TRIGGERMOVEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATETRIGGERENTITYDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATETRIGGERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOOKATTRIGGERENTITYDATA_TYPE_INFO);
    registry.register_type(LOOKATTRIGGERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERSPAWNREFERENCEOBJECTDATA_TYPE_INFO);
    registry.register_type(SOLDIERSPAWNREFERENCEOBJECTDATA_ARRAY_TYPE_INFO);
    registry.register_type(CUSTOMIZESOLDIERENTITYDATA_TYPE_INFO);
    registry.register_type(CUSTOMIZESOLDIERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERSPAWNAPPEARANCETEMPLATEDATA_TYPE_INFO);
    registry.register_type(SOLDIERSPAWNAPPEARANCETEMPLATEDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERSPAWNKITTEMPLATEDATA_TYPE_INFO);
    registry.register_type(SOLDIERSPAWNKITTEMPLATEDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERWEAPONSWITCHINGDATA_TYPE_INFO);
    registry.register_type(SOLDIERWEAPONSWITCHINGDATA_ARRAY_TYPE_INFO);
    registry.register_type(DIRECTWEAPONSWITCHINGMAPDATA_TYPE_INFO);
    registry.register_type(DIRECTWEAPONSWITCHINGMAPDATA_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONSWITCHINGMAPDATA_TYPE_INFO);
    registry.register_type(WEAPONSWITCHINGMAPDATA_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONSWITCHINGENUM_TYPE_INFO);
    registry.register_type(WEAPONSWITCHINGENUM_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERINPUTSETTINGS_TYPE_INFO);
    registry.register_type(SOLDIERINPUTSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(POSETRANSITION_TYPE_INFO);
    registry.register_type(POSETRANSITION_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERBUFFID_TYPE_INFO);
    registry.register_type(SOLDIERBUFFID_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERROLE_TYPE_INFO);
    registry.register_type(PLAYERROLE_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERHEALTHCOMPONENTDATA_TYPE_INFO);
    registry.register_type(SOLDIERHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(DAMAGEENTRYDATA_TYPE_INFO);
    registry.register_type(DAMAGEENTRYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERPHYSICSCOMPONENTDATA_TYPE_INFO);
    registry.register_type(SOLDIERPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(CUSTOMIZESOLDIERDATA_TYPE_INFO);
    registry.register_type(CUSTOMIZESOLDIERDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERSETTINGS_TYPE_INFO);
    registry.register_type(SOLDIERSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(SERVERSOLDIERONACTIONSTATECHANGEDMESSAGE_TYPE_INFO);
    registry.register_type(SOLDIERTOCOMPONENTSONCLEARSPOTTINGMESSAGE_TYPE_INFO);
    registry.register_type(CLIENTSOLDIERTOCOMPONENTSONHANDLEDAMAGEMESSAGE_TYPE_INFO);
    registry.register_type(CLIENTSOLDIERTOCOMPONENTSONIMPULSEMESSAGE_TYPE_INFO);
    registry.register_type(SOLDIERTOCOMPONENTSONACTIONSTATECHANGEDMESSAGE_TYPE_INFO);
    registry.register_type(SOLDIERTOCOMPONENTSONINCAPABLEMESSAGE_TYPE_INFO);
    registry.register_type(SOLDIERTOCOMPONENTSONCUSTOMIZESOLDIERMESSAGE_TYPE_INFO);
    registry.register_type(SOLDIERENTITYDATA_TYPE_INFO);
    registry.register_type(SOLDIERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERACTIONSTATE_TYPE_INFO);
    registry.register_type(SOLDIERACTIONSTATE_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERHEALTHMODULEDATA_TYPE_INFO);
    registry.register_type(SOLDIERHEALTHMODULEDATA_ARRAY_TYPE_INFO);
    registry.register_type(BREATHCONTROLDATA_TYPE_INFO);
    registry.register_type(BREATHCONTROLDATA_ARRAY_TYPE_INFO);
    registry.register_type(COLLISIONDATA_TYPE_INFO);
    registry.register_type(COLLISIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(VALUEATX_TYPE_INFO);
    registry.register_type(VALUEATX_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERWEAPONOVERRIDEDATA_TYPE_INFO);
    registry.register_type(SOLDIERWEAPONOVERRIDEDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERSPRINTSETTINGSDATA_TYPE_INFO);
    registry.register_type(SOLDIERSPRINTSETTINGSDATA_ARRAY_TYPE_INFO);
    registry.register_type(DEATHANIMATIONOPERATION_TYPE_INFO);
    registry.register_type(DEATHANIMATIONOPERATION_ARRAY_TYPE_INFO);
    registry.register_type(HIDABLESOLDIERMESHWEAPONPART_TYPE_INFO);
    registry.register_type(HIDABLESOLDIERMESHWEAPONPART_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERHEADCOLLISIONDATA_TYPE_INFO);
    registry.register_type(SOLDIERHEADCOLLISIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERHEADCOLLISIONPOSEDATA_TYPE_INFO);
    registry.register_type(SOLDIERHEADCOLLISIONPOSEDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERAUTOAIMDATA_TYPE_INFO);
    registry.register_type(SOLDIERAUTOAIMDATA_ARRAY_TYPE_INFO);
    registry.register_type(AUTOAIMDATA_TYPE_INFO);
    registry.register_type(AUTOAIMDATA_ARRAY_TYPE_INFO);
    registry.register_type(FOOTSTEPTRIGGER_TYPE_INFO);
    registry.register_type(FOOTSTEPTRIGGER_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERSOUNDDATA_TYPE_INFO);
    registry.register_type(SOLDIERSOUNDDATA_ARRAY_TYPE_INFO);
    registry.register_type(MATERIALPROPERTYSOLDERSOUNDDATA_TYPE_INFO);
    registry.register_type(MATERIALPROPERTYSOLDERSOUNDDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERAIMINGCONSTRAINTSDATA_TYPE_INFO);
    registry.register_type(SOLDIERAIMINGCONSTRAINTSDATA_ARRAY_TYPE_INFO);
    registry.register_type(EYERECOILNETSTATE_TYPE_INFO);
    registry.register_type(EYERECOILNETSTATE_ARRAY_TYPE_INFO);
    registry.register_type(EYESWAYNETSTATE_TYPE_INFO);
    registry.register_type(EYESWAYNETSTATE_ARRAY_TYPE_INFO);
    registry.register_type(EYEANGLENETSTATE_TYPE_INFO);
    registry.register_type(EYEANGLENETSTATE_ARRAY_TYPE_INFO);
    registry.register_type(PICKUPPHYSICSCOMPONENTDATA_TYPE_INFO);
    registry.register_type(PICKUPPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(NETWORKPICKUPWEAPONFROMKITMESSAGE_TYPE_INFO);
    registry.register_type(DYNAMICWEAPONPICKUPENTITYDATA_TYPE_INFO);
    registry.register_type(DYNAMICWEAPONPICKUPENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(DYNAMICWEAPONPICKUPSLOTDATA_TYPE_INFO);
    registry.register_type(DYNAMICWEAPONPICKUPSLOTDATA_ARRAY_TYPE_INFO);
    registry.register_type(PICKUPENTITYASSET_TYPE_INFO);
    registry.register_type(PICKUPENTITYASSET_ARRAY_TYPE_INFO);
    registry.register_type(KITPICKUPENTITYDATA_TYPE_INFO);
    registry.register_type(KITPICKUPENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONUNLOCKPICKUPENTITYDATA_TYPE_INFO);
    registry.register_type(WEAPONUNLOCKPICKUPENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONUNLOCKPICKUPDATA_TYPE_INFO);
    registry.register_type(WEAPONUNLOCKPICKUPDATA_ARRAY_TYPE_INFO);
    registry.register_type(PICKUPENTITYDATA_TYPE_INFO);
    registry.register_type(PICKUPENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONSNOPICKUPNETSTATE_TYPE_INFO);
    registry.register_type(WEAPONSNOPICKUPNETSTATE_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONSPICKUPNETSTATE_TYPE_INFO);
    registry.register_type(WEAPONSPICKUPNETSTATE_ARRAY_TYPE_INFO);
    registry.register_type(PICKUPPLAYERENUM_TYPE_INFO);
    registry.register_type(PICKUPPLAYERENUM_ARRAY_TYPE_INFO);
    registry.register_type(NETWORKEDSPECIALDEATHPARAMETERS_TYPE_INFO);
    registry.register_type(NETWORKEDSPECIALDEATHPARAMETERS_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONSTATEENTITYDATA_TYPE_INFO);
    registry.register_type(WEAPONSTATEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERWEAPONSOCKETENTITYDATA_TYPE_INFO);
    registry.register_type(SOLDIERWEAPONSOCKETENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(STATEEVENTGATEENTITYDATA_TYPE_INFO);
    registry.register_type(STATEEVENTGATEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(EVENTGATESTATE_TYPE_INFO);
    registry.register_type(EVENTGATESTATE_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERLOOKATENTITYDATA_TYPE_INFO);
    registry.register_type(PLAYERLOOKATENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(HITREACTIONCOMPONENTDATA_TYPE_INFO);
    registry.register_type(HITREACTIONCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(HITREACTIONSETTINGS_TYPE_INFO);
    registry.register_type(HITREACTIONSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(HITREACTIONCOMPONENTBINDING_TYPE_INFO);
    registry.register_type(HITREACTIONCOMPONENTBINDING_ARRAY_TYPE_INFO);
    registry.register_type(AIHITREACTIONANIMATIONTYPE_TYPE_INFO);
    registry.register_type(AIHITREACTIONANIMATIONTYPE_ARRAY_TYPE_INFO);
    registry.register_type(FACEPOSERCOMPONENTDATA_TYPE_INFO);
    registry.register_type(FACEPOSERCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATECORRECTEDCHANNELCHANGEMESSAGE_TYPE_INFO);
    registry.register_type(CORRECTEDCHANNELCHANGELIST_TYPE_INFO);
    registry.register_type(CORRECTEDCHANNELCHANGELIST_ARRAY_TYPE_INFO);
    registry.register_type(CORRECTEDCHANNELCHANGE_TYPE_INFO);
    registry.register_type(CORRECTEDCHANNELCHANGE_ARRAY_TYPE_INFO);
    registry.register_type(CORRECTEDVEC3CHANNELCHANGE_TYPE_INFO);
    registry.register_type(CORRECTEDVEC3CHANNELCHANGE_ARRAY_TYPE_INFO);
    registry.register_type(CORRECTEDFLOATCHANNELCHANGE_TYPE_INFO);
    registry.register_type(CORRECTEDFLOATCHANNELCHANGE_ARRAY_TYPE_INFO);
    registry.register_type(CORRECTEDINTCHANNELCHANGE_TYPE_INFO);
    registry.register_type(CORRECTEDINTCHANNELCHANGE_ARRAY_TYPE_INFO);
    registry.register_type(CORRECTEDBOOLCHANNELCHANGE_TYPE_INFO);
    registry.register_type(CORRECTEDBOOLCHANNELCHANGE_ARRAY_TYPE_INFO);
    registry.register_type(CORRECTEDTRANSFORMCHANNELCHANGE_TYPE_INFO);
    registry.register_type(CORRECTEDTRANSFORMCHANNELCHANGE_ARRAY_TYPE_INFO);
    registry.register_type(CORRECTEDINTERACTIONTRANSFORMCHANGE_TYPE_INFO);
    registry.register_type(CORRECTEDINTERACTIONTRANSFORMCHANGE_ARRAY_TYPE_INFO);
    registry.register_type(CORRECTEDCHANNELCHANGECOMMON_TYPE_INFO);
    registry.register_type(CORRECTEDCHANNELCHANGECOMMON_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEANDREQUIREDDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEANDREQUIREDDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEORREQUIREDDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEORREQUIREDDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEFLOATREQUIREDCHANNELVALUEDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEFLOATREQUIREDCHANNELVALUEDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEINTREQUIREDCHANNELVALUEDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEINTREQUIREDCHANNELVALUEDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEBOOLREQUIREDCHANNELVALUEDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEBOOLREQUIREDCHANNELVALUEDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEREQUIREDCHANNELVALUEDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEREQUIREDCHANNELVALUEDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEPUBLICCHANNELMAPPINGTABLE_TYPE_INFO);
    registry.register_type(CHARACTERSTATEPUBLICCHANNELMAPPINGTABLE_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEPUBLICVEC3CHANNELMAPPING_TYPE_INFO);
    registry.register_type(CHARACTERSTATEPUBLICVEC3CHANNELMAPPING_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEPUBLICBOOLCHANNELMAPPING_TYPE_INFO);
    registry.register_type(CHARACTERSTATEPUBLICBOOLCHANNELMAPPING_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEPUBLICINTCHANNELMAPPING_TYPE_INFO);
    registry.register_type(CHARACTERSTATEPUBLICINTCHANNELMAPPING_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEPUBLICFLOATCHANNELMAPPING_TYPE_INFO);
    registry.register_type(CHARACTERSTATEPUBLICFLOATCHANNELMAPPING_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEPUBLICTRANSFORMCHANNELMAPPING_TYPE_INFO);
    registry.register_type(CHARACTERSTATEPUBLICTRANSFORMCHANNELMAPPING_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEPUBLICCHANNELMAPPING_TYPE_INFO);
    registry.register_type(CHARACTERSTATEPUBLICCHANNELMAPPING_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEPUBLICCHANNELLISTDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEPUBLICCHANNELLISTDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEPUBLICBOOLCHANNELDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEPUBLICBOOLCHANNELDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEPUBLICINTCHANNELDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEPUBLICINTCHANNELDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEPUBLICFLOATCHANNELDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEPUBLICFLOATCHANNELDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEPUBLICVEC3CHANNELDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEPUBLICVEC3CHANNELDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEPUBLICTRANSFORMCHANNELDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEPUBLICTRANSFORMCHANNELDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEPUBLICCHANNELDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEPUBLICCHANNELDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHANNELTABLEDATA_TYPE_INFO);
    registry.register_type(CHANNELTABLEDATA_ARRAY_TYPE_INFO);
    registry.register_type(RESETEVERYFRAMEDATA_TYPE_INFO);
    registry.register_type(RESETEVERYFRAMEDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHANNELDATATYPE_TYPE_INFO);
    registry.register_type(CHANNELDATATYPE_ARRAY_TYPE_INFO);
    registry.register_type(CHANNELSETDATA_TYPE_INFO);
    registry.register_type(CHANNELSETDATA_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMCHANNELDATA_TYPE_INFO);
    registry.register_type(TRANSFORMCHANNELDATA_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMCHANNELMIRRORTOGAMESTATEMODE_TYPE_INFO);
    registry.register_type(TRANSFORMCHANNELMIRRORTOGAMESTATEMODE_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMNETWORKQUANTIZATION_TYPE_INFO);
    registry.register_type(TRANSFORMNETWORKQUANTIZATION_ARRAY_TYPE_INFO);
    registry.register_type(VEC3CHANNELDATA_TYPE_INFO);
    registry.register_type(VEC3CHANNELDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEC3NETWORKQUANTIZATION_TYPE_INFO);
    registry.register_type(VEC3NETWORKQUANTIZATION_ARRAY_TYPE_INFO);
    registry.register_type(FLOATCHANNELDATA_TYPE_INFO);
    registry.register_type(FLOATCHANNELDATA_ARRAY_TYPE_INFO);
    registry.register_type(FLOATNETWORKQUANTIZATION_TYPE_INFO);
    registry.register_type(FLOATNETWORKQUANTIZATION_ARRAY_TYPE_INFO);
    registry.register_type(INTCHANNELDATA_TYPE_INFO);
    registry.register_type(INTCHANNELDATA_ARRAY_TYPE_INFO);
    registry.register_type(INTNETWORKQUANTIZATION_TYPE_INFO);
    registry.register_type(INTNETWORKQUANTIZATION_ARRAY_TYPE_INFO);
    registry.register_type(BOOLCHANNELDATA_TYPE_INFO);
    registry.register_type(BOOLCHANNELDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHANNELDATA_TYPE_INFO);
    registry.register_type(CHANNELDATA_ARRAY_TYPE_INFO);
    registry.register_type(IEXTERNALCHARACTERSTATECONTROLCOMPONENTDATA_TYPE_INFO);
    registry.register_type(IEXTERNALCHARACTERSTATECONTROLCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(BLOCKAIMASSISTENTITYDATA_TYPE_INFO);
    registry.register_type(BLOCKAIMASSISTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(BLOCKAIMASSISTDATA_TYPE_INFO);
    registry.register_type(BLOCKAIMASSISTDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERCUSTOMIZATIONASSET_TYPE_INFO);
    registry.register_type(SOLDIERCUSTOMIZATIONASSET_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERWEAPONSOCKETOBJECTDATA_TYPE_INFO);
    registry.register_type(SOLDIERWEAPONSOCKETOBJECTDATA_ARRAY_TYPE_INFO);
    registry.register_type(NETWORKPLAYERSELECTEDWEAPONMESSAGE_TYPE_INFO);
    registry.register_type(COVERPEEKENTITYDATA_TYPE_INFO);
    registry.register_type(COVERPEEKENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COVERPEEKBINDING_TYPE_INFO);
    registry.register_type(COVERPEEKBINDING_ARRAY_TYPE_INFO);
    registry.register_type(ANIMATIONTURRETROTATIONCOMPONENTDATA_TYPE_INFO);
    registry.register_type(ANIMATIONTURRETROTATIONCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(PHANTOMCOMPONENTDATA_TYPE_INFO);
    registry.register_type(PHANTOMCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(RAGDOLLCOMPONENTDATA_TYPE_INFO);
    registry.register_type(RAGDOLLCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(RAGDOLLBINDING_TYPE_INFO);
    registry.register_type(RAGDOLLBINDING_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERFOOTPLANTEFFECTCOMPONENTDATA_TYPE_INFO);
    registry.register_type(SOLDIERFOOTPLANTEFFECTCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(OCCLUTIONQUERYCOMPONENTDATA_TYPE_INFO);
    registry.register_type(OCCLUTIONQUERYCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(BLOCKAIMASSISTCOMPONENTDATA_TYPE_INFO);
    registry.register_type(BLOCKAIMASSISTCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(ENTRYAIMASSISTTARGETOPTIONSCOMPONENTDATA_TYPE_INFO);
    registry.register_type(ENTRYAIMASSISTTARGETOPTIONSCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIMASSISTNODESNAPPOINTCOMPONENTDATA_TYPE_INFO);
    registry.register_type(AIMASSISTNODESNAPPOINTCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIMASSISTNODECOMPONENTDATA_TYPE_INFO);
    registry.register_type(AIMASSISTNODECOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERBREATHCONTROLCOMPONENTDATA_TYPE_INFO);
    registry.register_type(SOLDIERBREATHCONTROLCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERCUSTOMIZATIONCOMPONENTDATA_TYPE_INFO);
    registry.register_type(SOLDIERCUSTOMIZATIONCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSOCKETLISTASSET_TYPE_INFO);
    registry.register_type(CHARACTERSOCKETLISTASSET_ARRAY_TYPE_INFO);
    registry.register_type(SOCKETDATA_TYPE_INFO);
    registry.register_type(SOCKETDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOCKETVISIBILITY_TYPE_INFO);
    registry.register_type(SOCKETVISIBILITY_ARRAY_TYPE_INFO);
    registry.register_type(SOCKETGROUP_TYPE_INFO);
    registry.register_type(SOCKETGROUP_ARRAY_TYPE_INFO);
    registry.register_type(SOCKETOBJECTDATABASE_TYPE_INFO);
    registry.register_type(SOCKETOBJECTDATABASE_ARRAY_TYPE_INFO);
    registry.register_type(MOVEMENTCOMPONENTDATA_TYPE_INFO);
    registry.register_type(MOVEMENTCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(MOVETOTARGETDATA_TYPE_INFO);
    registry.register_type(MOVETOTARGETDATA_ARRAY_TYPE_INFO);
    registry.register_type(MOVEMENTCOMPONENTSHAREDBINDING_TYPE_INFO);
    registry.register_type(MOVEMENTCOMPONENTSHAREDBINDING_ARRAY_TYPE_INFO);
    registry.register_type(MOVEMENTCOMPONENTBINDING_TYPE_INFO);
    registry.register_type(MOVEMENTCOMPONENTBINDING_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERCAMERACOMPONENTDATA_TYPE_INFO);
    registry.register_type(SOLDIERCAMERACOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(CAMERACOMMONBINDING_TYPE_INFO);
    registry.register_type(CAMERACOMMONBINDING_ARRAY_TYPE_INFO);
    registry.register_type(CAMERA1PBINDING_TYPE_INFO);
    registry.register_type(CAMERA1PBINDING_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERBODYCOMPONENTDATA_TYPE_INFO);
    registry.register_type(SOLDIERBODYCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(BONECOLLISIONCOMPONENTDATA_TYPE_INFO);
    registry.register_type(BONECOLLISIONCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERENTRYCOMPONENTDATA_TYPE_INFO);
    registry.register_type(SOLDIERENTRYCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIMINGWORLDSPACELOCKEFFICIENCYDATA_TYPE_INFO);
    registry.register_type(AIMINGWORLDSPACELOCKEFFICIENCYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERTHIRDPERSONCAMERADATA_TYPE_INFO);
    registry.register_type(SOLDIERTHIRDPERSONCAMERADATA_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERFIRSTPERSONCAMERADATA_TYPE_INFO);
    registry.register_type(SOLDIERFIRSTPERSONCAMERADATA_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERCAMERADATA_TYPE_INFO);
    registry.register_type(SOLDIERCAMERADATA_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERWEAPONASSET_TYPE_INFO);
    registry.register_type(SOLDIERWEAPONASSET_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERASSET_TYPE_INFO);
    registry.register_type(SOLDIERASSET_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERWEAPONBLUEPRINT_TYPE_INFO);
    registry.register_type(SOLDIERWEAPONBLUEPRINT_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERBLUEPRINT_TYPE_INFO);
    registry.register_type(SOLDIERBLUEPRINT_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERHEALTHMODULEBINDING_TYPE_INFO);
    registry.register_type(SOLDIERHEALTHMODULEBINDING_ARRAY_TYPE_INFO);
    registry.register_type(AIDEATHREACTIONANIMATIONTYPE_TYPE_INFO);
    registry.register_type(AIDEATHREACTIONANIMATIONTYPE_ARRAY_TYPE_INFO);
    registry.register_type(ANIMATEDWEAPONBINDING_TYPE_INFO);
    registry.register_type(ANIMATEDWEAPONBINDING_ARRAY_TYPE_INFO);
    registry.register_type(ANIMATEDSTATICWEAPONBINDING_TYPE_INFO);
    registry.register_type(ANIMATEDSTATICWEAPONBINDING_ARRAY_TYPE_INFO);
    registry.register_type(ANIMATED3PONLYWEAPONBINDING_TYPE_INFO);
    registry.register_type(ANIMATED3PONLYWEAPONBINDING_ARRAY_TYPE_INFO);
    registry.register_type(ANIMATED1PONLYWEAPONBINDING_TYPE_INFO);
    registry.register_type(ANIMATED1PONLYWEAPONBINDING_ARRAY_TYPE_INFO);
    registry.register_type(AIMINGSIMULATIONENTITYDATA_TYPE_INFO);
    registry.register_type(AIMINGSIMULATIONENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIMINGSCALEDATAPROVIDERENTITYDATA_TYPE_INFO);
    registry.register_type(AIMINGSCALEDATAPROVIDERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIMINGSCALEDATA_TYPE_INFO);
    registry.register_type(AIMINGSCALEDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIMINGANGULARSPEEDCONSTRAINTDATAPROVIDERENTITYDATA_TYPE_INFO);
    registry.register_type(AIMINGANGULARSPEEDCONSTRAINTDATAPROVIDERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIMINGANGULARSPEEDCONSTRAINTDATA_TYPE_INFO);
    registry.register_type(AIMINGANGULARSPEEDCONSTRAINTDATA_ARRAY_TYPE_INFO);
    registry.register_type(REPLICATEDAIMENTITYDATA_TYPE_INFO);
    registry.register_type(REPLICATEDAIMENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SCHEMATICSAIMENTITYDATA_TYPE_INFO);
    registry.register_type(SCHEMATICSAIMENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIMENTITYDATA_TYPE_INFO);
    registry.register_type(AIMENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIMENTITYBASEDATA_TYPE_INFO);
    registry.register_type(AIMENTITYBASEDATA_ARRAY_TYPE_INFO);
}

#[derive(Clone, Debug, Default)]
pub struct ZeroingWeaponData {
    pub _glacier_base: super::weapon_shared::WeaponData,
}

pub trait ZeroingWeaponDataTrait: super::weapon_shared::WeaponDataTrait {
}

impl ZeroingWeaponDataTrait for ZeroingWeaponData {
}

impl super::weapon_shared::WeaponDataTrait for ZeroingWeaponData {
    fn show_laser_painted_vehicles(&self) -> &bool {
        self._glacier_base.show_laser_painted_vehicles()
    }
    fn show_laser_painted_vehicles_mut(&mut self) -> &mut bool {
        self._glacier_base.show_laser_painted_vehicles_mut()
    }
    fn apply_power_to_speed(&self) -> &bool {
        self._glacier_base.apply_power_to_speed()
    }
    fn apply_power_to_speed_mut(&mut self) -> &mut bool {
        self._glacier_base.apply_power_to_speed_mut()
    }
}

impl super::gameplay_sim::ToolDataTrait for ZeroingWeaponData {
    fn is_always_active(&self) -> &bool {
        self._glacier_base.is_always_active()
    }
    fn is_always_active_mut(&mut self) -> &mut bool {
        self._glacier_base.is_always_active_mut()
    }
}

impl super::core::DataContainerTrait for ZeroingWeaponData {
}

pub static ZEROINGWEAPONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ZeroingWeaponData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::weapon_shared::WEAPONDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ZeroingWeaponData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(ZEROINGWEAPONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ZeroingWeaponData {
    fn type_info(&self) -> &'static TypeInfo {
        ZEROINGWEAPONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ZEROINGWEAPONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ZeroingWeaponData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("ZeroingWeaponData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WeaponZeroingComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub enabled: bool,
    pub cycle_input_action: i32,
}

pub trait WeaponZeroingComponentDataTrait: super::entity::GameComponentDataTrait {
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
    fn cycle_input_action(&self) -> &i32;
    fn cycle_input_action_mut(&mut self) -> &mut i32;
}

impl WeaponZeroingComponentDataTrait for WeaponZeroingComponentData {
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
    fn cycle_input_action(&self) -> &i32 {
        &self.cycle_input_action
    }
    fn cycle_input_action_mut(&mut self) -> &mut i32 {
        &mut self.cycle_input_action
    }
}

impl super::entity::GameComponentDataTrait for WeaponZeroingComponentData {
}

impl super::entity::ComponentDataTrait for WeaponZeroingComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for WeaponZeroingComponentData {
}

impl super::core::DataBusPeerTrait for WeaponZeroingComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for WeaponZeroingComponentData {
}

impl super::core::DataContainerTrait for WeaponZeroingComponentData {
}

pub static WEAPONZEROINGCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponZeroingComponentData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WeaponZeroingComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WeaponZeroingComponentData, enabled),
            },
            FieldInfoData {
                name: "CycleInputAction",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(WeaponZeroingComponentData, cycle_input_action),
            },
        ],
    }),
    array_type: Some(WEAPONZEROINGCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for WeaponZeroingComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        WEAPONZEROINGCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WEAPONZEROINGCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponZeroingComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("WeaponZeroingComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WeaponZeroingModifier {
    pub _glacier_base: super::weapon_shared::WeaponModifierBase,
    pub modes: Vec<WeaponZeroingEntry>,
}

pub trait WeaponZeroingModifierTrait: super::weapon_shared::WeaponModifierBaseTrait {
    fn modes(&self) -> &Vec<WeaponZeroingEntry>;
    fn modes_mut(&mut self) -> &mut Vec<WeaponZeroingEntry>;
}

impl WeaponZeroingModifierTrait for WeaponZeroingModifier {
    fn modes(&self) -> &Vec<WeaponZeroingEntry> {
        &self.modes
    }
    fn modes_mut(&mut self) -> &mut Vec<WeaponZeroingEntry> {
        &mut self.modes
    }
}

impl super::weapon_shared::WeaponModifierBaseTrait for WeaponZeroingModifier {
    fn apply_order(&self) -> &i32 {
        self._glacier_base.apply_order()
    }
    fn apply_order_mut(&mut self) -> &mut i32 {
        self._glacier_base.apply_order_mut()
    }
    fn dynamic_update_enabled(&self) -> &bool {
        self._glacier_base.dynamic_update_enabled()
    }
    fn dynamic_update_enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.dynamic_update_enabled_mut()
    }
}

impl super::core::DataContainerTrait for WeaponZeroingModifier {
}

pub static WEAPONZEROINGMODIFIER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponZeroingModifier",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::weapon_shared::WEAPONMODIFIERBASE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WeaponZeroingModifier as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Modes",
                flags: MemberInfoFlags::new(144),
                field_type: "WeaponZeroingEntry-Array",
                rust_offset: offset_of!(WeaponZeroingModifier, modes),
            },
        ],
    }),
    array_type: Some(WEAPONZEROINGMODIFIER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WeaponZeroingModifier {
    fn type_info(&self) -> &'static TypeInfo {
        WEAPONZEROINGMODIFIER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WEAPONZEROINGMODIFIER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponZeroingModifier-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("WeaponZeroingModifier"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WeaponZeroingEntry {
    pub distance: f32,
    pub angle: f32,
}

pub trait WeaponZeroingEntryTrait: TypeObject {
    fn distance(&self) -> &f32;
    fn distance_mut(&mut self) -> &mut f32;
    fn angle(&self) -> &f32;
    fn angle_mut(&mut self) -> &mut f32;
}

impl WeaponZeroingEntryTrait for WeaponZeroingEntry {
    fn distance(&self) -> &f32 {
        &self.distance
    }
    fn distance_mut(&mut self) -> &mut f32 {
        &mut self.distance
    }
    fn angle(&self) -> &f32 {
        &self.angle
    }
    fn angle_mut(&mut self) -> &mut f32 {
        &mut self.angle
    }
}

pub static WEAPONZEROINGENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponZeroingEntry",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WeaponZeroingEntry as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Distance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WeaponZeroingEntry, distance),
            },
            FieldInfoData {
                name: "Angle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WeaponZeroingEntry, angle),
            },
        ],
    }),
    array_type: Some(WEAPONZEROINGENTRY_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for WeaponZeroingEntry {
    fn type_info(&self) -> &'static TypeInfo {
        WEAPONZEROINGENTRY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static WEAPONZEROINGENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponZeroingEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("WeaponZeroingEntry"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GunSwayData {
    pub _glacier_base: super::weapon_shared::WeaponSwayData,
    pub dispersion: Vec<GunSwayDispersionData>,
    pub recoil: Vec<GunSwayRecoilData>,
    pub stance_transition_dispersion: Vec<GunSwayStanceTransition>,
    pub suppression_dispersion_modifiers: Vec<GunSwayDispersionModData>,
    pub suppression_recoil_modifiers: Vec<GunSwayRecoilModData>,
    pub stand: GunSwayStandData,
    pub crouch: GunSwayCrouchProneData,
    pub prone: GunSwayCrouchProneData,
    pub prone_to_crouch: GunSwayStanceTransition,
    pub prone_to_stand: GunSwayStanceTransition,
    pub crouch_to_prone: GunSwayStanceTransition,
    pub crouch_to_stand: GunSwayStanceTransition,
    pub stand_to_prone: GunSwayStanceTransition,
    pub stand_to_crouch: GunSwayStanceTransition,
    pub suppression_modifier_unzoomed: GunSwayStanceZoomModifierData,
    pub suppression_modifier_zoomed: GunSwayStanceZoomModifierData,
    pub modifier_unlocks: Vec<GunSwayModifierUnlock>,
    pub shooting_recoil_decrease_scale: f32,
    pub first_shot_no_zoom_dispersion_multiplier: f32,
    pub first_shot_zoom_dispersion_multiplier: f32,
    pub first_shot_recoil_multiplier: f32,
    pub camera_recoil_when_zoomed: bool,
    pub power_of_dispersion_random: f32,
    pub minimum_power_required_to_fire: f32,
    pub camera_recoil: Option<Arc<Mutex<dyn CameraRecoilDataTrait>>>,
}

pub trait GunSwayDataTrait: super::weapon_shared::WeaponSwayDataTrait {
    fn dispersion(&self) -> &Vec<GunSwayDispersionData>;
    fn dispersion_mut(&mut self) -> &mut Vec<GunSwayDispersionData>;
    fn recoil(&self) -> &Vec<GunSwayRecoilData>;
    fn recoil_mut(&mut self) -> &mut Vec<GunSwayRecoilData>;
    fn stance_transition_dispersion(&self) -> &Vec<GunSwayStanceTransition>;
    fn stance_transition_dispersion_mut(&mut self) -> &mut Vec<GunSwayStanceTransition>;
    fn suppression_dispersion_modifiers(&self) -> &Vec<GunSwayDispersionModData>;
    fn suppression_dispersion_modifiers_mut(&mut self) -> &mut Vec<GunSwayDispersionModData>;
    fn suppression_recoil_modifiers(&self) -> &Vec<GunSwayRecoilModData>;
    fn suppression_recoil_modifiers_mut(&mut self) -> &mut Vec<GunSwayRecoilModData>;
    fn stand(&self) -> &GunSwayStandData;
    fn stand_mut(&mut self) -> &mut GunSwayStandData;
    fn crouch(&self) -> &GunSwayCrouchProneData;
    fn crouch_mut(&mut self) -> &mut GunSwayCrouchProneData;
    fn prone(&self) -> &GunSwayCrouchProneData;
    fn prone_mut(&mut self) -> &mut GunSwayCrouchProneData;
    fn prone_to_crouch(&self) -> &GunSwayStanceTransition;
    fn prone_to_crouch_mut(&mut self) -> &mut GunSwayStanceTransition;
    fn prone_to_stand(&self) -> &GunSwayStanceTransition;
    fn prone_to_stand_mut(&mut self) -> &mut GunSwayStanceTransition;
    fn crouch_to_prone(&self) -> &GunSwayStanceTransition;
    fn crouch_to_prone_mut(&mut self) -> &mut GunSwayStanceTransition;
    fn crouch_to_stand(&self) -> &GunSwayStanceTransition;
    fn crouch_to_stand_mut(&mut self) -> &mut GunSwayStanceTransition;
    fn stand_to_prone(&self) -> &GunSwayStanceTransition;
    fn stand_to_prone_mut(&mut self) -> &mut GunSwayStanceTransition;
    fn stand_to_crouch(&self) -> &GunSwayStanceTransition;
    fn stand_to_crouch_mut(&mut self) -> &mut GunSwayStanceTransition;
    fn suppression_modifier_unzoomed(&self) -> &GunSwayStanceZoomModifierData;
    fn suppression_modifier_unzoomed_mut(&mut self) -> &mut GunSwayStanceZoomModifierData;
    fn suppression_modifier_zoomed(&self) -> &GunSwayStanceZoomModifierData;
    fn suppression_modifier_zoomed_mut(&mut self) -> &mut GunSwayStanceZoomModifierData;
    fn modifier_unlocks(&self) -> &Vec<GunSwayModifierUnlock>;
    fn modifier_unlocks_mut(&mut self) -> &mut Vec<GunSwayModifierUnlock>;
    fn shooting_recoil_decrease_scale(&self) -> &f32;
    fn shooting_recoil_decrease_scale_mut(&mut self) -> &mut f32;
    fn first_shot_no_zoom_dispersion_multiplier(&self) -> &f32;
    fn first_shot_no_zoom_dispersion_multiplier_mut(&mut self) -> &mut f32;
    fn first_shot_zoom_dispersion_multiplier(&self) -> &f32;
    fn first_shot_zoom_dispersion_multiplier_mut(&mut self) -> &mut f32;
    fn first_shot_recoil_multiplier(&self) -> &f32;
    fn first_shot_recoil_multiplier_mut(&mut self) -> &mut f32;
    fn camera_recoil_when_zoomed(&self) -> &bool;
    fn camera_recoil_when_zoomed_mut(&mut self) -> &mut bool;
    fn power_of_dispersion_random(&self) -> &f32;
    fn power_of_dispersion_random_mut(&mut self) -> &mut f32;
    fn minimum_power_required_to_fire(&self) -> &f32;
    fn minimum_power_required_to_fire_mut(&mut self) -> &mut f32;
    fn camera_recoil(&self) -> &Option<Arc<Mutex<dyn CameraRecoilDataTrait>>>;
    fn camera_recoil_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CameraRecoilDataTrait>>>;
}

impl GunSwayDataTrait for GunSwayData {
    fn dispersion(&self) -> &Vec<GunSwayDispersionData> {
        &self.dispersion
    }
    fn dispersion_mut(&mut self) -> &mut Vec<GunSwayDispersionData> {
        &mut self.dispersion
    }
    fn recoil(&self) -> &Vec<GunSwayRecoilData> {
        &self.recoil
    }
    fn recoil_mut(&mut self) -> &mut Vec<GunSwayRecoilData> {
        &mut self.recoil
    }
    fn stance_transition_dispersion(&self) -> &Vec<GunSwayStanceTransition> {
        &self.stance_transition_dispersion
    }
    fn stance_transition_dispersion_mut(&mut self) -> &mut Vec<GunSwayStanceTransition> {
        &mut self.stance_transition_dispersion
    }
    fn suppression_dispersion_modifiers(&self) -> &Vec<GunSwayDispersionModData> {
        &self.suppression_dispersion_modifiers
    }
    fn suppression_dispersion_modifiers_mut(&mut self) -> &mut Vec<GunSwayDispersionModData> {
        &mut self.suppression_dispersion_modifiers
    }
    fn suppression_recoil_modifiers(&self) -> &Vec<GunSwayRecoilModData> {
        &self.suppression_recoil_modifiers
    }
    fn suppression_recoil_modifiers_mut(&mut self) -> &mut Vec<GunSwayRecoilModData> {
        &mut self.suppression_recoil_modifiers
    }
    fn stand(&self) -> &GunSwayStandData {
        &self.stand
    }
    fn stand_mut(&mut self) -> &mut GunSwayStandData {
        &mut self.stand
    }
    fn crouch(&self) -> &GunSwayCrouchProneData {
        &self.crouch
    }
    fn crouch_mut(&mut self) -> &mut GunSwayCrouchProneData {
        &mut self.crouch
    }
    fn prone(&self) -> &GunSwayCrouchProneData {
        &self.prone
    }
    fn prone_mut(&mut self) -> &mut GunSwayCrouchProneData {
        &mut self.prone
    }
    fn prone_to_crouch(&self) -> &GunSwayStanceTransition {
        &self.prone_to_crouch
    }
    fn prone_to_crouch_mut(&mut self) -> &mut GunSwayStanceTransition {
        &mut self.prone_to_crouch
    }
    fn prone_to_stand(&self) -> &GunSwayStanceTransition {
        &self.prone_to_stand
    }
    fn prone_to_stand_mut(&mut self) -> &mut GunSwayStanceTransition {
        &mut self.prone_to_stand
    }
    fn crouch_to_prone(&self) -> &GunSwayStanceTransition {
        &self.crouch_to_prone
    }
    fn crouch_to_prone_mut(&mut self) -> &mut GunSwayStanceTransition {
        &mut self.crouch_to_prone
    }
    fn crouch_to_stand(&self) -> &GunSwayStanceTransition {
        &self.crouch_to_stand
    }
    fn crouch_to_stand_mut(&mut self) -> &mut GunSwayStanceTransition {
        &mut self.crouch_to_stand
    }
    fn stand_to_prone(&self) -> &GunSwayStanceTransition {
        &self.stand_to_prone
    }
    fn stand_to_prone_mut(&mut self) -> &mut GunSwayStanceTransition {
        &mut self.stand_to_prone
    }
    fn stand_to_crouch(&self) -> &GunSwayStanceTransition {
        &self.stand_to_crouch
    }
    fn stand_to_crouch_mut(&mut self) -> &mut GunSwayStanceTransition {
        &mut self.stand_to_crouch
    }
    fn suppression_modifier_unzoomed(&self) -> &GunSwayStanceZoomModifierData {
        &self.suppression_modifier_unzoomed
    }
    fn suppression_modifier_unzoomed_mut(&mut self) -> &mut GunSwayStanceZoomModifierData {
        &mut self.suppression_modifier_unzoomed
    }
    fn suppression_modifier_zoomed(&self) -> &GunSwayStanceZoomModifierData {
        &self.suppression_modifier_zoomed
    }
    fn suppression_modifier_zoomed_mut(&mut self) -> &mut GunSwayStanceZoomModifierData {
        &mut self.suppression_modifier_zoomed
    }
    fn modifier_unlocks(&self) -> &Vec<GunSwayModifierUnlock> {
        &self.modifier_unlocks
    }
    fn modifier_unlocks_mut(&mut self) -> &mut Vec<GunSwayModifierUnlock> {
        &mut self.modifier_unlocks
    }
    fn shooting_recoil_decrease_scale(&self) -> &f32 {
        &self.shooting_recoil_decrease_scale
    }
    fn shooting_recoil_decrease_scale_mut(&mut self) -> &mut f32 {
        &mut self.shooting_recoil_decrease_scale
    }
    fn first_shot_no_zoom_dispersion_multiplier(&self) -> &f32 {
        &self.first_shot_no_zoom_dispersion_multiplier
    }
    fn first_shot_no_zoom_dispersion_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.first_shot_no_zoom_dispersion_multiplier
    }
    fn first_shot_zoom_dispersion_multiplier(&self) -> &f32 {
        &self.first_shot_zoom_dispersion_multiplier
    }
    fn first_shot_zoom_dispersion_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.first_shot_zoom_dispersion_multiplier
    }
    fn first_shot_recoil_multiplier(&self) -> &f32 {
        &self.first_shot_recoil_multiplier
    }
    fn first_shot_recoil_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.first_shot_recoil_multiplier
    }
    fn camera_recoil_when_zoomed(&self) -> &bool {
        &self.camera_recoil_when_zoomed
    }
    fn camera_recoil_when_zoomed_mut(&mut self) -> &mut bool {
        &mut self.camera_recoil_when_zoomed
    }
    fn power_of_dispersion_random(&self) -> &f32 {
        &self.power_of_dispersion_random
    }
    fn power_of_dispersion_random_mut(&mut self) -> &mut f32 {
        &mut self.power_of_dispersion_random
    }
    fn minimum_power_required_to_fire(&self) -> &f32 {
        &self.minimum_power_required_to_fire
    }
    fn minimum_power_required_to_fire_mut(&mut self) -> &mut f32 {
        &mut self.minimum_power_required_to_fire
    }
    fn camera_recoil(&self) -> &Option<Arc<Mutex<dyn CameraRecoilDataTrait>>> {
        &self.camera_recoil
    }
    fn camera_recoil_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CameraRecoilDataTrait>>> {
        &mut self.camera_recoil
    }
}

impl super::weapon_shared::WeaponSwayDataTrait for GunSwayData {
}

impl super::core::DataContainerTrait for GunSwayData {
}

pub static GUNSWAYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GunSwayData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::weapon_shared::WEAPONSWAYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GunSwayData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Dispersion",
                flags: MemberInfoFlags::new(144),
                field_type: "GunSwayDispersionData-Array",
                rust_offset: offset_of!(GunSwayData, dispersion),
            },
            FieldInfoData {
                name: "Recoil",
                flags: MemberInfoFlags::new(144),
                field_type: "GunSwayRecoilData-Array",
                rust_offset: offset_of!(GunSwayData, recoil),
            },
            FieldInfoData {
                name: "StanceTransitionDispersion",
                flags: MemberInfoFlags::new(144),
                field_type: "GunSwayStanceTransition-Array",
                rust_offset: offset_of!(GunSwayData, stance_transition_dispersion),
            },
            FieldInfoData {
                name: "SuppressionDispersionModifiers",
                flags: MemberInfoFlags::new(144),
                field_type: "GunSwayDispersionModData-Array",
                rust_offset: offset_of!(GunSwayData, suppression_dispersion_modifiers),
            },
            FieldInfoData {
                name: "SuppressionRecoilModifiers",
                flags: MemberInfoFlags::new(144),
                field_type: "GunSwayRecoilModData-Array",
                rust_offset: offset_of!(GunSwayData, suppression_recoil_modifiers),
            },
            FieldInfoData {
                name: "Stand",
                flags: MemberInfoFlags::new(0),
                field_type: "GunSwayStandData",
                rust_offset: offset_of!(GunSwayData, stand),
            },
            FieldInfoData {
                name: "Crouch",
                flags: MemberInfoFlags::new(0),
                field_type: "GunSwayCrouchProneData",
                rust_offset: offset_of!(GunSwayData, crouch),
            },
            FieldInfoData {
                name: "Prone",
                flags: MemberInfoFlags::new(0),
                field_type: "GunSwayCrouchProneData",
                rust_offset: offset_of!(GunSwayData, prone),
            },
            FieldInfoData {
                name: "ProneToCrouch",
                flags: MemberInfoFlags::new(0),
                field_type: "GunSwayStanceTransition",
                rust_offset: offset_of!(GunSwayData, prone_to_crouch),
            },
            FieldInfoData {
                name: "ProneToStand",
                flags: MemberInfoFlags::new(0),
                field_type: "GunSwayStanceTransition",
                rust_offset: offset_of!(GunSwayData, prone_to_stand),
            },
            FieldInfoData {
                name: "CrouchToProne",
                flags: MemberInfoFlags::new(0),
                field_type: "GunSwayStanceTransition",
                rust_offset: offset_of!(GunSwayData, crouch_to_prone),
            },
            FieldInfoData {
                name: "CrouchToStand",
                flags: MemberInfoFlags::new(0),
                field_type: "GunSwayStanceTransition",
                rust_offset: offset_of!(GunSwayData, crouch_to_stand),
            },
            FieldInfoData {
                name: "StandToProne",
                flags: MemberInfoFlags::new(0),
                field_type: "GunSwayStanceTransition",
                rust_offset: offset_of!(GunSwayData, stand_to_prone),
            },
            FieldInfoData {
                name: "StandToCrouch",
                flags: MemberInfoFlags::new(0),
                field_type: "GunSwayStanceTransition",
                rust_offset: offset_of!(GunSwayData, stand_to_crouch),
            },
            FieldInfoData {
                name: "SuppressionModifierUnzoomed",
                flags: MemberInfoFlags::new(0),
                field_type: "GunSwayStanceZoomModifierData",
                rust_offset: offset_of!(GunSwayData, suppression_modifier_unzoomed),
            },
            FieldInfoData {
                name: "SuppressionModifierZoomed",
                flags: MemberInfoFlags::new(0),
                field_type: "GunSwayStanceZoomModifierData",
                rust_offset: offset_of!(GunSwayData, suppression_modifier_zoomed),
            },
            FieldInfoData {
                name: "ModifierUnlocks",
                flags: MemberInfoFlags::new(144),
                field_type: "GunSwayModifierUnlock-Array",
                rust_offset: offset_of!(GunSwayData, modifier_unlocks),
            },
            FieldInfoData {
                name: "ShootingRecoilDecreaseScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GunSwayData, shooting_recoil_decrease_scale),
            },
            FieldInfoData {
                name: "FirstShotNoZoomDispersionMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GunSwayData, first_shot_no_zoom_dispersion_multiplier),
            },
            FieldInfoData {
                name: "FirstShotZoomDispersionMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GunSwayData, first_shot_zoom_dispersion_multiplier),
            },
            FieldInfoData {
                name: "FirstShotRecoilMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GunSwayData, first_shot_recoil_multiplier),
            },
            FieldInfoData {
                name: "CameraRecoilWhenZoomed",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(GunSwayData, camera_recoil_when_zoomed),
            },
            FieldInfoData {
                name: "PowerOfDispersionRandom",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GunSwayData, power_of_dispersion_random),
            },
            FieldInfoData {
                name: "MinimumPowerRequiredToFire",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GunSwayData, minimum_power_required_to_fire),
            },
            FieldInfoData {
                name: "CameraRecoil",
                flags: MemberInfoFlags::new(0),
                field_type: "CameraRecoilData",
                rust_offset: offset_of!(GunSwayData, camera_recoil),
            },
        ],
    }),
    array_type: Some(GUNSWAYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for GunSwayData {
    fn type_info(&self) -> &'static TypeInfo {
        GUNSWAYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static GUNSWAYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GunSwayData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("GunSwayData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GunSwayModifierUnlock {
    pub unlock_asset_guid: glacier_util::guid::Guid,
    pub modifier: Option<Arc<Mutex<dyn GunSwayModifierDataTrait>>>,
}

pub trait GunSwayModifierUnlockTrait: TypeObject {
    fn unlock_asset_guid(&self) -> &glacier_util::guid::Guid;
    fn unlock_asset_guid_mut(&mut self) -> &mut glacier_util::guid::Guid;
    fn modifier(&self) -> &Option<Arc<Mutex<dyn GunSwayModifierDataTrait>>>;
    fn modifier_mut(&mut self) -> &mut Option<Arc<Mutex<dyn GunSwayModifierDataTrait>>>;
}

impl GunSwayModifierUnlockTrait for GunSwayModifierUnlock {
    fn unlock_asset_guid(&self) -> &glacier_util::guid::Guid {
        &self.unlock_asset_guid
    }
    fn unlock_asset_guid_mut(&mut self) -> &mut glacier_util::guid::Guid {
        &mut self.unlock_asset_guid
    }
    fn modifier(&self) -> &Option<Arc<Mutex<dyn GunSwayModifierDataTrait>>> {
        &self.modifier
    }
    fn modifier_mut(&mut self) -> &mut Option<Arc<Mutex<dyn GunSwayModifierDataTrait>>> {
        &mut self.modifier
    }
}

pub static GUNSWAYMODIFIERUNLOCK_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GunSwayModifierUnlock",
    flags: MemberInfoFlags::new(73),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GunSwayModifierUnlock as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "UnlockAssetGuid",
                flags: MemberInfoFlags::new(0),
                field_type: "Guid",
                rust_offset: offset_of!(GunSwayModifierUnlock, unlock_asset_guid),
            },
            FieldInfoData {
                name: "Modifier",
                flags: MemberInfoFlags::new(0),
                field_type: "GunSwayModifierData",
                rust_offset: offset_of!(GunSwayModifierUnlock, modifier),
            },
        ],
    }),
    array_type: Some(GUNSWAYMODIFIERUNLOCK_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for GunSwayModifierUnlock {
    fn type_info(&self) -> &'static TypeInfo {
        GUNSWAYMODIFIERUNLOCK_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static GUNSWAYMODIFIERUNLOCK_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GunSwayModifierUnlock-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("GunSwayModifierUnlock"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GunSwayModifierData {
    pub _glacier_base: super::core::Asset,
    pub dispersion_modifiers: Vec<GunSwayDispersionModData>,
    pub recoil_modifiers: Vec<GunSwayRecoilModData>,
    pub stand_zoom_modifier: GunSwayStanceZoomModifierData,
    pub stand_no_zoom_modifier: GunSwayStanceZoomModifierData,
    pub crouch_zoom_modifier: GunSwayStanceZoomModifierData,
    pub crouch_no_zoom_modifier: GunSwayStanceZoomModifierData,
    pub prone_zoom_modifier: GunSwayStanceZoomModifierData,
    pub prone_no_zoom_modifier: GunSwayStanceZoomModifierData,
    pub only_in_supported_shooting: bool,
    pub only_on_weapon_light_enabled: bool,
    pub dynamic_update_enabled: bool,
}

pub trait GunSwayModifierDataTrait: super::core::AssetTrait {
    fn dispersion_modifiers(&self) -> &Vec<GunSwayDispersionModData>;
    fn dispersion_modifiers_mut(&mut self) -> &mut Vec<GunSwayDispersionModData>;
    fn recoil_modifiers(&self) -> &Vec<GunSwayRecoilModData>;
    fn recoil_modifiers_mut(&mut self) -> &mut Vec<GunSwayRecoilModData>;
    fn stand_zoom_modifier(&self) -> &GunSwayStanceZoomModifierData;
    fn stand_zoom_modifier_mut(&mut self) -> &mut GunSwayStanceZoomModifierData;
    fn stand_no_zoom_modifier(&self) -> &GunSwayStanceZoomModifierData;
    fn stand_no_zoom_modifier_mut(&mut self) -> &mut GunSwayStanceZoomModifierData;
    fn crouch_zoom_modifier(&self) -> &GunSwayStanceZoomModifierData;
    fn crouch_zoom_modifier_mut(&mut self) -> &mut GunSwayStanceZoomModifierData;
    fn crouch_no_zoom_modifier(&self) -> &GunSwayStanceZoomModifierData;
    fn crouch_no_zoom_modifier_mut(&mut self) -> &mut GunSwayStanceZoomModifierData;
    fn prone_zoom_modifier(&self) -> &GunSwayStanceZoomModifierData;
    fn prone_zoom_modifier_mut(&mut self) -> &mut GunSwayStanceZoomModifierData;
    fn prone_no_zoom_modifier(&self) -> &GunSwayStanceZoomModifierData;
    fn prone_no_zoom_modifier_mut(&mut self) -> &mut GunSwayStanceZoomModifierData;
    fn only_in_supported_shooting(&self) -> &bool;
    fn only_in_supported_shooting_mut(&mut self) -> &mut bool;
    fn only_on_weapon_light_enabled(&self) -> &bool;
    fn only_on_weapon_light_enabled_mut(&mut self) -> &mut bool;
    fn dynamic_update_enabled(&self) -> &bool;
    fn dynamic_update_enabled_mut(&mut self) -> &mut bool;
}

impl GunSwayModifierDataTrait for GunSwayModifierData {
    fn dispersion_modifiers(&self) -> &Vec<GunSwayDispersionModData> {
        &self.dispersion_modifiers
    }
    fn dispersion_modifiers_mut(&mut self) -> &mut Vec<GunSwayDispersionModData> {
        &mut self.dispersion_modifiers
    }
    fn recoil_modifiers(&self) -> &Vec<GunSwayRecoilModData> {
        &self.recoil_modifiers
    }
    fn recoil_modifiers_mut(&mut self) -> &mut Vec<GunSwayRecoilModData> {
        &mut self.recoil_modifiers
    }
    fn stand_zoom_modifier(&self) -> &GunSwayStanceZoomModifierData {
        &self.stand_zoom_modifier
    }
    fn stand_zoom_modifier_mut(&mut self) -> &mut GunSwayStanceZoomModifierData {
        &mut self.stand_zoom_modifier
    }
    fn stand_no_zoom_modifier(&self) -> &GunSwayStanceZoomModifierData {
        &self.stand_no_zoom_modifier
    }
    fn stand_no_zoom_modifier_mut(&mut self) -> &mut GunSwayStanceZoomModifierData {
        &mut self.stand_no_zoom_modifier
    }
    fn crouch_zoom_modifier(&self) -> &GunSwayStanceZoomModifierData {
        &self.crouch_zoom_modifier
    }
    fn crouch_zoom_modifier_mut(&mut self) -> &mut GunSwayStanceZoomModifierData {
        &mut self.crouch_zoom_modifier
    }
    fn crouch_no_zoom_modifier(&self) -> &GunSwayStanceZoomModifierData {
        &self.crouch_no_zoom_modifier
    }
    fn crouch_no_zoom_modifier_mut(&mut self) -> &mut GunSwayStanceZoomModifierData {
        &mut self.crouch_no_zoom_modifier
    }
    fn prone_zoom_modifier(&self) -> &GunSwayStanceZoomModifierData {
        &self.prone_zoom_modifier
    }
    fn prone_zoom_modifier_mut(&mut self) -> &mut GunSwayStanceZoomModifierData {
        &mut self.prone_zoom_modifier
    }
    fn prone_no_zoom_modifier(&self) -> &GunSwayStanceZoomModifierData {
        &self.prone_no_zoom_modifier
    }
    fn prone_no_zoom_modifier_mut(&mut self) -> &mut GunSwayStanceZoomModifierData {
        &mut self.prone_no_zoom_modifier
    }
    fn only_in_supported_shooting(&self) -> &bool {
        &self.only_in_supported_shooting
    }
    fn only_in_supported_shooting_mut(&mut self) -> &mut bool {
        &mut self.only_in_supported_shooting
    }
    fn only_on_weapon_light_enabled(&self) -> &bool {
        &self.only_on_weapon_light_enabled
    }
    fn only_on_weapon_light_enabled_mut(&mut self) -> &mut bool {
        &mut self.only_on_weapon_light_enabled
    }
    fn dynamic_update_enabled(&self) -> &bool {
        &self.dynamic_update_enabled
    }
    fn dynamic_update_enabled_mut(&mut self) -> &mut bool {
        &mut self.dynamic_update_enabled
    }
}

impl super::core::AssetTrait for GunSwayModifierData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for GunSwayModifierData {
}

pub static GUNSWAYMODIFIERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GunSwayModifierData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GunSwayModifierData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DispersionModifiers",
                flags: MemberInfoFlags::new(144),
                field_type: "GunSwayDispersionModData-Array",
                rust_offset: offset_of!(GunSwayModifierData, dispersion_modifiers),
            },
            FieldInfoData {
                name: "RecoilModifiers",
                flags: MemberInfoFlags::new(144),
                field_type: "GunSwayRecoilModData-Array",
                rust_offset: offset_of!(GunSwayModifierData, recoil_modifiers),
            },
            FieldInfoData {
                name: "StandZoomModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "GunSwayStanceZoomModifierData",
                rust_offset: offset_of!(GunSwayModifierData, stand_zoom_modifier),
            },
            FieldInfoData {
                name: "StandNoZoomModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "GunSwayStanceZoomModifierData",
                rust_offset: offset_of!(GunSwayModifierData, stand_no_zoom_modifier),
            },
            FieldInfoData {
                name: "CrouchZoomModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "GunSwayStanceZoomModifierData",
                rust_offset: offset_of!(GunSwayModifierData, crouch_zoom_modifier),
            },
            FieldInfoData {
                name: "CrouchNoZoomModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "GunSwayStanceZoomModifierData",
                rust_offset: offset_of!(GunSwayModifierData, crouch_no_zoom_modifier),
            },
            FieldInfoData {
                name: "ProneZoomModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "GunSwayStanceZoomModifierData",
                rust_offset: offset_of!(GunSwayModifierData, prone_zoom_modifier),
            },
            FieldInfoData {
                name: "ProneNoZoomModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "GunSwayStanceZoomModifierData",
                rust_offset: offset_of!(GunSwayModifierData, prone_no_zoom_modifier),
            },
            FieldInfoData {
                name: "OnlyInSupportedShooting",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(GunSwayModifierData, only_in_supported_shooting),
            },
            FieldInfoData {
                name: "OnlyOnWeaponLightEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(GunSwayModifierData, only_on_weapon_light_enabled),
            },
            FieldInfoData {
                name: "DynamicUpdateEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(GunSwayModifierData, dynamic_update_enabled),
            },
        ],
    }),
    array_type: Some(GUNSWAYMODIFIERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for GunSwayModifierData {
    fn type_info(&self) -> &'static TypeInfo {
        GUNSWAYMODIFIERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static GUNSWAYMODIFIERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GunSwayModifierData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("GunSwayModifierData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GunSwayStanceZoomModifierData {
    pub dispersion_mod: GunSwayDispersionModData,
    pub moving_dispersion_mod: GunSwayDispersionModData,
    pub sprinting_dispersion_mod: GunSwayDispersionModData,
    pub recoil_magnitude_mod: f32,
    pub recoil_angle_mod: f32,
    pub recoil_angle_offset: f32,
    pub first_shot_recoil_mod: f32,
    pub recoil_amplitude_decrease_factor_mod: f32,
}

pub trait GunSwayStanceZoomModifierDataTrait: TypeObject {
    fn dispersion_mod(&self) -> &GunSwayDispersionModData;
    fn dispersion_mod_mut(&mut self) -> &mut GunSwayDispersionModData;
    fn moving_dispersion_mod(&self) -> &GunSwayDispersionModData;
    fn moving_dispersion_mod_mut(&mut self) -> &mut GunSwayDispersionModData;
    fn sprinting_dispersion_mod(&self) -> &GunSwayDispersionModData;
    fn sprinting_dispersion_mod_mut(&mut self) -> &mut GunSwayDispersionModData;
    fn recoil_magnitude_mod(&self) -> &f32;
    fn recoil_magnitude_mod_mut(&mut self) -> &mut f32;
    fn recoil_angle_mod(&self) -> &f32;
    fn recoil_angle_mod_mut(&mut self) -> &mut f32;
    fn recoil_angle_offset(&self) -> &f32;
    fn recoil_angle_offset_mut(&mut self) -> &mut f32;
    fn first_shot_recoil_mod(&self) -> &f32;
    fn first_shot_recoil_mod_mut(&mut self) -> &mut f32;
    fn recoil_amplitude_decrease_factor_mod(&self) -> &f32;
    fn recoil_amplitude_decrease_factor_mod_mut(&mut self) -> &mut f32;
}

impl GunSwayStanceZoomModifierDataTrait for GunSwayStanceZoomModifierData {
    fn dispersion_mod(&self) -> &GunSwayDispersionModData {
        &self.dispersion_mod
    }
    fn dispersion_mod_mut(&mut self) -> &mut GunSwayDispersionModData {
        &mut self.dispersion_mod
    }
    fn moving_dispersion_mod(&self) -> &GunSwayDispersionModData {
        &self.moving_dispersion_mod
    }
    fn moving_dispersion_mod_mut(&mut self) -> &mut GunSwayDispersionModData {
        &mut self.moving_dispersion_mod
    }
    fn sprinting_dispersion_mod(&self) -> &GunSwayDispersionModData {
        &self.sprinting_dispersion_mod
    }
    fn sprinting_dispersion_mod_mut(&mut self) -> &mut GunSwayDispersionModData {
        &mut self.sprinting_dispersion_mod
    }
    fn recoil_magnitude_mod(&self) -> &f32 {
        &self.recoil_magnitude_mod
    }
    fn recoil_magnitude_mod_mut(&mut self) -> &mut f32 {
        &mut self.recoil_magnitude_mod
    }
    fn recoil_angle_mod(&self) -> &f32 {
        &self.recoil_angle_mod
    }
    fn recoil_angle_mod_mut(&mut self) -> &mut f32 {
        &mut self.recoil_angle_mod
    }
    fn recoil_angle_offset(&self) -> &f32 {
        &self.recoil_angle_offset
    }
    fn recoil_angle_offset_mut(&mut self) -> &mut f32 {
        &mut self.recoil_angle_offset
    }
    fn first_shot_recoil_mod(&self) -> &f32 {
        &self.first_shot_recoil_mod
    }
    fn first_shot_recoil_mod_mut(&mut self) -> &mut f32 {
        &mut self.first_shot_recoil_mod
    }
    fn recoil_amplitude_decrease_factor_mod(&self) -> &f32 {
        &self.recoil_amplitude_decrease_factor_mod
    }
    fn recoil_amplitude_decrease_factor_mod_mut(&mut self) -> &mut f32 {
        &mut self.recoil_amplitude_decrease_factor_mod
    }
}

pub static GUNSWAYSTANCEZOOMMODIFIERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GunSwayStanceZoomModifierData",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GunSwayStanceZoomModifierData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DispersionMod",
                flags: MemberInfoFlags::new(0),
                field_type: "GunSwayDispersionModData",
                rust_offset: offset_of!(GunSwayStanceZoomModifierData, dispersion_mod),
            },
            FieldInfoData {
                name: "MovingDispersionMod",
                flags: MemberInfoFlags::new(0),
                field_type: "GunSwayDispersionModData",
                rust_offset: offset_of!(GunSwayStanceZoomModifierData, moving_dispersion_mod),
            },
            FieldInfoData {
                name: "SprintingDispersionMod",
                flags: MemberInfoFlags::new(0),
                field_type: "GunSwayDispersionModData",
                rust_offset: offset_of!(GunSwayStanceZoomModifierData, sprinting_dispersion_mod),
            },
            FieldInfoData {
                name: "RecoilMagnitudeMod",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GunSwayStanceZoomModifierData, recoil_magnitude_mod),
            },
            FieldInfoData {
                name: "RecoilAngleMod",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GunSwayStanceZoomModifierData, recoil_angle_mod),
            },
            FieldInfoData {
                name: "RecoilAngleOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GunSwayStanceZoomModifierData, recoil_angle_offset),
            },
            FieldInfoData {
                name: "FirstShotRecoilMod",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GunSwayStanceZoomModifierData, first_shot_recoil_mod),
            },
            FieldInfoData {
                name: "RecoilAmplitudeDecreaseFactorMod",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GunSwayStanceZoomModifierData, recoil_amplitude_decrease_factor_mod),
            },
        ],
    }),
    array_type: Some(GUNSWAYSTANCEZOOMMODIFIERDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for GunSwayStanceZoomModifierData {
    fn type_info(&self) -> &'static TypeInfo {
        GUNSWAYSTANCEZOOMMODIFIERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static GUNSWAYSTANCEZOOMMODIFIERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GunSwayStanceZoomModifierData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("GunSwayStanceZoomModifierData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GunSwayCrouchProneData {
    pub no_zoom: GunSwayBaseMoveData,
    pub zoom: GunSwayBaseMoveData,
}

pub trait GunSwayCrouchProneDataTrait: TypeObject {
    fn no_zoom(&self) -> &GunSwayBaseMoveData;
    fn no_zoom_mut(&mut self) -> &mut GunSwayBaseMoveData;
    fn zoom(&self) -> &GunSwayBaseMoveData;
    fn zoom_mut(&mut self) -> &mut GunSwayBaseMoveData;
}

impl GunSwayCrouchProneDataTrait for GunSwayCrouchProneData {
    fn no_zoom(&self) -> &GunSwayBaseMoveData {
        &self.no_zoom
    }
    fn no_zoom_mut(&mut self) -> &mut GunSwayBaseMoveData {
        &mut self.no_zoom
    }
    fn zoom(&self) -> &GunSwayBaseMoveData {
        &self.zoom
    }
    fn zoom_mut(&mut self) -> &mut GunSwayBaseMoveData {
        &mut self.zoom
    }
}

pub static GUNSWAYCROUCHPRONEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GunSwayCrouchProneData",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GunSwayCrouchProneData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "NoZoom",
                flags: MemberInfoFlags::new(0),
                field_type: "GunSwayBaseMoveData",
                rust_offset: offset_of!(GunSwayCrouchProneData, no_zoom),
            },
            FieldInfoData {
                name: "Zoom",
                flags: MemberInfoFlags::new(0),
                field_type: "GunSwayBaseMoveData",
                rust_offset: offset_of!(GunSwayCrouchProneData, zoom),
            },
        ],
    }),
    array_type: Some(GUNSWAYCROUCHPRONEDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for GunSwayCrouchProneData {
    fn type_info(&self) -> &'static TypeInfo {
        GUNSWAYCROUCHPRONEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static GUNSWAYCROUCHPRONEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GunSwayCrouchProneData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("GunSwayCrouchProneData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GunSwayStandData {
    pub no_zoom: GunSwayBaseMoveJumpData,
    pub zoom: GunSwayBaseMoveJumpData,
}

pub trait GunSwayStandDataTrait: TypeObject {
    fn no_zoom(&self) -> &GunSwayBaseMoveJumpData;
    fn no_zoom_mut(&mut self) -> &mut GunSwayBaseMoveJumpData;
    fn zoom(&self) -> &GunSwayBaseMoveJumpData;
    fn zoom_mut(&mut self) -> &mut GunSwayBaseMoveJumpData;
}

impl GunSwayStandDataTrait for GunSwayStandData {
    fn no_zoom(&self) -> &GunSwayBaseMoveJumpData {
        &self.no_zoom
    }
    fn no_zoom_mut(&mut self) -> &mut GunSwayBaseMoveJumpData {
        &mut self.no_zoom
    }
    fn zoom(&self) -> &GunSwayBaseMoveJumpData {
        &self.zoom
    }
    fn zoom_mut(&mut self) -> &mut GunSwayBaseMoveJumpData {
        &mut self.zoom
    }
}

pub static GUNSWAYSTANDDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GunSwayStandData",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GunSwayStandData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "NoZoom",
                flags: MemberInfoFlags::new(0),
                field_type: "GunSwayBaseMoveJumpData",
                rust_offset: offset_of!(GunSwayStandData, no_zoom),
            },
            FieldInfoData {
                name: "Zoom",
                flags: MemberInfoFlags::new(0),
                field_type: "GunSwayBaseMoveJumpData",
                rust_offset: offset_of!(GunSwayStandData, zoom),
            },
        ],
    }),
    array_type: Some(GUNSWAYSTANDDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for GunSwayStandData {
    fn type_info(&self) -> &'static TypeInfo {
        GUNSWAYSTANDDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static GUNSWAYSTANDDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GunSwayStandData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("GunSwayStandData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GunSwayBaseMoveJumpData {
    pub base_value: GunSwayDispersionData,
    pub moving: GunSwayDispersionData,
    pub jumping: GunSwayDispersionData,
    pub sprinting: GunSwayDispersionData,
    pub recoil: GunSwayRecoilData,
}

pub trait GunSwayBaseMoveJumpDataTrait: TypeObject {
    fn base_value(&self) -> &GunSwayDispersionData;
    fn base_value_mut(&mut self) -> &mut GunSwayDispersionData;
    fn moving(&self) -> &GunSwayDispersionData;
    fn moving_mut(&mut self) -> &mut GunSwayDispersionData;
    fn jumping(&self) -> &GunSwayDispersionData;
    fn jumping_mut(&mut self) -> &mut GunSwayDispersionData;
    fn sprinting(&self) -> &GunSwayDispersionData;
    fn sprinting_mut(&mut self) -> &mut GunSwayDispersionData;
    fn recoil(&self) -> &GunSwayRecoilData;
    fn recoil_mut(&mut self) -> &mut GunSwayRecoilData;
}

impl GunSwayBaseMoveJumpDataTrait for GunSwayBaseMoveJumpData {
    fn base_value(&self) -> &GunSwayDispersionData {
        &self.base_value
    }
    fn base_value_mut(&mut self) -> &mut GunSwayDispersionData {
        &mut self.base_value
    }
    fn moving(&self) -> &GunSwayDispersionData {
        &self.moving
    }
    fn moving_mut(&mut self) -> &mut GunSwayDispersionData {
        &mut self.moving
    }
    fn jumping(&self) -> &GunSwayDispersionData {
        &self.jumping
    }
    fn jumping_mut(&mut self) -> &mut GunSwayDispersionData {
        &mut self.jumping
    }
    fn sprinting(&self) -> &GunSwayDispersionData {
        &self.sprinting
    }
    fn sprinting_mut(&mut self) -> &mut GunSwayDispersionData {
        &mut self.sprinting
    }
    fn recoil(&self) -> &GunSwayRecoilData {
        &self.recoil
    }
    fn recoil_mut(&mut self) -> &mut GunSwayRecoilData {
        &mut self.recoil
    }
}

pub static GUNSWAYBASEMOVEJUMPDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GunSwayBaseMoveJumpData",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GunSwayBaseMoveJumpData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "BaseValue",
                flags: MemberInfoFlags::new(0),
                field_type: "GunSwayDispersionData",
                rust_offset: offset_of!(GunSwayBaseMoveJumpData, base_value),
            },
            FieldInfoData {
                name: "Moving",
                flags: MemberInfoFlags::new(0),
                field_type: "GunSwayDispersionData",
                rust_offset: offset_of!(GunSwayBaseMoveJumpData, moving),
            },
            FieldInfoData {
                name: "Jumping",
                flags: MemberInfoFlags::new(0),
                field_type: "GunSwayDispersionData",
                rust_offset: offset_of!(GunSwayBaseMoveJumpData, jumping),
            },
            FieldInfoData {
                name: "Sprinting",
                flags: MemberInfoFlags::new(0),
                field_type: "GunSwayDispersionData",
                rust_offset: offset_of!(GunSwayBaseMoveJumpData, sprinting),
            },
            FieldInfoData {
                name: "Recoil",
                flags: MemberInfoFlags::new(0),
                field_type: "GunSwayRecoilData",
                rust_offset: offset_of!(GunSwayBaseMoveJumpData, recoil),
            },
        ],
    }),
    array_type: Some(GUNSWAYBASEMOVEJUMPDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for GunSwayBaseMoveJumpData {
    fn type_info(&self) -> &'static TypeInfo {
        GUNSWAYBASEMOVEJUMPDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static GUNSWAYBASEMOVEJUMPDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GunSwayBaseMoveJumpData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("GunSwayBaseMoveJumpData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum GunSwayZoomLevel {
    #[default]
    GunSwayZoomLevel_None = 0,
    GunSwayZoomLevel_Zoomed = 1,
    GunSwayZoomLevel_Count = 2,
}

pub static GUNSWAYZOOMLEVEL_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GunSwayZoomLevel",
    flags: MemberInfoFlags::new(49429),
    module: "SoldierShared",
    data: TypeInfoData::Enum,
    array_type: Some(GUNSWAYZOOMLEVEL_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for GunSwayZoomLevel {
    fn type_info(&self) -> &'static TypeInfo {
        GUNSWAYZOOMLEVEL_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static GUNSWAYZOOMLEVEL_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GunSwayZoomLevel-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("GunSwayZoomLevel"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum GunSwayDispersionAction {
    #[default]
    GunSwayDispersionAction_Default = 0,
    GunSwayDispersionAction_Moving = 1,
    GunSwayDispersionAction_Jumping = 2,
    GunSwayDispersionAction_Sprinting = 3,
    GunSwayDispersionAction_Count = 4,
}

pub static GUNSWAYDISPERSIONACTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GunSwayDispersionAction",
    flags: MemberInfoFlags::new(49429),
    module: "SoldierShared",
    data: TypeInfoData::Enum,
    array_type: Some(GUNSWAYDISPERSIONACTION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for GunSwayDispersionAction {
    fn type_info(&self) -> &'static TypeInfo {
        GUNSWAYDISPERSIONACTION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static GUNSWAYDISPERSIONACTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GunSwayDispersionAction-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("GunSwayDispersionAction"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GunSwayBaseMoveData {
    pub base_value: GunSwayDispersionData,
    pub moving: GunSwayDispersionData,
    pub recoil: GunSwayRecoilData,
}

pub trait GunSwayBaseMoveDataTrait: TypeObject {
    fn base_value(&self) -> &GunSwayDispersionData;
    fn base_value_mut(&mut self) -> &mut GunSwayDispersionData;
    fn moving(&self) -> &GunSwayDispersionData;
    fn moving_mut(&mut self) -> &mut GunSwayDispersionData;
    fn recoil(&self) -> &GunSwayRecoilData;
    fn recoil_mut(&mut self) -> &mut GunSwayRecoilData;
}

impl GunSwayBaseMoveDataTrait for GunSwayBaseMoveData {
    fn base_value(&self) -> &GunSwayDispersionData {
        &self.base_value
    }
    fn base_value_mut(&mut self) -> &mut GunSwayDispersionData {
        &mut self.base_value
    }
    fn moving(&self) -> &GunSwayDispersionData {
        &self.moving
    }
    fn moving_mut(&mut self) -> &mut GunSwayDispersionData {
        &mut self.moving
    }
    fn recoil(&self) -> &GunSwayRecoilData {
        &self.recoil
    }
    fn recoil_mut(&mut self) -> &mut GunSwayRecoilData {
        &mut self.recoil
    }
}

pub static GUNSWAYBASEMOVEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GunSwayBaseMoveData",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GunSwayBaseMoveData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "BaseValue",
                flags: MemberInfoFlags::new(0),
                field_type: "GunSwayDispersionData",
                rust_offset: offset_of!(GunSwayBaseMoveData, base_value),
            },
            FieldInfoData {
                name: "Moving",
                flags: MemberInfoFlags::new(0),
                field_type: "GunSwayDispersionData",
                rust_offset: offset_of!(GunSwayBaseMoveData, moving),
            },
            FieldInfoData {
                name: "Recoil",
                flags: MemberInfoFlags::new(0),
                field_type: "GunSwayRecoilData",
                rust_offset: offset_of!(GunSwayBaseMoveData, recoil),
            },
        ],
    }),
    array_type: Some(GUNSWAYBASEMOVEDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for GunSwayBaseMoveData {
    fn type_info(&self) -> &'static TypeInfo {
        GUNSWAYBASEMOVEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static GUNSWAYBASEMOVEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GunSwayBaseMoveData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("GunSwayBaseMoveData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GunSwayBaseData {
    pub base_value: GunSwayDispersionData,
    pub recoil: GunSwayRecoilData,
}

pub trait GunSwayBaseDataTrait: TypeObject {
    fn base_value(&self) -> &GunSwayDispersionData;
    fn base_value_mut(&mut self) -> &mut GunSwayDispersionData;
    fn recoil(&self) -> &GunSwayRecoilData;
    fn recoil_mut(&mut self) -> &mut GunSwayRecoilData;
}

impl GunSwayBaseDataTrait for GunSwayBaseData {
    fn base_value(&self) -> &GunSwayDispersionData {
        &self.base_value
    }
    fn base_value_mut(&mut self) -> &mut GunSwayDispersionData {
        &mut self.base_value
    }
    fn recoil(&self) -> &GunSwayRecoilData {
        &self.recoil
    }
    fn recoil_mut(&mut self) -> &mut GunSwayRecoilData {
        &mut self.recoil
    }
}

pub static GUNSWAYBASEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GunSwayBaseData",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GunSwayBaseData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "BaseValue",
                flags: MemberInfoFlags::new(0),
                field_type: "GunSwayDispersionData",
                rust_offset: offset_of!(GunSwayBaseData, base_value),
            },
            FieldInfoData {
                name: "Recoil",
                flags: MemberInfoFlags::new(0),
                field_type: "GunSwayRecoilData",
                rust_offset: offset_of!(GunSwayBaseData, recoil),
            },
        ],
    }),
    array_type: Some(GUNSWAYBASEDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for GunSwayBaseData {
    fn type_info(&self) -> &'static TypeInfo {
        GUNSWAYBASEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static GUNSWAYBASEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GunSwayBaseData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("GunSwayBaseData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GunSwayStanceTransition {
    pub max_penalty_value: GunSwayDispersionData,
    pub cool_down: f32,
}

pub trait GunSwayStanceTransitionTrait: TypeObject {
    fn max_penalty_value(&self) -> &GunSwayDispersionData;
    fn max_penalty_value_mut(&mut self) -> &mut GunSwayDispersionData;
    fn cool_down(&self) -> &f32;
    fn cool_down_mut(&mut self) -> &mut f32;
}

impl GunSwayStanceTransitionTrait for GunSwayStanceTransition {
    fn max_penalty_value(&self) -> &GunSwayDispersionData {
        &self.max_penalty_value
    }
    fn max_penalty_value_mut(&mut self) -> &mut GunSwayDispersionData {
        &mut self.max_penalty_value
    }
    fn cool_down(&self) -> &f32 {
        &self.cool_down
    }
    fn cool_down_mut(&mut self) -> &mut f32 {
        &mut self.cool_down
    }
}

pub static GUNSWAYSTANCETRANSITION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GunSwayStanceTransition",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GunSwayStanceTransition as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MaxPenaltyValue",
                flags: MemberInfoFlags::new(0),
                field_type: "GunSwayDispersionData",
                rust_offset: offset_of!(GunSwayStanceTransition, max_penalty_value),
            },
            FieldInfoData {
                name: "CoolDown",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GunSwayStanceTransition, cool_down),
            },
        ],
    }),
    array_type: Some(GUNSWAYSTANCETRANSITION_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for GunSwayStanceTransition {
    fn type_info(&self) -> &'static TypeInfo {
        GUNSWAYSTANCETRANSITION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static GUNSWAYSTANCETRANSITION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GunSwayStanceTransition-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("GunSwayStanceTransition"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GunSwayRecoilModData {
    pub recoil_magnitude_mod: f32,
    pub recoil_angle_mod: f32,
    pub first_shot_recoil_mod: f32,
    pub recoil_amplitude_decrease_factor_mod: f32,
    pub recoil_angle_offset: f32,
}

pub trait GunSwayRecoilModDataTrait: TypeObject {
    fn recoil_magnitude_mod(&self) -> &f32;
    fn recoil_magnitude_mod_mut(&mut self) -> &mut f32;
    fn recoil_angle_mod(&self) -> &f32;
    fn recoil_angle_mod_mut(&mut self) -> &mut f32;
    fn first_shot_recoil_mod(&self) -> &f32;
    fn first_shot_recoil_mod_mut(&mut self) -> &mut f32;
    fn recoil_amplitude_decrease_factor_mod(&self) -> &f32;
    fn recoil_amplitude_decrease_factor_mod_mut(&mut self) -> &mut f32;
    fn recoil_angle_offset(&self) -> &f32;
    fn recoil_angle_offset_mut(&mut self) -> &mut f32;
}

impl GunSwayRecoilModDataTrait for GunSwayRecoilModData {
    fn recoil_magnitude_mod(&self) -> &f32 {
        &self.recoil_magnitude_mod
    }
    fn recoil_magnitude_mod_mut(&mut self) -> &mut f32 {
        &mut self.recoil_magnitude_mod
    }
    fn recoil_angle_mod(&self) -> &f32 {
        &self.recoil_angle_mod
    }
    fn recoil_angle_mod_mut(&mut self) -> &mut f32 {
        &mut self.recoil_angle_mod
    }
    fn first_shot_recoil_mod(&self) -> &f32 {
        &self.first_shot_recoil_mod
    }
    fn first_shot_recoil_mod_mut(&mut self) -> &mut f32 {
        &mut self.first_shot_recoil_mod
    }
    fn recoil_amplitude_decrease_factor_mod(&self) -> &f32 {
        &self.recoil_amplitude_decrease_factor_mod
    }
    fn recoil_amplitude_decrease_factor_mod_mut(&mut self) -> &mut f32 {
        &mut self.recoil_amplitude_decrease_factor_mod
    }
    fn recoil_angle_offset(&self) -> &f32 {
        &self.recoil_angle_offset
    }
    fn recoil_angle_offset_mut(&mut self) -> &mut f32 {
        &mut self.recoil_angle_offset
    }
}

pub static GUNSWAYRECOILMODDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GunSwayRecoilModData",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GunSwayRecoilModData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "RecoilMagnitudeMod",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GunSwayRecoilModData, recoil_magnitude_mod),
            },
            FieldInfoData {
                name: "RecoilAngleMod",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GunSwayRecoilModData, recoil_angle_mod),
            },
            FieldInfoData {
                name: "FirstShotRecoilMod",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GunSwayRecoilModData, first_shot_recoil_mod),
            },
            FieldInfoData {
                name: "RecoilAmplitudeDecreaseFactorMod",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GunSwayRecoilModData, recoil_amplitude_decrease_factor_mod),
            },
            FieldInfoData {
                name: "RecoilAngleOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GunSwayRecoilModData, recoil_angle_offset),
            },
        ],
    }),
    array_type: Some(GUNSWAYRECOILMODDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for GunSwayRecoilModData {
    fn type_info(&self) -> &'static TypeInfo {
        GUNSWAYRECOILMODDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static GUNSWAYRECOILMODDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GunSwayRecoilModData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("GunSwayRecoilModData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GunSwayRecoilData {
    pub recoil_amplitude_max: f32,
    pub recoil_amplitude_inc_per_shot: f32,
    pub horizontal_recoil_amplitude_inc_per_shot_min: f32,
    pub horizontal_recoil_amplitude_inc_per_shot_max: f32,
    pub horizontal_recoil_amplitude_max: f32,
    pub recoil_amplitude_decrease_factor: f32,
}

pub trait GunSwayRecoilDataTrait: TypeObject {
    fn recoil_amplitude_max(&self) -> &f32;
    fn recoil_amplitude_max_mut(&mut self) -> &mut f32;
    fn recoil_amplitude_inc_per_shot(&self) -> &f32;
    fn recoil_amplitude_inc_per_shot_mut(&mut self) -> &mut f32;
    fn horizontal_recoil_amplitude_inc_per_shot_min(&self) -> &f32;
    fn horizontal_recoil_amplitude_inc_per_shot_min_mut(&mut self) -> &mut f32;
    fn horizontal_recoil_amplitude_inc_per_shot_max(&self) -> &f32;
    fn horizontal_recoil_amplitude_inc_per_shot_max_mut(&mut self) -> &mut f32;
    fn horizontal_recoil_amplitude_max(&self) -> &f32;
    fn horizontal_recoil_amplitude_max_mut(&mut self) -> &mut f32;
    fn recoil_amplitude_decrease_factor(&self) -> &f32;
    fn recoil_amplitude_decrease_factor_mut(&mut self) -> &mut f32;
}

impl GunSwayRecoilDataTrait for GunSwayRecoilData {
    fn recoil_amplitude_max(&self) -> &f32 {
        &self.recoil_amplitude_max
    }
    fn recoil_amplitude_max_mut(&mut self) -> &mut f32 {
        &mut self.recoil_amplitude_max
    }
    fn recoil_amplitude_inc_per_shot(&self) -> &f32 {
        &self.recoil_amplitude_inc_per_shot
    }
    fn recoil_amplitude_inc_per_shot_mut(&mut self) -> &mut f32 {
        &mut self.recoil_amplitude_inc_per_shot
    }
    fn horizontal_recoil_amplitude_inc_per_shot_min(&self) -> &f32 {
        &self.horizontal_recoil_amplitude_inc_per_shot_min
    }
    fn horizontal_recoil_amplitude_inc_per_shot_min_mut(&mut self) -> &mut f32 {
        &mut self.horizontal_recoil_amplitude_inc_per_shot_min
    }
    fn horizontal_recoil_amplitude_inc_per_shot_max(&self) -> &f32 {
        &self.horizontal_recoil_amplitude_inc_per_shot_max
    }
    fn horizontal_recoil_amplitude_inc_per_shot_max_mut(&mut self) -> &mut f32 {
        &mut self.horizontal_recoil_amplitude_inc_per_shot_max
    }
    fn horizontal_recoil_amplitude_max(&self) -> &f32 {
        &self.horizontal_recoil_amplitude_max
    }
    fn horizontal_recoil_amplitude_max_mut(&mut self) -> &mut f32 {
        &mut self.horizontal_recoil_amplitude_max
    }
    fn recoil_amplitude_decrease_factor(&self) -> &f32 {
        &self.recoil_amplitude_decrease_factor
    }
    fn recoil_amplitude_decrease_factor_mut(&mut self) -> &mut f32 {
        &mut self.recoil_amplitude_decrease_factor
    }
}

pub static GUNSWAYRECOILDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GunSwayRecoilData",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GunSwayRecoilData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "RecoilAmplitudeMax",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GunSwayRecoilData, recoil_amplitude_max),
            },
            FieldInfoData {
                name: "RecoilAmplitudeIncPerShot",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GunSwayRecoilData, recoil_amplitude_inc_per_shot),
            },
            FieldInfoData {
                name: "HorizontalRecoilAmplitudeIncPerShotMin",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GunSwayRecoilData, horizontal_recoil_amplitude_inc_per_shot_min),
            },
            FieldInfoData {
                name: "HorizontalRecoilAmplitudeIncPerShotMax",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GunSwayRecoilData, horizontal_recoil_amplitude_inc_per_shot_max),
            },
            FieldInfoData {
                name: "HorizontalRecoilAmplitudeMax",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GunSwayRecoilData, horizontal_recoil_amplitude_max),
            },
            FieldInfoData {
                name: "RecoilAmplitudeDecreaseFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GunSwayRecoilData, recoil_amplitude_decrease_factor),
            },
        ],
    }),
    array_type: Some(GUNSWAYRECOILDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for GunSwayRecoilData {
    fn type_info(&self) -> &'static TypeInfo {
        GUNSWAYRECOILDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static GUNSWAYRECOILDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GunSwayRecoilData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("GunSwayRecoilData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CameraRecoilData {
    pub _glacier_base: super::core::DataContainer,
    pub spring_constant: f32,
    pub spring_damping: f32,
    pub spring_min_threshold_angle: f32,
}

pub trait CameraRecoilDataTrait: super::core::DataContainerTrait {
    fn spring_constant(&self) -> &f32;
    fn spring_constant_mut(&mut self) -> &mut f32;
    fn spring_damping(&self) -> &f32;
    fn spring_damping_mut(&mut self) -> &mut f32;
    fn spring_min_threshold_angle(&self) -> &f32;
    fn spring_min_threshold_angle_mut(&mut self) -> &mut f32;
}

impl CameraRecoilDataTrait for CameraRecoilData {
    fn spring_constant(&self) -> &f32 {
        &self.spring_constant
    }
    fn spring_constant_mut(&mut self) -> &mut f32 {
        &mut self.spring_constant
    }
    fn spring_damping(&self) -> &f32 {
        &self.spring_damping
    }
    fn spring_damping_mut(&mut self) -> &mut f32 {
        &mut self.spring_damping
    }
    fn spring_min_threshold_angle(&self) -> &f32 {
        &self.spring_min_threshold_angle
    }
    fn spring_min_threshold_angle_mut(&mut self) -> &mut f32 {
        &mut self.spring_min_threshold_angle
    }
}

impl super::core::DataContainerTrait for CameraRecoilData {
}

pub static CAMERARECOILDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraRecoilData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraRecoilData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SpringConstant",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRecoilData, spring_constant),
            },
            FieldInfoData {
                name: "SpringDamping",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRecoilData, spring_damping),
            },
            FieldInfoData {
                name: "SpringMinThresholdAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRecoilData, spring_min_threshold_angle),
            },
        ],
    }),
    array_type: Some(CAMERARECOILDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CameraRecoilData {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERARECOILDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CAMERARECOILDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraRecoilData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("CameraRecoilData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GunSwayDispersionModData {
    pub min_angle_modifier: f32,
    pub max_angle_modifier: f32,
    pub increase_per_shot_modifier: f32,
    pub decrease_per_second_modifier: f32,
    pub no_fire_decrease_per_second_modifier: f32,
    pub no_fire_time_threshold_modifier: f32,
    pub first_shot_dispersion_modifier: f32,
}

pub trait GunSwayDispersionModDataTrait: TypeObject {
    fn min_angle_modifier(&self) -> &f32;
    fn min_angle_modifier_mut(&mut self) -> &mut f32;
    fn max_angle_modifier(&self) -> &f32;
    fn max_angle_modifier_mut(&mut self) -> &mut f32;
    fn increase_per_shot_modifier(&self) -> &f32;
    fn increase_per_shot_modifier_mut(&mut self) -> &mut f32;
    fn decrease_per_second_modifier(&self) -> &f32;
    fn decrease_per_second_modifier_mut(&mut self) -> &mut f32;
    fn no_fire_decrease_per_second_modifier(&self) -> &f32;
    fn no_fire_decrease_per_second_modifier_mut(&mut self) -> &mut f32;
    fn no_fire_time_threshold_modifier(&self) -> &f32;
    fn no_fire_time_threshold_modifier_mut(&mut self) -> &mut f32;
    fn first_shot_dispersion_modifier(&self) -> &f32;
    fn first_shot_dispersion_modifier_mut(&mut self) -> &mut f32;
}

impl GunSwayDispersionModDataTrait for GunSwayDispersionModData {
    fn min_angle_modifier(&self) -> &f32 {
        &self.min_angle_modifier
    }
    fn min_angle_modifier_mut(&mut self) -> &mut f32 {
        &mut self.min_angle_modifier
    }
    fn max_angle_modifier(&self) -> &f32 {
        &self.max_angle_modifier
    }
    fn max_angle_modifier_mut(&mut self) -> &mut f32 {
        &mut self.max_angle_modifier
    }
    fn increase_per_shot_modifier(&self) -> &f32 {
        &self.increase_per_shot_modifier
    }
    fn increase_per_shot_modifier_mut(&mut self) -> &mut f32 {
        &mut self.increase_per_shot_modifier
    }
    fn decrease_per_second_modifier(&self) -> &f32 {
        &self.decrease_per_second_modifier
    }
    fn decrease_per_second_modifier_mut(&mut self) -> &mut f32 {
        &mut self.decrease_per_second_modifier
    }
    fn no_fire_decrease_per_second_modifier(&self) -> &f32 {
        &self.no_fire_decrease_per_second_modifier
    }
    fn no_fire_decrease_per_second_modifier_mut(&mut self) -> &mut f32 {
        &mut self.no_fire_decrease_per_second_modifier
    }
    fn no_fire_time_threshold_modifier(&self) -> &f32 {
        &self.no_fire_time_threshold_modifier
    }
    fn no_fire_time_threshold_modifier_mut(&mut self) -> &mut f32 {
        &mut self.no_fire_time_threshold_modifier
    }
    fn first_shot_dispersion_modifier(&self) -> &f32 {
        &self.first_shot_dispersion_modifier
    }
    fn first_shot_dispersion_modifier_mut(&mut self) -> &mut f32 {
        &mut self.first_shot_dispersion_modifier
    }
}

pub static GUNSWAYDISPERSIONMODDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GunSwayDispersionModData",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GunSwayDispersionModData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MinAngleModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GunSwayDispersionModData, min_angle_modifier),
            },
            FieldInfoData {
                name: "MaxAngleModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GunSwayDispersionModData, max_angle_modifier),
            },
            FieldInfoData {
                name: "IncreasePerShotModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GunSwayDispersionModData, increase_per_shot_modifier),
            },
            FieldInfoData {
                name: "DecreasePerSecondModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GunSwayDispersionModData, decrease_per_second_modifier),
            },
            FieldInfoData {
                name: "NoFireDecreasePerSecondModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GunSwayDispersionModData, no_fire_decrease_per_second_modifier),
            },
            FieldInfoData {
                name: "NoFireTimeThresholdModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GunSwayDispersionModData, no_fire_time_threshold_modifier),
            },
            FieldInfoData {
                name: "FirstShotDispersionModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GunSwayDispersionModData, first_shot_dispersion_modifier),
            },
        ],
    }),
    array_type: Some(GUNSWAYDISPERSIONMODDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for GunSwayDispersionModData {
    fn type_info(&self) -> &'static TypeInfo {
        GUNSWAYDISPERSIONMODDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static GUNSWAYDISPERSIONMODDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GunSwayDispersionModData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("GunSwayDispersionModData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GunSwayDispersionData {
    pub min_angle: f32,
    pub max_angle: f32,
    pub increase_per_shot: f32,
    pub decrease_per_second: f32,
    pub no_fire_decrease_per_second: f32,
    pub no_fire_time_threshold: f32,
}

pub trait GunSwayDispersionDataTrait: TypeObject {
    fn min_angle(&self) -> &f32;
    fn min_angle_mut(&mut self) -> &mut f32;
    fn max_angle(&self) -> &f32;
    fn max_angle_mut(&mut self) -> &mut f32;
    fn increase_per_shot(&self) -> &f32;
    fn increase_per_shot_mut(&mut self) -> &mut f32;
    fn decrease_per_second(&self) -> &f32;
    fn decrease_per_second_mut(&mut self) -> &mut f32;
    fn no_fire_decrease_per_second(&self) -> &f32;
    fn no_fire_decrease_per_second_mut(&mut self) -> &mut f32;
    fn no_fire_time_threshold(&self) -> &f32;
    fn no_fire_time_threshold_mut(&mut self) -> &mut f32;
}

impl GunSwayDispersionDataTrait for GunSwayDispersionData {
    fn min_angle(&self) -> &f32 {
        &self.min_angle
    }
    fn min_angle_mut(&mut self) -> &mut f32 {
        &mut self.min_angle
    }
    fn max_angle(&self) -> &f32 {
        &self.max_angle
    }
    fn max_angle_mut(&mut self) -> &mut f32 {
        &mut self.max_angle
    }
    fn increase_per_shot(&self) -> &f32 {
        &self.increase_per_shot
    }
    fn increase_per_shot_mut(&mut self) -> &mut f32 {
        &mut self.increase_per_shot
    }
    fn decrease_per_second(&self) -> &f32 {
        &self.decrease_per_second
    }
    fn decrease_per_second_mut(&mut self) -> &mut f32 {
        &mut self.decrease_per_second
    }
    fn no_fire_decrease_per_second(&self) -> &f32 {
        &self.no_fire_decrease_per_second
    }
    fn no_fire_decrease_per_second_mut(&mut self) -> &mut f32 {
        &mut self.no_fire_decrease_per_second
    }
    fn no_fire_time_threshold(&self) -> &f32 {
        &self.no_fire_time_threshold
    }
    fn no_fire_time_threshold_mut(&mut self) -> &mut f32 {
        &mut self.no_fire_time_threshold
    }
}

pub static GUNSWAYDISPERSIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GunSwayDispersionData",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GunSwayDispersionData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MinAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GunSwayDispersionData, min_angle),
            },
            FieldInfoData {
                name: "MaxAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GunSwayDispersionData, max_angle),
            },
            FieldInfoData {
                name: "IncreasePerShot",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GunSwayDispersionData, increase_per_shot),
            },
            FieldInfoData {
                name: "DecreasePerSecond",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GunSwayDispersionData, decrease_per_second),
            },
            FieldInfoData {
                name: "NoFireDecreasePerSecond",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GunSwayDispersionData, no_fire_decrease_per_second),
            },
            FieldInfoData {
                name: "NoFireTimeThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GunSwayDispersionData, no_fire_time_threshold),
            },
        ],
    }),
    array_type: Some(GUNSWAYDISPERSIONDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for GunSwayDispersionData {
    fn type_info(&self) -> &'static TypeInfo {
        GUNSWAYDISPERSIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static GUNSWAYDISPERSIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GunSwayDispersionData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("GunSwayDispersionData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WeaponModifierNetStateData {
    pub weapon_dynamic_modifier_active_mask: u32,
}

pub trait WeaponModifierNetStateDataTrait: TypeObject {
    fn weapon_dynamic_modifier_active_mask(&self) -> &u32;
    fn weapon_dynamic_modifier_active_mask_mut(&mut self) -> &mut u32;
}

impl WeaponModifierNetStateDataTrait for WeaponModifierNetStateData {
    fn weapon_dynamic_modifier_active_mask(&self) -> &u32 {
        &self.weapon_dynamic_modifier_active_mask
    }
    fn weapon_dynamic_modifier_active_mask_mut(&mut self) -> &mut u32 {
        &mut self.weapon_dynamic_modifier_active_mask
    }
}

pub static WEAPONMODIFIERNETSTATEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponModifierNetStateData",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WeaponModifierNetStateData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "WeaponDynamicModifierActiveMask",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(WeaponModifierNetStateData, weapon_dynamic_modifier_active_mask),
            },
        ],
    }),
    array_type: Some(WEAPONMODIFIERNETSTATEDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for WeaponModifierNetStateData {
    fn type_info(&self) -> &'static TypeInfo {
        WEAPONMODIFIERNETSTATEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static WEAPONMODIFIERNETSTATEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponModifierNetStateData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("WeaponModifierNetStateData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WeaponSwitchingNetState {
    pub current_weapon_id: i8,
    pub player_switched_weapon: bool,
    pub quick_switch: bool,
    pub disable_switch_on_delayed_button_release: u32,
    pub automatic_fire: bool,
    pub switch_back_to_prev_max_time_pressed: f32,
    pub fire_and_switch_back_to_prev_action: u32,
}

pub trait WeaponSwitchingNetStateTrait: TypeObject {
    fn current_weapon_id(&self) -> &i8;
    fn current_weapon_id_mut(&mut self) -> &mut i8;
    fn player_switched_weapon(&self) -> &bool;
    fn player_switched_weapon_mut(&mut self) -> &mut bool;
    fn quick_switch(&self) -> &bool;
    fn quick_switch_mut(&mut self) -> &mut bool;
    fn disable_switch_on_delayed_button_release(&self) -> &u32;
    fn disable_switch_on_delayed_button_release_mut(&mut self) -> &mut u32;
    fn automatic_fire(&self) -> &bool;
    fn automatic_fire_mut(&mut self) -> &mut bool;
    fn switch_back_to_prev_max_time_pressed(&self) -> &f32;
    fn switch_back_to_prev_max_time_pressed_mut(&mut self) -> &mut f32;
    fn fire_and_switch_back_to_prev_action(&self) -> &u32;
    fn fire_and_switch_back_to_prev_action_mut(&mut self) -> &mut u32;
}

impl WeaponSwitchingNetStateTrait for WeaponSwitchingNetState {
    fn current_weapon_id(&self) -> &i8 {
        &self.current_weapon_id
    }
    fn current_weapon_id_mut(&mut self) -> &mut i8 {
        &mut self.current_weapon_id
    }
    fn player_switched_weapon(&self) -> &bool {
        &self.player_switched_weapon
    }
    fn player_switched_weapon_mut(&mut self) -> &mut bool {
        &mut self.player_switched_weapon
    }
    fn quick_switch(&self) -> &bool {
        &self.quick_switch
    }
    fn quick_switch_mut(&mut self) -> &mut bool {
        &mut self.quick_switch
    }
    fn disable_switch_on_delayed_button_release(&self) -> &u32 {
        &self.disable_switch_on_delayed_button_release
    }
    fn disable_switch_on_delayed_button_release_mut(&mut self) -> &mut u32 {
        &mut self.disable_switch_on_delayed_button_release
    }
    fn automatic_fire(&self) -> &bool {
        &self.automatic_fire
    }
    fn automatic_fire_mut(&mut self) -> &mut bool {
        &mut self.automatic_fire
    }
    fn switch_back_to_prev_max_time_pressed(&self) -> &f32 {
        &self.switch_back_to_prev_max_time_pressed
    }
    fn switch_back_to_prev_max_time_pressed_mut(&mut self) -> &mut f32 {
        &mut self.switch_back_to_prev_max_time_pressed
    }
    fn fire_and_switch_back_to_prev_action(&self) -> &u32 {
        &self.fire_and_switch_back_to_prev_action
    }
    fn fire_and_switch_back_to_prev_action_mut(&mut self) -> &mut u32 {
        &mut self.fire_and_switch_back_to_prev_action
    }
}

pub static WEAPONSWITCHINGNETSTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponSwitchingNetState",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WeaponSwitchingNetState as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "CurrentWeaponId",
                flags: MemberInfoFlags::new(0),
                field_type: "Int8",
                rust_offset: offset_of!(WeaponSwitchingNetState, current_weapon_id),
            },
            FieldInfoData {
                name: "PlayerSwitchedWeapon",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WeaponSwitchingNetState, player_switched_weapon),
            },
            FieldInfoData {
                name: "QuickSwitch",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WeaponSwitchingNetState, quick_switch),
            },
            FieldInfoData {
                name: "DisableSwitchOnDelayedButtonRelease",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(WeaponSwitchingNetState, disable_switch_on_delayed_button_release),
            },
            FieldInfoData {
                name: "AutomaticFire",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WeaponSwitchingNetState, automatic_fire),
            },
            FieldInfoData {
                name: "SwitchBackToPrevMaxTimePressed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WeaponSwitchingNetState, switch_back_to_prev_max_time_pressed),
            },
            FieldInfoData {
                name: "FireAndSwitchBackToPrevAction",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(WeaponSwitchingNetState, fire_and_switch_back_to_prev_action),
            },
        ],
    }),
    array_type: Some(WEAPONSWITCHINGNETSTATE_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for WeaponSwitchingNetState {
    fn type_info(&self) -> &'static TypeInfo {
        WEAPONSWITCHINGNETSTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static WEAPONSWITCHINGNETSTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponSwitchingNetState-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("WeaponSwitchingNetState"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WeaponsNetState {
}

pub trait WeaponsNetStateTrait: TypeObject {
}

impl WeaponsNetStateTrait for WeaponsNetState {
}

pub static WEAPONSNETSTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponsNetState",
    flags: MemberInfoFlags::new(73),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WeaponsNetState as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(WEAPONSNETSTATE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WeaponsNetState {
    fn type_info(&self) -> &'static TypeInfo {
        WEAPONSNETSTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static WEAPONSNETSTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponsNetState-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("WeaponsNetState"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoldierWeaponsNetState {
    pub soldier_weapon_unlock_asset: Option<Arc<Mutex<dyn SoldierWeaponUnlockAssetTrait>>>,
    pub weapon_instance_id: u8,
    pub sub_level_id: u16,
}

pub trait SoldierWeaponsNetStateTrait: TypeObject {
    fn soldier_weapon_unlock_asset(&self) -> &Option<Arc<Mutex<dyn SoldierWeaponUnlockAssetTrait>>>;
    fn soldier_weapon_unlock_asset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoldierWeaponUnlockAssetTrait>>>;
    fn weapon_instance_id(&self) -> &u8;
    fn weapon_instance_id_mut(&mut self) -> &mut u8;
    fn sub_level_id(&self) -> &u16;
    fn sub_level_id_mut(&mut self) -> &mut u16;
}

impl SoldierWeaponsNetStateTrait for SoldierWeaponsNetState {
    fn soldier_weapon_unlock_asset(&self) -> &Option<Arc<Mutex<dyn SoldierWeaponUnlockAssetTrait>>> {
        &self.soldier_weapon_unlock_asset
    }
    fn soldier_weapon_unlock_asset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoldierWeaponUnlockAssetTrait>>> {
        &mut self.soldier_weapon_unlock_asset
    }
    fn weapon_instance_id(&self) -> &u8 {
        &self.weapon_instance_id
    }
    fn weapon_instance_id_mut(&mut self) -> &mut u8 {
        &mut self.weapon_instance_id
    }
    fn sub_level_id(&self) -> &u16 {
        &self.sub_level_id
    }
    fn sub_level_id_mut(&mut self) -> &mut u16 {
        &mut self.sub_level_id
    }
}

pub static SOLDIERWEAPONSNETSTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierWeaponsNetState",
    flags: MemberInfoFlags::new(73),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierWeaponsNetState as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SoldierWeaponUnlockAsset",
                flags: MemberInfoFlags::new(0),
                field_type: "SoldierWeaponUnlockAsset",
                rust_offset: offset_of!(SoldierWeaponsNetState, soldier_weapon_unlock_asset),
            },
            FieldInfoData {
                name: "WeaponInstanceId",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(SoldierWeaponsNetState, weapon_instance_id),
            },
            FieldInfoData {
                name: "SubLevelId",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint16",
                rust_offset: offset_of!(SoldierWeaponsNetState, sub_level_id),
            },
        ],
    }),
    array_type: Some(SOLDIERWEAPONSNETSTATE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoldierWeaponsNetState {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERWEAPONSNETSTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SOLDIERWEAPONSNETSTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierWeaponsNetState-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SoldierWeaponsNetState"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WeaponLagEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub binding: WeaponLagBinding,
}

pub trait WeaponLagEntityDataTrait: super::entity::EntityDataTrait {
    fn binding(&self) -> &WeaponLagBinding;
    fn binding_mut(&mut self) -> &mut WeaponLagBinding;
}

impl WeaponLagEntityDataTrait for WeaponLagEntityData {
    fn binding(&self) -> &WeaponLagBinding {
        &self.binding
    }
    fn binding_mut(&mut self) -> &mut WeaponLagBinding {
        &mut self.binding
    }
}

impl super::entity::EntityDataTrait for WeaponLagEntityData {
}

impl super::entity::GameObjectDataTrait for WeaponLagEntityData {
}

impl super::core::DataBusPeerTrait for WeaponLagEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for WeaponLagEntityData {
}

impl super::core::DataContainerTrait for WeaponLagEntityData {
}

pub static WEAPONLAGENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponLagEntityData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WeaponLagEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Binding",
                flags: MemberInfoFlags::new(0),
                field_type: "WeaponLagBinding",
                rust_offset: offset_of!(WeaponLagEntityData, binding),
            },
        ],
    }),
    array_type: Some(WEAPONLAGENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WeaponLagEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        WEAPONLAGENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WEAPONLAGENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponLagEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("WeaponLagEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WeaponLagBinding {
    pub entity_pitch: super::ant::AntRef,
    pub entity_yaw: super::ant::AntRef,
    pub pitch_result: super::ant::AntRef,
    pub yaw_result: super::ant::AntRef,
    pub roll_result: super::ant::AntRef,
}

pub trait WeaponLagBindingTrait: TypeObject {
    fn entity_pitch(&self) -> &super::ant::AntRef;
    fn entity_pitch_mut(&mut self) -> &mut super::ant::AntRef;
    fn entity_yaw(&self) -> &super::ant::AntRef;
    fn entity_yaw_mut(&mut self) -> &mut super::ant::AntRef;
    fn pitch_result(&self) -> &super::ant::AntRef;
    fn pitch_result_mut(&mut self) -> &mut super::ant::AntRef;
    fn yaw_result(&self) -> &super::ant::AntRef;
    fn yaw_result_mut(&mut self) -> &mut super::ant::AntRef;
    fn roll_result(&self) -> &super::ant::AntRef;
    fn roll_result_mut(&mut self) -> &mut super::ant::AntRef;
}

impl WeaponLagBindingTrait for WeaponLagBinding {
    fn entity_pitch(&self) -> &super::ant::AntRef {
        &self.entity_pitch
    }
    fn entity_pitch_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.entity_pitch
    }
    fn entity_yaw(&self) -> &super::ant::AntRef {
        &self.entity_yaw
    }
    fn entity_yaw_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.entity_yaw
    }
    fn pitch_result(&self) -> &super::ant::AntRef {
        &self.pitch_result
    }
    fn pitch_result_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.pitch_result
    }
    fn yaw_result(&self) -> &super::ant::AntRef {
        &self.yaw_result
    }
    fn yaw_result_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.yaw_result
    }
    fn roll_result(&self) -> &super::ant::AntRef {
        &self.roll_result
    }
    fn roll_result_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.roll_result
    }
}

pub static WEAPONLAGBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponLagBinding",
    flags: MemberInfoFlags::new(32841),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WeaponLagBinding as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "EntityPitch",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(WeaponLagBinding, entity_pitch),
            },
            FieldInfoData {
                name: "EntityYaw",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(WeaponLagBinding, entity_yaw),
            },
            FieldInfoData {
                name: "PitchResult",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(WeaponLagBinding, pitch_result),
            },
            FieldInfoData {
                name: "YawResult",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(WeaponLagBinding, yaw_result),
            },
            FieldInfoData {
                name: "RollResult",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(WeaponLagBinding, roll_result),
            },
        ],
    }),
    array_type: Some(WEAPONLAGBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for WeaponLagBinding {
    fn type_info(&self) -> &'static TypeInfo {
        WEAPONLAGBINDING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static WEAPONLAGBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponLagBinding-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("WeaponLagBinding"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoldierWeaponHudData {
    pub _glacier_base: super::gameplay_sim::HudData,
    pub reload_prompt: f32,
}

pub trait SoldierWeaponHudDataTrait: super::gameplay_sim::HudDataTrait {
    fn reload_prompt(&self) -> &f32;
    fn reload_prompt_mut(&mut self) -> &mut f32;
}

impl SoldierWeaponHudDataTrait for SoldierWeaponHudData {
    fn reload_prompt(&self) -> &f32 {
        &self.reload_prompt
    }
    fn reload_prompt_mut(&mut self) -> &mut f32 {
        &mut self.reload_prompt
    }
}

impl super::gameplay_sim::HudDataTrait for SoldierWeaponHudData {
}

impl super::core::DataContainerTrait for SoldierWeaponHudData {
}

pub static SOLDIERWEAPONHUDDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierWeaponHudData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::HUDDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierWeaponHudData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ReloadPrompt",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierWeaponHudData, reload_prompt),
            },
        ],
    }),
    array_type: Some(SOLDIERWEAPONHUDDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoldierWeaponHudData {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERWEAPONHUDDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOLDIERWEAPONHUDDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierWeaponHudData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SoldierWeaponHudData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WeaponStateData1p {
    pub _glacier_base: super::core::DataContainer,
    pub weapon_mesh1p: Vec<WeaponMesh1p>,
}

pub trait WeaponStateData1pTrait: super::core::DataContainerTrait {
    fn weapon_mesh1p(&self) -> &Vec<WeaponMesh1p>;
    fn weapon_mesh1p_mut(&mut self) -> &mut Vec<WeaponMesh1p>;
}

impl WeaponStateData1pTrait for WeaponStateData1p {
    fn weapon_mesh1p(&self) -> &Vec<WeaponMesh1p> {
        &self.weapon_mesh1p
    }
    fn weapon_mesh1p_mut(&mut self) -> &mut Vec<WeaponMesh1p> {
        &mut self.weapon_mesh1p
    }
}

impl super::core::DataContainerTrait for WeaponStateData1p {
}

pub static WEAPONSTATEDATA1P_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponStateData1p",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WeaponStateData1p as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "WeaponMesh1p",
                flags: MemberInfoFlags::new(144),
                field_type: "WeaponMesh1p-Array",
                rust_offset: offset_of!(WeaponStateData1p, weapon_mesh1p),
            },
        ],
    }),
    array_type: Some(WEAPONSTATEDATA1P_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WeaponStateData1p {
    fn type_info(&self) -> &'static TypeInfo {
        WEAPONSTATEDATA1P_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WEAPONSTATEDATA1P_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponStateData1p-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("WeaponStateData1p"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WeaponMesh1p {
    pub mesh: Option<Arc<Mutex<dyn super::render::SkinnedMeshAssetTrait>>>,
    pub mesh_zoom: Option<Arc<Mutex<dyn super::render::SkinnedMeshAssetTrait>>>,
}

pub trait WeaponMesh1pTrait: TypeObject {
    fn mesh(&self) -> &Option<Arc<Mutex<dyn super::render::SkinnedMeshAssetTrait>>>;
    fn mesh_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render::SkinnedMeshAssetTrait>>>;
    fn mesh_zoom(&self) -> &Option<Arc<Mutex<dyn super::render::SkinnedMeshAssetTrait>>>;
    fn mesh_zoom_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render::SkinnedMeshAssetTrait>>>;
}

impl WeaponMesh1pTrait for WeaponMesh1p {
    fn mesh(&self) -> &Option<Arc<Mutex<dyn super::render::SkinnedMeshAssetTrait>>> {
        &self.mesh
    }
    fn mesh_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render::SkinnedMeshAssetTrait>>> {
        &mut self.mesh
    }
    fn mesh_zoom(&self) -> &Option<Arc<Mutex<dyn super::render::SkinnedMeshAssetTrait>>> {
        &self.mesh_zoom
    }
    fn mesh_zoom_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render::SkinnedMeshAssetTrait>>> {
        &mut self.mesh_zoom
    }
}

pub static WEAPONMESH1P_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponMesh1p",
    flags: MemberInfoFlags::new(73),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WeaponMesh1p as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Mesh",
                flags: MemberInfoFlags::new(0),
                field_type: "SkinnedMeshAsset",
                rust_offset: offset_of!(WeaponMesh1p, mesh),
            },
            FieldInfoData {
                name: "MeshZoom",
                flags: MemberInfoFlags::new(0),
                field_type: "SkinnedMeshAsset",
                rust_offset: offset_of!(WeaponMesh1p, mesh_zoom),
            },
        ],
    }),
    array_type: Some(WEAPONMESH1P_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WeaponMesh1p {
    fn type_info(&self) -> &'static TypeInfo {
        WEAPONMESH1P_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static WEAPONMESH1P_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponMesh1p-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("WeaponMesh1p"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ExplosionPackTripwireTrigger {
    pub _glacier_base: ExplosionPackTrigger,
    pub tripwire: Option<Arc<Mutex<dyn TripwireEntityDataTrait>>>,
}

pub trait ExplosionPackTripwireTriggerTrait: ExplosionPackTriggerTrait {
    fn tripwire(&self) -> &Option<Arc<Mutex<dyn TripwireEntityDataTrait>>>;
    fn tripwire_mut(&mut self) -> &mut Option<Arc<Mutex<dyn TripwireEntityDataTrait>>>;
}

impl ExplosionPackTripwireTriggerTrait for ExplosionPackTripwireTrigger {
    fn tripwire(&self) -> &Option<Arc<Mutex<dyn TripwireEntityDataTrait>>> {
        &self.tripwire
    }
    fn tripwire_mut(&mut self) -> &mut Option<Arc<Mutex<dyn TripwireEntityDataTrait>>> {
        &mut self.tripwire
    }
}

impl ExplosionPackTriggerTrait for ExplosionPackTripwireTrigger {
}

impl super::core::DataContainerTrait for ExplosionPackTripwireTrigger {
}

pub static EXPLOSIONPACKTRIPWIRETRIGGER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExplosionPackTripwireTrigger",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(EXPLOSIONPACKTRIGGER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ExplosionPackTripwireTrigger as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Tripwire",
                flags: MemberInfoFlags::new(0),
                field_type: "TripwireEntityData",
                rust_offset: offset_of!(ExplosionPackTripwireTrigger, tripwire),
            },
        ],
    }),
    array_type: Some(EXPLOSIONPACKTRIPWIRETRIGGER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ExplosionPackTripwireTrigger {
    fn type_info(&self) -> &'static TypeInfo {
        EXPLOSIONPACKTRIPWIRETRIGGER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EXPLOSIONPACKTRIPWIRETRIGGER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExplosionPackTripwireTrigger-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("ExplosionPackTripwireTrigger"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TripwireEntityData {
    pub _glacier_base: super::entity::GameComponentEntityData,
    pub wire_mesh: Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>>,
    pub wire_mesh_scale: super::core::Vec3,
    pub wire_impact_material: super::entity::MaterialDecl,
    pub deploy_sound_effect: Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>,
    pub trip_sound_effect: Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>,
    pub max_wire_count: i32,
    pub wire_max_length: f32,
    pub wire_min_length: f32,
    pub wire_min2_d_length: f32,
    pub wire_min_vertical_offset: f32,
    pub wire_origin_offset: super::core::Vec3,
    pub min_yaw: f32,
    pub max_yaw: f32,
    pub min_pitch: f32,
    pub max_pitch: f32,
    pub density_angle: u32,
    pub attach_wires_to_neutral_vehicles: bool,
    pub attach_wires_to_hostile_vehicles: bool,
    pub attach_wires_to_friendly_vehicles: bool,
    pub force_trip_by_friendly_vehicles: bool,
    pub force_trip_by_friendly_soldiers: bool,
    pub wire_deploy_speed: f32,
}

pub trait TripwireEntityDataTrait: super::entity::GameComponentEntityDataTrait {
    fn wire_mesh(&self) -> &Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>>;
    fn wire_mesh_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>>;
    fn wire_mesh_scale(&self) -> &super::core::Vec3;
    fn wire_mesh_scale_mut(&mut self) -> &mut super::core::Vec3;
    fn wire_impact_material(&self) -> &super::entity::MaterialDecl;
    fn wire_impact_material_mut(&mut self) -> &mut super::entity::MaterialDecl;
    fn deploy_sound_effect(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn deploy_sound_effect_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn trip_sound_effect(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn trip_sound_effect_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn max_wire_count(&self) -> &i32;
    fn max_wire_count_mut(&mut self) -> &mut i32;
    fn wire_max_length(&self) -> &f32;
    fn wire_max_length_mut(&mut self) -> &mut f32;
    fn wire_min_length(&self) -> &f32;
    fn wire_min_length_mut(&mut self) -> &mut f32;
    fn wire_min2_d_length(&self) -> &f32;
    fn wire_min2_d_length_mut(&mut self) -> &mut f32;
    fn wire_min_vertical_offset(&self) -> &f32;
    fn wire_min_vertical_offset_mut(&mut self) -> &mut f32;
    fn wire_origin_offset(&self) -> &super::core::Vec3;
    fn wire_origin_offset_mut(&mut self) -> &mut super::core::Vec3;
    fn min_yaw(&self) -> &f32;
    fn min_yaw_mut(&mut self) -> &mut f32;
    fn max_yaw(&self) -> &f32;
    fn max_yaw_mut(&mut self) -> &mut f32;
    fn min_pitch(&self) -> &f32;
    fn min_pitch_mut(&mut self) -> &mut f32;
    fn max_pitch(&self) -> &f32;
    fn max_pitch_mut(&mut self) -> &mut f32;
    fn density_angle(&self) -> &u32;
    fn density_angle_mut(&mut self) -> &mut u32;
    fn attach_wires_to_neutral_vehicles(&self) -> &bool;
    fn attach_wires_to_neutral_vehicles_mut(&mut self) -> &mut bool;
    fn attach_wires_to_hostile_vehicles(&self) -> &bool;
    fn attach_wires_to_hostile_vehicles_mut(&mut self) -> &mut bool;
    fn attach_wires_to_friendly_vehicles(&self) -> &bool;
    fn attach_wires_to_friendly_vehicles_mut(&mut self) -> &mut bool;
    fn force_trip_by_friendly_vehicles(&self) -> &bool;
    fn force_trip_by_friendly_vehicles_mut(&mut self) -> &mut bool;
    fn force_trip_by_friendly_soldiers(&self) -> &bool;
    fn force_trip_by_friendly_soldiers_mut(&mut self) -> &mut bool;
    fn wire_deploy_speed(&self) -> &f32;
    fn wire_deploy_speed_mut(&mut self) -> &mut f32;
}

impl TripwireEntityDataTrait for TripwireEntityData {
    fn wire_mesh(&self) -> &Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>> {
        &self.wire_mesh
    }
    fn wire_mesh_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>> {
        &mut self.wire_mesh
    }
    fn wire_mesh_scale(&self) -> &super::core::Vec3 {
        &self.wire_mesh_scale
    }
    fn wire_mesh_scale_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.wire_mesh_scale
    }
    fn wire_impact_material(&self) -> &super::entity::MaterialDecl {
        &self.wire_impact_material
    }
    fn wire_impact_material_mut(&mut self) -> &mut super::entity::MaterialDecl {
        &mut self.wire_impact_material
    }
    fn deploy_sound_effect(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &self.deploy_sound_effect
    }
    fn deploy_sound_effect_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &mut self.deploy_sound_effect
    }
    fn trip_sound_effect(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &self.trip_sound_effect
    }
    fn trip_sound_effect_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &mut self.trip_sound_effect
    }
    fn max_wire_count(&self) -> &i32 {
        &self.max_wire_count
    }
    fn max_wire_count_mut(&mut self) -> &mut i32 {
        &mut self.max_wire_count
    }
    fn wire_max_length(&self) -> &f32 {
        &self.wire_max_length
    }
    fn wire_max_length_mut(&mut self) -> &mut f32 {
        &mut self.wire_max_length
    }
    fn wire_min_length(&self) -> &f32 {
        &self.wire_min_length
    }
    fn wire_min_length_mut(&mut self) -> &mut f32 {
        &mut self.wire_min_length
    }
    fn wire_min2_d_length(&self) -> &f32 {
        &self.wire_min2_d_length
    }
    fn wire_min2_d_length_mut(&mut self) -> &mut f32 {
        &mut self.wire_min2_d_length
    }
    fn wire_min_vertical_offset(&self) -> &f32 {
        &self.wire_min_vertical_offset
    }
    fn wire_min_vertical_offset_mut(&mut self) -> &mut f32 {
        &mut self.wire_min_vertical_offset
    }
    fn wire_origin_offset(&self) -> &super::core::Vec3 {
        &self.wire_origin_offset
    }
    fn wire_origin_offset_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.wire_origin_offset
    }
    fn min_yaw(&self) -> &f32 {
        &self.min_yaw
    }
    fn min_yaw_mut(&mut self) -> &mut f32 {
        &mut self.min_yaw
    }
    fn max_yaw(&self) -> &f32 {
        &self.max_yaw
    }
    fn max_yaw_mut(&mut self) -> &mut f32 {
        &mut self.max_yaw
    }
    fn min_pitch(&self) -> &f32 {
        &self.min_pitch
    }
    fn min_pitch_mut(&mut self) -> &mut f32 {
        &mut self.min_pitch
    }
    fn max_pitch(&self) -> &f32 {
        &self.max_pitch
    }
    fn max_pitch_mut(&mut self) -> &mut f32 {
        &mut self.max_pitch
    }
    fn density_angle(&self) -> &u32 {
        &self.density_angle
    }
    fn density_angle_mut(&mut self) -> &mut u32 {
        &mut self.density_angle
    }
    fn attach_wires_to_neutral_vehicles(&self) -> &bool {
        &self.attach_wires_to_neutral_vehicles
    }
    fn attach_wires_to_neutral_vehicles_mut(&mut self) -> &mut bool {
        &mut self.attach_wires_to_neutral_vehicles
    }
    fn attach_wires_to_hostile_vehicles(&self) -> &bool {
        &self.attach_wires_to_hostile_vehicles
    }
    fn attach_wires_to_hostile_vehicles_mut(&mut self) -> &mut bool {
        &mut self.attach_wires_to_hostile_vehicles
    }
    fn attach_wires_to_friendly_vehicles(&self) -> &bool {
        &self.attach_wires_to_friendly_vehicles
    }
    fn attach_wires_to_friendly_vehicles_mut(&mut self) -> &mut bool {
        &mut self.attach_wires_to_friendly_vehicles
    }
    fn force_trip_by_friendly_vehicles(&self) -> &bool {
        &self.force_trip_by_friendly_vehicles
    }
    fn force_trip_by_friendly_vehicles_mut(&mut self) -> &mut bool {
        &mut self.force_trip_by_friendly_vehicles
    }
    fn force_trip_by_friendly_soldiers(&self) -> &bool {
        &self.force_trip_by_friendly_soldiers
    }
    fn force_trip_by_friendly_soldiers_mut(&mut self) -> &mut bool {
        &mut self.force_trip_by_friendly_soldiers
    }
    fn wire_deploy_speed(&self) -> &f32 {
        &self.wire_deploy_speed
    }
    fn wire_deploy_speed_mut(&mut self) -> &mut f32 {
        &mut self.wire_deploy_speed
    }
}

impl super::entity::GameComponentEntityDataTrait for TripwireEntityData {
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::ComponentEntityDataTrait for TripwireEntityData {
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn part_bounding_boxes(&self) -> &Vec<super::core::AxisAlignedBox> {
        self._glacier_base.part_bounding_boxes()
    }
    fn part_bounding_boxes_mut(&mut self) -> &mut Vec<super::core::AxisAlignedBox> {
        self._glacier_base.part_bounding_boxes_mut()
    }
    fn client_runtime_component_count(&self) -> &u8 {
        self._glacier_base.client_runtime_component_count()
    }
    fn client_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_component_count_mut()
    }
    fn server_runtime_component_count(&self) -> &u8 {
        self._glacier_base.server_runtime_component_count()
    }
    fn server_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_component_count_mut()
    }
    fn client_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.client_runtime_transformation_count()
    }
    fn client_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_transformation_count_mut()
    }
    fn server_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.server_runtime_transformation_count()
    }
    fn server_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_transformation_count_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for TripwireEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for TripwireEntityData {
}

impl super::entity::GameObjectDataTrait for TripwireEntityData {
}

impl super::core::DataBusPeerTrait for TripwireEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TripwireEntityData {
}

impl super::core::DataContainerTrait for TripwireEntityData {
}

pub static TRIPWIREENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TripwireEntityData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TripwireEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "WireMesh",
                flags: MemberInfoFlags::new(0),
                field_type: "ObjectBlueprint",
                rust_offset: offset_of!(TripwireEntityData, wire_mesh),
            },
            FieldInfoData {
                name: "WireMeshScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(TripwireEntityData, wire_mesh_scale),
            },
            FieldInfoData {
                name: "WireImpactMaterial",
                flags: MemberInfoFlags::new(0),
                field_type: "MaterialDecl",
                rust_offset: offset_of!(TripwireEntityData, wire_impact_material),
            },
            FieldInfoData {
                name: "DeploySoundEffect",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(TripwireEntityData, deploy_sound_effect),
            },
            FieldInfoData {
                name: "TripSoundEffect",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(TripwireEntityData, trip_sound_effect),
            },
            FieldInfoData {
                name: "MaxWireCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(TripwireEntityData, max_wire_count),
            },
            FieldInfoData {
                name: "WireMaxLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TripwireEntityData, wire_max_length),
            },
            FieldInfoData {
                name: "WireMinLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TripwireEntityData, wire_min_length),
            },
            FieldInfoData {
                name: "WireMin2DLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TripwireEntityData, wire_min2_d_length),
            },
            FieldInfoData {
                name: "WireMinVerticalOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TripwireEntityData, wire_min_vertical_offset),
            },
            FieldInfoData {
                name: "WireOriginOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(TripwireEntityData, wire_origin_offset),
            },
            FieldInfoData {
                name: "MinYaw",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TripwireEntityData, min_yaw),
            },
            FieldInfoData {
                name: "MaxYaw",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TripwireEntityData, max_yaw),
            },
            FieldInfoData {
                name: "MinPitch",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TripwireEntityData, min_pitch),
            },
            FieldInfoData {
                name: "MaxPitch",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TripwireEntityData, max_pitch),
            },
            FieldInfoData {
                name: "DensityAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(TripwireEntityData, density_angle),
            },
            FieldInfoData {
                name: "AttachWiresToNeutralVehicles",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TripwireEntityData, attach_wires_to_neutral_vehicles),
            },
            FieldInfoData {
                name: "AttachWiresToHostileVehicles",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TripwireEntityData, attach_wires_to_hostile_vehicles),
            },
            FieldInfoData {
                name: "AttachWiresToFriendlyVehicles",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TripwireEntityData, attach_wires_to_friendly_vehicles),
            },
            FieldInfoData {
                name: "ForceTripByFriendlyVehicles",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TripwireEntityData, force_trip_by_friendly_vehicles),
            },
            FieldInfoData {
                name: "ForceTripByFriendlySoldiers",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TripwireEntityData, force_trip_by_friendly_soldiers),
            },
            FieldInfoData {
                name: "WireDeploySpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TripwireEntityData, wire_deploy_speed),
            },
        ],
    }),
    array_type: Some(TRIPWIREENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for TripwireEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TRIPWIREENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TRIPWIREENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TripwireEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("TripwireEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoldierWeaponBlueprintBundle {
    pub _glacier_base: super::gameplay_sim::BlueprintBundle,
    pub ant_state_assets: Vec<Option<Arc<Mutex<dyn super::ant::AntStateAssetTrait>>>>,
}

pub trait SoldierWeaponBlueprintBundleTrait: super::gameplay_sim::BlueprintBundleTrait {
    fn ant_state_assets(&self) -> &Vec<Option<Arc<Mutex<dyn super::ant::AntStateAssetTrait>>>>;
    fn ant_state_assets_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::ant::AntStateAssetTrait>>>>;
}

impl SoldierWeaponBlueprintBundleTrait for SoldierWeaponBlueprintBundle {
    fn ant_state_assets(&self) -> &Vec<Option<Arc<Mutex<dyn super::ant::AntStateAssetTrait>>>> {
        &self.ant_state_assets
    }
    fn ant_state_assets_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::ant::AntStateAssetTrait>>>> {
        &mut self.ant_state_assets
    }
}

impl super::gameplay_sim::BlueprintBundleTrait for SoldierWeaponBlueprintBundle {
    fn blueprint(&self) -> &Option<Arc<Mutex<dyn super::entity::BlueprintTrait>>> {
        self._glacier_base.blueprint()
    }
    fn blueprint_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::BlueprintTrait>>> {
        self._glacier_base.blueprint_mut()
    }
}

impl super::entity::SharedBundleBaseAssetTrait for SoldierWeaponBlueprintBundle {
}

impl super::core::AssetTrait for SoldierWeaponBlueprintBundle {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for SoldierWeaponBlueprintBundle {
}

pub static SOLDIERWEAPONBLUEPRINTBUNDLE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierWeaponBlueprintBundle",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::BLUEPRINTBUNDLE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierWeaponBlueprintBundle as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AntStateAssets",
                flags: MemberInfoFlags::new(144),
                field_type: "AntStateAsset-Array",
                rust_offset: offset_of!(SoldierWeaponBlueprintBundle, ant_state_assets),
            },
        ],
    }),
    array_type: Some(SOLDIERWEAPONBLUEPRINTBUNDLE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoldierWeaponBlueprintBundle {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERWEAPONBLUEPRINTBUNDLE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOLDIERWEAPONBLUEPRINTBUNDLE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierWeaponBlueprintBundle-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SoldierWeaponBlueprintBundle"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WeaponSkinnedSocketObjectData {
    pub _glacier_base: WeaponSocketObjectData,
}

pub trait WeaponSkinnedSocketObjectDataTrait: WeaponSocketObjectDataTrait {
}

impl WeaponSkinnedSocketObjectDataTrait for WeaponSkinnedSocketObjectData {
}

impl WeaponSocketObjectDataTrait for WeaponSkinnedSocketObjectData {
    fn used_common(&self) -> &Option<Arc<Mutex<dyn super::core::AssetTrait>>> {
        self._glacier_base.used_common()
    }
    fn used_common_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::AssetTrait>>> {
        self._glacier_base.used_common_mut()
    }
    fn used1p(&self) -> &Option<Arc<Mutex<dyn super::core::AssetTrait>>> {
        self._glacier_base.used1p()
    }
    fn used1p_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::AssetTrait>>> {
        self._glacier_base.used1p_mut()
    }
    fn used1p_zoom(&self) -> &Option<Arc<Mutex<dyn super::core::AssetTrait>>> {
        self._glacier_base.used1p_zoom()
    }
    fn used1p_zoom_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::AssetTrait>>> {
        self._glacier_base.used1p_zoom_mut()
    }
    fn used3p(&self) -> &Option<Arc<Mutex<dyn super::core::AssetTrait>>> {
        self._glacier_base.used3p()
    }
    fn used3p_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::AssetTrait>>> {
        self._glacier_base.used3p_mut()
    }
    fn used3p_zoom(&self) -> &Option<Arc<Mutex<dyn super::core::AssetTrait>>> {
        self._glacier_base.used3p_zoom()
    }
    fn used3p_zoom_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::AssetTrait>>> {
        self._glacier_base.used3p_zoom_mut()
    }
}

impl SocketObjectDataBaseTrait for WeaponSkinnedSocketObjectData {
}

impl super::core::DataContainerTrait for WeaponSkinnedSocketObjectData {
}

pub static WEAPONSKINNEDSOCKETOBJECTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponSkinnedSocketObjectData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(WEAPONSOCKETOBJECTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WeaponSkinnedSocketObjectData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(WEAPONSKINNEDSOCKETOBJECTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WeaponSkinnedSocketObjectData {
    fn type_info(&self) -> &'static TypeInfo {
        WEAPONSKINNEDSOCKETOBJECTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WEAPONSKINNEDSOCKETOBJECTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponSkinnedSocketObjectData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("WeaponSkinnedSocketObjectData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WeaponRegularSocketObjectData {
    pub _glacier_base: WeaponSocketObjectData,
    pub transform: super::core::LinearTransform,
    pub mesh3p_transforms: Vec<super::core::SparseTransformArray>,
}

pub trait WeaponRegularSocketObjectDataTrait: WeaponSocketObjectDataTrait {
    fn transform(&self) -> &super::core::LinearTransform;
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform;
    fn mesh3p_transforms(&self) -> &Vec<super::core::SparseTransformArray>;
    fn mesh3p_transforms_mut(&mut self) -> &mut Vec<super::core::SparseTransformArray>;
}

impl WeaponRegularSocketObjectDataTrait for WeaponRegularSocketObjectData {
    fn transform(&self) -> &super::core::LinearTransform {
        &self.transform
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.transform
    }
    fn mesh3p_transforms(&self) -> &Vec<super::core::SparseTransformArray> {
        &self.mesh3p_transforms
    }
    fn mesh3p_transforms_mut(&mut self) -> &mut Vec<super::core::SparseTransformArray> {
        &mut self.mesh3p_transforms
    }
}

impl WeaponSocketObjectDataTrait for WeaponRegularSocketObjectData {
    fn used_common(&self) -> &Option<Arc<Mutex<dyn super::core::AssetTrait>>> {
        self._glacier_base.used_common()
    }
    fn used_common_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::AssetTrait>>> {
        self._glacier_base.used_common_mut()
    }
    fn used1p(&self) -> &Option<Arc<Mutex<dyn super::core::AssetTrait>>> {
        self._glacier_base.used1p()
    }
    fn used1p_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::AssetTrait>>> {
        self._glacier_base.used1p_mut()
    }
    fn used1p_zoom(&self) -> &Option<Arc<Mutex<dyn super::core::AssetTrait>>> {
        self._glacier_base.used1p_zoom()
    }
    fn used1p_zoom_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::AssetTrait>>> {
        self._glacier_base.used1p_zoom_mut()
    }
    fn used3p(&self) -> &Option<Arc<Mutex<dyn super::core::AssetTrait>>> {
        self._glacier_base.used3p()
    }
    fn used3p_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::AssetTrait>>> {
        self._glacier_base.used3p_mut()
    }
    fn used3p_zoom(&self) -> &Option<Arc<Mutex<dyn super::core::AssetTrait>>> {
        self._glacier_base.used3p_zoom()
    }
    fn used3p_zoom_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::AssetTrait>>> {
        self._glacier_base.used3p_zoom_mut()
    }
}

impl SocketObjectDataBaseTrait for WeaponRegularSocketObjectData {
}

impl super::core::DataContainerTrait for WeaponRegularSocketObjectData {
}

pub static WEAPONREGULARSOCKETOBJECTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponRegularSocketObjectData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(WEAPONSOCKETOBJECTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WeaponRegularSocketObjectData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Transform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(WeaponRegularSocketObjectData, transform),
            },
            FieldInfoData {
                name: "Mesh3pTransforms",
                flags: MemberInfoFlags::new(144),
                field_type: "SparseTransformArray-Array",
                rust_offset: offset_of!(WeaponRegularSocketObjectData, mesh3p_transforms),
            },
        ],
    }),
    array_type: Some(WEAPONREGULARSOCKETOBJECTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for WeaponRegularSocketObjectData {
    fn type_info(&self) -> &'static TypeInfo {
        WEAPONREGULARSOCKETOBJECTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WEAPONREGULARSOCKETOBJECTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponRegularSocketObjectData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("WeaponRegularSocketObjectData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WeaponSocketObjectData {
    pub _glacier_base: SocketObjectDataBase,
    pub used_common: Option<Arc<Mutex<dyn super::core::AssetTrait>>>,
    pub used1p: Option<Arc<Mutex<dyn super::core::AssetTrait>>>,
    pub used1p_zoom: Option<Arc<Mutex<dyn super::core::AssetTrait>>>,
    pub used3p: Option<Arc<Mutex<dyn super::core::AssetTrait>>>,
    pub used3p_zoom: Option<Arc<Mutex<dyn super::core::AssetTrait>>>,
}

pub trait WeaponSocketObjectDataTrait: SocketObjectDataBaseTrait {
    fn used_common(&self) -> &Option<Arc<Mutex<dyn super::core::AssetTrait>>>;
    fn used_common_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::AssetTrait>>>;
    fn used1p(&self) -> &Option<Arc<Mutex<dyn super::core::AssetTrait>>>;
    fn used1p_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::AssetTrait>>>;
    fn used1p_zoom(&self) -> &Option<Arc<Mutex<dyn super::core::AssetTrait>>>;
    fn used1p_zoom_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::AssetTrait>>>;
    fn used3p(&self) -> &Option<Arc<Mutex<dyn super::core::AssetTrait>>>;
    fn used3p_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::AssetTrait>>>;
    fn used3p_zoom(&self) -> &Option<Arc<Mutex<dyn super::core::AssetTrait>>>;
    fn used3p_zoom_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::AssetTrait>>>;
}

impl WeaponSocketObjectDataTrait for WeaponSocketObjectData {
    fn used_common(&self) -> &Option<Arc<Mutex<dyn super::core::AssetTrait>>> {
        &self.used_common
    }
    fn used_common_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::AssetTrait>>> {
        &mut self.used_common
    }
    fn used1p(&self) -> &Option<Arc<Mutex<dyn super::core::AssetTrait>>> {
        &self.used1p
    }
    fn used1p_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::AssetTrait>>> {
        &mut self.used1p
    }
    fn used1p_zoom(&self) -> &Option<Arc<Mutex<dyn super::core::AssetTrait>>> {
        &self.used1p_zoom
    }
    fn used1p_zoom_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::AssetTrait>>> {
        &mut self.used1p_zoom
    }
    fn used3p(&self) -> &Option<Arc<Mutex<dyn super::core::AssetTrait>>> {
        &self.used3p
    }
    fn used3p_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::AssetTrait>>> {
        &mut self.used3p
    }
    fn used3p_zoom(&self) -> &Option<Arc<Mutex<dyn super::core::AssetTrait>>> {
        &self.used3p_zoom
    }
    fn used3p_zoom_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::AssetTrait>>> {
        &mut self.used3p_zoom
    }
}

impl SocketObjectDataBaseTrait for WeaponSocketObjectData {
}

impl super::core::DataContainerTrait for WeaponSocketObjectData {
}

pub static WEAPONSOCKETOBJECTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponSocketObjectData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOCKETOBJECTDATABASE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WeaponSocketObjectData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "UsedCommon",
                flags: MemberInfoFlags::new(0),
                field_type: "Asset",
                rust_offset: offset_of!(WeaponSocketObjectData, used_common),
            },
            FieldInfoData {
                name: "Used1p",
                flags: MemberInfoFlags::new(0),
                field_type: "Asset",
                rust_offset: offset_of!(WeaponSocketObjectData, used1p),
            },
            FieldInfoData {
                name: "Used1pZoom",
                flags: MemberInfoFlags::new(0),
                field_type: "Asset",
                rust_offset: offset_of!(WeaponSocketObjectData, used1p_zoom),
            },
            FieldInfoData {
                name: "Used3p",
                flags: MemberInfoFlags::new(0),
                field_type: "Asset",
                rust_offset: offset_of!(WeaponSocketObjectData, used3p),
            },
            FieldInfoData {
                name: "Used3pZoom",
                flags: MemberInfoFlags::new(0),
                field_type: "Asset",
                rust_offset: offset_of!(WeaponSocketObjectData, used3p_zoom),
            },
        ],
    }),
    array_type: Some(WEAPONSOCKETOBJECTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WeaponSocketObjectData {
    fn type_info(&self) -> &'static TypeInfo {
        WEAPONSOCKETOBJECTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WEAPONSOCKETOBJECTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponSocketObjectData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("WeaponSocketObjectData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WeaponModifierData {
    pub unlock_asset_guid: glacier_util::guid::Guid,
    pub modifiers: Vec<Option<Arc<Mutex<dyn super::weapon_shared::WeaponModifierBaseTrait>>>>,
}

pub trait WeaponModifierDataTrait: TypeObject {
    fn unlock_asset_guid(&self) -> &glacier_util::guid::Guid;
    fn unlock_asset_guid_mut(&mut self) -> &mut glacier_util::guid::Guid;
    fn modifiers(&self) -> &Vec<Option<Arc<Mutex<dyn super::weapon_shared::WeaponModifierBaseTrait>>>>;
    fn modifiers_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::weapon_shared::WeaponModifierBaseTrait>>>>;
}

impl WeaponModifierDataTrait for WeaponModifierData {
    fn unlock_asset_guid(&self) -> &glacier_util::guid::Guid {
        &self.unlock_asset_guid
    }
    fn unlock_asset_guid_mut(&mut self) -> &mut glacier_util::guid::Guid {
        &mut self.unlock_asset_guid
    }
    fn modifiers(&self) -> &Vec<Option<Arc<Mutex<dyn super::weapon_shared::WeaponModifierBaseTrait>>>> {
        &self.modifiers
    }
    fn modifiers_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::weapon_shared::WeaponModifierBaseTrait>>>> {
        &mut self.modifiers
    }
}

pub static WEAPONMODIFIERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponModifierData",
    flags: MemberInfoFlags::new(73),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WeaponModifierData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "UnlockAssetGuid",
                flags: MemberInfoFlags::new(0),
                field_type: "Guid",
                rust_offset: offset_of!(WeaponModifierData, unlock_asset_guid),
            },
            FieldInfoData {
                name: "Modifiers",
                flags: MemberInfoFlags::new(144),
                field_type: "WeaponModifierBase-Array",
                rust_offset: offset_of!(WeaponModifierData, modifiers),
            },
        ],
    }),
    array_type: Some(WEAPONMODIFIERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WeaponModifierData {
    fn type_info(&self) -> &'static TypeInfo {
        WEAPONMODIFIERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static WEAPONMODIFIERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponModifierData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("WeaponModifierData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ClientSoldierWeaponWeaponModifierChangedMessage {
}

pub trait ClientSoldierWeaponWeaponModifierChangedMessageTrait: TypeObject {
}

impl ClientSoldierWeaponWeaponModifierChangedMessageTrait for ClientSoldierWeaponWeaponModifierChangedMessage {
}

pub static CLIENTSOLDIERWEAPONWEAPONMODIFIERCHANGEDMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClientSoldierWeaponWeaponModifierChangedMessage",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ClientSoldierWeaponWeaponModifierChangedMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for ClientSoldierWeaponWeaponModifierChangedMessage {
    fn type_info(&self) -> &'static TypeInfo {
        CLIENTSOLDIERWEAPONWEAPONMODIFIERCHANGEDMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Clone, Debug, Default)]
pub struct ServerSoldierWeaponWeaponModifierChangedMessage {
}

pub trait ServerSoldierWeaponWeaponModifierChangedMessageTrait: TypeObject {
}

impl ServerSoldierWeaponWeaponModifierChangedMessageTrait for ServerSoldierWeaponWeaponModifierChangedMessage {
}

pub static SERVERSOLDIERWEAPONWEAPONMODIFIERCHANGEDMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ServerSoldierWeaponWeaponModifierChangedMessage",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ServerSoldierWeaponWeaponModifierChangedMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for ServerSoldierWeaponWeaponModifierChangedMessage {
    fn type_info(&self) -> &'static TypeInfo {
        SERVERSOLDIERWEAPONWEAPONMODIFIERCHANGEDMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Clone, Debug, Default)]
pub struct WeaponAIDataModifier {
    pub _glacier_base: super::weapon_shared::WeaponModifierBase,
    pub a_i_data: Option<Arc<Mutex<dyn super::gameplay_sim::GameAIWeaponDataTrait>>>,
}

pub trait WeaponAIDataModifierTrait: super::weapon_shared::WeaponModifierBaseTrait {
    fn a_i_data(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::GameAIWeaponDataTrait>>>;
    fn a_i_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::GameAIWeaponDataTrait>>>;
}

impl WeaponAIDataModifierTrait for WeaponAIDataModifier {
    fn a_i_data(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::GameAIWeaponDataTrait>>> {
        &self.a_i_data
    }
    fn a_i_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::GameAIWeaponDataTrait>>> {
        &mut self.a_i_data
    }
}

impl super::weapon_shared::WeaponModifierBaseTrait for WeaponAIDataModifier {
    fn apply_order(&self) -> &i32 {
        self._glacier_base.apply_order()
    }
    fn apply_order_mut(&mut self) -> &mut i32 {
        self._glacier_base.apply_order_mut()
    }
    fn dynamic_update_enabled(&self) -> &bool {
        self._glacier_base.dynamic_update_enabled()
    }
    fn dynamic_update_enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.dynamic_update_enabled_mut()
    }
}

impl super::core::DataContainerTrait for WeaponAIDataModifier {
}

pub static WEAPONAIDATAMODIFIER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponAIDataModifier",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::weapon_shared::WEAPONMODIFIERBASE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WeaponAIDataModifier as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AIData",
                flags: MemberInfoFlags::new(0),
                field_type: "GameAIWeaponData",
                rust_offset: offset_of!(WeaponAIDataModifier, a_i_data),
            },
        ],
    }),
    array_type: Some(WEAPONAIDATAMODIFIER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WeaponAIDataModifier {
    fn type_info(&self) -> &'static TypeInfo {
        WEAPONAIDATAMODIFIER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WEAPONAIDATAMODIFIER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponAIDataModifier-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("WeaponAIDataModifier"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WeaponSprintSettingsModifier {
    pub _glacier_base: super::weapon_shared::WeaponModifierBase,
    pub sprint_settings: Option<Arc<Mutex<dyn WeaponSprintSettingsTrait>>>,
}

pub trait WeaponSprintSettingsModifierTrait: super::weapon_shared::WeaponModifierBaseTrait {
    fn sprint_settings(&self) -> &Option<Arc<Mutex<dyn WeaponSprintSettingsTrait>>>;
    fn sprint_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn WeaponSprintSettingsTrait>>>;
}

impl WeaponSprintSettingsModifierTrait for WeaponSprintSettingsModifier {
    fn sprint_settings(&self) -> &Option<Arc<Mutex<dyn WeaponSprintSettingsTrait>>> {
        &self.sprint_settings
    }
    fn sprint_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn WeaponSprintSettingsTrait>>> {
        &mut self.sprint_settings
    }
}

impl super::weapon_shared::WeaponModifierBaseTrait for WeaponSprintSettingsModifier {
    fn apply_order(&self) -> &i32 {
        self._glacier_base.apply_order()
    }
    fn apply_order_mut(&mut self) -> &mut i32 {
        self._glacier_base.apply_order_mut()
    }
    fn dynamic_update_enabled(&self) -> &bool {
        self._glacier_base.dynamic_update_enabled()
    }
    fn dynamic_update_enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.dynamic_update_enabled_mut()
    }
}

impl super::core::DataContainerTrait for WeaponSprintSettingsModifier {
}

pub static WEAPONSPRINTSETTINGSMODIFIER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponSprintSettingsModifier",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::weapon_shared::WEAPONMODIFIERBASE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WeaponSprintSettingsModifier as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SprintSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "WeaponSprintSettings",
                rust_offset: offset_of!(WeaponSprintSettingsModifier, sprint_settings),
            },
        ],
    }),
    array_type: Some(WEAPONSPRINTSETTINGSMODIFIER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WeaponSprintSettingsModifier {
    fn type_info(&self) -> &'static TypeInfo {
        WEAPONSPRINTSETTINGSMODIFIER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WEAPONSPRINTSETTINGSMODIFIER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponSprintSettingsModifier-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("WeaponSprintSettingsModifier"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WeaponSocketModifier {
    pub _glacier_base: super::weapon_shared::WeaponModifierDynamicBase,
    pub socket_hash: Vec<u32>,
}

pub trait WeaponSocketModifierTrait: super::weapon_shared::WeaponModifierDynamicBaseTrait {
    fn socket_hash(&self) -> &Vec<u32>;
    fn socket_hash_mut(&mut self) -> &mut Vec<u32>;
}

impl WeaponSocketModifierTrait for WeaponSocketModifier {
    fn socket_hash(&self) -> &Vec<u32> {
        &self.socket_hash
    }
    fn socket_hash_mut(&mut self) -> &mut Vec<u32> {
        &mut self.socket_hash
    }
}

impl super::weapon_shared::WeaponModifierDynamicBaseTrait for WeaponSocketModifier {
}

impl super::weapon_shared::WeaponModifierBaseTrait for WeaponSocketModifier {
    fn apply_order(&self) -> &i32 {
        self._glacier_base.apply_order()
    }
    fn apply_order_mut(&mut self) -> &mut i32 {
        self._glacier_base.apply_order_mut()
    }
    fn dynamic_update_enabled(&self) -> &bool {
        self._glacier_base.dynamic_update_enabled()
    }
    fn dynamic_update_enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.dynamic_update_enabled_mut()
    }
}

impl super::core::DataContainerTrait for WeaponSocketModifier {
}

pub static WEAPONSOCKETMODIFIER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponSocketModifier",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::weapon_shared::WEAPONMODIFIERDYNAMICBASE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WeaponSocketModifier as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SocketHash",
                flags: MemberInfoFlags::new(144),
                field_type: "Uint32-Array",
                rust_offset: offset_of!(WeaponSocketModifier, socket_hash),
            },
        ],
    }),
    array_type: Some(WEAPONSOCKETMODIFIER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WeaponSocketModifier {
    fn type_info(&self) -> &'static TypeInfo {
        WEAPONSOCKETMODIFIER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WEAPONSOCKETMODIFIER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponSocketModifier-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("WeaponSocketModifier"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WeaponAnimBaseModifier {
    pub _glacier_base: super::weapon_shared::WeaponModifierBase,
    pub anim_base_set: WeaponAnimBaseSetEnum,
}

pub trait WeaponAnimBaseModifierTrait: super::weapon_shared::WeaponModifierBaseTrait {
    fn anim_base_set(&self) -> &WeaponAnimBaseSetEnum;
    fn anim_base_set_mut(&mut self) -> &mut WeaponAnimBaseSetEnum;
}

impl WeaponAnimBaseModifierTrait for WeaponAnimBaseModifier {
    fn anim_base_set(&self) -> &WeaponAnimBaseSetEnum {
        &self.anim_base_set
    }
    fn anim_base_set_mut(&mut self) -> &mut WeaponAnimBaseSetEnum {
        &mut self.anim_base_set
    }
}

impl super::weapon_shared::WeaponModifierBaseTrait for WeaponAnimBaseModifier {
    fn apply_order(&self) -> &i32 {
        self._glacier_base.apply_order()
    }
    fn apply_order_mut(&mut self) -> &mut i32 {
        self._glacier_base.apply_order_mut()
    }
    fn dynamic_update_enabled(&self) -> &bool {
        self._glacier_base.dynamic_update_enabled()
    }
    fn dynamic_update_enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.dynamic_update_enabled_mut()
    }
}

impl super::core::DataContainerTrait for WeaponAnimBaseModifier {
}

pub static WEAPONANIMBASEMODIFIER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponAnimBaseModifier",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::weapon_shared::WEAPONMODIFIERBASE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WeaponAnimBaseModifier as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AnimBaseSet",
                flags: MemberInfoFlags::new(0),
                field_type: "WeaponAnimBaseSetEnum",
                rust_offset: offset_of!(WeaponAnimBaseModifier, anim_base_set),
            },
        ],
    }),
    array_type: Some(WEAPONANIMBASEMODIFIER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WeaponAnimBaseModifier {
    fn type_info(&self) -> &'static TypeInfo {
        WEAPONANIMBASEMODIFIER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WEAPONANIMBASEMODIFIER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponAnimBaseModifier-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("WeaponAnimBaseModifier"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CustomWeaponTypeModifier {
    pub _glacier_base: super::weapon_shared::WeaponModifierBase,
    pub custom_weapon_type: Option<Arc<Mutex<dyn super::weapon_shared::WeaponDataTrait>>>,
}

pub trait CustomWeaponTypeModifierTrait: super::weapon_shared::WeaponModifierBaseTrait {
    fn custom_weapon_type(&self) -> &Option<Arc<Mutex<dyn super::weapon_shared::WeaponDataTrait>>>;
    fn custom_weapon_type_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::weapon_shared::WeaponDataTrait>>>;
}

impl CustomWeaponTypeModifierTrait for CustomWeaponTypeModifier {
    fn custom_weapon_type(&self) -> &Option<Arc<Mutex<dyn super::weapon_shared::WeaponDataTrait>>> {
        &self.custom_weapon_type
    }
    fn custom_weapon_type_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::weapon_shared::WeaponDataTrait>>> {
        &mut self.custom_weapon_type
    }
}

impl super::weapon_shared::WeaponModifierBaseTrait for CustomWeaponTypeModifier {
    fn apply_order(&self) -> &i32 {
        self._glacier_base.apply_order()
    }
    fn apply_order_mut(&mut self) -> &mut i32 {
        self._glacier_base.apply_order_mut()
    }
    fn dynamic_update_enabled(&self) -> &bool {
        self._glacier_base.dynamic_update_enabled()
    }
    fn dynamic_update_enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.dynamic_update_enabled_mut()
    }
}

impl super::core::DataContainerTrait for CustomWeaponTypeModifier {
}

pub static CUSTOMWEAPONTYPEMODIFIER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomWeaponTypeModifier",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::weapon_shared::WEAPONMODIFIERBASE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CustomWeaponTypeModifier as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "CustomWeaponType",
                flags: MemberInfoFlags::new(0),
                field_type: "WeaponData",
                rust_offset: offset_of!(CustomWeaponTypeModifier, custom_weapon_type),
            },
        ],
    }),
    array_type: Some(CUSTOMWEAPONTYPEMODIFIER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CustomWeaponTypeModifier {
    fn type_info(&self) -> &'static TypeInfo {
        CUSTOMWEAPONTYPEMODIFIER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CUSTOMWEAPONTYPEMODIFIER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomWeaponTypeModifier-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("CustomWeaponTypeModifier"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WeaponZoomLevelModifier {
    pub _glacier_base: super::weapon_shared::WeaponModifierDynamicBase,
    pub zoom_level_index: i32,
    pub zoom_level: Option<Arc<Mutex<dyn ZoomLevelDataTrait>>>,
    pub weapon_zoom_level: Option<Arc<Mutex<dyn WeaponZoomLevelDataTrait>>>,
}

pub trait WeaponZoomLevelModifierTrait: super::weapon_shared::WeaponModifierDynamicBaseTrait {
    fn zoom_level_index(&self) -> &i32;
    fn zoom_level_index_mut(&mut self) -> &mut i32;
    fn zoom_level(&self) -> &Option<Arc<Mutex<dyn ZoomLevelDataTrait>>>;
    fn zoom_level_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ZoomLevelDataTrait>>>;
    fn weapon_zoom_level(&self) -> &Option<Arc<Mutex<dyn WeaponZoomLevelDataTrait>>>;
    fn weapon_zoom_level_mut(&mut self) -> &mut Option<Arc<Mutex<dyn WeaponZoomLevelDataTrait>>>;
}

impl WeaponZoomLevelModifierTrait for WeaponZoomLevelModifier {
    fn zoom_level_index(&self) -> &i32 {
        &self.zoom_level_index
    }
    fn zoom_level_index_mut(&mut self) -> &mut i32 {
        &mut self.zoom_level_index
    }
    fn zoom_level(&self) -> &Option<Arc<Mutex<dyn ZoomLevelDataTrait>>> {
        &self.zoom_level
    }
    fn zoom_level_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ZoomLevelDataTrait>>> {
        &mut self.zoom_level
    }
    fn weapon_zoom_level(&self) -> &Option<Arc<Mutex<dyn WeaponZoomLevelDataTrait>>> {
        &self.weapon_zoom_level
    }
    fn weapon_zoom_level_mut(&mut self) -> &mut Option<Arc<Mutex<dyn WeaponZoomLevelDataTrait>>> {
        &mut self.weapon_zoom_level
    }
}

impl super::weapon_shared::WeaponModifierDynamicBaseTrait for WeaponZoomLevelModifier {
}

impl super::weapon_shared::WeaponModifierBaseTrait for WeaponZoomLevelModifier {
    fn apply_order(&self) -> &i32 {
        self._glacier_base.apply_order()
    }
    fn apply_order_mut(&mut self) -> &mut i32 {
        self._glacier_base.apply_order_mut()
    }
    fn dynamic_update_enabled(&self) -> &bool {
        self._glacier_base.dynamic_update_enabled()
    }
    fn dynamic_update_enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.dynamic_update_enabled_mut()
    }
}

impl super::core::DataContainerTrait for WeaponZoomLevelModifier {
}

pub static WEAPONZOOMLEVELMODIFIER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponZoomLevelModifier",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::weapon_shared::WEAPONMODIFIERDYNAMICBASE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WeaponZoomLevelModifier as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ZoomLevelIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(WeaponZoomLevelModifier, zoom_level_index),
            },
            FieldInfoData {
                name: "ZoomLevel",
                flags: MemberInfoFlags::new(0),
                field_type: "ZoomLevelData",
                rust_offset: offset_of!(WeaponZoomLevelModifier, zoom_level),
            },
            FieldInfoData {
                name: "WeaponZoomLevel",
                flags: MemberInfoFlags::new(0),
                field_type: "WeaponZoomLevelData",
                rust_offset: offset_of!(WeaponZoomLevelModifier, weapon_zoom_level),
            },
        ],
    }),
    array_type: Some(WEAPONZOOMLEVELMODIFIER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WeaponZoomLevelModifier {
    fn type_info(&self) -> &'static TypeInfo {
        WEAPONZOOMLEVELMODIFIER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WEAPONZOOMLEVELMODIFIER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponZoomLevelModifier-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("WeaponZoomLevelModifier"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WeaponZoomModifier {
    pub _glacier_base: super::weapon_shared::WeaponModifierBase,
    pub zoom_render_fov: f32,
}

pub trait WeaponZoomModifierTrait: super::weapon_shared::WeaponModifierBaseTrait {
    fn zoom_render_fov(&self) -> &f32;
    fn zoom_render_fov_mut(&mut self) -> &mut f32;
}

impl WeaponZoomModifierTrait for WeaponZoomModifier {
    fn zoom_render_fov(&self) -> &f32 {
        &self.zoom_render_fov
    }
    fn zoom_render_fov_mut(&mut self) -> &mut f32 {
        &mut self.zoom_render_fov
    }
}

impl super::weapon_shared::WeaponModifierBaseTrait for WeaponZoomModifier {
    fn apply_order(&self) -> &i32 {
        self._glacier_base.apply_order()
    }
    fn apply_order_mut(&mut self) -> &mut i32 {
        self._glacier_base.apply_order_mut()
    }
    fn dynamic_update_enabled(&self) -> &bool {
        self._glacier_base.dynamic_update_enabled()
    }
    fn dynamic_update_enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.dynamic_update_enabled_mut()
    }
}

impl super::core::DataContainerTrait for WeaponZoomModifier {
}

pub static WEAPONZOOMMODIFIER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponZoomModifier",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::weapon_shared::WEAPONMODIFIERBASE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WeaponZoomModifier as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ZoomRenderFov",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WeaponZoomModifier, zoom_render_fov),
            },
        ],
    }),
    array_type: Some(WEAPONZOOMMODIFIER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WeaponZoomModifier {
    fn type_info(&self) -> &'static TypeInfo {
        WEAPONZOOMMODIFIER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WEAPONZOOMMODIFIER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponZoomModifier-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("WeaponZoomModifier"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WeaponClassModifier {
    pub _glacier_base: super::weapon_shared::WeaponModifierBase,
    pub weapon_class: WeaponClassEnum,
}

pub trait WeaponClassModifierTrait: super::weapon_shared::WeaponModifierBaseTrait {
    fn weapon_class(&self) -> &WeaponClassEnum;
    fn weapon_class_mut(&mut self) -> &mut WeaponClassEnum;
}

impl WeaponClassModifierTrait for WeaponClassModifier {
    fn weapon_class(&self) -> &WeaponClassEnum {
        &self.weapon_class
    }
    fn weapon_class_mut(&mut self) -> &mut WeaponClassEnum {
        &mut self.weapon_class
    }
}

impl super::weapon_shared::WeaponModifierBaseTrait for WeaponClassModifier {
    fn apply_order(&self) -> &i32 {
        self._glacier_base.apply_order()
    }
    fn apply_order_mut(&mut self) -> &mut i32 {
        self._glacier_base.apply_order_mut()
    }
    fn dynamic_update_enabled(&self) -> &bool {
        self._glacier_base.dynamic_update_enabled()
    }
    fn dynamic_update_enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.dynamic_update_enabled_mut()
    }
}

impl super::core::DataContainerTrait for WeaponClassModifier {
}

pub static WEAPONCLASSMODIFIER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponClassModifier",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::weapon_shared::WEAPONMODIFIERBASE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WeaponClassModifier as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "WeaponClass",
                flags: MemberInfoFlags::new(0),
                field_type: "WeaponClassEnum",
                rust_offset: offset_of!(WeaponClassModifier, weapon_class),
            },
        ],
    }),
    array_type: Some(WEAPONCLASSMODIFIER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WeaponClassModifier {
    fn type_info(&self) -> &'static TypeInfo {
        WEAPONCLASSMODIFIER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WEAPONCLASSMODIFIER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponClassModifier-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("WeaponClassModifier"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WeaponAnimatedFireTypeModifier {
    pub _glacier_base: super::weapon_shared::WeaponModifierBase,
    pub animated_fire_type: AnimatedFireEnum,
}

pub trait WeaponAnimatedFireTypeModifierTrait: super::weapon_shared::WeaponModifierBaseTrait {
    fn animated_fire_type(&self) -> &AnimatedFireEnum;
    fn animated_fire_type_mut(&mut self) -> &mut AnimatedFireEnum;
}

impl WeaponAnimatedFireTypeModifierTrait for WeaponAnimatedFireTypeModifier {
    fn animated_fire_type(&self) -> &AnimatedFireEnum {
        &self.animated_fire_type
    }
    fn animated_fire_type_mut(&mut self) -> &mut AnimatedFireEnum {
        &mut self.animated_fire_type
    }
}

impl super::weapon_shared::WeaponModifierBaseTrait for WeaponAnimatedFireTypeModifier {
    fn apply_order(&self) -> &i32 {
        self._glacier_base.apply_order()
    }
    fn apply_order_mut(&mut self) -> &mut i32 {
        self._glacier_base.apply_order_mut()
    }
    fn dynamic_update_enabled(&self) -> &bool {
        self._glacier_base.dynamic_update_enabled()
    }
    fn dynamic_update_enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.dynamic_update_enabled_mut()
    }
}

impl super::core::DataContainerTrait for WeaponAnimatedFireTypeModifier {
}

pub static WEAPONANIMATEDFIRETYPEMODIFIER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponAnimatedFireTypeModifier",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::weapon_shared::WEAPONMODIFIERBASE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WeaponAnimatedFireTypeModifier as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AnimatedFireType",
                flags: MemberInfoFlags::new(0),
                field_type: "AnimatedFireEnum",
                rust_offset: offset_of!(WeaponAnimatedFireTypeModifier, animated_fire_type),
            },
        ],
    }),
    array_type: Some(WEAPONANIMATEDFIRETYPEMODIFIER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WeaponAnimatedFireTypeModifier {
    fn type_info(&self) -> &'static TypeInfo {
        WEAPONANIMATEDFIRETYPEMODIFIER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WEAPONANIMATEDFIRETYPEMODIFIER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponAnimatedFireTypeModifier-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("WeaponAnimatedFireTypeModifier"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WeaponAnimTypeModifier {
    pub _glacier_base: super::weapon_shared::WeaponModifierBase,
    pub weapon_anim_type: WeaponAnimType,
}

pub trait WeaponAnimTypeModifierTrait: super::weapon_shared::WeaponModifierBaseTrait {
    fn weapon_anim_type(&self) -> &WeaponAnimType;
    fn weapon_anim_type_mut(&mut self) -> &mut WeaponAnimType;
}

impl WeaponAnimTypeModifierTrait for WeaponAnimTypeModifier {
    fn weapon_anim_type(&self) -> &WeaponAnimType {
        &self.weapon_anim_type
    }
    fn weapon_anim_type_mut(&mut self) -> &mut WeaponAnimType {
        &mut self.weapon_anim_type
    }
}

impl super::weapon_shared::WeaponModifierBaseTrait for WeaponAnimTypeModifier {
    fn apply_order(&self) -> &i32 {
        self._glacier_base.apply_order()
    }
    fn apply_order_mut(&mut self) -> &mut i32 {
        self._glacier_base.apply_order_mut()
    }
    fn dynamic_update_enabled(&self) -> &bool {
        self._glacier_base.dynamic_update_enabled()
    }
    fn dynamic_update_enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.dynamic_update_enabled_mut()
    }
}

impl super::core::DataContainerTrait for WeaponAnimTypeModifier {
}

pub static WEAPONANIMTYPEMODIFIER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponAnimTypeModifier",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::weapon_shared::WEAPONMODIFIERBASE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WeaponAnimTypeModifier as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "WeaponAnimType",
                flags: MemberInfoFlags::new(0),
                field_type: "WeaponAnimType",
                rust_offset: offset_of!(WeaponAnimTypeModifier, weapon_anim_type),
            },
        ],
    }),
    array_type: Some(WEAPONANIMTYPEMODIFIER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WeaponAnimTypeModifier {
    fn type_info(&self) -> &'static TypeInfo {
        WEAPONANIMTYPEMODIFIER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WEAPONANIMTYPEMODIFIER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponAnimTypeModifier-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("WeaponAnimTypeModifier"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum WeaponAnimType {
    #[default]
    WeaponAnimType_NoAddon = 0,
    WeaponAnimType_Bipod = 1,
    WeaponAnimType_Foregrip = 2,
    WeaponAnimType_40mm_GL = 3,
    WeaponAnimType_40mm_GL_Fire = 4,
    WeaponAnimType_Underslung_Shotgun = 5,
    WeaponAnimType_Underslung_Shotgun_Fire = 6,
    WeaponAnimType_Straight_Pull_Bolt = 7,
    WeaponAnimType_Extended_Mag = 8,
}

pub static WEAPONANIMTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponAnimType",
    flags: MemberInfoFlags::new(49429),
    module: "SoldierShared",
    data: TypeInfoData::Enum,
    array_type: Some(WEAPONANIMTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for WeaponAnimType {
    fn type_info(&self) -> &'static TypeInfo {
        WEAPONANIMTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static WEAPONANIMTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponAnimType-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("WeaponAnimType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WeaponAnimationConfigurationModifier {
    pub _glacier_base: super::weapon_shared::WeaponModifierBase,
    pub animated_fire_type: AnimatedFireEnum,
}

pub trait WeaponAnimationConfigurationModifierTrait: super::weapon_shared::WeaponModifierBaseTrait {
    fn animated_fire_type(&self) -> &AnimatedFireEnum;
    fn animated_fire_type_mut(&mut self) -> &mut AnimatedFireEnum;
}

impl WeaponAnimationConfigurationModifierTrait for WeaponAnimationConfigurationModifier {
    fn animated_fire_type(&self) -> &AnimatedFireEnum {
        &self.animated_fire_type
    }
    fn animated_fire_type_mut(&mut self) -> &mut AnimatedFireEnum {
        &mut self.animated_fire_type
    }
}

impl super::weapon_shared::WeaponModifierBaseTrait for WeaponAnimationConfigurationModifier {
    fn apply_order(&self) -> &i32 {
        self._glacier_base.apply_order()
    }
    fn apply_order_mut(&mut self) -> &mut i32 {
        self._glacier_base.apply_order_mut()
    }
    fn dynamic_update_enabled(&self) -> &bool {
        self._glacier_base.dynamic_update_enabled()
    }
    fn dynamic_update_enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.dynamic_update_enabled_mut()
    }
}

impl super::core::DataContainerTrait for WeaponAnimationConfigurationModifier {
}

pub static WEAPONANIMATIONCONFIGURATIONMODIFIER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponAnimationConfigurationModifier",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::weapon_shared::WEAPONMODIFIERBASE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WeaponAnimationConfigurationModifier as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AnimatedFireType",
                flags: MemberInfoFlags::new(0),
                field_type: "AnimatedFireEnum",
                rust_offset: offset_of!(WeaponAnimationConfigurationModifier, animated_fire_type),
            },
        ],
    }),
    array_type: Some(WEAPONANIMATIONCONFIGURATIONMODIFIER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WeaponAnimationConfigurationModifier {
    fn type_info(&self) -> &'static TypeInfo {
        WEAPONANIMATIONCONFIGURATIONMODIFIER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WEAPONANIMATIONCONFIGURATIONMODIFIER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponAnimationConfigurationModifier-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("WeaponAnimationConfigurationModifier"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GrenadeEntityData {
    pub _glacier_base: super::weapon_shared::GhostedProjectileEntityData,
    pub gravity: f32,
    pub collision_speed_multiplier: f32,
    pub min_bounce_speed: f32,
    pub damage_multiplier: f32,
    pub inner_blast_radius_multiplier: f32,
    pub blast_radius_multiplier: f32,
    pub shockwave_radius_multiplier: f32,
    pub collision_damage: f32,
    pub grenade_type: GrenadeType,
    pub show_hud_indicator: bool,
    pub hud_indicator_icon: String,
}

pub trait GrenadeEntityDataTrait: super::weapon_shared::GhostedProjectileEntityDataTrait {
    fn gravity(&self) -> &f32;
    fn gravity_mut(&mut self) -> &mut f32;
    fn collision_speed_multiplier(&self) -> &f32;
    fn collision_speed_multiplier_mut(&mut self) -> &mut f32;
    fn min_bounce_speed(&self) -> &f32;
    fn min_bounce_speed_mut(&mut self) -> &mut f32;
    fn damage_multiplier(&self) -> &f32;
    fn damage_multiplier_mut(&mut self) -> &mut f32;
    fn inner_blast_radius_multiplier(&self) -> &f32;
    fn inner_blast_radius_multiplier_mut(&mut self) -> &mut f32;
    fn blast_radius_multiplier(&self) -> &f32;
    fn blast_radius_multiplier_mut(&mut self) -> &mut f32;
    fn shockwave_radius_multiplier(&self) -> &f32;
    fn shockwave_radius_multiplier_mut(&mut self) -> &mut f32;
    fn collision_damage(&self) -> &f32;
    fn collision_damage_mut(&mut self) -> &mut f32;
    fn grenade_type(&self) -> &GrenadeType;
    fn grenade_type_mut(&mut self) -> &mut GrenadeType;
    fn show_hud_indicator(&self) -> &bool;
    fn show_hud_indicator_mut(&mut self) -> &mut bool;
    fn hud_indicator_icon(&self) -> &String;
    fn hud_indicator_icon_mut(&mut self) -> &mut String;
}

impl GrenadeEntityDataTrait for GrenadeEntityData {
    fn gravity(&self) -> &f32 {
        &self.gravity
    }
    fn gravity_mut(&mut self) -> &mut f32 {
        &mut self.gravity
    }
    fn collision_speed_multiplier(&self) -> &f32 {
        &self.collision_speed_multiplier
    }
    fn collision_speed_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.collision_speed_multiplier
    }
    fn min_bounce_speed(&self) -> &f32 {
        &self.min_bounce_speed
    }
    fn min_bounce_speed_mut(&mut self) -> &mut f32 {
        &mut self.min_bounce_speed
    }
    fn damage_multiplier(&self) -> &f32 {
        &self.damage_multiplier
    }
    fn damage_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.damage_multiplier
    }
    fn inner_blast_radius_multiplier(&self) -> &f32 {
        &self.inner_blast_radius_multiplier
    }
    fn inner_blast_radius_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.inner_blast_radius_multiplier
    }
    fn blast_radius_multiplier(&self) -> &f32 {
        &self.blast_radius_multiplier
    }
    fn blast_radius_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.blast_radius_multiplier
    }
    fn shockwave_radius_multiplier(&self) -> &f32 {
        &self.shockwave_radius_multiplier
    }
    fn shockwave_radius_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.shockwave_radius_multiplier
    }
    fn collision_damage(&self) -> &f32 {
        &self.collision_damage
    }
    fn collision_damage_mut(&mut self) -> &mut f32 {
        &mut self.collision_damage
    }
    fn grenade_type(&self) -> &GrenadeType {
        &self.grenade_type
    }
    fn grenade_type_mut(&mut self) -> &mut GrenadeType {
        &mut self.grenade_type
    }
    fn show_hud_indicator(&self) -> &bool {
        &self.show_hud_indicator
    }
    fn show_hud_indicator_mut(&mut self) -> &mut bool {
        &mut self.show_hud_indicator
    }
    fn hud_indicator_icon(&self) -> &String {
        &self.hud_indicator_icon
    }
    fn hud_indicator_icon_mut(&mut self) -> &mut String {
        &mut self.hud_indicator_icon
    }
}

impl super::weapon_shared::GhostedProjectileEntityDataTrait for GrenadeEntityData {
    fn proxy_convergence_delay(&self) -> &f32 {
        self._glacier_base.proxy_convergence_delay()
    }
    fn proxy_convergence_delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.proxy_convergence_delay_mut()
    }
    fn proxy_convergence_duration(&self) -> &f32 {
        self._glacier_base.proxy_convergence_duration()
    }
    fn proxy_convergence_duration_mut(&mut self) -> &mut f32 {
        self._glacier_base.proxy_convergence_duration_mut()
    }
    fn proxy_convergence_instant_on_attach(&self) -> &bool {
        self._glacier_base.proxy_convergence_instant_on_attach()
    }
    fn proxy_convergence_instant_on_attach_mut(&mut self) -> &mut bool {
        self._glacier_base.proxy_convergence_instant_on_attach_mut()
    }
    fn force_proxy_convergence(&self) -> &bool {
        self._glacier_base.force_proxy_convergence()
    }
    fn force_proxy_convergence_mut(&mut self) -> &mut bool {
        self._glacier_base.force_proxy_convergence_mut()
    }
    fn convergence_using_initial_speed(&self) -> &bool {
        self._glacier_base.convergence_using_initial_speed()
    }
    fn convergence_using_initial_speed_mut(&mut self) -> &mut bool {
        self._glacier_base.convergence_using_initial_speed_mut()
    }
}

impl super::weapon_shared::MeshProjectileEntityDataTrait for GrenadeEntityData {
    fn mesh(&self) -> &Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        self._glacier_base.mesh()
    }
    fn mesh_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        self._glacier_base.mesh_mut()
    }
    fn trail_effect(&self) -> &Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>> {
        self._glacier_base.trail_effect()
    }
    fn trail_effect_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>> {
        self._glacier_base.trail_effect_mut()
    }
    fn is_attachable(&self) -> &bool {
        self._glacier_base.is_attachable()
    }
    fn is_attachable_mut(&mut self) -> &mut bool {
        self._glacier_base.is_attachable_mut()
    }
    fn instant_attachable_test_distance(&self) -> &f32 {
        self._glacier_base.instant_attachable_test_distance()
    }
    fn instant_attachable_test_distance_mut(&mut self) -> &mut f32 {
        self._glacier_base.instant_attachable_test_distance_mut()
    }
    fn instant_attachable_visual_convergence_delay(&self) -> &f32 {
        self._glacier_base.instant_attachable_visual_convergence_delay()
    }
    fn instant_attachable_visual_convergence_delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.instant_attachable_visual_convergence_delay_mut()
    }
    fn instant_attachable_visual_convergence_duration(&self) -> &f32 {
        self._glacier_base.instant_attachable_visual_convergence_duration()
    }
    fn instant_attachable_visual_convergence_duration_mut(&mut self) -> &mut f32 {
        self._glacier_base.instant_attachable_visual_convergence_duration_mut()
    }
    fn instant_attachable_test_under_reticule(&self) -> &bool {
        self._glacier_base.instant_attachable_test_under_reticule()
    }
    fn instant_attachable_test_under_reticule_mut(&mut self) -> &mut bool {
        self._glacier_base.instant_attachable_test_under_reticule_mut()
    }
    fn max_attachable_inclination(&self) -> &f32 {
        self._glacier_base.max_attachable_inclination()
    }
    fn max_attachable_inclination_mut(&mut self) -> &mut f32 {
        self._glacier_base.max_attachable_inclination_mut()
    }
    fn extra_damping(&self) -> &bool {
        self._glacier_base.extra_damping()
    }
    fn extra_damping_mut(&mut self) -> &mut bool {
        self._glacier_base.extra_damping_mut()
    }
    fn initial_angular_velocity(&self) -> &super::core::Vec3 {
        self._glacier_base.initial_angular_velocity()
    }
    fn initial_angular_velocity_mut(&mut self) -> &mut super::core::Vec3 {
        self._glacier_base.initial_angular_velocity_mut()
    }
    fn unspawn_after_detonation_delay(&self) -> &f32 {
        self._glacier_base.unspawn_after_detonation_delay()
    }
    fn unspawn_after_detonation_delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.unspawn_after_detonation_delay_mut()
    }
}

impl super::weapon_shared::ProjectileEntityDataTrait for GrenadeEntityData {
    fn initial_speed(&self) -> &f32 {
        self._glacier_base.initial_speed()
    }
    fn initial_speed_mut(&mut self) -> &mut f32 {
        self._glacier_base.initial_speed_mut()
    }
    fn time_to_live(&self) -> &f32 {
        self._glacier_base.time_to_live()
    }
    fn time_to_live_mut(&mut self) -> &mut f32 {
        self._glacier_base.time_to_live_mut()
    }
    fn max_count(&self) -> &u32 {
        self._glacier_base.max_count()
    }
    fn max_count_mut(&mut self) -> &mut u32 {
        self._glacier_base.max_count_mut()
    }
    fn init_mesh_hide_time(&self) -> &f32 {
        self._glacier_base.init_mesh_hide_time()
    }
    fn init_mesh_hide_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.init_mesh_hide_time_mut()
    }
    fn visual_converge_distance(&self) -> &f32 {
        self._glacier_base.visual_converge_distance()
    }
    fn visual_converge_distance_mut(&mut self) -> &mut f32 {
        self._glacier_base.visual_converge_distance_mut()
    }
    fn visual_convergence_delay(&self) -> &f32 {
        self._glacier_base.visual_convergence_delay()
    }
    fn visual_convergence_delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.visual_convergence_delay_mut()
    }
    fn visual_convergence_duration(&self) -> &f32 {
        self._glacier_base.visual_convergence_duration()
    }
    fn visual_convergence_duration_mut(&mut self) -> &mut f32 {
        self._glacier_base.visual_convergence_duration_mut()
    }
    fn proxy_visual_convergence_delay(&self) -> &f32 {
        self._glacier_base.proxy_visual_convergence_delay()
    }
    fn proxy_visual_convergence_delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.proxy_visual_convergence_delay_mut()
    }
    fn proxy_visual_convergence_duration(&self) -> &f32 {
        self._glacier_base.proxy_visual_convergence_duration()
    }
    fn proxy_visual_convergence_duration_mut(&mut self) -> &mut f32 {
        self._glacier_base.proxy_visual_convergence_duration_mut()
    }
    fn detonate_on_timeout(&self) -> &bool {
        self._glacier_base.detonate_on_timeout()
    }
    fn detonate_on_timeout_mut(&mut self) -> &mut bool {
        self._glacier_base.detonate_on_timeout_mut()
    }
    fn server_projectile_disabled(&self) -> &bool {
        self._glacier_base.server_projectile_disabled()
    }
    fn server_projectile_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.server_projectile_disabled_mut()
    }
    fn explosion(&self) -> &Option<Arc<Mutex<dyn super::game_shared::ExplosionEntityDataTrait>>> {
        self._glacier_base.explosion()
    }
    fn explosion_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::game_shared::ExplosionEntityDataTrait>>> {
        self._glacier_base.explosion_mut()
    }
    fn suppression_data(&self) -> &Option<Arc<Mutex<dyn super::weapon_shared::WeaponSuppressionDataTrait>>> {
        self._glacier_base.suppression_data()
    }
    fn suppression_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::weapon_shared::WeaponSuppressionDataTrait>>> {
        self._glacier_base.suppression_data_mut()
    }
    fn ammunition_type(&self) -> &String {
        self._glacier_base.ammunition_type()
    }
    fn ammunition_type_mut(&mut self) -> &mut String {
        self._glacier_base.ammunition_type_mut()
    }
    fn material_pair(&self) -> &super::entity::MaterialDecl {
        self._glacier_base.material_pair()
    }
    fn material_pair_mut(&mut self) -> &mut super::entity::MaterialDecl {
        self._glacier_base.material_pair_mut()
    }
    fn hit_reaction_weapon_type(&self) -> &super::weapon_shared::AntHitReactionWeaponType {
        self._glacier_base.hit_reaction_weapon_type()
    }
    fn hit_reaction_weapon_type_mut(&mut self) -> &mut super::weapon_shared::AntHitReactionWeaponType {
        self._glacier_base.hit_reaction_weapon_type_mut()
    }
    fn hide_on_detonation(&self) -> &bool {
        self._glacier_base.hide_on_detonation()
    }
    fn hide_on_detonation_mut(&mut self) -> &mut bool {
        self._glacier_base.hide_on_detonation_mut()
    }
    fn voice_over_info(&self) -> &Option<Arc<Mutex<dyn super::audio::EntityVoiceOverInfoTrait>>> {
        self._glacier_base.voice_over_info()
    }
    fn voice_over_info_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::EntityVoiceOverInfoTrait>>> {
        self._glacier_base.voice_over_info_mut()
    }
}

impl super::physics::GamePhysicsEntityDataTrait for GrenadeEntityData {
}

impl super::entity::GameComponentEntityDataTrait for GrenadeEntityData {
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::ComponentEntityDataTrait for GrenadeEntityData {
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn part_bounding_boxes(&self) -> &Vec<super::core::AxisAlignedBox> {
        self._glacier_base.part_bounding_boxes()
    }
    fn part_bounding_boxes_mut(&mut self) -> &mut Vec<super::core::AxisAlignedBox> {
        self._glacier_base.part_bounding_boxes_mut()
    }
    fn client_runtime_component_count(&self) -> &u8 {
        self._glacier_base.client_runtime_component_count()
    }
    fn client_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_component_count_mut()
    }
    fn server_runtime_component_count(&self) -> &u8 {
        self._glacier_base.server_runtime_component_count()
    }
    fn server_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_component_count_mut()
    }
    fn client_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.client_runtime_transformation_count()
    }
    fn client_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_transformation_count_mut()
    }
    fn server_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.server_runtime_transformation_count()
    }
    fn server_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_transformation_count_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for GrenadeEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for GrenadeEntityData {
}

impl super::entity::GameObjectDataTrait for GrenadeEntityData {
}

impl super::core::DataBusPeerTrait for GrenadeEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for GrenadeEntityData {
}

impl super::core::DataContainerTrait for GrenadeEntityData {
}

pub static GRENADEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GrenadeEntityData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::weapon_shared::GHOSTEDPROJECTILEENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GrenadeEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Gravity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GrenadeEntityData, gravity),
            },
            FieldInfoData {
                name: "CollisionSpeedMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GrenadeEntityData, collision_speed_multiplier),
            },
            FieldInfoData {
                name: "MinBounceSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GrenadeEntityData, min_bounce_speed),
            },
            FieldInfoData {
                name: "DamageMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GrenadeEntityData, damage_multiplier),
            },
            FieldInfoData {
                name: "InnerBlastRadiusMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GrenadeEntityData, inner_blast_radius_multiplier),
            },
            FieldInfoData {
                name: "BlastRadiusMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GrenadeEntityData, blast_radius_multiplier),
            },
            FieldInfoData {
                name: "ShockwaveRadiusMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GrenadeEntityData, shockwave_radius_multiplier),
            },
            FieldInfoData {
                name: "CollisionDamage",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GrenadeEntityData, collision_damage),
            },
            FieldInfoData {
                name: "GrenadeType",
                flags: MemberInfoFlags::new(0),
                field_type: "GrenadeType",
                rust_offset: offset_of!(GrenadeEntityData, grenade_type),
            },
            FieldInfoData {
                name: "ShowHudIndicator",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(GrenadeEntityData, show_hud_indicator),
            },
            FieldInfoData {
                name: "HudIndicatorIcon",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(GrenadeEntityData, hud_indicator_icon),
            },
        ],
    }),
    array_type: Some(GRENADEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for GrenadeEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        GRENADEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static GRENADEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GrenadeEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("GrenadeEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum GrenadeType {
    #[default]
    GrenadeType_NotSet = 0,
    GrenadeType_Frag = 1,
    GrenadeType_Smoke = 2,
    GrenadeType_Flash = 3,
}

pub static GRENADETYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GrenadeType",
    flags: MemberInfoFlags::new(49429),
    module: "SoldierShared",
    data: TypeInfoData::Enum,
    array_type: Some(GRENADETYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for GrenadeType {
    fn type_info(&self) -> &'static TypeInfo {
        GRENADETYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static GRENADETYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GrenadeType-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("GrenadeType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SupplySphereWeaponData {
    pub _glacier_base: super::weapon_shared::WeaponData,
    pub supply_data: SupplyData,
}

pub trait SupplySphereWeaponDataTrait: super::weapon_shared::WeaponDataTrait {
    fn supply_data(&self) -> &SupplyData;
    fn supply_data_mut(&mut self) -> &mut SupplyData;
}

impl SupplySphereWeaponDataTrait for SupplySphereWeaponData {
    fn supply_data(&self) -> &SupplyData {
        &self.supply_data
    }
    fn supply_data_mut(&mut self) -> &mut SupplyData {
        &mut self.supply_data
    }
}

impl super::weapon_shared::WeaponDataTrait for SupplySphereWeaponData {
    fn show_laser_painted_vehicles(&self) -> &bool {
        self._glacier_base.show_laser_painted_vehicles()
    }
    fn show_laser_painted_vehicles_mut(&mut self) -> &mut bool {
        self._glacier_base.show_laser_painted_vehicles_mut()
    }
    fn apply_power_to_speed(&self) -> &bool {
        self._glacier_base.apply_power_to_speed()
    }
    fn apply_power_to_speed_mut(&mut self) -> &mut bool {
        self._glacier_base.apply_power_to_speed_mut()
    }
}

impl super::gameplay_sim::ToolDataTrait for SupplySphereWeaponData {
    fn is_always_active(&self) -> &bool {
        self._glacier_base.is_always_active()
    }
    fn is_always_active_mut(&mut self) -> &mut bool {
        self._glacier_base.is_always_active_mut()
    }
}

impl super::core::DataContainerTrait for SupplySphereWeaponData {
}

pub static SUPPLYSPHEREWEAPONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SupplySphereWeaponData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::weapon_shared::WEAPONDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SupplySphereWeaponData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SupplyData",
                flags: MemberInfoFlags::new(0),
                field_type: "SupplyData",
                rust_offset: offset_of!(SupplySphereWeaponData, supply_data),
            },
        ],
    }),
    array_type: Some(SUPPLYSPHEREWEAPONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SupplySphereWeaponData {
    fn type_info(&self) -> &'static TypeInfo {
        SUPPLYSPHEREWEAPONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SUPPLYSPHEREWEAPONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SupplySphereWeaponData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SupplySphereWeaponData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SupplyData {
    pub supply_soldiers: bool,
    pub supply_vehicles: bool,
    pub healing: Option<Arc<Mutex<dyn HealingSupplyUnitSphereDataTrait>>>,
    pub ammo: Option<Arc<Mutex<dyn AmmoSupplyUnitSphereDataTrait>>>,
    pub team_specific: bool,
    pub exclude_self: bool,
    pub exclusion_timeout: f32,
}

pub trait SupplyDataTrait: TypeObject {
    fn supply_soldiers(&self) -> &bool;
    fn supply_soldiers_mut(&mut self) -> &mut bool;
    fn supply_vehicles(&self) -> &bool;
    fn supply_vehicles_mut(&mut self) -> &mut bool;
    fn healing(&self) -> &Option<Arc<Mutex<dyn HealingSupplyUnitSphereDataTrait>>>;
    fn healing_mut(&mut self) -> &mut Option<Arc<Mutex<dyn HealingSupplyUnitSphereDataTrait>>>;
    fn ammo(&self) -> &Option<Arc<Mutex<dyn AmmoSupplyUnitSphereDataTrait>>>;
    fn ammo_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AmmoSupplyUnitSphereDataTrait>>>;
    fn team_specific(&self) -> &bool;
    fn team_specific_mut(&mut self) -> &mut bool;
    fn exclude_self(&self) -> &bool;
    fn exclude_self_mut(&mut self) -> &mut bool;
    fn exclusion_timeout(&self) -> &f32;
    fn exclusion_timeout_mut(&mut self) -> &mut f32;
}

impl SupplyDataTrait for SupplyData {
    fn supply_soldiers(&self) -> &bool {
        &self.supply_soldiers
    }
    fn supply_soldiers_mut(&mut self) -> &mut bool {
        &mut self.supply_soldiers
    }
    fn supply_vehicles(&self) -> &bool {
        &self.supply_vehicles
    }
    fn supply_vehicles_mut(&mut self) -> &mut bool {
        &mut self.supply_vehicles
    }
    fn healing(&self) -> &Option<Arc<Mutex<dyn HealingSupplyUnitSphereDataTrait>>> {
        &self.healing
    }
    fn healing_mut(&mut self) -> &mut Option<Arc<Mutex<dyn HealingSupplyUnitSphereDataTrait>>> {
        &mut self.healing
    }
    fn ammo(&self) -> &Option<Arc<Mutex<dyn AmmoSupplyUnitSphereDataTrait>>> {
        &self.ammo
    }
    fn ammo_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AmmoSupplyUnitSphereDataTrait>>> {
        &mut self.ammo
    }
    fn team_specific(&self) -> &bool {
        &self.team_specific
    }
    fn team_specific_mut(&mut self) -> &mut bool {
        &mut self.team_specific
    }
    fn exclude_self(&self) -> &bool {
        &self.exclude_self
    }
    fn exclude_self_mut(&mut self) -> &mut bool {
        &mut self.exclude_self
    }
    fn exclusion_timeout(&self) -> &f32 {
        &self.exclusion_timeout
    }
    fn exclusion_timeout_mut(&mut self) -> &mut f32 {
        &mut self.exclusion_timeout
    }
}

pub static SUPPLYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SupplyData",
    flags: MemberInfoFlags::new(73),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SupplyData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SupplySoldiers",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SupplyData, supply_soldiers),
            },
            FieldInfoData {
                name: "SupplyVehicles",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SupplyData, supply_vehicles),
            },
            FieldInfoData {
                name: "Healing",
                flags: MemberInfoFlags::new(0),
                field_type: "HealingSupplyUnitSphereData",
                rust_offset: offset_of!(SupplyData, healing),
            },
            FieldInfoData {
                name: "Ammo",
                flags: MemberInfoFlags::new(0),
                field_type: "AmmoSupplyUnitSphereData",
                rust_offset: offset_of!(SupplyData, ammo),
            },
            FieldInfoData {
                name: "TeamSpecific",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SupplyData, team_specific),
            },
            FieldInfoData {
                name: "ExcludeSelf",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SupplyData, exclude_self),
            },
            FieldInfoData {
                name: "ExclusionTimeout",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SupplyData, exclusion_timeout),
            },
        ],
    }),
    array_type: Some(SUPPLYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SupplyData {
    fn type_info(&self) -> &'static TypeInfo {
        SUPPLYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SUPPLYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SupplyData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SupplyData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AmmoSupplyUnitSphereData {
    pub _glacier_base: SupplyUnitSphereData,
    pub ignored_weapon_classes: Vec<WeaponClassEnum>,
}

pub trait AmmoSupplyUnitSphereDataTrait: SupplyUnitSphereDataTrait {
    fn ignored_weapon_classes(&self) -> &Vec<WeaponClassEnum>;
    fn ignored_weapon_classes_mut(&mut self) -> &mut Vec<WeaponClassEnum>;
}

impl AmmoSupplyUnitSphereDataTrait for AmmoSupplyUnitSphereData {
    fn ignored_weapon_classes(&self) -> &Vec<WeaponClassEnum> {
        &self.ignored_weapon_classes
    }
    fn ignored_weapon_classes_mut(&mut self) -> &mut Vec<WeaponClassEnum> {
        &mut self.ignored_weapon_classes
    }
}

impl SupplyUnitSphereDataTrait for AmmoSupplyUnitSphereData {
    fn radius(&self) -> &f32 {
        self._glacier_base.radius()
    }
    fn radius_mut(&mut self) -> &mut f32 {
        self._glacier_base.radius_mut()
    }
    fn max_radius(&self) -> &f32 {
        self._glacier_base.max_radius()
    }
    fn max_radius_mut(&mut self) -> &mut f32 {
        self._glacier_base.max_radius_mut()
    }
    fn radius_change_time(&self) -> &f32 {
        self._glacier_base.radius_change_time()
    }
    fn radius_change_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.radius_change_time_mut()
    }
    fn supply_inc_speed(&self) -> &f32 {
        self._glacier_base.supply_inc_speed()
    }
    fn supply_inc_speed_mut(&mut self) -> &mut f32 {
        self._glacier_base.supply_inc_speed_mut()
    }
    fn instant_refill(&self) -> &f32 {
        self._glacier_base.instant_refill()
    }
    fn instant_refill_mut(&mut self) -> &mut f32 {
        self._glacier_base.instant_refill_mut()
    }
    fn force_use_instant_refill(&self) -> &bool {
        self._glacier_base.force_use_instant_refill()
    }
    fn force_use_instant_refill_mut(&mut self) -> &mut bool {
        self._glacier_base.force_use_instant_refill_mut()
    }
    fn infinite_capacity(&self) -> &bool {
        self._glacier_base.infinite_capacity()
    }
    fn infinite_capacity_mut(&mut self) -> &mut bool {
        self._glacier_base.infinite_capacity_mut()
    }
    fn supply_points_refill_speed(&self) -> &f32 {
        self._glacier_base.supply_points_refill_speed()
    }
    fn supply_points_refill_speed_mut(&mut self) -> &mut f32 {
        self._glacier_base.supply_points_refill_speed_mut()
    }
    fn supply_points_capacity(&self) -> &f32 {
        self._glacier_base.supply_points_capacity()
    }
    fn supply_points_capacity_mut(&mut self) -> &mut f32 {
        self._glacier_base.supply_points_capacity_mut()
    }
}

impl super::core::DataContainerTrait for AmmoSupplyUnitSphereData {
}

pub static AMMOSUPPLYUNITSPHEREDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AmmoSupplyUnitSphereData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SUPPLYUNITSPHEREDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AmmoSupplyUnitSphereData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "IgnoredWeaponClasses",
                flags: MemberInfoFlags::new(144),
                field_type: "WeaponClassEnum-Array",
                rust_offset: offset_of!(AmmoSupplyUnitSphereData, ignored_weapon_classes),
            },
        ],
    }),
    array_type: Some(AMMOSUPPLYUNITSPHEREDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AmmoSupplyUnitSphereData {
    fn type_info(&self) -> &'static TypeInfo {
        AMMOSUPPLYUNITSPHEREDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AMMOSUPPLYUNITSPHEREDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AmmoSupplyUnitSphereData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("AmmoSupplyUnitSphereData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct HealingSupplyUnitSphereData {
    pub _glacier_base: SupplyUnitSphereData,
    pub distribute_healing_over_time: f32,
}

pub trait HealingSupplyUnitSphereDataTrait: SupplyUnitSphereDataTrait {
    fn distribute_healing_over_time(&self) -> &f32;
    fn distribute_healing_over_time_mut(&mut self) -> &mut f32;
}

impl HealingSupplyUnitSphereDataTrait for HealingSupplyUnitSphereData {
    fn distribute_healing_over_time(&self) -> &f32 {
        &self.distribute_healing_over_time
    }
    fn distribute_healing_over_time_mut(&mut self) -> &mut f32 {
        &mut self.distribute_healing_over_time
    }
}

impl SupplyUnitSphereDataTrait for HealingSupplyUnitSphereData {
    fn radius(&self) -> &f32 {
        self._glacier_base.radius()
    }
    fn radius_mut(&mut self) -> &mut f32 {
        self._glacier_base.radius_mut()
    }
    fn max_radius(&self) -> &f32 {
        self._glacier_base.max_radius()
    }
    fn max_radius_mut(&mut self) -> &mut f32 {
        self._glacier_base.max_radius_mut()
    }
    fn radius_change_time(&self) -> &f32 {
        self._glacier_base.radius_change_time()
    }
    fn radius_change_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.radius_change_time_mut()
    }
    fn supply_inc_speed(&self) -> &f32 {
        self._glacier_base.supply_inc_speed()
    }
    fn supply_inc_speed_mut(&mut self) -> &mut f32 {
        self._glacier_base.supply_inc_speed_mut()
    }
    fn instant_refill(&self) -> &f32 {
        self._glacier_base.instant_refill()
    }
    fn instant_refill_mut(&mut self) -> &mut f32 {
        self._glacier_base.instant_refill_mut()
    }
    fn force_use_instant_refill(&self) -> &bool {
        self._glacier_base.force_use_instant_refill()
    }
    fn force_use_instant_refill_mut(&mut self) -> &mut bool {
        self._glacier_base.force_use_instant_refill_mut()
    }
    fn infinite_capacity(&self) -> &bool {
        self._glacier_base.infinite_capacity()
    }
    fn infinite_capacity_mut(&mut self) -> &mut bool {
        self._glacier_base.infinite_capacity_mut()
    }
    fn supply_points_refill_speed(&self) -> &f32 {
        self._glacier_base.supply_points_refill_speed()
    }
    fn supply_points_refill_speed_mut(&mut self) -> &mut f32 {
        self._glacier_base.supply_points_refill_speed_mut()
    }
    fn supply_points_capacity(&self) -> &f32 {
        self._glacier_base.supply_points_capacity()
    }
    fn supply_points_capacity_mut(&mut self) -> &mut f32 {
        self._glacier_base.supply_points_capacity_mut()
    }
}

impl super::core::DataContainerTrait for HealingSupplyUnitSphereData {
}

pub static HEALINGSUPPLYUNITSPHEREDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HealingSupplyUnitSphereData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SUPPLYUNITSPHEREDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<HealingSupplyUnitSphereData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DistributeHealingOverTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HealingSupplyUnitSphereData, distribute_healing_over_time),
            },
        ],
    }),
    array_type: Some(HEALINGSUPPLYUNITSPHEREDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for HealingSupplyUnitSphereData {
    fn type_info(&self) -> &'static TypeInfo {
        HEALINGSUPPLYUNITSPHEREDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static HEALINGSUPPLYUNITSPHEREDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HealingSupplyUnitSphereData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("HealingSupplyUnitSphereData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SupplyUnitSphereData {
    pub _glacier_base: super::core::DataContainer,
    pub radius: f32,
    pub max_radius: f32,
    pub radius_change_time: f32,
    pub supply_inc_speed: f32,
    pub instant_refill: f32,
    pub force_use_instant_refill: bool,
    pub infinite_capacity: bool,
    pub supply_points_refill_speed: f32,
    pub supply_points_capacity: f32,
}

pub trait SupplyUnitSphereDataTrait: super::core::DataContainerTrait {
    fn radius(&self) -> &f32;
    fn radius_mut(&mut self) -> &mut f32;
    fn max_radius(&self) -> &f32;
    fn max_radius_mut(&mut self) -> &mut f32;
    fn radius_change_time(&self) -> &f32;
    fn radius_change_time_mut(&mut self) -> &mut f32;
    fn supply_inc_speed(&self) -> &f32;
    fn supply_inc_speed_mut(&mut self) -> &mut f32;
    fn instant_refill(&self) -> &f32;
    fn instant_refill_mut(&mut self) -> &mut f32;
    fn force_use_instant_refill(&self) -> &bool;
    fn force_use_instant_refill_mut(&mut self) -> &mut bool;
    fn infinite_capacity(&self) -> &bool;
    fn infinite_capacity_mut(&mut self) -> &mut bool;
    fn supply_points_refill_speed(&self) -> &f32;
    fn supply_points_refill_speed_mut(&mut self) -> &mut f32;
    fn supply_points_capacity(&self) -> &f32;
    fn supply_points_capacity_mut(&mut self) -> &mut f32;
}

impl SupplyUnitSphereDataTrait for SupplyUnitSphereData {
    fn radius(&self) -> &f32 {
        &self.radius
    }
    fn radius_mut(&mut self) -> &mut f32 {
        &mut self.radius
    }
    fn max_radius(&self) -> &f32 {
        &self.max_radius
    }
    fn max_radius_mut(&mut self) -> &mut f32 {
        &mut self.max_radius
    }
    fn radius_change_time(&self) -> &f32 {
        &self.radius_change_time
    }
    fn radius_change_time_mut(&mut self) -> &mut f32 {
        &mut self.radius_change_time
    }
    fn supply_inc_speed(&self) -> &f32 {
        &self.supply_inc_speed
    }
    fn supply_inc_speed_mut(&mut self) -> &mut f32 {
        &mut self.supply_inc_speed
    }
    fn instant_refill(&self) -> &f32 {
        &self.instant_refill
    }
    fn instant_refill_mut(&mut self) -> &mut f32 {
        &mut self.instant_refill
    }
    fn force_use_instant_refill(&self) -> &bool {
        &self.force_use_instant_refill
    }
    fn force_use_instant_refill_mut(&mut self) -> &mut bool {
        &mut self.force_use_instant_refill
    }
    fn infinite_capacity(&self) -> &bool {
        &self.infinite_capacity
    }
    fn infinite_capacity_mut(&mut self) -> &mut bool {
        &mut self.infinite_capacity
    }
    fn supply_points_refill_speed(&self) -> &f32 {
        &self.supply_points_refill_speed
    }
    fn supply_points_refill_speed_mut(&mut self) -> &mut f32 {
        &mut self.supply_points_refill_speed
    }
    fn supply_points_capacity(&self) -> &f32 {
        &self.supply_points_capacity
    }
    fn supply_points_capacity_mut(&mut self) -> &mut f32 {
        &mut self.supply_points_capacity
    }
}

impl super::core::DataContainerTrait for SupplyUnitSphereData {
}

pub static SUPPLYUNITSPHEREDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SupplyUnitSphereData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SupplyUnitSphereData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Radius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SupplyUnitSphereData, radius),
            },
            FieldInfoData {
                name: "MaxRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SupplyUnitSphereData, max_radius),
            },
            FieldInfoData {
                name: "RadiusChangeTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SupplyUnitSphereData, radius_change_time),
            },
            FieldInfoData {
                name: "SupplyIncSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SupplyUnitSphereData, supply_inc_speed),
            },
            FieldInfoData {
                name: "InstantRefill",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SupplyUnitSphereData, instant_refill),
            },
            FieldInfoData {
                name: "ForceUseInstantRefill",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SupplyUnitSphereData, force_use_instant_refill),
            },
            FieldInfoData {
                name: "InfiniteCapacity",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SupplyUnitSphereData, infinite_capacity),
            },
            FieldInfoData {
                name: "SupplyPointsRefillSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SupplyUnitSphereData, supply_points_refill_speed),
            },
            FieldInfoData {
                name: "SupplyPointsCapacity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SupplyUnitSphereData, supply_points_capacity),
            },
        ],
    }),
    array_type: Some(SUPPLYUNITSPHEREDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SupplyUnitSphereData {
    fn type_info(&self) -> &'static TypeInfo {
        SUPPLYUNITSPHEREDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SUPPLYUNITSPHEREDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SupplyUnitSphereData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SupplyUnitSphereData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WeaponAimingSimulationModifier {
    pub _glacier_base: super::weapon_shared::WeaponModifierBase,
    pub aiming_controller: Option<Arc<Mutex<dyn SoldierAimingSimulationDataTrait>>>,
}

pub trait WeaponAimingSimulationModifierTrait: super::weapon_shared::WeaponModifierBaseTrait {
    fn aiming_controller(&self) -> &Option<Arc<Mutex<dyn SoldierAimingSimulationDataTrait>>>;
    fn aiming_controller_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoldierAimingSimulationDataTrait>>>;
}

impl WeaponAimingSimulationModifierTrait for WeaponAimingSimulationModifier {
    fn aiming_controller(&self) -> &Option<Arc<Mutex<dyn SoldierAimingSimulationDataTrait>>> {
        &self.aiming_controller
    }
    fn aiming_controller_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoldierAimingSimulationDataTrait>>> {
        &mut self.aiming_controller
    }
}

impl super::weapon_shared::WeaponModifierBaseTrait for WeaponAimingSimulationModifier {
    fn apply_order(&self) -> &i32 {
        self._glacier_base.apply_order()
    }
    fn apply_order_mut(&mut self) -> &mut i32 {
        self._glacier_base.apply_order_mut()
    }
    fn dynamic_update_enabled(&self) -> &bool {
        self._glacier_base.dynamic_update_enabled()
    }
    fn dynamic_update_enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.dynamic_update_enabled_mut()
    }
}

impl super::core::DataContainerTrait for WeaponAimingSimulationModifier {
}

pub static WEAPONAIMINGSIMULATIONMODIFIER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponAimingSimulationModifier",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::weapon_shared::WEAPONMODIFIERBASE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WeaponAimingSimulationModifier as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AimingController",
                flags: MemberInfoFlags::new(0),
                field_type: "SoldierAimingSimulationData",
                rust_offset: offset_of!(WeaponAimingSimulationModifier, aiming_controller),
            },
        ],
    }),
    array_type: Some(WEAPONAIMINGSIMULATIONMODIFIER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WeaponAimingSimulationModifier {
    fn type_info(&self) -> &'static TypeInfo {
        WEAPONAIMINGSIMULATIONMODIFIER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WEAPONAIMINGSIMULATIONMODIFIER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponAimingSimulationModifier-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("WeaponAimingSimulationModifier"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoldierAimingSimulationData {
    pub _glacier_base: super::core::GameDataContainer,
    pub zoom_levels: Vec<Option<Arc<Mutex<dyn ZoomLevelDataTrait>>>>,
    pub return_to_zoom_after_reload: bool,
    pub ignore_zoom_toggle: bool,
    pub aim_assist: Option<Arc<Mutex<dyn SoldierAimAssistDataTrait>>>,
    pub stand_pose: AimingPoseData,
    pub crouch_pose: AimingPoseData,
    pub prone_pose: AimingPoseData,
    pub zoom_transition_time: f32,
    pub zoom_transition_time_array: Vec<ZoomLevelSpecificTransitionTime>,
    pub update_camera_f_o_v: bool,
    pub fov_delay_time: f32,
    pub fov_transition_time: f32,
    pub aiming_range: f32,
    pub lock_aim_to_target_speed: f32,
    pub force1p_on_zoom: bool,
}

pub trait SoldierAimingSimulationDataTrait: super::core::GameDataContainerTrait {
    fn zoom_levels(&self) -> &Vec<Option<Arc<Mutex<dyn ZoomLevelDataTrait>>>>;
    fn zoom_levels_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn ZoomLevelDataTrait>>>>;
    fn return_to_zoom_after_reload(&self) -> &bool;
    fn return_to_zoom_after_reload_mut(&mut self) -> &mut bool;
    fn ignore_zoom_toggle(&self) -> &bool;
    fn ignore_zoom_toggle_mut(&mut self) -> &mut bool;
    fn aim_assist(&self) -> &Option<Arc<Mutex<dyn SoldierAimAssistDataTrait>>>;
    fn aim_assist_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoldierAimAssistDataTrait>>>;
    fn stand_pose(&self) -> &AimingPoseData;
    fn stand_pose_mut(&mut self) -> &mut AimingPoseData;
    fn crouch_pose(&self) -> &AimingPoseData;
    fn crouch_pose_mut(&mut self) -> &mut AimingPoseData;
    fn prone_pose(&self) -> &AimingPoseData;
    fn prone_pose_mut(&mut self) -> &mut AimingPoseData;
    fn zoom_transition_time(&self) -> &f32;
    fn zoom_transition_time_mut(&mut self) -> &mut f32;
    fn zoom_transition_time_array(&self) -> &Vec<ZoomLevelSpecificTransitionTime>;
    fn zoom_transition_time_array_mut(&mut self) -> &mut Vec<ZoomLevelSpecificTransitionTime>;
    fn update_camera_f_o_v(&self) -> &bool;
    fn update_camera_f_o_v_mut(&mut self) -> &mut bool;
    fn fov_delay_time(&self) -> &f32;
    fn fov_delay_time_mut(&mut self) -> &mut f32;
    fn fov_transition_time(&self) -> &f32;
    fn fov_transition_time_mut(&mut self) -> &mut f32;
    fn aiming_range(&self) -> &f32;
    fn aiming_range_mut(&mut self) -> &mut f32;
    fn lock_aim_to_target_speed(&self) -> &f32;
    fn lock_aim_to_target_speed_mut(&mut self) -> &mut f32;
    fn force1p_on_zoom(&self) -> &bool;
    fn force1p_on_zoom_mut(&mut self) -> &mut bool;
}

impl SoldierAimingSimulationDataTrait for SoldierAimingSimulationData {
    fn zoom_levels(&self) -> &Vec<Option<Arc<Mutex<dyn ZoomLevelDataTrait>>>> {
        &self.zoom_levels
    }
    fn zoom_levels_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn ZoomLevelDataTrait>>>> {
        &mut self.zoom_levels
    }
    fn return_to_zoom_after_reload(&self) -> &bool {
        &self.return_to_zoom_after_reload
    }
    fn return_to_zoom_after_reload_mut(&mut self) -> &mut bool {
        &mut self.return_to_zoom_after_reload
    }
    fn ignore_zoom_toggle(&self) -> &bool {
        &self.ignore_zoom_toggle
    }
    fn ignore_zoom_toggle_mut(&mut self) -> &mut bool {
        &mut self.ignore_zoom_toggle
    }
    fn aim_assist(&self) -> &Option<Arc<Mutex<dyn SoldierAimAssistDataTrait>>> {
        &self.aim_assist
    }
    fn aim_assist_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoldierAimAssistDataTrait>>> {
        &mut self.aim_assist
    }
    fn stand_pose(&self) -> &AimingPoseData {
        &self.stand_pose
    }
    fn stand_pose_mut(&mut self) -> &mut AimingPoseData {
        &mut self.stand_pose
    }
    fn crouch_pose(&self) -> &AimingPoseData {
        &self.crouch_pose
    }
    fn crouch_pose_mut(&mut self) -> &mut AimingPoseData {
        &mut self.crouch_pose
    }
    fn prone_pose(&self) -> &AimingPoseData {
        &self.prone_pose
    }
    fn prone_pose_mut(&mut self) -> &mut AimingPoseData {
        &mut self.prone_pose
    }
    fn zoom_transition_time(&self) -> &f32 {
        &self.zoom_transition_time
    }
    fn zoom_transition_time_mut(&mut self) -> &mut f32 {
        &mut self.zoom_transition_time
    }
    fn zoom_transition_time_array(&self) -> &Vec<ZoomLevelSpecificTransitionTime> {
        &self.zoom_transition_time_array
    }
    fn zoom_transition_time_array_mut(&mut self) -> &mut Vec<ZoomLevelSpecificTransitionTime> {
        &mut self.zoom_transition_time_array
    }
    fn update_camera_f_o_v(&self) -> &bool {
        &self.update_camera_f_o_v
    }
    fn update_camera_f_o_v_mut(&mut self) -> &mut bool {
        &mut self.update_camera_f_o_v
    }
    fn fov_delay_time(&self) -> &f32 {
        &self.fov_delay_time
    }
    fn fov_delay_time_mut(&mut self) -> &mut f32 {
        &mut self.fov_delay_time
    }
    fn fov_transition_time(&self) -> &f32 {
        &self.fov_transition_time
    }
    fn fov_transition_time_mut(&mut self) -> &mut f32 {
        &mut self.fov_transition_time
    }
    fn aiming_range(&self) -> &f32 {
        &self.aiming_range
    }
    fn aiming_range_mut(&mut self) -> &mut f32 {
        &mut self.aiming_range
    }
    fn lock_aim_to_target_speed(&self) -> &f32 {
        &self.lock_aim_to_target_speed
    }
    fn lock_aim_to_target_speed_mut(&mut self) -> &mut f32 {
        &mut self.lock_aim_to_target_speed
    }
    fn force1p_on_zoom(&self) -> &bool {
        &self.force1p_on_zoom
    }
    fn force1p_on_zoom_mut(&mut self) -> &mut bool {
        &mut self.force1p_on_zoom
    }
}

impl super::core::GameDataContainerTrait for SoldierAimingSimulationData {
}

impl super::core::DataContainerTrait for SoldierAimingSimulationData {
}

pub static SOLDIERAIMINGSIMULATIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierAimingSimulationData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::GAMEDATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierAimingSimulationData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ZoomLevels",
                flags: MemberInfoFlags::new(144),
                field_type: "ZoomLevelData-Array",
                rust_offset: offset_of!(SoldierAimingSimulationData, zoom_levels),
            },
            FieldInfoData {
                name: "ReturnToZoomAfterReload",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierAimingSimulationData, return_to_zoom_after_reload),
            },
            FieldInfoData {
                name: "IgnoreZoomToggle",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierAimingSimulationData, ignore_zoom_toggle),
            },
            FieldInfoData {
                name: "AimAssist",
                flags: MemberInfoFlags::new(0),
                field_type: "SoldierAimAssistData",
                rust_offset: offset_of!(SoldierAimingSimulationData, aim_assist),
            },
            FieldInfoData {
                name: "StandPose",
                flags: MemberInfoFlags::new(0),
                field_type: "AimingPoseData",
                rust_offset: offset_of!(SoldierAimingSimulationData, stand_pose),
            },
            FieldInfoData {
                name: "CrouchPose",
                flags: MemberInfoFlags::new(0),
                field_type: "AimingPoseData",
                rust_offset: offset_of!(SoldierAimingSimulationData, crouch_pose),
            },
            FieldInfoData {
                name: "PronePose",
                flags: MemberInfoFlags::new(0),
                field_type: "AimingPoseData",
                rust_offset: offset_of!(SoldierAimingSimulationData, prone_pose),
            },
            FieldInfoData {
                name: "ZoomTransitionTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierAimingSimulationData, zoom_transition_time),
            },
            FieldInfoData {
                name: "ZoomTransitionTimeArray",
                flags: MemberInfoFlags::new(144),
                field_type: "ZoomLevelSpecificTransitionTime-Array",
                rust_offset: offset_of!(SoldierAimingSimulationData, zoom_transition_time_array),
            },
            FieldInfoData {
                name: "UpdateCameraFOV",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierAimingSimulationData, update_camera_f_o_v),
            },
            FieldInfoData {
                name: "FovDelayTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierAimingSimulationData, fov_delay_time),
            },
            FieldInfoData {
                name: "FovTransitionTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierAimingSimulationData, fov_transition_time),
            },
            FieldInfoData {
                name: "AimingRange",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierAimingSimulationData, aiming_range),
            },
            FieldInfoData {
                name: "LockAimToTargetSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierAimingSimulationData, lock_aim_to_target_speed),
            },
            FieldInfoData {
                name: "Force1pOnZoom",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierAimingSimulationData, force1p_on_zoom),
            },
        ],
    }),
    array_type: Some(SOLDIERAIMINGSIMULATIONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoldierAimingSimulationData {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERAIMINGSIMULATIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOLDIERAIMINGSIMULATIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierAimingSimulationData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SoldierAimingSimulationData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ZoomLevelData {
    pub _glacier_base: super::core::DataContainer,
    pub field_of_view: f32,
    pub field_of_view_s_p: f32,
    pub field_of_view_transition: Option<Arc<Mutex<dyn super::gameplay_sim::FOVTransitionDataTrait>>>,
    pub allow_field_of_view_scaling: bool,
    pub look_speed_multiplier: f32,
    pub sprint_look_speed_multiplier: f32,
    pub look_speed_sensitivity_profile_option: Option<Arc<Mutex<dyn super::gameplay_sim::ProfileOptionDataFloatTrait>>>,
    pub move_speed_multiplier: f32,
    pub sway_pitch_magnitude: f32,
    pub sway_yaw_magnitude: f32,
    pub supported_sway_pitch_magnitude: f32,
    pub supported_sway_yaw_magnitude: f32,
    pub suppressed_sway_pitch_magnitude: f32,
    pub suppressed_sway_yaw_magnitude: f32,
    pub suppressed_sway_min_factor: f32,
    pub time_pitch_multiplier: f32,
    pub time_yaw_multiplier: f32,
    pub dispersion_multiplier: f32,
    pub dispersion_rotation: f32,
    pub recoil_multiplier: f32,
    pub recoil_fov_multiplier: f32,
    pub camera_impulse_multiplier: f32,
    pub fade_to_black_in_zoom_transition: bool,
    pub start_fade_to_black_at_time: f32,
    pub fade_to_black_duration: f32,
    pub start_fade_from_black_at_time: f32,
    pub fade_from_black_duration: f32,
    pub screen_exposure_area_scale: f32,
    pub on_activate_event_type: ZoomLevelActivateEventType,
    pub use_weapon_mesh_zoom1p: bool,
    pub attract_yaw_strength: f32,
    pub attract_pitch_strength: f32,
}

pub trait ZoomLevelDataTrait: super::core::DataContainerTrait {
    fn field_of_view(&self) -> &f32;
    fn field_of_view_mut(&mut self) -> &mut f32;
    fn field_of_view_s_p(&self) -> &f32;
    fn field_of_view_s_p_mut(&mut self) -> &mut f32;
    fn field_of_view_transition(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::FOVTransitionDataTrait>>>;
    fn field_of_view_transition_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::FOVTransitionDataTrait>>>;
    fn allow_field_of_view_scaling(&self) -> &bool;
    fn allow_field_of_view_scaling_mut(&mut self) -> &mut bool;
    fn look_speed_multiplier(&self) -> &f32;
    fn look_speed_multiplier_mut(&mut self) -> &mut f32;
    fn sprint_look_speed_multiplier(&self) -> &f32;
    fn sprint_look_speed_multiplier_mut(&mut self) -> &mut f32;
    fn look_speed_sensitivity_profile_option(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::ProfileOptionDataFloatTrait>>>;
    fn look_speed_sensitivity_profile_option_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::ProfileOptionDataFloatTrait>>>;
    fn move_speed_multiplier(&self) -> &f32;
    fn move_speed_multiplier_mut(&mut self) -> &mut f32;
    fn sway_pitch_magnitude(&self) -> &f32;
    fn sway_pitch_magnitude_mut(&mut self) -> &mut f32;
    fn sway_yaw_magnitude(&self) -> &f32;
    fn sway_yaw_magnitude_mut(&mut self) -> &mut f32;
    fn supported_sway_pitch_magnitude(&self) -> &f32;
    fn supported_sway_pitch_magnitude_mut(&mut self) -> &mut f32;
    fn supported_sway_yaw_magnitude(&self) -> &f32;
    fn supported_sway_yaw_magnitude_mut(&mut self) -> &mut f32;
    fn suppressed_sway_pitch_magnitude(&self) -> &f32;
    fn suppressed_sway_pitch_magnitude_mut(&mut self) -> &mut f32;
    fn suppressed_sway_yaw_magnitude(&self) -> &f32;
    fn suppressed_sway_yaw_magnitude_mut(&mut self) -> &mut f32;
    fn suppressed_sway_min_factor(&self) -> &f32;
    fn suppressed_sway_min_factor_mut(&mut self) -> &mut f32;
    fn time_pitch_multiplier(&self) -> &f32;
    fn time_pitch_multiplier_mut(&mut self) -> &mut f32;
    fn time_yaw_multiplier(&self) -> &f32;
    fn time_yaw_multiplier_mut(&mut self) -> &mut f32;
    fn dispersion_multiplier(&self) -> &f32;
    fn dispersion_multiplier_mut(&mut self) -> &mut f32;
    fn dispersion_rotation(&self) -> &f32;
    fn dispersion_rotation_mut(&mut self) -> &mut f32;
    fn recoil_multiplier(&self) -> &f32;
    fn recoil_multiplier_mut(&mut self) -> &mut f32;
    fn recoil_fov_multiplier(&self) -> &f32;
    fn recoil_fov_multiplier_mut(&mut self) -> &mut f32;
    fn camera_impulse_multiplier(&self) -> &f32;
    fn camera_impulse_multiplier_mut(&mut self) -> &mut f32;
    fn fade_to_black_in_zoom_transition(&self) -> &bool;
    fn fade_to_black_in_zoom_transition_mut(&mut self) -> &mut bool;
    fn start_fade_to_black_at_time(&self) -> &f32;
    fn start_fade_to_black_at_time_mut(&mut self) -> &mut f32;
    fn fade_to_black_duration(&self) -> &f32;
    fn fade_to_black_duration_mut(&mut self) -> &mut f32;
    fn start_fade_from_black_at_time(&self) -> &f32;
    fn start_fade_from_black_at_time_mut(&mut self) -> &mut f32;
    fn fade_from_black_duration(&self) -> &f32;
    fn fade_from_black_duration_mut(&mut self) -> &mut f32;
    fn screen_exposure_area_scale(&self) -> &f32;
    fn screen_exposure_area_scale_mut(&mut self) -> &mut f32;
    fn on_activate_event_type(&self) -> &ZoomLevelActivateEventType;
    fn on_activate_event_type_mut(&mut self) -> &mut ZoomLevelActivateEventType;
    fn use_weapon_mesh_zoom1p(&self) -> &bool;
    fn use_weapon_mesh_zoom1p_mut(&mut self) -> &mut bool;
    fn attract_yaw_strength(&self) -> &f32;
    fn attract_yaw_strength_mut(&mut self) -> &mut f32;
    fn attract_pitch_strength(&self) -> &f32;
    fn attract_pitch_strength_mut(&mut self) -> &mut f32;
}

impl ZoomLevelDataTrait for ZoomLevelData {
    fn field_of_view(&self) -> &f32 {
        &self.field_of_view
    }
    fn field_of_view_mut(&mut self) -> &mut f32 {
        &mut self.field_of_view
    }
    fn field_of_view_s_p(&self) -> &f32 {
        &self.field_of_view_s_p
    }
    fn field_of_view_s_p_mut(&mut self) -> &mut f32 {
        &mut self.field_of_view_s_p
    }
    fn field_of_view_transition(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::FOVTransitionDataTrait>>> {
        &self.field_of_view_transition
    }
    fn field_of_view_transition_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::FOVTransitionDataTrait>>> {
        &mut self.field_of_view_transition
    }
    fn allow_field_of_view_scaling(&self) -> &bool {
        &self.allow_field_of_view_scaling
    }
    fn allow_field_of_view_scaling_mut(&mut self) -> &mut bool {
        &mut self.allow_field_of_view_scaling
    }
    fn look_speed_multiplier(&self) -> &f32 {
        &self.look_speed_multiplier
    }
    fn look_speed_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.look_speed_multiplier
    }
    fn sprint_look_speed_multiplier(&self) -> &f32 {
        &self.sprint_look_speed_multiplier
    }
    fn sprint_look_speed_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.sprint_look_speed_multiplier
    }
    fn look_speed_sensitivity_profile_option(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::ProfileOptionDataFloatTrait>>> {
        &self.look_speed_sensitivity_profile_option
    }
    fn look_speed_sensitivity_profile_option_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::ProfileOptionDataFloatTrait>>> {
        &mut self.look_speed_sensitivity_profile_option
    }
    fn move_speed_multiplier(&self) -> &f32 {
        &self.move_speed_multiplier
    }
    fn move_speed_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.move_speed_multiplier
    }
    fn sway_pitch_magnitude(&self) -> &f32 {
        &self.sway_pitch_magnitude
    }
    fn sway_pitch_magnitude_mut(&mut self) -> &mut f32 {
        &mut self.sway_pitch_magnitude
    }
    fn sway_yaw_magnitude(&self) -> &f32 {
        &self.sway_yaw_magnitude
    }
    fn sway_yaw_magnitude_mut(&mut self) -> &mut f32 {
        &mut self.sway_yaw_magnitude
    }
    fn supported_sway_pitch_magnitude(&self) -> &f32 {
        &self.supported_sway_pitch_magnitude
    }
    fn supported_sway_pitch_magnitude_mut(&mut self) -> &mut f32 {
        &mut self.supported_sway_pitch_magnitude
    }
    fn supported_sway_yaw_magnitude(&self) -> &f32 {
        &self.supported_sway_yaw_magnitude
    }
    fn supported_sway_yaw_magnitude_mut(&mut self) -> &mut f32 {
        &mut self.supported_sway_yaw_magnitude
    }
    fn suppressed_sway_pitch_magnitude(&self) -> &f32 {
        &self.suppressed_sway_pitch_magnitude
    }
    fn suppressed_sway_pitch_magnitude_mut(&mut self) -> &mut f32 {
        &mut self.suppressed_sway_pitch_magnitude
    }
    fn suppressed_sway_yaw_magnitude(&self) -> &f32 {
        &self.suppressed_sway_yaw_magnitude
    }
    fn suppressed_sway_yaw_magnitude_mut(&mut self) -> &mut f32 {
        &mut self.suppressed_sway_yaw_magnitude
    }
    fn suppressed_sway_min_factor(&self) -> &f32 {
        &self.suppressed_sway_min_factor
    }
    fn suppressed_sway_min_factor_mut(&mut self) -> &mut f32 {
        &mut self.suppressed_sway_min_factor
    }
    fn time_pitch_multiplier(&self) -> &f32 {
        &self.time_pitch_multiplier
    }
    fn time_pitch_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.time_pitch_multiplier
    }
    fn time_yaw_multiplier(&self) -> &f32 {
        &self.time_yaw_multiplier
    }
    fn time_yaw_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.time_yaw_multiplier
    }
    fn dispersion_multiplier(&self) -> &f32 {
        &self.dispersion_multiplier
    }
    fn dispersion_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.dispersion_multiplier
    }
    fn dispersion_rotation(&self) -> &f32 {
        &self.dispersion_rotation
    }
    fn dispersion_rotation_mut(&mut self) -> &mut f32 {
        &mut self.dispersion_rotation
    }
    fn recoil_multiplier(&self) -> &f32 {
        &self.recoil_multiplier
    }
    fn recoil_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.recoil_multiplier
    }
    fn recoil_fov_multiplier(&self) -> &f32 {
        &self.recoil_fov_multiplier
    }
    fn recoil_fov_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.recoil_fov_multiplier
    }
    fn camera_impulse_multiplier(&self) -> &f32 {
        &self.camera_impulse_multiplier
    }
    fn camera_impulse_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.camera_impulse_multiplier
    }
    fn fade_to_black_in_zoom_transition(&self) -> &bool {
        &self.fade_to_black_in_zoom_transition
    }
    fn fade_to_black_in_zoom_transition_mut(&mut self) -> &mut bool {
        &mut self.fade_to_black_in_zoom_transition
    }
    fn start_fade_to_black_at_time(&self) -> &f32 {
        &self.start_fade_to_black_at_time
    }
    fn start_fade_to_black_at_time_mut(&mut self) -> &mut f32 {
        &mut self.start_fade_to_black_at_time
    }
    fn fade_to_black_duration(&self) -> &f32 {
        &self.fade_to_black_duration
    }
    fn fade_to_black_duration_mut(&mut self) -> &mut f32 {
        &mut self.fade_to_black_duration
    }
    fn start_fade_from_black_at_time(&self) -> &f32 {
        &self.start_fade_from_black_at_time
    }
    fn start_fade_from_black_at_time_mut(&mut self) -> &mut f32 {
        &mut self.start_fade_from_black_at_time
    }
    fn fade_from_black_duration(&self) -> &f32 {
        &self.fade_from_black_duration
    }
    fn fade_from_black_duration_mut(&mut self) -> &mut f32 {
        &mut self.fade_from_black_duration
    }
    fn screen_exposure_area_scale(&self) -> &f32 {
        &self.screen_exposure_area_scale
    }
    fn screen_exposure_area_scale_mut(&mut self) -> &mut f32 {
        &mut self.screen_exposure_area_scale
    }
    fn on_activate_event_type(&self) -> &ZoomLevelActivateEventType {
        &self.on_activate_event_type
    }
    fn on_activate_event_type_mut(&mut self) -> &mut ZoomLevelActivateEventType {
        &mut self.on_activate_event_type
    }
    fn use_weapon_mesh_zoom1p(&self) -> &bool {
        &self.use_weapon_mesh_zoom1p
    }
    fn use_weapon_mesh_zoom1p_mut(&mut self) -> &mut bool {
        &mut self.use_weapon_mesh_zoom1p
    }
    fn attract_yaw_strength(&self) -> &f32 {
        &self.attract_yaw_strength
    }
    fn attract_yaw_strength_mut(&mut self) -> &mut f32 {
        &mut self.attract_yaw_strength
    }
    fn attract_pitch_strength(&self) -> &f32 {
        &self.attract_pitch_strength
    }
    fn attract_pitch_strength_mut(&mut self) -> &mut f32 {
        &mut self.attract_pitch_strength
    }
}

impl super::core::DataContainerTrait for ZoomLevelData {
}

pub static ZOOMLEVELDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ZoomLevelData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ZoomLevelData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "FieldOfView",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ZoomLevelData, field_of_view),
            },
            FieldInfoData {
                name: "FieldOfViewSP",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ZoomLevelData, field_of_view_s_p),
            },
            FieldInfoData {
                name: "FieldOfViewTransition",
                flags: MemberInfoFlags::new(0),
                field_type: "FOVTransitionData",
                rust_offset: offset_of!(ZoomLevelData, field_of_view_transition),
            },
            FieldInfoData {
                name: "AllowFieldOfViewScaling",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ZoomLevelData, allow_field_of_view_scaling),
            },
            FieldInfoData {
                name: "LookSpeedMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ZoomLevelData, look_speed_multiplier),
            },
            FieldInfoData {
                name: "SprintLookSpeedMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ZoomLevelData, sprint_look_speed_multiplier),
            },
            FieldInfoData {
                name: "LookSpeedSensitivityProfileOption",
                flags: MemberInfoFlags::new(0),
                field_type: "ProfileOptionDataFloat",
                rust_offset: offset_of!(ZoomLevelData, look_speed_sensitivity_profile_option),
            },
            FieldInfoData {
                name: "MoveSpeedMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ZoomLevelData, move_speed_multiplier),
            },
            FieldInfoData {
                name: "SwayPitchMagnitude",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ZoomLevelData, sway_pitch_magnitude),
            },
            FieldInfoData {
                name: "SwayYawMagnitude",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ZoomLevelData, sway_yaw_magnitude),
            },
            FieldInfoData {
                name: "SupportedSwayPitchMagnitude",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ZoomLevelData, supported_sway_pitch_magnitude),
            },
            FieldInfoData {
                name: "SupportedSwayYawMagnitude",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ZoomLevelData, supported_sway_yaw_magnitude),
            },
            FieldInfoData {
                name: "SuppressedSwayPitchMagnitude",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ZoomLevelData, suppressed_sway_pitch_magnitude),
            },
            FieldInfoData {
                name: "SuppressedSwayYawMagnitude",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ZoomLevelData, suppressed_sway_yaw_magnitude),
            },
            FieldInfoData {
                name: "SuppressedSwayMinFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ZoomLevelData, suppressed_sway_min_factor),
            },
            FieldInfoData {
                name: "TimePitchMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ZoomLevelData, time_pitch_multiplier),
            },
            FieldInfoData {
                name: "TimeYawMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ZoomLevelData, time_yaw_multiplier),
            },
            FieldInfoData {
                name: "DispersionMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ZoomLevelData, dispersion_multiplier),
            },
            FieldInfoData {
                name: "DispersionRotation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ZoomLevelData, dispersion_rotation),
            },
            FieldInfoData {
                name: "RecoilMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ZoomLevelData, recoil_multiplier),
            },
            FieldInfoData {
                name: "RecoilFovMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ZoomLevelData, recoil_fov_multiplier),
            },
            FieldInfoData {
                name: "CameraImpulseMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ZoomLevelData, camera_impulse_multiplier),
            },
            FieldInfoData {
                name: "FadeToBlackInZoomTransition",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ZoomLevelData, fade_to_black_in_zoom_transition),
            },
            FieldInfoData {
                name: "StartFadeToBlackAtTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ZoomLevelData, start_fade_to_black_at_time),
            },
            FieldInfoData {
                name: "FadeToBlackDuration",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ZoomLevelData, fade_to_black_duration),
            },
            FieldInfoData {
                name: "StartFadeFromBlackAtTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ZoomLevelData, start_fade_from_black_at_time),
            },
            FieldInfoData {
                name: "FadeFromBlackDuration",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ZoomLevelData, fade_from_black_duration),
            },
            FieldInfoData {
                name: "ScreenExposureAreaScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ZoomLevelData, screen_exposure_area_scale),
            },
            FieldInfoData {
                name: "OnActivateEventType",
                flags: MemberInfoFlags::new(0),
                field_type: "ZoomLevelActivateEventType",
                rust_offset: offset_of!(ZoomLevelData, on_activate_event_type),
            },
            FieldInfoData {
                name: "UseWeaponMeshZoom1p",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ZoomLevelData, use_weapon_mesh_zoom1p),
            },
            FieldInfoData {
                name: "AttractYawStrength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ZoomLevelData, attract_yaw_strength),
            },
            FieldInfoData {
                name: "AttractPitchStrength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ZoomLevelData, attract_pitch_strength),
            },
        ],
    }),
    array_type: Some(ZOOMLEVELDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ZoomLevelData {
    fn type_info(&self) -> &'static TypeInfo {
        ZOOMLEVELDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ZOOMLEVELDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ZoomLevelData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("ZoomLevelData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum ZoomLevelActivateEventType {
    #[default]
    ZoomLevelActivateEventType_Disable = 0,
    ZoomLevelActivateEventType_Enable = 1,
    ZoomLevelActivateEventType_ToggleOnLightSwitch = 2,
}

pub static ZOOMLEVELACTIVATEEVENTTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ZoomLevelActivateEventType",
    flags: MemberInfoFlags::new(49429),
    module: "SoldierShared",
    data: TypeInfoData::Enum,
    array_type: Some(ZOOMLEVELACTIVATEEVENTTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for ZoomLevelActivateEventType {
    fn type_info(&self) -> &'static TypeInfo {
        ZOOMLEVELACTIVATEEVENTTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ZOOMLEVELACTIVATEEVENTTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ZoomLevelActivateEventType-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("ZoomLevelActivateEventType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlatformAimAssistData {
    pub platform: super::core::GamePlatform,
    pub aim_assist_data: Option<Arc<Mutex<dyn SoldierAimAssistDataTrait>>>,
}

pub trait PlatformAimAssistDataTrait: TypeObject {
    fn platform(&self) -> &super::core::GamePlatform;
    fn platform_mut(&mut self) -> &mut super::core::GamePlatform;
    fn aim_assist_data(&self) -> &Option<Arc<Mutex<dyn SoldierAimAssistDataTrait>>>;
    fn aim_assist_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoldierAimAssistDataTrait>>>;
}

impl PlatformAimAssistDataTrait for PlatformAimAssistData {
    fn platform(&self) -> &super::core::GamePlatform {
        &self.platform
    }
    fn platform_mut(&mut self) -> &mut super::core::GamePlatform {
        &mut self.platform
    }
    fn aim_assist_data(&self) -> &Option<Arc<Mutex<dyn SoldierAimAssistDataTrait>>> {
        &self.aim_assist_data
    }
    fn aim_assist_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoldierAimAssistDataTrait>>> {
        &mut self.aim_assist_data
    }
}

pub static PLATFORMAIMASSISTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlatformAimAssistData",
    flags: MemberInfoFlags::new(73),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlatformAimAssistData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Platform",
                flags: MemberInfoFlags::new(0),
                field_type: "GamePlatform",
                rust_offset: offset_of!(PlatformAimAssistData, platform),
            },
            FieldInfoData {
                name: "AimAssistData",
                flags: MemberInfoFlags::new(0),
                field_type: "SoldierAimAssistData",
                rust_offset: offset_of!(PlatformAimAssistData, aim_assist_data),
            },
        ],
    }),
    array_type: Some(PLATFORMAIMASSISTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PlatformAimAssistData {
    fn type_info(&self) -> &'static TypeInfo {
        PLATFORMAIMASSISTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static PLATFORMAIMASSISTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlatformAimAssistData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("PlatformAimAssistData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoldierAimAssistData {
    pub _glacier_base: super::core::GameDataContainer,
    pub input_polynomial: Vec<f32>,
    pub zoomed_input_polynomial: Vec<f32>,
    pub use_yaw_acceleration: bool,
    pub use_pitch_acceleration: bool,
    pub acceleration_input_threshold: f32,
    pub acceleration_multiplier: f32,
    pub acceleration_damping: f32,
    pub acceleration_time_threshold: f32,
    pub squared_acceleration: f32,
    pub max_acceleration: super::core::Vec2,
    pub yaw_speed_strength: f32,
    pub pitch_speed_strength: f32,
    pub attract_distance_fall_offs: super::core::Vec2,
    pub attract_soft_zone: f32,
    pub attract_user_input_multiplier: f32,
    pub attract_user_input_multiplier_no_zoom: f32,
    pub attract_own_speed_influence: f32,
    pub attract_target_speed_influence: f32,
    pub attract_start_input_threshold: f32,
    pub attract_move_input_cap: f32,
    pub attract_yaw_strength: f32,
    pub attract_pitch_strength: f32,
    pub max_to_target_angle: f32,
    pub max_to_target_x_z_angle: f32,
    pub sticky_box_scale: super::core::Vec3,
    pub sticky_distance_scale: super::core::Vec3,
    pub view_obstructed_keep_time: f32,
    pub snap_zoom_lateral_speed_limit: f32,
    pub snap_zoom_time: f32,
    pub snap_zoom_user_shorter_weapon_time: bool,
    pub snap_zoom_post_time_no_input: f32,
    pub snap_zoom_post_time: f32,
    pub snap_zoom_post_time_dynamic_point: bool,
    pub snap_zoom_reticle_point_priority: u32,
    pub snap_zoom_break_time_at_max_input: f32,
    pub snap_zoom_break_max_input: f32,
    pub snap_zoom_break_min_angle: f32,
    pub snap_zoom_spam_guard_time: f32,
    pub soldier_backup_skeleton_collision_data: Option<Arc<Mutex<dyn super::game_shared::SkeletonCollisionDataTrait>>>,
    pub force_soldier_backup_skeleton_collision_use: bool,
    pub check_bone_center_only_distance: f32,
    pub disable_forced_target_recalc_distance: f32,
    pub override_aiming_range: f32,
    pub override_aiming_range_crouch: f32,
    pub override_aiming_range_prone: f32,
    pub snap_box_scale: super::core::Vec3,
    pub snap_distance_scale: super::core::Vec3,
    pub eye_pos_offset: super::core::Vec3,
}

pub trait SoldierAimAssistDataTrait: super::core::GameDataContainerTrait {
    fn input_polynomial(&self) -> &Vec<f32>;
    fn input_polynomial_mut(&mut self) -> &mut Vec<f32>;
    fn zoomed_input_polynomial(&self) -> &Vec<f32>;
    fn zoomed_input_polynomial_mut(&mut self) -> &mut Vec<f32>;
    fn use_yaw_acceleration(&self) -> &bool;
    fn use_yaw_acceleration_mut(&mut self) -> &mut bool;
    fn use_pitch_acceleration(&self) -> &bool;
    fn use_pitch_acceleration_mut(&mut self) -> &mut bool;
    fn acceleration_input_threshold(&self) -> &f32;
    fn acceleration_input_threshold_mut(&mut self) -> &mut f32;
    fn acceleration_multiplier(&self) -> &f32;
    fn acceleration_multiplier_mut(&mut self) -> &mut f32;
    fn acceleration_damping(&self) -> &f32;
    fn acceleration_damping_mut(&mut self) -> &mut f32;
    fn acceleration_time_threshold(&self) -> &f32;
    fn acceleration_time_threshold_mut(&mut self) -> &mut f32;
    fn squared_acceleration(&self) -> &f32;
    fn squared_acceleration_mut(&mut self) -> &mut f32;
    fn max_acceleration(&self) -> &super::core::Vec2;
    fn max_acceleration_mut(&mut self) -> &mut super::core::Vec2;
    fn yaw_speed_strength(&self) -> &f32;
    fn yaw_speed_strength_mut(&mut self) -> &mut f32;
    fn pitch_speed_strength(&self) -> &f32;
    fn pitch_speed_strength_mut(&mut self) -> &mut f32;
    fn attract_distance_fall_offs(&self) -> &super::core::Vec2;
    fn attract_distance_fall_offs_mut(&mut self) -> &mut super::core::Vec2;
    fn attract_soft_zone(&self) -> &f32;
    fn attract_soft_zone_mut(&mut self) -> &mut f32;
    fn attract_user_input_multiplier(&self) -> &f32;
    fn attract_user_input_multiplier_mut(&mut self) -> &mut f32;
    fn attract_user_input_multiplier_no_zoom(&self) -> &f32;
    fn attract_user_input_multiplier_no_zoom_mut(&mut self) -> &mut f32;
    fn attract_own_speed_influence(&self) -> &f32;
    fn attract_own_speed_influence_mut(&mut self) -> &mut f32;
    fn attract_target_speed_influence(&self) -> &f32;
    fn attract_target_speed_influence_mut(&mut self) -> &mut f32;
    fn attract_start_input_threshold(&self) -> &f32;
    fn attract_start_input_threshold_mut(&mut self) -> &mut f32;
    fn attract_move_input_cap(&self) -> &f32;
    fn attract_move_input_cap_mut(&mut self) -> &mut f32;
    fn attract_yaw_strength(&self) -> &f32;
    fn attract_yaw_strength_mut(&mut self) -> &mut f32;
    fn attract_pitch_strength(&self) -> &f32;
    fn attract_pitch_strength_mut(&mut self) -> &mut f32;
    fn max_to_target_angle(&self) -> &f32;
    fn max_to_target_angle_mut(&mut self) -> &mut f32;
    fn max_to_target_x_z_angle(&self) -> &f32;
    fn max_to_target_x_z_angle_mut(&mut self) -> &mut f32;
    fn sticky_box_scale(&self) -> &super::core::Vec3;
    fn sticky_box_scale_mut(&mut self) -> &mut super::core::Vec3;
    fn sticky_distance_scale(&self) -> &super::core::Vec3;
    fn sticky_distance_scale_mut(&mut self) -> &mut super::core::Vec3;
    fn view_obstructed_keep_time(&self) -> &f32;
    fn view_obstructed_keep_time_mut(&mut self) -> &mut f32;
    fn snap_zoom_lateral_speed_limit(&self) -> &f32;
    fn snap_zoom_lateral_speed_limit_mut(&mut self) -> &mut f32;
    fn snap_zoom_time(&self) -> &f32;
    fn snap_zoom_time_mut(&mut self) -> &mut f32;
    fn snap_zoom_user_shorter_weapon_time(&self) -> &bool;
    fn snap_zoom_user_shorter_weapon_time_mut(&mut self) -> &mut bool;
    fn snap_zoom_post_time_no_input(&self) -> &f32;
    fn snap_zoom_post_time_no_input_mut(&mut self) -> &mut f32;
    fn snap_zoom_post_time(&self) -> &f32;
    fn snap_zoom_post_time_mut(&mut self) -> &mut f32;
    fn snap_zoom_post_time_dynamic_point(&self) -> &bool;
    fn snap_zoom_post_time_dynamic_point_mut(&mut self) -> &mut bool;
    fn snap_zoom_reticle_point_priority(&self) -> &u32;
    fn snap_zoom_reticle_point_priority_mut(&mut self) -> &mut u32;
    fn snap_zoom_break_time_at_max_input(&self) -> &f32;
    fn snap_zoom_break_time_at_max_input_mut(&mut self) -> &mut f32;
    fn snap_zoom_break_max_input(&self) -> &f32;
    fn snap_zoom_break_max_input_mut(&mut self) -> &mut f32;
    fn snap_zoom_break_min_angle(&self) -> &f32;
    fn snap_zoom_break_min_angle_mut(&mut self) -> &mut f32;
    fn snap_zoom_spam_guard_time(&self) -> &f32;
    fn snap_zoom_spam_guard_time_mut(&mut self) -> &mut f32;
    fn soldier_backup_skeleton_collision_data(&self) -> &Option<Arc<Mutex<dyn super::game_shared::SkeletonCollisionDataTrait>>>;
    fn soldier_backup_skeleton_collision_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::game_shared::SkeletonCollisionDataTrait>>>;
    fn force_soldier_backup_skeleton_collision_use(&self) -> &bool;
    fn force_soldier_backup_skeleton_collision_use_mut(&mut self) -> &mut bool;
    fn check_bone_center_only_distance(&self) -> &f32;
    fn check_bone_center_only_distance_mut(&mut self) -> &mut f32;
    fn disable_forced_target_recalc_distance(&self) -> &f32;
    fn disable_forced_target_recalc_distance_mut(&mut self) -> &mut f32;
    fn override_aiming_range(&self) -> &f32;
    fn override_aiming_range_mut(&mut self) -> &mut f32;
    fn override_aiming_range_crouch(&self) -> &f32;
    fn override_aiming_range_crouch_mut(&mut self) -> &mut f32;
    fn override_aiming_range_prone(&self) -> &f32;
    fn override_aiming_range_prone_mut(&mut self) -> &mut f32;
    fn snap_box_scale(&self) -> &super::core::Vec3;
    fn snap_box_scale_mut(&mut self) -> &mut super::core::Vec3;
    fn snap_distance_scale(&self) -> &super::core::Vec3;
    fn snap_distance_scale_mut(&mut self) -> &mut super::core::Vec3;
    fn eye_pos_offset(&self) -> &super::core::Vec3;
    fn eye_pos_offset_mut(&mut self) -> &mut super::core::Vec3;
}

impl SoldierAimAssistDataTrait for SoldierAimAssistData {
    fn input_polynomial(&self) -> &Vec<f32> {
        &self.input_polynomial
    }
    fn input_polynomial_mut(&mut self) -> &mut Vec<f32> {
        &mut self.input_polynomial
    }
    fn zoomed_input_polynomial(&self) -> &Vec<f32> {
        &self.zoomed_input_polynomial
    }
    fn zoomed_input_polynomial_mut(&mut self) -> &mut Vec<f32> {
        &mut self.zoomed_input_polynomial
    }
    fn use_yaw_acceleration(&self) -> &bool {
        &self.use_yaw_acceleration
    }
    fn use_yaw_acceleration_mut(&mut self) -> &mut bool {
        &mut self.use_yaw_acceleration
    }
    fn use_pitch_acceleration(&self) -> &bool {
        &self.use_pitch_acceleration
    }
    fn use_pitch_acceleration_mut(&mut self) -> &mut bool {
        &mut self.use_pitch_acceleration
    }
    fn acceleration_input_threshold(&self) -> &f32 {
        &self.acceleration_input_threshold
    }
    fn acceleration_input_threshold_mut(&mut self) -> &mut f32 {
        &mut self.acceleration_input_threshold
    }
    fn acceleration_multiplier(&self) -> &f32 {
        &self.acceleration_multiplier
    }
    fn acceleration_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.acceleration_multiplier
    }
    fn acceleration_damping(&self) -> &f32 {
        &self.acceleration_damping
    }
    fn acceleration_damping_mut(&mut self) -> &mut f32 {
        &mut self.acceleration_damping
    }
    fn acceleration_time_threshold(&self) -> &f32 {
        &self.acceleration_time_threshold
    }
    fn acceleration_time_threshold_mut(&mut self) -> &mut f32 {
        &mut self.acceleration_time_threshold
    }
    fn squared_acceleration(&self) -> &f32 {
        &self.squared_acceleration
    }
    fn squared_acceleration_mut(&mut self) -> &mut f32 {
        &mut self.squared_acceleration
    }
    fn max_acceleration(&self) -> &super::core::Vec2 {
        &self.max_acceleration
    }
    fn max_acceleration_mut(&mut self) -> &mut super::core::Vec2 {
        &mut self.max_acceleration
    }
    fn yaw_speed_strength(&self) -> &f32 {
        &self.yaw_speed_strength
    }
    fn yaw_speed_strength_mut(&mut self) -> &mut f32 {
        &mut self.yaw_speed_strength
    }
    fn pitch_speed_strength(&self) -> &f32 {
        &self.pitch_speed_strength
    }
    fn pitch_speed_strength_mut(&mut self) -> &mut f32 {
        &mut self.pitch_speed_strength
    }
    fn attract_distance_fall_offs(&self) -> &super::core::Vec2 {
        &self.attract_distance_fall_offs
    }
    fn attract_distance_fall_offs_mut(&mut self) -> &mut super::core::Vec2 {
        &mut self.attract_distance_fall_offs
    }
    fn attract_soft_zone(&self) -> &f32 {
        &self.attract_soft_zone
    }
    fn attract_soft_zone_mut(&mut self) -> &mut f32 {
        &mut self.attract_soft_zone
    }
    fn attract_user_input_multiplier(&self) -> &f32 {
        &self.attract_user_input_multiplier
    }
    fn attract_user_input_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.attract_user_input_multiplier
    }
    fn attract_user_input_multiplier_no_zoom(&self) -> &f32 {
        &self.attract_user_input_multiplier_no_zoom
    }
    fn attract_user_input_multiplier_no_zoom_mut(&mut self) -> &mut f32 {
        &mut self.attract_user_input_multiplier_no_zoom
    }
    fn attract_own_speed_influence(&self) -> &f32 {
        &self.attract_own_speed_influence
    }
    fn attract_own_speed_influence_mut(&mut self) -> &mut f32 {
        &mut self.attract_own_speed_influence
    }
    fn attract_target_speed_influence(&self) -> &f32 {
        &self.attract_target_speed_influence
    }
    fn attract_target_speed_influence_mut(&mut self) -> &mut f32 {
        &mut self.attract_target_speed_influence
    }
    fn attract_start_input_threshold(&self) -> &f32 {
        &self.attract_start_input_threshold
    }
    fn attract_start_input_threshold_mut(&mut self) -> &mut f32 {
        &mut self.attract_start_input_threshold
    }
    fn attract_move_input_cap(&self) -> &f32 {
        &self.attract_move_input_cap
    }
    fn attract_move_input_cap_mut(&mut self) -> &mut f32 {
        &mut self.attract_move_input_cap
    }
    fn attract_yaw_strength(&self) -> &f32 {
        &self.attract_yaw_strength
    }
    fn attract_yaw_strength_mut(&mut self) -> &mut f32 {
        &mut self.attract_yaw_strength
    }
    fn attract_pitch_strength(&self) -> &f32 {
        &self.attract_pitch_strength
    }
    fn attract_pitch_strength_mut(&mut self) -> &mut f32 {
        &mut self.attract_pitch_strength
    }
    fn max_to_target_angle(&self) -> &f32 {
        &self.max_to_target_angle
    }
    fn max_to_target_angle_mut(&mut self) -> &mut f32 {
        &mut self.max_to_target_angle
    }
    fn max_to_target_x_z_angle(&self) -> &f32 {
        &self.max_to_target_x_z_angle
    }
    fn max_to_target_x_z_angle_mut(&mut self) -> &mut f32 {
        &mut self.max_to_target_x_z_angle
    }
    fn sticky_box_scale(&self) -> &super::core::Vec3 {
        &self.sticky_box_scale
    }
    fn sticky_box_scale_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.sticky_box_scale
    }
    fn sticky_distance_scale(&self) -> &super::core::Vec3 {
        &self.sticky_distance_scale
    }
    fn sticky_distance_scale_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.sticky_distance_scale
    }
    fn view_obstructed_keep_time(&self) -> &f32 {
        &self.view_obstructed_keep_time
    }
    fn view_obstructed_keep_time_mut(&mut self) -> &mut f32 {
        &mut self.view_obstructed_keep_time
    }
    fn snap_zoom_lateral_speed_limit(&self) -> &f32 {
        &self.snap_zoom_lateral_speed_limit
    }
    fn snap_zoom_lateral_speed_limit_mut(&mut self) -> &mut f32 {
        &mut self.snap_zoom_lateral_speed_limit
    }
    fn snap_zoom_time(&self) -> &f32 {
        &self.snap_zoom_time
    }
    fn snap_zoom_time_mut(&mut self) -> &mut f32 {
        &mut self.snap_zoom_time
    }
    fn snap_zoom_user_shorter_weapon_time(&self) -> &bool {
        &self.snap_zoom_user_shorter_weapon_time
    }
    fn snap_zoom_user_shorter_weapon_time_mut(&mut self) -> &mut bool {
        &mut self.snap_zoom_user_shorter_weapon_time
    }
    fn snap_zoom_post_time_no_input(&self) -> &f32 {
        &self.snap_zoom_post_time_no_input
    }
    fn snap_zoom_post_time_no_input_mut(&mut self) -> &mut f32 {
        &mut self.snap_zoom_post_time_no_input
    }
    fn snap_zoom_post_time(&self) -> &f32 {
        &self.snap_zoom_post_time
    }
    fn snap_zoom_post_time_mut(&mut self) -> &mut f32 {
        &mut self.snap_zoom_post_time
    }
    fn snap_zoom_post_time_dynamic_point(&self) -> &bool {
        &self.snap_zoom_post_time_dynamic_point
    }
    fn snap_zoom_post_time_dynamic_point_mut(&mut self) -> &mut bool {
        &mut self.snap_zoom_post_time_dynamic_point
    }
    fn snap_zoom_reticle_point_priority(&self) -> &u32 {
        &self.snap_zoom_reticle_point_priority
    }
    fn snap_zoom_reticle_point_priority_mut(&mut self) -> &mut u32 {
        &mut self.snap_zoom_reticle_point_priority
    }
    fn snap_zoom_break_time_at_max_input(&self) -> &f32 {
        &self.snap_zoom_break_time_at_max_input
    }
    fn snap_zoom_break_time_at_max_input_mut(&mut self) -> &mut f32 {
        &mut self.snap_zoom_break_time_at_max_input
    }
    fn snap_zoom_break_max_input(&self) -> &f32 {
        &self.snap_zoom_break_max_input
    }
    fn snap_zoom_break_max_input_mut(&mut self) -> &mut f32 {
        &mut self.snap_zoom_break_max_input
    }
    fn snap_zoom_break_min_angle(&self) -> &f32 {
        &self.snap_zoom_break_min_angle
    }
    fn snap_zoom_break_min_angle_mut(&mut self) -> &mut f32 {
        &mut self.snap_zoom_break_min_angle
    }
    fn snap_zoom_spam_guard_time(&self) -> &f32 {
        &self.snap_zoom_spam_guard_time
    }
    fn snap_zoom_spam_guard_time_mut(&mut self) -> &mut f32 {
        &mut self.snap_zoom_spam_guard_time
    }
    fn soldier_backup_skeleton_collision_data(&self) -> &Option<Arc<Mutex<dyn super::game_shared::SkeletonCollisionDataTrait>>> {
        &self.soldier_backup_skeleton_collision_data
    }
    fn soldier_backup_skeleton_collision_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::game_shared::SkeletonCollisionDataTrait>>> {
        &mut self.soldier_backup_skeleton_collision_data
    }
    fn force_soldier_backup_skeleton_collision_use(&self) -> &bool {
        &self.force_soldier_backup_skeleton_collision_use
    }
    fn force_soldier_backup_skeleton_collision_use_mut(&mut self) -> &mut bool {
        &mut self.force_soldier_backup_skeleton_collision_use
    }
    fn check_bone_center_only_distance(&self) -> &f32 {
        &self.check_bone_center_only_distance
    }
    fn check_bone_center_only_distance_mut(&mut self) -> &mut f32 {
        &mut self.check_bone_center_only_distance
    }
    fn disable_forced_target_recalc_distance(&self) -> &f32 {
        &self.disable_forced_target_recalc_distance
    }
    fn disable_forced_target_recalc_distance_mut(&mut self) -> &mut f32 {
        &mut self.disable_forced_target_recalc_distance
    }
    fn override_aiming_range(&self) -> &f32 {
        &self.override_aiming_range
    }
    fn override_aiming_range_mut(&mut self) -> &mut f32 {
        &mut self.override_aiming_range
    }
    fn override_aiming_range_crouch(&self) -> &f32 {
        &self.override_aiming_range_crouch
    }
    fn override_aiming_range_crouch_mut(&mut self) -> &mut f32 {
        &mut self.override_aiming_range_crouch
    }
    fn override_aiming_range_prone(&self) -> &f32 {
        &self.override_aiming_range_prone
    }
    fn override_aiming_range_prone_mut(&mut self) -> &mut f32 {
        &mut self.override_aiming_range_prone
    }
    fn snap_box_scale(&self) -> &super::core::Vec3 {
        &self.snap_box_scale
    }
    fn snap_box_scale_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.snap_box_scale
    }
    fn snap_distance_scale(&self) -> &super::core::Vec3 {
        &self.snap_distance_scale
    }
    fn snap_distance_scale_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.snap_distance_scale
    }
    fn eye_pos_offset(&self) -> &super::core::Vec3 {
        &self.eye_pos_offset
    }
    fn eye_pos_offset_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.eye_pos_offset
    }
}

impl super::core::GameDataContainerTrait for SoldierAimAssistData {
}

impl super::core::DataContainerTrait for SoldierAimAssistData {
}

pub static SOLDIERAIMASSISTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierAimAssistData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::GAMEDATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierAimAssistData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "InputPolynomial",
                flags: MemberInfoFlags::new(144),
                field_type: "Float32-Array",
                rust_offset: offset_of!(SoldierAimAssistData, input_polynomial),
            },
            FieldInfoData {
                name: "ZoomedInputPolynomial",
                flags: MemberInfoFlags::new(144),
                field_type: "Float32-Array",
                rust_offset: offset_of!(SoldierAimAssistData, zoomed_input_polynomial),
            },
            FieldInfoData {
                name: "UseYawAcceleration",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierAimAssistData, use_yaw_acceleration),
            },
            FieldInfoData {
                name: "UsePitchAcceleration",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierAimAssistData, use_pitch_acceleration),
            },
            FieldInfoData {
                name: "AccelerationInputThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierAimAssistData, acceleration_input_threshold),
            },
            FieldInfoData {
                name: "AccelerationMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierAimAssistData, acceleration_multiplier),
            },
            FieldInfoData {
                name: "AccelerationDamping",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierAimAssistData, acceleration_damping),
            },
            FieldInfoData {
                name: "AccelerationTimeThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierAimAssistData, acceleration_time_threshold),
            },
            FieldInfoData {
                name: "SquaredAcceleration",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierAimAssistData, squared_acceleration),
            },
            FieldInfoData {
                name: "MaxAcceleration",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(SoldierAimAssistData, max_acceleration),
            },
            FieldInfoData {
                name: "YawSpeedStrength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierAimAssistData, yaw_speed_strength),
            },
            FieldInfoData {
                name: "PitchSpeedStrength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierAimAssistData, pitch_speed_strength),
            },
            FieldInfoData {
                name: "AttractDistanceFallOffs",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(SoldierAimAssistData, attract_distance_fall_offs),
            },
            FieldInfoData {
                name: "AttractSoftZone",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierAimAssistData, attract_soft_zone),
            },
            FieldInfoData {
                name: "AttractUserInputMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierAimAssistData, attract_user_input_multiplier),
            },
            FieldInfoData {
                name: "AttractUserInputMultiplier_NoZoom",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierAimAssistData, attract_user_input_multiplier_no_zoom),
            },
            FieldInfoData {
                name: "AttractOwnSpeedInfluence",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierAimAssistData, attract_own_speed_influence),
            },
            FieldInfoData {
                name: "AttractTargetSpeedInfluence",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierAimAssistData, attract_target_speed_influence),
            },
            FieldInfoData {
                name: "AttractStartInputThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierAimAssistData, attract_start_input_threshold),
            },
            FieldInfoData {
                name: "AttractMoveInputCap",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierAimAssistData, attract_move_input_cap),
            },
            FieldInfoData {
                name: "AttractYawStrength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierAimAssistData, attract_yaw_strength),
            },
            FieldInfoData {
                name: "AttractPitchStrength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierAimAssistData, attract_pitch_strength),
            },
            FieldInfoData {
                name: "MaxToTargetAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierAimAssistData, max_to_target_angle),
            },
            FieldInfoData {
                name: "MaxToTargetXZAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierAimAssistData, max_to_target_x_z_angle),
            },
            FieldInfoData {
                name: "StickyBoxScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SoldierAimAssistData, sticky_box_scale),
            },
            FieldInfoData {
                name: "StickyDistanceScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SoldierAimAssistData, sticky_distance_scale),
            },
            FieldInfoData {
                name: "ViewObstructedKeepTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierAimAssistData, view_obstructed_keep_time),
            },
            FieldInfoData {
                name: "SnapZoomLateralSpeedLimit",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierAimAssistData, snap_zoom_lateral_speed_limit),
            },
            FieldInfoData {
                name: "SnapZoomTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierAimAssistData, snap_zoom_time),
            },
            FieldInfoData {
                name: "SnapZoomUserShorterWeaponTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierAimAssistData, snap_zoom_user_shorter_weapon_time),
            },
            FieldInfoData {
                name: "SnapZoomPostTimeNoInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierAimAssistData, snap_zoom_post_time_no_input),
            },
            FieldInfoData {
                name: "SnapZoomPostTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierAimAssistData, snap_zoom_post_time),
            },
            FieldInfoData {
                name: "SnapZoomPostTimeDynamicPoint",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierAimAssistData, snap_zoom_post_time_dynamic_point),
            },
            FieldInfoData {
                name: "SnapZoomReticlePointPriority",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(SoldierAimAssistData, snap_zoom_reticle_point_priority),
            },
            FieldInfoData {
                name: "SnapZoomBreakTimeAtMaxInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierAimAssistData, snap_zoom_break_time_at_max_input),
            },
            FieldInfoData {
                name: "SnapZoomBreakMaxInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierAimAssistData, snap_zoom_break_max_input),
            },
            FieldInfoData {
                name: "SnapZoomBreakMinAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierAimAssistData, snap_zoom_break_min_angle),
            },
            FieldInfoData {
                name: "SnapZoomSpamGuardTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierAimAssistData, snap_zoom_spam_guard_time),
            },
            FieldInfoData {
                name: "SoldierBackupSkeletonCollisionData",
                flags: MemberInfoFlags::new(0),
                field_type: "SkeletonCollisionData",
                rust_offset: offset_of!(SoldierAimAssistData, soldier_backup_skeleton_collision_data),
            },
            FieldInfoData {
                name: "ForceSoldierBackupSkeletonCollisionUse",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierAimAssistData, force_soldier_backup_skeleton_collision_use),
            },
            FieldInfoData {
                name: "CheckBoneCenterOnlyDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierAimAssistData, check_bone_center_only_distance),
            },
            FieldInfoData {
                name: "DisableForcedTargetRecalcDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierAimAssistData, disable_forced_target_recalc_distance),
            },
            FieldInfoData {
                name: "OverrideAimingRange",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierAimAssistData, override_aiming_range),
            },
            FieldInfoData {
                name: "OverrideAimingRangeCrouch",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierAimAssistData, override_aiming_range_crouch),
            },
            FieldInfoData {
                name: "OverrideAimingRangeProne",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierAimAssistData, override_aiming_range_prone),
            },
            FieldInfoData {
                name: "SnapBoxScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SoldierAimAssistData, snap_box_scale),
            },
            FieldInfoData {
                name: "SnapDistanceScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SoldierAimAssistData, snap_distance_scale),
            },
            FieldInfoData {
                name: "EyePosOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SoldierAimAssistData, eye_pos_offset),
            },
        ],
    }),
    array_type: Some(SOLDIERAIMASSISTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SoldierAimAssistData {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERAIMASSISTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOLDIERAIMASSISTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierAimAssistData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SoldierAimAssistData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ThrowAtTargetWeaponData {
    pub _glacier_base: super::weapon_shared::WeaponData,
    pub default_power_modifier: f32,
    pub throw_to_soldier_distance: f32,
    pub max_travel_time: f32,
    pub min_travel_time: f32,
    pub clamp_maximum_velocity: bool,
    pub max_query_angle: f32,
    pub max_aim_adjustment_angle: f32,
    pub weight_current_distance: f32,
    pub weight_target_distance: f32,
    pub weight_current_angle: f32,
    pub weight_target_angle: f32,
}

pub trait ThrowAtTargetWeaponDataTrait: super::weapon_shared::WeaponDataTrait {
    fn default_power_modifier(&self) -> &f32;
    fn default_power_modifier_mut(&mut self) -> &mut f32;
    fn throw_to_soldier_distance(&self) -> &f32;
    fn throw_to_soldier_distance_mut(&mut self) -> &mut f32;
    fn max_travel_time(&self) -> &f32;
    fn max_travel_time_mut(&mut self) -> &mut f32;
    fn min_travel_time(&self) -> &f32;
    fn min_travel_time_mut(&mut self) -> &mut f32;
    fn clamp_maximum_velocity(&self) -> &bool;
    fn clamp_maximum_velocity_mut(&mut self) -> &mut bool;
    fn max_query_angle(&self) -> &f32;
    fn max_query_angle_mut(&mut self) -> &mut f32;
    fn max_aim_adjustment_angle(&self) -> &f32;
    fn max_aim_adjustment_angle_mut(&mut self) -> &mut f32;
    fn weight_current_distance(&self) -> &f32;
    fn weight_current_distance_mut(&mut self) -> &mut f32;
    fn weight_target_distance(&self) -> &f32;
    fn weight_target_distance_mut(&mut self) -> &mut f32;
    fn weight_current_angle(&self) -> &f32;
    fn weight_current_angle_mut(&mut self) -> &mut f32;
    fn weight_target_angle(&self) -> &f32;
    fn weight_target_angle_mut(&mut self) -> &mut f32;
}

impl ThrowAtTargetWeaponDataTrait for ThrowAtTargetWeaponData {
    fn default_power_modifier(&self) -> &f32 {
        &self.default_power_modifier
    }
    fn default_power_modifier_mut(&mut self) -> &mut f32 {
        &mut self.default_power_modifier
    }
    fn throw_to_soldier_distance(&self) -> &f32 {
        &self.throw_to_soldier_distance
    }
    fn throw_to_soldier_distance_mut(&mut self) -> &mut f32 {
        &mut self.throw_to_soldier_distance
    }
    fn max_travel_time(&self) -> &f32 {
        &self.max_travel_time
    }
    fn max_travel_time_mut(&mut self) -> &mut f32 {
        &mut self.max_travel_time
    }
    fn min_travel_time(&self) -> &f32 {
        &self.min_travel_time
    }
    fn min_travel_time_mut(&mut self) -> &mut f32 {
        &mut self.min_travel_time
    }
    fn clamp_maximum_velocity(&self) -> &bool {
        &self.clamp_maximum_velocity
    }
    fn clamp_maximum_velocity_mut(&mut self) -> &mut bool {
        &mut self.clamp_maximum_velocity
    }
    fn max_query_angle(&self) -> &f32 {
        &self.max_query_angle
    }
    fn max_query_angle_mut(&mut self) -> &mut f32 {
        &mut self.max_query_angle
    }
    fn max_aim_adjustment_angle(&self) -> &f32 {
        &self.max_aim_adjustment_angle
    }
    fn max_aim_adjustment_angle_mut(&mut self) -> &mut f32 {
        &mut self.max_aim_adjustment_angle
    }
    fn weight_current_distance(&self) -> &f32 {
        &self.weight_current_distance
    }
    fn weight_current_distance_mut(&mut self) -> &mut f32 {
        &mut self.weight_current_distance
    }
    fn weight_target_distance(&self) -> &f32 {
        &self.weight_target_distance
    }
    fn weight_target_distance_mut(&mut self) -> &mut f32 {
        &mut self.weight_target_distance
    }
    fn weight_current_angle(&self) -> &f32 {
        &self.weight_current_angle
    }
    fn weight_current_angle_mut(&mut self) -> &mut f32 {
        &mut self.weight_current_angle
    }
    fn weight_target_angle(&self) -> &f32 {
        &self.weight_target_angle
    }
    fn weight_target_angle_mut(&mut self) -> &mut f32 {
        &mut self.weight_target_angle
    }
}

impl super::weapon_shared::WeaponDataTrait for ThrowAtTargetWeaponData {
    fn show_laser_painted_vehicles(&self) -> &bool {
        self._glacier_base.show_laser_painted_vehicles()
    }
    fn show_laser_painted_vehicles_mut(&mut self) -> &mut bool {
        self._glacier_base.show_laser_painted_vehicles_mut()
    }
    fn apply_power_to_speed(&self) -> &bool {
        self._glacier_base.apply_power_to_speed()
    }
    fn apply_power_to_speed_mut(&mut self) -> &mut bool {
        self._glacier_base.apply_power_to_speed_mut()
    }
}

impl super::gameplay_sim::ToolDataTrait for ThrowAtTargetWeaponData {
    fn is_always_active(&self) -> &bool {
        self._glacier_base.is_always_active()
    }
    fn is_always_active_mut(&mut self) -> &mut bool {
        self._glacier_base.is_always_active_mut()
    }
}

impl super::core::DataContainerTrait for ThrowAtTargetWeaponData {
}

pub static THROWATTARGETWEAPONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ThrowAtTargetWeaponData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::weapon_shared::WEAPONDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ThrowAtTargetWeaponData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DefaultPowerModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ThrowAtTargetWeaponData, default_power_modifier),
            },
            FieldInfoData {
                name: "ThrowToSoldierDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ThrowAtTargetWeaponData, throw_to_soldier_distance),
            },
            FieldInfoData {
                name: "MaxTravelTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ThrowAtTargetWeaponData, max_travel_time),
            },
            FieldInfoData {
                name: "MinTravelTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ThrowAtTargetWeaponData, min_travel_time),
            },
            FieldInfoData {
                name: "ClampMaximumVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ThrowAtTargetWeaponData, clamp_maximum_velocity),
            },
            FieldInfoData {
                name: "MaxQueryAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ThrowAtTargetWeaponData, max_query_angle),
            },
            FieldInfoData {
                name: "MaxAimAdjustmentAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ThrowAtTargetWeaponData, max_aim_adjustment_angle),
            },
            FieldInfoData {
                name: "WeightCurrentDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ThrowAtTargetWeaponData, weight_current_distance),
            },
            FieldInfoData {
                name: "WeightTargetDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ThrowAtTargetWeaponData, weight_target_distance),
            },
            FieldInfoData {
                name: "WeightCurrentAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ThrowAtTargetWeaponData, weight_current_angle),
            },
            FieldInfoData {
                name: "WeightTargetAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ThrowAtTargetWeaponData, weight_target_angle),
            },
        ],
    }),
    array_type: Some(THROWATTARGETWEAPONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ThrowAtTargetWeaponData {
    fn type_info(&self) -> &'static TypeInfo {
        THROWATTARGETWEAPONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static THROWATTARGETWEAPONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ThrowAtTargetWeaponData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("ThrowAtTargetWeaponData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MeleeWeaponData {
    pub _glacier_base: super::weapon_shared::WeaponData,
    pub use_canned_animation: bool,
    pub use_sphere_damage: bool,
}

pub trait MeleeWeaponDataTrait: super::weapon_shared::WeaponDataTrait {
    fn use_canned_animation(&self) -> &bool;
    fn use_canned_animation_mut(&mut self) -> &mut bool;
    fn use_sphere_damage(&self) -> &bool;
    fn use_sphere_damage_mut(&mut self) -> &mut bool;
}

impl MeleeWeaponDataTrait for MeleeWeaponData {
    fn use_canned_animation(&self) -> &bool {
        &self.use_canned_animation
    }
    fn use_canned_animation_mut(&mut self) -> &mut bool {
        &mut self.use_canned_animation
    }
    fn use_sphere_damage(&self) -> &bool {
        &self.use_sphere_damage
    }
    fn use_sphere_damage_mut(&mut self) -> &mut bool {
        &mut self.use_sphere_damage
    }
}

impl super::weapon_shared::WeaponDataTrait for MeleeWeaponData {
    fn show_laser_painted_vehicles(&self) -> &bool {
        self._glacier_base.show_laser_painted_vehicles()
    }
    fn show_laser_painted_vehicles_mut(&mut self) -> &mut bool {
        self._glacier_base.show_laser_painted_vehicles_mut()
    }
    fn apply_power_to_speed(&self) -> &bool {
        self._glacier_base.apply_power_to_speed()
    }
    fn apply_power_to_speed_mut(&mut self) -> &mut bool {
        self._glacier_base.apply_power_to_speed_mut()
    }
}

impl super::gameplay_sim::ToolDataTrait for MeleeWeaponData {
    fn is_always_active(&self) -> &bool {
        self._glacier_base.is_always_active()
    }
    fn is_always_active_mut(&mut self) -> &mut bool {
        self._glacier_base.is_always_active_mut()
    }
}

impl super::core::DataContainerTrait for MeleeWeaponData {
}

pub static MELEEWEAPONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MeleeWeaponData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::weapon_shared::WEAPONDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MeleeWeaponData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "UseCannedAnimation",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MeleeWeaponData, use_canned_animation),
            },
            FieldInfoData {
                name: "UseSphereDamage",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MeleeWeaponData, use_sphere_damage),
            },
        ],
    }),
    array_type: Some(MELEEWEAPONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MeleeWeaponData {
    fn type_info(&self) -> &'static TypeInfo {
        MELEEWEAPONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MELEEWEAPONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MeleeWeaponData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("MeleeWeaponData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FlashlightWeaponData {
    pub _glacier_base: super::weapon_shared::WeaponData,
    pub update_frequency: f32,
    pub range: f32,
    pub angle: f32,
}

pub trait FlashlightWeaponDataTrait: super::weapon_shared::WeaponDataTrait {
    fn update_frequency(&self) -> &f32;
    fn update_frequency_mut(&mut self) -> &mut f32;
    fn range(&self) -> &f32;
    fn range_mut(&mut self) -> &mut f32;
    fn angle(&self) -> &f32;
    fn angle_mut(&mut self) -> &mut f32;
}

impl FlashlightWeaponDataTrait for FlashlightWeaponData {
    fn update_frequency(&self) -> &f32 {
        &self.update_frequency
    }
    fn update_frequency_mut(&mut self) -> &mut f32 {
        &mut self.update_frequency
    }
    fn range(&self) -> &f32 {
        &self.range
    }
    fn range_mut(&mut self) -> &mut f32 {
        &mut self.range
    }
    fn angle(&self) -> &f32 {
        &self.angle
    }
    fn angle_mut(&mut self) -> &mut f32 {
        &mut self.angle
    }
}

impl super::weapon_shared::WeaponDataTrait for FlashlightWeaponData {
    fn show_laser_painted_vehicles(&self) -> &bool {
        self._glacier_base.show_laser_painted_vehicles()
    }
    fn show_laser_painted_vehicles_mut(&mut self) -> &mut bool {
        self._glacier_base.show_laser_painted_vehicles_mut()
    }
    fn apply_power_to_speed(&self) -> &bool {
        self._glacier_base.apply_power_to_speed()
    }
    fn apply_power_to_speed_mut(&mut self) -> &mut bool {
        self._glacier_base.apply_power_to_speed_mut()
    }
}

impl super::gameplay_sim::ToolDataTrait for FlashlightWeaponData {
    fn is_always_active(&self) -> &bool {
        self._glacier_base.is_always_active()
    }
    fn is_always_active_mut(&mut self) -> &mut bool {
        self._glacier_base.is_always_active_mut()
    }
}

impl super::core::DataContainerTrait for FlashlightWeaponData {
}

pub static FLASHLIGHTWEAPONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FlashlightWeaponData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::weapon_shared::WEAPONDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FlashlightWeaponData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "UpdateFrequency",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FlashlightWeaponData, update_frequency),
            },
            FieldInfoData {
                name: "Range",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FlashlightWeaponData, range),
            },
            FieldInfoData {
                name: "Angle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FlashlightWeaponData, angle),
            },
        ],
    }),
    array_type: Some(FLASHLIGHTWEAPONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FlashlightWeaponData {
    fn type_info(&self) -> &'static TypeInfo {
        FLASHLIGHTWEAPONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FLASHLIGHTWEAPONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FlashlightWeaponData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("FlashlightWeaponData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct NetworkDefibrillatorReviveMessage {
}

pub trait NetworkDefibrillatorReviveMessageTrait: TypeObject {
}

impl NetworkDefibrillatorReviveMessageTrait for NetworkDefibrillatorReviveMessage {
}

pub static NETWORKDEFIBRILLATORREVIVEMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NetworkDefibrillatorReviveMessage",
    flags: MemberInfoFlags::new(73),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<NetworkDefibrillatorReviveMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 16,
};

impl TypeObject for NetworkDefibrillatorReviveMessage {
    fn type_info(&self) -> &'static TypeInfo {
        NETWORKDEFIBRILLATORREVIVEMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Clone, Debug, Default)]
pub struct DefibrillatorWeaponData {
    pub _glacier_base: super::weapon_shared::WeaponData,
    pub attack_time: f32,
    pub full_health_time: f32,
    pub initial_start_health: f32,
    pub max_angle_to_victim_x_z: f32,
    pub defib_action_cooldown_time: f32,
    pub client_side_revive: bool,
    pub max_client_body_distance: f32,
    pub upgrade_weapon_data: DefibrillatorUpgradeWeaponData,
}

pub trait DefibrillatorWeaponDataTrait: super::weapon_shared::WeaponDataTrait {
    fn attack_time(&self) -> &f32;
    fn attack_time_mut(&mut self) -> &mut f32;
    fn full_health_time(&self) -> &f32;
    fn full_health_time_mut(&mut self) -> &mut f32;
    fn initial_start_health(&self) -> &f32;
    fn initial_start_health_mut(&mut self) -> &mut f32;
    fn max_angle_to_victim_x_z(&self) -> &f32;
    fn max_angle_to_victim_x_z_mut(&mut self) -> &mut f32;
    fn defib_action_cooldown_time(&self) -> &f32;
    fn defib_action_cooldown_time_mut(&mut self) -> &mut f32;
    fn client_side_revive(&self) -> &bool;
    fn client_side_revive_mut(&mut self) -> &mut bool;
    fn max_client_body_distance(&self) -> &f32;
    fn max_client_body_distance_mut(&mut self) -> &mut f32;
    fn upgrade_weapon_data(&self) -> &DefibrillatorUpgradeWeaponData;
    fn upgrade_weapon_data_mut(&mut self) -> &mut DefibrillatorUpgradeWeaponData;
}

impl DefibrillatorWeaponDataTrait for DefibrillatorWeaponData {
    fn attack_time(&self) -> &f32 {
        &self.attack_time
    }
    fn attack_time_mut(&mut self) -> &mut f32 {
        &mut self.attack_time
    }
    fn full_health_time(&self) -> &f32 {
        &self.full_health_time
    }
    fn full_health_time_mut(&mut self) -> &mut f32 {
        &mut self.full_health_time
    }
    fn initial_start_health(&self) -> &f32 {
        &self.initial_start_health
    }
    fn initial_start_health_mut(&mut self) -> &mut f32 {
        &mut self.initial_start_health
    }
    fn max_angle_to_victim_x_z(&self) -> &f32 {
        &self.max_angle_to_victim_x_z
    }
    fn max_angle_to_victim_x_z_mut(&mut self) -> &mut f32 {
        &mut self.max_angle_to_victim_x_z
    }
    fn defib_action_cooldown_time(&self) -> &f32 {
        &self.defib_action_cooldown_time
    }
    fn defib_action_cooldown_time_mut(&mut self) -> &mut f32 {
        &mut self.defib_action_cooldown_time
    }
    fn client_side_revive(&self) -> &bool {
        &self.client_side_revive
    }
    fn client_side_revive_mut(&mut self) -> &mut bool {
        &mut self.client_side_revive
    }
    fn max_client_body_distance(&self) -> &f32 {
        &self.max_client_body_distance
    }
    fn max_client_body_distance_mut(&mut self) -> &mut f32 {
        &mut self.max_client_body_distance
    }
    fn upgrade_weapon_data(&self) -> &DefibrillatorUpgradeWeaponData {
        &self.upgrade_weapon_data
    }
    fn upgrade_weapon_data_mut(&mut self) -> &mut DefibrillatorUpgradeWeaponData {
        &mut self.upgrade_weapon_data
    }
}

impl super::weapon_shared::WeaponDataTrait for DefibrillatorWeaponData {
    fn show_laser_painted_vehicles(&self) -> &bool {
        self._glacier_base.show_laser_painted_vehicles()
    }
    fn show_laser_painted_vehicles_mut(&mut self) -> &mut bool {
        self._glacier_base.show_laser_painted_vehicles_mut()
    }
    fn apply_power_to_speed(&self) -> &bool {
        self._glacier_base.apply_power_to_speed()
    }
    fn apply_power_to_speed_mut(&mut self) -> &mut bool {
        self._glacier_base.apply_power_to_speed_mut()
    }
}

impl super::gameplay_sim::ToolDataTrait for DefibrillatorWeaponData {
    fn is_always_active(&self) -> &bool {
        self._glacier_base.is_always_active()
    }
    fn is_always_active_mut(&mut self) -> &mut bool {
        self._glacier_base.is_always_active_mut()
    }
}

impl super::core::DataContainerTrait for DefibrillatorWeaponData {
}

pub static DEFIBRILLATORWEAPONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DefibrillatorWeaponData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::weapon_shared::WEAPONDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DefibrillatorWeaponData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AttackTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DefibrillatorWeaponData, attack_time),
            },
            FieldInfoData {
                name: "FullHealthTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DefibrillatorWeaponData, full_health_time),
            },
            FieldInfoData {
                name: "InitialStartHealth",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DefibrillatorWeaponData, initial_start_health),
            },
            FieldInfoData {
                name: "MaxAngleToVictimXZ",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DefibrillatorWeaponData, max_angle_to_victim_x_z),
            },
            FieldInfoData {
                name: "DefibActionCooldownTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DefibrillatorWeaponData, defib_action_cooldown_time),
            },
            FieldInfoData {
                name: "ClientSideRevive",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DefibrillatorWeaponData, client_side_revive),
            },
            FieldInfoData {
                name: "MaxClientBodyDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DefibrillatorWeaponData, max_client_body_distance),
            },
            FieldInfoData {
                name: "UpgradeWeaponData",
                flags: MemberInfoFlags::new(0),
                field_type: "DefibrillatorUpgradeWeaponData",
                rust_offset: offset_of!(DefibrillatorWeaponData, upgrade_weapon_data),
            },
        ],
    }),
    array_type: Some(DEFIBRILLATORWEAPONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DefibrillatorWeaponData {
    fn type_info(&self) -> &'static TypeInfo {
        DEFIBRILLATORWEAPONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DEFIBRILLATORWEAPONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DefibrillatorWeaponData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("DefibrillatorWeaponData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DefibrillatorUpgradeWeaponData {
    pub upgrade_unlock: Option<Arc<Mutex<dyn super::game_shared::ValueUnlockAssetTrait>>>,
    pub attack_time: f32,
    pub full_health_time: f32,
    pub initial_start_health: f32,
    pub defib_action_cooldown_time: f32,
}

pub trait DefibrillatorUpgradeWeaponDataTrait: TypeObject {
    fn upgrade_unlock(&self) -> &Option<Arc<Mutex<dyn super::game_shared::ValueUnlockAssetTrait>>>;
    fn upgrade_unlock_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::game_shared::ValueUnlockAssetTrait>>>;
    fn attack_time(&self) -> &f32;
    fn attack_time_mut(&mut self) -> &mut f32;
    fn full_health_time(&self) -> &f32;
    fn full_health_time_mut(&mut self) -> &mut f32;
    fn initial_start_health(&self) -> &f32;
    fn initial_start_health_mut(&mut self) -> &mut f32;
    fn defib_action_cooldown_time(&self) -> &f32;
    fn defib_action_cooldown_time_mut(&mut self) -> &mut f32;
}

impl DefibrillatorUpgradeWeaponDataTrait for DefibrillatorUpgradeWeaponData {
    fn upgrade_unlock(&self) -> &Option<Arc<Mutex<dyn super::game_shared::ValueUnlockAssetTrait>>> {
        &self.upgrade_unlock
    }
    fn upgrade_unlock_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::game_shared::ValueUnlockAssetTrait>>> {
        &mut self.upgrade_unlock
    }
    fn attack_time(&self) -> &f32 {
        &self.attack_time
    }
    fn attack_time_mut(&mut self) -> &mut f32 {
        &mut self.attack_time
    }
    fn full_health_time(&self) -> &f32 {
        &self.full_health_time
    }
    fn full_health_time_mut(&mut self) -> &mut f32 {
        &mut self.full_health_time
    }
    fn initial_start_health(&self) -> &f32 {
        &self.initial_start_health
    }
    fn initial_start_health_mut(&mut self) -> &mut f32 {
        &mut self.initial_start_health
    }
    fn defib_action_cooldown_time(&self) -> &f32 {
        &self.defib_action_cooldown_time
    }
    fn defib_action_cooldown_time_mut(&mut self) -> &mut f32 {
        &mut self.defib_action_cooldown_time
    }
}

pub static DEFIBRILLATORUPGRADEWEAPONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DefibrillatorUpgradeWeaponData",
    flags: MemberInfoFlags::new(73),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DefibrillatorUpgradeWeaponData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "UpgradeUnlock",
                flags: MemberInfoFlags::new(0),
                field_type: "ValueUnlockAsset",
                rust_offset: offset_of!(DefibrillatorUpgradeWeaponData, upgrade_unlock),
            },
            FieldInfoData {
                name: "AttackTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DefibrillatorUpgradeWeaponData, attack_time),
            },
            FieldInfoData {
                name: "FullHealthTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DefibrillatorUpgradeWeaponData, full_health_time),
            },
            FieldInfoData {
                name: "InitialStartHealth",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DefibrillatorUpgradeWeaponData, initial_start_health),
            },
            FieldInfoData {
                name: "DefibActionCooldownTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DefibrillatorUpgradeWeaponData, defib_action_cooldown_time),
            },
        ],
    }),
    array_type: Some(DEFIBRILLATORUPGRADEWEAPONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DefibrillatorUpgradeWeaponData {
    fn type_info(&self) -> &'static TypeInfo {
        DEFIBRILLATORUPGRADEWEAPONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static DEFIBRILLATORUPGRADEWEAPONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DefibrillatorUpgradeWeaponData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("DefibrillatorUpgradeWeaponData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RepairToolWeaponData {
    pub _glacier_base: PowerToolWeaponData,
    pub recharge_speed: f32,
}

pub trait RepairToolWeaponDataTrait: PowerToolWeaponDataTrait {
    fn recharge_speed(&self) -> &f32;
    fn recharge_speed_mut(&mut self) -> &mut f32;
}

impl RepairToolWeaponDataTrait for RepairToolWeaponData {
    fn recharge_speed(&self) -> &f32 {
        &self.recharge_speed
    }
    fn recharge_speed_mut(&mut self) -> &mut f32 {
        &mut self.recharge_speed
    }
}

impl PowerToolWeaponDataTrait for RepairToolWeaponData {
    fn repair_sound(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        self._glacier_base.repair_sound()
    }
    fn repair_sound_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        self._glacier_base.repair_sound_mut()
    }
    fn repair_completed_sound(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        self._glacier_base.repair_completed_sound()
    }
    fn repair_completed_sound_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        self._glacier_base.repair_completed_sound_mut()
    }
    fn damage_sound(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        self._glacier_base.damage_sound()
    }
    fn damage_sound_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        self._glacier_base.damage_sound_mut()
    }
    fn repair_material_pair(&self) -> &super::entity::MaterialDecl {
        self._glacier_base.repair_material_pair()
    }
    fn repair_material_pair_mut(&mut self) -> &mut super::entity::MaterialDecl {
        self._glacier_base.repair_material_pair_mut()
    }
    fn play_fire_effect_on_repair_only(&self) -> &bool {
        self._glacier_base.play_fire_effect_on_repair_only()
    }
    fn play_fire_effect_on_repair_only_mut(&mut self) -> &mut bool {
        self._glacier_base.play_fire_effect_on_repair_only_mut()
    }
}

impl super::weapon_shared::WeaponDataTrait for RepairToolWeaponData {
    fn show_laser_painted_vehicles(&self) -> &bool {
        self._glacier_base.show_laser_painted_vehicles()
    }
    fn show_laser_painted_vehicles_mut(&mut self) -> &mut bool {
        self._glacier_base.show_laser_painted_vehicles_mut()
    }
    fn apply_power_to_speed(&self) -> &bool {
        self._glacier_base.apply_power_to_speed()
    }
    fn apply_power_to_speed_mut(&mut self) -> &mut bool {
        self._glacier_base.apply_power_to_speed_mut()
    }
}

impl super::gameplay_sim::ToolDataTrait for RepairToolWeaponData {
    fn is_always_active(&self) -> &bool {
        self._glacier_base.is_always_active()
    }
    fn is_always_active_mut(&mut self) -> &mut bool {
        self._glacier_base.is_always_active_mut()
    }
}

impl super::core::DataContainerTrait for RepairToolWeaponData {
}

pub static REPAIRTOOLWEAPONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RepairToolWeaponData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(POWERTOOLWEAPONDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RepairToolWeaponData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "RechargeSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RepairToolWeaponData, recharge_speed),
            },
        ],
    }),
    array_type: Some(REPAIRTOOLWEAPONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RepairToolWeaponData {
    fn type_info(&self) -> &'static TypeInfo {
        REPAIRTOOLWEAPONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static REPAIRTOOLWEAPONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RepairToolWeaponData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("RepairToolWeaponData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PowerToolWeaponData {
    pub _glacier_base: super::weapon_shared::WeaponData,
    pub repair_sound: Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>,
    pub repair_completed_sound: Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>,
    pub damage_sound: Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>,
    pub repair_material_pair: super::entity::MaterialDecl,
    pub play_fire_effect_on_repair_only: bool,
}

pub trait PowerToolWeaponDataTrait: super::weapon_shared::WeaponDataTrait {
    fn repair_sound(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn repair_sound_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn repair_completed_sound(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn repair_completed_sound_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn damage_sound(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn damage_sound_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn repair_material_pair(&self) -> &super::entity::MaterialDecl;
    fn repair_material_pair_mut(&mut self) -> &mut super::entity::MaterialDecl;
    fn play_fire_effect_on_repair_only(&self) -> &bool;
    fn play_fire_effect_on_repair_only_mut(&mut self) -> &mut bool;
}

impl PowerToolWeaponDataTrait for PowerToolWeaponData {
    fn repair_sound(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &self.repair_sound
    }
    fn repair_sound_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &mut self.repair_sound
    }
    fn repair_completed_sound(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &self.repair_completed_sound
    }
    fn repair_completed_sound_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &mut self.repair_completed_sound
    }
    fn damage_sound(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &self.damage_sound
    }
    fn damage_sound_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &mut self.damage_sound
    }
    fn repair_material_pair(&self) -> &super::entity::MaterialDecl {
        &self.repair_material_pair
    }
    fn repair_material_pair_mut(&mut self) -> &mut super::entity::MaterialDecl {
        &mut self.repair_material_pair
    }
    fn play_fire_effect_on_repair_only(&self) -> &bool {
        &self.play_fire_effect_on_repair_only
    }
    fn play_fire_effect_on_repair_only_mut(&mut self) -> &mut bool {
        &mut self.play_fire_effect_on_repair_only
    }
}

impl super::weapon_shared::WeaponDataTrait for PowerToolWeaponData {
    fn show_laser_painted_vehicles(&self) -> &bool {
        self._glacier_base.show_laser_painted_vehicles()
    }
    fn show_laser_painted_vehicles_mut(&mut self) -> &mut bool {
        self._glacier_base.show_laser_painted_vehicles_mut()
    }
    fn apply_power_to_speed(&self) -> &bool {
        self._glacier_base.apply_power_to_speed()
    }
    fn apply_power_to_speed_mut(&mut self) -> &mut bool {
        self._glacier_base.apply_power_to_speed_mut()
    }
}

impl super::gameplay_sim::ToolDataTrait for PowerToolWeaponData {
    fn is_always_active(&self) -> &bool {
        self._glacier_base.is_always_active()
    }
    fn is_always_active_mut(&mut self) -> &mut bool {
        self._glacier_base.is_always_active_mut()
    }
}

impl super::core::DataContainerTrait for PowerToolWeaponData {
}

pub static POWERTOOLWEAPONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PowerToolWeaponData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::weapon_shared::WEAPONDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PowerToolWeaponData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "RepairSound",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(PowerToolWeaponData, repair_sound),
            },
            FieldInfoData {
                name: "RepairCompletedSound",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(PowerToolWeaponData, repair_completed_sound),
            },
            FieldInfoData {
                name: "DamageSound",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(PowerToolWeaponData, damage_sound),
            },
            FieldInfoData {
                name: "RepairMaterialPair",
                flags: MemberInfoFlags::new(0),
                field_type: "MaterialDecl",
                rust_offset: offset_of!(PowerToolWeaponData, repair_material_pair),
            },
            FieldInfoData {
                name: "PlayFireEffectOnRepairOnly",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PowerToolWeaponData, play_fire_effect_on_repair_only),
            },
        ],
    }),
    array_type: Some(POWERTOOLWEAPONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PowerToolWeaponData {
    fn type_info(&self) -> &'static TypeInfo {
        POWERTOOLWEAPONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static POWERTOOLWEAPONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PowerToolWeaponData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("PowerToolWeaponData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MedicBagHealingSphereWeaponData {
    pub _glacier_base: super::weapon_shared::WeaponData,
    pub healer: super::weapon_shared::HealingSphereData,
    pub health_points_refill_speed: f32,
    pub health_points_per_bag: f32,
}

pub trait MedicBagHealingSphereWeaponDataTrait: super::weapon_shared::WeaponDataTrait {
    fn healer(&self) -> &super::weapon_shared::HealingSphereData;
    fn healer_mut(&mut self) -> &mut super::weapon_shared::HealingSphereData;
    fn health_points_refill_speed(&self) -> &f32;
    fn health_points_refill_speed_mut(&mut self) -> &mut f32;
    fn health_points_per_bag(&self) -> &f32;
    fn health_points_per_bag_mut(&mut self) -> &mut f32;
}

impl MedicBagHealingSphereWeaponDataTrait for MedicBagHealingSphereWeaponData {
    fn healer(&self) -> &super::weapon_shared::HealingSphereData {
        &self.healer
    }
    fn healer_mut(&mut self) -> &mut super::weapon_shared::HealingSphereData {
        &mut self.healer
    }
    fn health_points_refill_speed(&self) -> &f32 {
        &self.health_points_refill_speed
    }
    fn health_points_refill_speed_mut(&mut self) -> &mut f32 {
        &mut self.health_points_refill_speed
    }
    fn health_points_per_bag(&self) -> &f32 {
        &self.health_points_per_bag
    }
    fn health_points_per_bag_mut(&mut self) -> &mut f32 {
        &mut self.health_points_per_bag
    }
}

impl super::weapon_shared::WeaponDataTrait for MedicBagHealingSphereWeaponData {
    fn show_laser_painted_vehicles(&self) -> &bool {
        self._glacier_base.show_laser_painted_vehicles()
    }
    fn show_laser_painted_vehicles_mut(&mut self) -> &mut bool {
        self._glacier_base.show_laser_painted_vehicles_mut()
    }
    fn apply_power_to_speed(&self) -> &bool {
        self._glacier_base.apply_power_to_speed()
    }
    fn apply_power_to_speed_mut(&mut self) -> &mut bool {
        self._glacier_base.apply_power_to_speed_mut()
    }
}

impl super::gameplay_sim::ToolDataTrait for MedicBagHealingSphereWeaponData {
    fn is_always_active(&self) -> &bool {
        self._glacier_base.is_always_active()
    }
    fn is_always_active_mut(&mut self) -> &mut bool {
        self._glacier_base.is_always_active_mut()
    }
}

impl super::core::DataContainerTrait for MedicBagHealingSphereWeaponData {
}

pub static MEDICBAGHEALINGSPHEREWEAPONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MedicBagHealingSphereWeaponData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::weapon_shared::WEAPONDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MedicBagHealingSphereWeaponData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Healer",
                flags: MemberInfoFlags::new(0),
                field_type: "HealingSphereData",
                rust_offset: offset_of!(MedicBagHealingSphereWeaponData, healer),
            },
            FieldInfoData {
                name: "HealthPointsRefillSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MedicBagHealingSphereWeaponData, health_points_refill_speed),
            },
            FieldInfoData {
                name: "HealthPointsPerBag",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MedicBagHealingSphereWeaponData, health_points_per_bag),
            },
        ],
    }),
    array_type: Some(MEDICBAGHEALINGSPHEREWEAPONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MedicBagHealingSphereWeaponData {
    fn type_info(&self) -> &'static TypeInfo {
        MEDICBAGHEALINGSPHEREWEAPONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MEDICBAGHEALINGSPHEREWEAPONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MedicBagHealingSphereWeaponData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("MedicBagHealingSphereWeaponData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MedkitWeaponData {
    pub _glacier_base: super::weapon_shared::WeaponData,
}

pub trait MedkitWeaponDataTrait: super::weapon_shared::WeaponDataTrait {
}

impl MedkitWeaponDataTrait for MedkitWeaponData {
}

impl super::weapon_shared::WeaponDataTrait for MedkitWeaponData {
    fn show_laser_painted_vehicles(&self) -> &bool {
        self._glacier_base.show_laser_painted_vehicles()
    }
    fn show_laser_painted_vehicles_mut(&mut self) -> &mut bool {
        self._glacier_base.show_laser_painted_vehicles_mut()
    }
    fn apply_power_to_speed(&self) -> &bool {
        self._glacier_base.apply_power_to_speed()
    }
    fn apply_power_to_speed_mut(&mut self) -> &mut bool {
        self._glacier_base.apply_power_to_speed_mut()
    }
}

impl super::gameplay_sim::ToolDataTrait for MedkitWeaponData {
    fn is_always_active(&self) -> &bool {
        self._glacier_base.is_always_active()
    }
    fn is_always_active_mut(&mut self) -> &mut bool {
        self._glacier_base.is_always_active_mut()
    }
}

impl super::core::DataContainerTrait for MedkitWeaponData {
}

pub static MEDKITWEAPONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MedkitWeaponData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::weapon_shared::WEAPONDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MedkitWeaponData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(MEDKITWEAPONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MedkitWeaponData {
    fn type_info(&self) -> &'static TypeInfo {
        MEDKITWEAPONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MEDKITWEAPONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MedkitWeaponData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("MedkitWeaponData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DetonatedWeaponData {
    pub _glacier_base: super::weapon_shared::WeaponData,
    pub locking_controller: Option<Arc<Mutex<dyn super::weapon_shared::LockingControllerDataTrait>>>,
    pub range: f32,
}

pub trait DetonatedWeaponDataTrait: super::weapon_shared::WeaponDataTrait {
    fn locking_controller(&self) -> &Option<Arc<Mutex<dyn super::weapon_shared::LockingControllerDataTrait>>>;
    fn locking_controller_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::weapon_shared::LockingControllerDataTrait>>>;
    fn range(&self) -> &f32;
    fn range_mut(&mut self) -> &mut f32;
}

impl DetonatedWeaponDataTrait for DetonatedWeaponData {
    fn locking_controller(&self) -> &Option<Arc<Mutex<dyn super::weapon_shared::LockingControllerDataTrait>>> {
        &self.locking_controller
    }
    fn locking_controller_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::weapon_shared::LockingControllerDataTrait>>> {
        &mut self.locking_controller
    }
    fn range(&self) -> &f32 {
        &self.range
    }
    fn range_mut(&mut self) -> &mut f32 {
        &mut self.range
    }
}

impl super::weapon_shared::WeaponDataTrait for DetonatedWeaponData {
    fn show_laser_painted_vehicles(&self) -> &bool {
        self._glacier_base.show_laser_painted_vehicles()
    }
    fn show_laser_painted_vehicles_mut(&mut self) -> &mut bool {
        self._glacier_base.show_laser_painted_vehicles_mut()
    }
    fn apply_power_to_speed(&self) -> &bool {
        self._glacier_base.apply_power_to_speed()
    }
    fn apply_power_to_speed_mut(&mut self) -> &mut bool {
        self._glacier_base.apply_power_to_speed_mut()
    }
}

impl super::gameplay_sim::ToolDataTrait for DetonatedWeaponData {
    fn is_always_active(&self) -> &bool {
        self._glacier_base.is_always_active()
    }
    fn is_always_active_mut(&mut self) -> &mut bool {
        self._glacier_base.is_always_active_mut()
    }
}

impl super::core::DataContainerTrait for DetonatedWeaponData {
}

pub static DETONATEDWEAPONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DetonatedWeaponData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::weapon_shared::WEAPONDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DetonatedWeaponData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "LockingController",
                flags: MemberInfoFlags::new(0),
                field_type: "LockingControllerData",
                rust_offset: offset_of!(DetonatedWeaponData, locking_controller),
            },
            FieldInfoData {
                name: "Range",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DetonatedWeaponData, range),
            },
        ],
    }),
    array_type: Some(DETONATEDWEAPONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DetonatedWeaponData {
    fn type_info(&self) -> &'static TypeInfo {
        DETONATEDWEAPONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DETONATEDWEAPONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DetonatedWeaponData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("DetonatedWeaponData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MissileHealthComponentData {
    pub _glacier_base: super::gameplay_sim::GameHealthComponentData,
    pub health: f32,
}

pub trait MissileHealthComponentDataTrait: super::gameplay_sim::GameHealthComponentDataTrait {
    fn health(&self) -> &f32;
    fn health_mut(&mut self) -> &mut f32;
}

impl MissileHealthComponentDataTrait for MissileHealthComponentData {
    fn health(&self) -> &f32 {
        &self.health
    }
    fn health_mut(&mut self) -> &mut f32 {
        &mut self.health
    }
}

impl super::gameplay_sim::GameHealthComponentDataTrait for MissileHealthComponentData {
}

impl super::gameplay_sim::HealthComponentDataTrait for MissileHealthComponentData {
}

impl super::entity::ComponentDataTrait for MissileHealthComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for MissileHealthComponentData {
}

impl super::core::DataBusPeerTrait for MissileHealthComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for MissileHealthComponentData {
}

impl super::core::DataContainerTrait for MissileHealthComponentData {
}

pub static MISSILEHEALTHCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MissileHealthComponentData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::GAMEHEALTHCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MissileHealthComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Health",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MissileHealthComponentData, health),
            },
        ],
    }),
    array_type: Some(MISSILEHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for MissileHealthComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        MISSILEHEALTHCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MISSILEHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MissileHealthComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("MissileHealthComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ExplosionPackHealthComponentData {
    pub _glacier_base: super::gameplay_sim::GameHealthComponentData,
    pub on_damage_explosion_inherit_unlock: bool,
}

pub trait ExplosionPackHealthComponentDataTrait: super::gameplay_sim::GameHealthComponentDataTrait {
    fn on_damage_explosion_inherit_unlock(&self) -> &bool;
    fn on_damage_explosion_inherit_unlock_mut(&mut self) -> &mut bool;
}

impl ExplosionPackHealthComponentDataTrait for ExplosionPackHealthComponentData {
    fn on_damage_explosion_inherit_unlock(&self) -> &bool {
        &self.on_damage_explosion_inherit_unlock
    }
    fn on_damage_explosion_inherit_unlock_mut(&mut self) -> &mut bool {
        &mut self.on_damage_explosion_inherit_unlock
    }
}

impl super::gameplay_sim::GameHealthComponentDataTrait for ExplosionPackHealthComponentData {
}

impl super::gameplay_sim::HealthComponentDataTrait for ExplosionPackHealthComponentData {
}

impl super::entity::ComponentDataTrait for ExplosionPackHealthComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for ExplosionPackHealthComponentData {
}

impl super::core::DataBusPeerTrait for ExplosionPackHealthComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ExplosionPackHealthComponentData {
}

impl super::core::DataContainerTrait for ExplosionPackHealthComponentData {
}

pub static EXPLOSIONPACKHEALTHCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExplosionPackHealthComponentData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::GAMEHEALTHCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ExplosionPackHealthComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "OnDamageExplosionInheritUnlock",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ExplosionPackHealthComponentData, on_damage_explosion_inherit_unlock),
            },
        ],
    }),
    array_type: Some(EXPLOSIONPACKHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ExplosionPackHealthComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        EXPLOSIONPACKHEALTHCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EXPLOSIONPACKHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExplosionPackHealthComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("ExplosionPackHealthComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ExplosionPackPhysicsComponentData {
    pub _glacier_base: super::gameplay_sim::GamePhysicsComponentData,
}

pub trait ExplosionPackPhysicsComponentDataTrait: super::gameplay_sim::GamePhysicsComponentDataTrait {
}

impl ExplosionPackPhysicsComponentDataTrait for ExplosionPackPhysicsComponentData {
}

impl super::gameplay_sim::GamePhysicsComponentDataTrait for ExplosionPackPhysicsComponentData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn effect_parameters(&self) -> &Vec<Option<Arc<Mutex<dyn super::effect_base::EffectParameterTrait>>>> {
        self._glacier_base.effect_parameters()
    }
    fn effect_parameters_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::effect_base::EffectParameterTrait>>>> {
        self._glacier_base.effect_parameters_mut()
    }
}

impl super::physics::PhysicsComponentDataTrait for ExplosionPackPhysicsComponentData {
    fn physics_bodies(&self) -> &Vec<Option<Arc<Mutex<dyn super::physics::PhysicsBodyDataTrait>>>> {
        self._glacier_base.physics_bodies()
    }
    fn physics_bodies_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::physics::PhysicsBodyDataTrait>>>> {
        self._glacier_base.physics_bodies_mut()
    }
    fn physics_constraints(&self) -> &Vec<Option<Arc<Mutex<dyn super::physics::PhysicsConstraintDataTrait>>>> {
        self._glacier_base.physics_constraints()
    }
    fn physics_constraints_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::physics::PhysicsConstraintDataTrait>>>> {
        self._glacier_base.physics_constraints_mut()
    }
    fn parts(&self) -> &Vec<super::physics::PhysicsPartData> {
        self._glacier_base.parts()
    }
    fn parts_mut(&mut self) -> &mut Vec<super::physics::PhysicsPartData> {
        self._glacier_base.parts_mut()
    }
    fn movable_parts(&self) -> &bool {
        self._glacier_base.movable_parts()
    }
    fn movable_parts_mut(&mut self) -> &mut bool {
        self._glacier_base.movable_parts_mut()
    }
    fn internal_collision_disabling(&self) -> &super::physics::InternalCollisionDisablingBehavior {
        self._glacier_base.internal_collision_disabling()
    }
    fn internal_collision_disabling_mut(&mut self) -> &mut super::physics::InternalCollisionDisablingBehavior {
        self._glacier_base.internal_collision_disabling_mut()
    }
    fn enable_collision_events(&self) -> &bool {
        self._glacier_base.enable_collision_events()
    }
    fn enable_collision_events_mut(&mut self) -> &mut bool {
        self._glacier_base.enable_collision_events_mut()
    }
}

impl super::entity::ComponentDataTrait for ExplosionPackPhysicsComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for ExplosionPackPhysicsComponentData {
}

impl super::core::DataBusPeerTrait for ExplosionPackPhysicsComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ExplosionPackPhysicsComponentData {
}

impl super::core::DataContainerTrait for ExplosionPackPhysicsComponentData {
}

pub static EXPLOSIONPACKPHYSICSCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExplosionPackPhysicsComponentData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::GAMEPHYSICSCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ExplosionPackPhysicsComponentData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(EXPLOSIONPACKPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ExplosionPackPhysicsComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        EXPLOSIONPACKPHYSICSCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EXPLOSIONPACKPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExplosionPackPhysicsComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("ExplosionPackPhysicsComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ExplosionPackEntityData {
    pub _glacier_base: super::weapon_shared::GhostedProjectileEntityData,
    pub soldier_detonation_data: SoldierDetonationData,
    pub explosion_pack_triggers: Vec<Option<Arc<Mutex<dyn ExplosionPackTriggerTrait>>>>,
    pub explosion_offset_transform: super::core::LinearTransform,
    pub gravity_scale: f32,
    pub time_to_live_on_player_death: f32,
    pub is_destructible: bool,
    pub receives_explosion_damage: bool,
    pub health: f32,
    pub spotted_time: f32,
    pub defuse_radius: f32,
    pub icon_name: String,
    pub show_in_spectator_u_i: bool,
    pub world_icon_offset: super::core::Vec3,
    pub align_with_ground: bool,
    pub align_with_ground_ray_length: f32,
}

pub trait ExplosionPackEntityDataTrait: super::weapon_shared::GhostedProjectileEntityDataTrait {
    fn soldier_detonation_data(&self) -> &SoldierDetonationData;
    fn soldier_detonation_data_mut(&mut self) -> &mut SoldierDetonationData;
    fn explosion_pack_triggers(&self) -> &Vec<Option<Arc<Mutex<dyn ExplosionPackTriggerTrait>>>>;
    fn explosion_pack_triggers_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn ExplosionPackTriggerTrait>>>>;
    fn explosion_offset_transform(&self) -> &super::core::LinearTransform;
    fn explosion_offset_transform_mut(&mut self) -> &mut super::core::LinearTransform;
    fn gravity_scale(&self) -> &f32;
    fn gravity_scale_mut(&mut self) -> &mut f32;
    fn time_to_live_on_player_death(&self) -> &f32;
    fn time_to_live_on_player_death_mut(&mut self) -> &mut f32;
    fn is_destructible(&self) -> &bool;
    fn is_destructible_mut(&mut self) -> &mut bool;
    fn receives_explosion_damage(&self) -> &bool;
    fn receives_explosion_damage_mut(&mut self) -> &mut bool;
    fn health(&self) -> &f32;
    fn health_mut(&mut self) -> &mut f32;
    fn spotted_time(&self) -> &f32;
    fn spotted_time_mut(&mut self) -> &mut f32;
    fn defuse_radius(&self) -> &f32;
    fn defuse_radius_mut(&mut self) -> &mut f32;
    fn icon_name(&self) -> &String;
    fn icon_name_mut(&mut self) -> &mut String;
    fn show_in_spectator_u_i(&self) -> &bool;
    fn show_in_spectator_u_i_mut(&mut self) -> &mut bool;
    fn world_icon_offset(&self) -> &super::core::Vec3;
    fn world_icon_offset_mut(&mut self) -> &mut super::core::Vec3;
    fn align_with_ground(&self) -> &bool;
    fn align_with_ground_mut(&mut self) -> &mut bool;
    fn align_with_ground_ray_length(&self) -> &f32;
    fn align_with_ground_ray_length_mut(&mut self) -> &mut f32;
}

impl ExplosionPackEntityDataTrait for ExplosionPackEntityData {
    fn soldier_detonation_data(&self) -> &SoldierDetonationData {
        &self.soldier_detonation_data
    }
    fn soldier_detonation_data_mut(&mut self) -> &mut SoldierDetonationData {
        &mut self.soldier_detonation_data
    }
    fn explosion_pack_triggers(&self) -> &Vec<Option<Arc<Mutex<dyn ExplosionPackTriggerTrait>>>> {
        &self.explosion_pack_triggers
    }
    fn explosion_pack_triggers_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn ExplosionPackTriggerTrait>>>> {
        &mut self.explosion_pack_triggers
    }
    fn explosion_offset_transform(&self) -> &super::core::LinearTransform {
        &self.explosion_offset_transform
    }
    fn explosion_offset_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.explosion_offset_transform
    }
    fn gravity_scale(&self) -> &f32 {
        &self.gravity_scale
    }
    fn gravity_scale_mut(&mut self) -> &mut f32 {
        &mut self.gravity_scale
    }
    fn time_to_live_on_player_death(&self) -> &f32 {
        &self.time_to_live_on_player_death
    }
    fn time_to_live_on_player_death_mut(&mut self) -> &mut f32 {
        &mut self.time_to_live_on_player_death
    }
    fn is_destructible(&self) -> &bool {
        &self.is_destructible
    }
    fn is_destructible_mut(&mut self) -> &mut bool {
        &mut self.is_destructible
    }
    fn receives_explosion_damage(&self) -> &bool {
        &self.receives_explosion_damage
    }
    fn receives_explosion_damage_mut(&mut self) -> &mut bool {
        &mut self.receives_explosion_damage
    }
    fn health(&self) -> &f32 {
        &self.health
    }
    fn health_mut(&mut self) -> &mut f32 {
        &mut self.health
    }
    fn spotted_time(&self) -> &f32 {
        &self.spotted_time
    }
    fn spotted_time_mut(&mut self) -> &mut f32 {
        &mut self.spotted_time
    }
    fn defuse_radius(&self) -> &f32 {
        &self.defuse_radius
    }
    fn defuse_radius_mut(&mut self) -> &mut f32 {
        &mut self.defuse_radius
    }
    fn icon_name(&self) -> &String {
        &self.icon_name
    }
    fn icon_name_mut(&mut self) -> &mut String {
        &mut self.icon_name
    }
    fn show_in_spectator_u_i(&self) -> &bool {
        &self.show_in_spectator_u_i
    }
    fn show_in_spectator_u_i_mut(&mut self) -> &mut bool {
        &mut self.show_in_spectator_u_i
    }
    fn world_icon_offset(&self) -> &super::core::Vec3 {
        &self.world_icon_offset
    }
    fn world_icon_offset_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.world_icon_offset
    }
    fn align_with_ground(&self) -> &bool {
        &self.align_with_ground
    }
    fn align_with_ground_mut(&mut self) -> &mut bool {
        &mut self.align_with_ground
    }
    fn align_with_ground_ray_length(&self) -> &f32 {
        &self.align_with_ground_ray_length
    }
    fn align_with_ground_ray_length_mut(&mut self) -> &mut f32 {
        &mut self.align_with_ground_ray_length
    }
}

impl super::weapon_shared::GhostedProjectileEntityDataTrait for ExplosionPackEntityData {
    fn proxy_convergence_delay(&self) -> &f32 {
        self._glacier_base.proxy_convergence_delay()
    }
    fn proxy_convergence_delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.proxy_convergence_delay_mut()
    }
    fn proxy_convergence_duration(&self) -> &f32 {
        self._glacier_base.proxy_convergence_duration()
    }
    fn proxy_convergence_duration_mut(&mut self) -> &mut f32 {
        self._glacier_base.proxy_convergence_duration_mut()
    }
    fn proxy_convergence_instant_on_attach(&self) -> &bool {
        self._glacier_base.proxy_convergence_instant_on_attach()
    }
    fn proxy_convergence_instant_on_attach_mut(&mut self) -> &mut bool {
        self._glacier_base.proxy_convergence_instant_on_attach_mut()
    }
    fn force_proxy_convergence(&self) -> &bool {
        self._glacier_base.force_proxy_convergence()
    }
    fn force_proxy_convergence_mut(&mut self) -> &mut bool {
        self._glacier_base.force_proxy_convergence_mut()
    }
    fn convergence_using_initial_speed(&self) -> &bool {
        self._glacier_base.convergence_using_initial_speed()
    }
    fn convergence_using_initial_speed_mut(&mut self) -> &mut bool {
        self._glacier_base.convergence_using_initial_speed_mut()
    }
}

impl super::weapon_shared::MeshProjectileEntityDataTrait for ExplosionPackEntityData {
    fn mesh(&self) -> &Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        self._glacier_base.mesh()
    }
    fn mesh_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        self._glacier_base.mesh_mut()
    }
    fn trail_effect(&self) -> &Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>> {
        self._glacier_base.trail_effect()
    }
    fn trail_effect_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>> {
        self._glacier_base.trail_effect_mut()
    }
    fn is_attachable(&self) -> &bool {
        self._glacier_base.is_attachable()
    }
    fn is_attachable_mut(&mut self) -> &mut bool {
        self._glacier_base.is_attachable_mut()
    }
    fn instant_attachable_test_distance(&self) -> &f32 {
        self._glacier_base.instant_attachable_test_distance()
    }
    fn instant_attachable_test_distance_mut(&mut self) -> &mut f32 {
        self._glacier_base.instant_attachable_test_distance_mut()
    }
    fn instant_attachable_visual_convergence_delay(&self) -> &f32 {
        self._glacier_base.instant_attachable_visual_convergence_delay()
    }
    fn instant_attachable_visual_convergence_delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.instant_attachable_visual_convergence_delay_mut()
    }
    fn instant_attachable_visual_convergence_duration(&self) -> &f32 {
        self._glacier_base.instant_attachable_visual_convergence_duration()
    }
    fn instant_attachable_visual_convergence_duration_mut(&mut self) -> &mut f32 {
        self._glacier_base.instant_attachable_visual_convergence_duration_mut()
    }
    fn instant_attachable_test_under_reticule(&self) -> &bool {
        self._glacier_base.instant_attachable_test_under_reticule()
    }
    fn instant_attachable_test_under_reticule_mut(&mut self) -> &mut bool {
        self._glacier_base.instant_attachable_test_under_reticule_mut()
    }
    fn max_attachable_inclination(&self) -> &f32 {
        self._glacier_base.max_attachable_inclination()
    }
    fn max_attachable_inclination_mut(&mut self) -> &mut f32 {
        self._glacier_base.max_attachable_inclination_mut()
    }
    fn extra_damping(&self) -> &bool {
        self._glacier_base.extra_damping()
    }
    fn extra_damping_mut(&mut self) -> &mut bool {
        self._glacier_base.extra_damping_mut()
    }
    fn initial_angular_velocity(&self) -> &super::core::Vec3 {
        self._glacier_base.initial_angular_velocity()
    }
    fn initial_angular_velocity_mut(&mut self) -> &mut super::core::Vec3 {
        self._glacier_base.initial_angular_velocity_mut()
    }
    fn unspawn_after_detonation_delay(&self) -> &f32 {
        self._glacier_base.unspawn_after_detonation_delay()
    }
    fn unspawn_after_detonation_delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.unspawn_after_detonation_delay_mut()
    }
}

impl super::weapon_shared::ProjectileEntityDataTrait for ExplosionPackEntityData {
    fn initial_speed(&self) -> &f32 {
        self._glacier_base.initial_speed()
    }
    fn initial_speed_mut(&mut self) -> &mut f32 {
        self._glacier_base.initial_speed_mut()
    }
    fn time_to_live(&self) -> &f32 {
        self._glacier_base.time_to_live()
    }
    fn time_to_live_mut(&mut self) -> &mut f32 {
        self._glacier_base.time_to_live_mut()
    }
    fn max_count(&self) -> &u32 {
        self._glacier_base.max_count()
    }
    fn max_count_mut(&mut self) -> &mut u32 {
        self._glacier_base.max_count_mut()
    }
    fn init_mesh_hide_time(&self) -> &f32 {
        self._glacier_base.init_mesh_hide_time()
    }
    fn init_mesh_hide_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.init_mesh_hide_time_mut()
    }
    fn visual_converge_distance(&self) -> &f32 {
        self._glacier_base.visual_converge_distance()
    }
    fn visual_converge_distance_mut(&mut self) -> &mut f32 {
        self._glacier_base.visual_converge_distance_mut()
    }
    fn visual_convergence_delay(&self) -> &f32 {
        self._glacier_base.visual_convergence_delay()
    }
    fn visual_convergence_delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.visual_convergence_delay_mut()
    }
    fn visual_convergence_duration(&self) -> &f32 {
        self._glacier_base.visual_convergence_duration()
    }
    fn visual_convergence_duration_mut(&mut self) -> &mut f32 {
        self._glacier_base.visual_convergence_duration_mut()
    }
    fn proxy_visual_convergence_delay(&self) -> &f32 {
        self._glacier_base.proxy_visual_convergence_delay()
    }
    fn proxy_visual_convergence_delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.proxy_visual_convergence_delay_mut()
    }
    fn proxy_visual_convergence_duration(&self) -> &f32 {
        self._glacier_base.proxy_visual_convergence_duration()
    }
    fn proxy_visual_convergence_duration_mut(&mut self) -> &mut f32 {
        self._glacier_base.proxy_visual_convergence_duration_mut()
    }
    fn detonate_on_timeout(&self) -> &bool {
        self._glacier_base.detonate_on_timeout()
    }
    fn detonate_on_timeout_mut(&mut self) -> &mut bool {
        self._glacier_base.detonate_on_timeout_mut()
    }
    fn server_projectile_disabled(&self) -> &bool {
        self._glacier_base.server_projectile_disabled()
    }
    fn server_projectile_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.server_projectile_disabled_mut()
    }
    fn explosion(&self) -> &Option<Arc<Mutex<dyn super::game_shared::ExplosionEntityDataTrait>>> {
        self._glacier_base.explosion()
    }
    fn explosion_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::game_shared::ExplosionEntityDataTrait>>> {
        self._glacier_base.explosion_mut()
    }
    fn suppression_data(&self) -> &Option<Arc<Mutex<dyn super::weapon_shared::WeaponSuppressionDataTrait>>> {
        self._glacier_base.suppression_data()
    }
    fn suppression_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::weapon_shared::WeaponSuppressionDataTrait>>> {
        self._glacier_base.suppression_data_mut()
    }
    fn ammunition_type(&self) -> &String {
        self._glacier_base.ammunition_type()
    }
    fn ammunition_type_mut(&mut self) -> &mut String {
        self._glacier_base.ammunition_type_mut()
    }
    fn material_pair(&self) -> &super::entity::MaterialDecl {
        self._glacier_base.material_pair()
    }
    fn material_pair_mut(&mut self) -> &mut super::entity::MaterialDecl {
        self._glacier_base.material_pair_mut()
    }
    fn hit_reaction_weapon_type(&self) -> &super::weapon_shared::AntHitReactionWeaponType {
        self._glacier_base.hit_reaction_weapon_type()
    }
    fn hit_reaction_weapon_type_mut(&mut self) -> &mut super::weapon_shared::AntHitReactionWeaponType {
        self._glacier_base.hit_reaction_weapon_type_mut()
    }
    fn hide_on_detonation(&self) -> &bool {
        self._glacier_base.hide_on_detonation()
    }
    fn hide_on_detonation_mut(&mut self) -> &mut bool {
        self._glacier_base.hide_on_detonation_mut()
    }
    fn voice_over_info(&self) -> &Option<Arc<Mutex<dyn super::audio::EntityVoiceOverInfoTrait>>> {
        self._glacier_base.voice_over_info()
    }
    fn voice_over_info_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::EntityVoiceOverInfoTrait>>> {
        self._glacier_base.voice_over_info_mut()
    }
}

impl super::physics::GamePhysicsEntityDataTrait for ExplosionPackEntityData {
}

impl super::entity::GameComponentEntityDataTrait for ExplosionPackEntityData {
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::ComponentEntityDataTrait for ExplosionPackEntityData {
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn part_bounding_boxes(&self) -> &Vec<super::core::AxisAlignedBox> {
        self._glacier_base.part_bounding_boxes()
    }
    fn part_bounding_boxes_mut(&mut self) -> &mut Vec<super::core::AxisAlignedBox> {
        self._glacier_base.part_bounding_boxes_mut()
    }
    fn client_runtime_component_count(&self) -> &u8 {
        self._glacier_base.client_runtime_component_count()
    }
    fn client_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_component_count_mut()
    }
    fn server_runtime_component_count(&self) -> &u8 {
        self._glacier_base.server_runtime_component_count()
    }
    fn server_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_component_count_mut()
    }
    fn client_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.client_runtime_transformation_count()
    }
    fn client_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_transformation_count_mut()
    }
    fn server_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.server_runtime_transformation_count()
    }
    fn server_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_transformation_count_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for ExplosionPackEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for ExplosionPackEntityData {
}

impl super::entity::GameObjectDataTrait for ExplosionPackEntityData {
}

impl super::core::DataBusPeerTrait for ExplosionPackEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ExplosionPackEntityData {
}

impl super::core::DataContainerTrait for ExplosionPackEntityData {
}

pub static EXPLOSIONPACKENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExplosionPackEntityData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::weapon_shared::GHOSTEDPROJECTILEENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ExplosionPackEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SoldierDetonationData",
                flags: MemberInfoFlags::new(0),
                field_type: "SoldierDetonationData",
                rust_offset: offset_of!(ExplosionPackEntityData, soldier_detonation_data),
            },
            FieldInfoData {
                name: "ExplosionPackTriggers",
                flags: MemberInfoFlags::new(144),
                field_type: "ExplosionPackTrigger-Array",
                rust_offset: offset_of!(ExplosionPackEntityData, explosion_pack_triggers),
            },
            FieldInfoData {
                name: "ExplosionOffsetTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(ExplosionPackEntityData, explosion_offset_transform),
            },
            FieldInfoData {
                name: "GravityScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ExplosionPackEntityData, gravity_scale),
            },
            FieldInfoData {
                name: "TimeToLiveOnPlayerDeath",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ExplosionPackEntityData, time_to_live_on_player_death),
            },
            FieldInfoData {
                name: "IsDestructible",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ExplosionPackEntityData, is_destructible),
            },
            FieldInfoData {
                name: "ReceivesExplosionDamage",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ExplosionPackEntityData, receives_explosion_damage),
            },
            FieldInfoData {
                name: "Health",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ExplosionPackEntityData, health),
            },
            FieldInfoData {
                name: "SpottedTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ExplosionPackEntityData, spotted_time),
            },
            FieldInfoData {
                name: "DefuseRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ExplosionPackEntityData, defuse_radius),
            },
            FieldInfoData {
                name: "IconName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ExplosionPackEntityData, icon_name),
            },
            FieldInfoData {
                name: "ShowInSpectatorUI",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ExplosionPackEntityData, show_in_spectator_u_i),
            },
            FieldInfoData {
                name: "WorldIconOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(ExplosionPackEntityData, world_icon_offset),
            },
            FieldInfoData {
                name: "AlignWithGround",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ExplosionPackEntityData, align_with_ground),
            },
            FieldInfoData {
                name: "AlignWithGroundRayLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ExplosionPackEntityData, align_with_ground_ray_length),
            },
        ],
    }),
    array_type: Some(EXPLOSIONPACKENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ExplosionPackEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        EXPLOSIONPACKENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EXPLOSIONPACKENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExplosionPackEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("ExplosionPackEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ExplosionPackRemoteDetonatorTrigger {
    pub _glacier_base: ExplosionPackTrigger,
}

pub trait ExplosionPackRemoteDetonatorTriggerTrait: ExplosionPackTriggerTrait {
}

impl ExplosionPackRemoteDetonatorTriggerTrait for ExplosionPackRemoteDetonatorTrigger {
}

impl ExplosionPackTriggerTrait for ExplosionPackRemoteDetonatorTrigger {
}

impl super::core::DataContainerTrait for ExplosionPackRemoteDetonatorTrigger {
}

pub static EXPLOSIONPACKREMOTEDETONATORTRIGGER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExplosionPackRemoteDetonatorTrigger",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(EXPLOSIONPACKTRIGGER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ExplosionPackRemoteDetonatorTrigger as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(EXPLOSIONPACKREMOTEDETONATORTRIGGER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ExplosionPackRemoteDetonatorTrigger {
    fn type_info(&self) -> &'static TypeInfo {
        EXPLOSIONPACKREMOTEDETONATORTRIGGER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EXPLOSIONPACKREMOTEDETONATORTRIGGER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExplosionPackRemoteDetonatorTrigger-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("ExplosionPackRemoteDetonatorTrigger"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ExplosionPackInfantryTrigger {
    pub _glacier_base: ExplosionPackTrigger,
}

pub trait ExplosionPackInfantryTriggerTrait: ExplosionPackTriggerTrait {
}

impl ExplosionPackInfantryTriggerTrait for ExplosionPackInfantryTrigger {
}

impl ExplosionPackTriggerTrait for ExplosionPackInfantryTrigger {
}

impl super::core::DataContainerTrait for ExplosionPackInfantryTrigger {
}

pub static EXPLOSIONPACKINFANTRYTRIGGER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExplosionPackInfantryTrigger",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(EXPLOSIONPACKTRIGGER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ExplosionPackInfantryTrigger as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(EXPLOSIONPACKINFANTRYTRIGGER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ExplosionPackInfantryTrigger {
    fn type_info(&self) -> &'static TypeInfo {
        EXPLOSIONPACKINFANTRYTRIGGER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EXPLOSIONPACKINFANTRYTRIGGER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExplosionPackInfantryTrigger-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("ExplosionPackInfantryTrigger"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ExplosionPackVehicleRayTrigger {
    pub _glacier_base: ExplosionPackTrigger,
    pub activation_delay: f32,
    pub distance: f32,
}

pub trait ExplosionPackVehicleRayTriggerTrait: ExplosionPackTriggerTrait {
    fn activation_delay(&self) -> &f32;
    fn activation_delay_mut(&mut self) -> &mut f32;
    fn distance(&self) -> &f32;
    fn distance_mut(&mut self) -> &mut f32;
}

impl ExplosionPackVehicleRayTriggerTrait for ExplosionPackVehicleRayTrigger {
    fn activation_delay(&self) -> &f32 {
        &self.activation_delay
    }
    fn activation_delay_mut(&mut self) -> &mut f32 {
        &mut self.activation_delay
    }
    fn distance(&self) -> &f32 {
        &self.distance
    }
    fn distance_mut(&mut self) -> &mut f32 {
        &mut self.distance
    }
}

impl ExplosionPackTriggerTrait for ExplosionPackVehicleRayTrigger {
}

impl super::core::DataContainerTrait for ExplosionPackVehicleRayTrigger {
}

pub static EXPLOSIONPACKVEHICLERAYTRIGGER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExplosionPackVehicleRayTrigger",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(EXPLOSIONPACKTRIGGER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ExplosionPackVehicleRayTrigger as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ActivationDelay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ExplosionPackVehicleRayTrigger, activation_delay),
            },
            FieldInfoData {
                name: "Distance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ExplosionPackVehicleRayTrigger, distance),
            },
        ],
    }),
    array_type: Some(EXPLOSIONPACKVEHICLERAYTRIGGER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ExplosionPackVehicleRayTrigger {
    fn type_info(&self) -> &'static TypeInfo {
        EXPLOSIONPACKVEHICLERAYTRIGGER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EXPLOSIONPACKVEHICLERAYTRIGGER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExplosionPackVehicleRayTrigger-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("ExplosionPackVehicleRayTrigger"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ExplosionPackVehicleProximityTrigger {
    pub _glacier_base: ExplosionPackTrigger,
    pub activation_delay: f32,
    pub radius: f32,
    pub use_detailed_collision_check: bool,
}

pub trait ExplosionPackVehicleProximityTriggerTrait: ExplosionPackTriggerTrait {
    fn activation_delay(&self) -> &f32;
    fn activation_delay_mut(&mut self) -> &mut f32;
    fn radius(&self) -> &f32;
    fn radius_mut(&mut self) -> &mut f32;
    fn use_detailed_collision_check(&self) -> &bool;
    fn use_detailed_collision_check_mut(&mut self) -> &mut bool;
}

impl ExplosionPackVehicleProximityTriggerTrait for ExplosionPackVehicleProximityTrigger {
    fn activation_delay(&self) -> &f32 {
        &self.activation_delay
    }
    fn activation_delay_mut(&mut self) -> &mut f32 {
        &mut self.activation_delay
    }
    fn radius(&self) -> &f32 {
        &self.radius
    }
    fn radius_mut(&mut self) -> &mut f32 {
        &mut self.radius
    }
    fn use_detailed_collision_check(&self) -> &bool {
        &self.use_detailed_collision_check
    }
    fn use_detailed_collision_check_mut(&mut self) -> &mut bool {
        &mut self.use_detailed_collision_check
    }
}

impl ExplosionPackTriggerTrait for ExplosionPackVehicleProximityTrigger {
}

impl super::core::DataContainerTrait for ExplosionPackVehicleProximityTrigger {
}

pub static EXPLOSIONPACKVEHICLEPROXIMITYTRIGGER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExplosionPackVehicleProximityTrigger",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(EXPLOSIONPACKTRIGGER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ExplosionPackVehicleProximityTrigger as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ActivationDelay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ExplosionPackVehicleProximityTrigger, activation_delay),
            },
            FieldInfoData {
                name: "Radius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ExplosionPackVehicleProximityTrigger, radius),
            },
            FieldInfoData {
                name: "UseDetailedCollisionCheck",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ExplosionPackVehicleProximityTrigger, use_detailed_collision_check),
            },
        ],
    }),
    array_type: Some(EXPLOSIONPACKVEHICLEPROXIMITYTRIGGER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ExplosionPackVehicleProximityTrigger {
    fn type_info(&self) -> &'static TypeInfo {
        EXPLOSIONPACKVEHICLEPROXIMITYTRIGGER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EXPLOSIONPACKVEHICLEPROXIMITYTRIGGER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExplosionPackVehicleProximityTrigger-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("ExplosionPackVehicleProximityTrigger"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ExplosionPackTrigger {
    pub _glacier_base: super::core::DataContainer,
}

pub trait ExplosionPackTriggerTrait: super::core::DataContainerTrait {
}

impl ExplosionPackTriggerTrait for ExplosionPackTrigger {
}

impl super::core::DataContainerTrait for ExplosionPackTrigger {
}

pub static EXPLOSIONPACKTRIGGER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExplosionPackTrigger",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ExplosionPackTrigger as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(EXPLOSIONPACKTRIGGER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ExplosionPackTrigger {
    fn type_info(&self) -> &'static TypeInfo {
        EXPLOSIONPACKTRIGGER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EXPLOSIONPACKTRIGGER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExplosionPackTrigger-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("ExplosionPackTrigger"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoldierDetonationData {
    pub has_soldier_detonation: bool,
    pub use_angle: bool,
    pub angle: f32,
    pub radius: f32,
    pub soldier_detonation_activation_delay: f32,
    pub min_speed_for_activation: f32,
}

pub trait SoldierDetonationDataTrait: TypeObject {
    fn has_soldier_detonation(&self) -> &bool;
    fn has_soldier_detonation_mut(&mut self) -> &mut bool;
    fn use_angle(&self) -> &bool;
    fn use_angle_mut(&mut self) -> &mut bool;
    fn angle(&self) -> &f32;
    fn angle_mut(&mut self) -> &mut f32;
    fn radius(&self) -> &f32;
    fn radius_mut(&mut self) -> &mut f32;
    fn soldier_detonation_activation_delay(&self) -> &f32;
    fn soldier_detonation_activation_delay_mut(&mut self) -> &mut f32;
    fn min_speed_for_activation(&self) -> &f32;
    fn min_speed_for_activation_mut(&mut self) -> &mut f32;
}

impl SoldierDetonationDataTrait for SoldierDetonationData {
    fn has_soldier_detonation(&self) -> &bool {
        &self.has_soldier_detonation
    }
    fn has_soldier_detonation_mut(&mut self) -> &mut bool {
        &mut self.has_soldier_detonation
    }
    fn use_angle(&self) -> &bool {
        &self.use_angle
    }
    fn use_angle_mut(&mut self) -> &mut bool {
        &mut self.use_angle
    }
    fn angle(&self) -> &f32 {
        &self.angle
    }
    fn angle_mut(&mut self) -> &mut f32 {
        &mut self.angle
    }
    fn radius(&self) -> &f32 {
        &self.radius
    }
    fn radius_mut(&mut self) -> &mut f32 {
        &mut self.radius
    }
    fn soldier_detonation_activation_delay(&self) -> &f32 {
        &self.soldier_detonation_activation_delay
    }
    fn soldier_detonation_activation_delay_mut(&mut self) -> &mut f32 {
        &mut self.soldier_detonation_activation_delay
    }
    fn min_speed_for_activation(&self) -> &f32 {
        &self.min_speed_for_activation
    }
    fn min_speed_for_activation_mut(&mut self) -> &mut f32 {
        &mut self.min_speed_for_activation
    }
}

pub static SOLDIERDETONATIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierDetonationData",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierDetonationData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "HasSoldierDetonation",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierDetonationData, has_soldier_detonation),
            },
            FieldInfoData {
                name: "UseAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierDetonationData, use_angle),
            },
            FieldInfoData {
                name: "Angle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierDetonationData, angle),
            },
            FieldInfoData {
                name: "Radius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierDetonationData, radius),
            },
            FieldInfoData {
                name: "SoldierDetonationActivationDelay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierDetonationData, soldier_detonation_activation_delay),
            },
            FieldInfoData {
                name: "MinSpeedForActivation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierDetonationData, min_speed_for_activation),
            },
        ],
    }),
    array_type: Some(SOLDIERDETONATIONDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for SoldierDetonationData {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERDETONATIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SOLDIERDETONATIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierDetonationData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SoldierDetonationData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct NetworkSetActiveWeaponSlotMessage {
}

pub trait NetworkSetActiveWeaponSlotMessageTrait: TypeObject {
}

impl NetworkSetActiveWeaponSlotMessageTrait for NetworkSetActiveWeaponSlotMessage {
}

pub static NETWORKSETACTIVEWEAPONSLOTMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NetworkSetActiveWeaponSlotMessage",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<NetworkSetActiveWeaponSlotMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for NetworkSetActiveWeaponSlotMessage {
    fn type_info(&self) -> &'static TypeInfo {
        NETWORKSETACTIVEWEAPONSLOTMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Clone, Debug, Default)]
pub struct ExplosionToCharacterComponentsHitMessage {
}

pub trait ExplosionToCharacterComponentsHitMessageTrait: TypeObject {
}

impl ExplosionToCharacterComponentsHitMessageTrait for ExplosionToCharacterComponentsHitMessage {
}

pub static EXPLOSIONTOCHARACTERCOMPONENTSHITMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExplosionToCharacterComponentsHitMessage",
    flags: MemberInfoFlags::new(73),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ExplosionToCharacterComponentsHitMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 16,
};

impl TypeObject for ExplosionToCharacterComponentsHitMessage {
    fn type_info(&self) -> &'static TypeInfo {
        EXPLOSIONTOCHARACTERCOMPONENTSHITMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Clone, Debug, Default)]
pub struct BulletToCharacterComponentsHitMessage {
}

pub trait BulletToCharacterComponentsHitMessageTrait: TypeObject {
}

impl BulletToCharacterComponentsHitMessageTrait for BulletToCharacterComponentsHitMessage {
}

pub static BULLETTOCHARACTERCOMPONENTSHITMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BulletToCharacterComponentsHitMessage",
    flags: MemberInfoFlags::new(73),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BulletToCharacterComponentsHitMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 16,
};

impl TypeObject for BulletToCharacterComponentsHitMessage {
    fn type_info(&self) -> &'static TypeInfo {
        BULLETTOCHARACTERCOMPONENTSHITMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Clone, Debug, Default)]
pub struct ExplosionHitInfo {
    pub direction: super::core::Vec3,
    pub spawn_position: super::core::Vec3,
    pub hit_position: super::core::Vec3,
    pub weapon_unlock_asset: Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>>,
    pub shooter_player_id: i32,
    pub shooter_is_a_i_player: bool,
    pub within_blast_radius: bool,
}

pub trait ExplosionHitInfoTrait: TypeObject {
    fn direction(&self) -> &super::core::Vec3;
    fn direction_mut(&mut self) -> &mut super::core::Vec3;
    fn spawn_position(&self) -> &super::core::Vec3;
    fn spawn_position_mut(&mut self) -> &mut super::core::Vec3;
    fn hit_position(&self) -> &super::core::Vec3;
    fn hit_position_mut(&mut self) -> &mut super::core::Vec3;
    fn weapon_unlock_asset(&self) -> &Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>>;
    fn weapon_unlock_asset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>>;
    fn shooter_player_id(&self) -> &i32;
    fn shooter_player_id_mut(&mut self) -> &mut i32;
    fn shooter_is_a_i_player(&self) -> &bool;
    fn shooter_is_a_i_player_mut(&mut self) -> &mut bool;
    fn within_blast_radius(&self) -> &bool;
    fn within_blast_radius_mut(&mut self) -> &mut bool;
}

impl ExplosionHitInfoTrait for ExplosionHitInfo {
    fn direction(&self) -> &super::core::Vec3 {
        &self.direction
    }
    fn direction_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.direction
    }
    fn spawn_position(&self) -> &super::core::Vec3 {
        &self.spawn_position
    }
    fn spawn_position_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.spawn_position
    }
    fn hit_position(&self) -> &super::core::Vec3 {
        &self.hit_position
    }
    fn hit_position_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.hit_position
    }
    fn weapon_unlock_asset(&self) -> &Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>> {
        &self.weapon_unlock_asset
    }
    fn weapon_unlock_asset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>> {
        &mut self.weapon_unlock_asset
    }
    fn shooter_player_id(&self) -> &i32 {
        &self.shooter_player_id
    }
    fn shooter_player_id_mut(&mut self) -> &mut i32 {
        &mut self.shooter_player_id
    }
    fn shooter_is_a_i_player(&self) -> &bool {
        &self.shooter_is_a_i_player
    }
    fn shooter_is_a_i_player_mut(&mut self) -> &mut bool {
        &mut self.shooter_is_a_i_player
    }
    fn within_blast_radius(&self) -> &bool {
        &self.within_blast_radius
    }
    fn within_blast_radius_mut(&mut self) -> &mut bool {
        &mut self.within_blast_radius
    }
}

pub static EXPLOSIONHITINFO_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExplosionHitInfo",
    flags: MemberInfoFlags::new(73),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ExplosionHitInfo as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Direction",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(ExplosionHitInfo, direction),
            },
            FieldInfoData {
                name: "SpawnPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(ExplosionHitInfo, spawn_position),
            },
            FieldInfoData {
                name: "HitPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(ExplosionHitInfo, hit_position),
            },
            FieldInfoData {
                name: "WeaponUnlockAsset",
                flags: MemberInfoFlags::new(0),
                field_type: "UnlockAssetBase",
                rust_offset: offset_of!(ExplosionHitInfo, weapon_unlock_asset),
            },
            FieldInfoData {
                name: "ShooterPlayerId",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ExplosionHitInfo, shooter_player_id),
            },
            FieldInfoData {
                name: "ShooterIsAIPlayer",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ExplosionHitInfo, shooter_is_a_i_player),
            },
            FieldInfoData {
                name: "WithinBlastRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ExplosionHitInfo, within_blast_radius),
            },
        ],
    }),
    array_type: Some(EXPLOSIONHITINFO_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ExplosionHitInfo {
    fn type_info(&self) -> &'static TypeInfo {
        EXPLOSIONHITINFO_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static EXPLOSIONHITINFO_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExplosionHitInfo-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("ExplosionHitInfo"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BulletHitInfo {
    pub direction: super::core::Vec3,
    pub spawn_position: super::core::Vec3,
    pub hit_position: super::core::Vec3,
    pub weapon_unlock_asset: Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>>,
    pub weapon_type: super::weapon_shared::AntHitReactionWeaponType,
    pub bone_type: i32,
    pub shooter_player_id: i32,
    pub shooter_is_a_i_player: bool,
}

pub trait BulletHitInfoTrait: TypeObject {
    fn direction(&self) -> &super::core::Vec3;
    fn direction_mut(&mut self) -> &mut super::core::Vec3;
    fn spawn_position(&self) -> &super::core::Vec3;
    fn spawn_position_mut(&mut self) -> &mut super::core::Vec3;
    fn hit_position(&self) -> &super::core::Vec3;
    fn hit_position_mut(&mut self) -> &mut super::core::Vec3;
    fn weapon_unlock_asset(&self) -> &Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>>;
    fn weapon_unlock_asset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>>;
    fn weapon_type(&self) -> &super::weapon_shared::AntHitReactionWeaponType;
    fn weapon_type_mut(&mut self) -> &mut super::weapon_shared::AntHitReactionWeaponType;
    fn bone_type(&self) -> &i32;
    fn bone_type_mut(&mut self) -> &mut i32;
    fn shooter_player_id(&self) -> &i32;
    fn shooter_player_id_mut(&mut self) -> &mut i32;
    fn shooter_is_a_i_player(&self) -> &bool;
    fn shooter_is_a_i_player_mut(&mut self) -> &mut bool;
}

impl BulletHitInfoTrait for BulletHitInfo {
    fn direction(&self) -> &super::core::Vec3 {
        &self.direction
    }
    fn direction_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.direction
    }
    fn spawn_position(&self) -> &super::core::Vec3 {
        &self.spawn_position
    }
    fn spawn_position_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.spawn_position
    }
    fn hit_position(&self) -> &super::core::Vec3 {
        &self.hit_position
    }
    fn hit_position_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.hit_position
    }
    fn weapon_unlock_asset(&self) -> &Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>> {
        &self.weapon_unlock_asset
    }
    fn weapon_unlock_asset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>> {
        &mut self.weapon_unlock_asset
    }
    fn weapon_type(&self) -> &super::weapon_shared::AntHitReactionWeaponType {
        &self.weapon_type
    }
    fn weapon_type_mut(&mut self) -> &mut super::weapon_shared::AntHitReactionWeaponType {
        &mut self.weapon_type
    }
    fn bone_type(&self) -> &i32 {
        &self.bone_type
    }
    fn bone_type_mut(&mut self) -> &mut i32 {
        &mut self.bone_type
    }
    fn shooter_player_id(&self) -> &i32 {
        &self.shooter_player_id
    }
    fn shooter_player_id_mut(&mut self) -> &mut i32 {
        &mut self.shooter_player_id
    }
    fn shooter_is_a_i_player(&self) -> &bool {
        &self.shooter_is_a_i_player
    }
    fn shooter_is_a_i_player_mut(&mut self) -> &mut bool {
        &mut self.shooter_is_a_i_player
    }
}

pub static BULLETHITINFO_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BulletHitInfo",
    flags: MemberInfoFlags::new(73),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BulletHitInfo as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Direction",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(BulletHitInfo, direction),
            },
            FieldInfoData {
                name: "SpawnPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(BulletHitInfo, spawn_position),
            },
            FieldInfoData {
                name: "HitPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(BulletHitInfo, hit_position),
            },
            FieldInfoData {
                name: "WeaponUnlockAsset",
                flags: MemberInfoFlags::new(0),
                field_type: "UnlockAssetBase",
                rust_offset: offset_of!(BulletHitInfo, weapon_unlock_asset),
            },
            FieldInfoData {
                name: "WeaponType",
                flags: MemberInfoFlags::new(0),
                field_type: "AntHitReactionWeaponType",
                rust_offset: offset_of!(BulletHitInfo, weapon_type),
            },
            FieldInfoData {
                name: "BoneType",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(BulletHitInfo, bone_type),
            },
            FieldInfoData {
                name: "ShooterPlayerId",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(BulletHitInfo, shooter_player_id),
            },
            FieldInfoData {
                name: "ShooterIsAIPlayer",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BulletHitInfo, shooter_is_a_i_player),
            },
        ],
    }),
    array_type: Some(BULLETHITINFO_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for BulletHitInfo {
    fn type_info(&self) -> &'static TypeInfo {
        BULLETHITINFO_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static BULLETHITINFO_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BulletHitInfo-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("BulletHitInfo"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoldierWeaponData {
    pub _glacier_base: WeaponEntityData,
    pub damage_giver_name: String,
    pub zoom_levels: Vec<Option<Arc<Mutex<dyn WeaponZoomLevelDataTrait>>>>,
    pub weapon_modifier_data: Vec<WeaponModifierData>,
    pub aiming_controller: Option<Arc<Mutex<dyn SoldierAimingSimulationDataTrait>>>,
    pub first_person_camera: Option<Arc<Mutex<dyn FirstPersonCameraDataTrait>>>,
    pub sprint_settings: Option<Arc<Mutex<dyn WeaponSprintSettingsTrait>>>,
    pub hud: Vec<Option<Arc<Mutex<dyn super::gameplay_sim::HudDataTrait>>>>,
    pub pickup_settings: PickupSettingsData,
    pub anim_base_set: WeaponAnimBaseSetEnum,
    pub hide_when_out_of_ammo: bool,
    pub allow_switching_to_weapon_out_of_ammo: bool,
    pub allow_switching_to_weapon_reloading: bool,
    pub switch_to_primary_when_out_of_ammo: bool,
    pub switch_to_primary_when_out_of_ammo_delay: f32,
    pub wait_for_fire_before_switch_to_primary_when_out_of_ammo: bool,
    pub wait_for_zoom_out_before_switch_to_primary_when_out_of_ammo: bool,
    pub wait_for_zoom_out_before_switch_to_primary_when_out_of_ammo_delay: f32,
    pub undeploy_time: f32,
    pub fire_and_switch_back_to_prev_supported: bool,
    pub allow_switching_to_weapon_in_vehicles: bool,
    pub allow_switching_to_weapon_in_water: bool,
    pub interaction_offset: super::core::Vec3,
    pub lower_on_own_team: bool,
    pub redeploy_when_switching_weapon_states: bool,
    pub use_quick_throw_on_automatic_switchback: bool,
    pub quick_throw_type: QuickThrowTypeEnum,
    pub soldier_weapon_blueprint: Option<Arc<Mutex<dyn SoldierWeaponBlueprintTrait>>>,
    pub persistence_id: String,
    pub enable_breath_control: bool,
    pub can_be_in_supported_shooting: bool,
    pub secondary_action_input_action: i32,
    pub tertiary_action_input_action: i32,
    pub voice_over_info: Option<Arc<Mutex<dyn super::audio::EntityVoiceOverInfoTrait>>>,
    pub weapon_float_param: f32,
    pub max_range_meter_distance: f32,
    pub use_detailed_range_meter_query: bool,
    pub is_silenced: bool,
    pub skip_first_zoom_level: bool,
    pub customization_accessory_pivots: CustomizationAccessoryPivots,
    pub sockets_in_weapon: Vec<Option<Arc<Mutex<dyn SocketDataTrait>>>>,
}

pub trait SoldierWeaponDataTrait: WeaponEntityDataTrait {
    fn damage_giver_name(&self) -> &String;
    fn damage_giver_name_mut(&mut self) -> &mut String;
    fn zoom_levels(&self) -> &Vec<Option<Arc<Mutex<dyn WeaponZoomLevelDataTrait>>>>;
    fn zoom_levels_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn WeaponZoomLevelDataTrait>>>>;
    fn weapon_modifier_data(&self) -> &Vec<WeaponModifierData>;
    fn weapon_modifier_data_mut(&mut self) -> &mut Vec<WeaponModifierData>;
    fn aiming_controller(&self) -> &Option<Arc<Mutex<dyn SoldierAimingSimulationDataTrait>>>;
    fn aiming_controller_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoldierAimingSimulationDataTrait>>>;
    fn first_person_camera(&self) -> &Option<Arc<Mutex<dyn FirstPersonCameraDataTrait>>>;
    fn first_person_camera_mut(&mut self) -> &mut Option<Arc<Mutex<dyn FirstPersonCameraDataTrait>>>;
    fn sprint_settings(&self) -> &Option<Arc<Mutex<dyn WeaponSprintSettingsTrait>>>;
    fn sprint_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn WeaponSprintSettingsTrait>>>;
    fn hud(&self) -> &Vec<Option<Arc<Mutex<dyn super::gameplay_sim::HudDataTrait>>>>;
    fn hud_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::gameplay_sim::HudDataTrait>>>>;
    fn pickup_settings(&self) -> &PickupSettingsData;
    fn pickup_settings_mut(&mut self) -> &mut PickupSettingsData;
    fn anim_base_set(&self) -> &WeaponAnimBaseSetEnum;
    fn anim_base_set_mut(&mut self) -> &mut WeaponAnimBaseSetEnum;
    fn hide_when_out_of_ammo(&self) -> &bool;
    fn hide_when_out_of_ammo_mut(&mut self) -> &mut bool;
    fn allow_switching_to_weapon_out_of_ammo(&self) -> &bool;
    fn allow_switching_to_weapon_out_of_ammo_mut(&mut self) -> &mut bool;
    fn allow_switching_to_weapon_reloading(&self) -> &bool;
    fn allow_switching_to_weapon_reloading_mut(&mut self) -> &mut bool;
    fn switch_to_primary_when_out_of_ammo(&self) -> &bool;
    fn switch_to_primary_when_out_of_ammo_mut(&mut self) -> &mut bool;
    fn switch_to_primary_when_out_of_ammo_delay(&self) -> &f32;
    fn switch_to_primary_when_out_of_ammo_delay_mut(&mut self) -> &mut f32;
    fn wait_for_fire_before_switch_to_primary_when_out_of_ammo(&self) -> &bool;
    fn wait_for_fire_before_switch_to_primary_when_out_of_ammo_mut(&mut self) -> &mut bool;
    fn wait_for_zoom_out_before_switch_to_primary_when_out_of_ammo(&self) -> &bool;
    fn wait_for_zoom_out_before_switch_to_primary_when_out_of_ammo_mut(&mut self) -> &mut bool;
    fn wait_for_zoom_out_before_switch_to_primary_when_out_of_ammo_delay(&self) -> &f32;
    fn wait_for_zoom_out_before_switch_to_primary_when_out_of_ammo_delay_mut(&mut self) -> &mut f32;
    fn undeploy_time(&self) -> &f32;
    fn undeploy_time_mut(&mut self) -> &mut f32;
    fn fire_and_switch_back_to_prev_supported(&self) -> &bool;
    fn fire_and_switch_back_to_prev_supported_mut(&mut self) -> &mut bool;
    fn allow_switching_to_weapon_in_vehicles(&self) -> &bool;
    fn allow_switching_to_weapon_in_vehicles_mut(&mut self) -> &mut bool;
    fn allow_switching_to_weapon_in_water(&self) -> &bool;
    fn allow_switching_to_weapon_in_water_mut(&mut self) -> &mut bool;
    fn interaction_offset(&self) -> &super::core::Vec3;
    fn interaction_offset_mut(&mut self) -> &mut super::core::Vec3;
    fn lower_on_own_team(&self) -> &bool;
    fn lower_on_own_team_mut(&mut self) -> &mut bool;
    fn redeploy_when_switching_weapon_states(&self) -> &bool;
    fn redeploy_when_switching_weapon_states_mut(&mut self) -> &mut bool;
    fn use_quick_throw_on_automatic_switchback(&self) -> &bool;
    fn use_quick_throw_on_automatic_switchback_mut(&mut self) -> &mut bool;
    fn quick_throw_type(&self) -> &QuickThrowTypeEnum;
    fn quick_throw_type_mut(&mut self) -> &mut QuickThrowTypeEnum;
    fn soldier_weapon_blueprint(&self) -> &Option<Arc<Mutex<dyn SoldierWeaponBlueprintTrait>>>;
    fn soldier_weapon_blueprint_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoldierWeaponBlueprintTrait>>>;
    fn persistence_id(&self) -> &String;
    fn persistence_id_mut(&mut self) -> &mut String;
    fn enable_breath_control(&self) -> &bool;
    fn enable_breath_control_mut(&mut self) -> &mut bool;
    fn can_be_in_supported_shooting(&self) -> &bool;
    fn can_be_in_supported_shooting_mut(&mut self) -> &mut bool;
    fn secondary_action_input_action(&self) -> &i32;
    fn secondary_action_input_action_mut(&mut self) -> &mut i32;
    fn tertiary_action_input_action(&self) -> &i32;
    fn tertiary_action_input_action_mut(&mut self) -> &mut i32;
    fn voice_over_info(&self) -> &Option<Arc<Mutex<dyn super::audio::EntityVoiceOverInfoTrait>>>;
    fn voice_over_info_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::EntityVoiceOverInfoTrait>>>;
    fn weapon_float_param(&self) -> &f32;
    fn weapon_float_param_mut(&mut self) -> &mut f32;
    fn max_range_meter_distance(&self) -> &f32;
    fn max_range_meter_distance_mut(&mut self) -> &mut f32;
    fn use_detailed_range_meter_query(&self) -> &bool;
    fn use_detailed_range_meter_query_mut(&mut self) -> &mut bool;
    fn is_silenced(&self) -> &bool;
    fn is_silenced_mut(&mut self) -> &mut bool;
    fn skip_first_zoom_level(&self) -> &bool;
    fn skip_first_zoom_level_mut(&mut self) -> &mut bool;
    fn customization_accessory_pivots(&self) -> &CustomizationAccessoryPivots;
    fn customization_accessory_pivots_mut(&mut self) -> &mut CustomizationAccessoryPivots;
    fn sockets_in_weapon(&self) -> &Vec<Option<Arc<Mutex<dyn SocketDataTrait>>>>;
    fn sockets_in_weapon_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn SocketDataTrait>>>>;
}

impl SoldierWeaponDataTrait for SoldierWeaponData {
    fn damage_giver_name(&self) -> &String {
        &self.damage_giver_name
    }
    fn damage_giver_name_mut(&mut self) -> &mut String {
        &mut self.damage_giver_name
    }
    fn zoom_levels(&self) -> &Vec<Option<Arc<Mutex<dyn WeaponZoomLevelDataTrait>>>> {
        &self.zoom_levels
    }
    fn zoom_levels_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn WeaponZoomLevelDataTrait>>>> {
        &mut self.zoom_levels
    }
    fn weapon_modifier_data(&self) -> &Vec<WeaponModifierData> {
        &self.weapon_modifier_data
    }
    fn weapon_modifier_data_mut(&mut self) -> &mut Vec<WeaponModifierData> {
        &mut self.weapon_modifier_data
    }
    fn aiming_controller(&self) -> &Option<Arc<Mutex<dyn SoldierAimingSimulationDataTrait>>> {
        &self.aiming_controller
    }
    fn aiming_controller_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoldierAimingSimulationDataTrait>>> {
        &mut self.aiming_controller
    }
    fn first_person_camera(&self) -> &Option<Arc<Mutex<dyn FirstPersonCameraDataTrait>>> {
        &self.first_person_camera
    }
    fn first_person_camera_mut(&mut self) -> &mut Option<Arc<Mutex<dyn FirstPersonCameraDataTrait>>> {
        &mut self.first_person_camera
    }
    fn sprint_settings(&self) -> &Option<Arc<Mutex<dyn WeaponSprintSettingsTrait>>> {
        &self.sprint_settings
    }
    fn sprint_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn WeaponSprintSettingsTrait>>> {
        &mut self.sprint_settings
    }
    fn hud(&self) -> &Vec<Option<Arc<Mutex<dyn super::gameplay_sim::HudDataTrait>>>> {
        &self.hud
    }
    fn hud_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::gameplay_sim::HudDataTrait>>>> {
        &mut self.hud
    }
    fn pickup_settings(&self) -> &PickupSettingsData {
        &self.pickup_settings
    }
    fn pickup_settings_mut(&mut self) -> &mut PickupSettingsData {
        &mut self.pickup_settings
    }
    fn anim_base_set(&self) -> &WeaponAnimBaseSetEnum {
        &self.anim_base_set
    }
    fn anim_base_set_mut(&mut self) -> &mut WeaponAnimBaseSetEnum {
        &mut self.anim_base_set
    }
    fn hide_when_out_of_ammo(&self) -> &bool {
        &self.hide_when_out_of_ammo
    }
    fn hide_when_out_of_ammo_mut(&mut self) -> &mut bool {
        &mut self.hide_when_out_of_ammo
    }
    fn allow_switching_to_weapon_out_of_ammo(&self) -> &bool {
        &self.allow_switching_to_weapon_out_of_ammo
    }
    fn allow_switching_to_weapon_out_of_ammo_mut(&mut self) -> &mut bool {
        &mut self.allow_switching_to_weapon_out_of_ammo
    }
    fn allow_switching_to_weapon_reloading(&self) -> &bool {
        &self.allow_switching_to_weapon_reloading
    }
    fn allow_switching_to_weapon_reloading_mut(&mut self) -> &mut bool {
        &mut self.allow_switching_to_weapon_reloading
    }
    fn switch_to_primary_when_out_of_ammo(&self) -> &bool {
        &self.switch_to_primary_when_out_of_ammo
    }
    fn switch_to_primary_when_out_of_ammo_mut(&mut self) -> &mut bool {
        &mut self.switch_to_primary_when_out_of_ammo
    }
    fn switch_to_primary_when_out_of_ammo_delay(&self) -> &f32 {
        &self.switch_to_primary_when_out_of_ammo_delay
    }
    fn switch_to_primary_when_out_of_ammo_delay_mut(&mut self) -> &mut f32 {
        &mut self.switch_to_primary_when_out_of_ammo_delay
    }
    fn wait_for_fire_before_switch_to_primary_when_out_of_ammo(&self) -> &bool {
        &self.wait_for_fire_before_switch_to_primary_when_out_of_ammo
    }
    fn wait_for_fire_before_switch_to_primary_when_out_of_ammo_mut(&mut self) -> &mut bool {
        &mut self.wait_for_fire_before_switch_to_primary_when_out_of_ammo
    }
    fn wait_for_zoom_out_before_switch_to_primary_when_out_of_ammo(&self) -> &bool {
        &self.wait_for_zoom_out_before_switch_to_primary_when_out_of_ammo
    }
    fn wait_for_zoom_out_before_switch_to_primary_when_out_of_ammo_mut(&mut self) -> &mut bool {
        &mut self.wait_for_zoom_out_before_switch_to_primary_when_out_of_ammo
    }
    fn wait_for_zoom_out_before_switch_to_primary_when_out_of_ammo_delay(&self) -> &f32 {
        &self.wait_for_zoom_out_before_switch_to_primary_when_out_of_ammo_delay
    }
    fn wait_for_zoom_out_before_switch_to_primary_when_out_of_ammo_delay_mut(&mut self) -> &mut f32 {
        &mut self.wait_for_zoom_out_before_switch_to_primary_when_out_of_ammo_delay
    }
    fn undeploy_time(&self) -> &f32 {
        &self.undeploy_time
    }
    fn undeploy_time_mut(&mut self) -> &mut f32 {
        &mut self.undeploy_time
    }
    fn fire_and_switch_back_to_prev_supported(&self) -> &bool {
        &self.fire_and_switch_back_to_prev_supported
    }
    fn fire_and_switch_back_to_prev_supported_mut(&mut self) -> &mut bool {
        &mut self.fire_and_switch_back_to_prev_supported
    }
    fn allow_switching_to_weapon_in_vehicles(&self) -> &bool {
        &self.allow_switching_to_weapon_in_vehicles
    }
    fn allow_switching_to_weapon_in_vehicles_mut(&mut self) -> &mut bool {
        &mut self.allow_switching_to_weapon_in_vehicles
    }
    fn allow_switching_to_weapon_in_water(&self) -> &bool {
        &self.allow_switching_to_weapon_in_water
    }
    fn allow_switching_to_weapon_in_water_mut(&mut self) -> &mut bool {
        &mut self.allow_switching_to_weapon_in_water
    }
    fn interaction_offset(&self) -> &super::core::Vec3 {
        &self.interaction_offset
    }
    fn interaction_offset_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.interaction_offset
    }
    fn lower_on_own_team(&self) -> &bool {
        &self.lower_on_own_team
    }
    fn lower_on_own_team_mut(&mut self) -> &mut bool {
        &mut self.lower_on_own_team
    }
    fn redeploy_when_switching_weapon_states(&self) -> &bool {
        &self.redeploy_when_switching_weapon_states
    }
    fn redeploy_when_switching_weapon_states_mut(&mut self) -> &mut bool {
        &mut self.redeploy_when_switching_weapon_states
    }
    fn use_quick_throw_on_automatic_switchback(&self) -> &bool {
        &self.use_quick_throw_on_automatic_switchback
    }
    fn use_quick_throw_on_automatic_switchback_mut(&mut self) -> &mut bool {
        &mut self.use_quick_throw_on_automatic_switchback
    }
    fn quick_throw_type(&self) -> &QuickThrowTypeEnum {
        &self.quick_throw_type
    }
    fn quick_throw_type_mut(&mut self) -> &mut QuickThrowTypeEnum {
        &mut self.quick_throw_type
    }
    fn soldier_weapon_blueprint(&self) -> &Option<Arc<Mutex<dyn SoldierWeaponBlueprintTrait>>> {
        &self.soldier_weapon_blueprint
    }
    fn soldier_weapon_blueprint_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoldierWeaponBlueprintTrait>>> {
        &mut self.soldier_weapon_blueprint
    }
    fn persistence_id(&self) -> &String {
        &self.persistence_id
    }
    fn persistence_id_mut(&mut self) -> &mut String {
        &mut self.persistence_id
    }
    fn enable_breath_control(&self) -> &bool {
        &self.enable_breath_control
    }
    fn enable_breath_control_mut(&mut self) -> &mut bool {
        &mut self.enable_breath_control
    }
    fn can_be_in_supported_shooting(&self) -> &bool {
        &self.can_be_in_supported_shooting
    }
    fn can_be_in_supported_shooting_mut(&mut self) -> &mut bool {
        &mut self.can_be_in_supported_shooting
    }
    fn secondary_action_input_action(&self) -> &i32 {
        &self.secondary_action_input_action
    }
    fn secondary_action_input_action_mut(&mut self) -> &mut i32 {
        &mut self.secondary_action_input_action
    }
    fn tertiary_action_input_action(&self) -> &i32 {
        &self.tertiary_action_input_action
    }
    fn tertiary_action_input_action_mut(&mut self) -> &mut i32 {
        &mut self.tertiary_action_input_action
    }
    fn voice_over_info(&self) -> &Option<Arc<Mutex<dyn super::audio::EntityVoiceOverInfoTrait>>> {
        &self.voice_over_info
    }
    fn voice_over_info_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::EntityVoiceOverInfoTrait>>> {
        &mut self.voice_over_info
    }
    fn weapon_float_param(&self) -> &f32 {
        &self.weapon_float_param
    }
    fn weapon_float_param_mut(&mut self) -> &mut f32 {
        &mut self.weapon_float_param
    }
    fn max_range_meter_distance(&self) -> &f32 {
        &self.max_range_meter_distance
    }
    fn max_range_meter_distance_mut(&mut self) -> &mut f32 {
        &mut self.max_range_meter_distance
    }
    fn use_detailed_range_meter_query(&self) -> &bool {
        &self.use_detailed_range_meter_query
    }
    fn use_detailed_range_meter_query_mut(&mut self) -> &mut bool {
        &mut self.use_detailed_range_meter_query
    }
    fn is_silenced(&self) -> &bool {
        &self.is_silenced
    }
    fn is_silenced_mut(&mut self) -> &mut bool {
        &mut self.is_silenced
    }
    fn skip_first_zoom_level(&self) -> &bool {
        &self.skip_first_zoom_level
    }
    fn skip_first_zoom_level_mut(&mut self) -> &mut bool {
        &mut self.skip_first_zoom_level
    }
    fn customization_accessory_pivots(&self) -> &CustomizationAccessoryPivots {
        &self.customization_accessory_pivots
    }
    fn customization_accessory_pivots_mut(&mut self) -> &mut CustomizationAccessoryPivots {
        &mut self.customization_accessory_pivots
    }
    fn sockets_in_weapon(&self) -> &Vec<Option<Arc<Mutex<dyn SocketDataTrait>>>> {
        &self.sockets_in_weapon
    }
    fn sockets_in_weapon_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn SocketDataTrait>>>> {
        &mut self.sockets_in_weapon
    }
}

impl WeaponEntityDataTrait for SoldierWeaponData {
    fn weapon_class(&self) -> &WeaponClassEnum {
        self._glacier_base.weapon_class()
    }
    fn weapon_class_mut(&mut self) -> &mut WeaponClassEnum {
        self._glacier_base.weapon_class_mut()
    }
    fn weapon_states(&self) -> &Vec<WeaponStateData> {
        self._glacier_base.weapon_states()
    }
    fn weapon_states_mut(&mut self) -> &mut Vec<WeaponStateData> {
        self._glacier_base.weapon_states_mut()
    }
    fn weapon_firing(&self) -> &Option<Arc<Mutex<dyn super::weapon_shared::WeaponFiringDataTrait>>> {
        self._glacier_base.weapon_firing()
    }
    fn weapon_firing_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::weapon_shared::WeaponFiringDataTrait>>> {
        self._glacier_base.weapon_firing_mut()
    }
    fn custom_weapon_type(&self) -> &Option<Arc<Mutex<dyn super::weapon_shared::WeaponDataTrait>>> {
        self._glacier_base.custom_weapon_type()
    }
    fn custom_weapon_type_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::weapon_shared::WeaponDataTrait>>> {
        self._glacier_base.custom_weapon_type_mut()
    }
    fn a_i_data(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::GameAIWeaponDataTrait>>> {
        self._glacier_base.a_i_data()
    }
    fn a_i_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::GameAIWeaponDataTrait>>> {
        self._glacier_base.a_i_data_mut()
    }
}

impl super::entity::GameComponentEntityDataTrait for SoldierWeaponData {
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::ComponentEntityDataTrait for SoldierWeaponData {
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn part_bounding_boxes(&self) -> &Vec<super::core::AxisAlignedBox> {
        self._glacier_base.part_bounding_boxes()
    }
    fn part_bounding_boxes_mut(&mut self) -> &mut Vec<super::core::AxisAlignedBox> {
        self._glacier_base.part_bounding_boxes_mut()
    }
    fn client_runtime_component_count(&self) -> &u8 {
        self._glacier_base.client_runtime_component_count()
    }
    fn client_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_component_count_mut()
    }
    fn server_runtime_component_count(&self) -> &u8 {
        self._glacier_base.server_runtime_component_count()
    }
    fn server_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_component_count_mut()
    }
    fn client_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.client_runtime_transformation_count()
    }
    fn client_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_transformation_count_mut()
    }
    fn server_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.server_runtime_transformation_count()
    }
    fn server_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_transformation_count_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for SoldierWeaponData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for SoldierWeaponData {
}

impl super::entity::GameObjectDataTrait for SoldierWeaponData {
}

impl super::core::DataBusPeerTrait for SoldierWeaponData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SoldierWeaponData {
}

impl super::core::DataContainerTrait for SoldierWeaponData {
}

pub static SOLDIERWEAPONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierWeaponData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(WEAPONENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierWeaponData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DamageGiverName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(SoldierWeaponData, damage_giver_name),
            },
            FieldInfoData {
                name: "ZoomLevels",
                flags: MemberInfoFlags::new(144),
                field_type: "WeaponZoomLevelData-Array",
                rust_offset: offset_of!(SoldierWeaponData, zoom_levels),
            },
            FieldInfoData {
                name: "WeaponModifierData",
                flags: MemberInfoFlags::new(144),
                field_type: "WeaponModifierData-Array",
                rust_offset: offset_of!(SoldierWeaponData, weapon_modifier_data),
            },
            FieldInfoData {
                name: "AimingController",
                flags: MemberInfoFlags::new(0),
                field_type: "SoldierAimingSimulationData",
                rust_offset: offset_of!(SoldierWeaponData, aiming_controller),
            },
            FieldInfoData {
                name: "FirstPersonCamera",
                flags: MemberInfoFlags::new(0),
                field_type: "FirstPersonCameraData",
                rust_offset: offset_of!(SoldierWeaponData, first_person_camera),
            },
            FieldInfoData {
                name: "SprintSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "WeaponSprintSettings",
                rust_offset: offset_of!(SoldierWeaponData, sprint_settings),
            },
            FieldInfoData {
                name: "Hud",
                flags: MemberInfoFlags::new(144),
                field_type: "HudData-Array",
                rust_offset: offset_of!(SoldierWeaponData, hud),
            },
            FieldInfoData {
                name: "PickupSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "PickupSettingsData",
                rust_offset: offset_of!(SoldierWeaponData, pickup_settings),
            },
            FieldInfoData {
                name: "AnimBaseSet",
                flags: MemberInfoFlags::new(0),
                field_type: "WeaponAnimBaseSetEnum",
                rust_offset: offset_of!(SoldierWeaponData, anim_base_set),
            },
            FieldInfoData {
                name: "HideWhenOutOfAmmo",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierWeaponData, hide_when_out_of_ammo),
            },
            FieldInfoData {
                name: "AllowSwitchingToWeaponOutOfAmmo",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierWeaponData, allow_switching_to_weapon_out_of_ammo),
            },
            FieldInfoData {
                name: "AllowSwitchingToWeaponReloading",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierWeaponData, allow_switching_to_weapon_reloading),
            },
            FieldInfoData {
                name: "SwitchToPrimaryWhenOutOfAmmo",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierWeaponData, switch_to_primary_when_out_of_ammo),
            },
            FieldInfoData {
                name: "SwitchToPrimaryWhenOutOfAmmoDelay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierWeaponData, switch_to_primary_when_out_of_ammo_delay),
            },
            FieldInfoData {
                name: "WaitForFireBeforeSwitchToPrimaryWhenOutOfAmmo",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierWeaponData, wait_for_fire_before_switch_to_primary_when_out_of_ammo),
            },
            FieldInfoData {
                name: "WaitForZoomOutBeforeSwitchToPrimaryWhenOutOfAmmo",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierWeaponData, wait_for_zoom_out_before_switch_to_primary_when_out_of_ammo),
            },
            FieldInfoData {
                name: "WaitForZoomOutBeforeSwitchToPrimaryWhenOutOfAmmoDelay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierWeaponData, wait_for_zoom_out_before_switch_to_primary_when_out_of_ammo_delay),
            },
            FieldInfoData {
                name: "UndeployTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierWeaponData, undeploy_time),
            },
            FieldInfoData {
                name: "FireAndSwitchBackToPrevSupported",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierWeaponData, fire_and_switch_back_to_prev_supported),
            },
            FieldInfoData {
                name: "AllowSwitchingToWeaponInVehicles",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierWeaponData, allow_switching_to_weapon_in_vehicles),
            },
            FieldInfoData {
                name: "AllowSwitchingToWeaponInWater",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierWeaponData, allow_switching_to_weapon_in_water),
            },
            FieldInfoData {
                name: "InteractionOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SoldierWeaponData, interaction_offset),
            },
            FieldInfoData {
                name: "LowerOnOwnTeam",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierWeaponData, lower_on_own_team),
            },
            FieldInfoData {
                name: "RedeployWhenSwitchingWeaponStates",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierWeaponData, redeploy_when_switching_weapon_states),
            },
            FieldInfoData {
                name: "UseQuickThrowOnAutomaticSwitchback",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierWeaponData, use_quick_throw_on_automatic_switchback),
            },
            FieldInfoData {
                name: "QuickThrowType",
                flags: MemberInfoFlags::new(0),
                field_type: "QuickThrowTypeEnum",
                rust_offset: offset_of!(SoldierWeaponData, quick_throw_type),
            },
            FieldInfoData {
                name: "SoldierWeaponBlueprint",
                flags: MemberInfoFlags::new(0),
                field_type: "SoldierWeaponBlueprint",
                rust_offset: offset_of!(SoldierWeaponData, soldier_weapon_blueprint),
            },
            FieldInfoData {
                name: "PersistenceId",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(SoldierWeaponData, persistence_id),
            },
            FieldInfoData {
                name: "EnableBreathControl",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierWeaponData, enable_breath_control),
            },
            FieldInfoData {
                name: "CanBeInSupportedShooting",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierWeaponData, can_be_in_supported_shooting),
            },
            FieldInfoData {
                name: "SecondaryActionInputAction",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SoldierWeaponData, secondary_action_input_action),
            },
            FieldInfoData {
                name: "TertiaryActionInputAction",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SoldierWeaponData, tertiary_action_input_action),
            },
            FieldInfoData {
                name: "VoiceOverInfo",
                flags: MemberInfoFlags::new(0),
                field_type: "EntityVoiceOverInfo",
                rust_offset: offset_of!(SoldierWeaponData, voice_over_info),
            },
            FieldInfoData {
                name: "WeaponFloatParam",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierWeaponData, weapon_float_param),
            },
            FieldInfoData {
                name: "MaxRangeMeterDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierWeaponData, max_range_meter_distance),
            },
            FieldInfoData {
                name: "UseDetailedRangeMeterQuery",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierWeaponData, use_detailed_range_meter_query),
            },
            FieldInfoData {
                name: "IsSilenced",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierWeaponData, is_silenced),
            },
            FieldInfoData {
                name: "SkipFirstZoomLevel",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierWeaponData, skip_first_zoom_level),
            },
            FieldInfoData {
                name: "CustomizationAccessoryPivots",
                flags: MemberInfoFlags::new(0),
                field_type: "CustomizationAccessoryPivots",
                rust_offset: offset_of!(SoldierWeaponData, customization_accessory_pivots),
            },
            FieldInfoData {
                name: "SocketsInWeapon",
                flags: MemberInfoFlags::new(144),
                field_type: "SocketData-Array",
                rust_offset: offset_of!(SoldierWeaponData, sockets_in_weapon),
            },
        ],
    }),
    array_type: Some(SOLDIERWEAPONDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SoldierWeaponData {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERWEAPONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOLDIERWEAPONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierWeaponData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SoldierWeaponData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WeaponSprintSettings {
    pub _glacier_base: super::core::DataContainer,
    pub sprint_recover_time_multiplier: f32,
    pub sprint_to_prone_recover_time_multiplier: f32,
}

pub trait WeaponSprintSettingsTrait: super::core::DataContainerTrait {
    fn sprint_recover_time_multiplier(&self) -> &f32;
    fn sprint_recover_time_multiplier_mut(&mut self) -> &mut f32;
    fn sprint_to_prone_recover_time_multiplier(&self) -> &f32;
    fn sprint_to_prone_recover_time_multiplier_mut(&mut self) -> &mut f32;
}

impl WeaponSprintSettingsTrait for WeaponSprintSettings {
    fn sprint_recover_time_multiplier(&self) -> &f32 {
        &self.sprint_recover_time_multiplier
    }
    fn sprint_recover_time_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.sprint_recover_time_multiplier
    }
    fn sprint_to_prone_recover_time_multiplier(&self) -> &f32 {
        &self.sprint_to_prone_recover_time_multiplier
    }
    fn sprint_to_prone_recover_time_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.sprint_to_prone_recover_time_multiplier
    }
}

impl super::core::DataContainerTrait for WeaponSprintSettings {
}

pub static WEAPONSPRINTSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponSprintSettings",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WeaponSprintSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SprintRecoverTimeMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WeaponSprintSettings, sprint_recover_time_multiplier),
            },
            FieldInfoData {
                name: "SprintToProneRecoverTimeMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WeaponSprintSettings, sprint_to_prone_recover_time_multiplier),
            },
        ],
    }),
    array_type: Some(WEAPONSPRINTSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WeaponSprintSettings {
    fn type_info(&self) -> &'static TypeInfo {
        WEAPONSPRINTSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WEAPONSPRINTSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponSprintSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("WeaponSprintSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ClientSoldierWeaponSpawnedMessage {
}

pub trait ClientSoldierWeaponSpawnedMessageTrait: TypeObject {
}

impl ClientSoldierWeaponSpawnedMessageTrait for ClientSoldierWeaponSpawnedMessage {
}

pub static CLIENTSOLDIERWEAPONSPAWNEDMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClientSoldierWeaponSpawnedMessage",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ClientSoldierWeaponSpawnedMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for ClientSoldierWeaponSpawnedMessage {
    fn type_info(&self) -> &'static TypeInfo {
        CLIENTSOLDIERWEAPONSPAWNEDMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Clone, Debug, Default)]
pub struct ServerSoldierWeaponSpawnedMessage {
}

pub trait ServerSoldierWeaponSpawnedMessageTrait: TypeObject {
}

impl ServerSoldierWeaponSpawnedMessageTrait for ServerSoldierWeaponSpawnedMessage {
}

pub static SERVERSOLDIERWEAPONSPAWNEDMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ServerSoldierWeaponSpawnedMessage",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ServerSoldierWeaponSpawnedMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for ServerSoldierWeaponSpawnedMessage {
    fn type_info(&self) -> &'static TypeInfo {
        SERVERSOLDIERWEAPONSPAWNEDMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Clone, Debug, Default)]
pub struct CustomizationAccessoryPivots {
    pub base_pivot_pos: super::core::Vec3,
    pub optic_pivot_pos: super::core::Vec3,
    pub barrel_pivot_pos: super::core::Vec3,
    pub accessory_pivot_pos: super::core::Vec3,
    pub under_barrel_pivot_pos: super::core::Vec3,
}

pub trait CustomizationAccessoryPivotsTrait: TypeObject {
    fn base_pivot_pos(&self) -> &super::core::Vec3;
    fn base_pivot_pos_mut(&mut self) -> &mut super::core::Vec3;
    fn optic_pivot_pos(&self) -> &super::core::Vec3;
    fn optic_pivot_pos_mut(&mut self) -> &mut super::core::Vec3;
    fn barrel_pivot_pos(&self) -> &super::core::Vec3;
    fn barrel_pivot_pos_mut(&mut self) -> &mut super::core::Vec3;
    fn accessory_pivot_pos(&self) -> &super::core::Vec3;
    fn accessory_pivot_pos_mut(&mut self) -> &mut super::core::Vec3;
    fn under_barrel_pivot_pos(&self) -> &super::core::Vec3;
    fn under_barrel_pivot_pos_mut(&mut self) -> &mut super::core::Vec3;
}

impl CustomizationAccessoryPivotsTrait for CustomizationAccessoryPivots {
    fn base_pivot_pos(&self) -> &super::core::Vec3 {
        &self.base_pivot_pos
    }
    fn base_pivot_pos_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.base_pivot_pos
    }
    fn optic_pivot_pos(&self) -> &super::core::Vec3 {
        &self.optic_pivot_pos
    }
    fn optic_pivot_pos_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.optic_pivot_pos
    }
    fn barrel_pivot_pos(&self) -> &super::core::Vec3 {
        &self.barrel_pivot_pos
    }
    fn barrel_pivot_pos_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.barrel_pivot_pos
    }
    fn accessory_pivot_pos(&self) -> &super::core::Vec3 {
        &self.accessory_pivot_pos
    }
    fn accessory_pivot_pos_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.accessory_pivot_pos
    }
    fn under_barrel_pivot_pos(&self) -> &super::core::Vec3 {
        &self.under_barrel_pivot_pos
    }
    fn under_barrel_pivot_pos_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.under_barrel_pivot_pos
    }
}

pub static CUSTOMIZATIONACCESSORYPIVOTS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomizationAccessoryPivots",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CustomizationAccessoryPivots as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "BasePivotPos",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(CustomizationAccessoryPivots, base_pivot_pos),
            },
            FieldInfoData {
                name: "OpticPivotPos",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(CustomizationAccessoryPivots, optic_pivot_pos),
            },
            FieldInfoData {
                name: "BarrelPivotPos",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(CustomizationAccessoryPivots, barrel_pivot_pos),
            },
            FieldInfoData {
                name: "AccessoryPivotPos",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(CustomizationAccessoryPivots, accessory_pivot_pos),
            },
            FieldInfoData {
                name: "UnderBarrelPivotPos",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(CustomizationAccessoryPivots, under_barrel_pivot_pos),
            },
        ],
    }),
    array_type: Some(CUSTOMIZATIONACCESSORYPIVOTS_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CustomizationAccessoryPivots {
    fn type_info(&self) -> &'static TypeInfo {
        CUSTOMIZATIONACCESSORYPIVOTS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CUSTOMIZATIONACCESSORYPIVOTS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomizationAccessoryPivots-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("CustomizationAccessoryPivots"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WeaponZoomLevelData {
    pub _glacier_base: super::core::DataContainer,
    pub render_fov: f32,
    pub render_fov_transition: Option<Arc<Mutex<dyn super::gameplay_sim::FOVTransitionDataTrait>>>,
    pub zoom_in_out_mesh_transition_factors: Vec<f32>,
    pub zoom_disabled_transition_timer: f32,
    pub sight_type: SightType,
    pub animation_settings: WeaponAnimationSettingsData,
}

pub trait WeaponZoomLevelDataTrait: super::core::DataContainerTrait {
    fn render_fov(&self) -> &f32;
    fn render_fov_mut(&mut self) -> &mut f32;
    fn render_fov_transition(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::FOVTransitionDataTrait>>>;
    fn render_fov_transition_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::FOVTransitionDataTrait>>>;
    fn zoom_in_out_mesh_transition_factors(&self) -> &Vec<f32>;
    fn zoom_in_out_mesh_transition_factors_mut(&mut self) -> &mut Vec<f32>;
    fn zoom_disabled_transition_timer(&self) -> &f32;
    fn zoom_disabled_transition_timer_mut(&mut self) -> &mut f32;
    fn sight_type(&self) -> &SightType;
    fn sight_type_mut(&mut self) -> &mut SightType;
    fn animation_settings(&self) -> &WeaponAnimationSettingsData;
    fn animation_settings_mut(&mut self) -> &mut WeaponAnimationSettingsData;
}

impl WeaponZoomLevelDataTrait for WeaponZoomLevelData {
    fn render_fov(&self) -> &f32 {
        &self.render_fov
    }
    fn render_fov_mut(&mut self) -> &mut f32 {
        &mut self.render_fov
    }
    fn render_fov_transition(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::FOVTransitionDataTrait>>> {
        &self.render_fov_transition
    }
    fn render_fov_transition_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::FOVTransitionDataTrait>>> {
        &mut self.render_fov_transition
    }
    fn zoom_in_out_mesh_transition_factors(&self) -> &Vec<f32> {
        &self.zoom_in_out_mesh_transition_factors
    }
    fn zoom_in_out_mesh_transition_factors_mut(&mut self) -> &mut Vec<f32> {
        &mut self.zoom_in_out_mesh_transition_factors
    }
    fn zoom_disabled_transition_timer(&self) -> &f32 {
        &self.zoom_disabled_transition_timer
    }
    fn zoom_disabled_transition_timer_mut(&mut self) -> &mut f32 {
        &mut self.zoom_disabled_transition_timer
    }
    fn sight_type(&self) -> &SightType {
        &self.sight_type
    }
    fn sight_type_mut(&mut self) -> &mut SightType {
        &mut self.sight_type
    }
    fn animation_settings(&self) -> &WeaponAnimationSettingsData {
        &self.animation_settings
    }
    fn animation_settings_mut(&mut self) -> &mut WeaponAnimationSettingsData {
        &mut self.animation_settings
    }
}

impl super::core::DataContainerTrait for WeaponZoomLevelData {
}

pub static WEAPONZOOMLEVELDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponZoomLevelData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WeaponZoomLevelData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "RenderFov",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WeaponZoomLevelData, render_fov),
            },
            FieldInfoData {
                name: "RenderFovTransition",
                flags: MemberInfoFlags::new(0),
                field_type: "FOVTransitionData",
                rust_offset: offset_of!(WeaponZoomLevelData, render_fov_transition),
            },
            FieldInfoData {
                name: "ZoomInOutMeshTransitionFactors",
                flags: MemberInfoFlags::new(144),
                field_type: "Float32-Array",
                rust_offset: offset_of!(WeaponZoomLevelData, zoom_in_out_mesh_transition_factors),
            },
            FieldInfoData {
                name: "ZoomDisabledTransitionTimer",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WeaponZoomLevelData, zoom_disabled_transition_timer),
            },
            FieldInfoData {
                name: "SightType",
                flags: MemberInfoFlags::new(0),
                field_type: "SightType",
                rust_offset: offset_of!(WeaponZoomLevelData, sight_type),
            },
            FieldInfoData {
                name: "AnimationSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "WeaponAnimationSettingsData",
                rust_offset: offset_of!(WeaponZoomLevelData, animation_settings),
            },
        ],
    }),
    array_type: Some(WEAPONZOOMLEVELDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WeaponZoomLevelData {
    fn type_info(&self) -> &'static TypeInfo {
        WEAPONZOOMLEVELDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WEAPONZOOMLEVELDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponZoomLevelData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("WeaponZoomLevelData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WeaponAnimationSettingsData {
    pub kickback_factor: f32,
    pub kickback_speed_factor: f32,
    pub weapon_offset_x: f32,
    pub weapon_offset_y: f32,
    pub weapon_offset_z: f32,
    pub zoom_out_speed: f32,
    pub zoom_in_speed: f32,
}

pub trait WeaponAnimationSettingsDataTrait: TypeObject {
    fn kickback_factor(&self) -> &f32;
    fn kickback_factor_mut(&mut self) -> &mut f32;
    fn kickback_speed_factor(&self) -> &f32;
    fn kickback_speed_factor_mut(&mut self) -> &mut f32;
    fn weapon_offset_x(&self) -> &f32;
    fn weapon_offset_x_mut(&mut self) -> &mut f32;
    fn weapon_offset_y(&self) -> &f32;
    fn weapon_offset_y_mut(&mut self) -> &mut f32;
    fn weapon_offset_z(&self) -> &f32;
    fn weapon_offset_z_mut(&mut self) -> &mut f32;
    fn zoom_out_speed(&self) -> &f32;
    fn zoom_out_speed_mut(&mut self) -> &mut f32;
    fn zoom_in_speed(&self) -> &f32;
    fn zoom_in_speed_mut(&mut self) -> &mut f32;
}

impl WeaponAnimationSettingsDataTrait for WeaponAnimationSettingsData {
    fn kickback_factor(&self) -> &f32 {
        &self.kickback_factor
    }
    fn kickback_factor_mut(&mut self) -> &mut f32 {
        &mut self.kickback_factor
    }
    fn kickback_speed_factor(&self) -> &f32 {
        &self.kickback_speed_factor
    }
    fn kickback_speed_factor_mut(&mut self) -> &mut f32 {
        &mut self.kickback_speed_factor
    }
    fn weapon_offset_x(&self) -> &f32 {
        &self.weapon_offset_x
    }
    fn weapon_offset_x_mut(&mut self) -> &mut f32 {
        &mut self.weapon_offset_x
    }
    fn weapon_offset_y(&self) -> &f32 {
        &self.weapon_offset_y
    }
    fn weapon_offset_y_mut(&mut self) -> &mut f32 {
        &mut self.weapon_offset_y
    }
    fn weapon_offset_z(&self) -> &f32 {
        &self.weapon_offset_z
    }
    fn weapon_offset_z_mut(&mut self) -> &mut f32 {
        &mut self.weapon_offset_z
    }
    fn zoom_out_speed(&self) -> &f32 {
        &self.zoom_out_speed
    }
    fn zoom_out_speed_mut(&mut self) -> &mut f32 {
        &mut self.zoom_out_speed
    }
    fn zoom_in_speed(&self) -> &f32 {
        &self.zoom_in_speed
    }
    fn zoom_in_speed_mut(&mut self) -> &mut f32 {
        &mut self.zoom_in_speed
    }
}

pub static WEAPONANIMATIONSETTINGSDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponAnimationSettingsData",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WeaponAnimationSettingsData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "KickbackFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WeaponAnimationSettingsData, kickback_factor),
            },
            FieldInfoData {
                name: "KickbackSpeedFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WeaponAnimationSettingsData, kickback_speed_factor),
            },
            FieldInfoData {
                name: "WeaponOffsetX",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WeaponAnimationSettingsData, weapon_offset_x),
            },
            FieldInfoData {
                name: "WeaponOffsetY",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WeaponAnimationSettingsData, weapon_offset_y),
            },
            FieldInfoData {
                name: "WeaponOffsetZ",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WeaponAnimationSettingsData, weapon_offset_z),
            },
            FieldInfoData {
                name: "ZoomOutSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WeaponAnimationSettingsData, zoom_out_speed),
            },
            FieldInfoData {
                name: "ZoomInSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WeaponAnimationSettingsData, zoom_in_speed),
            },
        ],
    }),
    array_type: Some(WEAPONANIMATIONSETTINGSDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for WeaponAnimationSettingsData {
    fn type_info(&self) -> &'static TypeInfo {
        WEAPONANIMATIONSETTINGSDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static WEAPONANIMATIONSETTINGSDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponAnimationSettingsData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("WeaponAnimationSettingsData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum SightType {
    #[default]
    SightType_None = 0,
    SightType_Canted = 1,
    SightType_Magnifier = 2,
}

pub static SIGHTTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SightType",
    flags: MemberInfoFlags::new(49429),
    module: "SoldierShared",
    data: TypeInfoData::Enum,
    array_type: Some(SIGHTTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SightType {
    fn type_info(&self) -> &'static TypeInfo {
        SIGHTTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SIGHTTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SightType-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SightType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WeaponOverrideData {
    pub _glacier_base: super::core::DataContainer,
    pub data: Option<Arc<Mutex<dyn super::core::DataContainerTrait>>>,
    pub values: Vec<WeaponOverrideValue>,
}

pub trait WeaponOverrideDataTrait: super::core::DataContainerTrait {
    fn data(&self) -> &Option<Arc<Mutex<dyn super::core::DataContainerTrait>>>;
    fn data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::DataContainerTrait>>>;
    fn values(&self) -> &Vec<WeaponOverrideValue>;
    fn values_mut(&mut self) -> &mut Vec<WeaponOverrideValue>;
}

impl WeaponOverrideDataTrait for WeaponOverrideData {
    fn data(&self) -> &Option<Arc<Mutex<dyn super::core::DataContainerTrait>>> {
        &self.data
    }
    fn data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::DataContainerTrait>>> {
        &mut self.data
    }
    fn values(&self) -> &Vec<WeaponOverrideValue> {
        &self.values
    }
    fn values_mut(&mut self) -> &mut Vec<WeaponOverrideValue> {
        &mut self.values
    }
}

impl super::core::DataContainerTrait for WeaponOverrideData {
}

pub static WEAPONOVERRIDEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponOverrideData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WeaponOverrideData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Data",
                flags: MemberInfoFlags::new(0),
                field_type: "DataContainer",
                rust_offset: offset_of!(WeaponOverrideData, data),
            },
            FieldInfoData {
                name: "Values",
                flags: MemberInfoFlags::new(144),
                field_type: "WeaponOverrideValue-Array",
                rust_offset: offset_of!(WeaponOverrideData, values),
            },
        ],
    }),
    array_type: Some(WEAPONOVERRIDEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WeaponOverrideData {
    fn type_info(&self) -> &'static TypeInfo {
        WEAPONOVERRIDEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WEAPONOVERRIDEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponOverrideData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("WeaponOverrideData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WeaponOverrideValue {
    pub value_type: WeaponOverrideValueType,
    pub value: f32,
}

pub trait WeaponOverrideValueTrait: TypeObject {
    fn value_type(&self) -> &WeaponOverrideValueType;
    fn value_type_mut(&mut self) -> &mut WeaponOverrideValueType;
    fn value(&self) -> &f32;
    fn value_mut(&mut self) -> &mut f32;
}

impl WeaponOverrideValueTrait for WeaponOverrideValue {
    fn value_type(&self) -> &WeaponOverrideValueType {
        &self.value_type
    }
    fn value_type_mut(&mut self) -> &mut WeaponOverrideValueType {
        &mut self.value_type
    }
    fn value(&self) -> &f32 {
        &self.value
    }
    fn value_mut(&mut self) -> &mut f32 {
        &mut self.value
    }
}

pub static WEAPONOVERRIDEVALUE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponOverrideValue",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WeaponOverrideValue as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ValueType",
                flags: MemberInfoFlags::new(0),
                field_type: "WeaponOverrideValueType",
                rust_offset: offset_of!(WeaponOverrideValue, value_type),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WeaponOverrideValue, value),
            },
        ],
    }),
    array_type: Some(WEAPONOVERRIDEVALUE_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for WeaponOverrideValue {
    fn type_info(&self) -> &'static TypeInfo {
        WEAPONOVERRIDEVALUE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static WEAPONOVERRIDEVALUE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponOverrideValue-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("WeaponOverrideValue"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum WeaponOverrideValueType {
    #[default]
    OverrideValue_BulletEntity_DistributeDamageOverTime = 0,
    OverrideValue_BulletEntity_StartDamage = 1,
    OverrideValue_BulletEntity_EndDamage = 2,
    OverrideValue_BulletEntity_DamageFalloffStartDistance = 3,
    OverrideValue_BulletEntity_DamageFalloffEndDistance = 4,
}

pub static WEAPONOVERRIDEVALUETYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponOverrideValueType",
    flags: MemberInfoFlags::new(49429),
    module: "SoldierShared",
    data: TypeInfoData::Enum,
    array_type: Some(WEAPONOVERRIDEVALUETYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for WeaponOverrideValueType {
    fn type_info(&self) -> &'static TypeInfo {
        WEAPONOVERRIDEVALUETYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static WEAPONOVERRIDEVALUETYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponOverrideValueType-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("WeaponOverrideValueType"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum QuickThrowTypeEnum {
    #[default]
    QttHand = 0,
    QttBag = 1,
}

pub static QUICKTHROWTYPEENUM_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "QuickThrowTypeEnum",
    flags: MemberInfoFlags::new(49429),
    module: "SoldierShared",
    data: TypeInfoData::Enum,
    array_type: Some(QUICKTHROWTYPEENUM_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for QuickThrowTypeEnum {
    fn type_info(&self) -> &'static TypeInfo {
        QUICKTHROWTYPEENUM_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static QUICKTHROWTYPEENUM_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "QuickThrowTypeEnum-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("QuickThrowTypeEnum"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WeaponEntityData {
    pub _glacier_base: super::entity::GameComponentEntityData,
    pub weapon_class: WeaponClassEnum,
    pub weapon_states: Vec<WeaponStateData>,
    pub weapon_firing: Option<Arc<Mutex<dyn super::weapon_shared::WeaponFiringDataTrait>>>,
    pub custom_weapon_type: Option<Arc<Mutex<dyn super::weapon_shared::WeaponDataTrait>>>,
    pub a_i_data: Option<Arc<Mutex<dyn super::gameplay_sim::GameAIWeaponDataTrait>>>,
}

pub trait WeaponEntityDataTrait: super::entity::GameComponentEntityDataTrait {
    fn weapon_class(&self) -> &WeaponClassEnum;
    fn weapon_class_mut(&mut self) -> &mut WeaponClassEnum;
    fn weapon_states(&self) -> &Vec<WeaponStateData>;
    fn weapon_states_mut(&mut self) -> &mut Vec<WeaponStateData>;
    fn weapon_firing(&self) -> &Option<Arc<Mutex<dyn super::weapon_shared::WeaponFiringDataTrait>>>;
    fn weapon_firing_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::weapon_shared::WeaponFiringDataTrait>>>;
    fn custom_weapon_type(&self) -> &Option<Arc<Mutex<dyn super::weapon_shared::WeaponDataTrait>>>;
    fn custom_weapon_type_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::weapon_shared::WeaponDataTrait>>>;
    fn a_i_data(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::GameAIWeaponDataTrait>>>;
    fn a_i_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::GameAIWeaponDataTrait>>>;
}

impl WeaponEntityDataTrait for WeaponEntityData {
    fn weapon_class(&self) -> &WeaponClassEnum {
        &self.weapon_class
    }
    fn weapon_class_mut(&mut self) -> &mut WeaponClassEnum {
        &mut self.weapon_class
    }
    fn weapon_states(&self) -> &Vec<WeaponStateData> {
        &self.weapon_states
    }
    fn weapon_states_mut(&mut self) -> &mut Vec<WeaponStateData> {
        &mut self.weapon_states
    }
    fn weapon_firing(&self) -> &Option<Arc<Mutex<dyn super::weapon_shared::WeaponFiringDataTrait>>> {
        &self.weapon_firing
    }
    fn weapon_firing_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::weapon_shared::WeaponFiringDataTrait>>> {
        &mut self.weapon_firing
    }
    fn custom_weapon_type(&self) -> &Option<Arc<Mutex<dyn super::weapon_shared::WeaponDataTrait>>> {
        &self.custom_weapon_type
    }
    fn custom_weapon_type_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::weapon_shared::WeaponDataTrait>>> {
        &mut self.custom_weapon_type
    }
    fn a_i_data(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::GameAIWeaponDataTrait>>> {
        &self.a_i_data
    }
    fn a_i_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::GameAIWeaponDataTrait>>> {
        &mut self.a_i_data
    }
}

impl super::entity::GameComponentEntityDataTrait for WeaponEntityData {
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::ComponentEntityDataTrait for WeaponEntityData {
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn part_bounding_boxes(&self) -> &Vec<super::core::AxisAlignedBox> {
        self._glacier_base.part_bounding_boxes()
    }
    fn part_bounding_boxes_mut(&mut self) -> &mut Vec<super::core::AxisAlignedBox> {
        self._glacier_base.part_bounding_boxes_mut()
    }
    fn client_runtime_component_count(&self) -> &u8 {
        self._glacier_base.client_runtime_component_count()
    }
    fn client_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_component_count_mut()
    }
    fn server_runtime_component_count(&self) -> &u8 {
        self._glacier_base.server_runtime_component_count()
    }
    fn server_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_component_count_mut()
    }
    fn client_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.client_runtime_transformation_count()
    }
    fn client_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_transformation_count_mut()
    }
    fn server_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.server_runtime_transformation_count()
    }
    fn server_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_transformation_count_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for WeaponEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for WeaponEntityData {
}

impl super::entity::GameObjectDataTrait for WeaponEntityData {
}

impl super::core::DataBusPeerTrait for WeaponEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for WeaponEntityData {
}

impl super::core::DataContainerTrait for WeaponEntityData {
}

pub static WEAPONENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponEntityData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WeaponEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "WeaponClass",
                flags: MemberInfoFlags::new(0),
                field_type: "WeaponClassEnum",
                rust_offset: offset_of!(WeaponEntityData, weapon_class),
            },
            FieldInfoData {
                name: "WeaponStates",
                flags: MemberInfoFlags::new(144),
                field_type: "WeaponStateData-Array",
                rust_offset: offset_of!(WeaponEntityData, weapon_states),
            },
            FieldInfoData {
                name: "WeaponFiring",
                flags: MemberInfoFlags::new(0),
                field_type: "WeaponFiringData",
                rust_offset: offset_of!(WeaponEntityData, weapon_firing),
            },
            FieldInfoData {
                name: "CustomWeaponType",
                flags: MemberInfoFlags::new(0),
                field_type: "WeaponData",
                rust_offset: offset_of!(WeaponEntityData, custom_weapon_type),
            },
            FieldInfoData {
                name: "AIData",
                flags: MemberInfoFlags::new(0),
                field_type: "GameAIWeaponData",
                rust_offset: offset_of!(WeaponEntityData, a_i_data),
            },
        ],
    }),
    array_type: Some(WEAPONENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for WeaponEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        WEAPONENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WEAPONENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("WeaponEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoldierWeaponsPreviewComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub weapon_skeleton: Option<Arc<Mutex<dyn super::entity::SkeletonAssetTrait>>>,
    pub visible: bool,
    pub soldier_weapon_unlock: Option<Arc<Mutex<dyn SoldierWeaponUnlockAssetTrait>>>,
    pub soldier_customization: Option<Arc<Mutex<dyn SoldierCustomizationAssetTrait>>>,
    pub animated_static_weapon_binding: AnimatedStaticWeaponBinding,
    pub animated_weapon_binding: AnimatedWeaponBinding,
    pub animated3p_only_weapon_binding: Animated3pOnlyWeaponBinding,
}

pub trait SoldierWeaponsPreviewComponentDataTrait: super::entity::GameComponentDataTrait {
    fn weapon_skeleton(&self) -> &Option<Arc<Mutex<dyn super::entity::SkeletonAssetTrait>>>;
    fn weapon_skeleton_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::SkeletonAssetTrait>>>;
    fn visible(&self) -> &bool;
    fn visible_mut(&mut self) -> &mut bool;
    fn soldier_weapon_unlock(&self) -> &Option<Arc<Mutex<dyn SoldierWeaponUnlockAssetTrait>>>;
    fn soldier_weapon_unlock_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoldierWeaponUnlockAssetTrait>>>;
    fn soldier_customization(&self) -> &Option<Arc<Mutex<dyn SoldierCustomizationAssetTrait>>>;
    fn soldier_customization_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoldierCustomizationAssetTrait>>>;
    fn animated_static_weapon_binding(&self) -> &AnimatedStaticWeaponBinding;
    fn animated_static_weapon_binding_mut(&mut self) -> &mut AnimatedStaticWeaponBinding;
    fn animated_weapon_binding(&self) -> &AnimatedWeaponBinding;
    fn animated_weapon_binding_mut(&mut self) -> &mut AnimatedWeaponBinding;
    fn animated3p_only_weapon_binding(&self) -> &Animated3pOnlyWeaponBinding;
    fn animated3p_only_weapon_binding_mut(&mut self) -> &mut Animated3pOnlyWeaponBinding;
}

impl SoldierWeaponsPreviewComponentDataTrait for SoldierWeaponsPreviewComponentData {
    fn weapon_skeleton(&self) -> &Option<Arc<Mutex<dyn super::entity::SkeletonAssetTrait>>> {
        &self.weapon_skeleton
    }
    fn weapon_skeleton_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::SkeletonAssetTrait>>> {
        &mut self.weapon_skeleton
    }
    fn visible(&self) -> &bool {
        &self.visible
    }
    fn visible_mut(&mut self) -> &mut bool {
        &mut self.visible
    }
    fn soldier_weapon_unlock(&self) -> &Option<Arc<Mutex<dyn SoldierWeaponUnlockAssetTrait>>> {
        &self.soldier_weapon_unlock
    }
    fn soldier_weapon_unlock_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoldierWeaponUnlockAssetTrait>>> {
        &mut self.soldier_weapon_unlock
    }
    fn soldier_customization(&self) -> &Option<Arc<Mutex<dyn SoldierCustomizationAssetTrait>>> {
        &self.soldier_customization
    }
    fn soldier_customization_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoldierCustomizationAssetTrait>>> {
        &mut self.soldier_customization
    }
    fn animated_static_weapon_binding(&self) -> &AnimatedStaticWeaponBinding {
        &self.animated_static_weapon_binding
    }
    fn animated_static_weapon_binding_mut(&mut self) -> &mut AnimatedStaticWeaponBinding {
        &mut self.animated_static_weapon_binding
    }
    fn animated_weapon_binding(&self) -> &AnimatedWeaponBinding {
        &self.animated_weapon_binding
    }
    fn animated_weapon_binding_mut(&mut self) -> &mut AnimatedWeaponBinding {
        &mut self.animated_weapon_binding
    }
    fn animated3p_only_weapon_binding(&self) -> &Animated3pOnlyWeaponBinding {
        &self.animated3p_only_weapon_binding
    }
    fn animated3p_only_weapon_binding_mut(&mut self) -> &mut Animated3pOnlyWeaponBinding {
        &mut self.animated3p_only_weapon_binding
    }
}

impl super::entity::GameComponentDataTrait for SoldierWeaponsPreviewComponentData {
}

impl super::entity::ComponentDataTrait for SoldierWeaponsPreviewComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for SoldierWeaponsPreviewComponentData {
}

impl super::core::DataBusPeerTrait for SoldierWeaponsPreviewComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SoldierWeaponsPreviewComponentData {
}

impl super::core::DataContainerTrait for SoldierWeaponsPreviewComponentData {
}

pub static SOLDIERWEAPONSPREVIEWCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierWeaponsPreviewComponentData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierWeaponsPreviewComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "WeaponSkeleton",
                flags: MemberInfoFlags::new(0),
                field_type: "SkeletonAsset",
                rust_offset: offset_of!(SoldierWeaponsPreviewComponentData, weapon_skeleton),
            },
            FieldInfoData {
                name: "Visible",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierWeaponsPreviewComponentData, visible),
            },
            FieldInfoData {
                name: "SoldierWeaponUnlock",
                flags: MemberInfoFlags::new(0),
                field_type: "SoldierWeaponUnlockAsset",
                rust_offset: offset_of!(SoldierWeaponsPreviewComponentData, soldier_weapon_unlock),
            },
            FieldInfoData {
                name: "SoldierCustomization",
                flags: MemberInfoFlags::new(0),
                field_type: "SoldierCustomizationAsset",
                rust_offset: offset_of!(SoldierWeaponsPreviewComponentData, soldier_customization),
            },
            FieldInfoData {
                name: "AnimatedStaticWeaponBinding",
                flags: MemberInfoFlags::new(0),
                field_type: "AnimatedStaticWeaponBinding",
                rust_offset: offset_of!(SoldierWeaponsPreviewComponentData, animated_static_weapon_binding),
            },
            FieldInfoData {
                name: "AnimatedWeaponBinding",
                flags: MemberInfoFlags::new(0),
                field_type: "AnimatedWeaponBinding",
                rust_offset: offset_of!(SoldierWeaponsPreviewComponentData, animated_weapon_binding),
            },
            FieldInfoData {
                name: "Animated3pOnlyWeaponBinding",
                flags: MemberInfoFlags::new(0),
                field_type: "Animated3pOnlyWeaponBinding",
                rust_offset: offset_of!(SoldierWeaponsPreviewComponentData, animated3p_only_weapon_binding),
            },
        ],
    }),
    array_type: Some(SOLDIERWEAPONSPREVIEWCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SoldierWeaponsPreviewComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERWEAPONSPREVIEWCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOLDIERWEAPONSPREVIEWCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierWeaponsPreviewComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SoldierWeaponsPreviewComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoldierWeaponsComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub primary_weapon_id: i32,
    pub default_aiming_controller: Option<Arc<Mutex<dyn SoldierAimingSimulationDataTrait>>>,
    pub use_external_aim_dir: bool,
    pub aim_dir: super::core::LinearTransform,
    pub animated_static_weapon_binding: AnimatedStaticWeaponBinding,
    pub animated_weapon_binding: AnimatedWeaponBinding,
    pub default_weapon_animation: super::ant::AntRef,
    pub animated1p_only_weapon_binding: Animated1pOnlyWeaponBinding,
    pub animated3p_only_weapon_binding: Animated3pOnlyWeaponBinding,
    pub anim_base_set_to_ant_weapon_type_conversion: Vec<AnimBaseSetToAntWeaponType>,
    pub weapon_skeleton: Option<Arc<Mutex<dyn super::entity::SkeletonAssetTrait>>>,
    pub unlimited_ammo: bool,
    pub unlimited_mags: bool,
    pub ammo_clip_increase_multiplier: f32,
    pub grenade_increase: i32,
    pub underslung_grenade_increase: i32,
    pub explosive_increase_multiplier: f32,
    pub suppression_value: f32,
    pub drop_weapon_pickup: Option<Arc<Mutex<dyn PickupEntityAssetTrait>>>,
    pub is_owned_by_a_i: bool,
    pub supports_weapon_prediction_and_correction: bool,
}

pub trait SoldierWeaponsComponentDataTrait: super::entity::GameComponentDataTrait {
    fn primary_weapon_id(&self) -> &i32;
    fn primary_weapon_id_mut(&mut self) -> &mut i32;
    fn default_aiming_controller(&self) -> &Option<Arc<Mutex<dyn SoldierAimingSimulationDataTrait>>>;
    fn default_aiming_controller_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoldierAimingSimulationDataTrait>>>;
    fn use_external_aim_dir(&self) -> &bool;
    fn use_external_aim_dir_mut(&mut self) -> &mut bool;
    fn aim_dir(&self) -> &super::core::LinearTransform;
    fn aim_dir_mut(&mut self) -> &mut super::core::LinearTransform;
    fn animated_static_weapon_binding(&self) -> &AnimatedStaticWeaponBinding;
    fn animated_static_weapon_binding_mut(&mut self) -> &mut AnimatedStaticWeaponBinding;
    fn animated_weapon_binding(&self) -> &AnimatedWeaponBinding;
    fn animated_weapon_binding_mut(&mut self) -> &mut AnimatedWeaponBinding;
    fn default_weapon_animation(&self) -> &super::ant::AntRef;
    fn default_weapon_animation_mut(&mut self) -> &mut super::ant::AntRef;
    fn animated1p_only_weapon_binding(&self) -> &Animated1pOnlyWeaponBinding;
    fn animated1p_only_weapon_binding_mut(&mut self) -> &mut Animated1pOnlyWeaponBinding;
    fn animated3p_only_weapon_binding(&self) -> &Animated3pOnlyWeaponBinding;
    fn animated3p_only_weapon_binding_mut(&mut self) -> &mut Animated3pOnlyWeaponBinding;
    fn anim_base_set_to_ant_weapon_type_conversion(&self) -> &Vec<AnimBaseSetToAntWeaponType>;
    fn anim_base_set_to_ant_weapon_type_conversion_mut(&mut self) -> &mut Vec<AnimBaseSetToAntWeaponType>;
    fn weapon_skeleton(&self) -> &Option<Arc<Mutex<dyn super::entity::SkeletonAssetTrait>>>;
    fn weapon_skeleton_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::SkeletonAssetTrait>>>;
    fn unlimited_ammo(&self) -> &bool;
    fn unlimited_ammo_mut(&mut self) -> &mut bool;
    fn unlimited_mags(&self) -> &bool;
    fn unlimited_mags_mut(&mut self) -> &mut bool;
    fn ammo_clip_increase_multiplier(&self) -> &f32;
    fn ammo_clip_increase_multiplier_mut(&mut self) -> &mut f32;
    fn grenade_increase(&self) -> &i32;
    fn grenade_increase_mut(&mut self) -> &mut i32;
    fn underslung_grenade_increase(&self) -> &i32;
    fn underslung_grenade_increase_mut(&mut self) -> &mut i32;
    fn explosive_increase_multiplier(&self) -> &f32;
    fn explosive_increase_multiplier_mut(&mut self) -> &mut f32;
    fn suppression_value(&self) -> &f32;
    fn suppression_value_mut(&mut self) -> &mut f32;
    fn drop_weapon_pickup(&self) -> &Option<Arc<Mutex<dyn PickupEntityAssetTrait>>>;
    fn drop_weapon_pickup_mut(&mut self) -> &mut Option<Arc<Mutex<dyn PickupEntityAssetTrait>>>;
    fn is_owned_by_a_i(&self) -> &bool;
    fn is_owned_by_a_i_mut(&mut self) -> &mut bool;
    fn supports_weapon_prediction_and_correction(&self) -> &bool;
    fn supports_weapon_prediction_and_correction_mut(&mut self) -> &mut bool;
}

impl SoldierWeaponsComponentDataTrait for SoldierWeaponsComponentData {
    fn primary_weapon_id(&self) -> &i32 {
        &self.primary_weapon_id
    }
    fn primary_weapon_id_mut(&mut self) -> &mut i32 {
        &mut self.primary_weapon_id
    }
    fn default_aiming_controller(&self) -> &Option<Arc<Mutex<dyn SoldierAimingSimulationDataTrait>>> {
        &self.default_aiming_controller
    }
    fn default_aiming_controller_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoldierAimingSimulationDataTrait>>> {
        &mut self.default_aiming_controller
    }
    fn use_external_aim_dir(&self) -> &bool {
        &self.use_external_aim_dir
    }
    fn use_external_aim_dir_mut(&mut self) -> &mut bool {
        &mut self.use_external_aim_dir
    }
    fn aim_dir(&self) -> &super::core::LinearTransform {
        &self.aim_dir
    }
    fn aim_dir_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.aim_dir
    }
    fn animated_static_weapon_binding(&self) -> &AnimatedStaticWeaponBinding {
        &self.animated_static_weapon_binding
    }
    fn animated_static_weapon_binding_mut(&mut self) -> &mut AnimatedStaticWeaponBinding {
        &mut self.animated_static_weapon_binding
    }
    fn animated_weapon_binding(&self) -> &AnimatedWeaponBinding {
        &self.animated_weapon_binding
    }
    fn animated_weapon_binding_mut(&mut self) -> &mut AnimatedWeaponBinding {
        &mut self.animated_weapon_binding
    }
    fn default_weapon_animation(&self) -> &super::ant::AntRef {
        &self.default_weapon_animation
    }
    fn default_weapon_animation_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.default_weapon_animation
    }
    fn animated1p_only_weapon_binding(&self) -> &Animated1pOnlyWeaponBinding {
        &self.animated1p_only_weapon_binding
    }
    fn animated1p_only_weapon_binding_mut(&mut self) -> &mut Animated1pOnlyWeaponBinding {
        &mut self.animated1p_only_weapon_binding
    }
    fn animated3p_only_weapon_binding(&self) -> &Animated3pOnlyWeaponBinding {
        &self.animated3p_only_weapon_binding
    }
    fn animated3p_only_weapon_binding_mut(&mut self) -> &mut Animated3pOnlyWeaponBinding {
        &mut self.animated3p_only_weapon_binding
    }
    fn anim_base_set_to_ant_weapon_type_conversion(&self) -> &Vec<AnimBaseSetToAntWeaponType> {
        &self.anim_base_set_to_ant_weapon_type_conversion
    }
    fn anim_base_set_to_ant_weapon_type_conversion_mut(&mut self) -> &mut Vec<AnimBaseSetToAntWeaponType> {
        &mut self.anim_base_set_to_ant_weapon_type_conversion
    }
    fn weapon_skeleton(&self) -> &Option<Arc<Mutex<dyn super::entity::SkeletonAssetTrait>>> {
        &self.weapon_skeleton
    }
    fn weapon_skeleton_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::SkeletonAssetTrait>>> {
        &mut self.weapon_skeleton
    }
    fn unlimited_ammo(&self) -> &bool {
        &self.unlimited_ammo
    }
    fn unlimited_ammo_mut(&mut self) -> &mut bool {
        &mut self.unlimited_ammo
    }
    fn unlimited_mags(&self) -> &bool {
        &self.unlimited_mags
    }
    fn unlimited_mags_mut(&mut self) -> &mut bool {
        &mut self.unlimited_mags
    }
    fn ammo_clip_increase_multiplier(&self) -> &f32 {
        &self.ammo_clip_increase_multiplier
    }
    fn ammo_clip_increase_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.ammo_clip_increase_multiplier
    }
    fn grenade_increase(&self) -> &i32 {
        &self.grenade_increase
    }
    fn grenade_increase_mut(&mut self) -> &mut i32 {
        &mut self.grenade_increase
    }
    fn underslung_grenade_increase(&self) -> &i32 {
        &self.underslung_grenade_increase
    }
    fn underslung_grenade_increase_mut(&mut self) -> &mut i32 {
        &mut self.underslung_grenade_increase
    }
    fn explosive_increase_multiplier(&self) -> &f32 {
        &self.explosive_increase_multiplier
    }
    fn explosive_increase_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.explosive_increase_multiplier
    }
    fn suppression_value(&self) -> &f32 {
        &self.suppression_value
    }
    fn suppression_value_mut(&mut self) -> &mut f32 {
        &mut self.suppression_value
    }
    fn drop_weapon_pickup(&self) -> &Option<Arc<Mutex<dyn PickupEntityAssetTrait>>> {
        &self.drop_weapon_pickup
    }
    fn drop_weapon_pickup_mut(&mut self) -> &mut Option<Arc<Mutex<dyn PickupEntityAssetTrait>>> {
        &mut self.drop_weapon_pickup
    }
    fn is_owned_by_a_i(&self) -> &bool {
        &self.is_owned_by_a_i
    }
    fn is_owned_by_a_i_mut(&mut self) -> &mut bool {
        &mut self.is_owned_by_a_i
    }
    fn supports_weapon_prediction_and_correction(&self) -> &bool {
        &self.supports_weapon_prediction_and_correction
    }
    fn supports_weapon_prediction_and_correction_mut(&mut self) -> &mut bool {
        &mut self.supports_weapon_prediction_and_correction
    }
}

impl super::entity::GameComponentDataTrait for SoldierWeaponsComponentData {
}

impl super::entity::ComponentDataTrait for SoldierWeaponsComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for SoldierWeaponsComponentData {
}

impl super::core::DataBusPeerTrait for SoldierWeaponsComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SoldierWeaponsComponentData {
}

impl super::core::DataContainerTrait for SoldierWeaponsComponentData {
}

pub static SOLDIERWEAPONSCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierWeaponsComponentData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierWeaponsComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PrimaryWeaponId",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SoldierWeaponsComponentData, primary_weapon_id),
            },
            FieldInfoData {
                name: "DefaultAimingController",
                flags: MemberInfoFlags::new(0),
                field_type: "SoldierAimingSimulationData",
                rust_offset: offset_of!(SoldierWeaponsComponentData, default_aiming_controller),
            },
            FieldInfoData {
                name: "UseExternalAimDir",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierWeaponsComponentData, use_external_aim_dir),
            },
            FieldInfoData {
                name: "AimDir",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(SoldierWeaponsComponentData, aim_dir),
            },
            FieldInfoData {
                name: "AnimatedStaticWeaponBinding",
                flags: MemberInfoFlags::new(0),
                field_type: "AnimatedStaticWeaponBinding",
                rust_offset: offset_of!(SoldierWeaponsComponentData, animated_static_weapon_binding),
            },
            FieldInfoData {
                name: "AnimatedWeaponBinding",
                flags: MemberInfoFlags::new(0),
                field_type: "AnimatedWeaponBinding",
                rust_offset: offset_of!(SoldierWeaponsComponentData, animated_weapon_binding),
            },
            FieldInfoData {
                name: "DefaultWeaponAnimation",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(SoldierWeaponsComponentData, default_weapon_animation),
            },
            FieldInfoData {
                name: "Animated1pOnlyWeaponBinding",
                flags: MemberInfoFlags::new(0),
                field_type: "Animated1pOnlyWeaponBinding",
                rust_offset: offset_of!(SoldierWeaponsComponentData, animated1p_only_weapon_binding),
            },
            FieldInfoData {
                name: "Animated3pOnlyWeaponBinding",
                flags: MemberInfoFlags::new(0),
                field_type: "Animated3pOnlyWeaponBinding",
                rust_offset: offset_of!(SoldierWeaponsComponentData, animated3p_only_weapon_binding),
            },
            FieldInfoData {
                name: "AnimBaseSetToAntWeaponTypeConversion",
                flags: MemberInfoFlags::new(144),
                field_type: "AnimBaseSetToAntWeaponType-Array",
                rust_offset: offset_of!(SoldierWeaponsComponentData, anim_base_set_to_ant_weapon_type_conversion),
            },
            FieldInfoData {
                name: "WeaponSkeleton",
                flags: MemberInfoFlags::new(0),
                field_type: "SkeletonAsset",
                rust_offset: offset_of!(SoldierWeaponsComponentData, weapon_skeleton),
            },
            FieldInfoData {
                name: "UnlimitedAmmo",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierWeaponsComponentData, unlimited_ammo),
            },
            FieldInfoData {
                name: "UnlimitedMags",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierWeaponsComponentData, unlimited_mags),
            },
            FieldInfoData {
                name: "AmmoClipIncreaseMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierWeaponsComponentData, ammo_clip_increase_multiplier),
            },
            FieldInfoData {
                name: "GrenadeIncrease",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SoldierWeaponsComponentData, grenade_increase),
            },
            FieldInfoData {
                name: "UnderslungGrenadeIncrease",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SoldierWeaponsComponentData, underslung_grenade_increase),
            },
            FieldInfoData {
                name: "ExplosiveIncreaseMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierWeaponsComponentData, explosive_increase_multiplier),
            },
            FieldInfoData {
                name: "SuppressionValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierWeaponsComponentData, suppression_value),
            },
            FieldInfoData {
                name: "DropWeaponPickup",
                flags: MemberInfoFlags::new(0),
                field_type: "PickupEntityAsset",
                rust_offset: offset_of!(SoldierWeaponsComponentData, drop_weapon_pickup),
            },
            FieldInfoData {
                name: "IsOwnedByAI",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierWeaponsComponentData, is_owned_by_a_i),
            },
            FieldInfoData {
                name: "SupportsWeaponPredictionAndCorrection",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierWeaponsComponentData, supports_weapon_prediction_and_correction),
            },
        ],
    }),
    array_type: Some(SOLDIERWEAPONSCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SoldierWeaponsComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERWEAPONSCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOLDIERWEAPONSCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierWeaponsComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SoldierWeaponsComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AnimBaseSetToAntWeaponType {
    pub anim_base_set: WeaponAnimBaseSetEnum,
    pub ant_weapon_type: i32,
}

pub trait AnimBaseSetToAntWeaponTypeTrait: TypeObject {
    fn anim_base_set(&self) -> &WeaponAnimBaseSetEnum;
    fn anim_base_set_mut(&mut self) -> &mut WeaponAnimBaseSetEnum;
    fn ant_weapon_type(&self) -> &i32;
    fn ant_weapon_type_mut(&mut self) -> &mut i32;
}

impl AnimBaseSetToAntWeaponTypeTrait for AnimBaseSetToAntWeaponType {
    fn anim_base_set(&self) -> &WeaponAnimBaseSetEnum {
        &self.anim_base_set
    }
    fn anim_base_set_mut(&mut self) -> &mut WeaponAnimBaseSetEnum {
        &mut self.anim_base_set
    }
    fn ant_weapon_type(&self) -> &i32 {
        &self.ant_weapon_type
    }
    fn ant_weapon_type_mut(&mut self) -> &mut i32 {
        &mut self.ant_weapon_type
    }
}

pub static ANIMBASESETTOANTWEAPONTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimBaseSetToAntWeaponType",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AnimBaseSetToAntWeaponType as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AnimBaseSet",
                flags: MemberInfoFlags::new(0),
                field_type: "WeaponAnimBaseSetEnum",
                rust_offset: offset_of!(AnimBaseSetToAntWeaponType, anim_base_set),
            },
            FieldInfoData {
                name: "AntWeaponType",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AnimBaseSetToAntWeaponType, ant_weapon_type),
            },
        ],
    }),
    array_type: Some(ANIMBASESETTOANTWEAPONTYPE_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AnimBaseSetToAntWeaponType {
    fn type_info(&self) -> &'static TypeInfo {
        ANIMBASESETTOANTWEAPONTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ANIMBASESETTOANTWEAPONTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimBaseSetToAntWeaponType-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("AnimBaseSetToAntWeaponType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PickupSettingsData {
    pub mesh_render_offset: super::core::Vec3,
    pub mesh_render_rotation: super::core::Vec3,
}

pub trait PickupSettingsDataTrait: TypeObject {
    fn mesh_render_offset(&self) -> &super::core::Vec3;
    fn mesh_render_offset_mut(&mut self) -> &mut super::core::Vec3;
    fn mesh_render_rotation(&self) -> &super::core::Vec3;
    fn mesh_render_rotation_mut(&mut self) -> &mut super::core::Vec3;
}

impl PickupSettingsDataTrait for PickupSettingsData {
    fn mesh_render_offset(&self) -> &super::core::Vec3 {
        &self.mesh_render_offset
    }
    fn mesh_render_offset_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.mesh_render_offset
    }
    fn mesh_render_rotation(&self) -> &super::core::Vec3 {
        &self.mesh_render_rotation
    }
    fn mesh_render_rotation_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.mesh_render_rotation
    }
}

pub static PICKUPSETTINGSDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PickupSettingsData",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PickupSettingsData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MeshRenderOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(PickupSettingsData, mesh_render_offset),
            },
            FieldInfoData {
                name: "MeshRenderRotation",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(PickupSettingsData, mesh_render_rotation),
            },
        ],
    }),
    array_type: Some(PICKUPSETTINGSDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PickupSettingsData {
    fn type_info(&self) -> &'static TypeInfo {
        PICKUPSETTINGSDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static PICKUPSETTINGSDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PickupSettingsData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("PickupSettingsData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum WeaponClassEnum {
    #[default]
    wc12gauge = 0,
    wc338Magnum = 1,
    wc357Magnum = 2,
    wc44Magnum = 3,
    wc45cal = 4,
    wc46x30mm = 5,
    wc50cal = 6,
    wc545x45mmWP = 7,
    wc556x45mmNATO = 8,
    wc57x28mm = 9,
    wc58x42mm = 10,
    wc762x39mmWP = 11,
    wc762x51mmNATO = 12,
    wc762x54mmR = 13,
    wc9x19mm = 14,
    wc9x39mm = 15,
    wcAssault = 16,
    wcShotgun = 17,
    wcSmg = 18,
    wcLmg = 19,
    wcSniper = 20,
    wcUgl = 21,
    wcHgr = 22,
    wcAt = 23,
    wcATMine = 24,
    wcC4 = 25,
    wcAutoInjector = 26,
    wcKnife = 27,
    wcLaserDesignator = 28,
    wcLaserPainter = 29,
    wcMedKit = 30,
    wcMortarStrike = 31,
    wcPowerTool = 32,
    wcTracerDart = 33,
    wcRadioBeacon = 34,
    wcEodBot = 35,
    wcReconMav = 36,
    wcUGS = 37,
    wcUnarmed = 38,
    wcRiotBaton = 39,
    wcCount = 40,
    wcNone = 41,
}

pub static WEAPONCLASSENUM_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponClassEnum",
    flags: MemberInfoFlags::new(49429),
    module: "SoldierShared",
    data: TypeInfoData::Enum,
    array_type: Some(WEAPONCLASSENUM_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for WeaponClassEnum {
    fn type_info(&self) -> &'static TypeInfo {
        WEAPONCLASSENUM_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static WEAPONCLASSENUM_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponClassEnum-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("WeaponClassEnum"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum WeaponAnimBaseSetEnum {
    #[default]
    wabsRif = 0,
    wabsPstl = 1,
    wabsHgr = 2,
    wabsAT = 3,
    wabsShg = 4,
    wabsLMG = 5,
    wabsBag = 6,
    wabsSnp = 7,
    wabsCount = 8,
    wabsNone = 9,
}

pub static WEAPONANIMBASESETENUM_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponAnimBaseSetEnum",
    flags: MemberInfoFlags::new(49429),
    module: "SoldierShared",
    data: TypeInfoData::Enum,
    array_type: Some(WEAPONANIMBASESETENUM_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for WeaponAnimBaseSetEnum {
    fn type_info(&self) -> &'static TypeInfo {
        WEAPONANIMBASESETENUM_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static WEAPONANIMBASESETENUM_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponAnimBaseSetEnum-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("WeaponAnimBaseSetEnum"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WeaponStateData {
    pub referenced_asset_hashes: Vec<u32>,
    pub bone_fake_physics: Vec<Option<Arc<Mutex<dyn super::game_shared::BoneFakePhysicsDataTrait>>>>,
    pub weapon_mesh3p: Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>>,
    pub mesh3p: Option<Arc<Mutex<dyn super::render::SkinnedMeshAssetTrait>>>,
    pub weapon: super::ant::AntRef,
    pub weapon3p: super::ant::AntRef,
    pub zoom_mesh_transition_factor: f32,
    pub zoom_scale_factor: f32,
    pub zoom_in_out_mesh_transition_factors: Vec<f32>,
    pub keep_aiming_time: f32,
    pub always_aim_head: bool,
    pub animated_fire_type: AnimatedFireEnum,
    pub animated_aiming_type: AnimatedAimingEnum,
    pub is_one_handed: bool,
    pub play_deploy_after_fire: bool,
    pub skip_deploy_animation: bool,
    pub skip_reload_animation: bool,
    pub skip_fire_animation: bool,
    pub hide_projectile_after_fire_time: f32,
    pub projectile_bone_name: String,
    pub un_deploy_speed: f32,
    pub deploy_speed: f32,
    pub mesh3p_transforms: super::core::SparseTransformArray,
}

pub trait WeaponStateDataTrait: TypeObject {
    fn referenced_asset_hashes(&self) -> &Vec<u32>;
    fn referenced_asset_hashes_mut(&mut self) -> &mut Vec<u32>;
    fn bone_fake_physics(&self) -> &Vec<Option<Arc<Mutex<dyn super::game_shared::BoneFakePhysicsDataTrait>>>>;
    fn bone_fake_physics_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::game_shared::BoneFakePhysicsDataTrait>>>>;
    fn weapon_mesh3p(&self) -> &Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>>;
    fn weapon_mesh3p_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>>;
    fn mesh3p(&self) -> &Option<Arc<Mutex<dyn super::render::SkinnedMeshAssetTrait>>>;
    fn mesh3p_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render::SkinnedMeshAssetTrait>>>;
    fn weapon(&self) -> &super::ant::AntRef;
    fn weapon_mut(&mut self) -> &mut super::ant::AntRef;
    fn weapon3p(&self) -> &super::ant::AntRef;
    fn weapon3p_mut(&mut self) -> &mut super::ant::AntRef;
    fn zoom_mesh_transition_factor(&self) -> &f32;
    fn zoom_mesh_transition_factor_mut(&mut self) -> &mut f32;
    fn zoom_scale_factor(&self) -> &f32;
    fn zoom_scale_factor_mut(&mut self) -> &mut f32;
    fn zoom_in_out_mesh_transition_factors(&self) -> &Vec<f32>;
    fn zoom_in_out_mesh_transition_factors_mut(&mut self) -> &mut Vec<f32>;
    fn keep_aiming_time(&self) -> &f32;
    fn keep_aiming_time_mut(&mut self) -> &mut f32;
    fn always_aim_head(&self) -> &bool;
    fn always_aim_head_mut(&mut self) -> &mut bool;
    fn animated_fire_type(&self) -> &AnimatedFireEnum;
    fn animated_fire_type_mut(&mut self) -> &mut AnimatedFireEnum;
    fn animated_aiming_type(&self) -> &AnimatedAimingEnum;
    fn animated_aiming_type_mut(&mut self) -> &mut AnimatedAimingEnum;
    fn is_one_handed(&self) -> &bool;
    fn is_one_handed_mut(&mut self) -> &mut bool;
    fn play_deploy_after_fire(&self) -> &bool;
    fn play_deploy_after_fire_mut(&mut self) -> &mut bool;
    fn skip_deploy_animation(&self) -> &bool;
    fn skip_deploy_animation_mut(&mut self) -> &mut bool;
    fn skip_reload_animation(&self) -> &bool;
    fn skip_reload_animation_mut(&mut self) -> &mut bool;
    fn skip_fire_animation(&self) -> &bool;
    fn skip_fire_animation_mut(&mut self) -> &mut bool;
    fn hide_projectile_after_fire_time(&self) -> &f32;
    fn hide_projectile_after_fire_time_mut(&mut self) -> &mut f32;
    fn projectile_bone_name(&self) -> &String;
    fn projectile_bone_name_mut(&mut self) -> &mut String;
    fn un_deploy_speed(&self) -> &f32;
    fn un_deploy_speed_mut(&mut self) -> &mut f32;
    fn deploy_speed(&self) -> &f32;
    fn deploy_speed_mut(&mut self) -> &mut f32;
    fn mesh3p_transforms(&self) -> &super::core::SparseTransformArray;
    fn mesh3p_transforms_mut(&mut self) -> &mut super::core::SparseTransformArray;
}

impl WeaponStateDataTrait for WeaponStateData {
    fn referenced_asset_hashes(&self) -> &Vec<u32> {
        &self.referenced_asset_hashes
    }
    fn referenced_asset_hashes_mut(&mut self) -> &mut Vec<u32> {
        &mut self.referenced_asset_hashes
    }
    fn bone_fake_physics(&self) -> &Vec<Option<Arc<Mutex<dyn super::game_shared::BoneFakePhysicsDataTrait>>>> {
        &self.bone_fake_physics
    }
    fn bone_fake_physics_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::game_shared::BoneFakePhysicsDataTrait>>>> {
        &mut self.bone_fake_physics
    }
    fn weapon_mesh3p(&self) -> &Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>> {
        &self.weapon_mesh3p
    }
    fn weapon_mesh3p_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>> {
        &mut self.weapon_mesh3p
    }
    fn mesh3p(&self) -> &Option<Arc<Mutex<dyn super::render::SkinnedMeshAssetTrait>>> {
        &self.mesh3p
    }
    fn mesh3p_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render::SkinnedMeshAssetTrait>>> {
        &mut self.mesh3p
    }
    fn weapon(&self) -> &super::ant::AntRef {
        &self.weapon
    }
    fn weapon_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.weapon
    }
    fn weapon3p(&self) -> &super::ant::AntRef {
        &self.weapon3p
    }
    fn weapon3p_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.weapon3p
    }
    fn zoom_mesh_transition_factor(&self) -> &f32 {
        &self.zoom_mesh_transition_factor
    }
    fn zoom_mesh_transition_factor_mut(&mut self) -> &mut f32 {
        &mut self.zoom_mesh_transition_factor
    }
    fn zoom_scale_factor(&self) -> &f32 {
        &self.zoom_scale_factor
    }
    fn zoom_scale_factor_mut(&mut self) -> &mut f32 {
        &mut self.zoom_scale_factor
    }
    fn zoom_in_out_mesh_transition_factors(&self) -> &Vec<f32> {
        &self.zoom_in_out_mesh_transition_factors
    }
    fn zoom_in_out_mesh_transition_factors_mut(&mut self) -> &mut Vec<f32> {
        &mut self.zoom_in_out_mesh_transition_factors
    }
    fn keep_aiming_time(&self) -> &f32 {
        &self.keep_aiming_time
    }
    fn keep_aiming_time_mut(&mut self) -> &mut f32 {
        &mut self.keep_aiming_time
    }
    fn always_aim_head(&self) -> &bool {
        &self.always_aim_head
    }
    fn always_aim_head_mut(&mut self) -> &mut bool {
        &mut self.always_aim_head
    }
    fn animated_fire_type(&self) -> &AnimatedFireEnum {
        &self.animated_fire_type
    }
    fn animated_fire_type_mut(&mut self) -> &mut AnimatedFireEnum {
        &mut self.animated_fire_type
    }
    fn animated_aiming_type(&self) -> &AnimatedAimingEnum {
        &self.animated_aiming_type
    }
    fn animated_aiming_type_mut(&mut self) -> &mut AnimatedAimingEnum {
        &mut self.animated_aiming_type
    }
    fn is_one_handed(&self) -> &bool {
        &self.is_one_handed
    }
    fn is_one_handed_mut(&mut self) -> &mut bool {
        &mut self.is_one_handed
    }
    fn play_deploy_after_fire(&self) -> &bool {
        &self.play_deploy_after_fire
    }
    fn play_deploy_after_fire_mut(&mut self) -> &mut bool {
        &mut self.play_deploy_after_fire
    }
    fn skip_deploy_animation(&self) -> &bool {
        &self.skip_deploy_animation
    }
    fn skip_deploy_animation_mut(&mut self) -> &mut bool {
        &mut self.skip_deploy_animation
    }
    fn skip_reload_animation(&self) -> &bool {
        &self.skip_reload_animation
    }
    fn skip_reload_animation_mut(&mut self) -> &mut bool {
        &mut self.skip_reload_animation
    }
    fn skip_fire_animation(&self) -> &bool {
        &self.skip_fire_animation
    }
    fn skip_fire_animation_mut(&mut self) -> &mut bool {
        &mut self.skip_fire_animation
    }
    fn hide_projectile_after_fire_time(&self) -> &f32 {
        &self.hide_projectile_after_fire_time
    }
    fn hide_projectile_after_fire_time_mut(&mut self) -> &mut f32 {
        &mut self.hide_projectile_after_fire_time
    }
    fn projectile_bone_name(&self) -> &String {
        &self.projectile_bone_name
    }
    fn projectile_bone_name_mut(&mut self) -> &mut String {
        &mut self.projectile_bone_name
    }
    fn un_deploy_speed(&self) -> &f32 {
        &self.un_deploy_speed
    }
    fn un_deploy_speed_mut(&mut self) -> &mut f32 {
        &mut self.un_deploy_speed
    }
    fn deploy_speed(&self) -> &f32 {
        &self.deploy_speed
    }
    fn deploy_speed_mut(&mut self) -> &mut f32 {
        &mut self.deploy_speed
    }
    fn mesh3p_transforms(&self) -> &super::core::SparseTransformArray {
        &self.mesh3p_transforms
    }
    fn mesh3p_transforms_mut(&mut self) -> &mut super::core::SparseTransformArray {
        &mut self.mesh3p_transforms
    }
}

pub static WEAPONSTATEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponStateData",
    flags: MemberInfoFlags::new(73),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WeaponStateData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ReferencedAssetHashes",
                flags: MemberInfoFlags::new(144),
                field_type: "Uint32-Array",
                rust_offset: offset_of!(WeaponStateData, referenced_asset_hashes),
            },
            FieldInfoData {
                name: "BoneFakePhysics",
                flags: MemberInfoFlags::new(144),
                field_type: "BoneFakePhysicsData-Array",
                rust_offset: offset_of!(WeaponStateData, bone_fake_physics),
            },
            FieldInfoData {
                name: "WeaponMesh3p",
                flags: MemberInfoFlags::new(0),
                field_type: "ObjectBlueprint",
                rust_offset: offset_of!(WeaponStateData, weapon_mesh3p),
            },
            FieldInfoData {
                name: "Mesh3p",
                flags: MemberInfoFlags::new(0),
                field_type: "SkinnedMeshAsset",
                rust_offset: offset_of!(WeaponStateData, mesh3p),
            },
            FieldInfoData {
                name: "Weapon",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(WeaponStateData, weapon),
            },
            FieldInfoData {
                name: "Weapon3p",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(WeaponStateData, weapon3p),
            },
            FieldInfoData {
                name: "ZoomMeshTransitionFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WeaponStateData, zoom_mesh_transition_factor),
            },
            FieldInfoData {
                name: "ZoomScaleFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WeaponStateData, zoom_scale_factor),
            },
            FieldInfoData {
                name: "ZoomInOutMeshTransitionFactors",
                flags: MemberInfoFlags::new(144),
                field_type: "Float32-Array",
                rust_offset: offset_of!(WeaponStateData, zoom_in_out_mesh_transition_factors),
            },
            FieldInfoData {
                name: "KeepAimingTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WeaponStateData, keep_aiming_time),
            },
            FieldInfoData {
                name: "AlwaysAimHead",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WeaponStateData, always_aim_head),
            },
            FieldInfoData {
                name: "AnimatedFireType",
                flags: MemberInfoFlags::new(0),
                field_type: "AnimatedFireEnum",
                rust_offset: offset_of!(WeaponStateData, animated_fire_type),
            },
            FieldInfoData {
                name: "AnimatedAimingType",
                flags: MemberInfoFlags::new(0),
                field_type: "AnimatedAimingEnum",
                rust_offset: offset_of!(WeaponStateData, animated_aiming_type),
            },
            FieldInfoData {
                name: "IsOneHanded",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WeaponStateData, is_one_handed),
            },
            FieldInfoData {
                name: "PlayDeployAfterFire",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WeaponStateData, play_deploy_after_fire),
            },
            FieldInfoData {
                name: "SkipDeployAnimation",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WeaponStateData, skip_deploy_animation),
            },
            FieldInfoData {
                name: "SkipReloadAnimation",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WeaponStateData, skip_reload_animation),
            },
            FieldInfoData {
                name: "SkipFireAnimation",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WeaponStateData, skip_fire_animation),
            },
            FieldInfoData {
                name: "HideProjectileAfterFireTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WeaponStateData, hide_projectile_after_fire_time),
            },
            FieldInfoData {
                name: "ProjectileBoneName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(WeaponStateData, projectile_bone_name),
            },
            FieldInfoData {
                name: "UnDeploySpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WeaponStateData, un_deploy_speed),
            },
            FieldInfoData {
                name: "DeploySpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WeaponStateData, deploy_speed),
            },
            FieldInfoData {
                name: "Mesh3pTransforms",
                flags: MemberInfoFlags::new(0),
                field_type: "SparseTransformArray",
                rust_offset: offset_of!(WeaponStateData, mesh3p_transforms),
            },
        ],
    }),
    array_type: Some(WEAPONSTATEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WeaponStateData {
    fn type_info(&self) -> &'static TypeInfo {
        WEAPONSTATEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static WEAPONSTATEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponStateData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("WeaponStateData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum AnimatedAimingEnum {
    #[default]
    AnimatedAimingTwoHanded = 0,
    AnimatedAimingRightHanded = 1,
    AnimatedAimingDisabled = 2,
}

pub static ANIMATEDAIMINGENUM_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimatedAimingEnum",
    flags: MemberInfoFlags::new(49429),
    module: "SoldierShared",
    data: TypeInfoData::Enum,
    array_type: Some(ANIMATEDAIMINGENUM_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AnimatedAimingEnum {
    fn type_info(&self) -> &'static TypeInfo {
        ANIMATEDAIMINGENUM_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ANIMATEDAIMINGENUM_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimatedAimingEnum-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("AnimatedAimingEnum"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum AnimatedFireEnum {
    #[default]
    AnimatedFireAutomatic = 0,
    AnimatedFireSingle = 1,
    AnimatedFireHoldAndRelease = 2,
    AnimatedFireDelayedSingleShot = 3,
    AnimatedFireSimple = 4,
}

pub static ANIMATEDFIREENUM_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimatedFireEnum",
    flags: MemberInfoFlags::new(49429),
    module: "SoldierShared",
    data: TypeInfoData::Enum,
    array_type: Some(ANIMATEDFIREENUM_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AnimatedFireEnum {
    fn type_info(&self) -> &'static TypeInfo {
        ANIMATEDFIREENUM_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ANIMATEDFIREENUM_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimatedFireEnum-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("AnimatedFireEnum"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FirstPersonCameraData {
    pub _glacier_base: super::core::DataContainer,
    pub offset: super::core::Vec3,
    pub rotation: super::core::Vec3,
}

pub trait FirstPersonCameraDataTrait: super::core::DataContainerTrait {
    fn offset(&self) -> &super::core::Vec3;
    fn offset_mut(&mut self) -> &mut super::core::Vec3;
    fn rotation(&self) -> &super::core::Vec3;
    fn rotation_mut(&mut self) -> &mut super::core::Vec3;
}

impl FirstPersonCameraDataTrait for FirstPersonCameraData {
    fn offset(&self) -> &super::core::Vec3 {
        &self.offset
    }
    fn offset_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.offset
    }
    fn rotation(&self) -> &super::core::Vec3 {
        &self.rotation
    }
    fn rotation_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.rotation
    }
}

impl super::core::DataContainerTrait for FirstPersonCameraData {
}

pub static FIRSTPERSONCAMERADATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FirstPersonCameraData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FirstPersonCameraData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Offset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(FirstPersonCameraData, offset),
            },
            FieldInfoData {
                name: "Rotation",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(FirstPersonCameraData, rotation),
            },
        ],
    }),
    array_type: Some(FIRSTPERSONCAMERADATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for FirstPersonCameraData {
    fn type_info(&self) -> &'static TypeInfo {
        FIRSTPERSONCAMERADATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FIRSTPERSONCAMERADATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FirstPersonCameraData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("FirstPersonCameraData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ZoomLevelSpecificTransitionTime {
    pub from_zoom_level: i32,
    pub to_zoom_level: i32,
    pub zoom_transition_time: f32,
    pub fov_transition_time: f32,
}

pub trait ZoomLevelSpecificTransitionTimeTrait: TypeObject {
    fn from_zoom_level(&self) -> &i32;
    fn from_zoom_level_mut(&mut self) -> &mut i32;
    fn to_zoom_level(&self) -> &i32;
    fn to_zoom_level_mut(&mut self) -> &mut i32;
    fn zoom_transition_time(&self) -> &f32;
    fn zoom_transition_time_mut(&mut self) -> &mut f32;
    fn fov_transition_time(&self) -> &f32;
    fn fov_transition_time_mut(&mut self) -> &mut f32;
}

impl ZoomLevelSpecificTransitionTimeTrait for ZoomLevelSpecificTransitionTime {
    fn from_zoom_level(&self) -> &i32 {
        &self.from_zoom_level
    }
    fn from_zoom_level_mut(&mut self) -> &mut i32 {
        &mut self.from_zoom_level
    }
    fn to_zoom_level(&self) -> &i32 {
        &self.to_zoom_level
    }
    fn to_zoom_level_mut(&mut self) -> &mut i32 {
        &mut self.to_zoom_level
    }
    fn zoom_transition_time(&self) -> &f32 {
        &self.zoom_transition_time
    }
    fn zoom_transition_time_mut(&mut self) -> &mut f32 {
        &mut self.zoom_transition_time
    }
    fn fov_transition_time(&self) -> &f32 {
        &self.fov_transition_time
    }
    fn fov_transition_time_mut(&mut self) -> &mut f32 {
        &mut self.fov_transition_time
    }
}

pub static ZOOMLEVELSPECIFICTRANSITIONTIME_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ZoomLevelSpecificTransitionTime",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ZoomLevelSpecificTransitionTime as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "FromZoomLevel",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ZoomLevelSpecificTransitionTime, from_zoom_level),
            },
            FieldInfoData {
                name: "ToZoomLevel",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ZoomLevelSpecificTransitionTime, to_zoom_level),
            },
            FieldInfoData {
                name: "ZoomTransitionTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ZoomLevelSpecificTransitionTime, zoom_transition_time),
            },
            FieldInfoData {
                name: "FovTransitionTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ZoomLevelSpecificTransitionTime, fov_transition_time),
            },
        ],
    }),
    array_type: Some(ZOOMLEVELSPECIFICTRANSITIONTIME_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for ZoomLevelSpecificTransitionTime {
    fn type_info(&self) -> &'static TypeInfo {
        ZOOMLEVELSPECIFICTRANSITIONTIME_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ZOOMLEVELSPECIFICTRANSITIONTIME_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ZoomLevelSpecificTransitionTime-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("ZoomLevelSpecificTransitionTime"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AimingPoseData {
    pub minimum_pitch: f32,
    pub maximum_pitch: f32,
    pub targeting_fov: f32,
    pub aim_steadiness: f32,
    pub speed_multiplier: f32,
    pub recoil_multiplier: f32,
}

pub trait AimingPoseDataTrait: TypeObject {
    fn minimum_pitch(&self) -> &f32;
    fn minimum_pitch_mut(&mut self) -> &mut f32;
    fn maximum_pitch(&self) -> &f32;
    fn maximum_pitch_mut(&mut self) -> &mut f32;
    fn targeting_fov(&self) -> &f32;
    fn targeting_fov_mut(&mut self) -> &mut f32;
    fn aim_steadiness(&self) -> &f32;
    fn aim_steadiness_mut(&mut self) -> &mut f32;
    fn speed_multiplier(&self) -> &f32;
    fn speed_multiplier_mut(&mut self) -> &mut f32;
    fn recoil_multiplier(&self) -> &f32;
    fn recoil_multiplier_mut(&mut self) -> &mut f32;
}

impl AimingPoseDataTrait for AimingPoseData {
    fn minimum_pitch(&self) -> &f32 {
        &self.minimum_pitch
    }
    fn minimum_pitch_mut(&mut self) -> &mut f32 {
        &mut self.minimum_pitch
    }
    fn maximum_pitch(&self) -> &f32 {
        &self.maximum_pitch
    }
    fn maximum_pitch_mut(&mut self) -> &mut f32 {
        &mut self.maximum_pitch
    }
    fn targeting_fov(&self) -> &f32 {
        &self.targeting_fov
    }
    fn targeting_fov_mut(&mut self) -> &mut f32 {
        &mut self.targeting_fov
    }
    fn aim_steadiness(&self) -> &f32 {
        &self.aim_steadiness
    }
    fn aim_steadiness_mut(&mut self) -> &mut f32 {
        &mut self.aim_steadiness
    }
    fn speed_multiplier(&self) -> &f32 {
        &self.speed_multiplier
    }
    fn speed_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.speed_multiplier
    }
    fn recoil_multiplier(&self) -> &f32 {
        &self.recoil_multiplier
    }
    fn recoil_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.recoil_multiplier
    }
}

pub static AIMINGPOSEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AimingPoseData",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AimingPoseData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MinimumPitch",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AimingPoseData, minimum_pitch),
            },
            FieldInfoData {
                name: "MaximumPitch",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AimingPoseData, maximum_pitch),
            },
            FieldInfoData {
                name: "TargetingFov",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AimingPoseData, targeting_fov),
            },
            FieldInfoData {
                name: "AimSteadiness",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AimingPoseData, aim_steadiness),
            },
            FieldInfoData {
                name: "SpeedMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AimingPoseData, speed_multiplier),
            },
            FieldInfoData {
                name: "RecoilMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AimingPoseData, recoil_multiplier),
            },
        ],
    }),
    array_type: Some(AIMINGPOSEDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AimingPoseData {
    fn type_info(&self) -> &'static TypeInfo {
        AIMINGPOSEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AIMINGPOSEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AimingPoseData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("AimingPoseData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AimerModifierData {
    pub _glacier_base: super::core::Asset,
    pub look_speed_multiplier: f32,
    pub only_in_supported_shooting: bool,
}

pub trait AimerModifierDataTrait: super::core::AssetTrait {
    fn look_speed_multiplier(&self) -> &f32;
    fn look_speed_multiplier_mut(&mut self) -> &mut f32;
    fn only_in_supported_shooting(&self) -> &bool;
    fn only_in_supported_shooting_mut(&mut self) -> &mut bool;
}

impl AimerModifierDataTrait for AimerModifierData {
    fn look_speed_multiplier(&self) -> &f32 {
        &self.look_speed_multiplier
    }
    fn look_speed_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.look_speed_multiplier
    }
    fn only_in_supported_shooting(&self) -> &bool {
        &self.only_in_supported_shooting
    }
    fn only_in_supported_shooting_mut(&mut self) -> &mut bool {
        &mut self.only_in_supported_shooting
    }
}

impl super::core::AssetTrait for AimerModifierData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for AimerModifierData {
}

pub static AIMERMODIFIERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AimerModifierData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AimerModifierData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "LookSpeedMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AimerModifierData, look_speed_multiplier),
            },
            FieldInfoData {
                name: "OnlyInSupportedShooting",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AimerModifierData, only_in_supported_shooting),
            },
        ],
    }),
    array_type: Some(AIMERMODIFIERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AimerModifierData {
    fn type_info(&self) -> &'static TypeInfo {
        AIMERMODIFIERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIMERMODIFIERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AimerModifierData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("AimerModifierData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverObjectReaderWatcherEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub vo_object_properties_array: Vec<VoObjectPropertiesReader>,
}

pub trait VoiceOverObjectReaderWatcherEntityDataTrait: super::entity::EntityDataTrait {
    fn vo_object_properties_array(&self) -> &Vec<VoObjectPropertiesReader>;
    fn vo_object_properties_array_mut(&mut self) -> &mut Vec<VoObjectPropertiesReader>;
}

impl VoiceOverObjectReaderWatcherEntityDataTrait for VoiceOverObjectReaderWatcherEntityData {
    fn vo_object_properties_array(&self) -> &Vec<VoObjectPropertiesReader> {
        &self.vo_object_properties_array
    }
    fn vo_object_properties_array_mut(&mut self) -> &mut Vec<VoObjectPropertiesReader> {
        &mut self.vo_object_properties_array
    }
}

impl super::entity::EntityDataTrait for VoiceOverObjectReaderWatcherEntityData {
}

impl super::entity::GameObjectDataTrait for VoiceOverObjectReaderWatcherEntityData {
}

impl super::core::DataBusPeerTrait for VoiceOverObjectReaderWatcherEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for VoiceOverObjectReaderWatcherEntityData {
}

impl super::core::DataContainerTrait for VoiceOverObjectReaderWatcherEntityData {
}

pub static VOICEOVEROBJECTREADERWATCHERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverObjectReaderWatcherEntityData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverObjectReaderWatcherEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "VoObjectPropertiesArray",
                flags: MemberInfoFlags::new(144),
                field_type: "VoObjectPropertiesReader-Array",
                rust_offset: offset_of!(VoiceOverObjectReaderWatcherEntityData, vo_object_properties_array),
            },
        ],
    }),
    array_type: Some(VOICEOVEROBJECTREADERWATCHERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverObjectReaderWatcherEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVEROBJECTREADERWATCHERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVEROBJECTREADERWATCHERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverObjectReaderWatcherEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("VoiceOverObjectReaderWatcherEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverObjectReaderEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub vo_object_properties_array: Vec<VoObjectPropertiesReader>,
}

pub trait VoiceOverObjectReaderEntityDataTrait: super::entity::EntityDataTrait {
    fn vo_object_properties_array(&self) -> &Vec<VoObjectPropertiesReader>;
    fn vo_object_properties_array_mut(&mut self) -> &mut Vec<VoObjectPropertiesReader>;
}

impl VoiceOverObjectReaderEntityDataTrait for VoiceOverObjectReaderEntityData {
    fn vo_object_properties_array(&self) -> &Vec<VoObjectPropertiesReader> {
        &self.vo_object_properties_array
    }
    fn vo_object_properties_array_mut(&mut self) -> &mut Vec<VoObjectPropertiesReader> {
        &mut self.vo_object_properties_array
    }
}

impl super::entity::EntityDataTrait for VoiceOverObjectReaderEntityData {
}

impl super::entity::GameObjectDataTrait for VoiceOverObjectReaderEntityData {
}

impl super::core::DataBusPeerTrait for VoiceOverObjectReaderEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for VoiceOverObjectReaderEntityData {
}

impl super::core::DataContainerTrait for VoiceOverObjectReaderEntityData {
}

pub static VOICEOVEROBJECTREADERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverObjectReaderEntityData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverObjectReaderEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "VoObjectPropertiesArray",
                flags: MemberInfoFlags::new(144),
                field_type: "VoObjectPropertiesReader-Array",
                rust_offset: offset_of!(VoiceOverObjectReaderEntityData, vo_object_properties_array),
            },
        ],
    }),
    array_type: Some(VOICEOVEROBJECTREADERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverObjectReaderEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVEROBJECTREADERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVEROBJECTREADERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverObjectReaderEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("VoiceOverObjectReaderEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoObjectPropertiesReader {
    pub object_name: String,
    pub object_type: VoiceOverObjectType,
}

pub trait VoObjectPropertiesReaderTrait: TypeObject {
    fn object_name(&self) -> &String;
    fn object_name_mut(&mut self) -> &mut String;
    fn object_type(&self) -> &VoiceOverObjectType;
    fn object_type_mut(&mut self) -> &mut VoiceOverObjectType;
}

impl VoObjectPropertiesReaderTrait for VoObjectPropertiesReader {
    fn object_name(&self) -> &String {
        &self.object_name
    }
    fn object_name_mut(&mut self) -> &mut String {
        &mut self.object_name
    }
    fn object_type(&self) -> &VoiceOverObjectType {
        &self.object_type
    }
    fn object_type_mut(&mut self) -> &mut VoiceOverObjectType {
        &mut self.object_type
    }
}

pub static VOOBJECTPROPERTIESREADER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoObjectPropertiesReader",
    flags: MemberInfoFlags::new(73),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoObjectPropertiesReader as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ObjectName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(VoObjectPropertiesReader, object_name),
            },
            FieldInfoData {
                name: "ObjectType",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverObjectType",
                rust_offset: offset_of!(VoObjectPropertiesReader, object_type),
            },
        ],
    }),
    array_type: Some(VOOBJECTPROPERTIESREADER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoObjectPropertiesReader {
    fn type_info(&self) -> &'static TypeInfo {
        VOOBJECTPROPERTIESREADER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VOOBJECTPROPERTIESREADER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoObjectPropertiesReader-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("VoObjectPropertiesReader"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum VoiceOverObjectType {
    #[default]
    VoiceOverObjectType_Boolean = 0,
    VoiceOverObjectType_Integer = 1,
    VoiceOverObjectType_Float = 2,
    VoiceOverObjectType_Vector = 3,
}

pub static VOICEOVEROBJECTTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverObjectType",
    flags: MemberInfoFlags::new(49429),
    module: "SoldierShared",
    data: TypeInfoData::Enum,
    array_type: Some(VOICEOVEROBJECTTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for VoiceOverObjectType {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVEROBJECTTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VOICEOVEROBJECTTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverObjectType-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("VoiceOverObjectType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct UnlockDynamicToggleMessage {
}

pub trait UnlockDynamicToggleMessageTrait: TypeObject {
}

impl UnlockDynamicToggleMessageTrait for UnlockDynamicToggleMessage {
}

pub static UNLOCKDYNAMICTOGGLEMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnlockDynamicToggleMessage",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<UnlockDynamicToggleMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for UnlockDynamicToggleMessage {
    fn type_info(&self) -> &'static TypeInfo {
        UNLOCKDYNAMICTOGGLEMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Clone, Debug, Default)]
pub struct SoldierWeaponCustomizationAsset {
    pub _glacier_base: super::core::DataContainerPolicyAsset,
    pub customization: Option<Arc<Mutex<dyn super::game_shared::CustomizationTableTrait>>>,
}

pub trait SoldierWeaponCustomizationAssetTrait: super::core::DataContainerPolicyAssetTrait {
    fn customization(&self) -> &Option<Arc<Mutex<dyn super::game_shared::CustomizationTableTrait>>>;
    fn customization_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::game_shared::CustomizationTableTrait>>>;
}

impl SoldierWeaponCustomizationAssetTrait for SoldierWeaponCustomizationAsset {
    fn customization(&self) -> &Option<Arc<Mutex<dyn super::game_shared::CustomizationTableTrait>>> {
        &self.customization
    }
    fn customization_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::game_shared::CustomizationTableTrait>>> {
        &mut self.customization
    }
}

impl super::core::DataContainerPolicyAssetTrait for SoldierWeaponCustomizationAsset {
}

impl super::core::AssetTrait for SoldierWeaponCustomizationAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for SoldierWeaponCustomizationAsset {
}

pub static SOLDIERWEAPONCUSTOMIZATIONASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierWeaponCustomizationAsset",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINERPOLICYASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierWeaponCustomizationAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Customization",
                flags: MemberInfoFlags::new(0),
                field_type: "CustomizationTable",
                rust_offset: offset_of!(SoldierWeaponCustomizationAsset, customization),
            },
        ],
    }),
    array_type: Some(SOLDIERWEAPONCUSTOMIZATIONASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoldierWeaponCustomizationAsset {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERWEAPONCUSTOMIZATIONASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOLDIERWEAPONCUSTOMIZATIONASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierWeaponCustomizationAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SoldierWeaponCustomizationAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct UnlockWeaponAndSlot {
    pub weapon: Option<Arc<Mutex<dyn SoldierWeaponUnlockAssetTrait>>>,
    pub slot: super::weapon_shared::WeaponSlot,
    pub customization_unlock_assets: Vec<Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>>>,
    pub unlock_assets: Vec<Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>>>,
}

pub trait UnlockWeaponAndSlotTrait: TypeObject {
    fn weapon(&self) -> &Option<Arc<Mutex<dyn SoldierWeaponUnlockAssetTrait>>>;
    fn weapon_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoldierWeaponUnlockAssetTrait>>>;
    fn slot(&self) -> &super::weapon_shared::WeaponSlot;
    fn slot_mut(&mut self) -> &mut super::weapon_shared::WeaponSlot;
    fn customization_unlock_assets(&self) -> &Vec<Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>>>;
    fn customization_unlock_assets_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>>>;
    fn unlock_assets(&self) -> &Vec<Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>>>;
    fn unlock_assets_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>>>;
}

impl UnlockWeaponAndSlotTrait for UnlockWeaponAndSlot {
    fn weapon(&self) -> &Option<Arc<Mutex<dyn SoldierWeaponUnlockAssetTrait>>> {
        &self.weapon
    }
    fn weapon_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoldierWeaponUnlockAssetTrait>>> {
        &mut self.weapon
    }
    fn slot(&self) -> &super::weapon_shared::WeaponSlot {
        &self.slot
    }
    fn slot_mut(&mut self) -> &mut super::weapon_shared::WeaponSlot {
        &mut self.slot
    }
    fn customization_unlock_assets(&self) -> &Vec<Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>>> {
        &self.customization_unlock_assets
    }
    fn customization_unlock_assets_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>>> {
        &mut self.customization_unlock_assets
    }
    fn unlock_assets(&self) -> &Vec<Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>>> {
        &self.unlock_assets
    }
    fn unlock_assets_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>>> {
        &mut self.unlock_assets
    }
}

pub static UNLOCKWEAPONANDSLOT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnlockWeaponAndSlot",
    flags: MemberInfoFlags::new(73),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<UnlockWeaponAndSlot as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Weapon",
                flags: MemberInfoFlags::new(0),
                field_type: "SoldierWeaponUnlockAsset",
                rust_offset: offset_of!(UnlockWeaponAndSlot, weapon),
            },
            FieldInfoData {
                name: "Slot",
                flags: MemberInfoFlags::new(0),
                field_type: "WeaponSlot",
                rust_offset: offset_of!(UnlockWeaponAndSlot, slot),
            },
            FieldInfoData {
                name: "CustomizationUnlockAssets",
                flags: MemberInfoFlags::new(144),
                field_type: "UnlockAssetBase-Array",
                rust_offset: offset_of!(UnlockWeaponAndSlot, customization_unlock_assets),
            },
            FieldInfoData {
                name: "UnlockAssets",
                flags: MemberInfoFlags::new(144),
                field_type: "UnlockAssetBase-Array",
                rust_offset: offset_of!(UnlockWeaponAndSlot, unlock_assets),
            },
        ],
    }),
    array_type: Some(UNLOCKWEAPONANDSLOT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for UnlockWeaponAndSlot {
    fn type_info(&self) -> &'static TypeInfo {
        UNLOCKWEAPONANDSLOT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static UNLOCKWEAPONANDSLOT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnlockWeaponAndSlot-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("UnlockWeaponAndSlot"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoldierWeaponUnlockAsset {
    pub _glacier_base: super::weapon_shared::WeaponUnlockAsset,
    pub weapon_blueprint_bundle_reference: super::gameplay_sim::BlueprintBundleReference,
    pub weapon1p_blueprint_bundle_reference: super::gameplay_sim::BlueprintBundleReference,
    pub non_streamed_blueprint: Option<Arc<Mutex<dyn super::entity::BlueprintTrait>>>,
    pub customization: Option<Arc<Mutex<dyn SoldierWeaponCustomizationAssetTrait>>>,
    pub extra: Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>>,
    pub weapon_identifier: u32,
    pub category: u32,
    pub weapon_data: StoredWeaponData,
    pub unlock_to_blueprint_bundle: Vec<UnlockToBlueprintBundle>,
}

pub trait SoldierWeaponUnlockAssetTrait: super::weapon_shared::WeaponUnlockAssetTrait {
    fn weapon_blueprint_bundle_reference(&self) -> &super::gameplay_sim::BlueprintBundleReference;
    fn weapon_blueprint_bundle_reference_mut(&mut self) -> &mut super::gameplay_sim::BlueprintBundleReference;
    fn weapon1p_blueprint_bundle_reference(&self) -> &super::gameplay_sim::BlueprintBundleReference;
    fn weapon1p_blueprint_bundle_reference_mut(&mut self) -> &mut super::gameplay_sim::BlueprintBundleReference;
    fn non_streamed_blueprint(&self) -> &Option<Arc<Mutex<dyn super::entity::BlueprintTrait>>>;
    fn non_streamed_blueprint_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::BlueprintTrait>>>;
    fn customization(&self) -> &Option<Arc<Mutex<dyn SoldierWeaponCustomizationAssetTrait>>>;
    fn customization_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoldierWeaponCustomizationAssetTrait>>>;
    fn extra(&self) -> &Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>>;
    fn extra_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>>;
    fn weapon_identifier(&self) -> &u32;
    fn weapon_identifier_mut(&mut self) -> &mut u32;
    fn category(&self) -> &u32;
    fn category_mut(&mut self) -> &mut u32;
    fn weapon_data(&self) -> &StoredWeaponData;
    fn weapon_data_mut(&mut self) -> &mut StoredWeaponData;
    fn unlock_to_blueprint_bundle(&self) -> &Vec<UnlockToBlueprintBundle>;
    fn unlock_to_blueprint_bundle_mut(&mut self) -> &mut Vec<UnlockToBlueprintBundle>;
}

impl SoldierWeaponUnlockAssetTrait for SoldierWeaponUnlockAsset {
    fn weapon_blueprint_bundle_reference(&self) -> &super::gameplay_sim::BlueprintBundleReference {
        &self.weapon_blueprint_bundle_reference
    }
    fn weapon_blueprint_bundle_reference_mut(&mut self) -> &mut super::gameplay_sim::BlueprintBundleReference {
        &mut self.weapon_blueprint_bundle_reference
    }
    fn weapon1p_blueprint_bundle_reference(&self) -> &super::gameplay_sim::BlueprintBundleReference {
        &self.weapon1p_blueprint_bundle_reference
    }
    fn weapon1p_blueprint_bundle_reference_mut(&mut self) -> &mut super::gameplay_sim::BlueprintBundleReference {
        &mut self.weapon1p_blueprint_bundle_reference
    }
    fn non_streamed_blueprint(&self) -> &Option<Arc<Mutex<dyn super::entity::BlueprintTrait>>> {
        &self.non_streamed_blueprint
    }
    fn non_streamed_blueprint_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::BlueprintTrait>>> {
        &mut self.non_streamed_blueprint
    }
    fn customization(&self) -> &Option<Arc<Mutex<dyn SoldierWeaponCustomizationAssetTrait>>> {
        &self.customization
    }
    fn customization_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoldierWeaponCustomizationAssetTrait>>> {
        &mut self.customization
    }
    fn extra(&self) -> &Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>> {
        &self.extra
    }
    fn extra_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>> {
        &mut self.extra
    }
    fn weapon_identifier(&self) -> &u32 {
        &self.weapon_identifier
    }
    fn weapon_identifier_mut(&mut self) -> &mut u32 {
        &mut self.weapon_identifier
    }
    fn category(&self) -> &u32 {
        &self.category
    }
    fn category_mut(&mut self) -> &mut u32 {
        &mut self.category
    }
    fn weapon_data(&self) -> &StoredWeaponData {
        &self.weapon_data
    }
    fn weapon_data_mut(&mut self) -> &mut StoredWeaponData {
        &mut self.weapon_data
    }
    fn unlock_to_blueprint_bundle(&self) -> &Vec<UnlockToBlueprintBundle> {
        &self.unlock_to_blueprint_bundle
    }
    fn unlock_to_blueprint_bundle_mut(&mut self) -> &mut Vec<UnlockToBlueprintBundle> {
        &mut self.unlock_to_blueprint_bundle
    }
}

impl super::weapon_shared::WeaponUnlockAssetTrait for SoldierWeaponUnlockAsset {
}

impl super::game_shared::UnlockAssetBaseTrait for SoldierWeaponUnlockAsset {
    fn unlock_user_data(&self) -> &Option<Arc<Mutex<dyn super::game_shared::UnlockUserDataBaseTrait>>> {
        self._glacier_base.unlock_user_data()
    }
    fn unlock_user_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::game_shared::UnlockUserDataBaseTrait>>> {
        self._glacier_base.unlock_user_data_mut()
    }
    fn debug_unlock_id(&self) -> &String {
        self._glacier_base.debug_unlock_id()
    }
    fn debug_unlock_id_mut(&mut self) -> &mut String {
        self._glacier_base.debug_unlock_id_mut()
    }
    fn identifier(&self) -> &u32 {
        self._glacier_base.identifier()
    }
    fn identifier_mut(&mut self) -> &mut u32 {
        self._glacier_base.identifier_mut()
    }
    fn unlock_score(&self) -> &u32 {
        self._glacier_base.unlock_score()
    }
    fn unlock_score_mut(&mut self) -> &mut u32 {
        self._glacier_base.unlock_score_mut()
    }
    fn auto_available(&self) -> &bool {
        self._glacier_base.auto_available()
    }
    fn auto_available_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_available_mut()
    }
    fn next_level_unlock_asset(&self) -> &Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>> {
        self._glacier_base.next_level_unlock_asset()
    }
    fn next_level_unlock_asset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>> {
        self._glacier_base.next_level_unlock_asset_mut()
    }
    fn hidden_in_progression(&self) -> &bool {
        self._glacier_base.hidden_in_progression()
    }
    fn hidden_in_progression_mut(&mut self) -> &mut bool {
        self._glacier_base.hidden_in_progression_mut()
    }
    fn available_for_player(&self) -> &super::game_shared::UnlockAvailability {
        self._glacier_base.available_for_player()
    }
    fn available_for_player_mut(&mut self) -> &mut super::game_shared::UnlockAvailability {
        self._glacier_base.available_for_player_mut()
    }
}

impl super::core::DataContainerPolicyAssetTrait for SoldierWeaponUnlockAsset {
}

impl super::core::AssetTrait for SoldierWeaponUnlockAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for SoldierWeaponUnlockAsset {
}

pub static SOLDIERWEAPONUNLOCKASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierWeaponUnlockAsset",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::weapon_shared::WEAPONUNLOCKASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierWeaponUnlockAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "WeaponBlueprintBundleReference",
                flags: MemberInfoFlags::new(0),
                field_type: "BlueprintBundleReference",
                rust_offset: offset_of!(SoldierWeaponUnlockAsset, weapon_blueprint_bundle_reference),
            },
            FieldInfoData {
                name: "Weapon1pBlueprintBundleReference",
                flags: MemberInfoFlags::new(0),
                field_type: "BlueprintBundleReference",
                rust_offset: offset_of!(SoldierWeaponUnlockAsset, weapon1p_blueprint_bundle_reference),
            },
            FieldInfoData {
                name: "NonStreamedBlueprint",
                flags: MemberInfoFlags::new(0),
                field_type: "Blueprint",
                rust_offset: offset_of!(SoldierWeaponUnlockAsset, non_streamed_blueprint),
            },
            FieldInfoData {
                name: "Customization",
                flags: MemberInfoFlags::new(0),
                field_type: "SoldierWeaponCustomizationAsset",
                rust_offset: offset_of!(SoldierWeaponUnlockAsset, customization),
            },
            FieldInfoData {
                name: "Extra",
                flags: MemberInfoFlags::new(0),
                field_type: "UnlockAssetBase",
                rust_offset: offset_of!(SoldierWeaponUnlockAsset, extra),
            },
            FieldInfoData {
                name: "WeaponIdentifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(SoldierWeaponUnlockAsset, weapon_identifier),
            },
            FieldInfoData {
                name: "Category",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(SoldierWeaponUnlockAsset, category),
            },
            FieldInfoData {
                name: "WeaponData",
                flags: MemberInfoFlags::new(0),
                field_type: "StoredWeaponData",
                rust_offset: offset_of!(SoldierWeaponUnlockAsset, weapon_data),
            },
            FieldInfoData {
                name: "UnlockToBlueprintBundle",
                flags: MemberInfoFlags::new(144),
                field_type: "UnlockToBlueprintBundle-Array",
                rust_offset: offset_of!(SoldierWeaponUnlockAsset, unlock_to_blueprint_bundle),
            },
        ],
    }),
    array_type: Some(SOLDIERWEAPONUNLOCKASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoldierWeaponUnlockAsset {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERWEAPONUNLOCKASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOLDIERWEAPONUNLOCKASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierWeaponUnlockAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SoldierWeaponUnlockAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct UnlockToBlueprintBundle {
    pub unlock_asset_guid: glacier_util::guid::Guid,
    pub is_first_person_only: bool,
    pub blueprint_bundle_reference: super::gameplay_sim::BlueprintBundleReference,
}

pub trait UnlockToBlueprintBundleTrait: TypeObject {
    fn unlock_asset_guid(&self) -> &glacier_util::guid::Guid;
    fn unlock_asset_guid_mut(&mut self) -> &mut glacier_util::guid::Guid;
    fn is_first_person_only(&self) -> &bool;
    fn is_first_person_only_mut(&mut self) -> &mut bool;
    fn blueprint_bundle_reference(&self) -> &super::gameplay_sim::BlueprintBundleReference;
    fn blueprint_bundle_reference_mut(&mut self) -> &mut super::gameplay_sim::BlueprintBundleReference;
}

impl UnlockToBlueprintBundleTrait for UnlockToBlueprintBundle {
    fn unlock_asset_guid(&self) -> &glacier_util::guid::Guid {
        &self.unlock_asset_guid
    }
    fn unlock_asset_guid_mut(&mut self) -> &mut glacier_util::guid::Guid {
        &mut self.unlock_asset_guid
    }
    fn is_first_person_only(&self) -> &bool {
        &self.is_first_person_only
    }
    fn is_first_person_only_mut(&mut self) -> &mut bool {
        &mut self.is_first_person_only
    }
    fn blueprint_bundle_reference(&self) -> &super::gameplay_sim::BlueprintBundleReference {
        &self.blueprint_bundle_reference
    }
    fn blueprint_bundle_reference_mut(&mut self) -> &mut super::gameplay_sim::BlueprintBundleReference {
        &mut self.blueprint_bundle_reference
    }
}

pub static UNLOCKTOBLUEPRINTBUNDLE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnlockToBlueprintBundle",
    flags: MemberInfoFlags::new(73),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<UnlockToBlueprintBundle as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "UnlockAssetGuid",
                flags: MemberInfoFlags::new(0),
                field_type: "Guid",
                rust_offset: offset_of!(UnlockToBlueprintBundle, unlock_asset_guid),
            },
            FieldInfoData {
                name: "IsFirstPersonOnly",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(UnlockToBlueprintBundle, is_first_person_only),
            },
            FieldInfoData {
                name: "BlueprintBundleReference",
                flags: MemberInfoFlags::new(0),
                field_type: "BlueprintBundleReference",
                rust_offset: offset_of!(UnlockToBlueprintBundle, blueprint_bundle_reference),
            },
        ],
    }),
    array_type: Some(UNLOCKTOBLUEPRINTBUNDLE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for UnlockToBlueprintBundle {
    fn type_info(&self) -> &'static TypeInfo {
        UNLOCKTOBLUEPRINTBUNDLE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static UNLOCKTOBLUEPRINTBUNDLE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnlockToBlueprintBundle-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("UnlockToBlueprintBundle"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct StoredWeaponData {
    pub weapon_class: i32,
    pub mag_count: i32,
    pub mag_capacity: i32,
    pub anim_base_set: i32,
    pub switch_to_primary_when_out_of_ammo: bool,
    pub undeploy_time: f32,
}

pub trait StoredWeaponDataTrait: TypeObject {
    fn weapon_class(&self) -> &i32;
    fn weapon_class_mut(&mut self) -> &mut i32;
    fn mag_count(&self) -> &i32;
    fn mag_count_mut(&mut self) -> &mut i32;
    fn mag_capacity(&self) -> &i32;
    fn mag_capacity_mut(&mut self) -> &mut i32;
    fn anim_base_set(&self) -> &i32;
    fn anim_base_set_mut(&mut self) -> &mut i32;
    fn switch_to_primary_when_out_of_ammo(&self) -> &bool;
    fn switch_to_primary_when_out_of_ammo_mut(&mut self) -> &mut bool;
    fn undeploy_time(&self) -> &f32;
    fn undeploy_time_mut(&mut self) -> &mut f32;
}

impl StoredWeaponDataTrait for StoredWeaponData {
    fn weapon_class(&self) -> &i32 {
        &self.weapon_class
    }
    fn weapon_class_mut(&mut self) -> &mut i32 {
        &mut self.weapon_class
    }
    fn mag_count(&self) -> &i32 {
        &self.mag_count
    }
    fn mag_count_mut(&mut self) -> &mut i32 {
        &mut self.mag_count
    }
    fn mag_capacity(&self) -> &i32 {
        &self.mag_capacity
    }
    fn mag_capacity_mut(&mut self) -> &mut i32 {
        &mut self.mag_capacity
    }
    fn anim_base_set(&self) -> &i32 {
        &self.anim_base_set
    }
    fn anim_base_set_mut(&mut self) -> &mut i32 {
        &mut self.anim_base_set
    }
    fn switch_to_primary_when_out_of_ammo(&self) -> &bool {
        &self.switch_to_primary_when_out_of_ammo
    }
    fn switch_to_primary_when_out_of_ammo_mut(&mut self) -> &mut bool {
        &mut self.switch_to_primary_when_out_of_ammo
    }
    fn undeploy_time(&self) -> &f32 {
        &self.undeploy_time
    }
    fn undeploy_time_mut(&mut self) -> &mut f32 {
        &mut self.undeploy_time
    }
}

pub static STOREDWEAPONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StoredWeaponData",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StoredWeaponData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "WeaponClass",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(StoredWeaponData, weapon_class),
            },
            FieldInfoData {
                name: "MagCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(StoredWeaponData, mag_count),
            },
            FieldInfoData {
                name: "MagCapacity",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(StoredWeaponData, mag_capacity),
            },
            FieldInfoData {
                name: "AnimBaseSet",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(StoredWeaponData, anim_base_set),
            },
            FieldInfoData {
                name: "SwitchToPrimaryWhenOutOfAmmo",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(StoredWeaponData, switch_to_primary_when_out_of_ammo),
            },
            FieldInfoData {
                name: "UndeployTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StoredWeaponData, undeploy_time),
            },
        ],
    }),
    array_type: Some(STOREDWEAPONDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for StoredWeaponData {
    fn type_info(&self) -> &'static TypeInfo {
        STOREDWEAPONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static STOREDWEAPONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StoredWeaponData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("StoredWeaponData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoldierWeaponMultiUnlock {
    pub _glacier_base: super::game_shared::UnlockUserDataBase,
    pub first: Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>>,
    pub unlock_asset_pairs: Vec<super::game_shared::UnlockAssetPair>,
}

pub trait SoldierWeaponMultiUnlockTrait: super::game_shared::UnlockUserDataBaseTrait {
    fn first(&self) -> &Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>>;
    fn first_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>>;
    fn unlock_asset_pairs(&self) -> &Vec<super::game_shared::UnlockAssetPair>;
    fn unlock_asset_pairs_mut(&mut self) -> &mut Vec<super::game_shared::UnlockAssetPair>;
}

impl SoldierWeaponMultiUnlockTrait for SoldierWeaponMultiUnlock {
    fn first(&self) -> &Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>> {
        &self.first
    }
    fn first_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>> {
        &mut self.first
    }
    fn unlock_asset_pairs(&self) -> &Vec<super::game_shared::UnlockAssetPair> {
        &self.unlock_asset_pairs
    }
    fn unlock_asset_pairs_mut(&mut self) -> &mut Vec<super::game_shared::UnlockAssetPair> {
        &mut self.unlock_asset_pairs
    }
}

impl super::game_shared::UnlockUserDataBaseTrait for SoldierWeaponMultiUnlock {
}

impl super::core::DataContainerPolicyAssetTrait for SoldierWeaponMultiUnlock {
}

impl super::core::AssetTrait for SoldierWeaponMultiUnlock {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for SoldierWeaponMultiUnlock {
}

pub static SOLDIERWEAPONMULTIUNLOCK_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierWeaponMultiUnlock",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::game_shared::UNLOCKUSERDATABASE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierWeaponMultiUnlock as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "First",
                flags: MemberInfoFlags::new(0),
                field_type: "UnlockAssetBase",
                rust_offset: offset_of!(SoldierWeaponMultiUnlock, first),
            },
            FieldInfoData {
                name: "UnlockAssetPairs",
                flags: MemberInfoFlags::new(144),
                field_type: "UnlockAssetPair-Array",
                rust_offset: offset_of!(SoldierWeaponMultiUnlock, unlock_asset_pairs),
            },
        ],
    }),
    array_type: Some(SOLDIERWEAPONMULTIUNLOCK_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoldierWeaponMultiUnlock {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERWEAPONMULTIUNLOCK_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOLDIERWEAPONMULTIUNLOCK_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierWeaponMultiUnlock-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SoldierWeaponMultiUnlock"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TripwireNetData {
    pub length: f32,
    pub pitch: f32,
    pub yaw: f32,
}

pub trait TripwireNetDataTrait: TypeObject {
    fn length(&self) -> &f32;
    fn length_mut(&mut self) -> &mut f32;
    fn pitch(&self) -> &f32;
    fn pitch_mut(&mut self) -> &mut f32;
    fn yaw(&self) -> &f32;
    fn yaw_mut(&mut self) -> &mut f32;
}

impl TripwireNetDataTrait for TripwireNetData {
    fn length(&self) -> &f32 {
        &self.length
    }
    fn length_mut(&mut self) -> &mut f32 {
        &mut self.length
    }
    fn pitch(&self) -> &f32 {
        &self.pitch
    }
    fn pitch_mut(&mut self) -> &mut f32 {
        &mut self.pitch
    }
    fn yaw(&self) -> &f32 {
        &self.yaw
    }
    fn yaw_mut(&mut self) -> &mut f32 {
        &mut self.yaw
    }
}

pub static TRIPWIRENETDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TripwireNetData",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TripwireNetData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Length",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TripwireNetData, length),
            },
            FieldInfoData {
                name: "Pitch",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TripwireNetData, pitch),
            },
            FieldInfoData {
                name: "Yaw",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TripwireNetData, yaw),
            },
        ],
    }),
    array_type: Some(TRIPWIRENETDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for TripwireNetData {
    fn type_info(&self) -> &'static TypeInfo {
        TRIPWIRENETDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static TRIPWIRENETDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TripwireNetData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("TripwireNetData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TriggerMoveEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub move_to_target: MoveToTargetData,
    pub move_to_transform: super::core::LinearTransform,
}

pub trait TriggerMoveEntityDataTrait: super::entity::EntityDataTrait {
    fn move_to_target(&self) -> &MoveToTargetData;
    fn move_to_target_mut(&mut self) -> &mut MoveToTargetData;
    fn move_to_transform(&self) -> &super::core::LinearTransform;
    fn move_to_transform_mut(&mut self) -> &mut super::core::LinearTransform;
}

impl TriggerMoveEntityDataTrait for TriggerMoveEntityData {
    fn move_to_target(&self) -> &MoveToTargetData {
        &self.move_to_target
    }
    fn move_to_target_mut(&mut self) -> &mut MoveToTargetData {
        &mut self.move_to_target
    }
    fn move_to_transform(&self) -> &super::core::LinearTransform {
        &self.move_to_transform
    }
    fn move_to_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.move_to_transform
    }
}

impl super::entity::EntityDataTrait for TriggerMoveEntityData {
}

impl super::entity::GameObjectDataTrait for TriggerMoveEntityData {
}

impl super::core::DataBusPeerTrait for TriggerMoveEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TriggerMoveEntityData {
}

impl super::core::DataContainerTrait for TriggerMoveEntityData {
}

pub static TRIGGERMOVEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TriggerMoveEntityData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TriggerMoveEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MoveToTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "MoveToTargetData",
                rust_offset: offset_of!(TriggerMoveEntityData, move_to_target),
            },
            FieldInfoData {
                name: "MoveToTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(TriggerMoveEntityData, move_to_transform),
            },
        ],
    }),
    array_type: Some(TRIGGERMOVEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for TriggerMoveEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TRIGGERMOVEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TRIGGERMOVEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TriggerMoveEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("TriggerMoveEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateTriggerEntityData {
    pub _glacier_base: super::game_shared::TriggerEntityData,
    pub use_pitch: bool,
    pub pitch: f32,
    pub character_pose: super::game_shared::CharacterPoseAction,
    pub exclude_connected_vehicles: bool,
    pub stay_in_vehicle_on_move: bool,
    pub leave_vehicle_on_move: bool,
    pub clear_out_nearby_vehicles_on_move: bool,
    pub soldier_weapon: Option<Arc<Mutex<dyn SoldierWeaponUnlockAssetTrait>>>,
    pub check_all_weapons: bool,
    pub check_only_ready_weapons: bool,
    pub continue_to_check_if_holding_wrong_weapon: bool,
    pub should_check_seat_index: bool,
    pub seat_index: u32,
    pub allow_remote_controlled_vehicles: bool,
    pub health_to_set: u32,
    pub health_to_check: u32,
    pub check_health_greater_or_equal: bool,
    pub ammo_to_set: u32,
    pub pose_to_check: super::game_shared::CharacterPoseAction,
    pub use_exit_point_when_leaving_vehicle: bool,
    pub disable_physics_when_leaving_vehicle: bool,
    pub leave_remote_vehicles: bool,
    pub active_weapon_slot: u32,
    pub move_speed_multiplier: f32,
    pub sprint_speed_multiplier: f32,
    pub jump_height_multiplier: f32,
    pub look_speed_multiplier: f32,
}

pub trait CharacterStateTriggerEntityDataTrait: super::game_shared::TriggerEntityDataTrait {
    fn use_pitch(&self) -> &bool;
    fn use_pitch_mut(&mut self) -> &mut bool;
    fn pitch(&self) -> &f32;
    fn pitch_mut(&mut self) -> &mut f32;
    fn character_pose(&self) -> &super::game_shared::CharacterPoseAction;
    fn character_pose_mut(&mut self) -> &mut super::game_shared::CharacterPoseAction;
    fn exclude_connected_vehicles(&self) -> &bool;
    fn exclude_connected_vehicles_mut(&mut self) -> &mut bool;
    fn stay_in_vehicle_on_move(&self) -> &bool;
    fn stay_in_vehicle_on_move_mut(&mut self) -> &mut bool;
    fn leave_vehicle_on_move(&self) -> &bool;
    fn leave_vehicle_on_move_mut(&mut self) -> &mut bool;
    fn clear_out_nearby_vehicles_on_move(&self) -> &bool;
    fn clear_out_nearby_vehicles_on_move_mut(&mut self) -> &mut bool;
    fn soldier_weapon(&self) -> &Option<Arc<Mutex<dyn SoldierWeaponUnlockAssetTrait>>>;
    fn soldier_weapon_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoldierWeaponUnlockAssetTrait>>>;
    fn check_all_weapons(&self) -> &bool;
    fn check_all_weapons_mut(&mut self) -> &mut bool;
    fn check_only_ready_weapons(&self) -> &bool;
    fn check_only_ready_weapons_mut(&mut self) -> &mut bool;
    fn continue_to_check_if_holding_wrong_weapon(&self) -> &bool;
    fn continue_to_check_if_holding_wrong_weapon_mut(&mut self) -> &mut bool;
    fn should_check_seat_index(&self) -> &bool;
    fn should_check_seat_index_mut(&mut self) -> &mut bool;
    fn seat_index(&self) -> &u32;
    fn seat_index_mut(&mut self) -> &mut u32;
    fn allow_remote_controlled_vehicles(&self) -> &bool;
    fn allow_remote_controlled_vehicles_mut(&mut self) -> &mut bool;
    fn health_to_set(&self) -> &u32;
    fn health_to_set_mut(&mut self) -> &mut u32;
    fn health_to_check(&self) -> &u32;
    fn health_to_check_mut(&mut self) -> &mut u32;
    fn check_health_greater_or_equal(&self) -> &bool;
    fn check_health_greater_or_equal_mut(&mut self) -> &mut bool;
    fn ammo_to_set(&self) -> &u32;
    fn ammo_to_set_mut(&mut self) -> &mut u32;
    fn pose_to_check(&self) -> &super::game_shared::CharacterPoseAction;
    fn pose_to_check_mut(&mut self) -> &mut super::game_shared::CharacterPoseAction;
    fn use_exit_point_when_leaving_vehicle(&self) -> &bool;
    fn use_exit_point_when_leaving_vehicle_mut(&mut self) -> &mut bool;
    fn disable_physics_when_leaving_vehicle(&self) -> &bool;
    fn disable_physics_when_leaving_vehicle_mut(&mut self) -> &mut bool;
    fn leave_remote_vehicles(&self) -> &bool;
    fn leave_remote_vehicles_mut(&mut self) -> &mut bool;
    fn active_weapon_slot(&self) -> &u32;
    fn active_weapon_slot_mut(&mut self) -> &mut u32;
    fn move_speed_multiplier(&self) -> &f32;
    fn move_speed_multiplier_mut(&mut self) -> &mut f32;
    fn sprint_speed_multiplier(&self) -> &f32;
    fn sprint_speed_multiplier_mut(&mut self) -> &mut f32;
    fn jump_height_multiplier(&self) -> &f32;
    fn jump_height_multiplier_mut(&mut self) -> &mut f32;
    fn look_speed_multiplier(&self) -> &f32;
    fn look_speed_multiplier_mut(&mut self) -> &mut f32;
}

impl CharacterStateTriggerEntityDataTrait for CharacterStateTriggerEntityData {
    fn use_pitch(&self) -> &bool {
        &self.use_pitch
    }
    fn use_pitch_mut(&mut self) -> &mut bool {
        &mut self.use_pitch
    }
    fn pitch(&self) -> &f32 {
        &self.pitch
    }
    fn pitch_mut(&mut self) -> &mut f32 {
        &mut self.pitch
    }
    fn character_pose(&self) -> &super::game_shared::CharacterPoseAction {
        &self.character_pose
    }
    fn character_pose_mut(&mut self) -> &mut super::game_shared::CharacterPoseAction {
        &mut self.character_pose
    }
    fn exclude_connected_vehicles(&self) -> &bool {
        &self.exclude_connected_vehicles
    }
    fn exclude_connected_vehicles_mut(&mut self) -> &mut bool {
        &mut self.exclude_connected_vehicles
    }
    fn stay_in_vehicle_on_move(&self) -> &bool {
        &self.stay_in_vehicle_on_move
    }
    fn stay_in_vehicle_on_move_mut(&mut self) -> &mut bool {
        &mut self.stay_in_vehicle_on_move
    }
    fn leave_vehicle_on_move(&self) -> &bool {
        &self.leave_vehicle_on_move
    }
    fn leave_vehicle_on_move_mut(&mut self) -> &mut bool {
        &mut self.leave_vehicle_on_move
    }
    fn clear_out_nearby_vehicles_on_move(&self) -> &bool {
        &self.clear_out_nearby_vehicles_on_move
    }
    fn clear_out_nearby_vehicles_on_move_mut(&mut self) -> &mut bool {
        &mut self.clear_out_nearby_vehicles_on_move
    }
    fn soldier_weapon(&self) -> &Option<Arc<Mutex<dyn SoldierWeaponUnlockAssetTrait>>> {
        &self.soldier_weapon
    }
    fn soldier_weapon_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoldierWeaponUnlockAssetTrait>>> {
        &mut self.soldier_weapon
    }
    fn check_all_weapons(&self) -> &bool {
        &self.check_all_weapons
    }
    fn check_all_weapons_mut(&mut self) -> &mut bool {
        &mut self.check_all_weapons
    }
    fn check_only_ready_weapons(&self) -> &bool {
        &self.check_only_ready_weapons
    }
    fn check_only_ready_weapons_mut(&mut self) -> &mut bool {
        &mut self.check_only_ready_weapons
    }
    fn continue_to_check_if_holding_wrong_weapon(&self) -> &bool {
        &self.continue_to_check_if_holding_wrong_weapon
    }
    fn continue_to_check_if_holding_wrong_weapon_mut(&mut self) -> &mut bool {
        &mut self.continue_to_check_if_holding_wrong_weapon
    }
    fn should_check_seat_index(&self) -> &bool {
        &self.should_check_seat_index
    }
    fn should_check_seat_index_mut(&mut self) -> &mut bool {
        &mut self.should_check_seat_index
    }
    fn seat_index(&self) -> &u32 {
        &self.seat_index
    }
    fn seat_index_mut(&mut self) -> &mut u32 {
        &mut self.seat_index
    }
    fn allow_remote_controlled_vehicles(&self) -> &bool {
        &self.allow_remote_controlled_vehicles
    }
    fn allow_remote_controlled_vehicles_mut(&mut self) -> &mut bool {
        &mut self.allow_remote_controlled_vehicles
    }
    fn health_to_set(&self) -> &u32 {
        &self.health_to_set
    }
    fn health_to_set_mut(&mut self) -> &mut u32 {
        &mut self.health_to_set
    }
    fn health_to_check(&self) -> &u32 {
        &self.health_to_check
    }
    fn health_to_check_mut(&mut self) -> &mut u32 {
        &mut self.health_to_check
    }
    fn check_health_greater_or_equal(&self) -> &bool {
        &self.check_health_greater_or_equal
    }
    fn check_health_greater_or_equal_mut(&mut self) -> &mut bool {
        &mut self.check_health_greater_or_equal
    }
    fn ammo_to_set(&self) -> &u32 {
        &self.ammo_to_set
    }
    fn ammo_to_set_mut(&mut self) -> &mut u32 {
        &mut self.ammo_to_set
    }
    fn pose_to_check(&self) -> &super::game_shared::CharacterPoseAction {
        &self.pose_to_check
    }
    fn pose_to_check_mut(&mut self) -> &mut super::game_shared::CharacterPoseAction {
        &mut self.pose_to_check
    }
    fn use_exit_point_when_leaving_vehicle(&self) -> &bool {
        &self.use_exit_point_when_leaving_vehicle
    }
    fn use_exit_point_when_leaving_vehicle_mut(&mut self) -> &mut bool {
        &mut self.use_exit_point_when_leaving_vehicle
    }
    fn disable_physics_when_leaving_vehicle(&self) -> &bool {
        &self.disable_physics_when_leaving_vehicle
    }
    fn disable_physics_when_leaving_vehicle_mut(&mut self) -> &mut bool {
        &mut self.disable_physics_when_leaving_vehicle
    }
    fn leave_remote_vehicles(&self) -> &bool {
        &self.leave_remote_vehicles
    }
    fn leave_remote_vehicles_mut(&mut self) -> &mut bool {
        &mut self.leave_remote_vehicles
    }
    fn active_weapon_slot(&self) -> &u32 {
        &self.active_weapon_slot
    }
    fn active_weapon_slot_mut(&mut self) -> &mut u32 {
        &mut self.active_weapon_slot
    }
    fn move_speed_multiplier(&self) -> &f32 {
        &self.move_speed_multiplier
    }
    fn move_speed_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.move_speed_multiplier
    }
    fn sprint_speed_multiplier(&self) -> &f32 {
        &self.sprint_speed_multiplier
    }
    fn sprint_speed_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.sprint_speed_multiplier
    }
    fn jump_height_multiplier(&self) -> &f32 {
        &self.jump_height_multiplier
    }
    fn jump_height_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.jump_height_multiplier
    }
    fn look_speed_multiplier(&self) -> &f32 {
        &self.look_speed_multiplier
    }
    fn look_speed_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.look_speed_multiplier
    }
}

impl super::game_shared::TriggerEntityDataTrait for CharacterStateTriggerEntityData {
    fn delay(&self) -> &f32 {
        self._glacier_base.delay()
    }
    fn delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.delay_mut()
    }
    fn run_once(&self) -> &bool {
        self._glacier_base.run_once()
    }
    fn run_once_mut(&mut self) -> &mut bool {
        self._glacier_base.run_once_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for CharacterStateTriggerEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for CharacterStateTriggerEntityData {
}

impl super::entity::GameObjectDataTrait for CharacterStateTriggerEntityData {
}

impl super::core::DataBusPeerTrait for CharacterStateTriggerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CharacterStateTriggerEntityData {
}

impl super::core::DataContainerTrait for CharacterStateTriggerEntityData {
}

pub static CHARACTERSTATETRIGGERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateTriggerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::game_shared::TRIGGERENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateTriggerEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "UsePitch",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateTriggerEntityData, use_pitch),
            },
            FieldInfoData {
                name: "Pitch",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateTriggerEntityData, pitch),
            },
            FieldInfoData {
                name: "CharacterPose",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterPoseAction",
                rust_offset: offset_of!(CharacterStateTriggerEntityData, character_pose),
            },
            FieldInfoData {
                name: "ExcludeConnectedVehicles",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateTriggerEntityData, exclude_connected_vehicles),
            },
            FieldInfoData {
                name: "StayInVehicleOnMove",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateTriggerEntityData, stay_in_vehicle_on_move),
            },
            FieldInfoData {
                name: "LeaveVehicleOnMove",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateTriggerEntityData, leave_vehicle_on_move),
            },
            FieldInfoData {
                name: "ClearOutNearbyVehiclesOnMove",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateTriggerEntityData, clear_out_nearby_vehicles_on_move),
            },
            FieldInfoData {
                name: "SoldierWeapon",
                flags: MemberInfoFlags::new(0),
                field_type: "SoldierWeaponUnlockAsset",
                rust_offset: offset_of!(CharacterStateTriggerEntityData, soldier_weapon),
            },
            FieldInfoData {
                name: "CheckAllWeapons",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateTriggerEntityData, check_all_weapons),
            },
            FieldInfoData {
                name: "CheckOnlyReadyWeapons",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateTriggerEntityData, check_only_ready_weapons),
            },
            FieldInfoData {
                name: "ContinueToCheckIfHoldingWrongWeapon",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateTriggerEntityData, continue_to_check_if_holding_wrong_weapon),
            },
            FieldInfoData {
                name: "ShouldCheckSeatIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateTriggerEntityData, should_check_seat_index),
            },
            FieldInfoData {
                name: "SeatIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(CharacterStateTriggerEntityData, seat_index),
            },
            FieldInfoData {
                name: "AllowRemoteControlledVehicles",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateTriggerEntityData, allow_remote_controlled_vehicles),
            },
            FieldInfoData {
                name: "HealthToSet",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(CharacterStateTriggerEntityData, health_to_set),
            },
            FieldInfoData {
                name: "HealthToCheck",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(CharacterStateTriggerEntityData, health_to_check),
            },
            FieldInfoData {
                name: "CheckHealthGreaterOrEqual",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateTriggerEntityData, check_health_greater_or_equal),
            },
            FieldInfoData {
                name: "AmmoToSet",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(CharacterStateTriggerEntityData, ammo_to_set),
            },
            FieldInfoData {
                name: "PoseToCheck",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterPoseAction",
                rust_offset: offset_of!(CharacterStateTriggerEntityData, pose_to_check),
            },
            FieldInfoData {
                name: "UseExitPointWhenLeavingVehicle",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateTriggerEntityData, use_exit_point_when_leaving_vehicle),
            },
            FieldInfoData {
                name: "DisablePhysicsWhenLeavingVehicle",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateTriggerEntityData, disable_physics_when_leaving_vehicle),
            },
            FieldInfoData {
                name: "LeaveRemoteVehicles",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateTriggerEntityData, leave_remote_vehicles),
            },
            FieldInfoData {
                name: "ActiveWeaponSlot",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(CharacterStateTriggerEntityData, active_weapon_slot),
            },
            FieldInfoData {
                name: "MoveSpeedMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateTriggerEntityData, move_speed_multiplier),
            },
            FieldInfoData {
                name: "SprintSpeedMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateTriggerEntityData, sprint_speed_multiplier),
            },
            FieldInfoData {
                name: "JumpHeightMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateTriggerEntityData, jump_height_multiplier),
            },
            FieldInfoData {
                name: "LookSpeedMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateTriggerEntityData, look_speed_multiplier),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATETRIGGERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CharacterStateTriggerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATETRIGGERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERSTATETRIGGERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateTriggerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("CharacterStateTriggerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LookAtTriggerEntityData {
    pub _glacier_base: super::game_shared::CharacterLookAtTriggerEntityData,
    pub soldier_weapon: Option<Arc<Mutex<dyn SoldierWeaponUnlockAssetTrait>>>,
    pub zoom_level: u32,
}

pub trait LookAtTriggerEntityDataTrait: super::game_shared::CharacterLookAtTriggerEntityDataTrait {
    fn soldier_weapon(&self) -> &Option<Arc<Mutex<dyn SoldierWeaponUnlockAssetTrait>>>;
    fn soldier_weapon_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoldierWeaponUnlockAssetTrait>>>;
    fn zoom_level(&self) -> &u32;
    fn zoom_level_mut(&mut self) -> &mut u32;
}

impl LookAtTriggerEntityDataTrait for LookAtTriggerEntityData {
    fn soldier_weapon(&self) -> &Option<Arc<Mutex<dyn SoldierWeaponUnlockAssetTrait>>> {
        &self.soldier_weapon
    }
    fn soldier_weapon_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoldierWeaponUnlockAssetTrait>>> {
        &mut self.soldier_weapon
    }
    fn zoom_level(&self) -> &u32 {
        &self.zoom_level
    }
    fn zoom_level_mut(&mut self) -> &mut u32 {
        &mut self.zoom_level
    }
}

impl super::game_shared::CharacterLookAtTriggerEntityDataTrait for LookAtTriggerEntityData {
    fn f_o_v(&self) -> &f32 {
        self._glacier_base.f_o_v()
    }
    fn f_o_v_mut(&mut self) -> &mut f32 {
        self._glacier_base.f_o_v_mut()
    }
    fn min_distance_to_object(&self) -> &f32 {
        self._glacier_base.min_distance_to_object()
    }
    fn min_distance_to_object_mut(&mut self) -> &mut f32 {
        self._glacier_base.min_distance_to_object_mut()
    }
    fn max_distance_to_object(&self) -> &f32 {
        self._glacier_base.max_distance_to_object()
    }
    fn max_distance_to_object_mut(&mut self) -> &mut f32 {
        self._glacier_base.max_distance_to_object_mut()
    }
    fn start_trigger_looking_at(&self) -> &bool {
        self._glacier_base.start_trigger_looking_at()
    }
    fn start_trigger_looking_at_mut(&mut self) -> &mut bool {
        self._glacier_base.start_trigger_looking_at_mut()
    }
    fn check_occlusion(&self) -> &bool {
        self._glacier_base.check_occlusion()
    }
    fn check_occlusion_mut(&mut self) -> &mut bool {
        self._glacier_base.check_occlusion_mut()
    }
    fn use_entity_direction(&self) -> &bool {
        self._glacier_base.use_entity_direction()
    }
    fn use_entity_direction_mut(&mut self) -> &mut bool {
        self._glacier_base.use_entity_direction_mut()
    }
}

impl super::game_shared::TriggerEventEntityDataTrait for LookAtTriggerEntityData {
}

impl super::game_shared::TriggerEntityDataTrait for LookAtTriggerEntityData {
    fn delay(&self) -> &f32 {
        self._glacier_base.delay()
    }
    fn delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.delay_mut()
    }
    fn run_once(&self) -> &bool {
        self._glacier_base.run_once()
    }
    fn run_once_mut(&mut self) -> &mut bool {
        self._glacier_base.run_once_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for LookAtTriggerEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for LookAtTriggerEntityData {
}

impl super::entity::GameObjectDataTrait for LookAtTriggerEntityData {
}

impl super::core::DataBusPeerTrait for LookAtTriggerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for LookAtTriggerEntityData {
}

impl super::core::DataContainerTrait for LookAtTriggerEntityData {
}

pub static LOOKATTRIGGERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LookAtTriggerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::game_shared::CHARACTERLOOKATTRIGGERENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LookAtTriggerEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SoldierWeapon",
                flags: MemberInfoFlags::new(0),
                field_type: "SoldierWeaponUnlockAsset",
                rust_offset: offset_of!(LookAtTriggerEntityData, soldier_weapon),
            },
            FieldInfoData {
                name: "ZoomLevel",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(LookAtTriggerEntityData, zoom_level),
            },
        ],
    }),
    array_type: Some(LOOKATTRIGGERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for LookAtTriggerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        LOOKATTRIGGERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LOOKATTRIGGERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LookAtTriggerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("LookAtTriggerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoldierSpawnReferenceObjectData {
    pub _glacier_base: super::game_shared::CharacterSpawnReferenceObjectData,
}

pub trait SoldierSpawnReferenceObjectDataTrait: super::game_shared::CharacterSpawnReferenceObjectDataTrait {
}

impl SoldierSpawnReferenceObjectDataTrait for SoldierSpawnReferenceObjectData {
}

impl super::game_shared::CharacterSpawnReferenceObjectDataTrait for SoldierSpawnReferenceObjectData {
    fn vehicle_entry_index(&self) -> &u32 {
        self._glacier_base.vehicle_entry_index()
    }
    fn vehicle_entry_index_mut(&mut self) -> &mut u32 {
        self._glacier_base.vehicle_entry_index_mut()
    }
    fn allow_fallback_on_next_availabe_vehicle_entry(&self) -> &bool {
        self._glacier_base.allow_fallback_on_next_availabe_vehicle_entry()
    }
    fn allow_fallback_on_next_availabe_vehicle_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.allow_fallback_on_next_availabe_vehicle_entry_mut()
    }
    fn template(&self) -> &Option<Arc<Mutex<dyn super::game_shared::CharacterSpawnTemplateDataTrait>>> {
        self._glacier_base.template()
    }
    fn template_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::game_shared::CharacterSpawnTemplateDataTrait>>> {
        self._glacier_base.template_mut()
    }
    fn spawn_visible(&self) -> &bool {
        self._glacier_base.spawn_visible()
    }
    fn spawn_visible_mut(&mut self) -> &mut bool {
        self._glacier_base.spawn_visible_mut()
    }
    fn human_target_preference(&self) -> &f32 {
        self._glacier_base.human_target_preference()
    }
    fn human_target_preference_mut(&mut self) -> &mut f32 {
        self._glacier_base.human_target_preference_mut()
    }
    fn is_target(&self) -> &bool {
        self._glacier_base.is_target()
    }
    fn is_target_mut(&mut self) -> &mut bool {
        self._glacier_base.is_target_mut()
    }
    fn affect_minimap_position(&self) -> &bool {
        self._glacier_base.affect_minimap_position()
    }
    fn affect_minimap_position_mut(&mut self) -> &mut bool {
        self._glacier_base.affect_minimap_position_mut()
    }
    fn show_as_label_only(&self) -> &bool {
        self._glacier_base.show_as_label_only()
    }
    fn show_as_label_only_mut(&mut self) -> &mut bool {
        self._glacier_base.show_as_label_only_mut()
    }
    fn show_in_menu(&self) -> &bool {
        self._glacier_base.show_in_menu()
    }
    fn show_in_menu_mut(&mut self) -> &mut bool {
        self._glacier_base.show_in_menu_mut()
    }
    fn menu_show_order(&self) -> &i32 {
        self._glacier_base.menu_show_order()
    }
    fn menu_show_order_mut(&mut self) -> &mut i32 {
        self._glacier_base.menu_show_order_mut()
    }
}

impl super::game_shared::SpawnReferenceObjectDataTrait for SoldierSpawnReferenceObjectData {
    fn team(&self) -> &super::gameplay_sim::TeamId {
        self._glacier_base.team()
    }
    fn team_mut(&mut self) -> &mut super::gameplay_sim::TeamId {
        self._glacier_base.team_mut()
    }
    fn locked_team(&self) -> &bool {
        self._glacier_base.locked_team()
    }
    fn locked_team_mut(&mut self) -> &mut bool {
        self._glacier_base.locked_team_mut()
    }
    fn spawn_area_radius(&self) -> &f32 {
        self._glacier_base.spawn_area_radius()
    }
    fn spawn_area_radius_mut(&mut self) -> &mut f32 {
        self._glacier_base.spawn_area_radius_mut()
    }
    fn spawn_protection_radius(&self) -> &f32 {
        self._glacier_base.spawn_protection_radius()
    }
    fn spawn_protection_radius_mut(&mut self) -> &mut f32 {
        self._glacier_base.spawn_protection_radius_mut()
    }
    fn spawn_protection_check_all_teams(&self) -> &bool {
        self._glacier_base.spawn_protection_check_all_teams()
    }
    fn spawn_protection_check_all_teams_mut(&mut self) -> &mut bool {
        self._glacier_base.spawn_protection_check_all_teams_mut()
    }
    fn spawn_protection_friendly_killed_count(&self) -> &u32 {
        self._glacier_base.spawn_protection_friendly_killed_count()
    }
    fn spawn_protection_friendly_killed_count_mut(&mut self) -> &mut u32 {
        self._glacier_base.spawn_protection_friendly_killed_count_mut()
    }
    fn spawn_protection_friendly_killed_time(&self) -> &f32 {
        self._glacier_base.spawn_protection_friendly_killed_time()
    }
    fn spawn_protection_friendly_killed_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.spawn_protection_friendly_killed_time_mut()
    }
    fn clear_bangers_on_spawn(&self) -> &bool {
        self._glacier_base.clear_bangers_on_spawn()
    }
    fn clear_bangers_on_spawn_mut(&mut self) -> &mut bool {
        self._glacier_base.clear_bangers_on_spawn_mut()
    }
    fn try_to_spawn_out_of_sight(&self) -> &bool {
        self._glacier_base.try_to_spawn_out_of_sight()
    }
    fn try_to_spawn_out_of_sight_mut(&mut self) -> &mut bool {
        self._glacier_base.try_to_spawn_out_of_sight_mut()
    }
    fn send_weapon_events(&self) -> &bool {
        self._glacier_base.send_weapon_events()
    }
    fn send_weapon_events_mut(&mut self) -> &mut bool {
        self._glacier_base.send_weapon_events_mut()
    }
    fn take_control_on_transform_change(&self) -> &bool {
        self._glacier_base.take_control_on_transform_change()
    }
    fn take_control_on_transform_change_mut(&mut self) -> &mut bool {
        self._glacier_base.take_control_on_transform_change_mut()
    }
    fn return_control_on_idle(&self) -> &bool {
        self._glacier_base.return_control_on_idle()
    }
    fn return_control_on_idle_mut(&mut self) -> &mut bool {
        self._glacier_base.return_control_on_idle_mut()
    }
    fn take_control_entry_index(&self) -> &i32 {
        self._glacier_base.take_control_entry_index()
    }
    fn take_control_entry_index_mut(&mut self) -> &mut i32 {
        self._glacier_base.take_control_entry_index_mut()
    }
    fn rotation_yaw(&self) -> &f32 {
        self._glacier_base.rotation_yaw()
    }
    fn rotation_yaw_mut(&mut self) -> &mut f32 {
        self._glacier_base.rotation_yaw_mut()
    }
    fn rotation_pitch(&self) -> &f32 {
        self._glacier_base.rotation_pitch()
    }
    fn rotation_pitch_mut(&mut self) -> &mut f32 {
        self._glacier_base.rotation_pitch_mut()
    }
    fn rotation_roll(&self) -> &f32 {
        self._glacier_base.rotation_roll()
    }
    fn rotation_roll_mut(&mut self) -> &mut f32 {
        self._glacier_base.rotation_roll_mut()
    }
    fn throttle(&self) -> &f32 {
        self._glacier_base.throttle()
    }
    fn throttle_mut(&mut self) -> &mut f32 {
        self._glacier_base.throttle_mut()
    }
    fn time_delta_type(&self) -> &super::entity::TimeDeltaType {
        self._glacier_base.time_delta_type()
    }
    fn time_delta_type_mut(&mut self) -> &mut super::entity::TimeDeltaType {
        self._glacier_base.time_delta_type_mut()
    }
    fn max_unspawn_in_frame(&self) -> &i32 {
        self._glacier_base.max_unspawn_in_frame()
    }
    fn max_unspawn_in_frame_mut(&mut self) -> &mut i32 {
        self._glacier_base.max_unspawn_in_frame_mut()
    }
}

impl super::gameplay_sim::GameplaySpawnReferenceObjectDataTrait for SoldierSpawnReferenceObjectData {
    fn extra_spawn_data(&self) -> &Vec<Option<Arc<Mutex<dyn super::gameplay_sim::ExtraSpawnDataTrait>>>> {
        self._glacier_base.extra_spawn_data()
    }
    fn extra_spawn_data_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::gameplay_sim::ExtraSpawnDataTrait>>>> {
        self._glacier_base.extra_spawn_data_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
    fn location_name_sid(&self) -> &String {
        self._glacier_base.location_name_sid()
    }
    fn location_name_sid_mut(&mut self) -> &mut String {
        self._glacier_base.location_name_sid_mut()
    }
    fn location_text_sid(&self) -> &String {
        self._glacier_base.location_text_sid()
    }
    fn location_text_sid_mut(&mut self) -> &mut String {
        self._glacier_base.location_text_sid_mut()
    }
    fn initial_auto_spawn(&self) -> &bool {
        self._glacier_base.initial_auto_spawn()
    }
    fn initial_auto_spawn_mut(&mut self) -> &mut bool {
        self._glacier_base.initial_auto_spawn_mut()
    }
    fn auto_spawn(&self) -> &bool {
        self._glacier_base.auto_spawn()
    }
    fn auto_spawn_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_spawn_mut()
    }
    fn queue_spawn_event(&self) -> &bool {
        self._glacier_base.queue_spawn_event()
    }
    fn queue_spawn_event_mut(&mut self) -> &mut bool {
        self._glacier_base.queue_spawn_event_mut()
    }
    fn use_as_spawn_point(&self) -> &bool {
        self._glacier_base.use_as_spawn_point()
    }
    fn use_as_spawn_point_mut(&mut self) -> &mut bool {
        self._glacier_base.use_as_spawn_point_mut()
    }
    fn initial_spawn_delay(&self) -> &f32 {
        self._glacier_base.initial_spawn_delay()
    }
    fn initial_spawn_delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.initial_spawn_delay_mut()
    }
    fn spawn_delay(&self) -> &f32 {
        self._glacier_base.spawn_delay()
    }
    fn spawn_delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.spawn_delay_mut()
    }
    fn max_count(&self) -> &i32 {
        self._glacier_base.max_count()
    }
    fn max_count_mut(&mut self) -> &mut i32 {
        self._glacier_base.max_count_mut()
    }
    fn max_count_simultaneously(&self) -> &i32 {
        self._glacier_base.max_count_simultaneously()
    }
    fn max_count_simultaneously_mut(&mut self) -> &mut i32 {
        self._glacier_base.max_count_simultaneously_mut()
    }
    fn total_count_simultaneously_of_type(&self) -> &i32 {
        self._glacier_base.total_count_simultaneously_of_type()
    }
    fn total_count_simultaneously_of_type_mut(&mut self) -> &mut i32 {
        self._glacier_base.total_count_simultaneously_of_type_mut()
    }
    fn max_spawn_in_frame(&self) -> &i32 {
        self._glacier_base.max_spawn_in_frame()
    }
    fn max_spawn_in_frame_mut(&mut self) -> &mut i32 {
        self._glacier_base.max_spawn_in_frame_mut()
    }
    fn only_send_event_for_human_players(&self) -> &bool {
        self._glacier_base.only_send_event_for_human_players()
    }
    fn only_send_event_for_human_players_mut(&mut self) -> &mut bool {
        self._glacier_base.only_send_event_for_human_players_mut()
    }
    fn controllable_transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.controllable_transform()
    }
    fn controllable_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.controllable_transform_mut()
    }
    fn controllable_input(&self) -> &super::core::LinearTransform {
        self._glacier_base.controllable_input()
    }
    fn controllable_input_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.controllable_input_mut()
    }
}

impl super::entity::SpatialReferenceObjectDataTrait for SoldierSpawnReferenceObjectData {
    fn local_player_id(&self) -> &super::core::LocalPlayerId {
        self._glacier_base.local_player_id()
    }
    fn local_player_id_mut(&mut self) -> &mut super::core::LocalPlayerId {
        self._glacier_base.local_player_id_mut()
    }
}

impl super::entity::ReferenceObjectDataTrait for SoldierSpawnReferenceObjectData {
    fn blueprint_transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.blueprint_transform()
    }
    fn blueprint_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.blueprint_transform_mut()
    }
    fn blueprint(&self) -> &Option<Arc<Mutex<dyn super::entity::BlueprintTrait>>> {
        self._glacier_base.blueprint()
    }
    fn blueprint_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::BlueprintTrait>>> {
        self._glacier_base.blueprint_mut()
    }
    fn object_variation(&self) -> &Option<Arc<Mutex<dyn super::entity::ObjectVariationTrait>>> {
        self._glacier_base.object_variation()
    }
    fn object_variation_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::ObjectVariationTrait>>> {
        self._glacier_base.object_variation_mut()
    }
    fn stream_realm(&self) -> &super::entity::StreamRealm {
        self._glacier_base.stream_realm()
    }
    fn stream_realm_mut(&mut self) -> &mut super::entity::StreamRealm {
        self._glacier_base.stream_realm_mut()
    }
    fn radiosity_type_override(&self) -> &super::core::RadiosityTypeOverride {
        self._glacier_base.radiosity_type_override()
    }
    fn radiosity_type_override_mut(&mut self) -> &mut super::core::RadiosityTypeOverride {
        self._glacier_base.radiosity_type_override_mut()
    }
    fn lightmap_resolution_scale(&self) -> &u32 {
        self._glacier_base.lightmap_resolution_scale()
    }
    fn lightmap_resolution_scale_mut(&mut self) -> &mut u32 {
        self._glacier_base.lightmap_resolution_scale_mut()
    }
    fn lightmap_scale_with_size(&self) -> &bool {
        self._glacier_base.lightmap_scale_with_size()
    }
    fn lightmap_scale_with_size_mut(&mut self) -> &mut bool {
        self._glacier_base.lightmap_scale_with_size_mut()
    }
    fn rendering_overrides(&self) -> &super::core::RenderingOverrides {
        self._glacier_base.rendering_overrides()
    }
    fn rendering_overrides_mut(&mut self) -> &mut super::core::RenderingOverrides {
        self._glacier_base.rendering_overrides_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
    fn create_indestructible_entity(&self) -> &bool {
        self._glacier_base.create_indestructible_entity()
    }
    fn create_indestructible_entity_mut(&mut self) -> &mut bool {
        self._glacier_base.create_indestructible_entity_mut()
    }
}

impl super::entity::GameObjectDataTrait for SoldierSpawnReferenceObjectData {
}

impl super::core::DataBusPeerTrait for SoldierSpawnReferenceObjectData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SoldierSpawnReferenceObjectData {
}

impl super::core::DataContainerTrait for SoldierSpawnReferenceObjectData {
}

pub static SOLDIERSPAWNREFERENCEOBJECTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierSpawnReferenceObjectData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::game_shared::CHARACTERSPAWNREFERENCEOBJECTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierSpawnReferenceObjectData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SOLDIERSPAWNREFERENCEOBJECTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SoldierSpawnReferenceObjectData {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERSPAWNREFERENCEOBJECTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOLDIERSPAWNREFERENCEOBJECTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierSpawnReferenceObjectData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SoldierSpawnReferenceObjectData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CustomizeSoldierEntityData {
    pub _glacier_base: super::game_shared::CustomizeBaseEntityData,
    pub auto_preload_on_creation: bool,
    pub customize_soldier_data: Option<Arc<Mutex<dyn CustomizeSoldierDataTrait>>>,
}

pub trait CustomizeSoldierEntityDataTrait: super::game_shared::CustomizeBaseEntityDataTrait {
    fn auto_preload_on_creation(&self) -> &bool;
    fn auto_preload_on_creation_mut(&mut self) -> &mut bool;
    fn customize_soldier_data(&self) -> &Option<Arc<Mutex<dyn CustomizeSoldierDataTrait>>>;
    fn customize_soldier_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CustomizeSoldierDataTrait>>>;
}

impl CustomizeSoldierEntityDataTrait for CustomizeSoldierEntityData {
    fn auto_preload_on_creation(&self) -> &bool {
        &self.auto_preload_on_creation
    }
    fn auto_preload_on_creation_mut(&mut self) -> &mut bool {
        &mut self.auto_preload_on_creation
    }
    fn customize_soldier_data(&self) -> &Option<Arc<Mutex<dyn CustomizeSoldierDataTrait>>> {
        &self.customize_soldier_data
    }
    fn customize_soldier_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CustomizeSoldierDataTrait>>> {
        &mut self.customize_soldier_data
    }
}

impl super::game_shared::CustomizeBaseEntityDataTrait for CustomizeSoldierEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
}

impl super::entity::EntityDataTrait for CustomizeSoldierEntityData {
}

impl super::entity::GameObjectDataTrait for CustomizeSoldierEntityData {
}

impl super::core::DataBusPeerTrait for CustomizeSoldierEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CustomizeSoldierEntityData {
}

impl super::core::DataContainerTrait for CustomizeSoldierEntityData {
}

pub static CUSTOMIZESOLDIERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomizeSoldierEntityData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::game_shared::CUSTOMIZEBASEENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CustomizeSoldierEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AutoPreloadOnCreation",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CustomizeSoldierEntityData, auto_preload_on_creation),
            },
            FieldInfoData {
                name: "CustomizeSoldierData",
                flags: MemberInfoFlags::new(0),
                field_type: "CustomizeSoldierData",
                rust_offset: offset_of!(CustomizeSoldierEntityData, customize_soldier_data),
            },
        ],
    }),
    array_type: Some(CUSTOMIZESOLDIERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CustomizeSoldierEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CUSTOMIZESOLDIERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CUSTOMIZESOLDIERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomizeSoldierEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("CustomizeSoldierEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoldierSpawnAppearanceTemplateData {
    pub _glacier_base: super::core::Asset,
    pub body: u32,
}

pub trait SoldierSpawnAppearanceTemplateDataTrait: super::core::AssetTrait {
    fn body(&self) -> &u32;
    fn body_mut(&mut self) -> &mut u32;
}

impl SoldierSpawnAppearanceTemplateDataTrait for SoldierSpawnAppearanceTemplateData {
    fn body(&self) -> &u32 {
        &self.body
    }
    fn body_mut(&mut self) -> &mut u32 {
        &mut self.body
    }
}

impl super::core::AssetTrait for SoldierSpawnAppearanceTemplateData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for SoldierSpawnAppearanceTemplateData {
}

pub static SOLDIERSPAWNAPPEARANCETEMPLATEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierSpawnAppearanceTemplateData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierSpawnAppearanceTemplateData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Body",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(SoldierSpawnAppearanceTemplateData, body),
            },
        ],
    }),
    array_type: Some(SOLDIERSPAWNAPPEARANCETEMPLATEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoldierSpawnAppearanceTemplateData {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERSPAWNAPPEARANCETEMPLATEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOLDIERSPAWNAPPEARANCETEMPLATEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierSpawnAppearanceTemplateData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SoldierSpawnAppearanceTemplateData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoldierSpawnKitTemplateData {
    pub _glacier_base: super::core::Asset,
    pub kit: u32,
    pub main_gun: u32,
}

pub trait SoldierSpawnKitTemplateDataTrait: super::core::AssetTrait {
    fn kit(&self) -> &u32;
    fn kit_mut(&mut self) -> &mut u32;
    fn main_gun(&self) -> &u32;
    fn main_gun_mut(&mut self) -> &mut u32;
}

impl SoldierSpawnKitTemplateDataTrait for SoldierSpawnKitTemplateData {
    fn kit(&self) -> &u32 {
        &self.kit
    }
    fn kit_mut(&mut self) -> &mut u32 {
        &mut self.kit
    }
    fn main_gun(&self) -> &u32 {
        &self.main_gun
    }
    fn main_gun_mut(&mut self) -> &mut u32 {
        &mut self.main_gun
    }
}

impl super::core::AssetTrait for SoldierSpawnKitTemplateData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for SoldierSpawnKitTemplateData {
}

pub static SOLDIERSPAWNKITTEMPLATEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierSpawnKitTemplateData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierSpawnKitTemplateData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Kit",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(SoldierSpawnKitTemplateData, kit),
            },
            FieldInfoData {
                name: "MainGun",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(SoldierSpawnKitTemplateData, main_gun),
            },
        ],
    }),
    array_type: Some(SOLDIERSPAWNKITTEMPLATEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoldierSpawnKitTemplateData {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERSPAWNKITTEMPLATEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOLDIERSPAWNKITTEMPLATEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierSpawnKitTemplateData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SoldierSpawnKitTemplateData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoldierWeaponSwitchingData {
    pub _glacier_base: super::core::Asset,
    pub switch_map: Vec<WeaponSwitchingMapData>,
    pub direct_switch_map: Vec<DirectWeaponSwitchingMapData>,
    pub auto_drop_slots: Vec<WeaponSwitchingEnum>,
    pub toggle_action: i32,
    pub toggle_max_hold_time: f32,
    pub always_use_max_hold_times: bool,
}

pub trait SoldierWeaponSwitchingDataTrait: super::core::AssetTrait {
    fn switch_map(&self) -> &Vec<WeaponSwitchingMapData>;
    fn switch_map_mut(&mut self) -> &mut Vec<WeaponSwitchingMapData>;
    fn direct_switch_map(&self) -> &Vec<DirectWeaponSwitchingMapData>;
    fn direct_switch_map_mut(&mut self) -> &mut Vec<DirectWeaponSwitchingMapData>;
    fn auto_drop_slots(&self) -> &Vec<WeaponSwitchingEnum>;
    fn auto_drop_slots_mut(&mut self) -> &mut Vec<WeaponSwitchingEnum>;
    fn toggle_action(&self) -> &i32;
    fn toggle_action_mut(&mut self) -> &mut i32;
    fn toggle_max_hold_time(&self) -> &f32;
    fn toggle_max_hold_time_mut(&mut self) -> &mut f32;
    fn always_use_max_hold_times(&self) -> &bool;
    fn always_use_max_hold_times_mut(&mut self) -> &mut bool;
}

impl SoldierWeaponSwitchingDataTrait for SoldierWeaponSwitchingData {
    fn switch_map(&self) -> &Vec<WeaponSwitchingMapData> {
        &self.switch_map
    }
    fn switch_map_mut(&mut self) -> &mut Vec<WeaponSwitchingMapData> {
        &mut self.switch_map
    }
    fn direct_switch_map(&self) -> &Vec<DirectWeaponSwitchingMapData> {
        &self.direct_switch_map
    }
    fn direct_switch_map_mut(&mut self) -> &mut Vec<DirectWeaponSwitchingMapData> {
        &mut self.direct_switch_map
    }
    fn auto_drop_slots(&self) -> &Vec<WeaponSwitchingEnum> {
        &self.auto_drop_slots
    }
    fn auto_drop_slots_mut(&mut self) -> &mut Vec<WeaponSwitchingEnum> {
        &mut self.auto_drop_slots
    }
    fn toggle_action(&self) -> &i32 {
        &self.toggle_action
    }
    fn toggle_action_mut(&mut self) -> &mut i32 {
        &mut self.toggle_action
    }
    fn toggle_max_hold_time(&self) -> &f32 {
        &self.toggle_max_hold_time
    }
    fn toggle_max_hold_time_mut(&mut self) -> &mut f32 {
        &mut self.toggle_max_hold_time
    }
    fn always_use_max_hold_times(&self) -> &bool {
        &self.always_use_max_hold_times
    }
    fn always_use_max_hold_times_mut(&mut self) -> &mut bool {
        &mut self.always_use_max_hold_times
    }
}

impl super::core::AssetTrait for SoldierWeaponSwitchingData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for SoldierWeaponSwitchingData {
}

pub static SOLDIERWEAPONSWITCHINGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierWeaponSwitchingData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierWeaponSwitchingData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SwitchMap",
                flags: MemberInfoFlags::new(144),
                field_type: "WeaponSwitchingMapData-Array",
                rust_offset: offset_of!(SoldierWeaponSwitchingData, switch_map),
            },
            FieldInfoData {
                name: "DirectSwitchMap",
                flags: MemberInfoFlags::new(144),
                field_type: "DirectWeaponSwitchingMapData-Array",
                rust_offset: offset_of!(SoldierWeaponSwitchingData, direct_switch_map),
            },
            FieldInfoData {
                name: "AutoDropSlots",
                flags: MemberInfoFlags::new(144),
                field_type: "WeaponSwitchingEnum-Array",
                rust_offset: offset_of!(SoldierWeaponSwitchingData, auto_drop_slots),
            },
            FieldInfoData {
                name: "ToggleAction",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SoldierWeaponSwitchingData, toggle_action),
            },
            FieldInfoData {
                name: "ToggleMaxHoldTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierWeaponSwitchingData, toggle_max_hold_time),
            },
            FieldInfoData {
                name: "AlwaysUseMaxHoldTimes",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierWeaponSwitchingData, always_use_max_hold_times),
            },
        ],
    }),
    array_type: Some(SOLDIERWEAPONSWITCHINGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoldierWeaponSwitchingData {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERWEAPONSWITCHINGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOLDIERWEAPONSWITCHINGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierWeaponSwitchingData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SoldierWeaponSwitchingData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DirectWeaponSwitchingMapData {
    pub action: i32,
    pub max_hold_time: f32,
    pub to_weapon: WeaponSwitchingEnum,
    pub fire_and_switch_back_to_prev: bool,
    pub fire_until_action_released: bool,
    pub switch_back_to_prev_max_time_pressed: f32,
    pub use_quick_switch: bool,
    pub prevent_melee_repeat_time: f32,
}

pub trait DirectWeaponSwitchingMapDataTrait: TypeObject {
    fn action(&self) -> &i32;
    fn action_mut(&mut self) -> &mut i32;
    fn max_hold_time(&self) -> &f32;
    fn max_hold_time_mut(&mut self) -> &mut f32;
    fn to_weapon(&self) -> &WeaponSwitchingEnum;
    fn to_weapon_mut(&mut self) -> &mut WeaponSwitchingEnum;
    fn fire_and_switch_back_to_prev(&self) -> &bool;
    fn fire_and_switch_back_to_prev_mut(&mut self) -> &mut bool;
    fn fire_until_action_released(&self) -> &bool;
    fn fire_until_action_released_mut(&mut self) -> &mut bool;
    fn switch_back_to_prev_max_time_pressed(&self) -> &f32;
    fn switch_back_to_prev_max_time_pressed_mut(&mut self) -> &mut f32;
    fn use_quick_switch(&self) -> &bool;
    fn use_quick_switch_mut(&mut self) -> &mut bool;
    fn prevent_melee_repeat_time(&self) -> &f32;
    fn prevent_melee_repeat_time_mut(&mut self) -> &mut f32;
}

impl DirectWeaponSwitchingMapDataTrait for DirectWeaponSwitchingMapData {
    fn action(&self) -> &i32 {
        &self.action
    }
    fn action_mut(&mut self) -> &mut i32 {
        &mut self.action
    }
    fn max_hold_time(&self) -> &f32 {
        &self.max_hold_time
    }
    fn max_hold_time_mut(&mut self) -> &mut f32 {
        &mut self.max_hold_time
    }
    fn to_weapon(&self) -> &WeaponSwitchingEnum {
        &self.to_weapon
    }
    fn to_weapon_mut(&mut self) -> &mut WeaponSwitchingEnum {
        &mut self.to_weapon
    }
    fn fire_and_switch_back_to_prev(&self) -> &bool {
        &self.fire_and_switch_back_to_prev
    }
    fn fire_and_switch_back_to_prev_mut(&mut self) -> &mut bool {
        &mut self.fire_and_switch_back_to_prev
    }
    fn fire_until_action_released(&self) -> &bool {
        &self.fire_until_action_released
    }
    fn fire_until_action_released_mut(&mut self) -> &mut bool {
        &mut self.fire_until_action_released
    }
    fn switch_back_to_prev_max_time_pressed(&self) -> &f32 {
        &self.switch_back_to_prev_max_time_pressed
    }
    fn switch_back_to_prev_max_time_pressed_mut(&mut self) -> &mut f32 {
        &mut self.switch_back_to_prev_max_time_pressed
    }
    fn use_quick_switch(&self) -> &bool {
        &self.use_quick_switch
    }
    fn use_quick_switch_mut(&mut self) -> &mut bool {
        &mut self.use_quick_switch
    }
    fn prevent_melee_repeat_time(&self) -> &f32 {
        &self.prevent_melee_repeat_time
    }
    fn prevent_melee_repeat_time_mut(&mut self) -> &mut f32 {
        &mut self.prevent_melee_repeat_time
    }
}

pub static DIRECTWEAPONSWITCHINGMAPDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DirectWeaponSwitchingMapData",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DirectWeaponSwitchingMapData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Action",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(DirectWeaponSwitchingMapData, action),
            },
            FieldInfoData {
                name: "MaxHoldTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DirectWeaponSwitchingMapData, max_hold_time),
            },
            FieldInfoData {
                name: "ToWeapon",
                flags: MemberInfoFlags::new(0),
                field_type: "WeaponSwitchingEnum",
                rust_offset: offset_of!(DirectWeaponSwitchingMapData, to_weapon),
            },
            FieldInfoData {
                name: "FireAndSwitchBackToPrev",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DirectWeaponSwitchingMapData, fire_and_switch_back_to_prev),
            },
            FieldInfoData {
                name: "FireUntilActionReleased",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DirectWeaponSwitchingMapData, fire_until_action_released),
            },
            FieldInfoData {
                name: "SwitchBackToPrevMaxTimePressed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DirectWeaponSwitchingMapData, switch_back_to_prev_max_time_pressed),
            },
            FieldInfoData {
                name: "UseQuickSwitch",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DirectWeaponSwitchingMapData, use_quick_switch),
            },
            FieldInfoData {
                name: "PreventMeleeRepeatTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DirectWeaponSwitchingMapData, prevent_melee_repeat_time),
            },
        ],
    }),
    array_type: Some(DIRECTWEAPONSWITCHINGMAPDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for DirectWeaponSwitchingMapData {
    fn type_info(&self) -> &'static TypeInfo {
        DIRECTWEAPONSWITCHINGMAPDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static DIRECTWEAPONSWITCHINGMAPDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DirectWeaponSwitchingMapData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("DirectWeaponSwitchingMapData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WeaponSwitchingMapData {
    pub from_weapon: WeaponSwitchingEnum,
    pub action: i32,
    pub max_hold_time: f32,
    pub to_weapon: Vec<WeaponSwitchingEnum>,
    pub fire_and_switch_back_to_prev: bool,
}

pub trait WeaponSwitchingMapDataTrait: TypeObject {
    fn from_weapon(&self) -> &WeaponSwitchingEnum;
    fn from_weapon_mut(&mut self) -> &mut WeaponSwitchingEnum;
    fn action(&self) -> &i32;
    fn action_mut(&mut self) -> &mut i32;
    fn max_hold_time(&self) -> &f32;
    fn max_hold_time_mut(&mut self) -> &mut f32;
    fn to_weapon(&self) -> &Vec<WeaponSwitchingEnum>;
    fn to_weapon_mut(&mut self) -> &mut Vec<WeaponSwitchingEnum>;
    fn fire_and_switch_back_to_prev(&self) -> &bool;
    fn fire_and_switch_back_to_prev_mut(&mut self) -> &mut bool;
}

impl WeaponSwitchingMapDataTrait for WeaponSwitchingMapData {
    fn from_weapon(&self) -> &WeaponSwitchingEnum {
        &self.from_weapon
    }
    fn from_weapon_mut(&mut self) -> &mut WeaponSwitchingEnum {
        &mut self.from_weapon
    }
    fn action(&self) -> &i32 {
        &self.action
    }
    fn action_mut(&mut self) -> &mut i32 {
        &mut self.action
    }
    fn max_hold_time(&self) -> &f32 {
        &self.max_hold_time
    }
    fn max_hold_time_mut(&mut self) -> &mut f32 {
        &mut self.max_hold_time
    }
    fn to_weapon(&self) -> &Vec<WeaponSwitchingEnum> {
        &self.to_weapon
    }
    fn to_weapon_mut(&mut self) -> &mut Vec<WeaponSwitchingEnum> {
        &mut self.to_weapon
    }
    fn fire_and_switch_back_to_prev(&self) -> &bool {
        &self.fire_and_switch_back_to_prev
    }
    fn fire_and_switch_back_to_prev_mut(&mut self) -> &mut bool {
        &mut self.fire_and_switch_back_to_prev
    }
}

pub static WEAPONSWITCHINGMAPDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponSwitchingMapData",
    flags: MemberInfoFlags::new(73),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WeaponSwitchingMapData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "FromWeapon",
                flags: MemberInfoFlags::new(0),
                field_type: "WeaponSwitchingEnum",
                rust_offset: offset_of!(WeaponSwitchingMapData, from_weapon),
            },
            FieldInfoData {
                name: "Action",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(WeaponSwitchingMapData, action),
            },
            FieldInfoData {
                name: "MaxHoldTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WeaponSwitchingMapData, max_hold_time),
            },
            FieldInfoData {
                name: "ToWeapon",
                flags: MemberInfoFlags::new(144),
                field_type: "WeaponSwitchingEnum-Array",
                rust_offset: offset_of!(WeaponSwitchingMapData, to_weapon),
            },
            FieldInfoData {
                name: "FireAndSwitchBackToPrev",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WeaponSwitchingMapData, fire_and_switch_back_to_prev),
            },
        ],
    }),
    array_type: Some(WEAPONSWITCHINGMAPDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WeaponSwitchingMapData {
    fn type_info(&self) -> &'static TypeInfo {
        WEAPONSWITCHINGMAPDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static WEAPONSWITCHINGMAPDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponSwitchingMapData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("WeaponSwitchingMapData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum WeaponSwitchingEnum {
    #[default]
    wsSlot0 = 0,
    wsSlot1 = 1,
    wsSlot2 = 2,
    wsSlot3 = 3,
    wsSlot4 = 4,
    wsSlot5 = 5,
    wsSlot6 = 6,
    wsSlot7 = 7,
    wsSlot8 = 8,
    wsSlot9 = 9,
    wsMaxSlots = 10,
    wsLastPrimary = 11,
    wsOtherPrimary = 12,
    wsNotUsed = 13,
}

pub static WEAPONSWITCHINGENUM_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponSwitchingEnum",
    flags: MemberInfoFlags::new(49429),
    module: "SoldierShared",
    data: TypeInfoData::Enum,
    array_type: Some(WEAPONSWITCHINGENUM_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for WeaponSwitchingEnum {
    fn type_info(&self) -> &'static TypeInfo {
        WEAPONSWITCHINGENUM_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static WEAPONSWITCHINGENUM_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponSwitchingEnum-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("WeaponSwitchingEnum"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoldierInputSettings {
    pub _glacier_base: super::input_shared::BaseInputSettings,
    pub toggle_pose_action: i32,
    pub crouch_action: i32,
    pub crouch_and_hold_action: i32,
    pub pickup_interaction_action: i32,
    pub pickup_interaction_action_keyboard: i32,
    pub prone_to_stand_on_jump: bool,
    pub stand_automatically_if_sprinting: bool,
    pub sprint_release_time: f32,
    pub throttle_input_required_for_sprint: f32,
    pub disable_crouch: bool,
    pub disable_prone: bool,
    pub disable_crawling_while_firing: bool,
    pub disable_crawling_while_reloading: bool,
    pub disable_firing_while_deploying_bipod: bool,
    pub disable_firing_while_jumping: bool,
    pub disable_sprinting_while_reloading: bool,
    pub disable_sprinting_while_firing: bool,
    pub double_tap_sprint_enabled: bool,
    pub enable_sprint_to_crouch_transition: bool,
    pub stop_sprinting_when_releasing_throttle: bool,
    pub stop_sprinting_when_releasing_sprint: bool,
    pub wait_for_sprint_release_before_sprint_again: bool,
    pub firing_disabling_transitions: Vec<PoseTransition>,
    pub enter_vehicle_hold_time: f32,
}

pub trait SoldierInputSettingsTrait: super::input_shared::BaseInputSettingsTrait {
    fn toggle_pose_action(&self) -> &i32;
    fn toggle_pose_action_mut(&mut self) -> &mut i32;
    fn crouch_action(&self) -> &i32;
    fn crouch_action_mut(&mut self) -> &mut i32;
    fn crouch_and_hold_action(&self) -> &i32;
    fn crouch_and_hold_action_mut(&mut self) -> &mut i32;
    fn pickup_interaction_action(&self) -> &i32;
    fn pickup_interaction_action_mut(&mut self) -> &mut i32;
    fn pickup_interaction_action_keyboard(&self) -> &i32;
    fn pickup_interaction_action_keyboard_mut(&mut self) -> &mut i32;
    fn prone_to_stand_on_jump(&self) -> &bool;
    fn prone_to_stand_on_jump_mut(&mut self) -> &mut bool;
    fn stand_automatically_if_sprinting(&self) -> &bool;
    fn stand_automatically_if_sprinting_mut(&mut self) -> &mut bool;
    fn sprint_release_time(&self) -> &f32;
    fn sprint_release_time_mut(&mut self) -> &mut f32;
    fn throttle_input_required_for_sprint(&self) -> &f32;
    fn throttle_input_required_for_sprint_mut(&mut self) -> &mut f32;
    fn disable_crouch(&self) -> &bool;
    fn disable_crouch_mut(&mut self) -> &mut bool;
    fn disable_prone(&self) -> &bool;
    fn disable_prone_mut(&mut self) -> &mut bool;
    fn disable_crawling_while_firing(&self) -> &bool;
    fn disable_crawling_while_firing_mut(&mut self) -> &mut bool;
    fn disable_crawling_while_reloading(&self) -> &bool;
    fn disable_crawling_while_reloading_mut(&mut self) -> &mut bool;
    fn disable_firing_while_deploying_bipod(&self) -> &bool;
    fn disable_firing_while_deploying_bipod_mut(&mut self) -> &mut bool;
    fn disable_firing_while_jumping(&self) -> &bool;
    fn disable_firing_while_jumping_mut(&mut self) -> &mut bool;
    fn disable_sprinting_while_reloading(&self) -> &bool;
    fn disable_sprinting_while_reloading_mut(&mut self) -> &mut bool;
    fn disable_sprinting_while_firing(&self) -> &bool;
    fn disable_sprinting_while_firing_mut(&mut self) -> &mut bool;
    fn double_tap_sprint_enabled(&self) -> &bool;
    fn double_tap_sprint_enabled_mut(&mut self) -> &mut bool;
    fn enable_sprint_to_crouch_transition(&self) -> &bool;
    fn enable_sprint_to_crouch_transition_mut(&mut self) -> &mut bool;
    fn stop_sprinting_when_releasing_throttle(&self) -> &bool;
    fn stop_sprinting_when_releasing_throttle_mut(&mut self) -> &mut bool;
    fn stop_sprinting_when_releasing_sprint(&self) -> &bool;
    fn stop_sprinting_when_releasing_sprint_mut(&mut self) -> &mut bool;
    fn wait_for_sprint_release_before_sprint_again(&self) -> &bool;
    fn wait_for_sprint_release_before_sprint_again_mut(&mut self) -> &mut bool;
    fn firing_disabling_transitions(&self) -> &Vec<PoseTransition>;
    fn firing_disabling_transitions_mut(&mut self) -> &mut Vec<PoseTransition>;
    fn enter_vehicle_hold_time(&self) -> &f32;
    fn enter_vehicle_hold_time_mut(&mut self) -> &mut f32;
}

impl SoldierInputSettingsTrait for SoldierInputSettings {
    fn toggle_pose_action(&self) -> &i32 {
        &self.toggle_pose_action
    }
    fn toggle_pose_action_mut(&mut self) -> &mut i32 {
        &mut self.toggle_pose_action
    }
    fn crouch_action(&self) -> &i32 {
        &self.crouch_action
    }
    fn crouch_action_mut(&mut self) -> &mut i32 {
        &mut self.crouch_action
    }
    fn crouch_and_hold_action(&self) -> &i32 {
        &self.crouch_and_hold_action
    }
    fn crouch_and_hold_action_mut(&mut self) -> &mut i32 {
        &mut self.crouch_and_hold_action
    }
    fn pickup_interaction_action(&self) -> &i32 {
        &self.pickup_interaction_action
    }
    fn pickup_interaction_action_mut(&mut self) -> &mut i32 {
        &mut self.pickup_interaction_action
    }
    fn pickup_interaction_action_keyboard(&self) -> &i32 {
        &self.pickup_interaction_action_keyboard
    }
    fn pickup_interaction_action_keyboard_mut(&mut self) -> &mut i32 {
        &mut self.pickup_interaction_action_keyboard
    }
    fn prone_to_stand_on_jump(&self) -> &bool {
        &self.prone_to_stand_on_jump
    }
    fn prone_to_stand_on_jump_mut(&mut self) -> &mut bool {
        &mut self.prone_to_stand_on_jump
    }
    fn stand_automatically_if_sprinting(&self) -> &bool {
        &self.stand_automatically_if_sprinting
    }
    fn stand_automatically_if_sprinting_mut(&mut self) -> &mut bool {
        &mut self.stand_automatically_if_sprinting
    }
    fn sprint_release_time(&self) -> &f32 {
        &self.sprint_release_time
    }
    fn sprint_release_time_mut(&mut self) -> &mut f32 {
        &mut self.sprint_release_time
    }
    fn throttle_input_required_for_sprint(&self) -> &f32 {
        &self.throttle_input_required_for_sprint
    }
    fn throttle_input_required_for_sprint_mut(&mut self) -> &mut f32 {
        &mut self.throttle_input_required_for_sprint
    }
    fn disable_crouch(&self) -> &bool {
        &self.disable_crouch
    }
    fn disable_crouch_mut(&mut self) -> &mut bool {
        &mut self.disable_crouch
    }
    fn disable_prone(&self) -> &bool {
        &self.disable_prone
    }
    fn disable_prone_mut(&mut self) -> &mut bool {
        &mut self.disable_prone
    }
    fn disable_crawling_while_firing(&self) -> &bool {
        &self.disable_crawling_while_firing
    }
    fn disable_crawling_while_firing_mut(&mut self) -> &mut bool {
        &mut self.disable_crawling_while_firing
    }
    fn disable_crawling_while_reloading(&self) -> &bool {
        &self.disable_crawling_while_reloading
    }
    fn disable_crawling_while_reloading_mut(&mut self) -> &mut bool {
        &mut self.disable_crawling_while_reloading
    }
    fn disable_firing_while_deploying_bipod(&self) -> &bool {
        &self.disable_firing_while_deploying_bipod
    }
    fn disable_firing_while_deploying_bipod_mut(&mut self) -> &mut bool {
        &mut self.disable_firing_while_deploying_bipod
    }
    fn disable_firing_while_jumping(&self) -> &bool {
        &self.disable_firing_while_jumping
    }
    fn disable_firing_while_jumping_mut(&mut self) -> &mut bool {
        &mut self.disable_firing_while_jumping
    }
    fn disable_sprinting_while_reloading(&self) -> &bool {
        &self.disable_sprinting_while_reloading
    }
    fn disable_sprinting_while_reloading_mut(&mut self) -> &mut bool {
        &mut self.disable_sprinting_while_reloading
    }
    fn disable_sprinting_while_firing(&self) -> &bool {
        &self.disable_sprinting_while_firing
    }
    fn disable_sprinting_while_firing_mut(&mut self) -> &mut bool {
        &mut self.disable_sprinting_while_firing
    }
    fn double_tap_sprint_enabled(&self) -> &bool {
        &self.double_tap_sprint_enabled
    }
    fn double_tap_sprint_enabled_mut(&mut self) -> &mut bool {
        &mut self.double_tap_sprint_enabled
    }
    fn enable_sprint_to_crouch_transition(&self) -> &bool {
        &self.enable_sprint_to_crouch_transition
    }
    fn enable_sprint_to_crouch_transition_mut(&mut self) -> &mut bool {
        &mut self.enable_sprint_to_crouch_transition
    }
    fn stop_sprinting_when_releasing_throttle(&self) -> &bool {
        &self.stop_sprinting_when_releasing_throttle
    }
    fn stop_sprinting_when_releasing_throttle_mut(&mut self) -> &mut bool {
        &mut self.stop_sprinting_when_releasing_throttle
    }
    fn stop_sprinting_when_releasing_sprint(&self) -> &bool {
        &self.stop_sprinting_when_releasing_sprint
    }
    fn stop_sprinting_when_releasing_sprint_mut(&mut self) -> &mut bool {
        &mut self.stop_sprinting_when_releasing_sprint
    }
    fn wait_for_sprint_release_before_sprint_again(&self) -> &bool {
        &self.wait_for_sprint_release_before_sprint_again
    }
    fn wait_for_sprint_release_before_sprint_again_mut(&mut self) -> &mut bool {
        &mut self.wait_for_sprint_release_before_sprint_again
    }
    fn firing_disabling_transitions(&self) -> &Vec<PoseTransition> {
        &self.firing_disabling_transitions
    }
    fn firing_disabling_transitions_mut(&mut self) -> &mut Vec<PoseTransition> {
        &mut self.firing_disabling_transitions
    }
    fn enter_vehicle_hold_time(&self) -> &f32 {
        &self.enter_vehicle_hold_time
    }
    fn enter_vehicle_hold_time_mut(&mut self) -> &mut f32 {
        &mut self.enter_vehicle_hold_time
    }
}

impl super::input_shared::BaseInputSettingsTrait for SoldierInputSettings {
}

impl super::core::DataContainerTrait for SoldierInputSettings {
}

pub static SOLDIERINPUTSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierInputSettings",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::input_shared::BASEINPUTSETTINGS_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierInputSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "TogglePoseAction",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SoldierInputSettings, toggle_pose_action),
            },
            FieldInfoData {
                name: "CrouchAction",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SoldierInputSettings, crouch_action),
            },
            FieldInfoData {
                name: "CrouchAndHoldAction",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SoldierInputSettings, crouch_and_hold_action),
            },
            FieldInfoData {
                name: "PickupInteractionAction",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SoldierInputSettings, pickup_interaction_action),
            },
            FieldInfoData {
                name: "PickupInteractionActionKeyboard",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SoldierInputSettings, pickup_interaction_action_keyboard),
            },
            FieldInfoData {
                name: "ProneToStandOnJump",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierInputSettings, prone_to_stand_on_jump),
            },
            FieldInfoData {
                name: "StandAutomaticallyIfSprinting",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierInputSettings, stand_automatically_if_sprinting),
            },
            FieldInfoData {
                name: "SprintReleaseTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierInputSettings, sprint_release_time),
            },
            FieldInfoData {
                name: "ThrottleInputRequiredForSprint",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierInputSettings, throttle_input_required_for_sprint),
            },
            FieldInfoData {
                name: "DisableCrouch",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierInputSettings, disable_crouch),
            },
            FieldInfoData {
                name: "DisableProne",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierInputSettings, disable_prone),
            },
            FieldInfoData {
                name: "DisableCrawlingWhileFiring",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierInputSettings, disable_crawling_while_firing),
            },
            FieldInfoData {
                name: "DisableCrawlingWhileReloading",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierInputSettings, disable_crawling_while_reloading),
            },
            FieldInfoData {
                name: "DisableFiringWhileDeployingBipod",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierInputSettings, disable_firing_while_deploying_bipod),
            },
            FieldInfoData {
                name: "DisableFiringWhileJumping",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierInputSettings, disable_firing_while_jumping),
            },
            FieldInfoData {
                name: "DisableSprintingWhileReloading",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierInputSettings, disable_sprinting_while_reloading),
            },
            FieldInfoData {
                name: "DisableSprintingWhileFiring",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierInputSettings, disable_sprinting_while_firing),
            },
            FieldInfoData {
                name: "DoubleTapSprintEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierInputSettings, double_tap_sprint_enabled),
            },
            FieldInfoData {
                name: "EnableSprintToCrouchTransition",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierInputSettings, enable_sprint_to_crouch_transition),
            },
            FieldInfoData {
                name: "StopSprintingWhenReleasingThrottle",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierInputSettings, stop_sprinting_when_releasing_throttle),
            },
            FieldInfoData {
                name: "StopSprintingWhenReleasingSprint",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierInputSettings, stop_sprinting_when_releasing_sprint),
            },
            FieldInfoData {
                name: "WaitForSprintReleaseBeforeSprintAgain",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierInputSettings, wait_for_sprint_release_before_sprint_again),
            },
            FieldInfoData {
                name: "FiringDisablingTransitions",
                flags: MemberInfoFlags::new(144),
                field_type: "PoseTransition-Array",
                rust_offset: offset_of!(SoldierInputSettings, firing_disabling_transitions),
            },
            FieldInfoData {
                name: "EnterVehicleHoldTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierInputSettings, enter_vehicle_hold_time),
            },
        ],
    }),
    array_type: Some(SOLDIERINPUTSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoldierInputSettings {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERINPUTSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOLDIERINPUTSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierInputSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SoldierInputSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum PoseTransition {
    #[default]
    PTStandToProne = 0,
    PTStandToCrouch = 1,
    PTCrouchToStand = 2,
    PTCrouchToProne = 3,
    PTProneToStand = 4,
    PTProneToCrouch = 5,
}

pub static POSETRANSITION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PoseTransition",
    flags: MemberInfoFlags::new(49429),
    module: "SoldierShared",
    data: TypeInfoData::Enum,
    array_type: Some(POSETRANSITION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for PoseTransition {
    fn type_info(&self) -> &'static TypeInfo {
        POSETRANSITION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static POSETRANSITION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PoseTransition-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("PoseTransition"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum SoldierBuffId {
    #[default]
    SBImprovedBodyArmor = 0,
    SBCount = 1,
}

pub static SOLDIERBUFFID_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierBuffId",
    flags: MemberInfoFlags::new(49429),
    module: "SoldierShared",
    data: TypeInfoData::Enum,
    array_type: Some(SOLDIERBUFFID_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SoldierBuffId {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERBUFFID_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SOLDIERBUFFID_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierBuffId-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SoldierBuffId"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum PlayerRole {
    #[default]
    PRSquadLeader = 0,
    PRSquadMember = 1,
    PRUnknown = 2,
}

pub static PLAYERROLE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerRole",
    flags: MemberInfoFlags::new(49429),
    module: "SoldierShared",
    data: TypeInfoData::Enum,
    array_type: Some(PLAYERROLE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for PlayerRole {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERROLE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static PLAYERROLE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerRole-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("PlayerRole"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoldierHealthComponentData {
    pub _glacier_base: super::game_shared::CharacterHealthComponentData,
    pub under_water_hold_breath_time: f32,
    pub under_water_breath_regeneration_time: f32,
    pub under_water_damage_table: Vec<DamageEntryData>,
    pub under_water_clear_spotting_time: f32,
}

pub trait SoldierHealthComponentDataTrait: super::game_shared::CharacterHealthComponentDataTrait {
    fn under_water_hold_breath_time(&self) -> &f32;
    fn under_water_hold_breath_time_mut(&mut self) -> &mut f32;
    fn under_water_breath_regeneration_time(&self) -> &f32;
    fn under_water_breath_regeneration_time_mut(&mut self) -> &mut f32;
    fn under_water_damage_table(&self) -> &Vec<DamageEntryData>;
    fn under_water_damage_table_mut(&mut self) -> &mut Vec<DamageEntryData>;
    fn under_water_clear_spotting_time(&self) -> &f32;
    fn under_water_clear_spotting_time_mut(&mut self) -> &mut f32;
}

impl SoldierHealthComponentDataTrait for SoldierHealthComponentData {
    fn under_water_hold_breath_time(&self) -> &f32 {
        &self.under_water_hold_breath_time
    }
    fn under_water_hold_breath_time_mut(&mut self) -> &mut f32 {
        &mut self.under_water_hold_breath_time
    }
    fn under_water_breath_regeneration_time(&self) -> &f32 {
        &self.under_water_breath_regeneration_time
    }
    fn under_water_breath_regeneration_time_mut(&mut self) -> &mut f32 {
        &mut self.under_water_breath_regeneration_time
    }
    fn under_water_damage_table(&self) -> &Vec<DamageEntryData> {
        &self.under_water_damage_table
    }
    fn under_water_damage_table_mut(&mut self) -> &mut Vec<DamageEntryData> {
        &mut self.under_water_damage_table
    }
    fn under_water_clear_spotting_time(&self) -> &f32 {
        &self.under_water_clear_spotting_time
    }
    fn under_water_clear_spotting_time_mut(&mut self) -> &mut f32 {
        &mut self.under_water_clear_spotting_time
    }
}

impl super::game_shared::CharacterHealthComponentDataTrait for SoldierHealthComponentData {
    fn max_health(&self) -> &f32 {
        self._glacier_base.max_health()
    }
    fn max_health_mut(&mut self) -> &mut f32 {
        self._glacier_base.max_health_mut()
    }
    fn time_for_corpse(&self) -> &f32 {
        self._glacier_base.time_for_corpse()
    }
    fn time_for_corpse_mut(&mut self) -> &mut f32 {
        self._glacier_base.time_for_corpse_mut()
    }
}

impl super::gameplay_sim::ControllableHealthComponentDataTrait for SoldierHealthComponentData {
}

impl super::gameplay_sim::GameHealthComponentDataTrait for SoldierHealthComponentData {
}

impl super::gameplay_sim::HealthComponentDataTrait for SoldierHealthComponentData {
}

impl super::entity::ComponentDataTrait for SoldierHealthComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for SoldierHealthComponentData {
}

impl super::core::DataBusPeerTrait for SoldierHealthComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SoldierHealthComponentData {
}

impl super::core::DataContainerTrait for SoldierHealthComponentData {
}

pub static SOLDIERHEALTHCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierHealthComponentData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::game_shared::CHARACTERHEALTHCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierHealthComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "UnderWaterHoldBreathTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierHealthComponentData, under_water_hold_breath_time),
            },
            FieldInfoData {
                name: "UnderWaterBreathRegenerationTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierHealthComponentData, under_water_breath_regeneration_time),
            },
            FieldInfoData {
                name: "UnderWaterDamageTable",
                flags: MemberInfoFlags::new(144),
                field_type: "DamageEntryData-Array",
                rust_offset: offset_of!(SoldierHealthComponentData, under_water_damage_table),
            },
            FieldInfoData {
                name: "UnderWaterClearSpottingTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierHealthComponentData, under_water_clear_spotting_time),
            },
        ],
    }),
    array_type: Some(SOLDIERHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SoldierHealthComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERHEALTHCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOLDIERHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierHealthComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SoldierHealthComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DamageEntryData {
    pub damage: f32,
    pub timeout: f32,
}

pub trait DamageEntryDataTrait: TypeObject {
    fn damage(&self) -> &f32;
    fn damage_mut(&mut self) -> &mut f32;
    fn timeout(&self) -> &f32;
    fn timeout_mut(&mut self) -> &mut f32;
}

impl DamageEntryDataTrait for DamageEntryData {
    fn damage(&self) -> &f32 {
        &self.damage
    }
    fn damage_mut(&mut self) -> &mut f32 {
        &mut self.damage
    }
    fn timeout(&self) -> &f32 {
        &self.timeout
    }
    fn timeout_mut(&mut self) -> &mut f32 {
        &mut self.timeout
    }
}

pub static DAMAGEENTRYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DamageEntryData",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DamageEntryData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Damage",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DamageEntryData, damage),
            },
            FieldInfoData {
                name: "Timeout",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DamageEntryData, timeout),
            },
        ],
    }),
    array_type: Some(DAMAGEENTRYDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for DamageEntryData {
    fn type_info(&self) -> &'static TypeInfo {
        DAMAGEENTRYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static DAMAGEENTRYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DamageEntryData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("DamageEntryData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoldierPhysicsComponentData {
    pub _glacier_base: super::game_shared::CharacterMasterPhysicsComponentData,
    pub radius_to_predict_collision_on_characters: f32,
    pub proximity_tracker_data: Option<Arc<Mutex<dyn super::physics::ProximityTrackerDataTrait>>>,
}

pub trait SoldierPhysicsComponentDataTrait: super::game_shared::CharacterMasterPhysicsComponentDataTrait {
    fn radius_to_predict_collision_on_characters(&self) -> &f32;
    fn radius_to_predict_collision_on_characters_mut(&mut self) -> &mut f32;
    fn proximity_tracker_data(&self) -> &Option<Arc<Mutex<dyn super::physics::ProximityTrackerDataTrait>>>;
    fn proximity_tracker_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::physics::ProximityTrackerDataTrait>>>;
}

impl SoldierPhysicsComponentDataTrait for SoldierPhysicsComponentData {
    fn radius_to_predict_collision_on_characters(&self) -> &f32 {
        &self.radius_to_predict_collision_on_characters
    }
    fn radius_to_predict_collision_on_characters_mut(&mut self) -> &mut f32 {
        &mut self.radius_to_predict_collision_on_characters
    }
    fn proximity_tracker_data(&self) -> &Option<Arc<Mutex<dyn super::physics::ProximityTrackerDataTrait>>> {
        &self.proximity_tracker_data
    }
    fn proximity_tracker_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::physics::ProximityTrackerDataTrait>>> {
        &mut self.proximity_tracker_data
    }
}

impl super::game_shared::CharacterMasterPhysicsComponentDataTrait for SoldierPhysicsComponentData {
}

impl super::gameplay_sim::ControllablePhysicsComponentDataTrait for SoldierPhysicsComponentData {
}

impl super::gameplay_sim::GamePhysicsComponentDataTrait for SoldierPhysicsComponentData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn effect_parameters(&self) -> &Vec<Option<Arc<Mutex<dyn super::effect_base::EffectParameterTrait>>>> {
        self._glacier_base.effect_parameters()
    }
    fn effect_parameters_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::effect_base::EffectParameterTrait>>>> {
        self._glacier_base.effect_parameters_mut()
    }
}

impl super::physics::PhysicsComponentDataTrait for SoldierPhysicsComponentData {
    fn physics_bodies(&self) -> &Vec<Option<Arc<Mutex<dyn super::physics::PhysicsBodyDataTrait>>>> {
        self._glacier_base.physics_bodies()
    }
    fn physics_bodies_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::physics::PhysicsBodyDataTrait>>>> {
        self._glacier_base.physics_bodies_mut()
    }
    fn physics_constraints(&self) -> &Vec<Option<Arc<Mutex<dyn super::physics::PhysicsConstraintDataTrait>>>> {
        self._glacier_base.physics_constraints()
    }
    fn physics_constraints_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::physics::PhysicsConstraintDataTrait>>>> {
        self._glacier_base.physics_constraints_mut()
    }
    fn parts(&self) -> &Vec<super::physics::PhysicsPartData> {
        self._glacier_base.parts()
    }
    fn parts_mut(&mut self) -> &mut Vec<super::physics::PhysicsPartData> {
        self._glacier_base.parts_mut()
    }
    fn movable_parts(&self) -> &bool {
        self._glacier_base.movable_parts()
    }
    fn movable_parts_mut(&mut self) -> &mut bool {
        self._glacier_base.movable_parts_mut()
    }
    fn internal_collision_disabling(&self) -> &super::physics::InternalCollisionDisablingBehavior {
        self._glacier_base.internal_collision_disabling()
    }
    fn internal_collision_disabling_mut(&mut self) -> &mut super::physics::InternalCollisionDisablingBehavior {
        self._glacier_base.internal_collision_disabling_mut()
    }
    fn enable_collision_events(&self) -> &bool {
        self._glacier_base.enable_collision_events()
    }
    fn enable_collision_events_mut(&mut self) -> &mut bool {
        self._glacier_base.enable_collision_events_mut()
    }
}

impl super::entity::ComponentDataTrait for SoldierPhysicsComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for SoldierPhysicsComponentData {
}

impl super::core::DataBusPeerTrait for SoldierPhysicsComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SoldierPhysicsComponentData {
}

impl super::core::DataContainerTrait for SoldierPhysicsComponentData {
}

pub static SOLDIERPHYSICSCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierPhysicsComponentData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::game_shared::CHARACTERMASTERPHYSICSCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierPhysicsComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "RadiusToPredictCollisionOnCharacters",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierPhysicsComponentData, radius_to_predict_collision_on_characters),
            },
            FieldInfoData {
                name: "ProximityTrackerData",
                flags: MemberInfoFlags::new(0),
                field_type: "ProximityTrackerData",
                rust_offset: offset_of!(SoldierPhysicsComponentData, proximity_tracker_data),
            },
        ],
    }),
    array_type: Some(SOLDIERPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SoldierPhysicsComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERPHYSICSCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOLDIERPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierPhysicsComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SoldierPhysicsComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CustomizeSoldierData {
    pub _glacier_base: super::game_shared::CustomizeCharacterData,
    pub weapons: Vec<UnlockWeaponAndSlot>,
    pub active_slot: super::weapon_shared::WeaponSlot,
    pub keep_current_active_slot: bool,
    pub remove_all_existing_weapons: bool,
    pub death_pickup: Option<Arc<Mutex<dyn PickupEntityAssetTrait>>>,
    pub disable_death_pickup: bool,
}

pub trait CustomizeSoldierDataTrait: super::game_shared::CustomizeCharacterDataTrait {
    fn weapons(&self) -> &Vec<UnlockWeaponAndSlot>;
    fn weapons_mut(&mut self) -> &mut Vec<UnlockWeaponAndSlot>;
    fn active_slot(&self) -> &super::weapon_shared::WeaponSlot;
    fn active_slot_mut(&mut self) -> &mut super::weapon_shared::WeaponSlot;
    fn keep_current_active_slot(&self) -> &bool;
    fn keep_current_active_slot_mut(&mut self) -> &mut bool;
    fn remove_all_existing_weapons(&self) -> &bool;
    fn remove_all_existing_weapons_mut(&mut self) -> &mut bool;
    fn death_pickup(&self) -> &Option<Arc<Mutex<dyn PickupEntityAssetTrait>>>;
    fn death_pickup_mut(&mut self) -> &mut Option<Arc<Mutex<dyn PickupEntityAssetTrait>>>;
    fn disable_death_pickup(&self) -> &bool;
    fn disable_death_pickup_mut(&mut self) -> &mut bool;
}

impl CustomizeSoldierDataTrait for CustomizeSoldierData {
    fn weapons(&self) -> &Vec<UnlockWeaponAndSlot> {
        &self.weapons
    }
    fn weapons_mut(&mut self) -> &mut Vec<UnlockWeaponAndSlot> {
        &mut self.weapons
    }
    fn active_slot(&self) -> &super::weapon_shared::WeaponSlot {
        &self.active_slot
    }
    fn active_slot_mut(&mut self) -> &mut super::weapon_shared::WeaponSlot {
        &mut self.active_slot
    }
    fn keep_current_active_slot(&self) -> &bool {
        &self.keep_current_active_slot
    }
    fn keep_current_active_slot_mut(&mut self) -> &mut bool {
        &mut self.keep_current_active_slot
    }
    fn remove_all_existing_weapons(&self) -> &bool {
        &self.remove_all_existing_weapons
    }
    fn remove_all_existing_weapons_mut(&mut self) -> &mut bool {
        &mut self.remove_all_existing_weapons
    }
    fn death_pickup(&self) -> &Option<Arc<Mutex<dyn PickupEntityAssetTrait>>> {
        &self.death_pickup
    }
    fn death_pickup_mut(&mut self) -> &mut Option<Arc<Mutex<dyn PickupEntityAssetTrait>>> {
        &mut self.death_pickup
    }
    fn disable_death_pickup(&self) -> &bool {
        &self.disable_death_pickup
    }
    fn disable_death_pickup_mut(&mut self) -> &mut bool {
        &mut self.disable_death_pickup
    }
}

impl super::game_shared::CustomizeCharacterDataTrait for CustomizeSoldierData {
    fn restore_to_original_visual_state(&self) -> &bool {
        self._glacier_base.restore_to_original_visual_state()
    }
    fn restore_to_original_visual_state_mut(&mut self) -> &mut bool {
        self._glacier_base.restore_to_original_visual_state_mut()
    }
    fn clear_visual_state(&self) -> &bool {
        self._glacier_base.clear_visual_state()
    }
    fn clear_visual_state_mut(&mut self) -> &mut bool {
        self._glacier_base.clear_visual_state_mut()
    }
    fn visual_groups(&self) -> &Vec<super::game_shared::CustomizeVisual> {
        self._glacier_base.visual_groups()
    }
    fn visual_groups_mut(&mut self) -> &mut Vec<super::game_shared::CustomizeVisual> {
        self._glacier_base.visual_groups_mut()
    }
    fn unlocks(&self) -> &Vec<Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>>> {
        self._glacier_base.unlocks()
    }
    fn unlocks_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>>> {
        self._glacier_base.unlocks_mut()
    }
    fn override_max_health(&self) -> &f32 {
        self._glacier_base.override_max_health()
    }
    fn override_max_health_mut(&mut self) -> &mut f32 {
        self._glacier_base.override_max_health_mut()
    }
    fn override_critical_health_threshold(&self) -> &f32 {
        self._glacier_base.override_critical_health_threshold()
    }
    fn override_critical_health_threshold_mut(&mut self) -> &mut f32 {
        self._glacier_base.override_critical_health_threshold_mut()
    }
}

impl super::core::AssetTrait for CustomizeSoldierData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for CustomizeSoldierData {
}

pub static CUSTOMIZESOLDIERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomizeSoldierData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::game_shared::CUSTOMIZECHARACTERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CustomizeSoldierData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Weapons",
                flags: MemberInfoFlags::new(144),
                field_type: "UnlockWeaponAndSlot-Array",
                rust_offset: offset_of!(CustomizeSoldierData, weapons),
            },
            FieldInfoData {
                name: "ActiveSlot",
                flags: MemberInfoFlags::new(0),
                field_type: "WeaponSlot",
                rust_offset: offset_of!(CustomizeSoldierData, active_slot),
            },
            FieldInfoData {
                name: "KeepCurrentActiveSlot",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CustomizeSoldierData, keep_current_active_slot),
            },
            FieldInfoData {
                name: "RemoveAllExistingWeapons",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CustomizeSoldierData, remove_all_existing_weapons),
            },
            FieldInfoData {
                name: "DeathPickup",
                flags: MemberInfoFlags::new(0),
                field_type: "PickupEntityAsset",
                rust_offset: offset_of!(CustomizeSoldierData, death_pickup),
            },
            FieldInfoData {
                name: "DisableDeathPickup",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CustomizeSoldierData, disable_death_pickup),
            },
        ],
    }),
    array_type: Some(CUSTOMIZESOLDIERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CustomizeSoldierData {
    fn type_info(&self) -> &'static TypeInfo {
        CUSTOMIZESOLDIERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CUSTOMIZESOLDIERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomizeSoldierData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("CustomizeSoldierData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoldierSettings {
    pub _glacier_base: super::core::SystemSettings,
    pub soldier_weapon_switching: Option<Arc<Mutex<dyn SoldierWeaponSwitchingDataTrait>>>,
    pub max_number_dropped_pickups: u32,
    pub max_visible_pickup_weapons: u32,
}

pub trait SoldierSettingsTrait: super::core::SystemSettingsTrait {
    fn soldier_weapon_switching(&self) -> &Option<Arc<Mutex<dyn SoldierWeaponSwitchingDataTrait>>>;
    fn soldier_weapon_switching_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoldierWeaponSwitchingDataTrait>>>;
    fn max_number_dropped_pickups(&self) -> &u32;
    fn max_number_dropped_pickups_mut(&mut self) -> &mut u32;
    fn max_visible_pickup_weapons(&self) -> &u32;
    fn max_visible_pickup_weapons_mut(&mut self) -> &mut u32;
}

impl SoldierSettingsTrait for SoldierSettings {
    fn soldier_weapon_switching(&self) -> &Option<Arc<Mutex<dyn SoldierWeaponSwitchingDataTrait>>> {
        &self.soldier_weapon_switching
    }
    fn soldier_weapon_switching_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoldierWeaponSwitchingDataTrait>>> {
        &mut self.soldier_weapon_switching
    }
    fn max_number_dropped_pickups(&self) -> &u32 {
        &self.max_number_dropped_pickups
    }
    fn max_number_dropped_pickups_mut(&mut self) -> &mut u32 {
        &mut self.max_number_dropped_pickups
    }
    fn max_visible_pickup_weapons(&self) -> &u32 {
        &self.max_visible_pickup_weapons
    }
    fn max_visible_pickup_weapons_mut(&mut self) -> &mut u32 {
        &mut self.max_visible_pickup_weapons
    }
}

impl super::core::SystemSettingsTrait for SoldierSettings {
    fn platform(&self) -> &super::core::GamePlatform {
        self._glacier_base.platform()
    }
    fn platform_mut(&mut self) -> &mut super::core::GamePlatform {
        self._glacier_base.platform_mut()
    }
}

impl super::core::DataContainerTrait for SoldierSettings {
}

pub static SOLDIERSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierSettings",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::SYSTEMSETTINGS_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SoldierWeaponSwitching",
                flags: MemberInfoFlags::new(0),
                field_type: "SoldierWeaponSwitchingData",
                rust_offset: offset_of!(SoldierSettings, soldier_weapon_switching),
            },
            FieldInfoData {
                name: "MaxNumberDroppedPickups",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(SoldierSettings, max_number_dropped_pickups),
            },
            FieldInfoData {
                name: "MaxVisiblePickupWeapons",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(SoldierSettings, max_visible_pickup_weapons),
            },
        ],
    }),
    array_type: Some(SOLDIERSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoldierSettings {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOLDIERSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SoldierSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ServerSoldierOnActionStateChangedMessage {
}

pub trait ServerSoldierOnActionStateChangedMessageTrait: TypeObject {
}

impl ServerSoldierOnActionStateChangedMessageTrait for ServerSoldierOnActionStateChangedMessage {
}

pub static SERVERSOLDIERONACTIONSTATECHANGEDMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ServerSoldierOnActionStateChangedMessage",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ServerSoldierOnActionStateChangedMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for ServerSoldierOnActionStateChangedMessage {
    fn type_info(&self) -> &'static TypeInfo {
        SERVERSOLDIERONACTIONSTATECHANGEDMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Clone, Debug, Default)]
pub struct SoldierToComponentsOnClearSpottingMessage {
}

pub trait SoldierToComponentsOnClearSpottingMessageTrait: TypeObject {
}

impl SoldierToComponentsOnClearSpottingMessageTrait for SoldierToComponentsOnClearSpottingMessage {
}

pub static SOLDIERTOCOMPONENTSONCLEARSPOTTINGMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierToComponentsOnClearSpottingMessage",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierToComponentsOnClearSpottingMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for SoldierToComponentsOnClearSpottingMessage {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERTOCOMPONENTSONCLEARSPOTTINGMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Clone, Debug, Default)]
pub struct ClientSoldierToComponentsOnHandleDamageMessage {
}

pub trait ClientSoldierToComponentsOnHandleDamageMessageTrait: TypeObject {
}

impl ClientSoldierToComponentsOnHandleDamageMessageTrait for ClientSoldierToComponentsOnHandleDamageMessage {
}

pub static CLIENTSOLDIERTOCOMPONENTSONHANDLEDAMAGEMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClientSoldierToComponentsOnHandleDamageMessage",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ClientSoldierToComponentsOnHandleDamageMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 16,
};

impl TypeObject for ClientSoldierToComponentsOnHandleDamageMessage {
    fn type_info(&self) -> &'static TypeInfo {
        CLIENTSOLDIERTOCOMPONENTSONHANDLEDAMAGEMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Clone, Debug, Default)]
pub struct ClientSoldierToComponentsOnImpulseMessage {
}

pub trait ClientSoldierToComponentsOnImpulseMessageTrait: TypeObject {
}

impl ClientSoldierToComponentsOnImpulseMessageTrait for ClientSoldierToComponentsOnImpulseMessage {
}

pub static CLIENTSOLDIERTOCOMPONENTSONIMPULSEMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClientSoldierToComponentsOnImpulseMessage",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ClientSoldierToComponentsOnImpulseMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for ClientSoldierToComponentsOnImpulseMessage {
    fn type_info(&self) -> &'static TypeInfo {
        CLIENTSOLDIERTOCOMPONENTSONIMPULSEMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Clone, Debug, Default)]
pub struct SoldierToComponentsOnActionStateChangedMessage {
}

pub trait SoldierToComponentsOnActionStateChangedMessageTrait: TypeObject {
}

impl SoldierToComponentsOnActionStateChangedMessageTrait for SoldierToComponentsOnActionStateChangedMessage {
}

pub static SOLDIERTOCOMPONENTSONACTIONSTATECHANGEDMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierToComponentsOnActionStateChangedMessage",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierToComponentsOnActionStateChangedMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for SoldierToComponentsOnActionStateChangedMessage {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERTOCOMPONENTSONACTIONSTATECHANGEDMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Clone, Debug, Default)]
pub struct SoldierToComponentsOnIncapableMessage {
}

pub trait SoldierToComponentsOnIncapableMessageTrait: TypeObject {
}

impl SoldierToComponentsOnIncapableMessageTrait for SoldierToComponentsOnIncapableMessage {
}

pub static SOLDIERTOCOMPONENTSONINCAPABLEMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierToComponentsOnIncapableMessage",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierToComponentsOnIncapableMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 16,
};

impl TypeObject for SoldierToComponentsOnIncapableMessage {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERTOCOMPONENTSONINCAPABLEMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Clone, Debug, Default)]
pub struct SoldierToComponentsOnCustomizeSoldierMessage {
}

pub trait SoldierToComponentsOnCustomizeSoldierMessageTrait: TypeObject {
}

impl SoldierToComponentsOnCustomizeSoldierMessageTrait for SoldierToComponentsOnCustomizeSoldierMessage {
}

pub static SOLDIERTOCOMPONENTSONCUSTOMIZESOLDIERMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierToComponentsOnCustomizeSoldierMessage",
    flags: MemberInfoFlags::new(73),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierToComponentsOnCustomizeSoldierMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for SoldierToComponentsOnCustomizeSoldierMessage {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERTOCOMPONENTSONCUSTOMIZESOLDIERMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Clone, Debug, Default)]
pub struct SoldierEntityData {
    pub _glacier_base: super::game_shared::CharacterEntityData,
    pub foot_material_pair: super::entity::MaterialDecl,
    pub head_material_pair: super::entity::MaterialDecl,
    pub bone_fake_physics: Vec<Option<Arc<Mutex<dyn super::game_shared::BoneFakePhysicsDataTrait>>>>,
    pub auto_aim: Option<Arc<Mutex<dyn SoldierAutoAimDataTrait>>>,
    pub aiming_constraints: Option<Arc<Mutex<dyn SoldierAimingConstraintsDataTrait>>>,
    pub head_collision: Option<Arc<Mutex<dyn SoldierHeadCollisionDataTrait>>>,
    pub character_physics: Option<Arc<Mutex<dyn super::physics::CharacterPhysicsDataTrait>>>,
    pub sprint_settings: Option<Arc<Mutex<dyn SoldierSprintSettingsDataTrait>>>,
    pub hidable_mesh_parts: Vec<HidableSoldierMeshWeaponPart>,
    pub impulse_reaction_time: f32,
    pub show_weapon_when_dead: bool,
    pub health_module: Option<Arc<Mutex<dyn SoldierHealthModuleDataTrait>>>,
    pub abort_spawn_invisibility_inputs: Vec<i32>,
    pub enable_groundmap_lighting: bool,
    pub lower_gun_on_own_team: bool,
    pub proximity_check: bool,
    pub free_space_check: bool,
    pub breath_control: Vec<Option<Arc<Mutex<dyn BreathControlDataTrait>>>>,
    pub collision_info: Option<Arc<Mutex<dyn CollisionDataTrait>>>,
    pub f_l_i_r_value: f32,
    pub f_l_i_r_key_color: super::core::Vec3,
    pub explosion_damage_modifier: f32,
    pub regeneration_delay_modifier: f32,
    pub fall_damage_threshold: f32,
    pub collision_enabled: bool,
    pub physics_controlled: bool,
    pub is_pushable: bool,
    pub human_player_controlled: bool,
    pub blueprint_name_hash: u32,
    pub interactive_man_down_allowed: bool,
    pub show_nametag: bool,
    pub visual_cull_screen_area: f32,
    pub aim_follow_eye_transform: bool,
    pub force_disable_render_first_person_in_foreground: bool,
}

pub trait SoldierEntityDataTrait: super::game_shared::CharacterEntityDataTrait {
    fn foot_material_pair(&self) -> &super::entity::MaterialDecl;
    fn foot_material_pair_mut(&mut self) -> &mut super::entity::MaterialDecl;
    fn head_material_pair(&self) -> &super::entity::MaterialDecl;
    fn head_material_pair_mut(&mut self) -> &mut super::entity::MaterialDecl;
    fn bone_fake_physics(&self) -> &Vec<Option<Arc<Mutex<dyn super::game_shared::BoneFakePhysicsDataTrait>>>>;
    fn bone_fake_physics_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::game_shared::BoneFakePhysicsDataTrait>>>>;
    fn auto_aim(&self) -> &Option<Arc<Mutex<dyn SoldierAutoAimDataTrait>>>;
    fn auto_aim_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoldierAutoAimDataTrait>>>;
    fn aiming_constraints(&self) -> &Option<Arc<Mutex<dyn SoldierAimingConstraintsDataTrait>>>;
    fn aiming_constraints_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoldierAimingConstraintsDataTrait>>>;
    fn head_collision(&self) -> &Option<Arc<Mutex<dyn SoldierHeadCollisionDataTrait>>>;
    fn head_collision_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoldierHeadCollisionDataTrait>>>;
    fn character_physics(&self) -> &Option<Arc<Mutex<dyn super::physics::CharacterPhysicsDataTrait>>>;
    fn character_physics_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::physics::CharacterPhysicsDataTrait>>>;
    fn sprint_settings(&self) -> &Option<Arc<Mutex<dyn SoldierSprintSettingsDataTrait>>>;
    fn sprint_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoldierSprintSettingsDataTrait>>>;
    fn hidable_mesh_parts(&self) -> &Vec<HidableSoldierMeshWeaponPart>;
    fn hidable_mesh_parts_mut(&mut self) -> &mut Vec<HidableSoldierMeshWeaponPart>;
    fn impulse_reaction_time(&self) -> &f32;
    fn impulse_reaction_time_mut(&mut self) -> &mut f32;
    fn show_weapon_when_dead(&self) -> &bool;
    fn show_weapon_when_dead_mut(&mut self) -> &mut bool;
    fn health_module(&self) -> &Option<Arc<Mutex<dyn SoldierHealthModuleDataTrait>>>;
    fn health_module_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoldierHealthModuleDataTrait>>>;
    fn abort_spawn_invisibility_inputs(&self) -> &Vec<i32>;
    fn abort_spawn_invisibility_inputs_mut(&mut self) -> &mut Vec<i32>;
    fn enable_groundmap_lighting(&self) -> &bool;
    fn enable_groundmap_lighting_mut(&mut self) -> &mut bool;
    fn lower_gun_on_own_team(&self) -> &bool;
    fn lower_gun_on_own_team_mut(&mut self) -> &mut bool;
    fn proximity_check(&self) -> &bool;
    fn proximity_check_mut(&mut self) -> &mut bool;
    fn free_space_check(&self) -> &bool;
    fn free_space_check_mut(&mut self) -> &mut bool;
    fn breath_control(&self) -> &Vec<Option<Arc<Mutex<dyn BreathControlDataTrait>>>>;
    fn breath_control_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn BreathControlDataTrait>>>>;
    fn collision_info(&self) -> &Option<Arc<Mutex<dyn CollisionDataTrait>>>;
    fn collision_info_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CollisionDataTrait>>>;
    fn f_l_i_r_value(&self) -> &f32;
    fn f_l_i_r_value_mut(&mut self) -> &mut f32;
    fn f_l_i_r_key_color(&self) -> &super::core::Vec3;
    fn f_l_i_r_key_color_mut(&mut self) -> &mut super::core::Vec3;
    fn explosion_damage_modifier(&self) -> &f32;
    fn explosion_damage_modifier_mut(&mut self) -> &mut f32;
    fn regeneration_delay_modifier(&self) -> &f32;
    fn regeneration_delay_modifier_mut(&mut self) -> &mut f32;
    fn fall_damage_threshold(&self) -> &f32;
    fn fall_damage_threshold_mut(&mut self) -> &mut f32;
    fn collision_enabled(&self) -> &bool;
    fn collision_enabled_mut(&mut self) -> &mut bool;
    fn physics_controlled(&self) -> &bool;
    fn physics_controlled_mut(&mut self) -> &mut bool;
    fn is_pushable(&self) -> &bool;
    fn is_pushable_mut(&mut self) -> &mut bool;
    fn human_player_controlled(&self) -> &bool;
    fn human_player_controlled_mut(&mut self) -> &mut bool;
    fn blueprint_name_hash(&self) -> &u32;
    fn blueprint_name_hash_mut(&mut self) -> &mut u32;
    fn interactive_man_down_allowed(&self) -> &bool;
    fn interactive_man_down_allowed_mut(&mut self) -> &mut bool;
    fn show_nametag(&self) -> &bool;
    fn show_nametag_mut(&mut self) -> &mut bool;
    fn visual_cull_screen_area(&self) -> &f32;
    fn visual_cull_screen_area_mut(&mut self) -> &mut f32;
    fn aim_follow_eye_transform(&self) -> &bool;
    fn aim_follow_eye_transform_mut(&mut self) -> &mut bool;
    fn force_disable_render_first_person_in_foreground(&self) -> &bool;
    fn force_disable_render_first_person_in_foreground_mut(&mut self) -> &mut bool;
}

impl SoldierEntityDataTrait for SoldierEntityData {
    fn foot_material_pair(&self) -> &super::entity::MaterialDecl {
        &self.foot_material_pair
    }
    fn foot_material_pair_mut(&mut self) -> &mut super::entity::MaterialDecl {
        &mut self.foot_material_pair
    }
    fn head_material_pair(&self) -> &super::entity::MaterialDecl {
        &self.head_material_pair
    }
    fn head_material_pair_mut(&mut self) -> &mut super::entity::MaterialDecl {
        &mut self.head_material_pair
    }
    fn bone_fake_physics(&self) -> &Vec<Option<Arc<Mutex<dyn super::game_shared::BoneFakePhysicsDataTrait>>>> {
        &self.bone_fake_physics
    }
    fn bone_fake_physics_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::game_shared::BoneFakePhysicsDataTrait>>>> {
        &mut self.bone_fake_physics
    }
    fn auto_aim(&self) -> &Option<Arc<Mutex<dyn SoldierAutoAimDataTrait>>> {
        &self.auto_aim
    }
    fn auto_aim_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoldierAutoAimDataTrait>>> {
        &mut self.auto_aim
    }
    fn aiming_constraints(&self) -> &Option<Arc<Mutex<dyn SoldierAimingConstraintsDataTrait>>> {
        &self.aiming_constraints
    }
    fn aiming_constraints_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoldierAimingConstraintsDataTrait>>> {
        &mut self.aiming_constraints
    }
    fn head_collision(&self) -> &Option<Arc<Mutex<dyn SoldierHeadCollisionDataTrait>>> {
        &self.head_collision
    }
    fn head_collision_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoldierHeadCollisionDataTrait>>> {
        &mut self.head_collision
    }
    fn character_physics(&self) -> &Option<Arc<Mutex<dyn super::physics::CharacterPhysicsDataTrait>>> {
        &self.character_physics
    }
    fn character_physics_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::physics::CharacterPhysicsDataTrait>>> {
        &mut self.character_physics
    }
    fn sprint_settings(&self) -> &Option<Arc<Mutex<dyn SoldierSprintSettingsDataTrait>>> {
        &self.sprint_settings
    }
    fn sprint_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoldierSprintSettingsDataTrait>>> {
        &mut self.sprint_settings
    }
    fn hidable_mesh_parts(&self) -> &Vec<HidableSoldierMeshWeaponPart> {
        &self.hidable_mesh_parts
    }
    fn hidable_mesh_parts_mut(&mut self) -> &mut Vec<HidableSoldierMeshWeaponPart> {
        &mut self.hidable_mesh_parts
    }
    fn impulse_reaction_time(&self) -> &f32 {
        &self.impulse_reaction_time
    }
    fn impulse_reaction_time_mut(&mut self) -> &mut f32 {
        &mut self.impulse_reaction_time
    }
    fn show_weapon_when_dead(&self) -> &bool {
        &self.show_weapon_when_dead
    }
    fn show_weapon_when_dead_mut(&mut self) -> &mut bool {
        &mut self.show_weapon_when_dead
    }
    fn health_module(&self) -> &Option<Arc<Mutex<dyn SoldierHealthModuleDataTrait>>> {
        &self.health_module
    }
    fn health_module_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoldierHealthModuleDataTrait>>> {
        &mut self.health_module
    }
    fn abort_spawn_invisibility_inputs(&self) -> &Vec<i32> {
        &self.abort_spawn_invisibility_inputs
    }
    fn abort_spawn_invisibility_inputs_mut(&mut self) -> &mut Vec<i32> {
        &mut self.abort_spawn_invisibility_inputs
    }
    fn enable_groundmap_lighting(&self) -> &bool {
        &self.enable_groundmap_lighting
    }
    fn enable_groundmap_lighting_mut(&mut self) -> &mut bool {
        &mut self.enable_groundmap_lighting
    }
    fn lower_gun_on_own_team(&self) -> &bool {
        &self.lower_gun_on_own_team
    }
    fn lower_gun_on_own_team_mut(&mut self) -> &mut bool {
        &mut self.lower_gun_on_own_team
    }
    fn proximity_check(&self) -> &bool {
        &self.proximity_check
    }
    fn proximity_check_mut(&mut self) -> &mut bool {
        &mut self.proximity_check
    }
    fn free_space_check(&self) -> &bool {
        &self.free_space_check
    }
    fn free_space_check_mut(&mut self) -> &mut bool {
        &mut self.free_space_check
    }
    fn breath_control(&self) -> &Vec<Option<Arc<Mutex<dyn BreathControlDataTrait>>>> {
        &self.breath_control
    }
    fn breath_control_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn BreathControlDataTrait>>>> {
        &mut self.breath_control
    }
    fn collision_info(&self) -> &Option<Arc<Mutex<dyn CollisionDataTrait>>> {
        &self.collision_info
    }
    fn collision_info_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CollisionDataTrait>>> {
        &mut self.collision_info
    }
    fn f_l_i_r_value(&self) -> &f32 {
        &self.f_l_i_r_value
    }
    fn f_l_i_r_value_mut(&mut self) -> &mut f32 {
        &mut self.f_l_i_r_value
    }
    fn f_l_i_r_key_color(&self) -> &super::core::Vec3 {
        &self.f_l_i_r_key_color
    }
    fn f_l_i_r_key_color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.f_l_i_r_key_color
    }
    fn explosion_damage_modifier(&self) -> &f32 {
        &self.explosion_damage_modifier
    }
    fn explosion_damage_modifier_mut(&mut self) -> &mut f32 {
        &mut self.explosion_damage_modifier
    }
    fn regeneration_delay_modifier(&self) -> &f32 {
        &self.regeneration_delay_modifier
    }
    fn regeneration_delay_modifier_mut(&mut self) -> &mut f32 {
        &mut self.regeneration_delay_modifier
    }
    fn fall_damage_threshold(&self) -> &f32 {
        &self.fall_damage_threshold
    }
    fn fall_damage_threshold_mut(&mut self) -> &mut f32 {
        &mut self.fall_damage_threshold
    }
    fn collision_enabled(&self) -> &bool {
        &self.collision_enabled
    }
    fn collision_enabled_mut(&mut self) -> &mut bool {
        &mut self.collision_enabled
    }
    fn physics_controlled(&self) -> &bool {
        &self.physics_controlled
    }
    fn physics_controlled_mut(&mut self) -> &mut bool {
        &mut self.physics_controlled
    }
    fn is_pushable(&self) -> &bool {
        &self.is_pushable
    }
    fn is_pushable_mut(&mut self) -> &mut bool {
        &mut self.is_pushable
    }
    fn human_player_controlled(&self) -> &bool {
        &self.human_player_controlled
    }
    fn human_player_controlled_mut(&mut self) -> &mut bool {
        &mut self.human_player_controlled
    }
    fn blueprint_name_hash(&self) -> &u32 {
        &self.blueprint_name_hash
    }
    fn blueprint_name_hash_mut(&mut self) -> &mut u32 {
        &mut self.blueprint_name_hash
    }
    fn interactive_man_down_allowed(&self) -> &bool {
        &self.interactive_man_down_allowed
    }
    fn interactive_man_down_allowed_mut(&mut self) -> &mut bool {
        &mut self.interactive_man_down_allowed
    }
    fn show_nametag(&self) -> &bool {
        &self.show_nametag
    }
    fn show_nametag_mut(&mut self) -> &mut bool {
        &mut self.show_nametag
    }
    fn visual_cull_screen_area(&self) -> &f32 {
        &self.visual_cull_screen_area
    }
    fn visual_cull_screen_area_mut(&mut self) -> &mut f32 {
        &mut self.visual_cull_screen_area
    }
    fn aim_follow_eye_transform(&self) -> &bool {
        &self.aim_follow_eye_transform
    }
    fn aim_follow_eye_transform_mut(&mut self) -> &mut bool {
        &mut self.aim_follow_eye_transform
    }
    fn force_disable_render_first_person_in_foreground(&self) -> &bool {
        &self.force_disable_render_first_person_in_foreground
    }
    fn force_disable_render_first_person_in_foreground_mut(&mut self) -> &mut bool {
        &mut self.force_disable_render_first_person_in_foreground
    }
}

impl super::game_shared::CharacterEntityDataTrait for SoldierEntityData {
    fn max_health(&self) -> &f32 {
        self._glacier_base.max_health()
    }
    fn max_health_mut(&mut self) -> &mut f32 {
        self._glacier_base.max_health_mut()
    }
    fn default_view_mode(&self) -> &super::game_shared::PersonViewMode {
        self._glacier_base.default_view_mode()
    }
    fn default_view_mode_mut(&mut self) -> &mut super::game_shared::PersonViewMode {
        self._glacier_base.default_view_mode_mut()
    }
    fn player_spawn_type(&self) -> &super::game_shared::PlayerSpawnType {
        self._glacier_base.player_spawn_type()
    }
    fn player_spawn_type_mut(&mut self) -> &mut super::game_shared::PlayerSpawnType {
        self._glacier_base.player_spawn_type_mut()
    }
    fn character_lighting_enable(&self) -> &bool {
        self._glacier_base.character_lighting_enable()
    }
    fn character_lighting_enable_mut(&mut self) -> &mut bool {
        self._glacier_base.character_lighting_enable_mut()
    }
    fn voice_over_info(&self) -> &Option<Arc<Mutex<dyn super::audio::EntityVoiceOverInfoTrait>>> {
        self._glacier_base.voice_over_info()
    }
    fn voice_over_info_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::EntityVoiceOverInfoTrait>>> {
        self._glacier_base.voice_over_info_mut()
    }
    fn sound(&self) -> &Option<Arc<Mutex<dyn super::game_shared::CharacterSoundDataTrait>>> {
        self._glacier_base.sound()
    }
    fn sound_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::game_shared::CharacterSoundDataTrait>>> {
        self._glacier_base.sound_mut()
    }
}

impl super::gameplay_sim::ControllableEntityDataTrait for SoldierEntityData {
    fn use_prediction(&self) -> &bool {
        self._glacier_base.use_prediction()
    }
    fn use_prediction_mut(&mut self) -> &mut bool {
        self._glacier_base.use_prediction_mut()
    }
    fn default_team(&self) -> &super::gameplay_sim::TeamId {
        self._glacier_base.default_team()
    }
    fn default_team_mut(&mut self) -> &mut super::gameplay_sim::TeamId {
        self._glacier_base.default_team_mut()
    }
    fn reset_team_on_last_player_exits(&self) -> &bool {
        self._glacier_base.reset_team_on_last_player_exits()
    }
    fn reset_team_on_last_player_exits_mut(&mut self) -> &mut bool {
        self._glacier_base.reset_team_on_last_player_exits_mut()
    }
    fn immortal(&self) -> &bool {
        self._glacier_base.immortal()
    }
    fn immortal_mut(&mut self) -> &mut bool {
        self._glacier_base.immortal_mut()
    }
    fn fake_immortal(&self) -> &bool {
        self._glacier_base.fake_immortal()
    }
    fn fake_immortal_mut(&mut self) -> &mut bool {
        self._glacier_base.fake_immortal_mut()
    }
    fn low_health_threshold(&self) -> &f32 {
        self._glacier_base.low_health_threshold()
    }
    fn low_health_threshold_mut(&mut self) -> &mut f32 {
        self._glacier_base.low_health_threshold_mut()
    }
    fn material_pair(&self) -> &super::entity::MaterialDecl {
        self._glacier_base.material_pair()
    }
    fn material_pair_mut(&mut self) -> &mut super::entity::MaterialDecl {
        self._glacier_base.material_pair_mut()
    }
    fn force_foreground_rendering(&self) -> &bool {
        self._glacier_base.force_foreground_rendering()
    }
    fn force_foreground_rendering_mut(&mut self) -> &mut bool {
        self._glacier_base.force_foreground_rendering_mut()
    }
    fn suppressed_inputs(&self) -> &Vec<i32> {
        self._glacier_base.suppressed_inputs()
    }
    fn suppressed_inputs_mut(&mut self) -> &mut Vec<i32> {
        self._glacier_base.suppressed_inputs_mut()
    }
}

impl super::physics::GamePhysicsEntityDataTrait for SoldierEntityData {
}

impl super::entity::GameComponentEntityDataTrait for SoldierEntityData {
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::ComponentEntityDataTrait for SoldierEntityData {
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn part_bounding_boxes(&self) -> &Vec<super::core::AxisAlignedBox> {
        self._glacier_base.part_bounding_boxes()
    }
    fn part_bounding_boxes_mut(&mut self) -> &mut Vec<super::core::AxisAlignedBox> {
        self._glacier_base.part_bounding_boxes_mut()
    }
    fn client_runtime_component_count(&self) -> &u8 {
        self._glacier_base.client_runtime_component_count()
    }
    fn client_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_component_count_mut()
    }
    fn server_runtime_component_count(&self) -> &u8 {
        self._glacier_base.server_runtime_component_count()
    }
    fn server_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_component_count_mut()
    }
    fn client_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.client_runtime_transformation_count()
    }
    fn client_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_transformation_count_mut()
    }
    fn server_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.server_runtime_transformation_count()
    }
    fn server_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_transformation_count_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for SoldierEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for SoldierEntityData {
}

impl super::entity::GameObjectDataTrait for SoldierEntityData {
}

impl super::core::DataBusPeerTrait for SoldierEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SoldierEntityData {
}

impl super::core::DataContainerTrait for SoldierEntityData {
}

pub static SOLDIERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierEntityData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::game_shared::CHARACTERENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "FootMaterialPair",
                flags: MemberInfoFlags::new(0),
                field_type: "MaterialDecl",
                rust_offset: offset_of!(SoldierEntityData, foot_material_pair),
            },
            FieldInfoData {
                name: "HeadMaterialPair",
                flags: MemberInfoFlags::new(0),
                field_type: "MaterialDecl",
                rust_offset: offset_of!(SoldierEntityData, head_material_pair),
            },
            FieldInfoData {
                name: "BoneFakePhysics",
                flags: MemberInfoFlags::new(144),
                field_type: "BoneFakePhysicsData-Array",
                rust_offset: offset_of!(SoldierEntityData, bone_fake_physics),
            },
            FieldInfoData {
                name: "AutoAim",
                flags: MemberInfoFlags::new(0),
                field_type: "SoldierAutoAimData",
                rust_offset: offset_of!(SoldierEntityData, auto_aim),
            },
            FieldInfoData {
                name: "AimingConstraints",
                flags: MemberInfoFlags::new(0),
                field_type: "SoldierAimingConstraintsData",
                rust_offset: offset_of!(SoldierEntityData, aiming_constraints),
            },
            FieldInfoData {
                name: "HeadCollision",
                flags: MemberInfoFlags::new(0),
                field_type: "SoldierHeadCollisionData",
                rust_offset: offset_of!(SoldierEntityData, head_collision),
            },
            FieldInfoData {
                name: "CharacterPhysics",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterPhysicsData",
                rust_offset: offset_of!(SoldierEntityData, character_physics),
            },
            FieldInfoData {
                name: "SprintSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "SoldierSprintSettingsData",
                rust_offset: offset_of!(SoldierEntityData, sprint_settings),
            },
            FieldInfoData {
                name: "HidableMeshParts",
                flags: MemberInfoFlags::new(144),
                field_type: "HidableSoldierMeshWeaponPart-Array",
                rust_offset: offset_of!(SoldierEntityData, hidable_mesh_parts),
            },
            FieldInfoData {
                name: "ImpulseReactionTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierEntityData, impulse_reaction_time),
            },
            FieldInfoData {
                name: "ShowWeaponWhenDead",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierEntityData, show_weapon_when_dead),
            },
            FieldInfoData {
                name: "HealthModule",
                flags: MemberInfoFlags::new(0),
                field_type: "SoldierHealthModuleData",
                rust_offset: offset_of!(SoldierEntityData, health_module),
            },
            FieldInfoData {
                name: "AbortSpawnInvisibilityInputs",
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(SoldierEntityData, abort_spawn_invisibility_inputs),
            },
            FieldInfoData {
                name: "EnableGroundmapLighting",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierEntityData, enable_groundmap_lighting),
            },
            FieldInfoData {
                name: "LowerGunOnOwnTeam",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierEntityData, lower_gun_on_own_team),
            },
            FieldInfoData {
                name: "ProximityCheck",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierEntityData, proximity_check),
            },
            FieldInfoData {
                name: "FreeSpaceCheck",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierEntityData, free_space_check),
            },
            FieldInfoData {
                name: "BreathControl",
                flags: MemberInfoFlags::new(144),
                field_type: "BreathControlData-Array",
                rust_offset: offset_of!(SoldierEntityData, breath_control),
            },
            FieldInfoData {
                name: "CollisionInfo",
                flags: MemberInfoFlags::new(0),
                field_type: "CollisionData",
                rust_offset: offset_of!(SoldierEntityData, collision_info),
            },
            FieldInfoData {
                name: "FLIRValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierEntityData, f_l_i_r_value),
            },
            FieldInfoData {
                name: "FLIRKeyColor",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SoldierEntityData, f_l_i_r_key_color),
            },
            FieldInfoData {
                name: "ExplosionDamageModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierEntityData, explosion_damage_modifier),
            },
            FieldInfoData {
                name: "RegenerationDelayModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierEntityData, regeneration_delay_modifier),
            },
            FieldInfoData {
                name: "FallDamageThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierEntityData, fall_damage_threshold),
            },
            FieldInfoData {
                name: "CollisionEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierEntityData, collision_enabled),
            },
            FieldInfoData {
                name: "PhysicsControlled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierEntityData, physics_controlled),
            },
            FieldInfoData {
                name: "IsPushable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierEntityData, is_pushable),
            },
            FieldInfoData {
                name: "HumanPlayerControlled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierEntityData, human_player_controlled),
            },
            FieldInfoData {
                name: "BlueprintNameHash",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(SoldierEntityData, blueprint_name_hash),
            },
            FieldInfoData {
                name: "InteractiveManDownAllowed",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierEntityData, interactive_man_down_allowed),
            },
            FieldInfoData {
                name: "ShowNametag",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierEntityData, show_nametag),
            },
            FieldInfoData {
                name: "VisualCullScreenArea",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierEntityData, visual_cull_screen_area),
            },
            FieldInfoData {
                name: "AimFollowEyeTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierEntityData, aim_follow_eye_transform),
            },
            FieldInfoData {
                name: "ForceDisableRenderFirstPersonInForeground",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierEntityData, force_disable_render_first_person_in_foreground),
            },
        ],
    }),
    array_type: Some(SOLDIERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SoldierEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOLDIERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SoldierEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum SoldierActionState {
    #[default]
    Jumping = 0,
    Walking = 1,
    Sliding = 2,
    Air = 3,
    Falling = 4,
    Parachute = 5,
    Swim = 6,
    Climb = 7,
    AnimationDriven = 8,
}

pub static SOLDIERACTIONSTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierActionState",
    flags: MemberInfoFlags::new(49429),
    module: "SoldierShared",
    data: TypeInfoData::Enum,
    array_type: Some(SOLDIERACTIONSTATE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SoldierActionState {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERACTIONSTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SOLDIERACTIONSTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierActionState-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SoldierActionState"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoldierHealthModuleData {
    pub _glacier_base: super::core::DataContainer,
}

pub trait SoldierHealthModuleDataTrait: super::core::DataContainerTrait {
}

impl SoldierHealthModuleDataTrait for SoldierHealthModuleData {
}

impl super::core::DataContainerTrait for SoldierHealthModuleData {
}

pub static SOLDIERHEALTHMODULEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierHealthModuleData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierHealthModuleData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SOLDIERHEALTHMODULEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoldierHealthModuleData {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERHEALTHMODULEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOLDIERHEALTHMODULEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierHealthModuleData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SoldierHealthModuleData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BreathControlData {
    pub _glacier_base: super::core::DataContainer,
    pub breath_control_time: f32,
    pub breath_control_release_time: f32,
    pub breath_control_penalty_multiplier: f32,
    pub breath_control_penalty_timeout: f32,
}

pub trait BreathControlDataTrait: super::core::DataContainerTrait {
    fn breath_control_time(&self) -> &f32;
    fn breath_control_time_mut(&mut self) -> &mut f32;
    fn breath_control_release_time(&self) -> &f32;
    fn breath_control_release_time_mut(&mut self) -> &mut f32;
    fn breath_control_penalty_multiplier(&self) -> &f32;
    fn breath_control_penalty_multiplier_mut(&mut self) -> &mut f32;
    fn breath_control_penalty_timeout(&self) -> &f32;
    fn breath_control_penalty_timeout_mut(&mut self) -> &mut f32;
}

impl BreathControlDataTrait for BreathControlData {
    fn breath_control_time(&self) -> &f32 {
        &self.breath_control_time
    }
    fn breath_control_time_mut(&mut self) -> &mut f32 {
        &mut self.breath_control_time
    }
    fn breath_control_release_time(&self) -> &f32 {
        &self.breath_control_release_time
    }
    fn breath_control_release_time_mut(&mut self) -> &mut f32 {
        &mut self.breath_control_release_time
    }
    fn breath_control_penalty_multiplier(&self) -> &f32 {
        &self.breath_control_penalty_multiplier
    }
    fn breath_control_penalty_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.breath_control_penalty_multiplier
    }
    fn breath_control_penalty_timeout(&self) -> &f32 {
        &self.breath_control_penalty_timeout
    }
    fn breath_control_penalty_timeout_mut(&mut self) -> &mut f32 {
        &mut self.breath_control_penalty_timeout
    }
}

impl super::core::DataContainerTrait for BreathControlData {
}

pub static BREATHCONTROLDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BreathControlData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BreathControlData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "BreathControlTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BreathControlData, breath_control_time),
            },
            FieldInfoData {
                name: "BreathControlReleaseTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BreathControlData, breath_control_release_time),
            },
            FieldInfoData {
                name: "BreathControlPenaltyMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BreathControlData, breath_control_penalty_multiplier),
            },
            FieldInfoData {
                name: "BreathControlPenaltyTimeout",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BreathControlData, breath_control_penalty_timeout),
            },
        ],
    }),
    array_type: Some(BREATHCONTROLDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BreathControlData {
    fn type_info(&self) -> &'static TypeInfo {
        BREATHCONTROLDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BREATHCONTROLDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BreathControlData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("BreathControlData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CollisionData {
    pub _glacier_base: super::core::DataContainer,
    pub damage_at_vertical_velocity: Vec<ValueAtX>,
    pub damage_at_horiz_velocity: Vec<ValueAtX>,
}

pub trait CollisionDataTrait: super::core::DataContainerTrait {
    fn damage_at_vertical_velocity(&self) -> &Vec<ValueAtX>;
    fn damage_at_vertical_velocity_mut(&mut self) -> &mut Vec<ValueAtX>;
    fn damage_at_horiz_velocity(&self) -> &Vec<ValueAtX>;
    fn damage_at_horiz_velocity_mut(&mut self) -> &mut Vec<ValueAtX>;
}

impl CollisionDataTrait for CollisionData {
    fn damage_at_vertical_velocity(&self) -> &Vec<ValueAtX> {
        &self.damage_at_vertical_velocity
    }
    fn damage_at_vertical_velocity_mut(&mut self) -> &mut Vec<ValueAtX> {
        &mut self.damage_at_vertical_velocity
    }
    fn damage_at_horiz_velocity(&self) -> &Vec<ValueAtX> {
        &self.damage_at_horiz_velocity
    }
    fn damage_at_horiz_velocity_mut(&mut self) -> &mut Vec<ValueAtX> {
        &mut self.damage_at_horiz_velocity
    }
}

impl super::core::DataContainerTrait for CollisionData {
}

pub static COLLISIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CollisionData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CollisionData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DamageAtVerticalVelocity",
                flags: MemberInfoFlags::new(144),
                field_type: "ValueAtX-Array",
                rust_offset: offset_of!(CollisionData, damage_at_vertical_velocity),
            },
            FieldInfoData {
                name: "DamageAtHorizVelocity",
                flags: MemberInfoFlags::new(144),
                field_type: "ValueAtX-Array",
                rust_offset: offset_of!(CollisionData, damage_at_horiz_velocity),
            },
        ],
    }),
    array_type: Some(COLLISIONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CollisionData {
    fn type_info(&self) -> &'static TypeInfo {
        COLLISIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COLLISIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CollisionData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("CollisionData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ValueAtX {
    pub x: f32,
    pub value: f32,
}

pub trait ValueAtXTrait: TypeObject {
    fn x(&self) -> &f32;
    fn x_mut(&mut self) -> &mut f32;
    fn value(&self) -> &f32;
    fn value_mut(&mut self) -> &mut f32;
}

impl ValueAtXTrait for ValueAtX {
    fn x(&self) -> &f32 {
        &self.x
    }
    fn x_mut(&mut self) -> &mut f32 {
        &mut self.x
    }
    fn value(&self) -> &f32 {
        &self.value
    }
    fn value_mut(&mut self) -> &mut f32 {
        &mut self.value
    }
}

pub static VALUEATX_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ValueAtX",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ValueAtX as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "X",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ValueAtX, x),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ValueAtX, value),
            },
        ],
    }),
    array_type: Some(VALUEATX_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for ValueAtX {
    fn type_info(&self) -> &'static TypeInfo {
        VALUEATX_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VALUEATX_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ValueAtX-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("ValueAtX"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoldierWeaponOverrideData {
    pub _glacier_base: super::core::DataContainer,
    pub overrides: Vec<Option<Arc<Mutex<dyn WeaponOverrideDataTrait>>>>,
}

pub trait SoldierWeaponOverrideDataTrait: super::core::DataContainerTrait {
    fn overrides(&self) -> &Vec<Option<Arc<Mutex<dyn WeaponOverrideDataTrait>>>>;
    fn overrides_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn WeaponOverrideDataTrait>>>>;
}

impl SoldierWeaponOverrideDataTrait for SoldierWeaponOverrideData {
    fn overrides(&self) -> &Vec<Option<Arc<Mutex<dyn WeaponOverrideDataTrait>>>> {
        &self.overrides
    }
    fn overrides_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn WeaponOverrideDataTrait>>>> {
        &mut self.overrides
    }
}

impl super::core::DataContainerTrait for SoldierWeaponOverrideData {
}

pub static SOLDIERWEAPONOVERRIDEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierWeaponOverrideData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierWeaponOverrideData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Overrides",
                flags: MemberInfoFlags::new(144),
                field_type: "WeaponOverrideData-Array",
                rust_offset: offset_of!(SoldierWeaponOverrideData, overrides),
            },
        ],
    }),
    array_type: Some(SOLDIERWEAPONOVERRIDEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoldierWeaponOverrideData {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERWEAPONOVERRIDEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOLDIERWEAPONOVERRIDEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierWeaponOverrideData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SoldierWeaponOverrideData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoldierSprintSettingsData {
    pub _glacier_base: super::core::DataContainer,
    pub fov: f32,
    pub fov_in_delay: f32,
    pub fov_in_time: f32,
    pub fov_out_delay: f32,
    pub fov_out_time: f32,
    pub recover_time: f32,
    pub sprint_to_prone_recover_time: f32,
    pub interrupting_actions: Vec<i32>,
    pub sprint_interrupt_recover_time: f32,
}

pub trait SoldierSprintSettingsDataTrait: super::core::DataContainerTrait {
    fn fov(&self) -> &f32;
    fn fov_mut(&mut self) -> &mut f32;
    fn fov_in_delay(&self) -> &f32;
    fn fov_in_delay_mut(&mut self) -> &mut f32;
    fn fov_in_time(&self) -> &f32;
    fn fov_in_time_mut(&mut self) -> &mut f32;
    fn fov_out_delay(&self) -> &f32;
    fn fov_out_delay_mut(&mut self) -> &mut f32;
    fn fov_out_time(&self) -> &f32;
    fn fov_out_time_mut(&mut self) -> &mut f32;
    fn recover_time(&self) -> &f32;
    fn recover_time_mut(&mut self) -> &mut f32;
    fn sprint_to_prone_recover_time(&self) -> &f32;
    fn sprint_to_prone_recover_time_mut(&mut self) -> &mut f32;
    fn interrupting_actions(&self) -> &Vec<i32>;
    fn interrupting_actions_mut(&mut self) -> &mut Vec<i32>;
    fn sprint_interrupt_recover_time(&self) -> &f32;
    fn sprint_interrupt_recover_time_mut(&mut self) -> &mut f32;
}

impl SoldierSprintSettingsDataTrait for SoldierSprintSettingsData {
    fn fov(&self) -> &f32 {
        &self.fov
    }
    fn fov_mut(&mut self) -> &mut f32 {
        &mut self.fov
    }
    fn fov_in_delay(&self) -> &f32 {
        &self.fov_in_delay
    }
    fn fov_in_delay_mut(&mut self) -> &mut f32 {
        &mut self.fov_in_delay
    }
    fn fov_in_time(&self) -> &f32 {
        &self.fov_in_time
    }
    fn fov_in_time_mut(&mut self) -> &mut f32 {
        &mut self.fov_in_time
    }
    fn fov_out_delay(&self) -> &f32 {
        &self.fov_out_delay
    }
    fn fov_out_delay_mut(&mut self) -> &mut f32 {
        &mut self.fov_out_delay
    }
    fn fov_out_time(&self) -> &f32 {
        &self.fov_out_time
    }
    fn fov_out_time_mut(&mut self) -> &mut f32 {
        &mut self.fov_out_time
    }
    fn recover_time(&self) -> &f32 {
        &self.recover_time
    }
    fn recover_time_mut(&mut self) -> &mut f32 {
        &mut self.recover_time
    }
    fn sprint_to_prone_recover_time(&self) -> &f32 {
        &self.sprint_to_prone_recover_time
    }
    fn sprint_to_prone_recover_time_mut(&mut self) -> &mut f32 {
        &mut self.sprint_to_prone_recover_time
    }
    fn interrupting_actions(&self) -> &Vec<i32> {
        &self.interrupting_actions
    }
    fn interrupting_actions_mut(&mut self) -> &mut Vec<i32> {
        &mut self.interrupting_actions
    }
    fn sprint_interrupt_recover_time(&self) -> &f32 {
        &self.sprint_interrupt_recover_time
    }
    fn sprint_interrupt_recover_time_mut(&mut self) -> &mut f32 {
        &mut self.sprint_interrupt_recover_time
    }
}

impl super::core::DataContainerTrait for SoldierSprintSettingsData {
}

pub static SOLDIERSPRINTSETTINGSDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierSprintSettingsData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierSprintSettingsData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Fov",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierSprintSettingsData, fov),
            },
            FieldInfoData {
                name: "FovInDelay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierSprintSettingsData, fov_in_delay),
            },
            FieldInfoData {
                name: "FovInTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierSprintSettingsData, fov_in_time),
            },
            FieldInfoData {
                name: "FovOutDelay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierSprintSettingsData, fov_out_delay),
            },
            FieldInfoData {
                name: "FovOutTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierSprintSettingsData, fov_out_time),
            },
            FieldInfoData {
                name: "RecoverTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierSprintSettingsData, recover_time),
            },
            FieldInfoData {
                name: "SprintToProneRecoverTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierSprintSettingsData, sprint_to_prone_recover_time),
            },
            FieldInfoData {
                name: "InterruptingActions",
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(SoldierSprintSettingsData, interrupting_actions),
            },
            FieldInfoData {
                name: "SprintInterruptRecoverTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierSprintSettingsData, sprint_interrupt_recover_time),
            },
        ],
    }),
    array_type: Some(SOLDIERSPRINTSETTINGSDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoldierSprintSettingsData {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERSPRINTSETTINGSDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOLDIERSPRINTSETTINGSDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierSprintSettingsData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SoldierSprintSettingsData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum DeathAnimationOperation {
    #[default]
    DALessThan = 0,
    DAGreaterThan = 1,
    DAEqualTo = 2,
}

pub static DEATHANIMATIONOPERATION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DeathAnimationOperation",
    flags: MemberInfoFlags::new(49429),
    module: "SoldierShared",
    data: TypeInfoData::Enum,
    array_type: Some(DEATHANIMATIONOPERATION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for DeathAnimationOperation {
    fn type_info(&self) -> &'static TypeInfo {
        DEATHANIMATIONOPERATION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static DEATHANIMATIONOPERATION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DeathAnimationOperation-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("DeathAnimationOperation"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct HidableSoldierMeshWeaponPart {
    pub weapon_mesh: Option<Arc<Mutex<dyn super::render::SkinnedMeshAssetTrait>>>,
    pub weapon_mesh_blueprint: Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>>,
    pub bone_name: String,
    pub hide_always: bool,
    pub hide_in_vehicle_entries: bool,
}

pub trait HidableSoldierMeshWeaponPartTrait: TypeObject {
    fn weapon_mesh(&self) -> &Option<Arc<Mutex<dyn super::render::SkinnedMeshAssetTrait>>>;
    fn weapon_mesh_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render::SkinnedMeshAssetTrait>>>;
    fn weapon_mesh_blueprint(&self) -> &Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>>;
    fn weapon_mesh_blueprint_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>>;
    fn bone_name(&self) -> &String;
    fn bone_name_mut(&mut self) -> &mut String;
    fn hide_always(&self) -> &bool;
    fn hide_always_mut(&mut self) -> &mut bool;
    fn hide_in_vehicle_entries(&self) -> &bool;
    fn hide_in_vehicle_entries_mut(&mut self) -> &mut bool;
}

impl HidableSoldierMeshWeaponPartTrait for HidableSoldierMeshWeaponPart {
    fn weapon_mesh(&self) -> &Option<Arc<Mutex<dyn super::render::SkinnedMeshAssetTrait>>> {
        &self.weapon_mesh
    }
    fn weapon_mesh_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render::SkinnedMeshAssetTrait>>> {
        &mut self.weapon_mesh
    }
    fn weapon_mesh_blueprint(&self) -> &Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>> {
        &self.weapon_mesh_blueprint
    }
    fn weapon_mesh_blueprint_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>> {
        &mut self.weapon_mesh_blueprint
    }
    fn bone_name(&self) -> &String {
        &self.bone_name
    }
    fn bone_name_mut(&mut self) -> &mut String {
        &mut self.bone_name
    }
    fn hide_always(&self) -> &bool {
        &self.hide_always
    }
    fn hide_always_mut(&mut self) -> &mut bool {
        &mut self.hide_always
    }
    fn hide_in_vehicle_entries(&self) -> &bool {
        &self.hide_in_vehicle_entries
    }
    fn hide_in_vehicle_entries_mut(&mut self) -> &mut bool {
        &mut self.hide_in_vehicle_entries
    }
}

pub static HIDABLESOLDIERMESHWEAPONPART_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HidableSoldierMeshWeaponPart",
    flags: MemberInfoFlags::new(73),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<HidableSoldierMeshWeaponPart as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "WeaponMesh",
                flags: MemberInfoFlags::new(0),
                field_type: "SkinnedMeshAsset",
                rust_offset: offset_of!(HidableSoldierMeshWeaponPart, weapon_mesh),
            },
            FieldInfoData {
                name: "WeaponMeshBlueprint",
                flags: MemberInfoFlags::new(0),
                field_type: "ObjectBlueprint",
                rust_offset: offset_of!(HidableSoldierMeshWeaponPart, weapon_mesh_blueprint),
            },
            FieldInfoData {
                name: "BoneName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(HidableSoldierMeshWeaponPart, bone_name),
            },
            FieldInfoData {
                name: "HideAlways",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(HidableSoldierMeshWeaponPart, hide_always),
            },
            FieldInfoData {
                name: "HideInVehicleEntries",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(HidableSoldierMeshWeaponPart, hide_in_vehicle_entries),
            },
        ],
    }),
    array_type: Some(HIDABLESOLDIERMESHWEAPONPART_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for HidableSoldierMeshWeaponPart {
    fn type_info(&self) -> &'static TypeInfo {
        HIDABLESOLDIERMESHWEAPONPART_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static HIDABLESOLDIERMESHWEAPONPART_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HidableSoldierMeshWeaponPart-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("HidableSoldierMeshWeaponPart"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoldierHeadCollisionData {
    pub _glacier_base: super::core::DataContainer,
    pub head_radius: f32,
    pub pose_states: Vec<SoldierHeadCollisionPoseData>,
}

pub trait SoldierHeadCollisionDataTrait: super::core::DataContainerTrait {
    fn head_radius(&self) -> &f32;
    fn head_radius_mut(&mut self) -> &mut f32;
    fn pose_states(&self) -> &Vec<SoldierHeadCollisionPoseData>;
    fn pose_states_mut(&mut self) -> &mut Vec<SoldierHeadCollisionPoseData>;
}

impl SoldierHeadCollisionDataTrait for SoldierHeadCollisionData {
    fn head_radius(&self) -> &f32 {
        &self.head_radius
    }
    fn head_radius_mut(&mut self) -> &mut f32 {
        &mut self.head_radius
    }
    fn pose_states(&self) -> &Vec<SoldierHeadCollisionPoseData> {
        &self.pose_states
    }
    fn pose_states_mut(&mut self) -> &mut Vec<SoldierHeadCollisionPoseData> {
        &mut self.pose_states
    }
}

impl super::core::DataContainerTrait for SoldierHeadCollisionData {
}

pub static SOLDIERHEADCOLLISIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierHeadCollisionData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierHeadCollisionData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "HeadRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierHeadCollisionData, head_radius),
            },
            FieldInfoData {
                name: "PoseStates",
                flags: MemberInfoFlags::new(144),
                field_type: "SoldierHeadCollisionPoseData-Array",
                rust_offset: offset_of!(SoldierHeadCollisionData, pose_states),
            },
        ],
    }),
    array_type: Some(SOLDIERHEADCOLLISIONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoldierHeadCollisionData {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERHEADCOLLISIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOLDIERHEADCOLLISIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierHeadCollisionData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SoldierHeadCollisionData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoldierHeadCollisionPoseData {
    pub idle_offset: super::core::Vec3,
    pub moving_forward_offset: super::core::Vec3,
}

pub trait SoldierHeadCollisionPoseDataTrait: TypeObject {
    fn idle_offset(&self) -> &super::core::Vec3;
    fn idle_offset_mut(&mut self) -> &mut super::core::Vec3;
    fn moving_forward_offset(&self) -> &super::core::Vec3;
    fn moving_forward_offset_mut(&mut self) -> &mut super::core::Vec3;
}

impl SoldierHeadCollisionPoseDataTrait for SoldierHeadCollisionPoseData {
    fn idle_offset(&self) -> &super::core::Vec3 {
        &self.idle_offset
    }
    fn idle_offset_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.idle_offset
    }
    fn moving_forward_offset(&self) -> &super::core::Vec3 {
        &self.moving_forward_offset
    }
    fn moving_forward_offset_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.moving_forward_offset
    }
}

pub static SOLDIERHEADCOLLISIONPOSEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierHeadCollisionPoseData",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierHeadCollisionPoseData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "IdleOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SoldierHeadCollisionPoseData, idle_offset),
            },
            FieldInfoData {
                name: "MovingForwardOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SoldierHeadCollisionPoseData, moving_forward_offset),
            },
        ],
    }),
    array_type: Some(SOLDIERHEADCOLLISIONPOSEDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SoldierHeadCollisionPoseData {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERHEADCOLLISIONPOSEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SOLDIERHEADCOLLISIONPOSEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierHeadCollisionPoseData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SoldierHeadCollisionPoseData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoldierAutoAimData {
    pub _glacier_base: super::core::DataContainer,
    pub poses: Vec<AutoAimData>,
}

pub trait SoldierAutoAimDataTrait: super::core::DataContainerTrait {
    fn poses(&self) -> &Vec<AutoAimData>;
    fn poses_mut(&mut self) -> &mut Vec<AutoAimData>;
}

impl SoldierAutoAimDataTrait for SoldierAutoAimData {
    fn poses(&self) -> &Vec<AutoAimData> {
        &self.poses
    }
    fn poses_mut(&mut self) -> &mut Vec<AutoAimData> {
        &mut self.poses
    }
}

impl super::core::DataContainerTrait for SoldierAutoAimData {
}

pub static SOLDIERAUTOAIMDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierAutoAimData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierAutoAimData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Poses",
                flags: MemberInfoFlags::new(144),
                field_type: "AutoAimData-Array",
                rust_offset: offset_of!(SoldierAutoAimData, poses),
            },
        ],
    }),
    array_type: Some(SOLDIERAUTOAIMDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoldierAutoAimData {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERAUTOAIMDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOLDIERAUTOAIMDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierAutoAimData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SoldierAutoAimData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AutoAimData {
    pub auto_aim_outer_box_offset: super::core::Vec3,
    pub auto_aim_outer_box_extends: super::core::Vec3,
    pub auto_aim_inner_box_offset: super::core::Vec3,
    pub auto_aim_inner_box_extends: super::core::Vec3,
    pub pose_type: super::physics::CharacterPoseType,
}

pub trait AutoAimDataTrait: TypeObject {
    fn auto_aim_outer_box_offset(&self) -> &super::core::Vec3;
    fn auto_aim_outer_box_offset_mut(&mut self) -> &mut super::core::Vec3;
    fn auto_aim_outer_box_extends(&self) -> &super::core::Vec3;
    fn auto_aim_outer_box_extends_mut(&mut self) -> &mut super::core::Vec3;
    fn auto_aim_inner_box_offset(&self) -> &super::core::Vec3;
    fn auto_aim_inner_box_offset_mut(&mut self) -> &mut super::core::Vec3;
    fn auto_aim_inner_box_extends(&self) -> &super::core::Vec3;
    fn auto_aim_inner_box_extends_mut(&mut self) -> &mut super::core::Vec3;
    fn pose_type(&self) -> &super::physics::CharacterPoseType;
    fn pose_type_mut(&mut self) -> &mut super::physics::CharacterPoseType;
}

impl AutoAimDataTrait for AutoAimData {
    fn auto_aim_outer_box_offset(&self) -> &super::core::Vec3 {
        &self.auto_aim_outer_box_offset
    }
    fn auto_aim_outer_box_offset_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.auto_aim_outer_box_offset
    }
    fn auto_aim_outer_box_extends(&self) -> &super::core::Vec3 {
        &self.auto_aim_outer_box_extends
    }
    fn auto_aim_outer_box_extends_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.auto_aim_outer_box_extends
    }
    fn auto_aim_inner_box_offset(&self) -> &super::core::Vec3 {
        &self.auto_aim_inner_box_offset
    }
    fn auto_aim_inner_box_offset_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.auto_aim_inner_box_offset
    }
    fn auto_aim_inner_box_extends(&self) -> &super::core::Vec3 {
        &self.auto_aim_inner_box_extends
    }
    fn auto_aim_inner_box_extends_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.auto_aim_inner_box_extends
    }
    fn pose_type(&self) -> &super::physics::CharacterPoseType {
        &self.pose_type
    }
    fn pose_type_mut(&mut self) -> &mut super::physics::CharacterPoseType {
        &mut self.pose_type
    }
}

pub static AUTOAIMDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AutoAimData",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AutoAimData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AutoAimOuterBoxOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(AutoAimData, auto_aim_outer_box_offset),
            },
            FieldInfoData {
                name: "AutoAimOuterBoxExtends",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(AutoAimData, auto_aim_outer_box_extends),
            },
            FieldInfoData {
                name: "AutoAimInnerBoxOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(AutoAimData, auto_aim_inner_box_offset),
            },
            FieldInfoData {
                name: "AutoAimInnerBoxExtends",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(AutoAimData, auto_aim_inner_box_extends),
            },
            FieldInfoData {
                name: "PoseType",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterPoseType",
                rust_offset: offset_of!(AutoAimData, pose_type),
            },
        ],
    }),
    array_type: Some(AUTOAIMDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AutoAimData {
    fn type_info(&self) -> &'static TypeInfo {
        AUTOAIMDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AUTOAIMDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AutoAimData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("AutoAimData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FootStepTrigger {
    pub time: f32,
}

pub trait FootStepTriggerTrait: TypeObject {
    fn time(&self) -> &f32;
    fn time_mut(&mut self) -> &mut f32;
}

impl FootStepTriggerTrait for FootStepTrigger {
    fn time(&self) -> &f32 {
        &self.time
    }
    fn time_mut(&mut self) -> &mut f32 {
        &mut self.time
    }
}

pub static FOOTSTEPTRIGGER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FootStepTrigger",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FootStepTrigger as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Time",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FootStepTrigger, time),
            },
        ],
    }),
    array_type: Some(FOOTSTEPTRIGGER_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for FootStepTrigger {
    fn type_info(&self) -> &'static TypeInfo {
        FOOTSTEPTRIGGER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static FOOTSTEPTRIGGER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FootStepTrigger-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("FootStepTrigger"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoldierSoundData {
    pub _glacier_base: super::game_shared::CharacterSoundData,
    pub death: Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>,
    pub bullet_impact: Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>,
    pub healing: Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>,
    pub breath_control: Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>,
    pub hit_indicator: Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>,
    pub pickup_kit: Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>,
    pub pickup_ammo: Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>,
    pub sprint_time_for_recovery: f32,
    pub movement_threshold: f32,
    pub min_heal_sound_time: f32,
}

pub trait SoldierSoundDataTrait: super::game_shared::CharacterSoundDataTrait {
    fn death(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn death_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn bullet_impact(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn bullet_impact_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn healing(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn healing_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn breath_control(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn breath_control_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn hit_indicator(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn hit_indicator_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn pickup_kit(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn pickup_kit_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn pickup_ammo(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn pickup_ammo_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn sprint_time_for_recovery(&self) -> &f32;
    fn sprint_time_for_recovery_mut(&mut self) -> &mut f32;
    fn movement_threshold(&self) -> &f32;
    fn movement_threshold_mut(&mut self) -> &mut f32;
    fn min_heal_sound_time(&self) -> &f32;
    fn min_heal_sound_time_mut(&mut self) -> &mut f32;
}

impl SoldierSoundDataTrait for SoldierSoundData {
    fn death(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &self.death
    }
    fn death_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &mut self.death
    }
    fn bullet_impact(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &self.bullet_impact
    }
    fn bullet_impact_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &mut self.bullet_impact
    }
    fn healing(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &self.healing
    }
    fn healing_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &mut self.healing
    }
    fn breath_control(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &self.breath_control
    }
    fn breath_control_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &mut self.breath_control
    }
    fn hit_indicator(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &self.hit_indicator
    }
    fn hit_indicator_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &mut self.hit_indicator
    }
    fn pickup_kit(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &self.pickup_kit
    }
    fn pickup_kit_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &mut self.pickup_kit
    }
    fn pickup_ammo(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &self.pickup_ammo
    }
    fn pickup_ammo_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &mut self.pickup_ammo
    }
    fn sprint_time_for_recovery(&self) -> &f32 {
        &self.sprint_time_for_recovery
    }
    fn sprint_time_for_recovery_mut(&mut self) -> &mut f32 {
        &mut self.sprint_time_for_recovery
    }
    fn movement_threshold(&self) -> &f32 {
        &self.movement_threshold
    }
    fn movement_threshold_mut(&mut self) -> &mut f32 {
        &mut self.movement_threshold
    }
    fn min_heal_sound_time(&self) -> &f32 {
        &self.min_heal_sound_time
    }
    fn min_heal_sound_time_mut(&mut self) -> &mut f32 {
        &mut self.min_heal_sound_time
    }
}

impl super::game_shared::CharacterSoundDataTrait for SoldierSoundData {
    fn movement(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        self._glacier_base.movement()
    }
    fn movement_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        self._glacier_base.movement_mut()
    }
}

impl super::core::DataContainerTrait for SoldierSoundData {
}

pub static SOLDIERSOUNDDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierSoundData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::game_shared::CHARACTERSOUNDDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierSoundData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Death",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(SoldierSoundData, death),
            },
            FieldInfoData {
                name: "BulletImpact",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(SoldierSoundData, bullet_impact),
            },
            FieldInfoData {
                name: "Healing",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(SoldierSoundData, healing),
            },
            FieldInfoData {
                name: "BreathControl",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(SoldierSoundData, breath_control),
            },
            FieldInfoData {
                name: "HitIndicator",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(SoldierSoundData, hit_indicator),
            },
            FieldInfoData {
                name: "PickupKit",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(SoldierSoundData, pickup_kit),
            },
            FieldInfoData {
                name: "PickupAmmo",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(SoldierSoundData, pickup_ammo),
            },
            FieldInfoData {
                name: "SprintTimeForRecovery",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierSoundData, sprint_time_for_recovery),
            },
            FieldInfoData {
                name: "MovementThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierSoundData, movement_threshold),
            },
            FieldInfoData {
                name: "MinHealSoundTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierSoundData, min_heal_sound_time),
            },
        ],
    }),
    array_type: Some(SOLDIERSOUNDDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoldierSoundData {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERSOUNDDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOLDIERSOUNDDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierSoundData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SoldierSoundData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MaterialPropertySolderSoundData {
    pub _glacier_base: super::gameplay_sim::MaterialPropertyLicenseeSoundData,
    pub foot_step_sound: Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>,
    pub prone_sound: Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>,
    pub land_sound: Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>,
}

pub trait MaterialPropertySolderSoundDataTrait: super::gameplay_sim::MaterialPropertyLicenseeSoundDataTrait {
    fn foot_step_sound(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn foot_step_sound_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn prone_sound(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn prone_sound_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn land_sound(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn land_sound_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
}

impl MaterialPropertySolderSoundDataTrait for MaterialPropertySolderSoundData {
    fn foot_step_sound(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &self.foot_step_sound
    }
    fn foot_step_sound_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &mut self.foot_step_sound
    }
    fn prone_sound(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &self.prone_sound
    }
    fn prone_sound_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &mut self.prone_sound
    }
    fn land_sound(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &self.land_sound
    }
    fn land_sound_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &mut self.land_sound
    }
}

impl super::gameplay_sim::MaterialPropertyLicenseeSoundDataTrait for MaterialPropertySolderSoundData {
}

impl super::core::DataContainerTrait for MaterialPropertySolderSoundData {
}

pub static MATERIALPROPERTYSOLDERSOUNDDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MaterialPropertySolderSoundData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::MATERIALPROPERTYLICENSEESOUNDDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MaterialPropertySolderSoundData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "FootStepSound",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(MaterialPropertySolderSoundData, foot_step_sound),
            },
            FieldInfoData {
                name: "ProneSound",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(MaterialPropertySolderSoundData, prone_sound),
            },
            FieldInfoData {
                name: "LandSound",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(MaterialPropertySolderSoundData, land_sound),
            },
        ],
    }),
    array_type: Some(MATERIALPROPERTYSOLDERSOUNDDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MaterialPropertySolderSoundData {
    fn type_info(&self) -> &'static TypeInfo {
        MATERIALPROPERTYSOLDERSOUNDDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MATERIALPROPERTYSOLDERSOUNDDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MaterialPropertySolderSoundData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("MaterialPropertySolderSoundData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoldierAimingConstraintsData {
    pub _glacier_base: super::core::DataContainer,
    pub swimming_constraints: super::gameplay_sim::AimingConstraintsData,
}

pub trait SoldierAimingConstraintsDataTrait: super::core::DataContainerTrait {
    fn swimming_constraints(&self) -> &super::gameplay_sim::AimingConstraintsData;
    fn swimming_constraints_mut(&mut self) -> &mut super::gameplay_sim::AimingConstraintsData;
}

impl SoldierAimingConstraintsDataTrait for SoldierAimingConstraintsData {
    fn swimming_constraints(&self) -> &super::gameplay_sim::AimingConstraintsData {
        &self.swimming_constraints
    }
    fn swimming_constraints_mut(&mut self) -> &mut super::gameplay_sim::AimingConstraintsData {
        &mut self.swimming_constraints
    }
}

impl super::core::DataContainerTrait for SoldierAimingConstraintsData {
}

pub static SOLDIERAIMINGCONSTRAINTSDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierAimingConstraintsData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierAimingConstraintsData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SwimmingConstraints",
                flags: MemberInfoFlags::new(0),
                field_type: "AimingConstraintsData",
                rust_offset: offset_of!(SoldierAimingConstraintsData, swimming_constraints),
            },
        ],
    }),
    array_type: Some(SOLDIERAIMINGCONSTRAINTSDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoldierAimingConstraintsData {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERAIMINGCONSTRAINTSDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOLDIERAIMINGCONSTRAINTSDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierAimingConstraintsData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SoldierAimingConstraintsData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EyeRecoilNetState {
    pub recoil_compensation_x: f32,
    pub recoil_compensation_y: f32,
}

pub trait EyeRecoilNetStateTrait: TypeObject {
    fn recoil_compensation_x(&self) -> &f32;
    fn recoil_compensation_x_mut(&mut self) -> &mut f32;
    fn recoil_compensation_y(&self) -> &f32;
    fn recoil_compensation_y_mut(&mut self) -> &mut f32;
}

impl EyeRecoilNetStateTrait for EyeRecoilNetState {
    fn recoil_compensation_x(&self) -> &f32 {
        &self.recoil_compensation_x
    }
    fn recoil_compensation_x_mut(&mut self) -> &mut f32 {
        &mut self.recoil_compensation_x
    }
    fn recoil_compensation_y(&self) -> &f32 {
        &self.recoil_compensation_y
    }
    fn recoil_compensation_y_mut(&mut self) -> &mut f32 {
        &mut self.recoil_compensation_y
    }
}

pub static EYERECOILNETSTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EyeRecoilNetState",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EyeRecoilNetState as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "RecoilCompensationX",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EyeRecoilNetState, recoil_compensation_x),
            },
            FieldInfoData {
                name: "RecoilCompensationY",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EyeRecoilNetState, recoil_compensation_y),
            },
        ],
    }),
    array_type: Some(EYERECOILNETSTATE_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for EyeRecoilNetState {
    fn type_info(&self) -> &'static TypeInfo {
        EYERECOILNETSTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static EYERECOILNETSTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EyeRecoilNetState-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("EyeRecoilNetState"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EyeSwayNetState {
    pub sway_angle_x: f32,
    pub sway_angle_y: f32,
}

pub trait EyeSwayNetStateTrait: TypeObject {
    fn sway_angle_x(&self) -> &f32;
    fn sway_angle_x_mut(&mut self) -> &mut f32;
    fn sway_angle_y(&self) -> &f32;
    fn sway_angle_y_mut(&mut self) -> &mut f32;
}

impl EyeSwayNetStateTrait for EyeSwayNetState {
    fn sway_angle_x(&self) -> &f32 {
        &self.sway_angle_x
    }
    fn sway_angle_x_mut(&mut self) -> &mut f32 {
        &mut self.sway_angle_x
    }
    fn sway_angle_y(&self) -> &f32 {
        &self.sway_angle_y
    }
    fn sway_angle_y_mut(&mut self) -> &mut f32 {
        &mut self.sway_angle_y
    }
}

pub static EYESWAYNETSTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EyeSwayNetState",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EyeSwayNetState as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SwayAngleX",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EyeSwayNetState, sway_angle_x),
            },
            FieldInfoData {
                name: "SwayAngleY",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EyeSwayNetState, sway_angle_y),
            },
        ],
    }),
    array_type: Some(EYESWAYNETSTATE_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for EyeSwayNetState {
    fn type_info(&self) -> &'static TypeInfo {
        EYESWAYNETSTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static EYESWAYNETSTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EyeSwayNetState-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("EyeSwayNetState"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EyeAngleNetState {
    pub yaw: f32,
    pub pitch: f32,
}

pub trait EyeAngleNetStateTrait: TypeObject {
    fn yaw(&self) -> &f32;
    fn yaw_mut(&mut self) -> &mut f32;
    fn pitch(&self) -> &f32;
    fn pitch_mut(&mut self) -> &mut f32;
}

impl EyeAngleNetStateTrait for EyeAngleNetState {
    fn yaw(&self) -> &f32 {
        &self.yaw
    }
    fn yaw_mut(&mut self) -> &mut f32 {
        &mut self.yaw
    }
    fn pitch(&self) -> &f32 {
        &self.pitch
    }
    fn pitch_mut(&mut self) -> &mut f32 {
        &mut self.pitch
    }
}

pub static EYEANGLENETSTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EyeAngleNetState",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EyeAngleNetState as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Yaw",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EyeAngleNetState, yaw),
            },
            FieldInfoData {
                name: "Pitch",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EyeAngleNetState, pitch),
            },
        ],
    }),
    array_type: Some(EYEANGLENETSTATE_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for EyeAngleNetState {
    fn type_info(&self) -> &'static TypeInfo {
        EYEANGLENETSTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static EYEANGLENETSTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EyeAngleNetState-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("EyeAngleNetState"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PickupPhysicsComponentData {
    pub _glacier_base: super::gameplay_sim::GamePhysicsComponentData,
}

pub trait PickupPhysicsComponentDataTrait: super::gameplay_sim::GamePhysicsComponentDataTrait {
}

impl PickupPhysicsComponentDataTrait for PickupPhysicsComponentData {
}

impl super::gameplay_sim::GamePhysicsComponentDataTrait for PickupPhysicsComponentData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn effect_parameters(&self) -> &Vec<Option<Arc<Mutex<dyn super::effect_base::EffectParameterTrait>>>> {
        self._glacier_base.effect_parameters()
    }
    fn effect_parameters_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::effect_base::EffectParameterTrait>>>> {
        self._glacier_base.effect_parameters_mut()
    }
}

impl super::physics::PhysicsComponentDataTrait for PickupPhysicsComponentData {
    fn physics_bodies(&self) -> &Vec<Option<Arc<Mutex<dyn super::physics::PhysicsBodyDataTrait>>>> {
        self._glacier_base.physics_bodies()
    }
    fn physics_bodies_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::physics::PhysicsBodyDataTrait>>>> {
        self._glacier_base.physics_bodies_mut()
    }
    fn physics_constraints(&self) -> &Vec<Option<Arc<Mutex<dyn super::physics::PhysicsConstraintDataTrait>>>> {
        self._glacier_base.physics_constraints()
    }
    fn physics_constraints_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::physics::PhysicsConstraintDataTrait>>>> {
        self._glacier_base.physics_constraints_mut()
    }
    fn parts(&self) -> &Vec<super::physics::PhysicsPartData> {
        self._glacier_base.parts()
    }
    fn parts_mut(&mut self) -> &mut Vec<super::physics::PhysicsPartData> {
        self._glacier_base.parts_mut()
    }
    fn movable_parts(&self) -> &bool {
        self._glacier_base.movable_parts()
    }
    fn movable_parts_mut(&mut self) -> &mut bool {
        self._glacier_base.movable_parts_mut()
    }
    fn internal_collision_disabling(&self) -> &super::physics::InternalCollisionDisablingBehavior {
        self._glacier_base.internal_collision_disabling()
    }
    fn internal_collision_disabling_mut(&mut self) -> &mut super::physics::InternalCollisionDisablingBehavior {
        self._glacier_base.internal_collision_disabling_mut()
    }
    fn enable_collision_events(&self) -> &bool {
        self._glacier_base.enable_collision_events()
    }
    fn enable_collision_events_mut(&mut self) -> &mut bool {
        self._glacier_base.enable_collision_events_mut()
    }
}

impl super::entity::ComponentDataTrait for PickupPhysicsComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for PickupPhysicsComponentData {
}

impl super::core::DataBusPeerTrait for PickupPhysicsComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PickupPhysicsComponentData {
}

impl super::core::DataContainerTrait for PickupPhysicsComponentData {
}

pub static PICKUPPHYSICSCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PickupPhysicsComponentData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::GAMEPHYSICSCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PickupPhysicsComponentData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(PICKUPPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PickupPhysicsComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        PICKUPPHYSICSCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PICKUPPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PickupPhysicsComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("PickupPhysicsComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct NetworkPickupWeaponFromKitMessage {
}

pub trait NetworkPickupWeaponFromKitMessageTrait: TypeObject {
}

impl NetworkPickupWeaponFromKitMessageTrait for NetworkPickupWeaponFromKitMessage {
}

pub static NETWORKPICKUPWEAPONFROMKITMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NetworkPickupWeaponFromKitMessage",
    flags: MemberInfoFlags::new(73),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<NetworkPickupWeaponFromKitMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for NetworkPickupWeaponFromKitMessage {
    fn type_info(&self) -> &'static TypeInfo {
        NETWORKPICKUPWEAPONFROMKITMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Clone, Debug, Default)]
pub struct DynamicWeaponPickupEntityData {
    pub _glacier_base: PickupEntityData,
    pub weapon_slots: Vec<DynamicWeaponPickupSlotData>,
}

pub trait DynamicWeaponPickupEntityDataTrait: PickupEntityDataTrait {
    fn weapon_slots(&self) -> &Vec<DynamicWeaponPickupSlotData>;
    fn weapon_slots_mut(&mut self) -> &mut Vec<DynamicWeaponPickupSlotData>;
}

impl DynamicWeaponPickupEntityDataTrait for DynamicWeaponPickupEntityData {
    fn weapon_slots(&self) -> &Vec<DynamicWeaponPickupSlotData> {
        &self.weapon_slots
    }
    fn weapon_slots_mut(&mut self) -> &mut Vec<DynamicWeaponPickupSlotData> {
        &mut self.weapon_slots
    }
}

impl PickupEntityDataTrait for DynamicWeaponPickupEntityData {
    fn physics_blueprint(&self) -> &Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>> {
        self._glacier_base.physics_blueprint()
    }
    fn physics_blueprint_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>> {
        self._glacier_base.physics_blueprint_mut()
    }
    fn mesh(&self) -> &Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        self._glacier_base.mesh()
    }
    fn mesh_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        self._glacier_base.mesh_mut()
    }
    fn use_weapon_mesh(&self) -> &bool {
        self._glacier_base.use_weapon_mesh()
    }
    fn use_weapon_mesh_mut(&mut self) -> &mut bool {
        self._glacier_base.use_weapon_mesh_mut()
    }
    fn time_to_show_weapon_mesh(&self) -> &f32 {
        self._glacier_base.time_to_show_weapon_mesh()
    }
    fn time_to_show_weapon_mesh_mut(&mut self) -> &mut f32 {
        self._glacier_base.time_to_show_weapon_mesh_mut()
    }
    fn preferred_weapon_slot(&self) -> &u32 {
        self._glacier_base.preferred_weapon_slot()
    }
    fn preferred_weapon_slot_mut(&mut self) -> &mut u32 {
        self._glacier_base.preferred_weapon_slot_mut()
    }
    fn time_to_live(&self) -> &f32 {
        self._glacier_base.time_to_live()
    }
    fn time_to_live_mut(&mut self) -> &mut f32 {
        self._glacier_base.time_to_live_mut()
    }
    fn unspawn_on_pickup(&self) -> &bool {
        self._glacier_base.unspawn_on_pickup()
    }
    fn unspawn_on_pickup_mut(&mut self) -> &mut bool {
        self._glacier_base.unspawn_on_pickup_mut()
    }
    fn unspawn_on_ammo_pickup(&self) -> &bool {
        self._glacier_base.unspawn_on_ammo_pickup()
    }
    fn unspawn_on_ammo_pickup_mut(&mut self) -> &mut bool {
        self._glacier_base.unspawn_on_ammo_pickup_mut()
    }
    fn content_is_static(&self) -> &bool {
        self._glacier_base.content_is_static()
    }
    fn content_is_static_mut(&mut self) -> &mut bool {
        self._glacier_base.content_is_static_mut()
    }
    fn position_is_static(&self) -> &bool {
        self._glacier_base.position_is_static()
    }
    fn position_is_static_mut(&mut self) -> &mut bool {
        self._glacier_base.position_is_static_mut()
    }
    fn allow_pickup(&self) -> &bool {
        self._glacier_base.allow_pickup()
    }
    fn allow_pickup_mut(&mut self) -> &mut bool {
        self._glacier_base.allow_pickup_mut()
    }
    fn ignore_null_weapon_slots(&self) -> &bool {
        self._glacier_base.ignore_null_weapon_slots()
    }
    fn ignore_null_weapon_slots_mut(&mut self) -> &mut bool {
        self._glacier_base.ignore_null_weapon_slots_mut()
    }
    fn force_weapon_slot_selection(&self) -> &bool {
        self._glacier_base.force_weapon_slot_selection()
    }
    fn force_weapon_slot_selection_mut(&mut self) -> &mut bool {
        self._glacier_base.force_weapon_slot_selection_mut()
    }
    fn display_in_mini_map(&self) -> &bool {
        self._glacier_base.display_in_mini_map()
    }
    fn display_in_mini_map_mut(&mut self) -> &mut bool {
        self._glacier_base.display_in_mini_map_mut()
    }
    fn icon_name(&self) -> &String {
        self._glacier_base.icon_name()
    }
    fn icon_name_mut(&mut self) -> &mut String {
        self._glacier_base.icon_name_mut()
    }
    fn has_automatic_ammo_pickup(&self) -> &bool {
        self._glacier_base.has_automatic_ammo_pickup()
    }
    fn has_automatic_ammo_pickup_mut(&mut self) -> &mut bool {
        self._glacier_base.has_automatic_ammo_pickup_mut()
    }
    fn min_random_spare_ammo_percent(&self) -> &i32 {
        self._glacier_base.min_random_spare_ammo_percent()
    }
    fn min_random_spare_ammo_percent_mut(&mut self) -> &mut i32 {
        self._glacier_base.min_random_spare_ammo_percent_mut()
    }
    fn max_random_spare_ammo_percent(&self) -> &i32 {
        self._glacier_base.max_random_spare_ammo_percent()
    }
    fn max_random_spare_ammo_percent_mut(&mut self) -> &mut i32 {
        self._glacier_base.max_random_spare_ammo_percent_mut()
    }
    fn min_random_clip_ammo_percent(&self) -> &i32 {
        self._glacier_base.min_random_clip_ammo_percent()
    }
    fn min_random_clip_ammo_percent_mut(&mut self) -> &mut i32 {
        self._glacier_base.min_random_clip_ammo_percent_mut()
    }
    fn max_random_clip_ammo_percent(&self) -> &i32 {
        self._glacier_base.max_random_clip_ammo_percent()
    }
    fn max_random_clip_ammo_percent_mut(&mut self) -> &mut i32 {
        self._glacier_base.max_random_clip_ammo_percent_mut()
    }
    fn randomize_ammo_on_drop_for_player(&self) -> &PickupPlayerEnum {
        self._glacier_base.randomize_ammo_on_drop_for_player()
    }
    fn randomize_ammo_on_drop_for_player_mut(&mut self) -> &mut PickupPlayerEnum {
        self._glacier_base.randomize_ammo_on_drop_for_player_mut()
    }
    fn interaction_radius(&self) -> &f32 {
        self._glacier_base.interaction_radius()
    }
    fn interaction_radius_mut(&mut self) -> &mut f32 {
        self._glacier_base.interaction_radius_mut()
    }
    fn replace_all_content(&self) -> &bool {
        self._glacier_base.replace_all_content()
    }
    fn replace_all_content_mut(&mut self) -> &mut bool {
        self._glacier_base.replace_all_content_mut()
    }
    fn remove_weapon_on_drop(&self) -> &bool {
        self._glacier_base.remove_weapon_on_drop()
    }
    fn remove_weapon_on_drop_mut(&mut self) -> &mut bool {
        self._glacier_base.remove_weapon_on_drop_mut()
    }
    fn display_within_radius(&self) -> &f32 {
        self._glacier_base.display_within_radius()
    }
    fn display_within_radius_mut(&mut self) -> &mut f32 {
        self._glacier_base.display_within_radius_mut()
    }
    fn use_display_within_radius(&self) -> &bool {
        self._glacier_base.use_display_within_radius()
    }
    fn use_display_within_radius_mut(&mut self) -> &mut bool {
        self._glacier_base.use_display_within_radius_mut()
    }
    fn tactical_radius(&self) -> &f32 {
        self._glacier_base.tactical_radius()
    }
    fn tactical_radius_mut(&mut self) -> &mut f32 {
        self._glacier_base.tactical_radius_mut()
    }
    fn keep_ammo_state(&self) -> &bool {
        self._glacier_base.keep_ammo_state()
    }
    fn keep_ammo_state_mut(&mut self) -> &mut bool {
        self._glacier_base.keep_ammo_state_mut()
    }
}

impl super::physics::GamePhysicsEntityDataTrait for DynamicWeaponPickupEntityData {
}

impl super::entity::GameComponentEntityDataTrait for DynamicWeaponPickupEntityData {
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::ComponentEntityDataTrait for DynamicWeaponPickupEntityData {
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn part_bounding_boxes(&self) -> &Vec<super::core::AxisAlignedBox> {
        self._glacier_base.part_bounding_boxes()
    }
    fn part_bounding_boxes_mut(&mut self) -> &mut Vec<super::core::AxisAlignedBox> {
        self._glacier_base.part_bounding_boxes_mut()
    }
    fn client_runtime_component_count(&self) -> &u8 {
        self._glacier_base.client_runtime_component_count()
    }
    fn client_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_component_count_mut()
    }
    fn server_runtime_component_count(&self) -> &u8 {
        self._glacier_base.server_runtime_component_count()
    }
    fn server_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_component_count_mut()
    }
    fn client_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.client_runtime_transformation_count()
    }
    fn client_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_transformation_count_mut()
    }
    fn server_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.server_runtime_transformation_count()
    }
    fn server_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_transformation_count_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for DynamicWeaponPickupEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for DynamicWeaponPickupEntityData {
}

impl super::entity::GameObjectDataTrait for DynamicWeaponPickupEntityData {
}

impl super::core::DataBusPeerTrait for DynamicWeaponPickupEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for DynamicWeaponPickupEntityData {
}

impl super::core::DataContainerTrait for DynamicWeaponPickupEntityData {
}

pub static DYNAMICWEAPONPICKUPENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicWeaponPickupEntityData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PICKUPENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DynamicWeaponPickupEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "WeaponSlots",
                flags: MemberInfoFlags::new(144),
                field_type: "DynamicWeaponPickupSlotData-Array",
                rust_offset: offset_of!(DynamicWeaponPickupEntityData, weapon_slots),
            },
        ],
    }),
    array_type: Some(DYNAMICWEAPONPICKUPENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for DynamicWeaponPickupEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        DYNAMICWEAPONPICKUPENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DYNAMICWEAPONPICKUPENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicWeaponPickupEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("DynamicWeaponPickupEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DynamicWeaponPickupSlotData {
    pub weapon_slot: u32,
    pub alt_weapon_slot: i32,
    pub linked_to_weapon_slot: i32,
}

pub trait DynamicWeaponPickupSlotDataTrait: TypeObject {
    fn weapon_slot(&self) -> &u32;
    fn weapon_slot_mut(&mut self) -> &mut u32;
    fn alt_weapon_slot(&self) -> &i32;
    fn alt_weapon_slot_mut(&mut self) -> &mut i32;
    fn linked_to_weapon_slot(&self) -> &i32;
    fn linked_to_weapon_slot_mut(&mut self) -> &mut i32;
}

impl DynamicWeaponPickupSlotDataTrait for DynamicWeaponPickupSlotData {
    fn weapon_slot(&self) -> &u32 {
        &self.weapon_slot
    }
    fn weapon_slot_mut(&mut self) -> &mut u32 {
        &mut self.weapon_slot
    }
    fn alt_weapon_slot(&self) -> &i32 {
        &self.alt_weapon_slot
    }
    fn alt_weapon_slot_mut(&mut self) -> &mut i32 {
        &mut self.alt_weapon_slot
    }
    fn linked_to_weapon_slot(&self) -> &i32 {
        &self.linked_to_weapon_slot
    }
    fn linked_to_weapon_slot_mut(&mut self) -> &mut i32 {
        &mut self.linked_to_weapon_slot
    }
}

pub static DYNAMICWEAPONPICKUPSLOTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicWeaponPickupSlotData",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DynamicWeaponPickupSlotData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "WeaponSlot",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(DynamicWeaponPickupSlotData, weapon_slot),
            },
            FieldInfoData {
                name: "AltWeaponSlot",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(DynamicWeaponPickupSlotData, alt_weapon_slot),
            },
            FieldInfoData {
                name: "LinkedToWeaponSlot",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(DynamicWeaponPickupSlotData, linked_to_weapon_slot),
            },
        ],
    }),
    array_type: Some(DYNAMICWEAPONPICKUPSLOTDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for DynamicWeaponPickupSlotData {
    fn type_info(&self) -> &'static TypeInfo {
        DYNAMICWEAPONPICKUPSLOTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static DYNAMICWEAPONPICKUPSLOTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicWeaponPickupSlotData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("DynamicWeaponPickupSlotData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PickupEntityAsset {
    pub _glacier_base: super::core::DataContainerPolicyAsset,
    pub data: Option<Arc<Mutex<dyn PickupEntityDataTrait>>>,
}

pub trait PickupEntityAssetTrait: super::core::DataContainerPolicyAssetTrait {
    fn data(&self) -> &Option<Arc<Mutex<dyn PickupEntityDataTrait>>>;
    fn data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn PickupEntityDataTrait>>>;
}

impl PickupEntityAssetTrait for PickupEntityAsset {
    fn data(&self) -> &Option<Arc<Mutex<dyn PickupEntityDataTrait>>> {
        &self.data
    }
    fn data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn PickupEntityDataTrait>>> {
        &mut self.data
    }
}

impl super::core::DataContainerPolicyAssetTrait for PickupEntityAsset {
}

impl super::core::AssetTrait for PickupEntityAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for PickupEntityAsset {
}

pub static PICKUPENTITYASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PickupEntityAsset",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINERPOLICYASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PickupEntityAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Data",
                flags: MemberInfoFlags::new(0),
                field_type: "PickupEntityData",
                rust_offset: offset_of!(PickupEntityAsset, data),
            },
        ],
    }),
    array_type: Some(PICKUPENTITYASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PickupEntityAsset {
    fn type_info(&self) -> &'static TypeInfo {
        PICKUPENTITYASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PICKUPENTITYASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PickupEntityAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("PickupEntityAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct KitPickupEntityData {
    pub _glacier_base: PickupEntityData,
    pub keep_additional_weapons: bool,
}

pub trait KitPickupEntityDataTrait: PickupEntityDataTrait {
    fn keep_additional_weapons(&self) -> &bool;
    fn keep_additional_weapons_mut(&mut self) -> &mut bool;
}

impl KitPickupEntityDataTrait for KitPickupEntityData {
    fn keep_additional_weapons(&self) -> &bool {
        &self.keep_additional_weapons
    }
    fn keep_additional_weapons_mut(&mut self) -> &mut bool {
        &mut self.keep_additional_weapons
    }
}

impl PickupEntityDataTrait for KitPickupEntityData {
    fn physics_blueprint(&self) -> &Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>> {
        self._glacier_base.physics_blueprint()
    }
    fn physics_blueprint_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>> {
        self._glacier_base.physics_blueprint_mut()
    }
    fn mesh(&self) -> &Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        self._glacier_base.mesh()
    }
    fn mesh_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        self._glacier_base.mesh_mut()
    }
    fn use_weapon_mesh(&self) -> &bool {
        self._glacier_base.use_weapon_mesh()
    }
    fn use_weapon_mesh_mut(&mut self) -> &mut bool {
        self._glacier_base.use_weapon_mesh_mut()
    }
    fn time_to_show_weapon_mesh(&self) -> &f32 {
        self._glacier_base.time_to_show_weapon_mesh()
    }
    fn time_to_show_weapon_mesh_mut(&mut self) -> &mut f32 {
        self._glacier_base.time_to_show_weapon_mesh_mut()
    }
    fn preferred_weapon_slot(&self) -> &u32 {
        self._glacier_base.preferred_weapon_slot()
    }
    fn preferred_weapon_slot_mut(&mut self) -> &mut u32 {
        self._glacier_base.preferred_weapon_slot_mut()
    }
    fn time_to_live(&self) -> &f32 {
        self._glacier_base.time_to_live()
    }
    fn time_to_live_mut(&mut self) -> &mut f32 {
        self._glacier_base.time_to_live_mut()
    }
    fn unspawn_on_pickup(&self) -> &bool {
        self._glacier_base.unspawn_on_pickup()
    }
    fn unspawn_on_pickup_mut(&mut self) -> &mut bool {
        self._glacier_base.unspawn_on_pickup_mut()
    }
    fn unspawn_on_ammo_pickup(&self) -> &bool {
        self._glacier_base.unspawn_on_ammo_pickup()
    }
    fn unspawn_on_ammo_pickup_mut(&mut self) -> &mut bool {
        self._glacier_base.unspawn_on_ammo_pickup_mut()
    }
    fn content_is_static(&self) -> &bool {
        self._glacier_base.content_is_static()
    }
    fn content_is_static_mut(&mut self) -> &mut bool {
        self._glacier_base.content_is_static_mut()
    }
    fn position_is_static(&self) -> &bool {
        self._glacier_base.position_is_static()
    }
    fn position_is_static_mut(&mut self) -> &mut bool {
        self._glacier_base.position_is_static_mut()
    }
    fn allow_pickup(&self) -> &bool {
        self._glacier_base.allow_pickup()
    }
    fn allow_pickup_mut(&mut self) -> &mut bool {
        self._glacier_base.allow_pickup_mut()
    }
    fn ignore_null_weapon_slots(&self) -> &bool {
        self._glacier_base.ignore_null_weapon_slots()
    }
    fn ignore_null_weapon_slots_mut(&mut self) -> &mut bool {
        self._glacier_base.ignore_null_weapon_slots_mut()
    }
    fn force_weapon_slot_selection(&self) -> &bool {
        self._glacier_base.force_weapon_slot_selection()
    }
    fn force_weapon_slot_selection_mut(&mut self) -> &mut bool {
        self._glacier_base.force_weapon_slot_selection_mut()
    }
    fn display_in_mini_map(&self) -> &bool {
        self._glacier_base.display_in_mini_map()
    }
    fn display_in_mini_map_mut(&mut self) -> &mut bool {
        self._glacier_base.display_in_mini_map_mut()
    }
    fn icon_name(&self) -> &String {
        self._glacier_base.icon_name()
    }
    fn icon_name_mut(&mut self) -> &mut String {
        self._glacier_base.icon_name_mut()
    }
    fn has_automatic_ammo_pickup(&self) -> &bool {
        self._glacier_base.has_automatic_ammo_pickup()
    }
    fn has_automatic_ammo_pickup_mut(&mut self) -> &mut bool {
        self._glacier_base.has_automatic_ammo_pickup_mut()
    }
    fn min_random_spare_ammo_percent(&self) -> &i32 {
        self._glacier_base.min_random_spare_ammo_percent()
    }
    fn min_random_spare_ammo_percent_mut(&mut self) -> &mut i32 {
        self._glacier_base.min_random_spare_ammo_percent_mut()
    }
    fn max_random_spare_ammo_percent(&self) -> &i32 {
        self._glacier_base.max_random_spare_ammo_percent()
    }
    fn max_random_spare_ammo_percent_mut(&mut self) -> &mut i32 {
        self._glacier_base.max_random_spare_ammo_percent_mut()
    }
    fn min_random_clip_ammo_percent(&self) -> &i32 {
        self._glacier_base.min_random_clip_ammo_percent()
    }
    fn min_random_clip_ammo_percent_mut(&mut self) -> &mut i32 {
        self._glacier_base.min_random_clip_ammo_percent_mut()
    }
    fn max_random_clip_ammo_percent(&self) -> &i32 {
        self._glacier_base.max_random_clip_ammo_percent()
    }
    fn max_random_clip_ammo_percent_mut(&mut self) -> &mut i32 {
        self._glacier_base.max_random_clip_ammo_percent_mut()
    }
    fn randomize_ammo_on_drop_for_player(&self) -> &PickupPlayerEnum {
        self._glacier_base.randomize_ammo_on_drop_for_player()
    }
    fn randomize_ammo_on_drop_for_player_mut(&mut self) -> &mut PickupPlayerEnum {
        self._glacier_base.randomize_ammo_on_drop_for_player_mut()
    }
    fn interaction_radius(&self) -> &f32 {
        self._glacier_base.interaction_radius()
    }
    fn interaction_radius_mut(&mut self) -> &mut f32 {
        self._glacier_base.interaction_radius_mut()
    }
    fn replace_all_content(&self) -> &bool {
        self._glacier_base.replace_all_content()
    }
    fn replace_all_content_mut(&mut self) -> &mut bool {
        self._glacier_base.replace_all_content_mut()
    }
    fn remove_weapon_on_drop(&self) -> &bool {
        self._glacier_base.remove_weapon_on_drop()
    }
    fn remove_weapon_on_drop_mut(&mut self) -> &mut bool {
        self._glacier_base.remove_weapon_on_drop_mut()
    }
    fn display_within_radius(&self) -> &f32 {
        self._glacier_base.display_within_radius()
    }
    fn display_within_radius_mut(&mut self) -> &mut f32 {
        self._glacier_base.display_within_radius_mut()
    }
    fn use_display_within_radius(&self) -> &bool {
        self._glacier_base.use_display_within_radius()
    }
    fn use_display_within_radius_mut(&mut self) -> &mut bool {
        self._glacier_base.use_display_within_radius_mut()
    }
    fn tactical_radius(&self) -> &f32 {
        self._glacier_base.tactical_radius()
    }
    fn tactical_radius_mut(&mut self) -> &mut f32 {
        self._glacier_base.tactical_radius_mut()
    }
    fn keep_ammo_state(&self) -> &bool {
        self._glacier_base.keep_ammo_state()
    }
    fn keep_ammo_state_mut(&mut self) -> &mut bool {
        self._glacier_base.keep_ammo_state_mut()
    }
}

impl super::physics::GamePhysicsEntityDataTrait for KitPickupEntityData {
}

impl super::entity::GameComponentEntityDataTrait for KitPickupEntityData {
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::ComponentEntityDataTrait for KitPickupEntityData {
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn part_bounding_boxes(&self) -> &Vec<super::core::AxisAlignedBox> {
        self._glacier_base.part_bounding_boxes()
    }
    fn part_bounding_boxes_mut(&mut self) -> &mut Vec<super::core::AxisAlignedBox> {
        self._glacier_base.part_bounding_boxes_mut()
    }
    fn client_runtime_component_count(&self) -> &u8 {
        self._glacier_base.client_runtime_component_count()
    }
    fn client_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_component_count_mut()
    }
    fn server_runtime_component_count(&self) -> &u8 {
        self._glacier_base.server_runtime_component_count()
    }
    fn server_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_component_count_mut()
    }
    fn client_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.client_runtime_transformation_count()
    }
    fn client_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_transformation_count_mut()
    }
    fn server_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.server_runtime_transformation_count()
    }
    fn server_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_transformation_count_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for KitPickupEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for KitPickupEntityData {
}

impl super::entity::GameObjectDataTrait for KitPickupEntityData {
}

impl super::core::DataBusPeerTrait for KitPickupEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for KitPickupEntityData {
}

impl super::core::DataContainerTrait for KitPickupEntityData {
}

pub static KITPICKUPENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "KitPickupEntityData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PICKUPENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<KitPickupEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "KeepAdditionalWeapons",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(KitPickupEntityData, keep_additional_weapons),
            },
        ],
    }),
    array_type: Some(KITPICKUPENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for KitPickupEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        KITPICKUPENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static KITPICKUPENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "KitPickupEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("KitPickupEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WeaponUnlockPickupEntityData {
    pub _glacier_base: PickupEntityData,
    pub weapons: Vec<WeaponUnlockPickupData>,
    pub use_for_persistence: bool,
}

pub trait WeaponUnlockPickupEntityDataTrait: PickupEntityDataTrait {
    fn weapons(&self) -> &Vec<WeaponUnlockPickupData>;
    fn weapons_mut(&mut self) -> &mut Vec<WeaponUnlockPickupData>;
    fn use_for_persistence(&self) -> &bool;
    fn use_for_persistence_mut(&mut self) -> &mut bool;
}

impl WeaponUnlockPickupEntityDataTrait for WeaponUnlockPickupEntityData {
    fn weapons(&self) -> &Vec<WeaponUnlockPickupData> {
        &self.weapons
    }
    fn weapons_mut(&mut self) -> &mut Vec<WeaponUnlockPickupData> {
        &mut self.weapons
    }
    fn use_for_persistence(&self) -> &bool {
        &self.use_for_persistence
    }
    fn use_for_persistence_mut(&mut self) -> &mut bool {
        &mut self.use_for_persistence
    }
}

impl PickupEntityDataTrait for WeaponUnlockPickupEntityData {
    fn physics_blueprint(&self) -> &Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>> {
        self._glacier_base.physics_blueprint()
    }
    fn physics_blueprint_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>> {
        self._glacier_base.physics_blueprint_mut()
    }
    fn mesh(&self) -> &Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        self._glacier_base.mesh()
    }
    fn mesh_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        self._glacier_base.mesh_mut()
    }
    fn use_weapon_mesh(&self) -> &bool {
        self._glacier_base.use_weapon_mesh()
    }
    fn use_weapon_mesh_mut(&mut self) -> &mut bool {
        self._glacier_base.use_weapon_mesh_mut()
    }
    fn time_to_show_weapon_mesh(&self) -> &f32 {
        self._glacier_base.time_to_show_weapon_mesh()
    }
    fn time_to_show_weapon_mesh_mut(&mut self) -> &mut f32 {
        self._glacier_base.time_to_show_weapon_mesh_mut()
    }
    fn preferred_weapon_slot(&self) -> &u32 {
        self._glacier_base.preferred_weapon_slot()
    }
    fn preferred_weapon_slot_mut(&mut self) -> &mut u32 {
        self._glacier_base.preferred_weapon_slot_mut()
    }
    fn time_to_live(&self) -> &f32 {
        self._glacier_base.time_to_live()
    }
    fn time_to_live_mut(&mut self) -> &mut f32 {
        self._glacier_base.time_to_live_mut()
    }
    fn unspawn_on_pickup(&self) -> &bool {
        self._glacier_base.unspawn_on_pickup()
    }
    fn unspawn_on_pickup_mut(&mut self) -> &mut bool {
        self._glacier_base.unspawn_on_pickup_mut()
    }
    fn unspawn_on_ammo_pickup(&self) -> &bool {
        self._glacier_base.unspawn_on_ammo_pickup()
    }
    fn unspawn_on_ammo_pickup_mut(&mut self) -> &mut bool {
        self._glacier_base.unspawn_on_ammo_pickup_mut()
    }
    fn content_is_static(&self) -> &bool {
        self._glacier_base.content_is_static()
    }
    fn content_is_static_mut(&mut self) -> &mut bool {
        self._glacier_base.content_is_static_mut()
    }
    fn position_is_static(&self) -> &bool {
        self._glacier_base.position_is_static()
    }
    fn position_is_static_mut(&mut self) -> &mut bool {
        self._glacier_base.position_is_static_mut()
    }
    fn allow_pickup(&self) -> &bool {
        self._glacier_base.allow_pickup()
    }
    fn allow_pickup_mut(&mut self) -> &mut bool {
        self._glacier_base.allow_pickup_mut()
    }
    fn ignore_null_weapon_slots(&self) -> &bool {
        self._glacier_base.ignore_null_weapon_slots()
    }
    fn ignore_null_weapon_slots_mut(&mut self) -> &mut bool {
        self._glacier_base.ignore_null_weapon_slots_mut()
    }
    fn force_weapon_slot_selection(&self) -> &bool {
        self._glacier_base.force_weapon_slot_selection()
    }
    fn force_weapon_slot_selection_mut(&mut self) -> &mut bool {
        self._glacier_base.force_weapon_slot_selection_mut()
    }
    fn display_in_mini_map(&self) -> &bool {
        self._glacier_base.display_in_mini_map()
    }
    fn display_in_mini_map_mut(&mut self) -> &mut bool {
        self._glacier_base.display_in_mini_map_mut()
    }
    fn icon_name(&self) -> &String {
        self._glacier_base.icon_name()
    }
    fn icon_name_mut(&mut self) -> &mut String {
        self._glacier_base.icon_name_mut()
    }
    fn has_automatic_ammo_pickup(&self) -> &bool {
        self._glacier_base.has_automatic_ammo_pickup()
    }
    fn has_automatic_ammo_pickup_mut(&mut self) -> &mut bool {
        self._glacier_base.has_automatic_ammo_pickup_mut()
    }
    fn min_random_spare_ammo_percent(&self) -> &i32 {
        self._glacier_base.min_random_spare_ammo_percent()
    }
    fn min_random_spare_ammo_percent_mut(&mut self) -> &mut i32 {
        self._glacier_base.min_random_spare_ammo_percent_mut()
    }
    fn max_random_spare_ammo_percent(&self) -> &i32 {
        self._glacier_base.max_random_spare_ammo_percent()
    }
    fn max_random_spare_ammo_percent_mut(&mut self) -> &mut i32 {
        self._glacier_base.max_random_spare_ammo_percent_mut()
    }
    fn min_random_clip_ammo_percent(&self) -> &i32 {
        self._glacier_base.min_random_clip_ammo_percent()
    }
    fn min_random_clip_ammo_percent_mut(&mut self) -> &mut i32 {
        self._glacier_base.min_random_clip_ammo_percent_mut()
    }
    fn max_random_clip_ammo_percent(&self) -> &i32 {
        self._glacier_base.max_random_clip_ammo_percent()
    }
    fn max_random_clip_ammo_percent_mut(&mut self) -> &mut i32 {
        self._glacier_base.max_random_clip_ammo_percent_mut()
    }
    fn randomize_ammo_on_drop_for_player(&self) -> &PickupPlayerEnum {
        self._glacier_base.randomize_ammo_on_drop_for_player()
    }
    fn randomize_ammo_on_drop_for_player_mut(&mut self) -> &mut PickupPlayerEnum {
        self._glacier_base.randomize_ammo_on_drop_for_player_mut()
    }
    fn interaction_radius(&self) -> &f32 {
        self._glacier_base.interaction_radius()
    }
    fn interaction_radius_mut(&mut self) -> &mut f32 {
        self._glacier_base.interaction_radius_mut()
    }
    fn replace_all_content(&self) -> &bool {
        self._glacier_base.replace_all_content()
    }
    fn replace_all_content_mut(&mut self) -> &mut bool {
        self._glacier_base.replace_all_content_mut()
    }
    fn remove_weapon_on_drop(&self) -> &bool {
        self._glacier_base.remove_weapon_on_drop()
    }
    fn remove_weapon_on_drop_mut(&mut self) -> &mut bool {
        self._glacier_base.remove_weapon_on_drop_mut()
    }
    fn display_within_radius(&self) -> &f32 {
        self._glacier_base.display_within_radius()
    }
    fn display_within_radius_mut(&mut self) -> &mut f32 {
        self._glacier_base.display_within_radius_mut()
    }
    fn use_display_within_radius(&self) -> &bool {
        self._glacier_base.use_display_within_radius()
    }
    fn use_display_within_radius_mut(&mut self) -> &mut bool {
        self._glacier_base.use_display_within_radius_mut()
    }
    fn tactical_radius(&self) -> &f32 {
        self._glacier_base.tactical_radius()
    }
    fn tactical_radius_mut(&mut self) -> &mut f32 {
        self._glacier_base.tactical_radius_mut()
    }
    fn keep_ammo_state(&self) -> &bool {
        self._glacier_base.keep_ammo_state()
    }
    fn keep_ammo_state_mut(&mut self) -> &mut bool {
        self._glacier_base.keep_ammo_state_mut()
    }
}

impl super::physics::GamePhysicsEntityDataTrait for WeaponUnlockPickupEntityData {
}

impl super::entity::GameComponentEntityDataTrait for WeaponUnlockPickupEntityData {
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::ComponentEntityDataTrait for WeaponUnlockPickupEntityData {
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn part_bounding_boxes(&self) -> &Vec<super::core::AxisAlignedBox> {
        self._glacier_base.part_bounding_boxes()
    }
    fn part_bounding_boxes_mut(&mut self) -> &mut Vec<super::core::AxisAlignedBox> {
        self._glacier_base.part_bounding_boxes_mut()
    }
    fn client_runtime_component_count(&self) -> &u8 {
        self._glacier_base.client_runtime_component_count()
    }
    fn client_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_component_count_mut()
    }
    fn server_runtime_component_count(&self) -> &u8 {
        self._glacier_base.server_runtime_component_count()
    }
    fn server_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_component_count_mut()
    }
    fn client_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.client_runtime_transformation_count()
    }
    fn client_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_transformation_count_mut()
    }
    fn server_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.server_runtime_transformation_count()
    }
    fn server_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_transformation_count_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for WeaponUnlockPickupEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for WeaponUnlockPickupEntityData {
}

impl super::entity::GameObjectDataTrait for WeaponUnlockPickupEntityData {
}

impl super::core::DataBusPeerTrait for WeaponUnlockPickupEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for WeaponUnlockPickupEntityData {
}

impl super::core::DataContainerTrait for WeaponUnlockPickupEntityData {
}

pub static WEAPONUNLOCKPICKUPENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponUnlockPickupEntityData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PICKUPENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WeaponUnlockPickupEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Weapons",
                flags: MemberInfoFlags::new(144),
                field_type: "WeaponUnlockPickupData-Array",
                rust_offset: offset_of!(WeaponUnlockPickupEntityData, weapons),
            },
            FieldInfoData {
                name: "UseForPersistence",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WeaponUnlockPickupEntityData, use_for_persistence),
            },
        ],
    }),
    array_type: Some(WEAPONUNLOCKPICKUPENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for WeaponUnlockPickupEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        WEAPONUNLOCKPICKUPENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WEAPONUNLOCKPICKUPENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponUnlockPickupEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("WeaponUnlockPickupEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WeaponUnlockPickupData {
    pub unlock_weapon_and_slot: UnlockWeaponAndSlot,
    pub alt_weapon_slot: i32,
    pub linked_to_weapon_slot: i32,
    pub min_ammo: u32,
    pub max_ammo: u32,
    pub unlimited_ammo_pickup: bool,
}

pub trait WeaponUnlockPickupDataTrait: TypeObject {
    fn unlock_weapon_and_slot(&self) -> &UnlockWeaponAndSlot;
    fn unlock_weapon_and_slot_mut(&mut self) -> &mut UnlockWeaponAndSlot;
    fn alt_weapon_slot(&self) -> &i32;
    fn alt_weapon_slot_mut(&mut self) -> &mut i32;
    fn linked_to_weapon_slot(&self) -> &i32;
    fn linked_to_weapon_slot_mut(&mut self) -> &mut i32;
    fn min_ammo(&self) -> &u32;
    fn min_ammo_mut(&mut self) -> &mut u32;
    fn max_ammo(&self) -> &u32;
    fn max_ammo_mut(&mut self) -> &mut u32;
    fn unlimited_ammo_pickup(&self) -> &bool;
    fn unlimited_ammo_pickup_mut(&mut self) -> &mut bool;
}

impl WeaponUnlockPickupDataTrait for WeaponUnlockPickupData {
    fn unlock_weapon_and_slot(&self) -> &UnlockWeaponAndSlot {
        &self.unlock_weapon_and_slot
    }
    fn unlock_weapon_and_slot_mut(&mut self) -> &mut UnlockWeaponAndSlot {
        &mut self.unlock_weapon_and_slot
    }
    fn alt_weapon_slot(&self) -> &i32 {
        &self.alt_weapon_slot
    }
    fn alt_weapon_slot_mut(&mut self) -> &mut i32 {
        &mut self.alt_weapon_slot
    }
    fn linked_to_weapon_slot(&self) -> &i32 {
        &self.linked_to_weapon_slot
    }
    fn linked_to_weapon_slot_mut(&mut self) -> &mut i32 {
        &mut self.linked_to_weapon_slot
    }
    fn min_ammo(&self) -> &u32 {
        &self.min_ammo
    }
    fn min_ammo_mut(&mut self) -> &mut u32 {
        &mut self.min_ammo
    }
    fn max_ammo(&self) -> &u32 {
        &self.max_ammo
    }
    fn max_ammo_mut(&mut self) -> &mut u32 {
        &mut self.max_ammo
    }
    fn unlimited_ammo_pickup(&self) -> &bool {
        &self.unlimited_ammo_pickup
    }
    fn unlimited_ammo_pickup_mut(&mut self) -> &mut bool {
        &mut self.unlimited_ammo_pickup
    }
}

pub static WEAPONUNLOCKPICKUPDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponUnlockPickupData",
    flags: MemberInfoFlags::new(73),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WeaponUnlockPickupData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "UnlockWeaponAndSlot",
                flags: MemberInfoFlags::new(0),
                field_type: "UnlockWeaponAndSlot",
                rust_offset: offset_of!(WeaponUnlockPickupData, unlock_weapon_and_slot),
            },
            FieldInfoData {
                name: "AltWeaponSlot",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(WeaponUnlockPickupData, alt_weapon_slot),
            },
            FieldInfoData {
                name: "LinkedToWeaponSlot",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(WeaponUnlockPickupData, linked_to_weapon_slot),
            },
            FieldInfoData {
                name: "MinAmmo",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(WeaponUnlockPickupData, min_ammo),
            },
            FieldInfoData {
                name: "MaxAmmo",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(WeaponUnlockPickupData, max_ammo),
            },
            FieldInfoData {
                name: "UnlimitedAmmoPickup",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WeaponUnlockPickupData, unlimited_ammo_pickup),
            },
        ],
    }),
    array_type: Some(WEAPONUNLOCKPICKUPDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WeaponUnlockPickupData {
    fn type_info(&self) -> &'static TypeInfo {
        WEAPONUNLOCKPICKUPDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static WEAPONUNLOCKPICKUPDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponUnlockPickupData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("WeaponUnlockPickupData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PickupEntityData {
    pub _glacier_base: super::physics::GamePhysicsEntityData,
    pub physics_blueprint: Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>>,
    pub mesh: Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>>,
    pub use_weapon_mesh: bool,
    pub time_to_show_weapon_mesh: f32,
    pub preferred_weapon_slot: u32,
    pub time_to_live: f32,
    pub unspawn_on_pickup: bool,
    pub unspawn_on_ammo_pickup: bool,
    pub content_is_static: bool,
    pub position_is_static: bool,
    pub allow_pickup: bool,
    pub ignore_null_weapon_slots: bool,
    pub force_weapon_slot_selection: bool,
    pub display_in_mini_map: bool,
    pub icon_name: String,
    pub has_automatic_ammo_pickup: bool,
    pub min_random_spare_ammo_percent: i32,
    pub max_random_spare_ammo_percent: i32,
    pub min_random_clip_ammo_percent: i32,
    pub max_random_clip_ammo_percent: i32,
    pub randomize_ammo_on_drop_for_player: PickupPlayerEnum,
    pub interaction_radius: f32,
    pub replace_all_content: bool,
    pub remove_weapon_on_drop: bool,
    pub display_within_radius: f32,
    pub use_display_within_radius: bool,
    pub tactical_radius: f32,
    pub keep_ammo_state: bool,
}

pub trait PickupEntityDataTrait: super::physics::GamePhysicsEntityDataTrait {
    fn physics_blueprint(&self) -> &Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>>;
    fn physics_blueprint_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>>;
    fn mesh(&self) -> &Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>>;
    fn mesh_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>>;
    fn use_weapon_mesh(&self) -> &bool;
    fn use_weapon_mesh_mut(&mut self) -> &mut bool;
    fn time_to_show_weapon_mesh(&self) -> &f32;
    fn time_to_show_weapon_mesh_mut(&mut self) -> &mut f32;
    fn preferred_weapon_slot(&self) -> &u32;
    fn preferred_weapon_slot_mut(&mut self) -> &mut u32;
    fn time_to_live(&self) -> &f32;
    fn time_to_live_mut(&mut self) -> &mut f32;
    fn unspawn_on_pickup(&self) -> &bool;
    fn unspawn_on_pickup_mut(&mut self) -> &mut bool;
    fn unspawn_on_ammo_pickup(&self) -> &bool;
    fn unspawn_on_ammo_pickup_mut(&mut self) -> &mut bool;
    fn content_is_static(&self) -> &bool;
    fn content_is_static_mut(&mut self) -> &mut bool;
    fn position_is_static(&self) -> &bool;
    fn position_is_static_mut(&mut self) -> &mut bool;
    fn allow_pickup(&self) -> &bool;
    fn allow_pickup_mut(&mut self) -> &mut bool;
    fn ignore_null_weapon_slots(&self) -> &bool;
    fn ignore_null_weapon_slots_mut(&mut self) -> &mut bool;
    fn force_weapon_slot_selection(&self) -> &bool;
    fn force_weapon_slot_selection_mut(&mut self) -> &mut bool;
    fn display_in_mini_map(&self) -> &bool;
    fn display_in_mini_map_mut(&mut self) -> &mut bool;
    fn icon_name(&self) -> &String;
    fn icon_name_mut(&mut self) -> &mut String;
    fn has_automatic_ammo_pickup(&self) -> &bool;
    fn has_automatic_ammo_pickup_mut(&mut self) -> &mut bool;
    fn min_random_spare_ammo_percent(&self) -> &i32;
    fn min_random_spare_ammo_percent_mut(&mut self) -> &mut i32;
    fn max_random_spare_ammo_percent(&self) -> &i32;
    fn max_random_spare_ammo_percent_mut(&mut self) -> &mut i32;
    fn min_random_clip_ammo_percent(&self) -> &i32;
    fn min_random_clip_ammo_percent_mut(&mut self) -> &mut i32;
    fn max_random_clip_ammo_percent(&self) -> &i32;
    fn max_random_clip_ammo_percent_mut(&mut self) -> &mut i32;
    fn randomize_ammo_on_drop_for_player(&self) -> &PickupPlayerEnum;
    fn randomize_ammo_on_drop_for_player_mut(&mut self) -> &mut PickupPlayerEnum;
    fn interaction_radius(&self) -> &f32;
    fn interaction_radius_mut(&mut self) -> &mut f32;
    fn replace_all_content(&self) -> &bool;
    fn replace_all_content_mut(&mut self) -> &mut bool;
    fn remove_weapon_on_drop(&self) -> &bool;
    fn remove_weapon_on_drop_mut(&mut self) -> &mut bool;
    fn display_within_radius(&self) -> &f32;
    fn display_within_radius_mut(&mut self) -> &mut f32;
    fn use_display_within_radius(&self) -> &bool;
    fn use_display_within_radius_mut(&mut self) -> &mut bool;
    fn tactical_radius(&self) -> &f32;
    fn tactical_radius_mut(&mut self) -> &mut f32;
    fn keep_ammo_state(&self) -> &bool;
    fn keep_ammo_state_mut(&mut self) -> &mut bool;
}

impl PickupEntityDataTrait for PickupEntityData {
    fn physics_blueprint(&self) -> &Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>> {
        &self.physics_blueprint
    }
    fn physics_blueprint_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>> {
        &mut self.physics_blueprint
    }
    fn mesh(&self) -> &Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        &self.mesh
    }
    fn mesh_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        &mut self.mesh
    }
    fn use_weapon_mesh(&self) -> &bool {
        &self.use_weapon_mesh
    }
    fn use_weapon_mesh_mut(&mut self) -> &mut bool {
        &mut self.use_weapon_mesh
    }
    fn time_to_show_weapon_mesh(&self) -> &f32 {
        &self.time_to_show_weapon_mesh
    }
    fn time_to_show_weapon_mesh_mut(&mut self) -> &mut f32 {
        &mut self.time_to_show_weapon_mesh
    }
    fn preferred_weapon_slot(&self) -> &u32 {
        &self.preferred_weapon_slot
    }
    fn preferred_weapon_slot_mut(&mut self) -> &mut u32 {
        &mut self.preferred_weapon_slot
    }
    fn time_to_live(&self) -> &f32 {
        &self.time_to_live
    }
    fn time_to_live_mut(&mut self) -> &mut f32 {
        &mut self.time_to_live
    }
    fn unspawn_on_pickup(&self) -> &bool {
        &self.unspawn_on_pickup
    }
    fn unspawn_on_pickup_mut(&mut self) -> &mut bool {
        &mut self.unspawn_on_pickup
    }
    fn unspawn_on_ammo_pickup(&self) -> &bool {
        &self.unspawn_on_ammo_pickup
    }
    fn unspawn_on_ammo_pickup_mut(&mut self) -> &mut bool {
        &mut self.unspawn_on_ammo_pickup
    }
    fn content_is_static(&self) -> &bool {
        &self.content_is_static
    }
    fn content_is_static_mut(&mut self) -> &mut bool {
        &mut self.content_is_static
    }
    fn position_is_static(&self) -> &bool {
        &self.position_is_static
    }
    fn position_is_static_mut(&mut self) -> &mut bool {
        &mut self.position_is_static
    }
    fn allow_pickup(&self) -> &bool {
        &self.allow_pickup
    }
    fn allow_pickup_mut(&mut self) -> &mut bool {
        &mut self.allow_pickup
    }
    fn ignore_null_weapon_slots(&self) -> &bool {
        &self.ignore_null_weapon_slots
    }
    fn ignore_null_weapon_slots_mut(&mut self) -> &mut bool {
        &mut self.ignore_null_weapon_slots
    }
    fn force_weapon_slot_selection(&self) -> &bool {
        &self.force_weapon_slot_selection
    }
    fn force_weapon_slot_selection_mut(&mut self) -> &mut bool {
        &mut self.force_weapon_slot_selection
    }
    fn display_in_mini_map(&self) -> &bool {
        &self.display_in_mini_map
    }
    fn display_in_mini_map_mut(&mut self) -> &mut bool {
        &mut self.display_in_mini_map
    }
    fn icon_name(&self) -> &String {
        &self.icon_name
    }
    fn icon_name_mut(&mut self) -> &mut String {
        &mut self.icon_name
    }
    fn has_automatic_ammo_pickup(&self) -> &bool {
        &self.has_automatic_ammo_pickup
    }
    fn has_automatic_ammo_pickup_mut(&mut self) -> &mut bool {
        &mut self.has_automatic_ammo_pickup
    }
    fn min_random_spare_ammo_percent(&self) -> &i32 {
        &self.min_random_spare_ammo_percent
    }
    fn min_random_spare_ammo_percent_mut(&mut self) -> &mut i32 {
        &mut self.min_random_spare_ammo_percent
    }
    fn max_random_spare_ammo_percent(&self) -> &i32 {
        &self.max_random_spare_ammo_percent
    }
    fn max_random_spare_ammo_percent_mut(&mut self) -> &mut i32 {
        &mut self.max_random_spare_ammo_percent
    }
    fn min_random_clip_ammo_percent(&self) -> &i32 {
        &self.min_random_clip_ammo_percent
    }
    fn min_random_clip_ammo_percent_mut(&mut self) -> &mut i32 {
        &mut self.min_random_clip_ammo_percent
    }
    fn max_random_clip_ammo_percent(&self) -> &i32 {
        &self.max_random_clip_ammo_percent
    }
    fn max_random_clip_ammo_percent_mut(&mut self) -> &mut i32 {
        &mut self.max_random_clip_ammo_percent
    }
    fn randomize_ammo_on_drop_for_player(&self) -> &PickupPlayerEnum {
        &self.randomize_ammo_on_drop_for_player
    }
    fn randomize_ammo_on_drop_for_player_mut(&mut self) -> &mut PickupPlayerEnum {
        &mut self.randomize_ammo_on_drop_for_player
    }
    fn interaction_radius(&self) -> &f32 {
        &self.interaction_radius
    }
    fn interaction_radius_mut(&mut self) -> &mut f32 {
        &mut self.interaction_radius
    }
    fn replace_all_content(&self) -> &bool {
        &self.replace_all_content
    }
    fn replace_all_content_mut(&mut self) -> &mut bool {
        &mut self.replace_all_content
    }
    fn remove_weapon_on_drop(&self) -> &bool {
        &self.remove_weapon_on_drop
    }
    fn remove_weapon_on_drop_mut(&mut self) -> &mut bool {
        &mut self.remove_weapon_on_drop
    }
    fn display_within_radius(&self) -> &f32 {
        &self.display_within_radius
    }
    fn display_within_radius_mut(&mut self) -> &mut f32 {
        &mut self.display_within_radius
    }
    fn use_display_within_radius(&self) -> &bool {
        &self.use_display_within_radius
    }
    fn use_display_within_radius_mut(&mut self) -> &mut bool {
        &mut self.use_display_within_radius
    }
    fn tactical_radius(&self) -> &f32 {
        &self.tactical_radius
    }
    fn tactical_radius_mut(&mut self) -> &mut f32 {
        &mut self.tactical_radius
    }
    fn keep_ammo_state(&self) -> &bool {
        &self.keep_ammo_state
    }
    fn keep_ammo_state_mut(&mut self) -> &mut bool {
        &mut self.keep_ammo_state
    }
}

impl super::physics::GamePhysicsEntityDataTrait for PickupEntityData {
}

impl super::entity::GameComponentEntityDataTrait for PickupEntityData {
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::ComponentEntityDataTrait for PickupEntityData {
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn part_bounding_boxes(&self) -> &Vec<super::core::AxisAlignedBox> {
        self._glacier_base.part_bounding_boxes()
    }
    fn part_bounding_boxes_mut(&mut self) -> &mut Vec<super::core::AxisAlignedBox> {
        self._glacier_base.part_bounding_boxes_mut()
    }
    fn client_runtime_component_count(&self) -> &u8 {
        self._glacier_base.client_runtime_component_count()
    }
    fn client_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_component_count_mut()
    }
    fn server_runtime_component_count(&self) -> &u8 {
        self._glacier_base.server_runtime_component_count()
    }
    fn server_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_component_count_mut()
    }
    fn client_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.client_runtime_transformation_count()
    }
    fn client_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_transformation_count_mut()
    }
    fn server_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.server_runtime_transformation_count()
    }
    fn server_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_transformation_count_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for PickupEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for PickupEntityData {
}

impl super::entity::GameObjectDataTrait for PickupEntityData {
}

impl super::core::DataBusPeerTrait for PickupEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PickupEntityData {
}

impl super::core::DataContainerTrait for PickupEntityData {
}

pub static PICKUPENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PickupEntityData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::physics::GAMEPHYSICSENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PickupEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PhysicsBlueprint",
                flags: MemberInfoFlags::new(0),
                field_type: "ObjectBlueprint",
                rust_offset: offset_of!(PickupEntityData, physics_blueprint),
            },
            FieldInfoData {
                name: "Mesh",
                flags: MemberInfoFlags::new(0),
                field_type: "MeshBaseAsset",
                rust_offset: offset_of!(PickupEntityData, mesh),
            },
            FieldInfoData {
                name: "UseWeaponMesh",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PickupEntityData, use_weapon_mesh),
            },
            FieldInfoData {
                name: "TimeToShowWeaponMesh",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PickupEntityData, time_to_show_weapon_mesh),
            },
            FieldInfoData {
                name: "PreferredWeaponSlot",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(PickupEntityData, preferred_weapon_slot),
            },
            FieldInfoData {
                name: "TimeToLive",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PickupEntityData, time_to_live),
            },
            FieldInfoData {
                name: "UnspawnOnPickup",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PickupEntityData, unspawn_on_pickup),
            },
            FieldInfoData {
                name: "UnspawnOnAmmoPickup",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PickupEntityData, unspawn_on_ammo_pickup),
            },
            FieldInfoData {
                name: "ContentIsStatic",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PickupEntityData, content_is_static),
            },
            FieldInfoData {
                name: "PositionIsStatic",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PickupEntityData, position_is_static),
            },
            FieldInfoData {
                name: "AllowPickup",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PickupEntityData, allow_pickup),
            },
            FieldInfoData {
                name: "IgnoreNullWeaponSlots",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PickupEntityData, ignore_null_weapon_slots),
            },
            FieldInfoData {
                name: "ForceWeaponSlotSelection",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PickupEntityData, force_weapon_slot_selection),
            },
            FieldInfoData {
                name: "DisplayInMiniMap",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PickupEntityData, display_in_mini_map),
            },
            FieldInfoData {
                name: "IconName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(PickupEntityData, icon_name),
            },
            FieldInfoData {
                name: "HasAutomaticAmmoPickup",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PickupEntityData, has_automatic_ammo_pickup),
            },
            FieldInfoData {
                name: "MinRandomSpareAmmoPercent",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(PickupEntityData, min_random_spare_ammo_percent),
            },
            FieldInfoData {
                name: "MaxRandomSpareAmmoPercent",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(PickupEntityData, max_random_spare_ammo_percent),
            },
            FieldInfoData {
                name: "MinRandomClipAmmoPercent",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(PickupEntityData, min_random_clip_ammo_percent),
            },
            FieldInfoData {
                name: "MaxRandomClipAmmoPercent",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(PickupEntityData, max_random_clip_ammo_percent),
            },
            FieldInfoData {
                name: "RandomizeAmmoOnDropForPlayer",
                flags: MemberInfoFlags::new(0),
                field_type: "PickupPlayerEnum",
                rust_offset: offset_of!(PickupEntityData, randomize_ammo_on_drop_for_player),
            },
            FieldInfoData {
                name: "InteractionRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PickupEntityData, interaction_radius),
            },
            FieldInfoData {
                name: "ReplaceAllContent",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PickupEntityData, replace_all_content),
            },
            FieldInfoData {
                name: "RemoveWeaponOnDrop",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PickupEntityData, remove_weapon_on_drop),
            },
            FieldInfoData {
                name: "DisplayWithinRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PickupEntityData, display_within_radius),
            },
            FieldInfoData {
                name: "UseDisplayWithinRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PickupEntityData, use_display_within_radius),
            },
            FieldInfoData {
                name: "TacticalRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PickupEntityData, tactical_radius),
            },
            FieldInfoData {
                name: "KeepAmmoState",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PickupEntityData, keep_ammo_state),
            },
        ],
    }),
    array_type: Some(PICKUPENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PickupEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PICKUPENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PICKUPENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PickupEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("PickupEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WeaponsNoPickupNetState {
    pub projectiles_in_magazines: i16,
    pub projectiles_loaded: i16,
}

pub trait WeaponsNoPickupNetStateTrait: TypeObject {
    fn projectiles_in_magazines(&self) -> &i16;
    fn projectiles_in_magazines_mut(&mut self) -> &mut i16;
    fn projectiles_loaded(&self) -> &i16;
    fn projectiles_loaded_mut(&mut self) -> &mut i16;
}

impl WeaponsNoPickupNetStateTrait for WeaponsNoPickupNetState {
    fn projectiles_in_magazines(&self) -> &i16 {
        &self.projectiles_in_magazines
    }
    fn projectiles_in_magazines_mut(&mut self) -> &mut i16 {
        &mut self.projectiles_in_magazines
    }
    fn projectiles_loaded(&self) -> &i16 {
        &self.projectiles_loaded
    }
    fn projectiles_loaded_mut(&mut self) -> &mut i16 {
        &mut self.projectiles_loaded
    }
}

pub static WEAPONSNOPICKUPNETSTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponsNoPickupNetState",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WeaponsNoPickupNetState as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ProjectilesInMagazines",
                flags: MemberInfoFlags::new(0),
                field_type: "Int16",
                rust_offset: offset_of!(WeaponsNoPickupNetState, projectiles_in_magazines),
            },
            FieldInfoData {
                name: "ProjectilesLoaded",
                flags: MemberInfoFlags::new(0),
                field_type: "Int16",
                rust_offset: offset_of!(WeaponsNoPickupNetState, projectiles_loaded),
            },
        ],
    }),
    array_type: Some(WEAPONSNOPICKUPNETSTATE_ARRAY_TYPE_INFO),
    alignment: 2,
};

impl TypeObject for WeaponsNoPickupNetState {
    fn type_info(&self) -> &'static TypeInfo {
        WEAPONSNOPICKUPNETSTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static WEAPONSNOPICKUPNETSTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponsNoPickupNetState-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("WeaponsNoPickupNetState"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WeaponsPickupNetState {
    pub soldier_weapon_unlock: Option<Arc<Mutex<dyn SoldierWeaponUnlockAssetTrait>>>,
    pub weapon_slot_unlocks_size: u8,
    pub weapon_slot: u8,
    pub alt_weapon_slot: i8,
    pub linked_to_weapon_slot: i8,
    pub projectiles_in_magazines: i16,
    pub projectiles_loaded: i16,
    pub ammo_pickup: bool,
    pub ammo_pickup_unlimited: bool,
    pub use_weapon_mesh: bool,
    pub soldier_weapons_net_state: SoldierWeaponsNetState,
}

pub trait WeaponsPickupNetStateTrait: TypeObject {
    fn soldier_weapon_unlock(&self) -> &Option<Arc<Mutex<dyn SoldierWeaponUnlockAssetTrait>>>;
    fn soldier_weapon_unlock_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoldierWeaponUnlockAssetTrait>>>;
    fn weapon_slot_unlocks_size(&self) -> &u8;
    fn weapon_slot_unlocks_size_mut(&mut self) -> &mut u8;
    fn weapon_slot(&self) -> &u8;
    fn weapon_slot_mut(&mut self) -> &mut u8;
    fn alt_weapon_slot(&self) -> &i8;
    fn alt_weapon_slot_mut(&mut self) -> &mut i8;
    fn linked_to_weapon_slot(&self) -> &i8;
    fn linked_to_weapon_slot_mut(&mut self) -> &mut i8;
    fn projectiles_in_magazines(&self) -> &i16;
    fn projectiles_in_magazines_mut(&mut self) -> &mut i16;
    fn projectiles_loaded(&self) -> &i16;
    fn projectiles_loaded_mut(&mut self) -> &mut i16;
    fn ammo_pickup(&self) -> &bool;
    fn ammo_pickup_mut(&mut self) -> &mut bool;
    fn ammo_pickup_unlimited(&self) -> &bool;
    fn ammo_pickup_unlimited_mut(&mut self) -> &mut bool;
    fn use_weapon_mesh(&self) -> &bool;
    fn use_weapon_mesh_mut(&mut self) -> &mut bool;
    fn soldier_weapons_net_state(&self) -> &SoldierWeaponsNetState;
    fn soldier_weapons_net_state_mut(&mut self) -> &mut SoldierWeaponsNetState;
}

impl WeaponsPickupNetStateTrait for WeaponsPickupNetState {
    fn soldier_weapon_unlock(&self) -> &Option<Arc<Mutex<dyn SoldierWeaponUnlockAssetTrait>>> {
        &self.soldier_weapon_unlock
    }
    fn soldier_weapon_unlock_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoldierWeaponUnlockAssetTrait>>> {
        &mut self.soldier_weapon_unlock
    }
    fn weapon_slot_unlocks_size(&self) -> &u8 {
        &self.weapon_slot_unlocks_size
    }
    fn weapon_slot_unlocks_size_mut(&mut self) -> &mut u8 {
        &mut self.weapon_slot_unlocks_size
    }
    fn weapon_slot(&self) -> &u8 {
        &self.weapon_slot
    }
    fn weapon_slot_mut(&mut self) -> &mut u8 {
        &mut self.weapon_slot
    }
    fn alt_weapon_slot(&self) -> &i8 {
        &self.alt_weapon_slot
    }
    fn alt_weapon_slot_mut(&mut self) -> &mut i8 {
        &mut self.alt_weapon_slot
    }
    fn linked_to_weapon_slot(&self) -> &i8 {
        &self.linked_to_weapon_slot
    }
    fn linked_to_weapon_slot_mut(&mut self) -> &mut i8 {
        &mut self.linked_to_weapon_slot
    }
    fn projectiles_in_magazines(&self) -> &i16 {
        &self.projectiles_in_magazines
    }
    fn projectiles_in_magazines_mut(&mut self) -> &mut i16 {
        &mut self.projectiles_in_magazines
    }
    fn projectiles_loaded(&self) -> &i16 {
        &self.projectiles_loaded
    }
    fn projectiles_loaded_mut(&mut self) -> &mut i16 {
        &mut self.projectiles_loaded
    }
    fn ammo_pickup(&self) -> &bool {
        &self.ammo_pickup
    }
    fn ammo_pickup_mut(&mut self) -> &mut bool {
        &mut self.ammo_pickup
    }
    fn ammo_pickup_unlimited(&self) -> &bool {
        &self.ammo_pickup_unlimited
    }
    fn ammo_pickup_unlimited_mut(&mut self) -> &mut bool {
        &mut self.ammo_pickup_unlimited
    }
    fn use_weapon_mesh(&self) -> &bool {
        &self.use_weapon_mesh
    }
    fn use_weapon_mesh_mut(&mut self) -> &mut bool {
        &mut self.use_weapon_mesh
    }
    fn soldier_weapons_net_state(&self) -> &SoldierWeaponsNetState {
        &self.soldier_weapons_net_state
    }
    fn soldier_weapons_net_state_mut(&mut self) -> &mut SoldierWeaponsNetState {
        &mut self.soldier_weapons_net_state
    }
}

pub static WEAPONSPICKUPNETSTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponsPickupNetState",
    flags: MemberInfoFlags::new(73),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WeaponsPickupNetState as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SoldierWeaponUnlock",
                flags: MemberInfoFlags::new(0),
                field_type: "SoldierWeaponUnlockAsset",
                rust_offset: offset_of!(WeaponsPickupNetState, soldier_weapon_unlock),
            },
            FieldInfoData {
                name: "WeaponSlotUnlocksSize",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(WeaponsPickupNetState, weapon_slot_unlocks_size),
            },
            FieldInfoData {
                name: "WeaponSlot",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(WeaponsPickupNetState, weapon_slot),
            },
            FieldInfoData {
                name: "AltWeaponSlot",
                flags: MemberInfoFlags::new(0),
                field_type: "Int8",
                rust_offset: offset_of!(WeaponsPickupNetState, alt_weapon_slot),
            },
            FieldInfoData {
                name: "LinkedToWeaponSlot",
                flags: MemberInfoFlags::new(0),
                field_type: "Int8",
                rust_offset: offset_of!(WeaponsPickupNetState, linked_to_weapon_slot),
            },
            FieldInfoData {
                name: "ProjectilesInMagazines",
                flags: MemberInfoFlags::new(0),
                field_type: "Int16",
                rust_offset: offset_of!(WeaponsPickupNetState, projectiles_in_magazines),
            },
            FieldInfoData {
                name: "ProjectilesLoaded",
                flags: MemberInfoFlags::new(0),
                field_type: "Int16",
                rust_offset: offset_of!(WeaponsPickupNetState, projectiles_loaded),
            },
            FieldInfoData {
                name: "AmmoPickup",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WeaponsPickupNetState, ammo_pickup),
            },
            FieldInfoData {
                name: "AmmoPickupUnlimited",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WeaponsPickupNetState, ammo_pickup_unlimited),
            },
            FieldInfoData {
                name: "UseWeaponMesh",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WeaponsPickupNetState, use_weapon_mesh),
            },
            FieldInfoData {
                name: "SoldierWeaponsNetState",
                flags: MemberInfoFlags::new(0),
                field_type: "SoldierWeaponsNetState",
                rust_offset: offset_of!(WeaponsPickupNetState, soldier_weapons_net_state),
            },
        ],
    }),
    array_type: Some(WEAPONSPICKUPNETSTATE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WeaponsPickupNetState {
    fn type_info(&self) -> &'static TypeInfo {
        WEAPONSPICKUPNETSTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static WEAPONSPICKUPNETSTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponsPickupNetState-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("WeaponsPickupNetState"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum PickupPlayerEnum {
    #[default]
    PickupPlayerEnum_None = 0,
    PickupPlayerEnum_Both = 1,
    PickupPlayerEnum_HumanOnly = 2,
    PickupPlayerEnum_AIOnly = 3,
}

pub static PICKUPPLAYERENUM_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PickupPlayerEnum",
    flags: MemberInfoFlags::new(49429),
    module: "SoldierShared",
    data: TypeInfoData::Enum,
    array_type: Some(PICKUPPLAYERENUM_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for PickupPlayerEnum {
    fn type_info(&self) -> &'static TypeInfo {
        PICKUPPLAYERENUM_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static PICKUPPLAYERENUM_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PickupPlayerEnum-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("PickupPlayerEnum"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct NetworkedSpecialDeathParameters {
    pub forward_speed: i32,
    pub right_speed: i32,
    pub hit_direction: super::game_shared::CharacterEntityHitDirection,
    pub random_value: f32,
    pub pose: super::physics::CharacterPoseType,
    pub hit_reaction_type: super::game_shared::HitReactionType,
    pub unique_index: AIDeathReactionAnimationType,
    pub death_animation_triggered: bool,
    pub on_ground: bool,
    pub sprinting: bool,
    pub explosion: bool,
}

pub trait NetworkedSpecialDeathParametersTrait: TypeObject {
    fn forward_speed(&self) -> &i32;
    fn forward_speed_mut(&mut self) -> &mut i32;
    fn right_speed(&self) -> &i32;
    fn right_speed_mut(&mut self) -> &mut i32;
    fn hit_direction(&self) -> &super::game_shared::CharacterEntityHitDirection;
    fn hit_direction_mut(&mut self) -> &mut super::game_shared::CharacterEntityHitDirection;
    fn random_value(&self) -> &f32;
    fn random_value_mut(&mut self) -> &mut f32;
    fn pose(&self) -> &super::physics::CharacterPoseType;
    fn pose_mut(&mut self) -> &mut super::physics::CharacterPoseType;
    fn hit_reaction_type(&self) -> &super::game_shared::HitReactionType;
    fn hit_reaction_type_mut(&mut self) -> &mut super::game_shared::HitReactionType;
    fn unique_index(&self) -> &AIDeathReactionAnimationType;
    fn unique_index_mut(&mut self) -> &mut AIDeathReactionAnimationType;
    fn death_animation_triggered(&self) -> &bool;
    fn death_animation_triggered_mut(&mut self) -> &mut bool;
    fn on_ground(&self) -> &bool;
    fn on_ground_mut(&mut self) -> &mut bool;
    fn sprinting(&self) -> &bool;
    fn sprinting_mut(&mut self) -> &mut bool;
    fn explosion(&self) -> &bool;
    fn explosion_mut(&mut self) -> &mut bool;
}

impl NetworkedSpecialDeathParametersTrait for NetworkedSpecialDeathParameters {
    fn forward_speed(&self) -> &i32 {
        &self.forward_speed
    }
    fn forward_speed_mut(&mut self) -> &mut i32 {
        &mut self.forward_speed
    }
    fn right_speed(&self) -> &i32 {
        &self.right_speed
    }
    fn right_speed_mut(&mut self) -> &mut i32 {
        &mut self.right_speed
    }
    fn hit_direction(&self) -> &super::game_shared::CharacterEntityHitDirection {
        &self.hit_direction
    }
    fn hit_direction_mut(&mut self) -> &mut super::game_shared::CharacterEntityHitDirection {
        &mut self.hit_direction
    }
    fn random_value(&self) -> &f32 {
        &self.random_value
    }
    fn random_value_mut(&mut self) -> &mut f32 {
        &mut self.random_value
    }
    fn pose(&self) -> &super::physics::CharacterPoseType {
        &self.pose
    }
    fn pose_mut(&mut self) -> &mut super::physics::CharacterPoseType {
        &mut self.pose
    }
    fn hit_reaction_type(&self) -> &super::game_shared::HitReactionType {
        &self.hit_reaction_type
    }
    fn hit_reaction_type_mut(&mut self) -> &mut super::game_shared::HitReactionType {
        &mut self.hit_reaction_type
    }
    fn unique_index(&self) -> &AIDeathReactionAnimationType {
        &self.unique_index
    }
    fn unique_index_mut(&mut self) -> &mut AIDeathReactionAnimationType {
        &mut self.unique_index
    }
    fn death_animation_triggered(&self) -> &bool {
        &self.death_animation_triggered
    }
    fn death_animation_triggered_mut(&mut self) -> &mut bool {
        &mut self.death_animation_triggered
    }
    fn on_ground(&self) -> &bool {
        &self.on_ground
    }
    fn on_ground_mut(&mut self) -> &mut bool {
        &mut self.on_ground
    }
    fn sprinting(&self) -> &bool {
        &self.sprinting
    }
    fn sprinting_mut(&mut self) -> &mut bool {
        &mut self.sprinting
    }
    fn explosion(&self) -> &bool {
        &self.explosion
    }
    fn explosion_mut(&mut self) -> &mut bool {
        &mut self.explosion
    }
}

pub static NETWORKEDSPECIALDEATHPARAMETERS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NetworkedSpecialDeathParameters",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<NetworkedSpecialDeathParameters as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ForwardSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(NetworkedSpecialDeathParameters, forward_speed),
            },
            FieldInfoData {
                name: "RightSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(NetworkedSpecialDeathParameters, right_speed),
            },
            FieldInfoData {
                name: "HitDirection",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterEntityHitDirection",
                rust_offset: offset_of!(NetworkedSpecialDeathParameters, hit_direction),
            },
            FieldInfoData {
                name: "RandomValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(NetworkedSpecialDeathParameters, random_value),
            },
            FieldInfoData {
                name: "Pose",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterPoseType",
                rust_offset: offset_of!(NetworkedSpecialDeathParameters, pose),
            },
            FieldInfoData {
                name: "HitReactionType",
                flags: MemberInfoFlags::new(0),
                field_type: "HitReactionType",
                rust_offset: offset_of!(NetworkedSpecialDeathParameters, hit_reaction_type),
            },
            FieldInfoData {
                name: "UniqueIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "AIDeathReactionAnimationType",
                rust_offset: offset_of!(NetworkedSpecialDeathParameters, unique_index),
            },
            FieldInfoData {
                name: "DeathAnimationTriggered",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(NetworkedSpecialDeathParameters, death_animation_triggered),
            },
            FieldInfoData {
                name: "OnGround",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(NetworkedSpecialDeathParameters, on_ground),
            },
            FieldInfoData {
                name: "Sprinting",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(NetworkedSpecialDeathParameters, sprinting),
            },
            FieldInfoData {
                name: "Explosion",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(NetworkedSpecialDeathParameters, explosion),
            },
        ],
    }),
    array_type: Some(NETWORKEDSPECIALDEATHPARAMETERS_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for NetworkedSpecialDeathParameters {
    fn type_info(&self) -> &'static TypeInfo {
        NETWORKEDSPECIALDEATHPARAMETERS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static NETWORKEDSPECIALDEATHPARAMETERS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NetworkedSpecialDeathParameters-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("NetworkedSpecialDeathParameters"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WeaponStateEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub weapon_slot: i32,
    pub ammo: i32,
    pub ammo_in_mags: i32,
    pub use_local_player: bool,
}

pub trait WeaponStateEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn weapon_slot(&self) -> &i32;
    fn weapon_slot_mut(&mut self) -> &mut i32;
    fn ammo(&self) -> &i32;
    fn ammo_mut(&mut self) -> &mut i32;
    fn ammo_in_mags(&self) -> &i32;
    fn ammo_in_mags_mut(&mut self) -> &mut i32;
    fn use_local_player(&self) -> &bool;
    fn use_local_player_mut(&mut self) -> &mut bool;
}

impl WeaponStateEntityDataTrait for WeaponStateEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn weapon_slot(&self) -> &i32 {
        &self.weapon_slot
    }
    fn weapon_slot_mut(&mut self) -> &mut i32 {
        &mut self.weapon_slot
    }
    fn ammo(&self) -> &i32 {
        &self.ammo
    }
    fn ammo_mut(&mut self) -> &mut i32 {
        &mut self.ammo
    }
    fn ammo_in_mags(&self) -> &i32 {
        &self.ammo_in_mags
    }
    fn ammo_in_mags_mut(&mut self) -> &mut i32 {
        &mut self.ammo_in_mags
    }
    fn use_local_player(&self) -> &bool {
        &self.use_local_player
    }
    fn use_local_player_mut(&mut self) -> &mut bool {
        &mut self.use_local_player
    }
}

impl super::entity::EntityDataTrait for WeaponStateEntityData {
}

impl super::entity::GameObjectDataTrait for WeaponStateEntityData {
}

impl super::core::DataBusPeerTrait for WeaponStateEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for WeaponStateEntityData {
}

impl super::core::DataContainerTrait for WeaponStateEntityData {
}

pub static WEAPONSTATEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponStateEntityData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WeaponStateEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(WeaponStateEntityData, realm),
            },
            FieldInfoData {
                name: "WeaponSlot",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(WeaponStateEntityData, weapon_slot),
            },
            FieldInfoData {
                name: "Ammo",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(WeaponStateEntityData, ammo),
            },
            FieldInfoData {
                name: "AmmoInMags",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(WeaponStateEntityData, ammo_in_mags),
            },
            FieldInfoData {
                name: "UseLocalPlayer",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WeaponStateEntityData, use_local_player),
            },
        ],
    }),
    array_type: Some(WEAPONSTATEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WeaponStateEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        WEAPONSTATEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WEAPONSTATEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponStateEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("WeaponStateEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoldierWeaponSocketEntityData {
    pub _glacier_base: super::entity::EntityData,
}

pub trait SoldierWeaponSocketEntityDataTrait: super::entity::EntityDataTrait {
}

impl SoldierWeaponSocketEntityDataTrait for SoldierWeaponSocketEntityData {
}

impl super::entity::EntityDataTrait for SoldierWeaponSocketEntityData {
}

impl super::entity::GameObjectDataTrait for SoldierWeaponSocketEntityData {
}

impl super::core::DataBusPeerTrait for SoldierWeaponSocketEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SoldierWeaponSocketEntityData {
}

impl super::core::DataContainerTrait for SoldierWeaponSocketEntityData {
}

pub static SOLDIERWEAPONSOCKETENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierWeaponSocketEntityData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierWeaponSocketEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SOLDIERWEAPONSOCKETENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoldierWeaponSocketEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERWEAPONSOCKETENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOLDIERWEAPONSOCKETENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierWeaponSocketEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SoldierWeaponSocketEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct StateEventGateEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub checked_state: EventGateState,
}

pub trait StateEventGateEntityDataTrait: super::entity::EntityDataTrait {
    fn checked_state(&self) -> &EventGateState;
    fn checked_state_mut(&mut self) -> &mut EventGateState;
}

impl StateEventGateEntityDataTrait for StateEventGateEntityData {
    fn checked_state(&self) -> &EventGateState {
        &self.checked_state
    }
    fn checked_state_mut(&mut self) -> &mut EventGateState {
        &mut self.checked_state
    }
}

impl super::entity::EntityDataTrait for StateEventGateEntityData {
}

impl super::entity::GameObjectDataTrait for StateEventGateEntityData {
}

impl super::core::DataBusPeerTrait for StateEventGateEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for StateEventGateEntityData {
}

impl super::core::DataContainerTrait for StateEventGateEntityData {
}

pub static STATEEVENTGATEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StateEventGateEntityData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StateEventGateEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "CheckedState",
                flags: MemberInfoFlags::new(0),
                field_type: "EventGateState",
                rust_offset: offset_of!(StateEventGateEntityData, checked_state),
            },
        ],
    }),
    array_type: Some(STATEEVENTGATEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for StateEventGateEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        STATEEVENTGATEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static STATEEVENTGATEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StateEventGateEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("StateEventGateEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum EventGateState {
    #[default]
    EGSInvalid = 0,
    EGSUpright = 1,
    EGSCrouched = 2,
    EGSProne = 3,
    EGSZoomed = 4,
    EGSCount = 5,
}

pub static EVENTGATESTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventGateState",
    flags: MemberInfoFlags::new(49429),
    module: "SoldierShared",
    data: TypeInfoData::Enum,
    array_type: Some(EVENTGATESTATE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for EventGateState {
    fn type_info(&self) -> &'static TypeInfo {
        EVENTGATESTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static EVENTGATESTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventGateState-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("EventGateState"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlayerLookAtEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub target_transform: super::core::LinearTransform,
}

pub trait PlayerLookAtEntityDataTrait: super::entity::EntityDataTrait {
    fn target_transform(&self) -> &super::core::LinearTransform;
    fn target_transform_mut(&mut self) -> &mut super::core::LinearTransform;
}

impl PlayerLookAtEntityDataTrait for PlayerLookAtEntityData {
    fn target_transform(&self) -> &super::core::LinearTransform {
        &self.target_transform
    }
    fn target_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.target_transform
    }
}

impl super::entity::EntityDataTrait for PlayerLookAtEntityData {
}

impl super::entity::GameObjectDataTrait for PlayerLookAtEntityData {
}

impl super::core::DataBusPeerTrait for PlayerLookAtEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PlayerLookAtEntityData {
}

impl super::core::DataContainerTrait for PlayerLookAtEntityData {
}

pub static PLAYERLOOKATENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerLookAtEntityData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayerLookAtEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "TargetTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(PlayerLookAtEntityData, target_transform),
            },
        ],
    }),
    array_type: Some(PLAYERLOOKATENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PlayerLookAtEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERLOOKATENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PLAYERLOOKATENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerLookAtEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("PlayerLookAtEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct HitReactionComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub hit_reaction_binding: HitReactionComponentBinding,
    pub enabled: bool,
    pub settings: HitReactionSettings,
    pub override_settings_for_local_player: bool,
    pub local_player_controlled_settings: HitReactionSettings,
    pub manually_triggered_hit_reaction_type: super::weapon_shared::AntHitReactionWeaponType,
}

pub trait HitReactionComponentDataTrait: super::entity::GameComponentDataTrait {
    fn hit_reaction_binding(&self) -> &HitReactionComponentBinding;
    fn hit_reaction_binding_mut(&mut self) -> &mut HitReactionComponentBinding;
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
    fn settings(&self) -> &HitReactionSettings;
    fn settings_mut(&mut self) -> &mut HitReactionSettings;
    fn override_settings_for_local_player(&self) -> &bool;
    fn override_settings_for_local_player_mut(&mut self) -> &mut bool;
    fn local_player_controlled_settings(&self) -> &HitReactionSettings;
    fn local_player_controlled_settings_mut(&mut self) -> &mut HitReactionSettings;
    fn manually_triggered_hit_reaction_type(&self) -> &super::weapon_shared::AntHitReactionWeaponType;
    fn manually_triggered_hit_reaction_type_mut(&mut self) -> &mut super::weapon_shared::AntHitReactionWeaponType;
}

impl HitReactionComponentDataTrait for HitReactionComponentData {
    fn hit_reaction_binding(&self) -> &HitReactionComponentBinding {
        &self.hit_reaction_binding
    }
    fn hit_reaction_binding_mut(&mut self) -> &mut HitReactionComponentBinding {
        &mut self.hit_reaction_binding
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
    fn settings(&self) -> &HitReactionSettings {
        &self.settings
    }
    fn settings_mut(&mut self) -> &mut HitReactionSettings {
        &mut self.settings
    }
    fn override_settings_for_local_player(&self) -> &bool {
        &self.override_settings_for_local_player
    }
    fn override_settings_for_local_player_mut(&mut self) -> &mut bool {
        &mut self.override_settings_for_local_player
    }
    fn local_player_controlled_settings(&self) -> &HitReactionSettings {
        &self.local_player_controlled_settings
    }
    fn local_player_controlled_settings_mut(&mut self) -> &mut HitReactionSettings {
        &mut self.local_player_controlled_settings
    }
    fn manually_triggered_hit_reaction_type(&self) -> &super::weapon_shared::AntHitReactionWeaponType {
        &self.manually_triggered_hit_reaction_type
    }
    fn manually_triggered_hit_reaction_type_mut(&mut self) -> &mut super::weapon_shared::AntHitReactionWeaponType {
        &mut self.manually_triggered_hit_reaction_type
    }
}

impl super::entity::GameComponentDataTrait for HitReactionComponentData {
}

impl super::entity::ComponentDataTrait for HitReactionComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for HitReactionComponentData {
}

impl super::core::DataBusPeerTrait for HitReactionComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for HitReactionComponentData {
}

impl super::core::DataContainerTrait for HitReactionComponentData {
}

pub static HITREACTIONCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HitReactionComponentData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<HitReactionComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "HitReactionBinding",
                flags: MemberInfoFlags::new(0),
                field_type: "HitReactionComponentBinding",
                rust_offset: offset_of!(HitReactionComponentData, hit_reaction_binding),
            },
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(HitReactionComponentData, enabled),
            },
            FieldInfoData {
                name: "Settings",
                flags: MemberInfoFlags::new(0),
                field_type: "HitReactionSettings",
                rust_offset: offset_of!(HitReactionComponentData, settings),
            },
            FieldInfoData {
                name: "OverrideSettingsForLocalPlayer",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(HitReactionComponentData, override_settings_for_local_player),
            },
            FieldInfoData {
                name: "LocalPlayerControlledSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "HitReactionSettings",
                rust_offset: offset_of!(HitReactionComponentData, local_player_controlled_settings),
            },
            FieldInfoData {
                name: "ManuallyTriggeredHitReactionType",
                flags: MemberInfoFlags::new(0),
                field_type: "AntHitReactionWeaponType",
                rust_offset: offset_of!(HitReactionComponentData, manually_triggered_hit_reaction_type),
            },
        ],
    }),
    array_type: Some(HITREACTIONCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for HitReactionComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        HITREACTIONCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static HITREACTIONCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HitReactionComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("HitReactionComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct HitReactionSettings {
    pub trigger_on_friendly: bool,
    pub trigger_on_own_damage: bool,
    pub trigger_on_non_friendly: bool,
    pub ignore_shockwave: bool,
}

pub trait HitReactionSettingsTrait: TypeObject {
    fn trigger_on_friendly(&self) -> &bool;
    fn trigger_on_friendly_mut(&mut self) -> &mut bool;
    fn trigger_on_own_damage(&self) -> &bool;
    fn trigger_on_own_damage_mut(&mut self) -> &mut bool;
    fn trigger_on_non_friendly(&self) -> &bool;
    fn trigger_on_non_friendly_mut(&mut self) -> &mut bool;
    fn ignore_shockwave(&self) -> &bool;
    fn ignore_shockwave_mut(&mut self) -> &mut bool;
}

impl HitReactionSettingsTrait for HitReactionSettings {
    fn trigger_on_friendly(&self) -> &bool {
        &self.trigger_on_friendly
    }
    fn trigger_on_friendly_mut(&mut self) -> &mut bool {
        &mut self.trigger_on_friendly
    }
    fn trigger_on_own_damage(&self) -> &bool {
        &self.trigger_on_own_damage
    }
    fn trigger_on_own_damage_mut(&mut self) -> &mut bool {
        &mut self.trigger_on_own_damage
    }
    fn trigger_on_non_friendly(&self) -> &bool {
        &self.trigger_on_non_friendly
    }
    fn trigger_on_non_friendly_mut(&mut self) -> &mut bool {
        &mut self.trigger_on_non_friendly
    }
    fn ignore_shockwave(&self) -> &bool {
        &self.ignore_shockwave
    }
    fn ignore_shockwave_mut(&mut self) -> &mut bool {
        &mut self.ignore_shockwave
    }
}

pub static HITREACTIONSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HitReactionSettings",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<HitReactionSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "TriggerOnFriendly",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(HitReactionSettings, trigger_on_friendly),
            },
            FieldInfoData {
                name: "TriggerOnOwnDamage",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(HitReactionSettings, trigger_on_own_damage),
            },
            FieldInfoData {
                name: "TriggerOnNonFriendly",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(HitReactionSettings, trigger_on_non_friendly),
            },
            FieldInfoData {
                name: "IgnoreShockwave",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(HitReactionSettings, ignore_shockwave),
            },
        ],
    }),
    array_type: Some(HITREACTIONSETTINGS_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for HitReactionSettings {
    fn type_info(&self) -> &'static TypeInfo {
        HITREACTIONSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static HITREACTIONSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HitReactionSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("HitReactionSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct HitReactionComponentBinding {
    pub hit: super::ant::AntRef,
    pub hit_by_a_i_player: super::ant::AntRef,
    pub allow_kill_from_animation: super::ant::AntRef,
    pub direction: super::ant::AntRef,
    pub firing_distance: super::ant::AntRef,
    pub bone_type: super::ant::AntRef,
    pub impact_type: super::ant::AntRef,
    pub immortal: super::ant::AntRef,
    pub random_animation_index: super::ant::AntRef,
    pub explosion_nearby: super::ant::AntRef,
    pub explosion_nearby_a_i_player: super::ant::AntRef,
    pub explosion_direction: super::ant::AntRef,
}

pub trait HitReactionComponentBindingTrait: TypeObject {
    fn hit(&self) -> &super::ant::AntRef;
    fn hit_mut(&mut self) -> &mut super::ant::AntRef;
    fn hit_by_a_i_player(&self) -> &super::ant::AntRef;
    fn hit_by_a_i_player_mut(&mut self) -> &mut super::ant::AntRef;
    fn allow_kill_from_animation(&self) -> &super::ant::AntRef;
    fn allow_kill_from_animation_mut(&mut self) -> &mut super::ant::AntRef;
    fn direction(&self) -> &super::ant::AntRef;
    fn direction_mut(&mut self) -> &mut super::ant::AntRef;
    fn firing_distance(&self) -> &super::ant::AntRef;
    fn firing_distance_mut(&mut self) -> &mut super::ant::AntRef;
    fn bone_type(&self) -> &super::ant::AntRef;
    fn bone_type_mut(&mut self) -> &mut super::ant::AntRef;
    fn impact_type(&self) -> &super::ant::AntRef;
    fn impact_type_mut(&mut self) -> &mut super::ant::AntRef;
    fn immortal(&self) -> &super::ant::AntRef;
    fn immortal_mut(&mut self) -> &mut super::ant::AntRef;
    fn random_animation_index(&self) -> &super::ant::AntRef;
    fn random_animation_index_mut(&mut self) -> &mut super::ant::AntRef;
    fn explosion_nearby(&self) -> &super::ant::AntRef;
    fn explosion_nearby_mut(&mut self) -> &mut super::ant::AntRef;
    fn explosion_nearby_a_i_player(&self) -> &super::ant::AntRef;
    fn explosion_nearby_a_i_player_mut(&mut self) -> &mut super::ant::AntRef;
    fn explosion_direction(&self) -> &super::ant::AntRef;
    fn explosion_direction_mut(&mut self) -> &mut super::ant::AntRef;
}

impl HitReactionComponentBindingTrait for HitReactionComponentBinding {
    fn hit(&self) -> &super::ant::AntRef {
        &self.hit
    }
    fn hit_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.hit
    }
    fn hit_by_a_i_player(&self) -> &super::ant::AntRef {
        &self.hit_by_a_i_player
    }
    fn hit_by_a_i_player_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.hit_by_a_i_player
    }
    fn allow_kill_from_animation(&self) -> &super::ant::AntRef {
        &self.allow_kill_from_animation
    }
    fn allow_kill_from_animation_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.allow_kill_from_animation
    }
    fn direction(&self) -> &super::ant::AntRef {
        &self.direction
    }
    fn direction_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.direction
    }
    fn firing_distance(&self) -> &super::ant::AntRef {
        &self.firing_distance
    }
    fn firing_distance_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.firing_distance
    }
    fn bone_type(&self) -> &super::ant::AntRef {
        &self.bone_type
    }
    fn bone_type_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.bone_type
    }
    fn impact_type(&self) -> &super::ant::AntRef {
        &self.impact_type
    }
    fn impact_type_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.impact_type
    }
    fn immortal(&self) -> &super::ant::AntRef {
        &self.immortal
    }
    fn immortal_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.immortal
    }
    fn random_animation_index(&self) -> &super::ant::AntRef {
        &self.random_animation_index
    }
    fn random_animation_index_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.random_animation_index
    }
    fn explosion_nearby(&self) -> &super::ant::AntRef {
        &self.explosion_nearby
    }
    fn explosion_nearby_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.explosion_nearby
    }
    fn explosion_nearby_a_i_player(&self) -> &super::ant::AntRef {
        &self.explosion_nearby_a_i_player
    }
    fn explosion_nearby_a_i_player_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.explosion_nearby_a_i_player
    }
    fn explosion_direction(&self) -> &super::ant::AntRef {
        &self.explosion_direction
    }
    fn explosion_direction_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.explosion_direction
    }
}

pub static HITREACTIONCOMPONENTBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HitReactionComponentBinding",
    flags: MemberInfoFlags::new(32841),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<HitReactionComponentBinding as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Hit",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(HitReactionComponentBinding, hit),
            },
            FieldInfoData {
                name: "HitByAIPlayer",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(HitReactionComponentBinding, hit_by_a_i_player),
            },
            FieldInfoData {
                name: "AllowKillFromAnimation",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(HitReactionComponentBinding, allow_kill_from_animation),
            },
            FieldInfoData {
                name: "Direction",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(HitReactionComponentBinding, direction),
            },
            FieldInfoData {
                name: "FiringDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(HitReactionComponentBinding, firing_distance),
            },
            FieldInfoData {
                name: "BoneType",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(HitReactionComponentBinding, bone_type),
            },
            FieldInfoData {
                name: "ImpactType",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(HitReactionComponentBinding, impact_type),
            },
            FieldInfoData {
                name: "Immortal",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(HitReactionComponentBinding, immortal),
            },
            FieldInfoData {
                name: "RandomAnimationIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(HitReactionComponentBinding, random_animation_index),
            },
            FieldInfoData {
                name: "ExplosionNearby",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(HitReactionComponentBinding, explosion_nearby),
            },
            FieldInfoData {
                name: "ExplosionNearbyAIPlayer",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(HitReactionComponentBinding, explosion_nearby_a_i_player),
            },
            FieldInfoData {
                name: "ExplosionDirection",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(HitReactionComponentBinding, explosion_direction),
            },
        ],
    }),
    array_type: Some(HITREACTIONCOMPONENTBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for HitReactionComponentBinding {
    fn type_info(&self) -> &'static TypeInfo {
        HITREACTIONCOMPONENTBINDING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static HITREACTIONCOMPONENTBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HitReactionComponentBinding-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("HitReactionComponentBinding"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum AIHitReactionAnimationType {
    #[default]
    AIHitReactionAnimationType_1 = 0,
    AIHitReactionAnimationType_2 = 1,
    AIHitReactionAnimationType_3 = 2,
    AIHitReactionAnimationType_4 = 3,
    AIHitReactionAnimationType_5 = 4,
    AIHitReactionAnimationType_Count = 5,
}

pub static AIHITREACTIONANIMATIONTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIHitReactionAnimationType",
    flags: MemberInfoFlags::new(49429),
    module: "SoldierShared",
    data: TypeInfoData::Enum,
    array_type: Some(AIHITREACTIONANIMATIONTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AIHitReactionAnimationType {
    fn type_info(&self) -> &'static TypeInfo {
        AIHITREACTIONANIMATIONTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AIHITREACTIONANIMATIONTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIHitReactionAnimationType-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("AIHitReactionAnimationType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FaceposerComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub face_poser_enabled: super::ant::AntRef,
    pub lod_distance: f32,
    pub face_pose_library_reference: super::ant::AntRef,
    pub face_pose_library: Vec<super::ant::AntRef>,
    pub face_poser_dof_set_name: String,
    pub shader_exposed_values: Vec<String>,
    pub face_pose_library_index: i32,
}

pub trait FaceposerComponentDataTrait: super::entity::GameComponentDataTrait {
    fn face_poser_enabled(&self) -> &super::ant::AntRef;
    fn face_poser_enabled_mut(&mut self) -> &mut super::ant::AntRef;
    fn lod_distance(&self) -> &f32;
    fn lod_distance_mut(&mut self) -> &mut f32;
    fn face_pose_library_reference(&self) -> &super::ant::AntRef;
    fn face_pose_library_reference_mut(&mut self) -> &mut super::ant::AntRef;
    fn face_pose_library(&self) -> &Vec<super::ant::AntRef>;
    fn face_pose_library_mut(&mut self) -> &mut Vec<super::ant::AntRef>;
    fn face_poser_dof_set_name(&self) -> &String;
    fn face_poser_dof_set_name_mut(&mut self) -> &mut String;
    fn shader_exposed_values(&self) -> &Vec<String>;
    fn shader_exposed_values_mut(&mut self) -> &mut Vec<String>;
    fn face_pose_library_index(&self) -> &i32;
    fn face_pose_library_index_mut(&mut self) -> &mut i32;
}

impl FaceposerComponentDataTrait for FaceposerComponentData {
    fn face_poser_enabled(&self) -> &super::ant::AntRef {
        &self.face_poser_enabled
    }
    fn face_poser_enabled_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.face_poser_enabled
    }
    fn lod_distance(&self) -> &f32 {
        &self.lod_distance
    }
    fn lod_distance_mut(&mut self) -> &mut f32 {
        &mut self.lod_distance
    }
    fn face_pose_library_reference(&self) -> &super::ant::AntRef {
        &self.face_pose_library_reference
    }
    fn face_pose_library_reference_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.face_pose_library_reference
    }
    fn face_pose_library(&self) -> &Vec<super::ant::AntRef> {
        &self.face_pose_library
    }
    fn face_pose_library_mut(&mut self) -> &mut Vec<super::ant::AntRef> {
        &mut self.face_pose_library
    }
    fn face_poser_dof_set_name(&self) -> &String {
        &self.face_poser_dof_set_name
    }
    fn face_poser_dof_set_name_mut(&mut self) -> &mut String {
        &mut self.face_poser_dof_set_name
    }
    fn shader_exposed_values(&self) -> &Vec<String> {
        &self.shader_exposed_values
    }
    fn shader_exposed_values_mut(&mut self) -> &mut Vec<String> {
        &mut self.shader_exposed_values
    }
    fn face_pose_library_index(&self) -> &i32 {
        &self.face_pose_library_index
    }
    fn face_pose_library_index_mut(&mut self) -> &mut i32 {
        &mut self.face_pose_library_index
    }
}

impl super::entity::GameComponentDataTrait for FaceposerComponentData {
}

impl super::entity::ComponentDataTrait for FaceposerComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for FaceposerComponentData {
}

impl super::core::DataBusPeerTrait for FaceposerComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for FaceposerComponentData {
}

impl super::core::DataContainerTrait for FaceposerComponentData {
}

pub static FACEPOSERCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FaceposerComponentData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FaceposerComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "FacePoserEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(FaceposerComponentData, face_poser_enabled),
            },
            FieldInfoData {
                name: "LodDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FaceposerComponentData, lod_distance),
            },
            FieldInfoData {
                name: "FacePoseLibraryReference",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(FaceposerComponentData, face_pose_library_reference),
            },
            FieldInfoData {
                name: "FacePoseLibrary",
                flags: MemberInfoFlags::new(144),
                field_type: "AntRef-Array",
                rust_offset: offset_of!(FaceposerComponentData, face_pose_library),
            },
            FieldInfoData {
                name: "FacePoserDofSetName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(FaceposerComponentData, face_poser_dof_set_name),
            },
            FieldInfoData {
                name: "ShaderExposedValues",
                flags: MemberInfoFlags::new(144),
                field_type: "CString-Array",
                rust_offset: offset_of!(FaceposerComponentData, shader_exposed_values),
            },
            FieldInfoData {
                name: "FacePoseLibraryIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(FaceposerComponentData, face_pose_library_index),
            },
        ],
    }),
    array_type: Some(FACEPOSERCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for FaceposerComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        FACEPOSERCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FACEPOSERCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FaceposerComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("FaceposerComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateCorrectedChannelChangeMessage {
}

pub trait CharacterStateCorrectedChannelChangeMessageTrait: TypeObject {
}

impl CharacterStateCorrectedChannelChangeMessageTrait for CharacterStateCorrectedChannelChangeMessage {
}

pub static CHARACTERSTATECORRECTEDCHANNELCHANGEMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateCorrectedChannelChangeMessage",
    flags: MemberInfoFlags::new(73),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateCorrectedChannelChangeMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 16,
};

impl TypeObject for CharacterStateCorrectedChannelChangeMessage {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATECORRECTEDCHANNELCHANGEMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Clone, Debug, Default)]
pub struct CorrectedChannelChangeList {
}

pub trait CorrectedChannelChangeListTrait: TypeObject {
}

impl CorrectedChannelChangeListTrait for CorrectedChannelChangeList {
}

pub static CORRECTEDCHANNELCHANGELIST_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CorrectedChannelChangeList",
    flags: MemberInfoFlags::new(73),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CorrectedChannelChangeList as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(CORRECTEDCHANNELCHANGELIST_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CorrectedChannelChangeList {
    fn type_info(&self) -> &'static TypeInfo {
        CORRECTEDCHANNELCHANGELIST_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CORRECTEDCHANNELCHANGELIST_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CorrectedChannelChangeList-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("CorrectedChannelChangeList"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CorrectedChannelChange {
    pub common: CorrectedChannelChangeCommon,
}

pub trait CorrectedChannelChangeTrait: TypeObject {
    fn common(&self) -> &CorrectedChannelChangeCommon;
    fn common_mut(&mut self) -> &mut CorrectedChannelChangeCommon;
}

impl CorrectedChannelChangeTrait for CorrectedChannelChange {
    fn common(&self) -> &CorrectedChannelChangeCommon {
        &self.common
    }
    fn common_mut(&mut self) -> &mut CorrectedChannelChangeCommon {
        &mut self.common
    }
}

pub static CORRECTEDCHANNELCHANGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CorrectedChannelChange",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CorrectedChannelChange as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Common",
                flags: MemberInfoFlags::new(0),
                field_type: "CorrectedChannelChangeCommon",
                rust_offset: offset_of!(CorrectedChannelChange, common),
            },
        ],
    }),
    array_type: Some(CORRECTEDCHANNELCHANGE_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CorrectedChannelChange {
    fn type_info(&self) -> &'static TypeInfo {
        CORRECTEDCHANNELCHANGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CORRECTEDCHANNELCHANGE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CorrectedChannelChange-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("CorrectedChannelChange"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CorrectedVec3ChannelChange {
    pub value: super::core::Vec3,
    pub reset_value: super::core::Vec3,
    pub reset: bool,
}

pub trait CorrectedVec3ChannelChangeTrait: TypeObject {
    fn value(&self) -> &super::core::Vec3;
    fn value_mut(&mut self) -> &mut super::core::Vec3;
    fn reset_value(&self) -> &super::core::Vec3;
    fn reset_value_mut(&mut self) -> &mut super::core::Vec3;
    fn reset(&self) -> &bool;
    fn reset_mut(&mut self) -> &mut bool;
}

impl CorrectedVec3ChannelChangeTrait for CorrectedVec3ChannelChange {
    fn value(&self) -> &super::core::Vec3 {
        &self.value
    }
    fn value_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.value
    }
    fn reset_value(&self) -> &super::core::Vec3 {
        &self.reset_value
    }
    fn reset_value_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.reset_value
    }
    fn reset(&self) -> &bool {
        &self.reset
    }
    fn reset_mut(&mut self) -> &mut bool {
        &mut self.reset
    }
}

pub static CORRECTEDVEC3CHANNELCHANGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CorrectedVec3ChannelChange",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CorrectedVec3ChannelChange as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(CorrectedVec3ChannelChange, value),
            },
            FieldInfoData {
                name: "ResetValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(CorrectedVec3ChannelChange, reset_value),
            },
            FieldInfoData {
                name: "Reset",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CorrectedVec3ChannelChange, reset),
            },
        ],
    }),
    array_type: Some(CORRECTEDVEC3CHANNELCHANGE_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CorrectedVec3ChannelChange {
    fn type_info(&self) -> &'static TypeInfo {
        CORRECTEDVEC3CHANNELCHANGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CORRECTEDVEC3CHANNELCHANGE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CorrectedVec3ChannelChange-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("CorrectedVec3ChannelChange"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CorrectedFloatChannelChange {
    pub value: f32,
    pub reset_value: f32,
    pub reset: bool,
}

pub trait CorrectedFloatChannelChangeTrait: TypeObject {
    fn value(&self) -> &f32;
    fn value_mut(&mut self) -> &mut f32;
    fn reset_value(&self) -> &f32;
    fn reset_value_mut(&mut self) -> &mut f32;
    fn reset(&self) -> &bool;
    fn reset_mut(&mut self) -> &mut bool;
}

impl CorrectedFloatChannelChangeTrait for CorrectedFloatChannelChange {
    fn value(&self) -> &f32 {
        &self.value
    }
    fn value_mut(&mut self) -> &mut f32 {
        &mut self.value
    }
    fn reset_value(&self) -> &f32 {
        &self.reset_value
    }
    fn reset_value_mut(&mut self) -> &mut f32 {
        &mut self.reset_value
    }
    fn reset(&self) -> &bool {
        &self.reset
    }
    fn reset_mut(&mut self) -> &mut bool {
        &mut self.reset
    }
}

pub static CORRECTEDFLOATCHANNELCHANGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CorrectedFloatChannelChange",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CorrectedFloatChannelChange as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CorrectedFloatChannelChange, value),
            },
            FieldInfoData {
                name: "ResetValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CorrectedFloatChannelChange, reset_value),
            },
            FieldInfoData {
                name: "Reset",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CorrectedFloatChannelChange, reset),
            },
        ],
    }),
    array_type: Some(CORRECTEDFLOATCHANNELCHANGE_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for CorrectedFloatChannelChange {
    fn type_info(&self) -> &'static TypeInfo {
        CORRECTEDFLOATCHANNELCHANGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CORRECTEDFLOATCHANNELCHANGE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CorrectedFloatChannelChange-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("CorrectedFloatChannelChange"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CorrectedIntChannelChange {
    pub value: i32,
    pub reset_value: i32,
    pub reset: bool,
}

pub trait CorrectedIntChannelChangeTrait: TypeObject {
    fn value(&self) -> &i32;
    fn value_mut(&mut self) -> &mut i32;
    fn reset_value(&self) -> &i32;
    fn reset_value_mut(&mut self) -> &mut i32;
    fn reset(&self) -> &bool;
    fn reset_mut(&mut self) -> &mut bool;
}

impl CorrectedIntChannelChangeTrait for CorrectedIntChannelChange {
    fn value(&self) -> &i32 {
        &self.value
    }
    fn value_mut(&mut self) -> &mut i32 {
        &mut self.value
    }
    fn reset_value(&self) -> &i32 {
        &self.reset_value
    }
    fn reset_value_mut(&mut self) -> &mut i32 {
        &mut self.reset_value
    }
    fn reset(&self) -> &bool {
        &self.reset
    }
    fn reset_mut(&mut self) -> &mut bool {
        &mut self.reset
    }
}

pub static CORRECTEDINTCHANNELCHANGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CorrectedIntChannelChange",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CorrectedIntChannelChange as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CorrectedIntChannelChange, value),
            },
            FieldInfoData {
                name: "ResetValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CorrectedIntChannelChange, reset_value),
            },
            FieldInfoData {
                name: "Reset",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CorrectedIntChannelChange, reset),
            },
        ],
    }),
    array_type: Some(CORRECTEDINTCHANNELCHANGE_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for CorrectedIntChannelChange {
    fn type_info(&self) -> &'static TypeInfo {
        CORRECTEDINTCHANNELCHANGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CORRECTEDINTCHANNELCHANGE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CorrectedIntChannelChange-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("CorrectedIntChannelChange"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CorrectedBoolChannelChange {
    pub value: bool,
    pub reset: bool,
    pub reset_value: bool,
}

pub trait CorrectedBoolChannelChangeTrait: TypeObject {
    fn value(&self) -> &bool;
    fn value_mut(&mut self) -> &mut bool;
    fn reset(&self) -> &bool;
    fn reset_mut(&mut self) -> &mut bool;
    fn reset_value(&self) -> &bool;
    fn reset_value_mut(&mut self) -> &mut bool;
}

impl CorrectedBoolChannelChangeTrait for CorrectedBoolChannelChange {
    fn value(&self) -> &bool {
        &self.value
    }
    fn value_mut(&mut self) -> &mut bool {
        &mut self.value
    }
    fn reset(&self) -> &bool {
        &self.reset
    }
    fn reset_mut(&mut self) -> &mut bool {
        &mut self.reset
    }
    fn reset_value(&self) -> &bool {
        &self.reset_value
    }
    fn reset_value_mut(&mut self) -> &mut bool {
        &mut self.reset_value
    }
}

pub static CORRECTEDBOOLCHANNELCHANGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CorrectedBoolChannelChange",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CorrectedBoolChannelChange as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CorrectedBoolChannelChange, value),
            },
            FieldInfoData {
                name: "Reset",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CorrectedBoolChannelChange, reset),
            },
            FieldInfoData {
                name: "ResetValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CorrectedBoolChannelChange, reset_value),
            },
        ],
    }),
    array_type: Some(CORRECTEDBOOLCHANNELCHANGE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CorrectedBoolChannelChange {
    fn type_info(&self) -> &'static TypeInfo {
        CORRECTEDBOOLCHANNELCHANGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CORRECTEDBOOLCHANNELCHANGE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CorrectedBoolChannelChange-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("CorrectedBoolChannelChange"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CorrectedTransformChannelChange {
    pub value: super::core::LinearTransform,
}

pub trait CorrectedTransformChannelChangeTrait: TypeObject {
    fn value(&self) -> &super::core::LinearTransform;
    fn value_mut(&mut self) -> &mut super::core::LinearTransform;
}

impl CorrectedTransformChannelChangeTrait for CorrectedTransformChannelChange {
    fn value(&self) -> &super::core::LinearTransform {
        &self.value
    }
    fn value_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.value
    }
}

pub static CORRECTEDTRANSFORMCHANNELCHANGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CorrectedTransformChannelChange",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CorrectedTransformChannelChange as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(CorrectedTransformChannelChange, value),
            },
        ],
    }),
    array_type: Some(CORRECTEDTRANSFORMCHANNELCHANGE_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CorrectedTransformChannelChange {
    fn type_info(&self) -> &'static TypeInfo {
        CORRECTEDTRANSFORMCHANNELCHANGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CORRECTEDTRANSFORMCHANNELCHANGE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CorrectedTransformChannelChange-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("CorrectedTransformChannelChange"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CorrectedInteractionTransformChange {
    pub have_target: bool,
    pub rotation: super::core::Quat,
    pub translation: super::core::Vec3,
}

pub trait CorrectedInteractionTransformChangeTrait: TypeObject {
    fn have_target(&self) -> &bool;
    fn have_target_mut(&mut self) -> &mut bool;
    fn rotation(&self) -> &super::core::Quat;
    fn rotation_mut(&mut self) -> &mut super::core::Quat;
    fn translation(&self) -> &super::core::Vec3;
    fn translation_mut(&mut self) -> &mut super::core::Vec3;
}

impl CorrectedInteractionTransformChangeTrait for CorrectedInteractionTransformChange {
    fn have_target(&self) -> &bool {
        &self.have_target
    }
    fn have_target_mut(&mut self) -> &mut bool {
        &mut self.have_target
    }
    fn rotation(&self) -> &super::core::Quat {
        &self.rotation
    }
    fn rotation_mut(&mut self) -> &mut super::core::Quat {
        &mut self.rotation
    }
    fn translation(&self) -> &super::core::Vec3 {
        &self.translation
    }
    fn translation_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.translation
    }
}

pub static CORRECTEDINTERACTIONTRANSFORMCHANGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CorrectedInteractionTransformChange",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CorrectedInteractionTransformChange as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "HaveTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CorrectedInteractionTransformChange, have_target),
            },
            FieldInfoData {
                name: "Rotation",
                flags: MemberInfoFlags::new(0),
                field_type: "Quat",
                rust_offset: offset_of!(CorrectedInteractionTransformChange, rotation),
            },
            FieldInfoData {
                name: "Translation",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(CorrectedInteractionTransformChange, translation),
            },
        ],
    }),
    array_type: Some(CORRECTEDINTERACTIONTRANSFORMCHANGE_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CorrectedInteractionTransformChange {
    fn type_info(&self) -> &'static TypeInfo {
        CORRECTEDINTERACTIONTRANSFORMCHANGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CORRECTEDINTERACTIONTRANSFORMCHANGE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CorrectedInteractionTransformChange-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("CorrectedInteractionTransformChange"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CorrectedChannelChangeCommon {
    pub tick_to_apply: u32,
    pub length: u32,
    pub hash: u32,
}

pub trait CorrectedChannelChangeCommonTrait: TypeObject {
    fn tick_to_apply(&self) -> &u32;
    fn tick_to_apply_mut(&mut self) -> &mut u32;
    fn length(&self) -> &u32;
    fn length_mut(&mut self) -> &mut u32;
    fn hash(&self) -> &u32;
    fn hash_mut(&mut self) -> &mut u32;
}

impl CorrectedChannelChangeCommonTrait for CorrectedChannelChangeCommon {
    fn tick_to_apply(&self) -> &u32 {
        &self.tick_to_apply
    }
    fn tick_to_apply_mut(&mut self) -> &mut u32 {
        &mut self.tick_to_apply
    }
    fn length(&self) -> &u32 {
        &self.length
    }
    fn length_mut(&mut self) -> &mut u32 {
        &mut self.length
    }
    fn hash(&self) -> &u32 {
        &self.hash
    }
    fn hash_mut(&mut self) -> &mut u32 {
        &mut self.hash
    }
}

pub static CORRECTEDCHANNELCHANGECOMMON_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CorrectedChannelChangeCommon",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CorrectedChannelChangeCommon as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "TickToApply",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(CorrectedChannelChangeCommon, tick_to_apply),
            },
            FieldInfoData {
                name: "Length",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(CorrectedChannelChangeCommon, length),
            },
            FieldInfoData {
                name: "Hash",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(CorrectedChannelChangeCommon, hash),
            },
        ],
    }),
    array_type: Some(CORRECTEDCHANNELCHANGECOMMON_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for CorrectedChannelChangeCommon {
    fn type_info(&self) -> &'static TypeInfo {
        CORRECTEDCHANNELCHANGECOMMON_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CORRECTEDCHANNELCHANGECOMMON_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CorrectedChannelChangeCommon-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("CorrectedChannelChangeCommon"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateAndRequiredData {
    pub _glacier_base: CharacterStateRequiredChannelValueData,
    pub and_values: Vec<Option<Arc<Mutex<dyn CharacterStateRequiredChannelValueDataTrait>>>>,
}

pub trait CharacterStateAndRequiredDataTrait: CharacterStateRequiredChannelValueDataTrait {
    fn and_values(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateRequiredChannelValueDataTrait>>>>;
    fn and_values_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn CharacterStateRequiredChannelValueDataTrait>>>>;
}

impl CharacterStateAndRequiredDataTrait for CharacterStateAndRequiredData {
    fn and_values(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateRequiredChannelValueDataTrait>>>> {
        &self.and_values
    }
    fn and_values_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn CharacterStateRequiredChannelValueDataTrait>>>> {
        &mut self.and_values
    }
}

impl CharacterStateRequiredChannelValueDataTrait for CharacterStateAndRequiredData {
    fn invert_conditions(&self) -> &bool {
        self._glacier_base.invert_conditions()
    }
    fn invert_conditions_mut(&mut self) -> &mut bool {
        self._glacier_base.invert_conditions_mut()
    }
}

impl super::core::DataContainerTrait for CharacterStateAndRequiredData {
}

pub static CHARACTERSTATEANDREQUIREDDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateAndRequiredData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEREQUIREDCHANNELVALUEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateAndRequiredData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AndValues",
                flags: MemberInfoFlags::new(144),
                field_type: "CharacterStateRequiredChannelValueData-Array",
                rust_offset: offset_of!(CharacterStateAndRequiredData, and_values),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEANDREQUIREDDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateAndRequiredData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEANDREQUIREDDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERSTATEANDREQUIREDDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateAndRequiredData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("CharacterStateAndRequiredData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateOrRequiredData {
    pub _glacier_base: CharacterStateRequiredChannelValueData,
    pub or_values: Vec<Option<Arc<Mutex<dyn CharacterStateRequiredChannelValueDataTrait>>>>,
}

pub trait CharacterStateOrRequiredDataTrait: CharacterStateRequiredChannelValueDataTrait {
    fn or_values(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateRequiredChannelValueDataTrait>>>>;
    fn or_values_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn CharacterStateRequiredChannelValueDataTrait>>>>;
}

impl CharacterStateOrRequiredDataTrait for CharacterStateOrRequiredData {
    fn or_values(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateRequiredChannelValueDataTrait>>>> {
        &self.or_values
    }
    fn or_values_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn CharacterStateRequiredChannelValueDataTrait>>>> {
        &mut self.or_values
    }
}

impl CharacterStateRequiredChannelValueDataTrait for CharacterStateOrRequiredData {
    fn invert_conditions(&self) -> &bool {
        self._glacier_base.invert_conditions()
    }
    fn invert_conditions_mut(&mut self) -> &mut bool {
        self._glacier_base.invert_conditions_mut()
    }
}

impl super::core::DataContainerTrait for CharacterStateOrRequiredData {
}

pub static CHARACTERSTATEORREQUIREDDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateOrRequiredData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEREQUIREDCHANNELVALUEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateOrRequiredData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "OrValues",
                flags: MemberInfoFlags::new(144),
                field_type: "CharacterStateRequiredChannelValueData-Array",
                rust_offset: offset_of!(CharacterStateOrRequiredData, or_values),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEORREQUIREDDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateOrRequiredData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEORREQUIREDDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERSTATEORREQUIREDDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateOrRequiredData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("CharacterStateOrRequiredData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateFloatRequiredChannelValueData {
    pub _glacier_base: CharacterStateRequiredChannelValueData,
    pub channel: Option<Arc<Mutex<dyn CharacterStatePublicFloatChannelDataTrait>>>,
    pub allowed_values: Vec<f32>,
}

pub trait CharacterStateFloatRequiredChannelValueDataTrait: CharacterStateRequiredChannelValueDataTrait {
    fn channel(&self) -> &Option<Arc<Mutex<dyn CharacterStatePublicFloatChannelDataTrait>>>;
    fn channel_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CharacterStatePublicFloatChannelDataTrait>>>;
    fn allowed_values(&self) -> &Vec<f32>;
    fn allowed_values_mut(&mut self) -> &mut Vec<f32>;
}

impl CharacterStateFloatRequiredChannelValueDataTrait for CharacterStateFloatRequiredChannelValueData {
    fn channel(&self) -> &Option<Arc<Mutex<dyn CharacterStatePublicFloatChannelDataTrait>>> {
        &self.channel
    }
    fn channel_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CharacterStatePublicFloatChannelDataTrait>>> {
        &mut self.channel
    }
    fn allowed_values(&self) -> &Vec<f32> {
        &self.allowed_values
    }
    fn allowed_values_mut(&mut self) -> &mut Vec<f32> {
        &mut self.allowed_values
    }
}

impl CharacterStateRequiredChannelValueDataTrait for CharacterStateFloatRequiredChannelValueData {
    fn invert_conditions(&self) -> &bool {
        self._glacier_base.invert_conditions()
    }
    fn invert_conditions_mut(&mut self) -> &mut bool {
        self._glacier_base.invert_conditions_mut()
    }
}

impl super::core::DataContainerTrait for CharacterStateFloatRequiredChannelValueData {
}

pub static CHARACTERSTATEFLOATREQUIREDCHANNELVALUEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateFloatRequiredChannelValueData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEREQUIREDCHANNELVALUEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateFloatRequiredChannelValueData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Channel",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterStatePublicFloatChannelData",
                rust_offset: offset_of!(CharacterStateFloatRequiredChannelValueData, channel),
            },
            FieldInfoData {
                name: "AllowedValues",
                flags: MemberInfoFlags::new(144),
                field_type: "Float32-Array",
                rust_offset: offset_of!(CharacterStateFloatRequiredChannelValueData, allowed_values),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEFLOATREQUIREDCHANNELVALUEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateFloatRequiredChannelValueData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEFLOATREQUIREDCHANNELVALUEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERSTATEFLOATREQUIREDCHANNELVALUEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateFloatRequiredChannelValueData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("CharacterStateFloatRequiredChannelValueData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateIntRequiredChannelValueData {
    pub _glacier_base: CharacterStateRequiredChannelValueData,
    pub channel: Option<Arc<Mutex<dyn CharacterStatePublicIntChannelDataTrait>>>,
    pub allowed_values: Vec<i32>,
}

pub trait CharacterStateIntRequiredChannelValueDataTrait: CharacterStateRequiredChannelValueDataTrait {
    fn channel(&self) -> &Option<Arc<Mutex<dyn CharacterStatePublicIntChannelDataTrait>>>;
    fn channel_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CharacterStatePublicIntChannelDataTrait>>>;
    fn allowed_values(&self) -> &Vec<i32>;
    fn allowed_values_mut(&mut self) -> &mut Vec<i32>;
}

impl CharacterStateIntRequiredChannelValueDataTrait for CharacterStateIntRequiredChannelValueData {
    fn channel(&self) -> &Option<Arc<Mutex<dyn CharacterStatePublicIntChannelDataTrait>>> {
        &self.channel
    }
    fn channel_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CharacterStatePublicIntChannelDataTrait>>> {
        &mut self.channel
    }
    fn allowed_values(&self) -> &Vec<i32> {
        &self.allowed_values
    }
    fn allowed_values_mut(&mut self) -> &mut Vec<i32> {
        &mut self.allowed_values
    }
}

impl CharacterStateRequiredChannelValueDataTrait for CharacterStateIntRequiredChannelValueData {
    fn invert_conditions(&self) -> &bool {
        self._glacier_base.invert_conditions()
    }
    fn invert_conditions_mut(&mut self) -> &mut bool {
        self._glacier_base.invert_conditions_mut()
    }
}

impl super::core::DataContainerTrait for CharacterStateIntRequiredChannelValueData {
}

pub static CHARACTERSTATEINTREQUIREDCHANNELVALUEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateIntRequiredChannelValueData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEREQUIREDCHANNELVALUEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateIntRequiredChannelValueData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Channel",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterStatePublicIntChannelData",
                rust_offset: offset_of!(CharacterStateIntRequiredChannelValueData, channel),
            },
            FieldInfoData {
                name: "AllowedValues",
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(CharacterStateIntRequiredChannelValueData, allowed_values),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEINTREQUIREDCHANNELVALUEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateIntRequiredChannelValueData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEINTREQUIREDCHANNELVALUEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERSTATEINTREQUIREDCHANNELVALUEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateIntRequiredChannelValueData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("CharacterStateIntRequiredChannelValueData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateBoolRequiredChannelValueData {
    pub _glacier_base: CharacterStateRequiredChannelValueData,
    pub channel: Option<Arc<Mutex<dyn CharacterStatePublicBoolChannelDataTrait>>>,
    pub allowed_values: Vec<bool>,
}

pub trait CharacterStateBoolRequiredChannelValueDataTrait: CharacterStateRequiredChannelValueDataTrait {
    fn channel(&self) -> &Option<Arc<Mutex<dyn CharacterStatePublicBoolChannelDataTrait>>>;
    fn channel_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CharacterStatePublicBoolChannelDataTrait>>>;
    fn allowed_values(&self) -> &Vec<bool>;
    fn allowed_values_mut(&mut self) -> &mut Vec<bool>;
}

impl CharacterStateBoolRequiredChannelValueDataTrait for CharacterStateBoolRequiredChannelValueData {
    fn channel(&self) -> &Option<Arc<Mutex<dyn CharacterStatePublicBoolChannelDataTrait>>> {
        &self.channel
    }
    fn channel_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CharacterStatePublicBoolChannelDataTrait>>> {
        &mut self.channel
    }
    fn allowed_values(&self) -> &Vec<bool> {
        &self.allowed_values
    }
    fn allowed_values_mut(&mut self) -> &mut Vec<bool> {
        &mut self.allowed_values
    }
}

impl CharacterStateRequiredChannelValueDataTrait for CharacterStateBoolRequiredChannelValueData {
    fn invert_conditions(&self) -> &bool {
        self._glacier_base.invert_conditions()
    }
    fn invert_conditions_mut(&mut self) -> &mut bool {
        self._glacier_base.invert_conditions_mut()
    }
}

impl super::core::DataContainerTrait for CharacterStateBoolRequiredChannelValueData {
}

pub static CHARACTERSTATEBOOLREQUIREDCHANNELVALUEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateBoolRequiredChannelValueData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEREQUIREDCHANNELVALUEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateBoolRequiredChannelValueData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Channel",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterStatePublicBoolChannelData",
                rust_offset: offset_of!(CharacterStateBoolRequiredChannelValueData, channel),
            },
            FieldInfoData {
                name: "AllowedValues",
                flags: MemberInfoFlags::new(144),
                field_type: "Boolean-Array",
                rust_offset: offset_of!(CharacterStateBoolRequiredChannelValueData, allowed_values),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEBOOLREQUIREDCHANNELVALUEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateBoolRequiredChannelValueData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEBOOLREQUIREDCHANNELVALUEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERSTATEBOOLREQUIREDCHANNELVALUEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateBoolRequiredChannelValueData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("CharacterStateBoolRequiredChannelValueData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateRequiredChannelValueData {
    pub _glacier_base: super::core::DataContainer,
    pub invert_conditions: bool,
}

pub trait CharacterStateRequiredChannelValueDataTrait: super::core::DataContainerTrait {
    fn invert_conditions(&self) -> &bool;
    fn invert_conditions_mut(&mut self) -> &mut bool;
}

impl CharacterStateRequiredChannelValueDataTrait for CharacterStateRequiredChannelValueData {
    fn invert_conditions(&self) -> &bool {
        &self.invert_conditions
    }
    fn invert_conditions_mut(&mut self) -> &mut bool {
        &mut self.invert_conditions
    }
}

impl super::core::DataContainerTrait for CharacterStateRequiredChannelValueData {
}

pub static CHARACTERSTATEREQUIREDCHANNELVALUEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateRequiredChannelValueData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateRequiredChannelValueData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "InvertConditions",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateRequiredChannelValueData, invert_conditions),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEREQUIREDCHANNELVALUEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateRequiredChannelValueData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEREQUIREDCHANNELVALUEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERSTATEREQUIREDCHANNELVALUEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateRequiredChannelValueData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("CharacterStateRequiredChannelValueData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStatePublicChannelMappingTable {
    pub bool_channel_mappings: Vec<Option<Arc<Mutex<dyn CharacterStatePublicBoolChannelMappingTrait>>>>,
    pub int_channel_mappings: Vec<Option<Arc<Mutex<dyn CharacterStatePublicIntChannelMappingTrait>>>>,
    pub float_channel_mappings: Vec<Option<Arc<Mutex<dyn CharacterStatePublicFloatChannelMappingTrait>>>>,
    pub vec3_channel_mappings: Vec<Option<Arc<Mutex<dyn CharacterStatePublicVec3ChannelMappingTrait>>>>,
    pub transform_channel_mappings: Vec<Option<Arc<Mutex<dyn CharacterStatePublicTransformChannelMappingTrait>>>>,
}

pub trait CharacterStatePublicChannelMappingTableTrait: TypeObject {
    fn bool_channel_mappings(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStatePublicBoolChannelMappingTrait>>>>;
    fn bool_channel_mappings_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn CharacterStatePublicBoolChannelMappingTrait>>>>;
    fn int_channel_mappings(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStatePublicIntChannelMappingTrait>>>>;
    fn int_channel_mappings_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn CharacterStatePublicIntChannelMappingTrait>>>>;
    fn float_channel_mappings(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStatePublicFloatChannelMappingTrait>>>>;
    fn float_channel_mappings_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn CharacterStatePublicFloatChannelMappingTrait>>>>;
    fn vec3_channel_mappings(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStatePublicVec3ChannelMappingTrait>>>>;
    fn vec3_channel_mappings_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn CharacterStatePublicVec3ChannelMappingTrait>>>>;
    fn transform_channel_mappings(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStatePublicTransformChannelMappingTrait>>>>;
    fn transform_channel_mappings_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn CharacterStatePublicTransformChannelMappingTrait>>>>;
}

impl CharacterStatePublicChannelMappingTableTrait for CharacterStatePublicChannelMappingTable {
    fn bool_channel_mappings(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStatePublicBoolChannelMappingTrait>>>> {
        &self.bool_channel_mappings
    }
    fn bool_channel_mappings_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn CharacterStatePublicBoolChannelMappingTrait>>>> {
        &mut self.bool_channel_mappings
    }
    fn int_channel_mappings(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStatePublicIntChannelMappingTrait>>>> {
        &self.int_channel_mappings
    }
    fn int_channel_mappings_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn CharacterStatePublicIntChannelMappingTrait>>>> {
        &mut self.int_channel_mappings
    }
    fn float_channel_mappings(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStatePublicFloatChannelMappingTrait>>>> {
        &self.float_channel_mappings
    }
    fn float_channel_mappings_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn CharacterStatePublicFloatChannelMappingTrait>>>> {
        &mut self.float_channel_mappings
    }
    fn vec3_channel_mappings(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStatePublicVec3ChannelMappingTrait>>>> {
        &self.vec3_channel_mappings
    }
    fn vec3_channel_mappings_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn CharacterStatePublicVec3ChannelMappingTrait>>>> {
        &mut self.vec3_channel_mappings
    }
    fn transform_channel_mappings(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStatePublicTransformChannelMappingTrait>>>> {
        &self.transform_channel_mappings
    }
    fn transform_channel_mappings_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn CharacterStatePublicTransformChannelMappingTrait>>>> {
        &mut self.transform_channel_mappings
    }
}

pub static CHARACTERSTATEPUBLICCHANNELMAPPINGTABLE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStatePublicChannelMappingTable",
    flags: MemberInfoFlags::new(73),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStatePublicChannelMappingTable as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "BoolChannelMappings",
                flags: MemberInfoFlags::new(144),
                field_type: "CharacterStatePublicBoolChannelMapping-Array",
                rust_offset: offset_of!(CharacterStatePublicChannelMappingTable, bool_channel_mappings),
            },
            FieldInfoData {
                name: "IntChannelMappings",
                flags: MemberInfoFlags::new(144),
                field_type: "CharacterStatePublicIntChannelMapping-Array",
                rust_offset: offset_of!(CharacterStatePublicChannelMappingTable, int_channel_mappings),
            },
            FieldInfoData {
                name: "FloatChannelMappings",
                flags: MemberInfoFlags::new(144),
                field_type: "CharacterStatePublicFloatChannelMapping-Array",
                rust_offset: offset_of!(CharacterStatePublicChannelMappingTable, float_channel_mappings),
            },
            FieldInfoData {
                name: "Vec3ChannelMappings",
                flags: MemberInfoFlags::new(144),
                field_type: "CharacterStatePublicVec3ChannelMapping-Array",
                rust_offset: offset_of!(CharacterStatePublicChannelMappingTable, vec3_channel_mappings),
            },
            FieldInfoData {
                name: "TransformChannelMappings",
                flags: MemberInfoFlags::new(144),
                field_type: "CharacterStatePublicTransformChannelMapping-Array",
                rust_offset: offset_of!(CharacterStatePublicChannelMappingTable, transform_channel_mappings),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEPUBLICCHANNELMAPPINGTABLE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStatePublicChannelMappingTable {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEPUBLICCHANNELMAPPINGTABLE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CHARACTERSTATEPUBLICCHANNELMAPPINGTABLE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStatePublicChannelMappingTable-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("CharacterStatePublicChannelMappingTable"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStatePublicVec3ChannelMapping {
    pub _glacier_base: CharacterStatePublicChannelMapping,
    pub public_channel: Option<Arc<Mutex<dyn CharacterStatePublicVec3ChannelDataTrait>>>,
    pub channel: Option<Arc<Mutex<dyn Vec3ChannelDataTrait>>>,
}

pub trait CharacterStatePublicVec3ChannelMappingTrait: CharacterStatePublicChannelMappingTrait {
    fn public_channel(&self) -> &Option<Arc<Mutex<dyn CharacterStatePublicVec3ChannelDataTrait>>>;
    fn public_channel_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CharacterStatePublicVec3ChannelDataTrait>>>;
    fn channel(&self) -> &Option<Arc<Mutex<dyn Vec3ChannelDataTrait>>>;
    fn channel_mut(&mut self) -> &mut Option<Arc<Mutex<dyn Vec3ChannelDataTrait>>>;
}

impl CharacterStatePublicVec3ChannelMappingTrait for CharacterStatePublicVec3ChannelMapping {
    fn public_channel(&self) -> &Option<Arc<Mutex<dyn CharacterStatePublicVec3ChannelDataTrait>>> {
        &self.public_channel
    }
    fn public_channel_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CharacterStatePublicVec3ChannelDataTrait>>> {
        &mut self.public_channel
    }
    fn channel(&self) -> &Option<Arc<Mutex<dyn Vec3ChannelDataTrait>>> {
        &self.channel
    }
    fn channel_mut(&mut self) -> &mut Option<Arc<Mutex<dyn Vec3ChannelDataTrait>>> {
        &mut self.channel
    }
}

impl CharacterStatePublicChannelMappingTrait for CharacterStatePublicVec3ChannelMapping {
}

impl super::core::DataContainerTrait for CharacterStatePublicVec3ChannelMapping {
}

pub static CHARACTERSTATEPUBLICVEC3CHANNELMAPPING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStatePublicVec3ChannelMapping",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEPUBLICCHANNELMAPPING_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStatePublicVec3ChannelMapping as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PublicChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterStatePublicVec3ChannelData",
                rust_offset: offset_of!(CharacterStatePublicVec3ChannelMapping, public_channel),
            },
            FieldInfoData {
                name: "Channel",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStatePublicVec3ChannelMapping, channel),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEPUBLICVEC3CHANNELMAPPING_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStatePublicVec3ChannelMapping {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEPUBLICVEC3CHANNELMAPPING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERSTATEPUBLICVEC3CHANNELMAPPING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStatePublicVec3ChannelMapping-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("CharacterStatePublicVec3ChannelMapping"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStatePublicBoolChannelMapping {
    pub _glacier_base: CharacterStatePublicChannelMapping,
    pub public_channel: Option<Arc<Mutex<dyn CharacterStatePublicBoolChannelDataTrait>>>,
    pub channel: Option<Arc<Mutex<dyn BoolChannelDataTrait>>>,
}

pub trait CharacterStatePublicBoolChannelMappingTrait: CharacterStatePublicChannelMappingTrait {
    fn public_channel(&self) -> &Option<Arc<Mutex<dyn CharacterStatePublicBoolChannelDataTrait>>>;
    fn public_channel_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CharacterStatePublicBoolChannelDataTrait>>>;
    fn channel(&self) -> &Option<Arc<Mutex<dyn BoolChannelDataTrait>>>;
    fn channel_mut(&mut self) -> &mut Option<Arc<Mutex<dyn BoolChannelDataTrait>>>;
}

impl CharacterStatePublicBoolChannelMappingTrait for CharacterStatePublicBoolChannelMapping {
    fn public_channel(&self) -> &Option<Arc<Mutex<dyn CharacterStatePublicBoolChannelDataTrait>>> {
        &self.public_channel
    }
    fn public_channel_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CharacterStatePublicBoolChannelDataTrait>>> {
        &mut self.public_channel
    }
    fn channel(&self) -> &Option<Arc<Mutex<dyn BoolChannelDataTrait>>> {
        &self.channel
    }
    fn channel_mut(&mut self) -> &mut Option<Arc<Mutex<dyn BoolChannelDataTrait>>> {
        &mut self.channel
    }
}

impl CharacterStatePublicChannelMappingTrait for CharacterStatePublicBoolChannelMapping {
}

impl super::core::DataContainerTrait for CharacterStatePublicBoolChannelMapping {
}

pub static CHARACTERSTATEPUBLICBOOLCHANNELMAPPING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStatePublicBoolChannelMapping",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEPUBLICCHANNELMAPPING_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStatePublicBoolChannelMapping as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PublicChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterStatePublicBoolChannelData",
                rust_offset: offset_of!(CharacterStatePublicBoolChannelMapping, public_channel),
            },
            FieldInfoData {
                name: "Channel",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(CharacterStatePublicBoolChannelMapping, channel),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEPUBLICBOOLCHANNELMAPPING_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStatePublicBoolChannelMapping {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEPUBLICBOOLCHANNELMAPPING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERSTATEPUBLICBOOLCHANNELMAPPING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStatePublicBoolChannelMapping-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("CharacterStatePublicBoolChannelMapping"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStatePublicIntChannelMapping {
    pub _glacier_base: CharacterStatePublicChannelMapping,
    pub public_channel: Option<Arc<Mutex<dyn CharacterStatePublicIntChannelDataTrait>>>,
    pub channel: Option<Arc<Mutex<dyn IntChannelDataTrait>>>,
}

pub trait CharacterStatePublicIntChannelMappingTrait: CharacterStatePublicChannelMappingTrait {
    fn public_channel(&self) -> &Option<Arc<Mutex<dyn CharacterStatePublicIntChannelDataTrait>>>;
    fn public_channel_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CharacterStatePublicIntChannelDataTrait>>>;
    fn channel(&self) -> &Option<Arc<Mutex<dyn IntChannelDataTrait>>>;
    fn channel_mut(&mut self) -> &mut Option<Arc<Mutex<dyn IntChannelDataTrait>>>;
}

impl CharacterStatePublicIntChannelMappingTrait for CharacterStatePublicIntChannelMapping {
    fn public_channel(&self) -> &Option<Arc<Mutex<dyn CharacterStatePublicIntChannelDataTrait>>> {
        &self.public_channel
    }
    fn public_channel_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CharacterStatePublicIntChannelDataTrait>>> {
        &mut self.public_channel
    }
    fn channel(&self) -> &Option<Arc<Mutex<dyn IntChannelDataTrait>>> {
        &self.channel
    }
    fn channel_mut(&mut self) -> &mut Option<Arc<Mutex<dyn IntChannelDataTrait>>> {
        &mut self.channel
    }
}

impl CharacterStatePublicChannelMappingTrait for CharacterStatePublicIntChannelMapping {
}

impl super::core::DataContainerTrait for CharacterStatePublicIntChannelMapping {
}

pub static CHARACTERSTATEPUBLICINTCHANNELMAPPING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStatePublicIntChannelMapping",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEPUBLICCHANNELMAPPING_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStatePublicIntChannelMapping as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PublicChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterStatePublicIntChannelData",
                rust_offset: offset_of!(CharacterStatePublicIntChannelMapping, public_channel),
            },
            FieldInfoData {
                name: "Channel",
                flags: MemberInfoFlags::new(0),
                field_type: "IntChannelData",
                rust_offset: offset_of!(CharacterStatePublicIntChannelMapping, channel),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEPUBLICINTCHANNELMAPPING_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStatePublicIntChannelMapping {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEPUBLICINTCHANNELMAPPING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERSTATEPUBLICINTCHANNELMAPPING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStatePublicIntChannelMapping-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("CharacterStatePublicIntChannelMapping"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStatePublicFloatChannelMapping {
    pub _glacier_base: CharacterStatePublicChannelMapping,
    pub public_channel: Option<Arc<Mutex<dyn CharacterStatePublicFloatChannelDataTrait>>>,
    pub channel: Option<Arc<Mutex<dyn FloatChannelDataTrait>>>,
}

pub trait CharacterStatePublicFloatChannelMappingTrait: CharacterStatePublicChannelMappingTrait {
    fn public_channel(&self) -> &Option<Arc<Mutex<dyn CharacterStatePublicFloatChannelDataTrait>>>;
    fn public_channel_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CharacterStatePublicFloatChannelDataTrait>>>;
    fn channel(&self) -> &Option<Arc<Mutex<dyn FloatChannelDataTrait>>>;
    fn channel_mut(&mut self) -> &mut Option<Arc<Mutex<dyn FloatChannelDataTrait>>>;
}

impl CharacterStatePublicFloatChannelMappingTrait for CharacterStatePublicFloatChannelMapping {
    fn public_channel(&self) -> &Option<Arc<Mutex<dyn CharacterStatePublicFloatChannelDataTrait>>> {
        &self.public_channel
    }
    fn public_channel_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CharacterStatePublicFloatChannelDataTrait>>> {
        &mut self.public_channel
    }
    fn channel(&self) -> &Option<Arc<Mutex<dyn FloatChannelDataTrait>>> {
        &self.channel
    }
    fn channel_mut(&mut self) -> &mut Option<Arc<Mutex<dyn FloatChannelDataTrait>>> {
        &mut self.channel
    }
}

impl CharacterStatePublicChannelMappingTrait for CharacterStatePublicFloatChannelMapping {
}

impl super::core::DataContainerTrait for CharacterStatePublicFloatChannelMapping {
}

pub static CHARACTERSTATEPUBLICFLOATCHANNELMAPPING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStatePublicFloatChannelMapping",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEPUBLICCHANNELMAPPING_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStatePublicFloatChannelMapping as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PublicChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterStatePublicFloatChannelData",
                rust_offset: offset_of!(CharacterStatePublicFloatChannelMapping, public_channel),
            },
            FieldInfoData {
                name: "Channel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStatePublicFloatChannelMapping, channel),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEPUBLICFLOATCHANNELMAPPING_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStatePublicFloatChannelMapping {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEPUBLICFLOATCHANNELMAPPING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERSTATEPUBLICFLOATCHANNELMAPPING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStatePublicFloatChannelMapping-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("CharacterStatePublicFloatChannelMapping"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStatePublicTransformChannelMapping {
    pub _glacier_base: CharacterStatePublicChannelMapping,
    pub public_channel: Option<Arc<Mutex<dyn CharacterStatePublicTransformChannelDataTrait>>>,
    pub channel: Option<Arc<Mutex<dyn TransformChannelDataTrait>>>,
}

pub trait CharacterStatePublicTransformChannelMappingTrait: CharacterStatePublicChannelMappingTrait {
    fn public_channel(&self) -> &Option<Arc<Mutex<dyn CharacterStatePublicTransformChannelDataTrait>>>;
    fn public_channel_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CharacterStatePublicTransformChannelDataTrait>>>;
    fn channel(&self) -> &Option<Arc<Mutex<dyn TransformChannelDataTrait>>>;
    fn channel_mut(&mut self) -> &mut Option<Arc<Mutex<dyn TransformChannelDataTrait>>>;
}

impl CharacterStatePublicTransformChannelMappingTrait for CharacterStatePublicTransformChannelMapping {
    fn public_channel(&self) -> &Option<Arc<Mutex<dyn CharacterStatePublicTransformChannelDataTrait>>> {
        &self.public_channel
    }
    fn public_channel_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CharacterStatePublicTransformChannelDataTrait>>> {
        &mut self.public_channel
    }
    fn channel(&self) -> &Option<Arc<Mutex<dyn TransformChannelDataTrait>>> {
        &self.channel
    }
    fn channel_mut(&mut self) -> &mut Option<Arc<Mutex<dyn TransformChannelDataTrait>>> {
        &mut self.channel
    }
}

impl CharacterStatePublicChannelMappingTrait for CharacterStatePublicTransformChannelMapping {
}

impl super::core::DataContainerTrait for CharacterStatePublicTransformChannelMapping {
}

pub static CHARACTERSTATEPUBLICTRANSFORMCHANNELMAPPING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStatePublicTransformChannelMapping",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEPUBLICCHANNELMAPPING_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStatePublicTransformChannelMapping as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PublicChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterStatePublicTransformChannelData",
                rust_offset: offset_of!(CharacterStatePublicTransformChannelMapping, public_channel),
            },
            FieldInfoData {
                name: "Channel",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(CharacterStatePublicTransformChannelMapping, channel),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEPUBLICTRANSFORMCHANNELMAPPING_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStatePublicTransformChannelMapping {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEPUBLICTRANSFORMCHANNELMAPPING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERSTATEPUBLICTRANSFORMCHANNELMAPPING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStatePublicTransformChannelMapping-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("CharacterStatePublicTransformChannelMapping"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStatePublicChannelMapping {
    pub _glacier_base: super::core::DataContainer,
}

pub trait CharacterStatePublicChannelMappingTrait: super::core::DataContainerTrait {
}

impl CharacterStatePublicChannelMappingTrait for CharacterStatePublicChannelMapping {
}

impl super::core::DataContainerTrait for CharacterStatePublicChannelMapping {
}

pub static CHARACTERSTATEPUBLICCHANNELMAPPING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStatePublicChannelMapping",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStatePublicChannelMapping as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(CHARACTERSTATEPUBLICCHANNELMAPPING_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStatePublicChannelMapping {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEPUBLICCHANNELMAPPING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERSTATEPUBLICCHANNELMAPPING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStatePublicChannelMapping-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("CharacterStatePublicChannelMapping"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStatePublicChannelListData {
    pub _glacier_base: super::core::DataContainerPolicyAsset,
    pub public_channels: Vec<Option<Arc<Mutex<dyn CharacterStatePublicChannelDataTrait>>>>,
}

pub trait CharacterStatePublicChannelListDataTrait: super::core::DataContainerPolicyAssetTrait {
    fn public_channels(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStatePublicChannelDataTrait>>>>;
    fn public_channels_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn CharacterStatePublicChannelDataTrait>>>>;
}

impl CharacterStatePublicChannelListDataTrait for CharacterStatePublicChannelListData {
    fn public_channels(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStatePublicChannelDataTrait>>>> {
        &self.public_channels
    }
    fn public_channels_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn CharacterStatePublicChannelDataTrait>>>> {
        &mut self.public_channels
    }
}

impl super::core::DataContainerPolicyAssetTrait for CharacterStatePublicChannelListData {
}

impl super::core::AssetTrait for CharacterStatePublicChannelListData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for CharacterStatePublicChannelListData {
}

pub static CHARACTERSTATEPUBLICCHANNELLISTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStatePublicChannelListData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINERPOLICYASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStatePublicChannelListData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PublicChannels",
                flags: MemberInfoFlags::new(144),
                field_type: "CharacterStatePublicChannelData-Array",
                rust_offset: offset_of!(CharacterStatePublicChannelListData, public_channels),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEPUBLICCHANNELLISTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStatePublicChannelListData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEPUBLICCHANNELLISTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERSTATEPUBLICCHANNELLISTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStatePublicChannelListData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("CharacterStatePublicChannelListData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStatePublicBoolChannelData {
    pub _glacier_base: CharacterStatePublicChannelData,
}

pub trait CharacterStatePublicBoolChannelDataTrait: CharacterStatePublicChannelDataTrait {
}

impl CharacterStatePublicBoolChannelDataTrait for CharacterStatePublicBoolChannelData {
}

impl CharacterStatePublicChannelDataTrait for CharacterStatePublicBoolChannelData {
    fn hash(&self) -> &u32 {
        self._glacier_base.hash()
    }
    fn hash_mut(&mut self) -> &mut u32 {
        self._glacier_base.hash_mut()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for CharacterStatePublicBoolChannelData {
}

pub static CHARACTERSTATEPUBLICBOOLCHANNELDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStatePublicBoolChannelData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEPUBLICCHANNELDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStatePublicBoolChannelData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(CHARACTERSTATEPUBLICBOOLCHANNELDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStatePublicBoolChannelData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEPUBLICBOOLCHANNELDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERSTATEPUBLICBOOLCHANNELDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStatePublicBoolChannelData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("CharacterStatePublicBoolChannelData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStatePublicIntChannelData {
    pub _glacier_base: CharacterStatePublicChannelData,
}

pub trait CharacterStatePublicIntChannelDataTrait: CharacterStatePublicChannelDataTrait {
}

impl CharacterStatePublicIntChannelDataTrait for CharacterStatePublicIntChannelData {
}

impl CharacterStatePublicChannelDataTrait for CharacterStatePublicIntChannelData {
    fn hash(&self) -> &u32 {
        self._glacier_base.hash()
    }
    fn hash_mut(&mut self) -> &mut u32 {
        self._glacier_base.hash_mut()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for CharacterStatePublicIntChannelData {
}

pub static CHARACTERSTATEPUBLICINTCHANNELDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStatePublicIntChannelData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEPUBLICCHANNELDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStatePublicIntChannelData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(CHARACTERSTATEPUBLICINTCHANNELDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStatePublicIntChannelData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEPUBLICINTCHANNELDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERSTATEPUBLICINTCHANNELDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStatePublicIntChannelData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("CharacterStatePublicIntChannelData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStatePublicFloatChannelData {
    pub _glacier_base: CharacterStatePublicChannelData,
}

pub trait CharacterStatePublicFloatChannelDataTrait: CharacterStatePublicChannelDataTrait {
}

impl CharacterStatePublicFloatChannelDataTrait for CharacterStatePublicFloatChannelData {
}

impl CharacterStatePublicChannelDataTrait for CharacterStatePublicFloatChannelData {
    fn hash(&self) -> &u32 {
        self._glacier_base.hash()
    }
    fn hash_mut(&mut self) -> &mut u32 {
        self._glacier_base.hash_mut()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for CharacterStatePublicFloatChannelData {
}

pub static CHARACTERSTATEPUBLICFLOATCHANNELDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStatePublicFloatChannelData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEPUBLICCHANNELDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStatePublicFloatChannelData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(CHARACTERSTATEPUBLICFLOATCHANNELDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStatePublicFloatChannelData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEPUBLICFLOATCHANNELDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERSTATEPUBLICFLOATCHANNELDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStatePublicFloatChannelData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("CharacterStatePublicFloatChannelData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStatePublicVec3ChannelData {
    pub _glacier_base: CharacterStatePublicChannelData,
}

pub trait CharacterStatePublicVec3ChannelDataTrait: CharacterStatePublicChannelDataTrait {
}

impl CharacterStatePublicVec3ChannelDataTrait for CharacterStatePublicVec3ChannelData {
}

impl CharacterStatePublicChannelDataTrait for CharacterStatePublicVec3ChannelData {
    fn hash(&self) -> &u32 {
        self._glacier_base.hash()
    }
    fn hash_mut(&mut self) -> &mut u32 {
        self._glacier_base.hash_mut()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for CharacterStatePublicVec3ChannelData {
}

pub static CHARACTERSTATEPUBLICVEC3CHANNELDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStatePublicVec3ChannelData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEPUBLICCHANNELDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStatePublicVec3ChannelData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(CHARACTERSTATEPUBLICVEC3CHANNELDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStatePublicVec3ChannelData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEPUBLICVEC3CHANNELDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERSTATEPUBLICVEC3CHANNELDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStatePublicVec3ChannelData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("CharacterStatePublicVec3ChannelData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStatePublicTransformChannelData {
    pub _glacier_base: CharacterStatePublicChannelData,
}

pub trait CharacterStatePublicTransformChannelDataTrait: CharacterStatePublicChannelDataTrait {
}

impl CharacterStatePublicTransformChannelDataTrait for CharacterStatePublicTransformChannelData {
}

impl CharacterStatePublicChannelDataTrait for CharacterStatePublicTransformChannelData {
    fn hash(&self) -> &u32 {
        self._glacier_base.hash()
    }
    fn hash_mut(&mut self) -> &mut u32 {
        self._glacier_base.hash_mut()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for CharacterStatePublicTransformChannelData {
}

pub static CHARACTERSTATEPUBLICTRANSFORMCHANNELDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStatePublicTransformChannelData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEPUBLICCHANNELDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStatePublicTransformChannelData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(CHARACTERSTATEPUBLICTRANSFORMCHANNELDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStatePublicTransformChannelData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEPUBLICTRANSFORMCHANNELDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERSTATEPUBLICTRANSFORMCHANNELDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStatePublicTransformChannelData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("CharacterStatePublicTransformChannelData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStatePublicChannelData {
    pub _glacier_base: super::core::DataContainer,
    pub hash: u32,
    pub name: String,
}

pub trait CharacterStatePublicChannelDataTrait: super::core::DataContainerTrait {
    fn hash(&self) -> &u32;
    fn hash_mut(&mut self) -> &mut u32;
    fn name(&self) -> &String;
    fn name_mut(&mut self) -> &mut String;
}

impl CharacterStatePublicChannelDataTrait for CharacterStatePublicChannelData {
    fn hash(&self) -> &u32 {
        &self.hash
    }
    fn hash_mut(&mut self) -> &mut u32 {
        &mut self.hash
    }
    fn name(&self) -> &String {
        &self.name
    }
    fn name_mut(&mut self) -> &mut String {
        &mut self.name
    }
}

impl super::core::DataContainerTrait for CharacterStatePublicChannelData {
}

pub static CHARACTERSTATEPUBLICCHANNELDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStatePublicChannelData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStatePublicChannelData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Hash",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(CharacterStatePublicChannelData, hash),
            },
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(CharacterStatePublicChannelData, name),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEPUBLICCHANNELDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStatePublicChannelData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEPUBLICCHANNELDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERSTATEPUBLICCHANNELDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStatePublicChannelData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("CharacterStatePublicChannelData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ChannelTableData {
    pub bool_channels: Vec<Option<Arc<Mutex<dyn BoolChannelDataTrait>>>>,
    pub int_channels: Vec<Option<Arc<Mutex<dyn IntChannelDataTrait>>>>,
    pub float_channels: Vec<Option<Arc<Mutex<dyn FloatChannelDataTrait>>>>,
    pub vec3_channels: Vec<Option<Arc<Mutex<dyn Vec3ChannelDataTrait>>>>,
    pub transform_channels: Vec<Option<Arc<Mutex<dyn TransformChannelDataTrait>>>>,
    pub networked_bool_channels: Vec<Option<Arc<Mutex<dyn BoolChannelDataTrait>>>>,
    pub networked_int_channels: Vec<Option<Arc<Mutex<dyn IntChannelDataTrait>>>>,
    pub networked_float_channels: Vec<Option<Arc<Mutex<dyn FloatChannelDataTrait>>>>,
    pub networked_vec3_channels: Vec<Option<Arc<Mutex<dyn Vec3ChannelDataTrait>>>>,
    pub networked_transform_channels: Vec<Option<Arc<Mutex<dyn TransformChannelDataTrait>>>>,
    pub reset_every_frame: ResetEveryFrameData,
}

pub trait ChannelTableDataTrait: TypeObject {
    fn bool_channels(&self) -> &Vec<Option<Arc<Mutex<dyn BoolChannelDataTrait>>>>;
    fn bool_channels_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn BoolChannelDataTrait>>>>;
    fn int_channels(&self) -> &Vec<Option<Arc<Mutex<dyn IntChannelDataTrait>>>>;
    fn int_channels_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn IntChannelDataTrait>>>>;
    fn float_channels(&self) -> &Vec<Option<Arc<Mutex<dyn FloatChannelDataTrait>>>>;
    fn float_channels_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn FloatChannelDataTrait>>>>;
    fn vec3_channels(&self) -> &Vec<Option<Arc<Mutex<dyn Vec3ChannelDataTrait>>>>;
    fn vec3_channels_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn Vec3ChannelDataTrait>>>>;
    fn transform_channels(&self) -> &Vec<Option<Arc<Mutex<dyn TransformChannelDataTrait>>>>;
    fn transform_channels_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn TransformChannelDataTrait>>>>;
    fn networked_bool_channels(&self) -> &Vec<Option<Arc<Mutex<dyn BoolChannelDataTrait>>>>;
    fn networked_bool_channels_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn BoolChannelDataTrait>>>>;
    fn networked_int_channels(&self) -> &Vec<Option<Arc<Mutex<dyn IntChannelDataTrait>>>>;
    fn networked_int_channels_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn IntChannelDataTrait>>>>;
    fn networked_float_channels(&self) -> &Vec<Option<Arc<Mutex<dyn FloatChannelDataTrait>>>>;
    fn networked_float_channels_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn FloatChannelDataTrait>>>>;
    fn networked_vec3_channels(&self) -> &Vec<Option<Arc<Mutex<dyn Vec3ChannelDataTrait>>>>;
    fn networked_vec3_channels_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn Vec3ChannelDataTrait>>>>;
    fn networked_transform_channels(&self) -> &Vec<Option<Arc<Mutex<dyn TransformChannelDataTrait>>>>;
    fn networked_transform_channels_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn TransformChannelDataTrait>>>>;
    fn reset_every_frame(&self) -> &ResetEveryFrameData;
    fn reset_every_frame_mut(&mut self) -> &mut ResetEveryFrameData;
}

impl ChannelTableDataTrait for ChannelTableData {
    fn bool_channels(&self) -> &Vec<Option<Arc<Mutex<dyn BoolChannelDataTrait>>>> {
        &self.bool_channels
    }
    fn bool_channels_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn BoolChannelDataTrait>>>> {
        &mut self.bool_channels
    }
    fn int_channels(&self) -> &Vec<Option<Arc<Mutex<dyn IntChannelDataTrait>>>> {
        &self.int_channels
    }
    fn int_channels_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn IntChannelDataTrait>>>> {
        &mut self.int_channels
    }
    fn float_channels(&self) -> &Vec<Option<Arc<Mutex<dyn FloatChannelDataTrait>>>> {
        &self.float_channels
    }
    fn float_channels_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn FloatChannelDataTrait>>>> {
        &mut self.float_channels
    }
    fn vec3_channels(&self) -> &Vec<Option<Arc<Mutex<dyn Vec3ChannelDataTrait>>>> {
        &self.vec3_channels
    }
    fn vec3_channels_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn Vec3ChannelDataTrait>>>> {
        &mut self.vec3_channels
    }
    fn transform_channels(&self) -> &Vec<Option<Arc<Mutex<dyn TransformChannelDataTrait>>>> {
        &self.transform_channels
    }
    fn transform_channels_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn TransformChannelDataTrait>>>> {
        &mut self.transform_channels
    }
    fn networked_bool_channels(&self) -> &Vec<Option<Arc<Mutex<dyn BoolChannelDataTrait>>>> {
        &self.networked_bool_channels
    }
    fn networked_bool_channels_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn BoolChannelDataTrait>>>> {
        &mut self.networked_bool_channels
    }
    fn networked_int_channels(&self) -> &Vec<Option<Arc<Mutex<dyn IntChannelDataTrait>>>> {
        &self.networked_int_channels
    }
    fn networked_int_channels_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn IntChannelDataTrait>>>> {
        &mut self.networked_int_channels
    }
    fn networked_float_channels(&self) -> &Vec<Option<Arc<Mutex<dyn FloatChannelDataTrait>>>> {
        &self.networked_float_channels
    }
    fn networked_float_channels_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn FloatChannelDataTrait>>>> {
        &mut self.networked_float_channels
    }
    fn networked_vec3_channels(&self) -> &Vec<Option<Arc<Mutex<dyn Vec3ChannelDataTrait>>>> {
        &self.networked_vec3_channels
    }
    fn networked_vec3_channels_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn Vec3ChannelDataTrait>>>> {
        &mut self.networked_vec3_channels
    }
    fn networked_transform_channels(&self) -> &Vec<Option<Arc<Mutex<dyn TransformChannelDataTrait>>>> {
        &self.networked_transform_channels
    }
    fn networked_transform_channels_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn TransformChannelDataTrait>>>> {
        &mut self.networked_transform_channels
    }
    fn reset_every_frame(&self) -> &ResetEveryFrameData {
        &self.reset_every_frame
    }
    fn reset_every_frame_mut(&mut self) -> &mut ResetEveryFrameData {
        &mut self.reset_every_frame
    }
}

pub static CHANNELTABLEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ChannelTableData",
    flags: MemberInfoFlags::new(73),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ChannelTableData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "BoolChannels",
                flags: MemberInfoFlags::new(144),
                field_type: "BoolChannelData-Array",
                rust_offset: offset_of!(ChannelTableData, bool_channels),
            },
            FieldInfoData {
                name: "IntChannels",
                flags: MemberInfoFlags::new(144),
                field_type: "IntChannelData-Array",
                rust_offset: offset_of!(ChannelTableData, int_channels),
            },
            FieldInfoData {
                name: "FloatChannels",
                flags: MemberInfoFlags::new(144),
                field_type: "FloatChannelData-Array",
                rust_offset: offset_of!(ChannelTableData, float_channels),
            },
            FieldInfoData {
                name: "Vec3Channels",
                flags: MemberInfoFlags::new(144),
                field_type: "Vec3ChannelData-Array",
                rust_offset: offset_of!(ChannelTableData, vec3_channels),
            },
            FieldInfoData {
                name: "TransformChannels",
                flags: MemberInfoFlags::new(144),
                field_type: "TransformChannelData-Array",
                rust_offset: offset_of!(ChannelTableData, transform_channels),
            },
            FieldInfoData {
                name: "NetworkedBoolChannels",
                flags: MemberInfoFlags::new(144),
                field_type: "BoolChannelData-Array",
                rust_offset: offset_of!(ChannelTableData, networked_bool_channels),
            },
            FieldInfoData {
                name: "NetworkedIntChannels",
                flags: MemberInfoFlags::new(144),
                field_type: "IntChannelData-Array",
                rust_offset: offset_of!(ChannelTableData, networked_int_channels),
            },
            FieldInfoData {
                name: "NetworkedFloatChannels",
                flags: MemberInfoFlags::new(144),
                field_type: "FloatChannelData-Array",
                rust_offset: offset_of!(ChannelTableData, networked_float_channels),
            },
            FieldInfoData {
                name: "NetworkedVec3Channels",
                flags: MemberInfoFlags::new(144),
                field_type: "Vec3ChannelData-Array",
                rust_offset: offset_of!(ChannelTableData, networked_vec3_channels),
            },
            FieldInfoData {
                name: "NetworkedTransformChannels",
                flags: MemberInfoFlags::new(144),
                field_type: "TransformChannelData-Array",
                rust_offset: offset_of!(ChannelTableData, networked_transform_channels),
            },
            FieldInfoData {
                name: "ResetEveryFrame",
                flags: MemberInfoFlags::new(0),
                field_type: "ResetEveryFrameData",
                rust_offset: offset_of!(ChannelTableData, reset_every_frame),
            },
        ],
    }),
    array_type: Some(CHANNELTABLEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ChannelTableData {
    fn type_info(&self) -> &'static TypeInfo {
        CHANNELTABLEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CHANNELTABLEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ChannelTableData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("ChannelTableData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ResetEveryFrameData {
    pub bool_bucket_masks: Vec<u8>,
    pub bool_bucket_values: Vec<u8>,
    pub net_bool_bucket_masks: Vec<u8>,
    pub net_bool_bucket_values: Vec<u8>,
    pub int_bucket_masks: Vec<u8>,
    pub net_int_bucket_masks: Vec<u8>,
    pub float_bucket_masks: Vec<u8>,
    pub net_float_bucket_masks: Vec<u8>,
    pub vec3_bucket_masks: Vec<u8>,
    pub net_vec3_bucket_masks: Vec<u8>,
    pub transform_bucket_masks: Vec<u8>,
    pub net_transform_bucket_masks: Vec<u8>,
    pub int_channel_indices: Vec<i32>,
    pub int_channel_values: Vec<i32>,
    pub net_int_channel_indices: Vec<i32>,
    pub net_int_channel_values: Vec<i32>,
    pub float_channel_indices: Vec<i32>,
    pub float_channel_values: Vec<f32>,
    pub net_float_channel_indices: Vec<i32>,
    pub net_float_channel_values: Vec<f32>,
    pub vec3_channel_indices: Vec<i32>,
    pub vec3_channel_values: Vec<super::core::Vec3>,
    pub net_vec3_channel_indices: Vec<i32>,
    pub net_vec3_channel_values: Vec<super::core::Vec3>,
    pub transform_channel_indices: Vec<i32>,
    pub transform_channel_values: Vec<super::core::LinearTransform>,
    pub net_transform_channel_indices: Vec<i32>,
    pub net_transform_channel_values: Vec<super::core::LinearTransform>,
}

pub trait ResetEveryFrameDataTrait: TypeObject {
    fn bool_bucket_masks(&self) -> &Vec<u8>;
    fn bool_bucket_masks_mut(&mut self) -> &mut Vec<u8>;
    fn bool_bucket_values(&self) -> &Vec<u8>;
    fn bool_bucket_values_mut(&mut self) -> &mut Vec<u8>;
    fn net_bool_bucket_masks(&self) -> &Vec<u8>;
    fn net_bool_bucket_masks_mut(&mut self) -> &mut Vec<u8>;
    fn net_bool_bucket_values(&self) -> &Vec<u8>;
    fn net_bool_bucket_values_mut(&mut self) -> &mut Vec<u8>;
    fn int_bucket_masks(&self) -> &Vec<u8>;
    fn int_bucket_masks_mut(&mut self) -> &mut Vec<u8>;
    fn net_int_bucket_masks(&self) -> &Vec<u8>;
    fn net_int_bucket_masks_mut(&mut self) -> &mut Vec<u8>;
    fn float_bucket_masks(&self) -> &Vec<u8>;
    fn float_bucket_masks_mut(&mut self) -> &mut Vec<u8>;
    fn net_float_bucket_masks(&self) -> &Vec<u8>;
    fn net_float_bucket_masks_mut(&mut self) -> &mut Vec<u8>;
    fn vec3_bucket_masks(&self) -> &Vec<u8>;
    fn vec3_bucket_masks_mut(&mut self) -> &mut Vec<u8>;
    fn net_vec3_bucket_masks(&self) -> &Vec<u8>;
    fn net_vec3_bucket_masks_mut(&mut self) -> &mut Vec<u8>;
    fn transform_bucket_masks(&self) -> &Vec<u8>;
    fn transform_bucket_masks_mut(&mut self) -> &mut Vec<u8>;
    fn net_transform_bucket_masks(&self) -> &Vec<u8>;
    fn net_transform_bucket_masks_mut(&mut self) -> &mut Vec<u8>;
    fn int_channel_indices(&self) -> &Vec<i32>;
    fn int_channel_indices_mut(&mut self) -> &mut Vec<i32>;
    fn int_channel_values(&self) -> &Vec<i32>;
    fn int_channel_values_mut(&mut self) -> &mut Vec<i32>;
    fn net_int_channel_indices(&self) -> &Vec<i32>;
    fn net_int_channel_indices_mut(&mut self) -> &mut Vec<i32>;
    fn net_int_channel_values(&self) -> &Vec<i32>;
    fn net_int_channel_values_mut(&mut self) -> &mut Vec<i32>;
    fn float_channel_indices(&self) -> &Vec<i32>;
    fn float_channel_indices_mut(&mut self) -> &mut Vec<i32>;
    fn float_channel_values(&self) -> &Vec<f32>;
    fn float_channel_values_mut(&mut self) -> &mut Vec<f32>;
    fn net_float_channel_indices(&self) -> &Vec<i32>;
    fn net_float_channel_indices_mut(&mut self) -> &mut Vec<i32>;
    fn net_float_channel_values(&self) -> &Vec<f32>;
    fn net_float_channel_values_mut(&mut self) -> &mut Vec<f32>;
    fn vec3_channel_indices(&self) -> &Vec<i32>;
    fn vec3_channel_indices_mut(&mut self) -> &mut Vec<i32>;
    fn vec3_channel_values(&self) -> &Vec<super::core::Vec3>;
    fn vec3_channel_values_mut(&mut self) -> &mut Vec<super::core::Vec3>;
    fn net_vec3_channel_indices(&self) -> &Vec<i32>;
    fn net_vec3_channel_indices_mut(&mut self) -> &mut Vec<i32>;
    fn net_vec3_channel_values(&self) -> &Vec<super::core::Vec3>;
    fn net_vec3_channel_values_mut(&mut self) -> &mut Vec<super::core::Vec3>;
    fn transform_channel_indices(&self) -> &Vec<i32>;
    fn transform_channel_indices_mut(&mut self) -> &mut Vec<i32>;
    fn transform_channel_values(&self) -> &Vec<super::core::LinearTransform>;
    fn transform_channel_values_mut(&mut self) -> &mut Vec<super::core::LinearTransform>;
    fn net_transform_channel_indices(&self) -> &Vec<i32>;
    fn net_transform_channel_indices_mut(&mut self) -> &mut Vec<i32>;
    fn net_transform_channel_values(&self) -> &Vec<super::core::LinearTransform>;
    fn net_transform_channel_values_mut(&mut self) -> &mut Vec<super::core::LinearTransform>;
}

impl ResetEveryFrameDataTrait for ResetEveryFrameData {
    fn bool_bucket_masks(&self) -> &Vec<u8> {
        &self.bool_bucket_masks
    }
    fn bool_bucket_masks_mut(&mut self) -> &mut Vec<u8> {
        &mut self.bool_bucket_masks
    }
    fn bool_bucket_values(&self) -> &Vec<u8> {
        &self.bool_bucket_values
    }
    fn bool_bucket_values_mut(&mut self) -> &mut Vec<u8> {
        &mut self.bool_bucket_values
    }
    fn net_bool_bucket_masks(&self) -> &Vec<u8> {
        &self.net_bool_bucket_masks
    }
    fn net_bool_bucket_masks_mut(&mut self) -> &mut Vec<u8> {
        &mut self.net_bool_bucket_masks
    }
    fn net_bool_bucket_values(&self) -> &Vec<u8> {
        &self.net_bool_bucket_values
    }
    fn net_bool_bucket_values_mut(&mut self) -> &mut Vec<u8> {
        &mut self.net_bool_bucket_values
    }
    fn int_bucket_masks(&self) -> &Vec<u8> {
        &self.int_bucket_masks
    }
    fn int_bucket_masks_mut(&mut self) -> &mut Vec<u8> {
        &mut self.int_bucket_masks
    }
    fn net_int_bucket_masks(&self) -> &Vec<u8> {
        &self.net_int_bucket_masks
    }
    fn net_int_bucket_masks_mut(&mut self) -> &mut Vec<u8> {
        &mut self.net_int_bucket_masks
    }
    fn float_bucket_masks(&self) -> &Vec<u8> {
        &self.float_bucket_masks
    }
    fn float_bucket_masks_mut(&mut self) -> &mut Vec<u8> {
        &mut self.float_bucket_masks
    }
    fn net_float_bucket_masks(&self) -> &Vec<u8> {
        &self.net_float_bucket_masks
    }
    fn net_float_bucket_masks_mut(&mut self) -> &mut Vec<u8> {
        &mut self.net_float_bucket_masks
    }
    fn vec3_bucket_masks(&self) -> &Vec<u8> {
        &self.vec3_bucket_masks
    }
    fn vec3_bucket_masks_mut(&mut self) -> &mut Vec<u8> {
        &mut self.vec3_bucket_masks
    }
    fn net_vec3_bucket_masks(&self) -> &Vec<u8> {
        &self.net_vec3_bucket_masks
    }
    fn net_vec3_bucket_masks_mut(&mut self) -> &mut Vec<u8> {
        &mut self.net_vec3_bucket_masks
    }
    fn transform_bucket_masks(&self) -> &Vec<u8> {
        &self.transform_bucket_masks
    }
    fn transform_bucket_masks_mut(&mut self) -> &mut Vec<u8> {
        &mut self.transform_bucket_masks
    }
    fn net_transform_bucket_masks(&self) -> &Vec<u8> {
        &self.net_transform_bucket_masks
    }
    fn net_transform_bucket_masks_mut(&mut self) -> &mut Vec<u8> {
        &mut self.net_transform_bucket_masks
    }
    fn int_channel_indices(&self) -> &Vec<i32> {
        &self.int_channel_indices
    }
    fn int_channel_indices_mut(&mut self) -> &mut Vec<i32> {
        &mut self.int_channel_indices
    }
    fn int_channel_values(&self) -> &Vec<i32> {
        &self.int_channel_values
    }
    fn int_channel_values_mut(&mut self) -> &mut Vec<i32> {
        &mut self.int_channel_values
    }
    fn net_int_channel_indices(&self) -> &Vec<i32> {
        &self.net_int_channel_indices
    }
    fn net_int_channel_indices_mut(&mut self) -> &mut Vec<i32> {
        &mut self.net_int_channel_indices
    }
    fn net_int_channel_values(&self) -> &Vec<i32> {
        &self.net_int_channel_values
    }
    fn net_int_channel_values_mut(&mut self) -> &mut Vec<i32> {
        &mut self.net_int_channel_values
    }
    fn float_channel_indices(&self) -> &Vec<i32> {
        &self.float_channel_indices
    }
    fn float_channel_indices_mut(&mut self) -> &mut Vec<i32> {
        &mut self.float_channel_indices
    }
    fn float_channel_values(&self) -> &Vec<f32> {
        &self.float_channel_values
    }
    fn float_channel_values_mut(&mut self) -> &mut Vec<f32> {
        &mut self.float_channel_values
    }
    fn net_float_channel_indices(&self) -> &Vec<i32> {
        &self.net_float_channel_indices
    }
    fn net_float_channel_indices_mut(&mut self) -> &mut Vec<i32> {
        &mut self.net_float_channel_indices
    }
    fn net_float_channel_values(&self) -> &Vec<f32> {
        &self.net_float_channel_values
    }
    fn net_float_channel_values_mut(&mut self) -> &mut Vec<f32> {
        &mut self.net_float_channel_values
    }
    fn vec3_channel_indices(&self) -> &Vec<i32> {
        &self.vec3_channel_indices
    }
    fn vec3_channel_indices_mut(&mut self) -> &mut Vec<i32> {
        &mut self.vec3_channel_indices
    }
    fn vec3_channel_values(&self) -> &Vec<super::core::Vec3> {
        &self.vec3_channel_values
    }
    fn vec3_channel_values_mut(&mut self) -> &mut Vec<super::core::Vec3> {
        &mut self.vec3_channel_values
    }
    fn net_vec3_channel_indices(&self) -> &Vec<i32> {
        &self.net_vec3_channel_indices
    }
    fn net_vec3_channel_indices_mut(&mut self) -> &mut Vec<i32> {
        &mut self.net_vec3_channel_indices
    }
    fn net_vec3_channel_values(&self) -> &Vec<super::core::Vec3> {
        &self.net_vec3_channel_values
    }
    fn net_vec3_channel_values_mut(&mut self) -> &mut Vec<super::core::Vec3> {
        &mut self.net_vec3_channel_values
    }
    fn transform_channel_indices(&self) -> &Vec<i32> {
        &self.transform_channel_indices
    }
    fn transform_channel_indices_mut(&mut self) -> &mut Vec<i32> {
        &mut self.transform_channel_indices
    }
    fn transform_channel_values(&self) -> &Vec<super::core::LinearTransform> {
        &self.transform_channel_values
    }
    fn transform_channel_values_mut(&mut self) -> &mut Vec<super::core::LinearTransform> {
        &mut self.transform_channel_values
    }
    fn net_transform_channel_indices(&self) -> &Vec<i32> {
        &self.net_transform_channel_indices
    }
    fn net_transform_channel_indices_mut(&mut self) -> &mut Vec<i32> {
        &mut self.net_transform_channel_indices
    }
    fn net_transform_channel_values(&self) -> &Vec<super::core::LinearTransform> {
        &self.net_transform_channel_values
    }
    fn net_transform_channel_values_mut(&mut self) -> &mut Vec<super::core::LinearTransform> {
        &mut self.net_transform_channel_values
    }
}

pub static RESETEVERYFRAMEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ResetEveryFrameData",
    flags: MemberInfoFlags::new(73),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ResetEveryFrameData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "BoolBucketMasks",
                flags: MemberInfoFlags::new(144),
                field_type: "Uint8-Array",
                rust_offset: offset_of!(ResetEveryFrameData, bool_bucket_masks),
            },
            FieldInfoData {
                name: "BoolBucketValues",
                flags: MemberInfoFlags::new(144),
                field_type: "Uint8-Array",
                rust_offset: offset_of!(ResetEveryFrameData, bool_bucket_values),
            },
            FieldInfoData {
                name: "NetBoolBucketMasks",
                flags: MemberInfoFlags::new(144),
                field_type: "Uint8-Array",
                rust_offset: offset_of!(ResetEveryFrameData, net_bool_bucket_masks),
            },
            FieldInfoData {
                name: "NetBoolBucketValues",
                flags: MemberInfoFlags::new(144),
                field_type: "Uint8-Array",
                rust_offset: offset_of!(ResetEveryFrameData, net_bool_bucket_values),
            },
            FieldInfoData {
                name: "IntBucketMasks",
                flags: MemberInfoFlags::new(144),
                field_type: "Uint8-Array",
                rust_offset: offset_of!(ResetEveryFrameData, int_bucket_masks),
            },
            FieldInfoData {
                name: "NetIntBucketMasks",
                flags: MemberInfoFlags::new(144),
                field_type: "Uint8-Array",
                rust_offset: offset_of!(ResetEveryFrameData, net_int_bucket_masks),
            },
            FieldInfoData {
                name: "FloatBucketMasks",
                flags: MemberInfoFlags::new(144),
                field_type: "Uint8-Array",
                rust_offset: offset_of!(ResetEveryFrameData, float_bucket_masks),
            },
            FieldInfoData {
                name: "NetFloatBucketMasks",
                flags: MemberInfoFlags::new(144),
                field_type: "Uint8-Array",
                rust_offset: offset_of!(ResetEveryFrameData, net_float_bucket_masks),
            },
            FieldInfoData {
                name: "Vec3BucketMasks",
                flags: MemberInfoFlags::new(144),
                field_type: "Uint8-Array",
                rust_offset: offset_of!(ResetEveryFrameData, vec3_bucket_masks),
            },
            FieldInfoData {
                name: "NetVec3BucketMasks",
                flags: MemberInfoFlags::new(144),
                field_type: "Uint8-Array",
                rust_offset: offset_of!(ResetEveryFrameData, net_vec3_bucket_masks),
            },
            FieldInfoData {
                name: "TransformBucketMasks",
                flags: MemberInfoFlags::new(144),
                field_type: "Uint8-Array",
                rust_offset: offset_of!(ResetEveryFrameData, transform_bucket_masks),
            },
            FieldInfoData {
                name: "NetTransformBucketMasks",
                flags: MemberInfoFlags::new(144),
                field_type: "Uint8-Array",
                rust_offset: offset_of!(ResetEveryFrameData, net_transform_bucket_masks),
            },
            FieldInfoData {
                name: "IntChannelIndices",
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(ResetEveryFrameData, int_channel_indices),
            },
            FieldInfoData {
                name: "IntChannelValues",
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(ResetEveryFrameData, int_channel_values),
            },
            FieldInfoData {
                name: "NetIntChannelIndices",
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(ResetEveryFrameData, net_int_channel_indices),
            },
            FieldInfoData {
                name: "NetIntChannelValues",
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(ResetEveryFrameData, net_int_channel_values),
            },
            FieldInfoData {
                name: "FloatChannelIndices",
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(ResetEveryFrameData, float_channel_indices),
            },
            FieldInfoData {
                name: "FloatChannelValues",
                flags: MemberInfoFlags::new(144),
                field_type: "Float32-Array",
                rust_offset: offset_of!(ResetEveryFrameData, float_channel_values),
            },
            FieldInfoData {
                name: "NetFloatChannelIndices",
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(ResetEveryFrameData, net_float_channel_indices),
            },
            FieldInfoData {
                name: "NetFloatChannelValues",
                flags: MemberInfoFlags::new(144),
                field_type: "Float32-Array",
                rust_offset: offset_of!(ResetEveryFrameData, net_float_channel_values),
            },
            FieldInfoData {
                name: "Vec3ChannelIndices",
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(ResetEveryFrameData, vec3_channel_indices),
            },
            FieldInfoData {
                name: "Vec3ChannelValues",
                flags: MemberInfoFlags::new(144),
                field_type: "Vec3-Array",
                rust_offset: offset_of!(ResetEveryFrameData, vec3_channel_values),
            },
            FieldInfoData {
                name: "NetVec3ChannelIndices",
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(ResetEveryFrameData, net_vec3_channel_indices),
            },
            FieldInfoData {
                name: "NetVec3ChannelValues",
                flags: MemberInfoFlags::new(144),
                field_type: "Vec3-Array",
                rust_offset: offset_of!(ResetEveryFrameData, net_vec3_channel_values),
            },
            FieldInfoData {
                name: "TransformChannelIndices",
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(ResetEveryFrameData, transform_channel_indices),
            },
            FieldInfoData {
                name: "TransformChannelValues",
                flags: MemberInfoFlags::new(144),
                field_type: "LinearTransform-Array",
                rust_offset: offset_of!(ResetEveryFrameData, transform_channel_values),
            },
            FieldInfoData {
                name: "NetTransformChannelIndices",
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(ResetEveryFrameData, net_transform_channel_indices),
            },
            FieldInfoData {
                name: "NetTransformChannelValues",
                flags: MemberInfoFlags::new(144),
                field_type: "LinearTransform-Array",
                rust_offset: offset_of!(ResetEveryFrameData, net_transform_channel_values),
            },
        ],
    }),
    array_type: Some(RESETEVERYFRAMEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ResetEveryFrameData {
    fn type_info(&self) -> &'static TypeInfo {
        RESETEVERYFRAMEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static RESETEVERYFRAMEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ResetEveryFrameData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("ResetEveryFrameData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum ChannelDataType {
    #[default]
    ChannelDataType_NOT_SET = 0,
    ChannelDataType_Bool = 1,
    ChannelDataType_NetworkedBool = 2,
    ChannelDataType_Int = 3,
    ChannelDataType_NetworkedInt = 4,
    ChannelDataType_Float = 5,
    ChannelDataType_NetworkedFloat = 6,
    ChannelDataType_Vec3 = 7,
    ChannelDataType_NetworkedVec3 = 8,
    ChannelDataType_Transform = 9,
    ChannelDataType_NetworkedTransform = 10,
}

pub static CHANNELDATATYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ChannelDataType",
    flags: MemberInfoFlags::new(49429),
    module: "SoldierShared",
    data: TypeInfoData::Enum,
    array_type: Some(CHANNELDATATYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for ChannelDataType {
    fn type_info(&self) -> &'static TypeInfo {
        CHANNELDATATYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CHANNELDATATYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ChannelDataType-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("ChannelDataType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ChannelSetData {
    pub _glacier_base: super::core::DataContainer,
    pub channel: Vec<Option<Arc<Mutex<dyn TransformChannelDataTrait>>>>,
}

pub trait ChannelSetDataTrait: super::core::DataContainerTrait {
    fn channel(&self) -> &Vec<Option<Arc<Mutex<dyn TransformChannelDataTrait>>>>;
    fn channel_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn TransformChannelDataTrait>>>>;
}

impl ChannelSetDataTrait for ChannelSetData {
    fn channel(&self) -> &Vec<Option<Arc<Mutex<dyn TransformChannelDataTrait>>>> {
        &self.channel
    }
    fn channel_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn TransformChannelDataTrait>>>> {
        &mut self.channel
    }
}

impl super::core::DataContainerTrait for ChannelSetData {
}

pub static CHANNELSETDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ChannelSetData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ChannelSetData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Channel",
                flags: MemberInfoFlags::new(144),
                field_type: "TransformChannelData-Array",
                rust_offset: offset_of!(ChannelSetData, channel),
            },
        ],
    }),
    array_type: Some(CHANNELSETDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ChannelSetData {
    fn type_info(&self) -> &'static TypeInfo {
        CHANNELSETDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHANNELSETDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ChannelSetData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("ChannelSetData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TransformChannelData {
    pub _glacier_base: ChannelData,
    pub ant_vec: super::ant::AntRef,
    pub ant_quat: super::ant::AntRef,
    pub mirror_mode: TransformChannelMirrorToGameStateMode,
    pub network_quantization: TransformNetworkQuantization,
    pub is_delta_channel: bool,
    pub accumulate_delta: bool,
    pub joint_name: String,
    pub parent_channel: Option<Arc<Mutex<dyn TransformChannelDataTrait>>>,
    pub default_value: super::core::LinearTransform,
}

pub trait TransformChannelDataTrait: ChannelDataTrait {
    fn ant_vec(&self) -> &super::ant::AntRef;
    fn ant_vec_mut(&mut self) -> &mut super::ant::AntRef;
    fn ant_quat(&self) -> &super::ant::AntRef;
    fn ant_quat_mut(&mut self) -> &mut super::ant::AntRef;
    fn mirror_mode(&self) -> &TransformChannelMirrorToGameStateMode;
    fn mirror_mode_mut(&mut self) -> &mut TransformChannelMirrorToGameStateMode;
    fn network_quantization(&self) -> &TransformNetworkQuantization;
    fn network_quantization_mut(&mut self) -> &mut TransformNetworkQuantization;
    fn is_delta_channel(&self) -> &bool;
    fn is_delta_channel_mut(&mut self) -> &mut bool;
    fn accumulate_delta(&self) -> &bool;
    fn accumulate_delta_mut(&mut self) -> &mut bool;
    fn joint_name(&self) -> &String;
    fn joint_name_mut(&mut self) -> &mut String;
    fn parent_channel(&self) -> &Option<Arc<Mutex<dyn TransformChannelDataTrait>>>;
    fn parent_channel_mut(&mut self) -> &mut Option<Arc<Mutex<dyn TransformChannelDataTrait>>>;
    fn default_value(&self) -> &super::core::LinearTransform;
    fn default_value_mut(&mut self) -> &mut super::core::LinearTransform;
}

impl TransformChannelDataTrait for TransformChannelData {
    fn ant_vec(&self) -> &super::ant::AntRef {
        &self.ant_vec
    }
    fn ant_vec_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.ant_vec
    }
    fn ant_quat(&self) -> &super::ant::AntRef {
        &self.ant_quat
    }
    fn ant_quat_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.ant_quat
    }
    fn mirror_mode(&self) -> &TransformChannelMirrorToGameStateMode {
        &self.mirror_mode
    }
    fn mirror_mode_mut(&mut self) -> &mut TransformChannelMirrorToGameStateMode {
        &mut self.mirror_mode
    }
    fn network_quantization(&self) -> &TransformNetworkQuantization {
        &self.network_quantization
    }
    fn network_quantization_mut(&mut self) -> &mut TransformNetworkQuantization {
        &mut self.network_quantization
    }
    fn is_delta_channel(&self) -> &bool {
        &self.is_delta_channel
    }
    fn is_delta_channel_mut(&mut self) -> &mut bool {
        &mut self.is_delta_channel
    }
    fn accumulate_delta(&self) -> &bool {
        &self.accumulate_delta
    }
    fn accumulate_delta_mut(&mut self) -> &mut bool {
        &mut self.accumulate_delta
    }
    fn joint_name(&self) -> &String {
        &self.joint_name
    }
    fn joint_name_mut(&mut self) -> &mut String {
        &mut self.joint_name
    }
    fn parent_channel(&self) -> &Option<Arc<Mutex<dyn TransformChannelDataTrait>>> {
        &self.parent_channel
    }
    fn parent_channel_mut(&mut self) -> &mut Option<Arc<Mutex<dyn TransformChannelDataTrait>>> {
        &mut self.parent_channel
    }
    fn default_value(&self) -> &super::core::LinearTransform {
        &self.default_value
    }
    fn default_value_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.default_value
    }
}

impl ChannelDataTrait for TransformChannelData {
    fn channel_asset_index(&self) -> &i32 {
        self._glacier_base.channel_asset_index()
    }
    fn channel_asset_index_mut(&mut self) -> &mut i32 {
        self._glacier_base.channel_asset_index_mut()
    }
    fn reset_with_controller_tree_reset(&self) -> &bool {
        self._glacier_base.reset_with_controller_tree_reset()
    }
    fn reset_with_controller_tree_reset_mut(&mut self) -> &mut bool {
        self._glacier_base.reset_with_controller_tree_reset_mut()
    }
    fn reset_every_frame(&self) -> &bool {
        self._glacier_base.reset_every_frame()
    }
    fn reset_every_frame_mut(&mut self) -> &mut bool {
        self._glacier_base.reset_every_frame_mut()
    }
    fn mirror_to_ant(&self) -> &bool {
        self._glacier_base.mirror_to_ant()
    }
    fn mirror_to_ant_mut(&mut self) -> &mut bool {
        self._glacier_base.mirror_to_ant_mut()
    }
    fn replicate(&self) -> &bool {
        self._glacier_base.replicate()
    }
    fn replicate_mut(&mut self) -> &mut bool {
        self._glacier_base.replicate_mut()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
    fn networked(&self) -> &bool {
        self._glacier_base.networked()
    }
    fn networked_mut(&mut self) -> &mut bool {
        self._glacier_base.networked_mut()
    }
    fn table_index(&self) -> &i32 {
        self._glacier_base.table_index()
    }
    fn table_index_mut(&mut self) -> &mut i32 {
        self._glacier_base.table_index_mut()
    }
}

impl super::core::DataContainerTrait for TransformChannelData {
}

pub static TRANSFORMCHANNELDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformChannelData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHANNELDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformChannelData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AntVec",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(TransformChannelData, ant_vec),
            },
            FieldInfoData {
                name: "AntQuat",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(TransformChannelData, ant_quat),
            },
            FieldInfoData {
                name: "MirrorMode",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelMirrorToGameStateMode",
                rust_offset: offset_of!(TransformChannelData, mirror_mode),
            },
            FieldInfoData {
                name: "NetworkQuantization",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformNetworkQuantization",
                rust_offset: offset_of!(TransformChannelData, network_quantization),
            },
            FieldInfoData {
                name: "IsDeltaChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TransformChannelData, is_delta_channel),
            },
            FieldInfoData {
                name: "AccumulateDelta",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TransformChannelData, accumulate_delta),
            },
            FieldInfoData {
                name: "JointName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(TransformChannelData, joint_name),
            },
            FieldInfoData {
                name: "ParentChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(TransformChannelData, parent_channel),
            },
            FieldInfoData {
                name: "DefaultValue",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(TransformChannelData, default_value),
            },
        ],
    }),
    array_type: Some(TRANSFORMCHANNELDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for TransformChannelData {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMCHANNELDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TRANSFORMCHANNELDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformChannelData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("TransformChannelData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum TransformChannelMirrorToGameStateMode {
    #[default]
    TransformChannelMirrorToGameStateMode_WorldSpace = 0,
    TransformChannelMirrorToGameStateMode_LocalSpace = 1,
}

pub static TRANSFORMCHANNELMIRRORTOGAMESTATEMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformChannelMirrorToGameStateMode",
    flags: MemberInfoFlags::new(49429),
    module: "SoldierShared",
    data: TypeInfoData::Enum,
    array_type: Some(TRANSFORMCHANNELMIRRORTOGAMESTATEMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for TransformChannelMirrorToGameStateMode {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMCHANNELMIRRORTOGAMESTATEMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static TRANSFORMCHANNELMIRRORTOGAMESTATEMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformChannelMirrorToGameStateMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("TransformChannelMirrorToGameStateMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TransformNetworkQuantization {
    pub quat_scale: f32,
    pub translation_quantization: Vec3NetworkQuantization,
}

pub trait TransformNetworkQuantizationTrait: TypeObject {
    fn quat_scale(&self) -> &f32;
    fn quat_scale_mut(&mut self) -> &mut f32;
    fn translation_quantization(&self) -> &Vec3NetworkQuantization;
    fn translation_quantization_mut(&mut self) -> &mut Vec3NetworkQuantization;
}

impl TransformNetworkQuantizationTrait for TransformNetworkQuantization {
    fn quat_scale(&self) -> &f32 {
        &self.quat_scale
    }
    fn quat_scale_mut(&mut self) -> &mut f32 {
        &mut self.quat_scale
    }
    fn translation_quantization(&self) -> &Vec3NetworkQuantization {
        &self.translation_quantization
    }
    fn translation_quantization_mut(&mut self) -> &mut Vec3NetworkQuantization {
        &mut self.translation_quantization
    }
}

pub static TRANSFORMNETWORKQUANTIZATION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformNetworkQuantization",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformNetworkQuantization as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "QuatScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TransformNetworkQuantization, quat_scale),
            },
            FieldInfoData {
                name: "TranslationQuantization",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3NetworkQuantization",
                rust_offset: offset_of!(TransformNetworkQuantization, translation_quantization),
            },
        ],
    }),
    array_type: Some(TRANSFORMNETWORKQUANTIZATION_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for TransformNetworkQuantization {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMNETWORKQUANTIZATION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static TRANSFORMNETWORKQUANTIZATION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformNetworkQuantization-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("TransformNetworkQuantization"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Vec3ChannelData {
    pub _glacier_base: ChannelData,
    pub ant_vec: super::ant::AntRef,
    pub network_quantization: Vec3NetworkQuantization,
    pub default_value: super::core::Vec3,
}

pub trait Vec3ChannelDataTrait: ChannelDataTrait {
    fn ant_vec(&self) -> &super::ant::AntRef;
    fn ant_vec_mut(&mut self) -> &mut super::ant::AntRef;
    fn network_quantization(&self) -> &Vec3NetworkQuantization;
    fn network_quantization_mut(&mut self) -> &mut Vec3NetworkQuantization;
    fn default_value(&self) -> &super::core::Vec3;
    fn default_value_mut(&mut self) -> &mut super::core::Vec3;
}

impl Vec3ChannelDataTrait for Vec3ChannelData {
    fn ant_vec(&self) -> &super::ant::AntRef {
        &self.ant_vec
    }
    fn ant_vec_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.ant_vec
    }
    fn network_quantization(&self) -> &Vec3NetworkQuantization {
        &self.network_quantization
    }
    fn network_quantization_mut(&mut self) -> &mut Vec3NetworkQuantization {
        &mut self.network_quantization
    }
    fn default_value(&self) -> &super::core::Vec3 {
        &self.default_value
    }
    fn default_value_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.default_value
    }
}

impl ChannelDataTrait for Vec3ChannelData {
    fn channel_asset_index(&self) -> &i32 {
        self._glacier_base.channel_asset_index()
    }
    fn channel_asset_index_mut(&mut self) -> &mut i32 {
        self._glacier_base.channel_asset_index_mut()
    }
    fn reset_with_controller_tree_reset(&self) -> &bool {
        self._glacier_base.reset_with_controller_tree_reset()
    }
    fn reset_with_controller_tree_reset_mut(&mut self) -> &mut bool {
        self._glacier_base.reset_with_controller_tree_reset_mut()
    }
    fn reset_every_frame(&self) -> &bool {
        self._glacier_base.reset_every_frame()
    }
    fn reset_every_frame_mut(&mut self) -> &mut bool {
        self._glacier_base.reset_every_frame_mut()
    }
    fn mirror_to_ant(&self) -> &bool {
        self._glacier_base.mirror_to_ant()
    }
    fn mirror_to_ant_mut(&mut self) -> &mut bool {
        self._glacier_base.mirror_to_ant_mut()
    }
    fn replicate(&self) -> &bool {
        self._glacier_base.replicate()
    }
    fn replicate_mut(&mut self) -> &mut bool {
        self._glacier_base.replicate_mut()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
    fn networked(&self) -> &bool {
        self._glacier_base.networked()
    }
    fn networked_mut(&mut self) -> &mut bool {
        self._glacier_base.networked_mut()
    }
    fn table_index(&self) -> &i32 {
        self._glacier_base.table_index()
    }
    fn table_index_mut(&mut self) -> &mut i32 {
        self._glacier_base.table_index_mut()
    }
}

impl super::core::DataContainerTrait for Vec3ChannelData {
}

pub static VEC3CHANNELDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3ChannelData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHANNELDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec3ChannelData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AntVec",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(Vec3ChannelData, ant_vec),
            },
            FieldInfoData {
                name: "NetworkQuantization",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3NetworkQuantization",
                rust_offset: offset_of!(Vec3ChannelData, network_quantization),
            },
            FieldInfoData {
                name: "DefaultValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(Vec3ChannelData, default_value),
            },
        ],
    }),
    array_type: Some(VEC3CHANNELDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for Vec3ChannelData {
    fn type_info(&self) -> &'static TypeInfo {
        VEC3CHANNELDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEC3CHANNELDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3ChannelData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("Vec3ChannelData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Vec3NetworkQuantization {
    pub x_quant: FloatNetworkQuantization,
    pub y_quant: FloatNetworkQuantization,
    pub z_quant: FloatNetworkQuantization,
}

pub trait Vec3NetworkQuantizationTrait: TypeObject {
    fn x_quant(&self) -> &FloatNetworkQuantization;
    fn x_quant_mut(&mut self) -> &mut FloatNetworkQuantization;
    fn y_quant(&self) -> &FloatNetworkQuantization;
    fn y_quant_mut(&mut self) -> &mut FloatNetworkQuantization;
    fn z_quant(&self) -> &FloatNetworkQuantization;
    fn z_quant_mut(&mut self) -> &mut FloatNetworkQuantization;
}

impl Vec3NetworkQuantizationTrait for Vec3NetworkQuantization {
    fn x_quant(&self) -> &FloatNetworkQuantization {
        &self.x_quant
    }
    fn x_quant_mut(&mut self) -> &mut FloatNetworkQuantization {
        &mut self.x_quant
    }
    fn y_quant(&self) -> &FloatNetworkQuantization {
        &self.y_quant
    }
    fn y_quant_mut(&mut self) -> &mut FloatNetworkQuantization {
        &mut self.y_quant
    }
    fn z_quant(&self) -> &FloatNetworkQuantization {
        &self.z_quant
    }
    fn z_quant_mut(&mut self) -> &mut FloatNetworkQuantization {
        &mut self.z_quant
    }
}

pub static VEC3NETWORKQUANTIZATION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3NetworkQuantization",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec3NetworkQuantization as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "XQuant",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatNetworkQuantization",
                rust_offset: offset_of!(Vec3NetworkQuantization, x_quant),
            },
            FieldInfoData {
                name: "YQuant",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatNetworkQuantization",
                rust_offset: offset_of!(Vec3NetworkQuantization, y_quant),
            },
            FieldInfoData {
                name: "ZQuant",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatNetworkQuantization",
                rust_offset: offset_of!(Vec3NetworkQuantization, z_quant),
            },
        ],
    }),
    array_type: Some(VEC3NETWORKQUANTIZATION_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for Vec3NetworkQuantization {
    fn type_info(&self) -> &'static TypeInfo {
        VEC3NETWORKQUANTIZATION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VEC3NETWORKQUANTIZATION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3NetworkQuantization-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("Vec3NetworkQuantization"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FloatChannelData {
    pub _glacier_base: ChannelData,
    pub ant_float: super::ant::AntRef,
    pub default_value: f32,
    pub network_quantization: FloatNetworkQuantization,
    pub is_delta_channel: bool,
    pub accumulate_delta: bool,
    pub treat_as_game_logic: bool,
}

pub trait FloatChannelDataTrait: ChannelDataTrait {
    fn ant_float(&self) -> &super::ant::AntRef;
    fn ant_float_mut(&mut self) -> &mut super::ant::AntRef;
    fn default_value(&self) -> &f32;
    fn default_value_mut(&mut self) -> &mut f32;
    fn network_quantization(&self) -> &FloatNetworkQuantization;
    fn network_quantization_mut(&mut self) -> &mut FloatNetworkQuantization;
    fn is_delta_channel(&self) -> &bool;
    fn is_delta_channel_mut(&mut self) -> &mut bool;
    fn accumulate_delta(&self) -> &bool;
    fn accumulate_delta_mut(&mut self) -> &mut bool;
    fn treat_as_game_logic(&self) -> &bool;
    fn treat_as_game_logic_mut(&mut self) -> &mut bool;
}

impl FloatChannelDataTrait for FloatChannelData {
    fn ant_float(&self) -> &super::ant::AntRef {
        &self.ant_float
    }
    fn ant_float_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.ant_float
    }
    fn default_value(&self) -> &f32 {
        &self.default_value
    }
    fn default_value_mut(&mut self) -> &mut f32 {
        &mut self.default_value
    }
    fn network_quantization(&self) -> &FloatNetworkQuantization {
        &self.network_quantization
    }
    fn network_quantization_mut(&mut self) -> &mut FloatNetworkQuantization {
        &mut self.network_quantization
    }
    fn is_delta_channel(&self) -> &bool {
        &self.is_delta_channel
    }
    fn is_delta_channel_mut(&mut self) -> &mut bool {
        &mut self.is_delta_channel
    }
    fn accumulate_delta(&self) -> &bool {
        &self.accumulate_delta
    }
    fn accumulate_delta_mut(&mut self) -> &mut bool {
        &mut self.accumulate_delta
    }
    fn treat_as_game_logic(&self) -> &bool {
        &self.treat_as_game_logic
    }
    fn treat_as_game_logic_mut(&mut self) -> &mut bool {
        &mut self.treat_as_game_logic
    }
}

impl ChannelDataTrait for FloatChannelData {
    fn channel_asset_index(&self) -> &i32 {
        self._glacier_base.channel_asset_index()
    }
    fn channel_asset_index_mut(&mut self) -> &mut i32 {
        self._glacier_base.channel_asset_index_mut()
    }
    fn reset_with_controller_tree_reset(&self) -> &bool {
        self._glacier_base.reset_with_controller_tree_reset()
    }
    fn reset_with_controller_tree_reset_mut(&mut self) -> &mut bool {
        self._glacier_base.reset_with_controller_tree_reset_mut()
    }
    fn reset_every_frame(&self) -> &bool {
        self._glacier_base.reset_every_frame()
    }
    fn reset_every_frame_mut(&mut self) -> &mut bool {
        self._glacier_base.reset_every_frame_mut()
    }
    fn mirror_to_ant(&self) -> &bool {
        self._glacier_base.mirror_to_ant()
    }
    fn mirror_to_ant_mut(&mut self) -> &mut bool {
        self._glacier_base.mirror_to_ant_mut()
    }
    fn replicate(&self) -> &bool {
        self._glacier_base.replicate()
    }
    fn replicate_mut(&mut self) -> &mut bool {
        self._glacier_base.replicate_mut()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
    fn networked(&self) -> &bool {
        self._glacier_base.networked()
    }
    fn networked_mut(&mut self) -> &mut bool {
        self._glacier_base.networked_mut()
    }
    fn table_index(&self) -> &i32 {
        self._glacier_base.table_index()
    }
    fn table_index_mut(&mut self) -> &mut i32 {
        self._glacier_base.table_index_mut()
    }
}

impl super::core::DataContainerTrait for FloatChannelData {
}

pub static FLOATCHANNELDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatChannelData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHANNELDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FloatChannelData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AntFloat",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(FloatChannelData, ant_float),
            },
            FieldInfoData {
                name: "DefaultValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FloatChannelData, default_value),
            },
            FieldInfoData {
                name: "NetworkQuantization",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatNetworkQuantization",
                rust_offset: offset_of!(FloatChannelData, network_quantization),
            },
            FieldInfoData {
                name: "IsDeltaChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FloatChannelData, is_delta_channel),
            },
            FieldInfoData {
                name: "AccumulateDelta",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FloatChannelData, accumulate_delta),
            },
            FieldInfoData {
                name: "TreatAsGameLogic",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FloatChannelData, treat_as_game_logic),
            },
        ],
    }),
    array_type: Some(FLOATCHANNELDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FloatChannelData {
    fn type_info(&self) -> &'static TypeInfo {
        FLOATCHANNELDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FLOATCHANNELDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatChannelData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("FloatChannelData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FloatNetworkQuantization {
    pub quantization_scale: f32,
    pub max_value: f32,
    pub min_value: f32,
    pub bits_needed_for_typical_change: i32,
}

pub trait FloatNetworkQuantizationTrait: TypeObject {
    fn quantization_scale(&self) -> &f32;
    fn quantization_scale_mut(&mut self) -> &mut f32;
    fn max_value(&self) -> &f32;
    fn max_value_mut(&mut self) -> &mut f32;
    fn min_value(&self) -> &f32;
    fn min_value_mut(&mut self) -> &mut f32;
    fn bits_needed_for_typical_change(&self) -> &i32;
    fn bits_needed_for_typical_change_mut(&mut self) -> &mut i32;
}

impl FloatNetworkQuantizationTrait for FloatNetworkQuantization {
    fn quantization_scale(&self) -> &f32 {
        &self.quantization_scale
    }
    fn quantization_scale_mut(&mut self) -> &mut f32 {
        &mut self.quantization_scale
    }
    fn max_value(&self) -> &f32 {
        &self.max_value
    }
    fn max_value_mut(&mut self) -> &mut f32 {
        &mut self.max_value
    }
    fn min_value(&self) -> &f32 {
        &self.min_value
    }
    fn min_value_mut(&mut self) -> &mut f32 {
        &mut self.min_value
    }
    fn bits_needed_for_typical_change(&self) -> &i32 {
        &self.bits_needed_for_typical_change
    }
    fn bits_needed_for_typical_change_mut(&mut self) -> &mut i32 {
        &mut self.bits_needed_for_typical_change
    }
}

pub static FLOATNETWORKQUANTIZATION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatNetworkQuantization",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FloatNetworkQuantization as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "QuantizationScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FloatNetworkQuantization, quantization_scale),
            },
            FieldInfoData {
                name: "MaxValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FloatNetworkQuantization, max_value),
            },
            FieldInfoData {
                name: "MinValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FloatNetworkQuantization, min_value),
            },
            FieldInfoData {
                name: "BitsNeededForTypicalChange",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(FloatNetworkQuantization, bits_needed_for_typical_change),
            },
        ],
    }),
    array_type: Some(FLOATNETWORKQUANTIZATION_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for FloatNetworkQuantization {
    fn type_info(&self) -> &'static TypeInfo {
        FLOATNETWORKQUANTIZATION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static FLOATNETWORKQUANTIZATION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatNetworkQuantization-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("FloatNetworkQuantization"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct IntChannelData {
    pub _glacier_base: ChannelData,
    pub ant_int: super::ant::AntRef,
    pub default_value: i32,
    pub network_quantization: IntNetworkQuantization,
    pub latency_compensate_tag_frames: i32,
}

pub trait IntChannelDataTrait: ChannelDataTrait {
    fn ant_int(&self) -> &super::ant::AntRef;
    fn ant_int_mut(&mut self) -> &mut super::ant::AntRef;
    fn default_value(&self) -> &i32;
    fn default_value_mut(&mut self) -> &mut i32;
    fn network_quantization(&self) -> &IntNetworkQuantization;
    fn network_quantization_mut(&mut self) -> &mut IntNetworkQuantization;
    fn latency_compensate_tag_frames(&self) -> &i32;
    fn latency_compensate_tag_frames_mut(&mut self) -> &mut i32;
}

impl IntChannelDataTrait for IntChannelData {
    fn ant_int(&self) -> &super::ant::AntRef {
        &self.ant_int
    }
    fn ant_int_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.ant_int
    }
    fn default_value(&self) -> &i32 {
        &self.default_value
    }
    fn default_value_mut(&mut self) -> &mut i32 {
        &mut self.default_value
    }
    fn network_quantization(&self) -> &IntNetworkQuantization {
        &self.network_quantization
    }
    fn network_quantization_mut(&mut self) -> &mut IntNetworkQuantization {
        &mut self.network_quantization
    }
    fn latency_compensate_tag_frames(&self) -> &i32 {
        &self.latency_compensate_tag_frames
    }
    fn latency_compensate_tag_frames_mut(&mut self) -> &mut i32 {
        &mut self.latency_compensate_tag_frames
    }
}

impl ChannelDataTrait for IntChannelData {
    fn channel_asset_index(&self) -> &i32 {
        self._glacier_base.channel_asset_index()
    }
    fn channel_asset_index_mut(&mut self) -> &mut i32 {
        self._glacier_base.channel_asset_index_mut()
    }
    fn reset_with_controller_tree_reset(&self) -> &bool {
        self._glacier_base.reset_with_controller_tree_reset()
    }
    fn reset_with_controller_tree_reset_mut(&mut self) -> &mut bool {
        self._glacier_base.reset_with_controller_tree_reset_mut()
    }
    fn reset_every_frame(&self) -> &bool {
        self._glacier_base.reset_every_frame()
    }
    fn reset_every_frame_mut(&mut self) -> &mut bool {
        self._glacier_base.reset_every_frame_mut()
    }
    fn mirror_to_ant(&self) -> &bool {
        self._glacier_base.mirror_to_ant()
    }
    fn mirror_to_ant_mut(&mut self) -> &mut bool {
        self._glacier_base.mirror_to_ant_mut()
    }
    fn replicate(&self) -> &bool {
        self._glacier_base.replicate()
    }
    fn replicate_mut(&mut self) -> &mut bool {
        self._glacier_base.replicate_mut()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
    fn networked(&self) -> &bool {
        self._glacier_base.networked()
    }
    fn networked_mut(&mut self) -> &mut bool {
        self._glacier_base.networked_mut()
    }
    fn table_index(&self) -> &i32 {
        self._glacier_base.table_index()
    }
    fn table_index_mut(&mut self) -> &mut i32 {
        self._glacier_base.table_index_mut()
    }
}

impl super::core::DataContainerTrait for IntChannelData {
}

pub static INTCHANNELDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntChannelData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHANNELDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<IntChannelData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AntInt",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(IntChannelData, ant_int),
            },
            FieldInfoData {
                name: "DefaultValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(IntChannelData, default_value),
            },
            FieldInfoData {
                name: "NetworkQuantization",
                flags: MemberInfoFlags::new(0),
                field_type: "IntNetworkQuantization",
                rust_offset: offset_of!(IntChannelData, network_quantization),
            },
            FieldInfoData {
                name: "LatencyCompensateTagFrames",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(IntChannelData, latency_compensate_tag_frames),
            },
        ],
    }),
    array_type: Some(INTCHANNELDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for IntChannelData {
    fn type_info(&self) -> &'static TypeInfo {
        INTCHANNELDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static INTCHANNELDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntChannelData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("IntChannelData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct IntNetworkQuantization {
    pub lower_limit: i32,
    pub upper_limit: i32,
}

pub trait IntNetworkQuantizationTrait: TypeObject {
    fn lower_limit(&self) -> &i32;
    fn lower_limit_mut(&mut self) -> &mut i32;
    fn upper_limit(&self) -> &i32;
    fn upper_limit_mut(&mut self) -> &mut i32;
}

impl IntNetworkQuantizationTrait for IntNetworkQuantization {
    fn lower_limit(&self) -> &i32 {
        &self.lower_limit
    }
    fn lower_limit_mut(&mut self) -> &mut i32 {
        &mut self.lower_limit
    }
    fn upper_limit(&self) -> &i32 {
        &self.upper_limit
    }
    fn upper_limit_mut(&mut self) -> &mut i32 {
        &mut self.upper_limit
    }
}

pub static INTNETWORKQUANTIZATION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntNetworkQuantization",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<IntNetworkQuantization as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "LowerLimit",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(IntNetworkQuantization, lower_limit),
            },
            FieldInfoData {
                name: "UpperLimit",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(IntNetworkQuantization, upper_limit),
            },
        ],
    }),
    array_type: Some(INTNETWORKQUANTIZATION_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for IntNetworkQuantization {
    fn type_info(&self) -> &'static TypeInfo {
        INTNETWORKQUANTIZATION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static INTNETWORKQUANTIZATION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntNetworkQuantization-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("IntNetworkQuantization"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BoolChannelData {
    pub _glacier_base: ChannelData,
    pub ant_bool: super::ant::AntRef,
    pub default_value: bool,
    pub latency_compensate_tag_frames: i32,
}

pub trait BoolChannelDataTrait: ChannelDataTrait {
    fn ant_bool(&self) -> &super::ant::AntRef;
    fn ant_bool_mut(&mut self) -> &mut super::ant::AntRef;
    fn default_value(&self) -> &bool;
    fn default_value_mut(&mut self) -> &mut bool;
    fn latency_compensate_tag_frames(&self) -> &i32;
    fn latency_compensate_tag_frames_mut(&mut self) -> &mut i32;
}

impl BoolChannelDataTrait for BoolChannelData {
    fn ant_bool(&self) -> &super::ant::AntRef {
        &self.ant_bool
    }
    fn ant_bool_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.ant_bool
    }
    fn default_value(&self) -> &bool {
        &self.default_value
    }
    fn default_value_mut(&mut self) -> &mut bool {
        &mut self.default_value
    }
    fn latency_compensate_tag_frames(&self) -> &i32 {
        &self.latency_compensate_tag_frames
    }
    fn latency_compensate_tag_frames_mut(&mut self) -> &mut i32 {
        &mut self.latency_compensate_tag_frames
    }
}

impl ChannelDataTrait for BoolChannelData {
    fn channel_asset_index(&self) -> &i32 {
        self._glacier_base.channel_asset_index()
    }
    fn channel_asset_index_mut(&mut self) -> &mut i32 {
        self._glacier_base.channel_asset_index_mut()
    }
    fn reset_with_controller_tree_reset(&self) -> &bool {
        self._glacier_base.reset_with_controller_tree_reset()
    }
    fn reset_with_controller_tree_reset_mut(&mut self) -> &mut bool {
        self._glacier_base.reset_with_controller_tree_reset_mut()
    }
    fn reset_every_frame(&self) -> &bool {
        self._glacier_base.reset_every_frame()
    }
    fn reset_every_frame_mut(&mut self) -> &mut bool {
        self._glacier_base.reset_every_frame_mut()
    }
    fn mirror_to_ant(&self) -> &bool {
        self._glacier_base.mirror_to_ant()
    }
    fn mirror_to_ant_mut(&mut self) -> &mut bool {
        self._glacier_base.mirror_to_ant_mut()
    }
    fn replicate(&self) -> &bool {
        self._glacier_base.replicate()
    }
    fn replicate_mut(&mut self) -> &mut bool {
        self._glacier_base.replicate_mut()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
    fn networked(&self) -> &bool {
        self._glacier_base.networked()
    }
    fn networked_mut(&mut self) -> &mut bool {
        self._glacier_base.networked_mut()
    }
    fn table_index(&self) -> &i32 {
        self._glacier_base.table_index()
    }
    fn table_index_mut(&mut self) -> &mut i32 {
        self._glacier_base.table_index_mut()
    }
}

impl super::core::DataContainerTrait for BoolChannelData {
}

pub static BOOLCHANNELDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolChannelData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHANNELDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BoolChannelData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AntBool",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(BoolChannelData, ant_bool),
            },
            FieldInfoData {
                name: "DefaultValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BoolChannelData, default_value),
            },
            FieldInfoData {
                name: "LatencyCompensateTagFrames",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(BoolChannelData, latency_compensate_tag_frames),
            },
        ],
    }),
    array_type: Some(BOOLCHANNELDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BoolChannelData {
    fn type_info(&self) -> &'static TypeInfo {
        BOOLCHANNELDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BOOLCHANNELDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolChannelData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("BoolChannelData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ChannelData {
    pub _glacier_base: super::core::DataContainer,
    pub channel_asset_index: i32,
    pub reset_with_controller_tree_reset: bool,
    pub reset_every_frame: bool,
    pub mirror_to_ant: bool,
    pub replicate: bool,
    pub name: String,
    pub networked: bool,
    pub table_index: i32,
}

pub trait ChannelDataTrait: super::core::DataContainerTrait {
    fn channel_asset_index(&self) -> &i32;
    fn channel_asset_index_mut(&mut self) -> &mut i32;
    fn reset_with_controller_tree_reset(&self) -> &bool;
    fn reset_with_controller_tree_reset_mut(&mut self) -> &mut bool;
    fn reset_every_frame(&self) -> &bool;
    fn reset_every_frame_mut(&mut self) -> &mut bool;
    fn mirror_to_ant(&self) -> &bool;
    fn mirror_to_ant_mut(&mut self) -> &mut bool;
    fn replicate(&self) -> &bool;
    fn replicate_mut(&mut self) -> &mut bool;
    fn name(&self) -> &String;
    fn name_mut(&mut self) -> &mut String;
    fn networked(&self) -> &bool;
    fn networked_mut(&mut self) -> &mut bool;
    fn table_index(&self) -> &i32;
    fn table_index_mut(&mut self) -> &mut i32;
}

impl ChannelDataTrait for ChannelData {
    fn channel_asset_index(&self) -> &i32 {
        &self.channel_asset_index
    }
    fn channel_asset_index_mut(&mut self) -> &mut i32 {
        &mut self.channel_asset_index
    }
    fn reset_with_controller_tree_reset(&self) -> &bool {
        &self.reset_with_controller_tree_reset
    }
    fn reset_with_controller_tree_reset_mut(&mut self) -> &mut bool {
        &mut self.reset_with_controller_tree_reset
    }
    fn reset_every_frame(&self) -> &bool {
        &self.reset_every_frame
    }
    fn reset_every_frame_mut(&mut self) -> &mut bool {
        &mut self.reset_every_frame
    }
    fn mirror_to_ant(&self) -> &bool {
        &self.mirror_to_ant
    }
    fn mirror_to_ant_mut(&mut self) -> &mut bool {
        &mut self.mirror_to_ant
    }
    fn replicate(&self) -> &bool {
        &self.replicate
    }
    fn replicate_mut(&mut self) -> &mut bool {
        &mut self.replicate
    }
    fn name(&self) -> &String {
        &self.name
    }
    fn name_mut(&mut self) -> &mut String {
        &mut self.name
    }
    fn networked(&self) -> &bool {
        &self.networked
    }
    fn networked_mut(&mut self) -> &mut bool {
        &mut self.networked
    }
    fn table_index(&self) -> &i32 {
        &self.table_index
    }
    fn table_index_mut(&mut self) -> &mut i32 {
        &mut self.table_index
    }
}

impl super::core::DataContainerTrait for ChannelData {
}

pub static CHANNELDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ChannelData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ChannelData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ChannelAssetIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ChannelData, channel_asset_index),
            },
            FieldInfoData {
                name: "ResetWithControllerTreeReset",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ChannelData, reset_with_controller_tree_reset),
            },
            FieldInfoData {
                name: "ResetEveryFrame",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ChannelData, reset_every_frame),
            },
            FieldInfoData {
                name: "MirrorToAnt",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ChannelData, mirror_to_ant),
            },
            FieldInfoData {
                name: "Replicate",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ChannelData, replicate),
            },
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ChannelData, name),
            },
            FieldInfoData {
                name: "Networked",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ChannelData, networked),
            },
            FieldInfoData {
                name: "TableIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ChannelData, table_index),
            },
        ],
    }),
    array_type: Some(CHANNELDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ChannelData {
    fn type_info(&self) -> &'static TypeInfo {
        CHANNELDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHANNELDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ChannelData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("ChannelData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct IExternalCharacterStateControlComponentData {
    pub _glacier_base: super::entity::GameComponentData,
}

pub trait IExternalCharacterStateControlComponentDataTrait: super::entity::GameComponentDataTrait {
}

impl IExternalCharacterStateControlComponentDataTrait for IExternalCharacterStateControlComponentData {
}

impl super::entity::GameComponentDataTrait for IExternalCharacterStateControlComponentData {
}

impl super::entity::ComponentDataTrait for IExternalCharacterStateControlComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for IExternalCharacterStateControlComponentData {
}

impl super::core::DataBusPeerTrait for IExternalCharacterStateControlComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for IExternalCharacterStateControlComponentData {
}

impl super::core::DataContainerTrait for IExternalCharacterStateControlComponentData {
}

pub static IEXTERNALCHARACTERSTATECONTROLCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IExternalCharacterStateControlComponentData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<IExternalCharacterStateControlComponentData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(IEXTERNALCHARACTERSTATECONTROLCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for IExternalCharacterStateControlComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        IEXTERNALCHARACTERSTATECONTROLCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static IEXTERNALCHARACTERSTATECONTROLCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IExternalCharacterStateControlComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("IExternalCharacterStateControlComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BlockAimAssistEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub block_data: BlockAimAssistData,
}

pub trait BlockAimAssistEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn block_data(&self) -> &BlockAimAssistData;
    fn block_data_mut(&mut self) -> &mut BlockAimAssistData;
}

impl BlockAimAssistEntityDataTrait for BlockAimAssistEntityData {
    fn block_data(&self) -> &BlockAimAssistData {
        &self.block_data
    }
    fn block_data_mut(&mut self) -> &mut BlockAimAssistData {
        &mut self.block_data
    }
}

impl super::entity::SpatialEntityDataTrait for BlockAimAssistEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for BlockAimAssistEntityData {
}

impl super::entity::GameObjectDataTrait for BlockAimAssistEntityData {
}

impl super::core::DataBusPeerTrait for BlockAimAssistEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for BlockAimAssistEntityData {
}

impl super::core::DataContainerTrait for BlockAimAssistEntityData {
}

pub static BLOCKAIMASSISTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BlockAimAssistEntityData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BlockAimAssistEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "BlockData",
                flags: MemberInfoFlags::new(0),
                field_type: "BlockAimAssistData",
                rust_offset: offset_of!(BlockAimAssistEntityData, block_data),
            },
        ],
    }),
    array_type: Some(BLOCKAIMASSISTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for BlockAimAssistEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        BLOCKAIMASSISTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BLOCKAIMASSISTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BlockAimAssistEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("BlockAimAssistEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BlockAimAssistData {
    pub blocking_radius: f32,
    pub life_time: f32,
}

pub trait BlockAimAssistDataTrait: TypeObject {
    fn blocking_radius(&self) -> &f32;
    fn blocking_radius_mut(&mut self) -> &mut f32;
    fn life_time(&self) -> &f32;
    fn life_time_mut(&mut self) -> &mut f32;
}

impl BlockAimAssistDataTrait for BlockAimAssistData {
    fn blocking_radius(&self) -> &f32 {
        &self.blocking_radius
    }
    fn blocking_radius_mut(&mut self) -> &mut f32 {
        &mut self.blocking_radius
    }
    fn life_time(&self) -> &f32 {
        &self.life_time
    }
    fn life_time_mut(&mut self) -> &mut f32 {
        &mut self.life_time
    }
}

pub static BLOCKAIMASSISTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BlockAimAssistData",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BlockAimAssistData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "BlockingRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BlockAimAssistData, blocking_radius),
            },
            FieldInfoData {
                name: "LifeTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BlockAimAssistData, life_time),
            },
        ],
    }),
    array_type: Some(BLOCKAIMASSISTDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for BlockAimAssistData {
    fn type_info(&self) -> &'static TypeInfo {
        BLOCKAIMASSISTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static BLOCKAIMASSISTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BlockAimAssistData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("BlockAimAssistData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoldierCustomizationAsset {
    pub _glacier_base: super::game_shared::CharacterCustomizationAsset,
    pub weapon_table: Option<Arc<Mutex<dyn super::game_shared::CustomizationTableTrait>>>,
}

pub trait SoldierCustomizationAssetTrait: super::game_shared::CharacterCustomizationAssetTrait {
    fn weapon_table(&self) -> &Option<Arc<Mutex<dyn super::game_shared::CustomizationTableTrait>>>;
    fn weapon_table_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::game_shared::CustomizationTableTrait>>>;
}

impl SoldierCustomizationAssetTrait for SoldierCustomizationAsset {
    fn weapon_table(&self) -> &Option<Arc<Mutex<dyn super::game_shared::CustomizationTableTrait>>> {
        &self.weapon_table
    }
    fn weapon_table_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::game_shared::CustomizationTableTrait>>> {
        &mut self.weapon_table
    }
}

impl super::game_shared::CharacterCustomizationAssetTrait for SoldierCustomizationAsset {
    fn label_sid(&self) -> &String {
        self._glacier_base.label_sid()
    }
    fn label_sid_mut(&mut self) -> &mut String {
        self._glacier_base.label_sid_mut()
    }
    fn visual_table(&self) -> &Option<Arc<Mutex<dyn super::game_shared::CustomizationTableTrait>>> {
        self._glacier_base.visual_table()
    }
    fn visual_table_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::game_shared::CustomizationTableTrait>>> {
        self._glacier_base.visual_table_mut()
    }
    fn specialization_table(&self) -> &Option<Arc<Mutex<dyn super::game_shared::CustomizationTableTrait>>> {
        self._glacier_base.specialization_table()
    }
    fn specialization_table_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::game_shared::CustomizationTableTrait>>> {
        self._glacier_base.specialization_table_mut()
    }
}

impl super::core::DataContainerPolicyAssetTrait for SoldierCustomizationAsset {
}

impl super::core::AssetTrait for SoldierCustomizationAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for SoldierCustomizationAsset {
}

pub static SOLDIERCUSTOMIZATIONASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierCustomizationAsset",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::game_shared::CHARACTERCUSTOMIZATIONASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierCustomizationAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "WeaponTable",
                flags: MemberInfoFlags::new(0),
                field_type: "CustomizationTable",
                rust_offset: offset_of!(SoldierCustomizationAsset, weapon_table),
            },
        ],
    }),
    array_type: Some(SOLDIERCUSTOMIZATIONASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoldierCustomizationAsset {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERCUSTOMIZATIONASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOLDIERCUSTOMIZATIONASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierCustomizationAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SoldierCustomizationAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoldierWeaponSocketObjectData {
    pub _glacier_base: SocketObjectDataBase,
    pub soldier_weapon_guid: glacier_util::guid::Guid,
    pub transform: super::core::LinearTransform,
}

pub trait SoldierWeaponSocketObjectDataTrait: SocketObjectDataBaseTrait {
    fn soldier_weapon_guid(&self) -> &glacier_util::guid::Guid;
    fn soldier_weapon_guid_mut(&mut self) -> &mut glacier_util::guid::Guid;
    fn transform(&self) -> &super::core::LinearTransform;
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform;
}

impl SoldierWeaponSocketObjectDataTrait for SoldierWeaponSocketObjectData {
    fn soldier_weapon_guid(&self) -> &glacier_util::guid::Guid {
        &self.soldier_weapon_guid
    }
    fn soldier_weapon_guid_mut(&mut self) -> &mut glacier_util::guid::Guid {
        &mut self.soldier_weapon_guid
    }
    fn transform(&self) -> &super::core::LinearTransform {
        &self.transform
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.transform
    }
}

impl SocketObjectDataBaseTrait for SoldierWeaponSocketObjectData {
}

impl super::core::DataContainerTrait for SoldierWeaponSocketObjectData {
}

pub static SOLDIERWEAPONSOCKETOBJECTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierWeaponSocketObjectData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOCKETOBJECTDATABASE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierWeaponSocketObjectData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SoldierWeaponGuid",
                flags: MemberInfoFlags::new(0),
                field_type: "Guid",
                rust_offset: offset_of!(SoldierWeaponSocketObjectData, soldier_weapon_guid),
            },
            FieldInfoData {
                name: "Transform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(SoldierWeaponSocketObjectData, transform),
            },
        ],
    }),
    array_type: Some(SOLDIERWEAPONSOCKETOBJECTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SoldierWeaponSocketObjectData {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERWEAPONSOCKETOBJECTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOLDIERWEAPONSOCKETOBJECTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierWeaponSocketObjectData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SoldierWeaponSocketObjectData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct NetworkPlayerSelectedWeaponMessage {
}

pub trait NetworkPlayerSelectedWeaponMessageTrait: TypeObject {
}

impl NetworkPlayerSelectedWeaponMessageTrait for NetworkPlayerSelectedWeaponMessage {
}

pub static NETWORKPLAYERSELECTEDWEAPONMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NetworkPlayerSelectedWeaponMessage",
    flags: MemberInfoFlags::new(73),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<NetworkPlayerSelectedWeaponMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for NetworkPlayerSelectedWeaponMessage {
    fn type_info(&self) -> &'static TypeInfo {
        NETWORKPLAYERSELECTEDWEAPONMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Clone, Debug, Default)]
pub struct CoverPeekEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub binding: CoverPeekBinding,
    pub over_enabled: bool,
    pub horiz_enabled: bool,
    pub detect_distance_forward: f32,
    pub detect_distance_horizontal: f32,
}

pub trait CoverPeekEntityDataTrait: super::entity::EntityDataTrait {
    fn binding(&self) -> &CoverPeekBinding;
    fn binding_mut(&mut self) -> &mut CoverPeekBinding;
    fn over_enabled(&self) -> &bool;
    fn over_enabled_mut(&mut self) -> &mut bool;
    fn horiz_enabled(&self) -> &bool;
    fn horiz_enabled_mut(&mut self) -> &mut bool;
    fn detect_distance_forward(&self) -> &f32;
    fn detect_distance_forward_mut(&mut self) -> &mut f32;
    fn detect_distance_horizontal(&self) -> &f32;
    fn detect_distance_horizontal_mut(&mut self) -> &mut f32;
}

impl CoverPeekEntityDataTrait for CoverPeekEntityData {
    fn binding(&self) -> &CoverPeekBinding {
        &self.binding
    }
    fn binding_mut(&mut self) -> &mut CoverPeekBinding {
        &mut self.binding
    }
    fn over_enabled(&self) -> &bool {
        &self.over_enabled
    }
    fn over_enabled_mut(&mut self) -> &mut bool {
        &mut self.over_enabled
    }
    fn horiz_enabled(&self) -> &bool {
        &self.horiz_enabled
    }
    fn horiz_enabled_mut(&mut self) -> &mut bool {
        &mut self.horiz_enabled
    }
    fn detect_distance_forward(&self) -> &f32 {
        &self.detect_distance_forward
    }
    fn detect_distance_forward_mut(&mut self) -> &mut f32 {
        &mut self.detect_distance_forward
    }
    fn detect_distance_horizontal(&self) -> &f32 {
        &self.detect_distance_horizontal
    }
    fn detect_distance_horizontal_mut(&mut self) -> &mut f32 {
        &mut self.detect_distance_horizontal
    }
}

impl super::entity::EntityDataTrait for CoverPeekEntityData {
}

impl super::entity::GameObjectDataTrait for CoverPeekEntityData {
}

impl super::core::DataBusPeerTrait for CoverPeekEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CoverPeekEntityData {
}

impl super::core::DataContainerTrait for CoverPeekEntityData {
}

pub static COVERPEEKENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverPeekEntityData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CoverPeekEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Binding",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverPeekBinding",
                rust_offset: offset_of!(CoverPeekEntityData, binding),
            },
            FieldInfoData {
                name: "OverEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CoverPeekEntityData, over_enabled),
            },
            FieldInfoData {
                name: "HorizEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CoverPeekEntityData, horiz_enabled),
            },
            FieldInfoData {
                name: "DetectDistanceForward",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverPeekEntityData, detect_distance_forward),
            },
            FieldInfoData {
                name: "DetectDistanceHorizontal",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverPeekEntityData, detect_distance_horizontal),
            },
        ],
    }),
    array_type: Some(COVERPEEKENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CoverPeekEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        COVERPEEKENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COVERPEEKENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverPeekEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("CoverPeekEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CoverPeekBinding {
    pub cover_height1p: super::ant::AntRef,
    pub can_cover_peek: super::ant::AntRef,
    pub can_peek_over: super::ant::AntRef,
    pub can_peek_left: super::ant::AntRef,
    pub can_peek_right: super::ant::AntRef,
}

pub trait CoverPeekBindingTrait: TypeObject {
    fn cover_height1p(&self) -> &super::ant::AntRef;
    fn cover_height1p_mut(&mut self) -> &mut super::ant::AntRef;
    fn can_cover_peek(&self) -> &super::ant::AntRef;
    fn can_cover_peek_mut(&mut self) -> &mut super::ant::AntRef;
    fn can_peek_over(&self) -> &super::ant::AntRef;
    fn can_peek_over_mut(&mut self) -> &mut super::ant::AntRef;
    fn can_peek_left(&self) -> &super::ant::AntRef;
    fn can_peek_left_mut(&mut self) -> &mut super::ant::AntRef;
    fn can_peek_right(&self) -> &super::ant::AntRef;
    fn can_peek_right_mut(&mut self) -> &mut super::ant::AntRef;
}

impl CoverPeekBindingTrait for CoverPeekBinding {
    fn cover_height1p(&self) -> &super::ant::AntRef {
        &self.cover_height1p
    }
    fn cover_height1p_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.cover_height1p
    }
    fn can_cover_peek(&self) -> &super::ant::AntRef {
        &self.can_cover_peek
    }
    fn can_cover_peek_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.can_cover_peek
    }
    fn can_peek_over(&self) -> &super::ant::AntRef {
        &self.can_peek_over
    }
    fn can_peek_over_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.can_peek_over
    }
    fn can_peek_left(&self) -> &super::ant::AntRef {
        &self.can_peek_left
    }
    fn can_peek_left_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.can_peek_left
    }
    fn can_peek_right(&self) -> &super::ant::AntRef {
        &self.can_peek_right
    }
    fn can_peek_right_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.can_peek_right
    }
}

pub static COVERPEEKBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverPeekBinding",
    flags: MemberInfoFlags::new(32841),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CoverPeekBinding as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "CoverHeight1p",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CoverPeekBinding, cover_height1p),
            },
            FieldInfoData {
                name: "CanCoverPeek",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CoverPeekBinding, can_cover_peek),
            },
            FieldInfoData {
                name: "CanPeekOver",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CoverPeekBinding, can_peek_over),
            },
            FieldInfoData {
                name: "CanPeekLeft",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CoverPeekBinding, can_peek_left),
            },
            FieldInfoData {
                name: "CanPeekRight",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CoverPeekBinding, can_peek_right),
            },
        ],
    }),
    array_type: Some(COVERPEEKBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for CoverPeekBinding {
    fn type_info(&self) -> &'static TypeInfo {
        COVERPEEKBINDING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static COVERPEEKBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverPeekBinding-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("CoverPeekBinding"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AnimationTurretRotationComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub rotations: Vec<super::game_shared::TurretRotationInfo>,
    pub soldier_base_index: i32,
    pub use_vehicle_world_transform: bool,
    pub output_world_transform: bool,
}

pub trait AnimationTurretRotationComponentDataTrait: super::entity::GameComponentDataTrait {
    fn rotations(&self) -> &Vec<super::game_shared::TurretRotationInfo>;
    fn rotations_mut(&mut self) -> &mut Vec<super::game_shared::TurretRotationInfo>;
    fn soldier_base_index(&self) -> &i32;
    fn soldier_base_index_mut(&mut self) -> &mut i32;
    fn use_vehicle_world_transform(&self) -> &bool;
    fn use_vehicle_world_transform_mut(&mut self) -> &mut bool;
    fn output_world_transform(&self) -> &bool;
    fn output_world_transform_mut(&mut self) -> &mut bool;
}

impl AnimationTurretRotationComponentDataTrait for AnimationTurretRotationComponentData {
    fn rotations(&self) -> &Vec<super::game_shared::TurretRotationInfo> {
        &self.rotations
    }
    fn rotations_mut(&mut self) -> &mut Vec<super::game_shared::TurretRotationInfo> {
        &mut self.rotations
    }
    fn soldier_base_index(&self) -> &i32 {
        &self.soldier_base_index
    }
    fn soldier_base_index_mut(&mut self) -> &mut i32 {
        &mut self.soldier_base_index
    }
    fn use_vehicle_world_transform(&self) -> &bool {
        &self.use_vehicle_world_transform
    }
    fn use_vehicle_world_transform_mut(&mut self) -> &mut bool {
        &mut self.use_vehicle_world_transform
    }
    fn output_world_transform(&self) -> &bool {
        &self.output_world_transform
    }
    fn output_world_transform_mut(&mut self) -> &mut bool {
        &mut self.output_world_transform
    }
}

impl super::entity::GameComponentDataTrait for AnimationTurretRotationComponentData {
}

impl super::entity::ComponentDataTrait for AnimationTurretRotationComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for AnimationTurretRotationComponentData {
}

impl super::core::DataBusPeerTrait for AnimationTurretRotationComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AnimationTurretRotationComponentData {
}

impl super::core::DataContainerTrait for AnimationTurretRotationComponentData {
}

pub static ANIMATIONTURRETROTATIONCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimationTurretRotationComponentData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AnimationTurretRotationComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Rotations",
                flags: MemberInfoFlags::new(144),
                field_type: "TurretRotationInfo-Array",
                rust_offset: offset_of!(AnimationTurretRotationComponentData, rotations),
            },
            FieldInfoData {
                name: "SoldierBaseIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AnimationTurretRotationComponentData, soldier_base_index),
            },
            FieldInfoData {
                name: "UseVehicleWorldTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AnimationTurretRotationComponentData, use_vehicle_world_transform),
            },
            FieldInfoData {
                name: "OutputWorldTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AnimationTurretRotationComponentData, output_world_transform),
            },
        ],
    }),
    array_type: Some(ANIMATIONTURRETROTATIONCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AnimationTurretRotationComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        ANIMATIONTURRETROTATIONCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANIMATIONTURRETROTATIONCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimationTurretRotationComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("AnimationTurretRotationComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PhantomComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub box_size: super::core::Vec3,
    pub async_query_pointer_asset: super::ant::AntRef,
    pub enable_trajectory_override: super::ant::AntRef,
    pub trajectory_override: super::ant::AntRef,
}

pub trait PhantomComponentDataTrait: super::entity::GameComponentDataTrait {
    fn box_size(&self) -> &super::core::Vec3;
    fn box_size_mut(&mut self) -> &mut super::core::Vec3;
    fn async_query_pointer_asset(&self) -> &super::ant::AntRef;
    fn async_query_pointer_asset_mut(&mut self) -> &mut super::ant::AntRef;
    fn enable_trajectory_override(&self) -> &super::ant::AntRef;
    fn enable_trajectory_override_mut(&mut self) -> &mut super::ant::AntRef;
    fn trajectory_override(&self) -> &super::ant::AntRef;
    fn trajectory_override_mut(&mut self) -> &mut super::ant::AntRef;
}

impl PhantomComponentDataTrait for PhantomComponentData {
    fn box_size(&self) -> &super::core::Vec3 {
        &self.box_size
    }
    fn box_size_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.box_size
    }
    fn async_query_pointer_asset(&self) -> &super::ant::AntRef {
        &self.async_query_pointer_asset
    }
    fn async_query_pointer_asset_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.async_query_pointer_asset
    }
    fn enable_trajectory_override(&self) -> &super::ant::AntRef {
        &self.enable_trajectory_override
    }
    fn enable_trajectory_override_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.enable_trajectory_override
    }
    fn trajectory_override(&self) -> &super::ant::AntRef {
        &self.trajectory_override
    }
    fn trajectory_override_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.trajectory_override
    }
}

impl super::entity::GameComponentDataTrait for PhantomComponentData {
}

impl super::entity::ComponentDataTrait for PhantomComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for PhantomComponentData {
}

impl super::core::DataBusPeerTrait for PhantomComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PhantomComponentData {
}

impl super::core::DataContainerTrait for PhantomComponentData {
}

pub static PHANTOMCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhantomComponentData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PhantomComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "BoxSize",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(PhantomComponentData, box_size),
            },
            FieldInfoData {
                name: "AsyncQueryPointerAsset",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhantomComponentData, async_query_pointer_asset),
            },
            FieldInfoData {
                name: "EnableTrajectoryOverride",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhantomComponentData, enable_trajectory_override),
            },
            FieldInfoData {
                name: "TrajectoryOverride",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhantomComponentData, trajectory_override),
            },
        ],
    }),
    array_type: Some(PHANTOMCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PhantomComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        PHANTOMCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PHANTOMCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhantomComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("PhantomComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RagdollComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub realm: super::core::Realm,
    pub skeleton_asset: Option<Arc<Mutex<dyn super::entity::SkeletonAssetTrait>>>,
    pub use_server_ragdoll: bool,
    pub skeleton_collision_data: Option<Arc<Mutex<dyn super::game_shared::SkeletonCollisionDataTrait>>>,
    pub binding: RagdollBinding,
    pub left_leg_bone_name: String,
    pub right_leg_bone_name: String,
    pub allow_client_trigger_on_blend: bool,
    pub bone_materials: Vec<super::entity::MaterialDecl>,
    pub buoyant_parts: Vec<super::game_shared::BuoyantPartsData>,
    pub ragdoll_model: Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>>,
}

pub trait RagdollComponentDataTrait: super::entity::GameComponentDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn skeleton_asset(&self) -> &Option<Arc<Mutex<dyn super::entity::SkeletonAssetTrait>>>;
    fn skeleton_asset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::SkeletonAssetTrait>>>;
    fn use_server_ragdoll(&self) -> &bool;
    fn use_server_ragdoll_mut(&mut self) -> &mut bool;
    fn skeleton_collision_data(&self) -> &Option<Arc<Mutex<dyn super::game_shared::SkeletonCollisionDataTrait>>>;
    fn skeleton_collision_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::game_shared::SkeletonCollisionDataTrait>>>;
    fn binding(&self) -> &RagdollBinding;
    fn binding_mut(&mut self) -> &mut RagdollBinding;
    fn left_leg_bone_name(&self) -> &String;
    fn left_leg_bone_name_mut(&mut self) -> &mut String;
    fn right_leg_bone_name(&self) -> &String;
    fn right_leg_bone_name_mut(&mut self) -> &mut String;
    fn allow_client_trigger_on_blend(&self) -> &bool;
    fn allow_client_trigger_on_blend_mut(&mut self) -> &mut bool;
    fn bone_materials(&self) -> &Vec<super::entity::MaterialDecl>;
    fn bone_materials_mut(&mut self) -> &mut Vec<super::entity::MaterialDecl>;
    fn buoyant_parts(&self) -> &Vec<super::game_shared::BuoyantPartsData>;
    fn buoyant_parts_mut(&mut self) -> &mut Vec<super::game_shared::BuoyantPartsData>;
    fn ragdoll_model(&self) -> &Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>>;
    fn ragdoll_model_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>>;
}

impl RagdollComponentDataTrait for RagdollComponentData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn skeleton_asset(&self) -> &Option<Arc<Mutex<dyn super::entity::SkeletonAssetTrait>>> {
        &self.skeleton_asset
    }
    fn skeleton_asset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::SkeletonAssetTrait>>> {
        &mut self.skeleton_asset
    }
    fn use_server_ragdoll(&self) -> &bool {
        &self.use_server_ragdoll
    }
    fn use_server_ragdoll_mut(&mut self) -> &mut bool {
        &mut self.use_server_ragdoll
    }
    fn skeleton_collision_data(&self) -> &Option<Arc<Mutex<dyn super::game_shared::SkeletonCollisionDataTrait>>> {
        &self.skeleton_collision_data
    }
    fn skeleton_collision_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::game_shared::SkeletonCollisionDataTrait>>> {
        &mut self.skeleton_collision_data
    }
    fn binding(&self) -> &RagdollBinding {
        &self.binding
    }
    fn binding_mut(&mut self) -> &mut RagdollBinding {
        &mut self.binding
    }
    fn left_leg_bone_name(&self) -> &String {
        &self.left_leg_bone_name
    }
    fn left_leg_bone_name_mut(&mut self) -> &mut String {
        &mut self.left_leg_bone_name
    }
    fn right_leg_bone_name(&self) -> &String {
        &self.right_leg_bone_name
    }
    fn right_leg_bone_name_mut(&mut self) -> &mut String {
        &mut self.right_leg_bone_name
    }
    fn allow_client_trigger_on_blend(&self) -> &bool {
        &self.allow_client_trigger_on_blend
    }
    fn allow_client_trigger_on_blend_mut(&mut self) -> &mut bool {
        &mut self.allow_client_trigger_on_blend
    }
    fn bone_materials(&self) -> &Vec<super::entity::MaterialDecl> {
        &self.bone_materials
    }
    fn bone_materials_mut(&mut self) -> &mut Vec<super::entity::MaterialDecl> {
        &mut self.bone_materials
    }
    fn buoyant_parts(&self) -> &Vec<super::game_shared::BuoyantPartsData> {
        &self.buoyant_parts
    }
    fn buoyant_parts_mut(&mut self) -> &mut Vec<super::game_shared::BuoyantPartsData> {
        &mut self.buoyant_parts
    }
    fn ragdoll_model(&self) -> &Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>> {
        &self.ragdoll_model
    }
    fn ragdoll_model_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>> {
        &mut self.ragdoll_model
    }
}

impl super::entity::GameComponentDataTrait for RagdollComponentData {
}

impl super::entity::ComponentDataTrait for RagdollComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for RagdollComponentData {
}

impl super::core::DataBusPeerTrait for RagdollComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for RagdollComponentData {
}

impl super::core::DataContainerTrait for RagdollComponentData {
}

pub static RAGDOLLCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RagdollComponentData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RagdollComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(RagdollComponentData, realm),
            },
            FieldInfoData {
                name: "SkeletonAsset",
                flags: MemberInfoFlags::new(0),
                field_type: "SkeletonAsset",
                rust_offset: offset_of!(RagdollComponentData, skeleton_asset),
            },
            FieldInfoData {
                name: "UseServerRagdoll",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RagdollComponentData, use_server_ragdoll),
            },
            FieldInfoData {
                name: "SkeletonCollisionData",
                flags: MemberInfoFlags::new(0),
                field_type: "SkeletonCollisionData",
                rust_offset: offset_of!(RagdollComponentData, skeleton_collision_data),
            },
            FieldInfoData {
                name: "Binding",
                flags: MemberInfoFlags::new(0),
                field_type: "RagdollBinding",
                rust_offset: offset_of!(RagdollComponentData, binding),
            },
            FieldInfoData {
                name: "LeftLegBoneName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(RagdollComponentData, left_leg_bone_name),
            },
            FieldInfoData {
                name: "RightLegBoneName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(RagdollComponentData, right_leg_bone_name),
            },
            FieldInfoData {
                name: "AllowClientTriggerOnBlend",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RagdollComponentData, allow_client_trigger_on_blend),
            },
            FieldInfoData {
                name: "BoneMaterials",
                flags: MemberInfoFlags::new(144),
                field_type: "MaterialDecl-Array",
                rust_offset: offset_of!(RagdollComponentData, bone_materials),
            },
            FieldInfoData {
                name: "BuoyantParts",
                flags: MemberInfoFlags::new(144),
                field_type: "BuoyantPartsData-Array",
                rust_offset: offset_of!(RagdollComponentData, buoyant_parts),
            },
            FieldInfoData {
                name: "RagdollModel",
                flags: MemberInfoFlags::new(0),
                field_type: "ObjectBlueprint",
                rust_offset: offset_of!(RagdollComponentData, ragdoll_model),
            },
        ],
    }),
    array_type: Some(RAGDOLLCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for RagdollComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        RAGDOLLCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RAGDOLLCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RagdollComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("RagdollComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RagdollBinding {
    pub ragdoll_on_back: super::ant::AntRef,
    pub ragdoll_blend: super::ant::AntRef,
    pub ragdoll_blend_early: super::ant::AntRef,
    pub ragdoll_force_blend_disabled: super::ant::AntRef,
    pub ragdoll_active_time: super::ant::AntRef,
    pub ragdoll_fully_blended_in: super::ant::AntRef,
}

pub trait RagdollBindingTrait: TypeObject {
    fn ragdoll_on_back(&self) -> &super::ant::AntRef;
    fn ragdoll_on_back_mut(&mut self) -> &mut super::ant::AntRef;
    fn ragdoll_blend(&self) -> &super::ant::AntRef;
    fn ragdoll_blend_mut(&mut self) -> &mut super::ant::AntRef;
    fn ragdoll_blend_early(&self) -> &super::ant::AntRef;
    fn ragdoll_blend_early_mut(&mut self) -> &mut super::ant::AntRef;
    fn ragdoll_force_blend_disabled(&self) -> &super::ant::AntRef;
    fn ragdoll_force_blend_disabled_mut(&mut self) -> &mut super::ant::AntRef;
    fn ragdoll_active_time(&self) -> &super::ant::AntRef;
    fn ragdoll_active_time_mut(&mut self) -> &mut super::ant::AntRef;
    fn ragdoll_fully_blended_in(&self) -> &super::ant::AntRef;
    fn ragdoll_fully_blended_in_mut(&mut self) -> &mut super::ant::AntRef;
}

impl RagdollBindingTrait for RagdollBinding {
    fn ragdoll_on_back(&self) -> &super::ant::AntRef {
        &self.ragdoll_on_back
    }
    fn ragdoll_on_back_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.ragdoll_on_back
    }
    fn ragdoll_blend(&self) -> &super::ant::AntRef {
        &self.ragdoll_blend
    }
    fn ragdoll_blend_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.ragdoll_blend
    }
    fn ragdoll_blend_early(&self) -> &super::ant::AntRef {
        &self.ragdoll_blend_early
    }
    fn ragdoll_blend_early_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.ragdoll_blend_early
    }
    fn ragdoll_force_blend_disabled(&self) -> &super::ant::AntRef {
        &self.ragdoll_force_blend_disabled
    }
    fn ragdoll_force_blend_disabled_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.ragdoll_force_blend_disabled
    }
    fn ragdoll_active_time(&self) -> &super::ant::AntRef {
        &self.ragdoll_active_time
    }
    fn ragdoll_active_time_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.ragdoll_active_time
    }
    fn ragdoll_fully_blended_in(&self) -> &super::ant::AntRef {
        &self.ragdoll_fully_blended_in
    }
    fn ragdoll_fully_blended_in_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.ragdoll_fully_blended_in
    }
}

pub static RAGDOLLBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RagdollBinding",
    flags: MemberInfoFlags::new(32841),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RagdollBinding as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "RagdollOnBack",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(RagdollBinding, ragdoll_on_back),
            },
            FieldInfoData {
                name: "RagdollBlend",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(RagdollBinding, ragdoll_blend),
            },
            FieldInfoData {
                name: "RagdollBlendEarly",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(RagdollBinding, ragdoll_blend_early),
            },
            FieldInfoData {
                name: "RagdollForceBlendDisabled",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(RagdollBinding, ragdoll_force_blend_disabled),
            },
            FieldInfoData {
                name: "RagdollActiveTime",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(RagdollBinding, ragdoll_active_time),
            },
            FieldInfoData {
                name: "RagdollFullyBlendedIn",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(RagdollBinding, ragdoll_fully_blended_in),
            },
        ],
    }),
    array_type: Some(RAGDOLLBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for RagdollBinding {
    fn type_info(&self) -> &'static TypeInfo {
        RAGDOLLBINDING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static RAGDOLLBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RagdollBinding-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("RagdollBinding"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoldierFootplantEffectComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub foot_material_pair: super::entity::MaterialDecl,
    pub height_over_ground_threshold: f32,
    pub foot_velocity_threshold: f32,
    pub full_footplanting_enabled: bool,
    pub lod_distance: f32,
}

pub trait SoldierFootplantEffectComponentDataTrait: super::entity::GameComponentDataTrait {
    fn foot_material_pair(&self) -> &super::entity::MaterialDecl;
    fn foot_material_pair_mut(&mut self) -> &mut super::entity::MaterialDecl;
    fn height_over_ground_threshold(&self) -> &f32;
    fn height_over_ground_threshold_mut(&mut self) -> &mut f32;
    fn foot_velocity_threshold(&self) -> &f32;
    fn foot_velocity_threshold_mut(&mut self) -> &mut f32;
    fn full_footplanting_enabled(&self) -> &bool;
    fn full_footplanting_enabled_mut(&mut self) -> &mut bool;
    fn lod_distance(&self) -> &f32;
    fn lod_distance_mut(&mut self) -> &mut f32;
}

impl SoldierFootplantEffectComponentDataTrait for SoldierFootplantEffectComponentData {
    fn foot_material_pair(&self) -> &super::entity::MaterialDecl {
        &self.foot_material_pair
    }
    fn foot_material_pair_mut(&mut self) -> &mut super::entity::MaterialDecl {
        &mut self.foot_material_pair
    }
    fn height_over_ground_threshold(&self) -> &f32 {
        &self.height_over_ground_threshold
    }
    fn height_over_ground_threshold_mut(&mut self) -> &mut f32 {
        &mut self.height_over_ground_threshold
    }
    fn foot_velocity_threshold(&self) -> &f32 {
        &self.foot_velocity_threshold
    }
    fn foot_velocity_threshold_mut(&mut self) -> &mut f32 {
        &mut self.foot_velocity_threshold
    }
    fn full_footplanting_enabled(&self) -> &bool {
        &self.full_footplanting_enabled
    }
    fn full_footplanting_enabled_mut(&mut self) -> &mut bool {
        &mut self.full_footplanting_enabled
    }
    fn lod_distance(&self) -> &f32 {
        &self.lod_distance
    }
    fn lod_distance_mut(&mut self) -> &mut f32 {
        &mut self.lod_distance
    }
}

impl super::entity::GameComponentDataTrait for SoldierFootplantEffectComponentData {
}

impl super::entity::ComponentDataTrait for SoldierFootplantEffectComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for SoldierFootplantEffectComponentData {
}

impl super::core::DataBusPeerTrait for SoldierFootplantEffectComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SoldierFootplantEffectComponentData {
}

impl super::core::DataContainerTrait for SoldierFootplantEffectComponentData {
}

pub static SOLDIERFOOTPLANTEFFECTCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierFootplantEffectComponentData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierFootplantEffectComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "FootMaterialPair",
                flags: MemberInfoFlags::new(0),
                field_type: "MaterialDecl",
                rust_offset: offset_of!(SoldierFootplantEffectComponentData, foot_material_pair),
            },
            FieldInfoData {
                name: "HeightOverGroundThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierFootplantEffectComponentData, height_over_ground_threshold),
            },
            FieldInfoData {
                name: "FootVelocityThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierFootplantEffectComponentData, foot_velocity_threshold),
            },
            FieldInfoData {
                name: "FullFootplantingEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierFootplantEffectComponentData, full_footplanting_enabled),
            },
            FieldInfoData {
                name: "LodDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierFootplantEffectComponentData, lod_distance),
            },
        ],
    }),
    array_type: Some(SOLDIERFOOTPLANTEFFECTCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SoldierFootplantEffectComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERFOOTPLANTEFFECTCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOLDIERFOOTPLANTEFFECTCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierFootplantEffectComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SoldierFootplantEffectComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct OcclutionQueryComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub occlusion_box_min_treshold: f32,
    pub occlusion_box_scale: f32,
    pub enabled: bool,
    pub team_override: super::gameplay_sim::TeamId,
}

pub trait OcclutionQueryComponentDataTrait: super::entity::GameComponentDataTrait {
    fn occlusion_box_min_treshold(&self) -> &f32;
    fn occlusion_box_min_treshold_mut(&mut self) -> &mut f32;
    fn occlusion_box_scale(&self) -> &f32;
    fn occlusion_box_scale_mut(&mut self) -> &mut f32;
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
    fn team_override(&self) -> &super::gameplay_sim::TeamId;
    fn team_override_mut(&mut self) -> &mut super::gameplay_sim::TeamId;
}

impl OcclutionQueryComponentDataTrait for OcclutionQueryComponentData {
    fn occlusion_box_min_treshold(&self) -> &f32 {
        &self.occlusion_box_min_treshold
    }
    fn occlusion_box_min_treshold_mut(&mut self) -> &mut f32 {
        &mut self.occlusion_box_min_treshold
    }
    fn occlusion_box_scale(&self) -> &f32 {
        &self.occlusion_box_scale
    }
    fn occlusion_box_scale_mut(&mut self) -> &mut f32 {
        &mut self.occlusion_box_scale
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
    fn team_override(&self) -> &super::gameplay_sim::TeamId {
        &self.team_override
    }
    fn team_override_mut(&mut self) -> &mut super::gameplay_sim::TeamId {
        &mut self.team_override
    }
}

impl super::entity::GameComponentDataTrait for OcclutionQueryComponentData {
}

impl super::entity::ComponentDataTrait for OcclutionQueryComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for OcclutionQueryComponentData {
}

impl super::core::DataBusPeerTrait for OcclutionQueryComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for OcclutionQueryComponentData {
}

impl super::core::DataContainerTrait for OcclutionQueryComponentData {
}

pub static OCCLUTIONQUERYCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OcclutionQueryComponentData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<OcclutionQueryComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "OcclusionBoxMinTreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(OcclutionQueryComponentData, occlusion_box_min_treshold),
            },
            FieldInfoData {
                name: "OcclusionBoxScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(OcclutionQueryComponentData, occlusion_box_scale),
            },
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(OcclutionQueryComponentData, enabled),
            },
            FieldInfoData {
                name: "TeamOverride",
                flags: MemberInfoFlags::new(0),
                field_type: "TeamId",
                rust_offset: offset_of!(OcclutionQueryComponentData, team_override),
            },
        ],
    }),
    array_type: Some(OCCLUTIONQUERYCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for OcclutionQueryComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        OCCLUTIONQUERYCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static OCCLUTIONQUERYCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OcclutionQueryComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("OcclutionQueryComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BlockAimAssistComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub block_data: BlockAimAssistData,
}

pub trait BlockAimAssistComponentDataTrait: super::entity::GameComponentDataTrait {
    fn block_data(&self) -> &BlockAimAssistData;
    fn block_data_mut(&mut self) -> &mut BlockAimAssistData;
}

impl BlockAimAssistComponentDataTrait for BlockAimAssistComponentData {
    fn block_data(&self) -> &BlockAimAssistData {
        &self.block_data
    }
    fn block_data_mut(&mut self) -> &mut BlockAimAssistData {
        &mut self.block_data
    }
}

impl super::entity::GameComponentDataTrait for BlockAimAssistComponentData {
}

impl super::entity::ComponentDataTrait for BlockAimAssistComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for BlockAimAssistComponentData {
}

impl super::core::DataBusPeerTrait for BlockAimAssistComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for BlockAimAssistComponentData {
}

impl super::core::DataContainerTrait for BlockAimAssistComponentData {
}

pub static BLOCKAIMASSISTCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BlockAimAssistComponentData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BlockAimAssistComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "BlockData",
                flags: MemberInfoFlags::new(0),
                field_type: "BlockAimAssistData",
                rust_offset: offset_of!(BlockAimAssistComponentData, block_data),
            },
        ],
    }),
    array_type: Some(BLOCKAIMASSISTCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for BlockAimAssistComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        BLOCKAIMASSISTCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BLOCKAIMASSISTCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BlockAimAssistComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("BlockAimAssistComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EntryAimAssistTargetOptionsComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub allow_soldier_as_target: bool,
    pub not_snap_zoom_target_angle: f32,
}

pub trait EntryAimAssistTargetOptionsComponentDataTrait: super::entity::GameComponentDataTrait {
    fn allow_soldier_as_target(&self) -> &bool;
    fn allow_soldier_as_target_mut(&mut self) -> &mut bool;
    fn not_snap_zoom_target_angle(&self) -> &f32;
    fn not_snap_zoom_target_angle_mut(&mut self) -> &mut f32;
}

impl EntryAimAssistTargetOptionsComponentDataTrait for EntryAimAssistTargetOptionsComponentData {
    fn allow_soldier_as_target(&self) -> &bool {
        &self.allow_soldier_as_target
    }
    fn allow_soldier_as_target_mut(&mut self) -> &mut bool {
        &mut self.allow_soldier_as_target
    }
    fn not_snap_zoom_target_angle(&self) -> &f32 {
        &self.not_snap_zoom_target_angle
    }
    fn not_snap_zoom_target_angle_mut(&mut self) -> &mut f32 {
        &mut self.not_snap_zoom_target_angle
    }
}

impl super::entity::GameComponentDataTrait for EntryAimAssistTargetOptionsComponentData {
}

impl super::entity::ComponentDataTrait for EntryAimAssistTargetOptionsComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for EntryAimAssistTargetOptionsComponentData {
}

impl super::core::DataBusPeerTrait for EntryAimAssistTargetOptionsComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for EntryAimAssistTargetOptionsComponentData {
}

impl super::core::DataContainerTrait for EntryAimAssistTargetOptionsComponentData {
}

pub static ENTRYAIMASSISTTARGETOPTIONSCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntryAimAssistTargetOptionsComponentData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EntryAimAssistTargetOptionsComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AllowSoldierAsTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EntryAimAssistTargetOptionsComponentData, allow_soldier_as_target),
            },
            FieldInfoData {
                name: "NotSnapZoomTargetAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EntryAimAssistTargetOptionsComponentData, not_snap_zoom_target_angle),
            },
        ],
    }),
    array_type: Some(ENTRYAIMASSISTTARGETOPTIONSCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for EntryAimAssistTargetOptionsComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        ENTRYAIMASSISTTARGETOPTIONSCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ENTRYAIMASSISTTARGETOPTIONSCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntryAimAssistTargetOptionsComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("EntryAimAssistTargetOptionsComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AimAssistNodeSnapPointComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub enabled: bool,
    pub priority: u32,
    pub under_reticle_sphere_radius: f32,
    pub under_reticle_capsule_length: f32,
    pub priority_under_reticle: u32,
}

pub trait AimAssistNodeSnapPointComponentDataTrait: super::entity::GameComponentDataTrait {
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
    fn priority(&self) -> &u32;
    fn priority_mut(&mut self) -> &mut u32;
    fn under_reticle_sphere_radius(&self) -> &f32;
    fn under_reticle_sphere_radius_mut(&mut self) -> &mut f32;
    fn under_reticle_capsule_length(&self) -> &f32;
    fn under_reticle_capsule_length_mut(&mut self) -> &mut f32;
    fn priority_under_reticle(&self) -> &u32;
    fn priority_under_reticle_mut(&mut self) -> &mut u32;
}

impl AimAssistNodeSnapPointComponentDataTrait for AimAssistNodeSnapPointComponentData {
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
    fn priority(&self) -> &u32 {
        &self.priority
    }
    fn priority_mut(&mut self) -> &mut u32 {
        &mut self.priority
    }
    fn under_reticle_sphere_radius(&self) -> &f32 {
        &self.under_reticle_sphere_radius
    }
    fn under_reticle_sphere_radius_mut(&mut self) -> &mut f32 {
        &mut self.under_reticle_sphere_radius
    }
    fn under_reticle_capsule_length(&self) -> &f32 {
        &self.under_reticle_capsule_length
    }
    fn under_reticle_capsule_length_mut(&mut self) -> &mut f32 {
        &mut self.under_reticle_capsule_length
    }
    fn priority_under_reticle(&self) -> &u32 {
        &self.priority_under_reticle
    }
    fn priority_under_reticle_mut(&mut self) -> &mut u32 {
        &mut self.priority_under_reticle
    }
}

impl super::entity::GameComponentDataTrait for AimAssistNodeSnapPointComponentData {
}

impl super::entity::ComponentDataTrait for AimAssistNodeSnapPointComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for AimAssistNodeSnapPointComponentData {
}

impl super::core::DataBusPeerTrait for AimAssistNodeSnapPointComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AimAssistNodeSnapPointComponentData {
}

impl super::core::DataContainerTrait for AimAssistNodeSnapPointComponentData {
}

pub static AIMASSISTNODESNAPPOINTCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AimAssistNodeSnapPointComponentData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AimAssistNodeSnapPointComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AimAssistNodeSnapPointComponentData, enabled),
            },
            FieldInfoData {
                name: "Priority",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(AimAssistNodeSnapPointComponentData, priority),
            },
            FieldInfoData {
                name: "UnderReticleSphereRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AimAssistNodeSnapPointComponentData, under_reticle_sphere_radius),
            },
            FieldInfoData {
                name: "UnderReticleCapsuleLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AimAssistNodeSnapPointComponentData, under_reticle_capsule_length),
            },
            FieldInfoData {
                name: "Priority_UnderReticle",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(AimAssistNodeSnapPointComponentData, priority_under_reticle),
            },
        ],
    }),
    array_type: Some(AIMASSISTNODESNAPPOINTCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AimAssistNodeSnapPointComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        AIMASSISTNODESNAPPOINTCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIMASSISTNODESNAPPOINTCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AimAssistNodeSnapPointComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("AimAssistNodeSnapPointComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AimAssistNodeComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub enabled: bool,
    pub team: super::gameplay_sim::TeamId,
    pub get_team_from_owner: bool,
    pub color_player_reticle: bool,
    pub sticky_center_offset: super::core::Vec3,
}

pub trait AimAssistNodeComponentDataTrait: super::entity::GameComponentDataTrait {
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
    fn team(&self) -> &super::gameplay_sim::TeamId;
    fn team_mut(&mut self) -> &mut super::gameplay_sim::TeamId;
    fn get_team_from_owner(&self) -> &bool;
    fn get_team_from_owner_mut(&mut self) -> &mut bool;
    fn color_player_reticle(&self) -> &bool;
    fn color_player_reticle_mut(&mut self) -> &mut bool;
    fn sticky_center_offset(&self) -> &super::core::Vec3;
    fn sticky_center_offset_mut(&mut self) -> &mut super::core::Vec3;
}

impl AimAssistNodeComponentDataTrait for AimAssistNodeComponentData {
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
    fn team(&self) -> &super::gameplay_sim::TeamId {
        &self.team
    }
    fn team_mut(&mut self) -> &mut super::gameplay_sim::TeamId {
        &mut self.team
    }
    fn get_team_from_owner(&self) -> &bool {
        &self.get_team_from_owner
    }
    fn get_team_from_owner_mut(&mut self) -> &mut bool {
        &mut self.get_team_from_owner
    }
    fn color_player_reticle(&self) -> &bool {
        &self.color_player_reticle
    }
    fn color_player_reticle_mut(&mut self) -> &mut bool {
        &mut self.color_player_reticle
    }
    fn sticky_center_offset(&self) -> &super::core::Vec3 {
        &self.sticky_center_offset
    }
    fn sticky_center_offset_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.sticky_center_offset
    }
}

impl super::entity::GameComponentDataTrait for AimAssistNodeComponentData {
}

impl super::entity::ComponentDataTrait for AimAssistNodeComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for AimAssistNodeComponentData {
}

impl super::core::DataBusPeerTrait for AimAssistNodeComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AimAssistNodeComponentData {
}

impl super::core::DataContainerTrait for AimAssistNodeComponentData {
}

pub static AIMASSISTNODECOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AimAssistNodeComponentData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AimAssistNodeComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AimAssistNodeComponentData, enabled),
            },
            FieldInfoData {
                name: "Team",
                flags: MemberInfoFlags::new(0),
                field_type: "TeamId",
                rust_offset: offset_of!(AimAssistNodeComponentData, team),
            },
            FieldInfoData {
                name: "GetTeamFromOwner",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AimAssistNodeComponentData, get_team_from_owner),
            },
            FieldInfoData {
                name: "ColorPlayerReticle",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AimAssistNodeComponentData, color_player_reticle),
            },
            FieldInfoData {
                name: "StickyCenterOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(AimAssistNodeComponentData, sticky_center_offset),
            },
        ],
    }),
    array_type: Some(AIMASSISTNODECOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AimAssistNodeComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        AIMASSISTNODECOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIMASSISTNODECOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AimAssistNodeComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("AimAssistNodeComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoldierBreathControlComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub time: f32,
    pub transition_time: f32,
    pub transition_curve_shape: f32,
    pub release_time: f32,
    pub penalty_multiplier: f32,
    pub penalty_timeout: f32,
}

pub trait SoldierBreathControlComponentDataTrait: super::entity::GameComponentDataTrait {
    fn time(&self) -> &f32;
    fn time_mut(&mut self) -> &mut f32;
    fn transition_time(&self) -> &f32;
    fn transition_time_mut(&mut self) -> &mut f32;
    fn transition_curve_shape(&self) -> &f32;
    fn transition_curve_shape_mut(&mut self) -> &mut f32;
    fn release_time(&self) -> &f32;
    fn release_time_mut(&mut self) -> &mut f32;
    fn penalty_multiplier(&self) -> &f32;
    fn penalty_multiplier_mut(&mut self) -> &mut f32;
    fn penalty_timeout(&self) -> &f32;
    fn penalty_timeout_mut(&mut self) -> &mut f32;
}

impl SoldierBreathControlComponentDataTrait for SoldierBreathControlComponentData {
    fn time(&self) -> &f32 {
        &self.time
    }
    fn time_mut(&mut self) -> &mut f32 {
        &mut self.time
    }
    fn transition_time(&self) -> &f32 {
        &self.transition_time
    }
    fn transition_time_mut(&mut self) -> &mut f32 {
        &mut self.transition_time
    }
    fn transition_curve_shape(&self) -> &f32 {
        &self.transition_curve_shape
    }
    fn transition_curve_shape_mut(&mut self) -> &mut f32 {
        &mut self.transition_curve_shape
    }
    fn release_time(&self) -> &f32 {
        &self.release_time
    }
    fn release_time_mut(&mut self) -> &mut f32 {
        &mut self.release_time
    }
    fn penalty_multiplier(&self) -> &f32 {
        &self.penalty_multiplier
    }
    fn penalty_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.penalty_multiplier
    }
    fn penalty_timeout(&self) -> &f32 {
        &self.penalty_timeout
    }
    fn penalty_timeout_mut(&mut self) -> &mut f32 {
        &mut self.penalty_timeout
    }
}

impl super::entity::GameComponentDataTrait for SoldierBreathControlComponentData {
}

impl super::entity::ComponentDataTrait for SoldierBreathControlComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for SoldierBreathControlComponentData {
}

impl super::core::DataBusPeerTrait for SoldierBreathControlComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SoldierBreathControlComponentData {
}

impl super::core::DataContainerTrait for SoldierBreathControlComponentData {
}

pub static SOLDIERBREATHCONTROLCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierBreathControlComponentData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierBreathControlComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Time",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierBreathControlComponentData, time),
            },
            FieldInfoData {
                name: "TransitionTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierBreathControlComponentData, transition_time),
            },
            FieldInfoData {
                name: "TransitionCurveShape",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierBreathControlComponentData, transition_curve_shape),
            },
            FieldInfoData {
                name: "ReleaseTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierBreathControlComponentData, release_time),
            },
            FieldInfoData {
                name: "PenaltyMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierBreathControlComponentData, penalty_multiplier),
            },
            FieldInfoData {
                name: "PenaltyTimeout",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierBreathControlComponentData, penalty_timeout),
            },
        ],
    }),
    array_type: Some(SOLDIERBREATHCONTROLCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SoldierBreathControlComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERBREATHCONTROLCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOLDIERBREATHCONTROLCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierBreathControlComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SoldierBreathControlComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoldierCustomizationComponentData {
    pub _glacier_base: super::game_shared::CharacterCustomizationComponentData,
    pub customization_weapon_override: Option<Arc<Mutex<dyn SoldierWeaponUnlockAssetTrait>>>,
}

pub trait SoldierCustomizationComponentDataTrait: super::game_shared::CharacterCustomizationComponentDataTrait {
    fn customization_weapon_override(&self) -> &Option<Arc<Mutex<dyn SoldierWeaponUnlockAssetTrait>>>;
    fn customization_weapon_override_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoldierWeaponUnlockAssetTrait>>>;
}

impl SoldierCustomizationComponentDataTrait for SoldierCustomizationComponentData {
    fn customization_weapon_override(&self) -> &Option<Arc<Mutex<dyn SoldierWeaponUnlockAssetTrait>>> {
        &self.customization_weapon_override
    }
    fn customization_weapon_override_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoldierWeaponUnlockAssetTrait>>> {
        &mut self.customization_weapon_override
    }
}

impl super::game_shared::CharacterCustomizationComponentDataTrait for SoldierCustomizationComponentData {
    fn customization(&self) -> &Option<Arc<Mutex<dyn super::game_shared::CharacterCustomizationAssetTrait>>> {
        self._glacier_base.customization()
    }
    fn customization_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::game_shared::CharacterCustomizationAssetTrait>>> {
        self._glacier_base.customization_mut()
    }
    fn visual_unlock(&self) -> &Option<Arc<Mutex<dyn super::game_shared::VisualUnlockAssetTrait>>> {
        self._glacier_base.visual_unlock()
    }
    fn visual_unlock_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::game_shared::VisualUnlockAssetTrait>>> {
        self._glacier_base.visual_unlock_mut()
    }
    fn character_lighting_enable(&self) -> &bool {
        self._glacier_base.character_lighting_enable()
    }
    fn character_lighting_enable_mut(&mut self) -> &mut bool {
        self._glacier_base.character_lighting_enable_mut()
    }
}

impl super::entity::GameComponentDataTrait for SoldierCustomizationComponentData {
}

impl super::entity::ComponentDataTrait for SoldierCustomizationComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for SoldierCustomizationComponentData {
}

impl super::core::DataBusPeerTrait for SoldierCustomizationComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SoldierCustomizationComponentData {
}

impl super::core::DataContainerTrait for SoldierCustomizationComponentData {
}

pub static SOLDIERCUSTOMIZATIONCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierCustomizationComponentData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::game_shared::CHARACTERCUSTOMIZATIONCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierCustomizationComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "CustomizationWeaponOverride",
                flags: MemberInfoFlags::new(0),
                field_type: "SoldierWeaponUnlockAsset",
                rust_offset: offset_of!(SoldierCustomizationComponentData, customization_weapon_override),
            },
        ],
    }),
    array_type: Some(SOLDIERCUSTOMIZATIONCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SoldierCustomizationComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERCUSTOMIZATIONCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOLDIERCUSTOMIZATIONCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierCustomizationComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SoldierCustomizationComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterSocketListAsset {
    pub _glacier_base: super::core::Asset,
    pub gameplay_sockets: Vec<Option<Arc<Mutex<dyn SocketDataTrait>>>>,
}

pub trait CharacterSocketListAssetTrait: super::core::AssetTrait {
    fn gameplay_sockets(&self) -> &Vec<Option<Arc<Mutex<dyn SocketDataTrait>>>>;
    fn gameplay_sockets_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn SocketDataTrait>>>>;
}

impl CharacterSocketListAssetTrait for CharacterSocketListAsset {
    fn gameplay_sockets(&self) -> &Vec<Option<Arc<Mutex<dyn SocketDataTrait>>>> {
        &self.gameplay_sockets
    }
    fn gameplay_sockets_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn SocketDataTrait>>>> {
        &mut self.gameplay_sockets
    }
}

impl super::core::AssetTrait for CharacterSocketListAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for CharacterSocketListAsset {
}

pub static CHARACTERSOCKETLISTASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterSocketListAsset",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterSocketListAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "GameplaySockets",
                flags: MemberInfoFlags::new(144),
                field_type: "SocketData-Array",
                rust_offset: offset_of!(CharacterSocketListAsset, gameplay_sockets),
            },
        ],
    }),
    array_type: Some(CHARACTERSOCKETLISTASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterSocketListAsset {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSOCKETLISTASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERSOCKETLISTASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterSocketListAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("CharacterSocketListAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SocketData {
    pub _glacier_base: super::core::DataContainer,
    pub excluded: bool,
    pub unlock_asset_guid: glacier_util::guid::Guid,
    pub belongs_to_unlock_asset_guid: glacier_util::guid::Guid,
    pub invert_unlock_check: bool,
    pub socket_hash: u32,
    pub bone_name: String,
    pub bone_id: i32,
    pub bone_rigid_transform: super::core::LinearTransform,
    pub available_objects: Vec<Option<Arc<Mutex<dyn SocketObjectDataBaseTrait>>>>,
    pub transform: super::core::LinearTransform,
    pub visibility: SocketVisibility,
    pub hide_by_zoom_transition: bool,
}

pub trait SocketDataTrait: super::core::DataContainerTrait {
    fn excluded(&self) -> &bool;
    fn excluded_mut(&mut self) -> &mut bool;
    fn unlock_asset_guid(&self) -> &glacier_util::guid::Guid;
    fn unlock_asset_guid_mut(&mut self) -> &mut glacier_util::guid::Guid;
    fn belongs_to_unlock_asset_guid(&self) -> &glacier_util::guid::Guid;
    fn belongs_to_unlock_asset_guid_mut(&mut self) -> &mut glacier_util::guid::Guid;
    fn invert_unlock_check(&self) -> &bool;
    fn invert_unlock_check_mut(&mut self) -> &mut bool;
    fn socket_hash(&self) -> &u32;
    fn socket_hash_mut(&mut self) -> &mut u32;
    fn bone_name(&self) -> &String;
    fn bone_name_mut(&mut self) -> &mut String;
    fn bone_id(&self) -> &i32;
    fn bone_id_mut(&mut self) -> &mut i32;
    fn bone_rigid_transform(&self) -> &super::core::LinearTransform;
    fn bone_rigid_transform_mut(&mut self) -> &mut super::core::LinearTransform;
    fn available_objects(&self) -> &Vec<Option<Arc<Mutex<dyn SocketObjectDataBaseTrait>>>>;
    fn available_objects_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn SocketObjectDataBaseTrait>>>>;
    fn transform(&self) -> &super::core::LinearTransform;
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform;
    fn visibility(&self) -> &SocketVisibility;
    fn visibility_mut(&mut self) -> &mut SocketVisibility;
    fn hide_by_zoom_transition(&self) -> &bool;
    fn hide_by_zoom_transition_mut(&mut self) -> &mut bool;
}

impl SocketDataTrait for SocketData {
    fn excluded(&self) -> &bool {
        &self.excluded
    }
    fn excluded_mut(&mut self) -> &mut bool {
        &mut self.excluded
    }
    fn unlock_asset_guid(&self) -> &glacier_util::guid::Guid {
        &self.unlock_asset_guid
    }
    fn unlock_asset_guid_mut(&mut self) -> &mut glacier_util::guid::Guid {
        &mut self.unlock_asset_guid
    }
    fn belongs_to_unlock_asset_guid(&self) -> &glacier_util::guid::Guid {
        &self.belongs_to_unlock_asset_guid
    }
    fn belongs_to_unlock_asset_guid_mut(&mut self) -> &mut glacier_util::guid::Guid {
        &mut self.belongs_to_unlock_asset_guid
    }
    fn invert_unlock_check(&self) -> &bool {
        &self.invert_unlock_check
    }
    fn invert_unlock_check_mut(&mut self) -> &mut bool {
        &mut self.invert_unlock_check
    }
    fn socket_hash(&self) -> &u32 {
        &self.socket_hash
    }
    fn socket_hash_mut(&mut self) -> &mut u32 {
        &mut self.socket_hash
    }
    fn bone_name(&self) -> &String {
        &self.bone_name
    }
    fn bone_name_mut(&mut self) -> &mut String {
        &mut self.bone_name
    }
    fn bone_id(&self) -> &i32 {
        &self.bone_id
    }
    fn bone_id_mut(&mut self) -> &mut i32 {
        &mut self.bone_id
    }
    fn bone_rigid_transform(&self) -> &super::core::LinearTransform {
        &self.bone_rigid_transform
    }
    fn bone_rigid_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.bone_rigid_transform
    }
    fn available_objects(&self) -> &Vec<Option<Arc<Mutex<dyn SocketObjectDataBaseTrait>>>> {
        &self.available_objects
    }
    fn available_objects_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn SocketObjectDataBaseTrait>>>> {
        &mut self.available_objects
    }
    fn transform(&self) -> &super::core::LinearTransform {
        &self.transform
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.transform
    }
    fn visibility(&self) -> &SocketVisibility {
        &self.visibility
    }
    fn visibility_mut(&mut self) -> &mut SocketVisibility {
        &mut self.visibility
    }
    fn hide_by_zoom_transition(&self) -> &bool {
        &self.hide_by_zoom_transition
    }
    fn hide_by_zoom_transition_mut(&mut self) -> &mut bool {
        &mut self.hide_by_zoom_transition
    }
}

impl super::core::DataContainerTrait for SocketData {
}

pub static SOCKETDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SocketData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SocketData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Excluded",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SocketData, excluded),
            },
            FieldInfoData {
                name: "UnlockAssetGuid",
                flags: MemberInfoFlags::new(0),
                field_type: "Guid",
                rust_offset: offset_of!(SocketData, unlock_asset_guid),
            },
            FieldInfoData {
                name: "BelongsToUnlockAssetGuid",
                flags: MemberInfoFlags::new(0),
                field_type: "Guid",
                rust_offset: offset_of!(SocketData, belongs_to_unlock_asset_guid),
            },
            FieldInfoData {
                name: "InvertUnlockCheck",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SocketData, invert_unlock_check),
            },
            FieldInfoData {
                name: "SocketHash",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(SocketData, socket_hash),
            },
            FieldInfoData {
                name: "BoneName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(SocketData, bone_name),
            },
            FieldInfoData {
                name: "BoneId",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SocketData, bone_id),
            },
            FieldInfoData {
                name: "BoneRigidTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(SocketData, bone_rigid_transform),
            },
            FieldInfoData {
                name: "AvailableObjects",
                flags: MemberInfoFlags::new(144),
                field_type: "SocketObjectDataBase-Array",
                rust_offset: offset_of!(SocketData, available_objects),
            },
            FieldInfoData {
                name: "Transform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(SocketData, transform),
            },
            FieldInfoData {
                name: "Visibility",
                flags: MemberInfoFlags::new(0),
                field_type: "SocketVisibility",
                rust_offset: offset_of!(SocketData, visibility),
            },
            FieldInfoData {
                name: "HideByZoomTransition",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SocketData, hide_by_zoom_transition),
            },
        ],
    }),
    array_type: Some(SOCKETDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SocketData {
    fn type_info(&self) -> &'static TypeInfo {
        SOCKETDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOCKETDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SocketData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SocketData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum SocketVisibility {
    #[default]
    SocketVisibility_Never = 0,
    SocketVisibility_Always = 1,
    SocketVisibility_EnableByModifier = 2,
    SocketVisibility_EnableOnlyOnCurrentWeapon = 3,
    SocketVisibility_EnableOnlyOnInactiveWeapons = 4,
}

pub static SOCKETVISIBILITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SocketVisibility",
    flags: MemberInfoFlags::new(49429),
    module: "SoldierShared",
    data: TypeInfoData::Enum,
    array_type: Some(SOCKETVISIBILITY_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SocketVisibility {
    fn type_info(&self) -> &'static TypeInfo {
        SOCKETVISIBILITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SOCKETVISIBILITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SocketVisibility-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SocketVisibility"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SocketGroup {
    pub _glacier_base: super::core::Asset,
}

pub trait SocketGroupTrait: super::core::AssetTrait {
}

impl SocketGroupTrait for SocketGroup {
}

impl super::core::AssetTrait for SocketGroup {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for SocketGroup {
}

pub static SOCKETGROUP_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SocketGroup",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SocketGroup as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SOCKETGROUP_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SocketGroup {
    fn type_info(&self) -> &'static TypeInfo {
        SOCKETGROUP_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOCKETGROUP_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SocketGroup-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SocketGroup"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SocketObjectDataBase {
    pub _glacier_base: super::core::DataContainer,
}

pub trait SocketObjectDataBaseTrait: super::core::DataContainerTrait {
}

impl SocketObjectDataBaseTrait for SocketObjectDataBase {
}

impl super::core::DataContainerTrait for SocketObjectDataBase {
}

pub static SOCKETOBJECTDATABASE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SocketObjectDataBase",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SocketObjectDataBase as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SOCKETOBJECTDATABASE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SocketObjectDataBase {
    fn type_info(&self) -> &'static TypeInfo {
        SOCKETOBJECTDATABASE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOCKETOBJECTDATABASE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SocketObjectDataBase-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SocketObjectDataBase"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MovementComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub movement_binding: MovementComponentBinding,
    pub movement_binding_shared: MovementComponentSharedBinding,
    pub feed_trajectory_corrections_through_game_state: bool,
    pub client_side_physics_controlled: bool,
    pub clamp_velocity: f32,
    pub move_to_target_list: Vec<MoveToTargetData>,
    pub move_to_transform: super::core::LinearTransform,
    pub move_to_target_index: i32,
    pub enable_animation_controlled: bool,
    pub enable_animated_camera: bool,
    pub enable_gravity_active: bool,
}

pub trait MovementComponentDataTrait: super::entity::GameComponentDataTrait {
    fn movement_binding(&self) -> &MovementComponentBinding;
    fn movement_binding_mut(&mut self) -> &mut MovementComponentBinding;
    fn movement_binding_shared(&self) -> &MovementComponentSharedBinding;
    fn movement_binding_shared_mut(&mut self) -> &mut MovementComponentSharedBinding;
    fn feed_trajectory_corrections_through_game_state(&self) -> &bool;
    fn feed_trajectory_corrections_through_game_state_mut(&mut self) -> &mut bool;
    fn client_side_physics_controlled(&self) -> &bool;
    fn client_side_physics_controlled_mut(&mut self) -> &mut bool;
    fn clamp_velocity(&self) -> &f32;
    fn clamp_velocity_mut(&mut self) -> &mut f32;
    fn move_to_target_list(&self) -> &Vec<MoveToTargetData>;
    fn move_to_target_list_mut(&mut self) -> &mut Vec<MoveToTargetData>;
    fn move_to_transform(&self) -> &super::core::LinearTransform;
    fn move_to_transform_mut(&mut self) -> &mut super::core::LinearTransform;
    fn move_to_target_index(&self) -> &i32;
    fn move_to_target_index_mut(&mut self) -> &mut i32;
    fn enable_animation_controlled(&self) -> &bool;
    fn enable_animation_controlled_mut(&mut self) -> &mut bool;
    fn enable_animated_camera(&self) -> &bool;
    fn enable_animated_camera_mut(&mut self) -> &mut bool;
    fn enable_gravity_active(&self) -> &bool;
    fn enable_gravity_active_mut(&mut self) -> &mut bool;
}

impl MovementComponentDataTrait for MovementComponentData {
    fn movement_binding(&self) -> &MovementComponentBinding {
        &self.movement_binding
    }
    fn movement_binding_mut(&mut self) -> &mut MovementComponentBinding {
        &mut self.movement_binding
    }
    fn movement_binding_shared(&self) -> &MovementComponentSharedBinding {
        &self.movement_binding_shared
    }
    fn movement_binding_shared_mut(&mut self) -> &mut MovementComponentSharedBinding {
        &mut self.movement_binding_shared
    }
    fn feed_trajectory_corrections_through_game_state(&self) -> &bool {
        &self.feed_trajectory_corrections_through_game_state
    }
    fn feed_trajectory_corrections_through_game_state_mut(&mut self) -> &mut bool {
        &mut self.feed_trajectory_corrections_through_game_state
    }
    fn client_side_physics_controlled(&self) -> &bool {
        &self.client_side_physics_controlled
    }
    fn client_side_physics_controlled_mut(&mut self) -> &mut bool {
        &mut self.client_side_physics_controlled
    }
    fn clamp_velocity(&self) -> &f32 {
        &self.clamp_velocity
    }
    fn clamp_velocity_mut(&mut self) -> &mut f32 {
        &mut self.clamp_velocity
    }
    fn move_to_target_list(&self) -> &Vec<MoveToTargetData> {
        &self.move_to_target_list
    }
    fn move_to_target_list_mut(&mut self) -> &mut Vec<MoveToTargetData> {
        &mut self.move_to_target_list
    }
    fn move_to_transform(&self) -> &super::core::LinearTransform {
        &self.move_to_transform
    }
    fn move_to_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.move_to_transform
    }
    fn move_to_target_index(&self) -> &i32 {
        &self.move_to_target_index
    }
    fn move_to_target_index_mut(&mut self) -> &mut i32 {
        &mut self.move_to_target_index
    }
    fn enable_animation_controlled(&self) -> &bool {
        &self.enable_animation_controlled
    }
    fn enable_animation_controlled_mut(&mut self) -> &mut bool {
        &mut self.enable_animation_controlled
    }
    fn enable_animated_camera(&self) -> &bool {
        &self.enable_animated_camera
    }
    fn enable_animated_camera_mut(&mut self) -> &mut bool {
        &mut self.enable_animated_camera
    }
    fn enable_gravity_active(&self) -> &bool {
        &self.enable_gravity_active
    }
    fn enable_gravity_active_mut(&mut self) -> &mut bool {
        &mut self.enable_gravity_active
    }
}

impl super::entity::GameComponentDataTrait for MovementComponentData {
}

impl super::entity::ComponentDataTrait for MovementComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for MovementComponentData {
}

impl super::core::DataBusPeerTrait for MovementComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for MovementComponentData {
}

impl super::core::DataContainerTrait for MovementComponentData {
}

pub static MOVEMENTCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MovementComponentData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MovementComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MovementBinding",
                flags: MemberInfoFlags::new(0),
                field_type: "MovementComponentBinding",
                rust_offset: offset_of!(MovementComponentData, movement_binding),
            },
            FieldInfoData {
                name: "MovementBindingShared",
                flags: MemberInfoFlags::new(0),
                field_type: "MovementComponentSharedBinding",
                rust_offset: offset_of!(MovementComponentData, movement_binding_shared),
            },
            FieldInfoData {
                name: "FeedTrajectoryCorrectionsThroughGameState",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MovementComponentData, feed_trajectory_corrections_through_game_state),
            },
            FieldInfoData {
                name: "ClientSidePhysicsControlled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MovementComponentData, client_side_physics_controlled),
            },
            FieldInfoData {
                name: "ClampVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MovementComponentData, clamp_velocity),
            },
            FieldInfoData {
                name: "MoveToTargetList",
                flags: MemberInfoFlags::new(144),
                field_type: "MoveToTargetData-Array",
                rust_offset: offset_of!(MovementComponentData, move_to_target_list),
            },
            FieldInfoData {
                name: "MoveToTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(MovementComponentData, move_to_transform),
            },
            FieldInfoData {
                name: "MoveToTargetIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MovementComponentData, move_to_target_index),
            },
            FieldInfoData {
                name: "EnableAnimationControlled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MovementComponentData, enable_animation_controlled),
            },
            FieldInfoData {
                name: "EnableAnimatedCamera",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MovementComponentData, enable_animated_camera),
            },
            FieldInfoData {
                name: "EnableGravityActive",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MovementComponentData, enable_gravity_active),
            },
        ],
    }),
    array_type: Some(MOVEMENTCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for MovementComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        MOVEMENTCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MOVEMENTCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MovementComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("MovementComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MoveToTargetData {
    pub duration_of_move: f32,
    pub pause_time_after_move: f32,
    pub slow_down_factor_in_pause: f32,
    pub move_at_constant_speed: f32,
    pub rotation_speed: f32,
    pub snap_to_movement_direction: bool,
    pub blend_acceleration: f32,
    pub distance_tolerance: f32,
    pub gravity_active: bool,
}

pub trait MoveToTargetDataTrait: TypeObject {
    fn duration_of_move(&self) -> &f32;
    fn duration_of_move_mut(&mut self) -> &mut f32;
    fn pause_time_after_move(&self) -> &f32;
    fn pause_time_after_move_mut(&mut self) -> &mut f32;
    fn slow_down_factor_in_pause(&self) -> &f32;
    fn slow_down_factor_in_pause_mut(&mut self) -> &mut f32;
    fn move_at_constant_speed(&self) -> &f32;
    fn move_at_constant_speed_mut(&mut self) -> &mut f32;
    fn rotation_speed(&self) -> &f32;
    fn rotation_speed_mut(&mut self) -> &mut f32;
    fn snap_to_movement_direction(&self) -> &bool;
    fn snap_to_movement_direction_mut(&mut self) -> &mut bool;
    fn blend_acceleration(&self) -> &f32;
    fn blend_acceleration_mut(&mut self) -> &mut f32;
    fn distance_tolerance(&self) -> &f32;
    fn distance_tolerance_mut(&mut self) -> &mut f32;
    fn gravity_active(&self) -> &bool;
    fn gravity_active_mut(&mut self) -> &mut bool;
}

impl MoveToTargetDataTrait for MoveToTargetData {
    fn duration_of_move(&self) -> &f32 {
        &self.duration_of_move
    }
    fn duration_of_move_mut(&mut self) -> &mut f32 {
        &mut self.duration_of_move
    }
    fn pause_time_after_move(&self) -> &f32 {
        &self.pause_time_after_move
    }
    fn pause_time_after_move_mut(&mut self) -> &mut f32 {
        &mut self.pause_time_after_move
    }
    fn slow_down_factor_in_pause(&self) -> &f32 {
        &self.slow_down_factor_in_pause
    }
    fn slow_down_factor_in_pause_mut(&mut self) -> &mut f32 {
        &mut self.slow_down_factor_in_pause
    }
    fn move_at_constant_speed(&self) -> &f32 {
        &self.move_at_constant_speed
    }
    fn move_at_constant_speed_mut(&mut self) -> &mut f32 {
        &mut self.move_at_constant_speed
    }
    fn rotation_speed(&self) -> &f32 {
        &self.rotation_speed
    }
    fn rotation_speed_mut(&mut self) -> &mut f32 {
        &mut self.rotation_speed
    }
    fn snap_to_movement_direction(&self) -> &bool {
        &self.snap_to_movement_direction
    }
    fn snap_to_movement_direction_mut(&mut self) -> &mut bool {
        &mut self.snap_to_movement_direction
    }
    fn blend_acceleration(&self) -> &f32 {
        &self.blend_acceleration
    }
    fn blend_acceleration_mut(&mut self) -> &mut f32 {
        &mut self.blend_acceleration
    }
    fn distance_tolerance(&self) -> &f32 {
        &self.distance_tolerance
    }
    fn distance_tolerance_mut(&mut self) -> &mut f32 {
        &mut self.distance_tolerance
    }
    fn gravity_active(&self) -> &bool {
        &self.gravity_active
    }
    fn gravity_active_mut(&mut self) -> &mut bool {
        &mut self.gravity_active
    }
}

pub static MOVETOTARGETDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MoveToTargetData",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MoveToTargetData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DurationOfMove",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MoveToTargetData, duration_of_move),
            },
            FieldInfoData {
                name: "PauseTimeAfterMove",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MoveToTargetData, pause_time_after_move),
            },
            FieldInfoData {
                name: "SlowDownFactorInPause",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MoveToTargetData, slow_down_factor_in_pause),
            },
            FieldInfoData {
                name: "MoveAtConstantSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MoveToTargetData, move_at_constant_speed),
            },
            FieldInfoData {
                name: "RotationSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MoveToTargetData, rotation_speed),
            },
            FieldInfoData {
                name: "SnapToMovementDirection",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MoveToTargetData, snap_to_movement_direction),
            },
            FieldInfoData {
                name: "BlendAcceleration",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MoveToTargetData, blend_acceleration),
            },
            FieldInfoData {
                name: "DistanceTolerance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MoveToTargetData, distance_tolerance),
            },
            FieldInfoData {
                name: "GravityActive",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MoveToTargetData, gravity_active),
            },
        ],
    }),
    array_type: Some(MOVETOTARGETDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for MoveToTargetData {
    fn type_info(&self) -> &'static TypeInfo {
        MOVETOTARGETDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MOVETOTARGETDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MoveToTargetData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("MoveToTargetData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MovementComponentSharedBinding {
    pub moving_to_target: super::ant::AntRef,
}

pub trait MovementComponentSharedBindingTrait: TypeObject {
    fn moving_to_target(&self) -> &super::ant::AntRef;
    fn moving_to_target_mut(&mut self) -> &mut super::ant::AntRef;
}

impl MovementComponentSharedBindingTrait for MovementComponentSharedBinding {
    fn moving_to_target(&self) -> &super::ant::AntRef {
        &self.moving_to_target
    }
    fn moving_to_target_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.moving_to_target
    }
}

pub static MOVEMENTCOMPONENTSHAREDBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MovementComponentSharedBinding",
    flags: MemberInfoFlags::new(32841),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MovementComponentSharedBinding as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MovingToTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(MovementComponentSharedBinding, moving_to_target),
            },
        ],
    }),
    array_type: Some(MOVEMENTCOMPONENTSHAREDBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for MovementComponentSharedBinding {
    fn type_info(&self) -> &'static TypeInfo {
        MOVEMENTCOMPONENTSHAREDBINDING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MOVEMENTCOMPONENTSHAREDBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MovementComponentSharedBinding-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("MovementComponentSharedBinding"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MovementComponentBinding {
    pub animation_controlled: super::ant::AntRef,
    pub feedback_collisions: super::ant::AntRef,
    pub disable_animation_controlled_camera: super::ant::AntRef,
    pub disable_animation_control_exit_velocity: super::ant::AntRef,
    pub force_velocity_mode: super::ant::AntRef,
    pub keep_gravity_active: super::ant::AntRef,
    pub trajectory_correction_position: super::ant::AntRef,
    pub trajectory_needs_correction: super::ant::AntRef,
}

pub trait MovementComponentBindingTrait: TypeObject {
    fn animation_controlled(&self) -> &super::ant::AntRef;
    fn animation_controlled_mut(&mut self) -> &mut super::ant::AntRef;
    fn feedback_collisions(&self) -> &super::ant::AntRef;
    fn feedback_collisions_mut(&mut self) -> &mut super::ant::AntRef;
    fn disable_animation_controlled_camera(&self) -> &super::ant::AntRef;
    fn disable_animation_controlled_camera_mut(&mut self) -> &mut super::ant::AntRef;
    fn disable_animation_control_exit_velocity(&self) -> &super::ant::AntRef;
    fn disable_animation_control_exit_velocity_mut(&mut self) -> &mut super::ant::AntRef;
    fn force_velocity_mode(&self) -> &super::ant::AntRef;
    fn force_velocity_mode_mut(&mut self) -> &mut super::ant::AntRef;
    fn keep_gravity_active(&self) -> &super::ant::AntRef;
    fn keep_gravity_active_mut(&mut self) -> &mut super::ant::AntRef;
    fn trajectory_correction_position(&self) -> &super::ant::AntRef;
    fn trajectory_correction_position_mut(&mut self) -> &mut super::ant::AntRef;
    fn trajectory_needs_correction(&self) -> &super::ant::AntRef;
    fn trajectory_needs_correction_mut(&mut self) -> &mut super::ant::AntRef;
}

impl MovementComponentBindingTrait for MovementComponentBinding {
    fn animation_controlled(&self) -> &super::ant::AntRef {
        &self.animation_controlled
    }
    fn animation_controlled_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.animation_controlled
    }
    fn feedback_collisions(&self) -> &super::ant::AntRef {
        &self.feedback_collisions
    }
    fn feedback_collisions_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.feedback_collisions
    }
    fn disable_animation_controlled_camera(&self) -> &super::ant::AntRef {
        &self.disable_animation_controlled_camera
    }
    fn disable_animation_controlled_camera_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.disable_animation_controlled_camera
    }
    fn disable_animation_control_exit_velocity(&self) -> &super::ant::AntRef {
        &self.disable_animation_control_exit_velocity
    }
    fn disable_animation_control_exit_velocity_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.disable_animation_control_exit_velocity
    }
    fn force_velocity_mode(&self) -> &super::ant::AntRef {
        &self.force_velocity_mode
    }
    fn force_velocity_mode_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.force_velocity_mode
    }
    fn keep_gravity_active(&self) -> &super::ant::AntRef {
        &self.keep_gravity_active
    }
    fn keep_gravity_active_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.keep_gravity_active
    }
    fn trajectory_correction_position(&self) -> &super::ant::AntRef {
        &self.trajectory_correction_position
    }
    fn trajectory_correction_position_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.trajectory_correction_position
    }
    fn trajectory_needs_correction(&self) -> &super::ant::AntRef {
        &self.trajectory_needs_correction
    }
    fn trajectory_needs_correction_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.trajectory_needs_correction
    }
}

pub static MOVEMENTCOMPONENTBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MovementComponentBinding",
    flags: MemberInfoFlags::new(32841),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MovementComponentBinding as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AnimationControlled",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(MovementComponentBinding, animation_controlled),
            },
            FieldInfoData {
                name: "FeedbackCollisions",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(MovementComponentBinding, feedback_collisions),
            },
            FieldInfoData {
                name: "DisableAnimationControlledCamera",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(MovementComponentBinding, disable_animation_controlled_camera),
            },
            FieldInfoData {
                name: "DisableAnimationControlExitVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(MovementComponentBinding, disable_animation_control_exit_velocity),
            },
            FieldInfoData {
                name: "ForceVelocityMode",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(MovementComponentBinding, force_velocity_mode),
            },
            FieldInfoData {
                name: "KeepGravityActive",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(MovementComponentBinding, keep_gravity_active),
            },
            FieldInfoData {
                name: "TrajectoryCorrectionPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(MovementComponentBinding, trajectory_correction_position),
            },
            FieldInfoData {
                name: "TrajectoryNeedsCorrection",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(MovementComponentBinding, trajectory_needs_correction),
            },
        ],
    }),
    array_type: Some(MOVEMENTCOMPONENTBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for MovementComponentBinding {
    fn type_info(&self) -> &'static TypeInfo {
        MOVEMENTCOMPONENTBINDING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MOVEMENTCOMPONENTBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MovementComponentBinding-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("MovementComponentBinding"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoldierCameraComponentData {
    pub _glacier_base: super::game_shared::CharacterCameraComponentData,
    pub explosion_impulse_multiplier: f32,
    pub camera_cull_sphere_radius: f32,
    pub stand_camera_cull_sqr_distance: f32,
    pub stand_camera_cull_y_distance: f32,
    pub crouch_camera_cull_sqr_distance: f32,
    pub crouch_camera_cull_y_distance: f32,
    pub prone_camera_cull_sqr_distance: f32,
    pub prone_camera_cull_y_distance: f32,
    pub dead_camera_cull_y_distance: f32,
    pub disable_aiming: bool,
    pub authoritative_eye_position: bool,
    pub enable_camera_bob_non_first_person: bool,
    pub override_transform: super::core::LinearTransform,
    pub camera1p_binding: Camera1pBinding,
    pub camera_common_binding: CameraCommonBinding,
    pub force_field_of_view: f32,
    pub roll: f32,
    pub third_person_camera_arm_length: f32,
    pub third_person_camera_local_transform: super::core::LinearTransform,
    pub third_person_camera_free_transform: super::core::LinearTransform,
    pub third_person_camera_free_transform_blend_value: f32,
}

pub trait SoldierCameraComponentDataTrait: super::game_shared::CharacterCameraComponentDataTrait {
    fn explosion_impulse_multiplier(&self) -> &f32;
    fn explosion_impulse_multiplier_mut(&mut self) -> &mut f32;
    fn camera_cull_sphere_radius(&self) -> &f32;
    fn camera_cull_sphere_radius_mut(&mut self) -> &mut f32;
    fn stand_camera_cull_sqr_distance(&self) -> &f32;
    fn stand_camera_cull_sqr_distance_mut(&mut self) -> &mut f32;
    fn stand_camera_cull_y_distance(&self) -> &f32;
    fn stand_camera_cull_y_distance_mut(&mut self) -> &mut f32;
    fn crouch_camera_cull_sqr_distance(&self) -> &f32;
    fn crouch_camera_cull_sqr_distance_mut(&mut self) -> &mut f32;
    fn crouch_camera_cull_y_distance(&self) -> &f32;
    fn crouch_camera_cull_y_distance_mut(&mut self) -> &mut f32;
    fn prone_camera_cull_sqr_distance(&self) -> &f32;
    fn prone_camera_cull_sqr_distance_mut(&mut self) -> &mut f32;
    fn prone_camera_cull_y_distance(&self) -> &f32;
    fn prone_camera_cull_y_distance_mut(&mut self) -> &mut f32;
    fn dead_camera_cull_y_distance(&self) -> &f32;
    fn dead_camera_cull_y_distance_mut(&mut self) -> &mut f32;
    fn disable_aiming(&self) -> &bool;
    fn disable_aiming_mut(&mut self) -> &mut bool;
    fn authoritative_eye_position(&self) -> &bool;
    fn authoritative_eye_position_mut(&mut self) -> &mut bool;
    fn enable_camera_bob_non_first_person(&self) -> &bool;
    fn enable_camera_bob_non_first_person_mut(&mut self) -> &mut bool;
    fn override_transform(&self) -> &super::core::LinearTransform;
    fn override_transform_mut(&mut self) -> &mut super::core::LinearTransform;
    fn camera1p_binding(&self) -> &Camera1pBinding;
    fn camera1p_binding_mut(&mut self) -> &mut Camera1pBinding;
    fn camera_common_binding(&self) -> &CameraCommonBinding;
    fn camera_common_binding_mut(&mut self) -> &mut CameraCommonBinding;
    fn force_field_of_view(&self) -> &f32;
    fn force_field_of_view_mut(&mut self) -> &mut f32;
    fn roll(&self) -> &f32;
    fn roll_mut(&mut self) -> &mut f32;
    fn third_person_camera_arm_length(&self) -> &f32;
    fn third_person_camera_arm_length_mut(&mut self) -> &mut f32;
    fn third_person_camera_local_transform(&self) -> &super::core::LinearTransform;
    fn third_person_camera_local_transform_mut(&mut self) -> &mut super::core::LinearTransform;
    fn third_person_camera_free_transform(&self) -> &super::core::LinearTransform;
    fn third_person_camera_free_transform_mut(&mut self) -> &mut super::core::LinearTransform;
    fn third_person_camera_free_transform_blend_value(&self) -> &f32;
    fn third_person_camera_free_transform_blend_value_mut(&mut self) -> &mut f32;
}

impl SoldierCameraComponentDataTrait for SoldierCameraComponentData {
    fn explosion_impulse_multiplier(&self) -> &f32 {
        &self.explosion_impulse_multiplier
    }
    fn explosion_impulse_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.explosion_impulse_multiplier
    }
    fn camera_cull_sphere_radius(&self) -> &f32 {
        &self.camera_cull_sphere_radius
    }
    fn camera_cull_sphere_radius_mut(&mut self) -> &mut f32 {
        &mut self.camera_cull_sphere_radius
    }
    fn stand_camera_cull_sqr_distance(&self) -> &f32 {
        &self.stand_camera_cull_sqr_distance
    }
    fn stand_camera_cull_sqr_distance_mut(&mut self) -> &mut f32 {
        &mut self.stand_camera_cull_sqr_distance
    }
    fn stand_camera_cull_y_distance(&self) -> &f32 {
        &self.stand_camera_cull_y_distance
    }
    fn stand_camera_cull_y_distance_mut(&mut self) -> &mut f32 {
        &mut self.stand_camera_cull_y_distance
    }
    fn crouch_camera_cull_sqr_distance(&self) -> &f32 {
        &self.crouch_camera_cull_sqr_distance
    }
    fn crouch_camera_cull_sqr_distance_mut(&mut self) -> &mut f32 {
        &mut self.crouch_camera_cull_sqr_distance
    }
    fn crouch_camera_cull_y_distance(&self) -> &f32 {
        &self.crouch_camera_cull_y_distance
    }
    fn crouch_camera_cull_y_distance_mut(&mut self) -> &mut f32 {
        &mut self.crouch_camera_cull_y_distance
    }
    fn prone_camera_cull_sqr_distance(&self) -> &f32 {
        &self.prone_camera_cull_sqr_distance
    }
    fn prone_camera_cull_sqr_distance_mut(&mut self) -> &mut f32 {
        &mut self.prone_camera_cull_sqr_distance
    }
    fn prone_camera_cull_y_distance(&self) -> &f32 {
        &self.prone_camera_cull_y_distance
    }
    fn prone_camera_cull_y_distance_mut(&mut self) -> &mut f32 {
        &mut self.prone_camera_cull_y_distance
    }
    fn dead_camera_cull_y_distance(&self) -> &f32 {
        &self.dead_camera_cull_y_distance
    }
    fn dead_camera_cull_y_distance_mut(&mut self) -> &mut f32 {
        &mut self.dead_camera_cull_y_distance
    }
    fn disable_aiming(&self) -> &bool {
        &self.disable_aiming
    }
    fn disable_aiming_mut(&mut self) -> &mut bool {
        &mut self.disable_aiming
    }
    fn authoritative_eye_position(&self) -> &bool {
        &self.authoritative_eye_position
    }
    fn authoritative_eye_position_mut(&mut self) -> &mut bool {
        &mut self.authoritative_eye_position
    }
    fn enable_camera_bob_non_first_person(&self) -> &bool {
        &self.enable_camera_bob_non_first_person
    }
    fn enable_camera_bob_non_first_person_mut(&mut self) -> &mut bool {
        &mut self.enable_camera_bob_non_first_person
    }
    fn override_transform(&self) -> &super::core::LinearTransform {
        &self.override_transform
    }
    fn override_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.override_transform
    }
    fn camera1p_binding(&self) -> &Camera1pBinding {
        &self.camera1p_binding
    }
    fn camera1p_binding_mut(&mut self) -> &mut Camera1pBinding {
        &mut self.camera1p_binding
    }
    fn camera_common_binding(&self) -> &CameraCommonBinding {
        &self.camera_common_binding
    }
    fn camera_common_binding_mut(&mut self) -> &mut CameraCommonBinding {
        &mut self.camera_common_binding
    }
    fn force_field_of_view(&self) -> &f32 {
        &self.force_field_of_view
    }
    fn force_field_of_view_mut(&mut self) -> &mut f32 {
        &mut self.force_field_of_view
    }
    fn roll(&self) -> &f32 {
        &self.roll
    }
    fn roll_mut(&mut self) -> &mut f32 {
        &mut self.roll
    }
    fn third_person_camera_arm_length(&self) -> &f32 {
        &self.third_person_camera_arm_length
    }
    fn third_person_camera_arm_length_mut(&mut self) -> &mut f32 {
        &mut self.third_person_camera_arm_length
    }
    fn third_person_camera_local_transform(&self) -> &super::core::LinearTransform {
        &self.third_person_camera_local_transform
    }
    fn third_person_camera_local_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.third_person_camera_local_transform
    }
    fn third_person_camera_free_transform(&self) -> &super::core::LinearTransform {
        &self.third_person_camera_free_transform
    }
    fn third_person_camera_free_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.third_person_camera_free_transform
    }
    fn third_person_camera_free_transform_blend_value(&self) -> &f32 {
        &self.third_person_camera_free_transform_blend_value
    }
    fn third_person_camera_free_transform_blend_value_mut(&mut self) -> &mut f32 {
        &mut self.third_person_camera_free_transform_blend_value
    }
}

impl super::game_shared::CharacterCameraComponentDataTrait for SoldierCameraComponentData {
    fn cameras(&self) -> &Vec<Option<Arc<Mutex<dyn super::gameplay_sim::CameraDataTrait>>>> {
        self._glacier_base.cameras()
    }
    fn cameras_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::gameplay_sim::CameraDataTrait>>>> {
        self._glacier_base.cameras_mut()
    }
}

impl super::entity::GameComponentDataTrait for SoldierCameraComponentData {
}

impl super::entity::ComponentDataTrait for SoldierCameraComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for SoldierCameraComponentData {
}

impl super::core::DataBusPeerTrait for SoldierCameraComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SoldierCameraComponentData {
}

impl super::core::DataContainerTrait for SoldierCameraComponentData {
}

pub static SOLDIERCAMERACOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierCameraComponentData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::game_shared::CHARACTERCAMERACOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierCameraComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ExplosionImpulseMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierCameraComponentData, explosion_impulse_multiplier),
            },
            FieldInfoData {
                name: "CameraCullSphereRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierCameraComponentData, camera_cull_sphere_radius),
            },
            FieldInfoData {
                name: "StandCameraCullSqrDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierCameraComponentData, stand_camera_cull_sqr_distance),
            },
            FieldInfoData {
                name: "StandCameraCullYDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierCameraComponentData, stand_camera_cull_y_distance),
            },
            FieldInfoData {
                name: "CrouchCameraCullSqrDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierCameraComponentData, crouch_camera_cull_sqr_distance),
            },
            FieldInfoData {
                name: "CrouchCameraCullYDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierCameraComponentData, crouch_camera_cull_y_distance),
            },
            FieldInfoData {
                name: "ProneCameraCullSqrDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierCameraComponentData, prone_camera_cull_sqr_distance),
            },
            FieldInfoData {
                name: "ProneCameraCullYDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierCameraComponentData, prone_camera_cull_y_distance),
            },
            FieldInfoData {
                name: "DeadCameraCullYDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierCameraComponentData, dead_camera_cull_y_distance),
            },
            FieldInfoData {
                name: "DisableAiming",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierCameraComponentData, disable_aiming),
            },
            FieldInfoData {
                name: "AuthoritativeEyePosition",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierCameraComponentData, authoritative_eye_position),
            },
            FieldInfoData {
                name: "EnableCameraBobNonFirstPerson",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierCameraComponentData, enable_camera_bob_non_first_person),
            },
            FieldInfoData {
                name: "OverrideTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(SoldierCameraComponentData, override_transform),
            },
            FieldInfoData {
                name: "Camera1pBinding",
                flags: MemberInfoFlags::new(0),
                field_type: "Camera1pBinding",
                rust_offset: offset_of!(SoldierCameraComponentData, camera1p_binding),
            },
            FieldInfoData {
                name: "CameraCommonBinding",
                flags: MemberInfoFlags::new(0),
                field_type: "CameraCommonBinding",
                rust_offset: offset_of!(SoldierCameraComponentData, camera_common_binding),
            },
            FieldInfoData {
                name: "ForceFieldOfView",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierCameraComponentData, force_field_of_view),
            },
            FieldInfoData {
                name: "Roll",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierCameraComponentData, roll),
            },
            FieldInfoData {
                name: "ThirdPersonCameraArmLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierCameraComponentData, third_person_camera_arm_length),
            },
            FieldInfoData {
                name: "ThirdPersonCameraLocalTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(SoldierCameraComponentData, third_person_camera_local_transform),
            },
            FieldInfoData {
                name: "ThirdPersonCameraFreeTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(SoldierCameraComponentData, third_person_camera_free_transform),
            },
            FieldInfoData {
                name: "ThirdPersonCameraFreeTransformBlendValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierCameraComponentData, third_person_camera_free_transform_blend_value),
            },
        ],
    }),
    array_type: Some(SOLDIERCAMERACOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SoldierCameraComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERCAMERACOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOLDIERCAMERACOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierCameraComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SoldierCameraComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CameraCommonBinding {
    pub first_person_camera_height: super::ant::AntRef,
    pub animated_camera_blend_time: super::ant::AntRef,
}

pub trait CameraCommonBindingTrait: TypeObject {
    fn first_person_camera_height(&self) -> &super::ant::AntRef;
    fn first_person_camera_height_mut(&mut self) -> &mut super::ant::AntRef;
    fn animated_camera_blend_time(&self) -> &super::ant::AntRef;
    fn animated_camera_blend_time_mut(&mut self) -> &mut super::ant::AntRef;
}

impl CameraCommonBindingTrait for CameraCommonBinding {
    fn first_person_camera_height(&self) -> &super::ant::AntRef {
        &self.first_person_camera_height
    }
    fn first_person_camera_height_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.first_person_camera_height
    }
    fn animated_camera_blend_time(&self) -> &super::ant::AntRef {
        &self.animated_camera_blend_time
    }
    fn animated_camera_blend_time_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.animated_camera_blend_time
    }
}

pub static CAMERACOMMONBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraCommonBinding",
    flags: MemberInfoFlags::new(32841),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraCommonBinding as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "FirstPersonCameraHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CameraCommonBinding, first_person_camera_height),
            },
            FieldInfoData {
                name: "AnimatedCameraBlendTime",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CameraCommonBinding, animated_camera_blend_time),
            },
        ],
    }),
    array_type: Some(CAMERACOMMONBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for CameraCommonBinding {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERACOMMONBINDING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CAMERACOMMONBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraCommonBinding-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("CameraCommonBinding"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Camera1pBinding {
    pub render1p_in_background: super::ant::AntRef,
    pub force_render1p_in_foreground: super::ant::AntRef,
    pub force_animated_camera: super::ant::AntRef,
}

pub trait Camera1pBindingTrait: TypeObject {
    fn render1p_in_background(&self) -> &super::ant::AntRef;
    fn render1p_in_background_mut(&mut self) -> &mut super::ant::AntRef;
    fn force_render1p_in_foreground(&self) -> &super::ant::AntRef;
    fn force_render1p_in_foreground_mut(&mut self) -> &mut super::ant::AntRef;
    fn force_animated_camera(&self) -> &super::ant::AntRef;
    fn force_animated_camera_mut(&mut self) -> &mut super::ant::AntRef;
}

impl Camera1pBindingTrait for Camera1pBinding {
    fn render1p_in_background(&self) -> &super::ant::AntRef {
        &self.render1p_in_background
    }
    fn render1p_in_background_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.render1p_in_background
    }
    fn force_render1p_in_foreground(&self) -> &super::ant::AntRef {
        &self.force_render1p_in_foreground
    }
    fn force_render1p_in_foreground_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.force_render1p_in_foreground
    }
    fn force_animated_camera(&self) -> &super::ant::AntRef {
        &self.force_animated_camera
    }
    fn force_animated_camera_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.force_animated_camera
    }
}

pub static CAMERA1PBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Camera1pBinding",
    flags: MemberInfoFlags::new(32841),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Camera1pBinding as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Render1pInBackground",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(Camera1pBinding, render1p_in_background),
            },
            FieldInfoData {
                name: "ForceRender1pInForeground",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(Camera1pBinding, force_render1p_in_foreground),
            },
            FieldInfoData {
                name: "ForceAnimatedCamera",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(Camera1pBinding, force_animated_camera),
            },
        ],
    }),
    array_type: Some(CAMERA1PBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for Camera1pBinding {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERA1PBINDING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CAMERA1PBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Camera1pBinding-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("Camera1pBinding"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoldierBodyComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub override_gravity: bool,
    pub override_gravity_value: f32,
    pub override_velocity: bool,
    pub override_velocity_y: f32,
    pub sprint_multiplier: f32,
    pub disable_parachute: bool,
    pub disable_crouch: bool,
    pub override_raycast_offset: bool,
    pub override_raycast_offset_stand: super::core::Vec3,
    pub override_raycast_offset_crouch: super::core::Vec3,
    pub override_raycast_offset_prone: super::core::Vec3,
}

pub trait SoldierBodyComponentDataTrait: super::entity::GameComponentDataTrait {
    fn override_gravity(&self) -> &bool;
    fn override_gravity_mut(&mut self) -> &mut bool;
    fn override_gravity_value(&self) -> &f32;
    fn override_gravity_value_mut(&mut self) -> &mut f32;
    fn override_velocity(&self) -> &bool;
    fn override_velocity_mut(&mut self) -> &mut bool;
    fn override_velocity_y(&self) -> &f32;
    fn override_velocity_y_mut(&mut self) -> &mut f32;
    fn sprint_multiplier(&self) -> &f32;
    fn sprint_multiplier_mut(&mut self) -> &mut f32;
    fn disable_parachute(&self) -> &bool;
    fn disable_parachute_mut(&mut self) -> &mut bool;
    fn disable_crouch(&self) -> &bool;
    fn disable_crouch_mut(&mut self) -> &mut bool;
    fn override_raycast_offset(&self) -> &bool;
    fn override_raycast_offset_mut(&mut self) -> &mut bool;
    fn override_raycast_offset_stand(&self) -> &super::core::Vec3;
    fn override_raycast_offset_stand_mut(&mut self) -> &mut super::core::Vec3;
    fn override_raycast_offset_crouch(&self) -> &super::core::Vec3;
    fn override_raycast_offset_crouch_mut(&mut self) -> &mut super::core::Vec3;
    fn override_raycast_offset_prone(&self) -> &super::core::Vec3;
    fn override_raycast_offset_prone_mut(&mut self) -> &mut super::core::Vec3;
}

impl SoldierBodyComponentDataTrait for SoldierBodyComponentData {
    fn override_gravity(&self) -> &bool {
        &self.override_gravity
    }
    fn override_gravity_mut(&mut self) -> &mut bool {
        &mut self.override_gravity
    }
    fn override_gravity_value(&self) -> &f32 {
        &self.override_gravity_value
    }
    fn override_gravity_value_mut(&mut self) -> &mut f32 {
        &mut self.override_gravity_value
    }
    fn override_velocity(&self) -> &bool {
        &self.override_velocity
    }
    fn override_velocity_mut(&mut self) -> &mut bool {
        &mut self.override_velocity
    }
    fn override_velocity_y(&self) -> &f32 {
        &self.override_velocity_y
    }
    fn override_velocity_y_mut(&mut self) -> &mut f32 {
        &mut self.override_velocity_y
    }
    fn sprint_multiplier(&self) -> &f32 {
        &self.sprint_multiplier
    }
    fn sprint_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.sprint_multiplier
    }
    fn disable_parachute(&self) -> &bool {
        &self.disable_parachute
    }
    fn disable_parachute_mut(&mut self) -> &mut bool {
        &mut self.disable_parachute
    }
    fn disable_crouch(&self) -> &bool {
        &self.disable_crouch
    }
    fn disable_crouch_mut(&mut self) -> &mut bool {
        &mut self.disable_crouch
    }
    fn override_raycast_offset(&self) -> &bool {
        &self.override_raycast_offset
    }
    fn override_raycast_offset_mut(&mut self) -> &mut bool {
        &mut self.override_raycast_offset
    }
    fn override_raycast_offset_stand(&self) -> &super::core::Vec3 {
        &self.override_raycast_offset_stand
    }
    fn override_raycast_offset_stand_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.override_raycast_offset_stand
    }
    fn override_raycast_offset_crouch(&self) -> &super::core::Vec3 {
        &self.override_raycast_offset_crouch
    }
    fn override_raycast_offset_crouch_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.override_raycast_offset_crouch
    }
    fn override_raycast_offset_prone(&self) -> &super::core::Vec3 {
        &self.override_raycast_offset_prone
    }
    fn override_raycast_offset_prone_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.override_raycast_offset_prone
    }
}

impl super::entity::GameComponentDataTrait for SoldierBodyComponentData {
}

impl super::entity::ComponentDataTrait for SoldierBodyComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for SoldierBodyComponentData {
}

impl super::core::DataBusPeerTrait for SoldierBodyComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SoldierBodyComponentData {
}

impl super::core::DataContainerTrait for SoldierBodyComponentData {
}

pub static SOLDIERBODYCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierBodyComponentData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierBodyComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "OverrideGravity",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierBodyComponentData, override_gravity),
            },
            FieldInfoData {
                name: "OverrideGravityValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierBodyComponentData, override_gravity_value),
            },
            FieldInfoData {
                name: "OverrideVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierBodyComponentData, override_velocity),
            },
            FieldInfoData {
                name: "OverrideVelocityY",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierBodyComponentData, override_velocity_y),
            },
            FieldInfoData {
                name: "SprintMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierBodyComponentData, sprint_multiplier),
            },
            FieldInfoData {
                name: "DisableParachute",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierBodyComponentData, disable_parachute),
            },
            FieldInfoData {
                name: "DisableCrouch",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierBodyComponentData, disable_crouch),
            },
            FieldInfoData {
                name: "OverrideRaycastOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierBodyComponentData, override_raycast_offset),
            },
            FieldInfoData {
                name: "OverrideRaycastOffsetStand",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SoldierBodyComponentData, override_raycast_offset_stand),
            },
            FieldInfoData {
                name: "OverrideRaycastOffsetCrouch",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SoldierBodyComponentData, override_raycast_offset_crouch),
            },
            FieldInfoData {
                name: "OverrideRaycastOffsetProne",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SoldierBodyComponentData, override_raycast_offset_prone),
            },
        ],
    }),
    array_type: Some(SOLDIERBODYCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SoldierBodyComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERBODYCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOLDIERBODYCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierBodyComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SoldierBodyComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BoneCollisionComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub realm: super::core::Realm,
    pub skeleton_collision_data: Option<Arc<Mutex<dyn super::game_shared::SkeletonCollisionDataTrait>>>,
}

pub trait BoneCollisionComponentDataTrait: super::entity::GameComponentDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn skeleton_collision_data(&self) -> &Option<Arc<Mutex<dyn super::game_shared::SkeletonCollisionDataTrait>>>;
    fn skeleton_collision_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::game_shared::SkeletonCollisionDataTrait>>>;
}

impl BoneCollisionComponentDataTrait for BoneCollisionComponentData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn skeleton_collision_data(&self) -> &Option<Arc<Mutex<dyn super::game_shared::SkeletonCollisionDataTrait>>> {
        &self.skeleton_collision_data
    }
    fn skeleton_collision_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::game_shared::SkeletonCollisionDataTrait>>> {
        &mut self.skeleton_collision_data
    }
}

impl super::entity::GameComponentDataTrait for BoneCollisionComponentData {
}

impl super::entity::ComponentDataTrait for BoneCollisionComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for BoneCollisionComponentData {
}

impl super::core::DataBusPeerTrait for BoneCollisionComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for BoneCollisionComponentData {
}

impl super::core::DataContainerTrait for BoneCollisionComponentData {
}

pub static BONECOLLISIONCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoneCollisionComponentData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BoneCollisionComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(BoneCollisionComponentData, realm),
            },
            FieldInfoData {
                name: "SkeletonCollisionData",
                flags: MemberInfoFlags::new(0),
                field_type: "SkeletonCollisionData",
                rust_offset: offset_of!(BoneCollisionComponentData, skeleton_collision_data),
            },
        ],
    }),
    array_type: Some(BONECOLLISIONCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for BoneCollisionComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        BONECOLLISIONCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BONECOLLISIONCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoneCollisionComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("BoneCollisionComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoldierEntryComponentData {
    pub _glacier_base: super::game_shared::CharacterEntryComponentData,
    pub ant_entry_enumeration: Option<Arc<Mutex<dyn super::gameplay_sim::AntEnumerationTrait>>>,
    pub animation_acceleration_multiplier: super::core::Vec3,
    pub world_space_lock_efficiency: AimingWorldSpaceLockEfficiencyData,
    pub leave_soldier_in_place: bool,
    pub clamp_soldier_offset_to_bounding_box: bool,
    pub clamp_soldier_y_offset_to_floor: bool,
    pub hide_vehicle_hud: bool,
}

pub trait SoldierEntryComponentDataTrait: super::game_shared::CharacterEntryComponentDataTrait {
    fn ant_entry_enumeration(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::AntEnumerationTrait>>>;
    fn ant_entry_enumeration_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::AntEnumerationTrait>>>;
    fn animation_acceleration_multiplier(&self) -> &super::core::Vec3;
    fn animation_acceleration_multiplier_mut(&mut self) -> &mut super::core::Vec3;
    fn world_space_lock_efficiency(&self) -> &AimingWorldSpaceLockEfficiencyData;
    fn world_space_lock_efficiency_mut(&mut self) -> &mut AimingWorldSpaceLockEfficiencyData;
    fn leave_soldier_in_place(&self) -> &bool;
    fn leave_soldier_in_place_mut(&mut self) -> &mut bool;
    fn clamp_soldier_offset_to_bounding_box(&self) -> &bool;
    fn clamp_soldier_offset_to_bounding_box_mut(&mut self) -> &mut bool;
    fn clamp_soldier_y_offset_to_floor(&self) -> &bool;
    fn clamp_soldier_y_offset_to_floor_mut(&mut self) -> &mut bool;
    fn hide_vehicle_hud(&self) -> &bool;
    fn hide_vehicle_hud_mut(&mut self) -> &mut bool;
}

impl SoldierEntryComponentDataTrait for SoldierEntryComponentData {
    fn ant_entry_enumeration(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::AntEnumerationTrait>>> {
        &self.ant_entry_enumeration
    }
    fn ant_entry_enumeration_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::AntEnumerationTrait>>> {
        &mut self.ant_entry_enumeration
    }
    fn animation_acceleration_multiplier(&self) -> &super::core::Vec3 {
        &self.animation_acceleration_multiplier
    }
    fn animation_acceleration_multiplier_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.animation_acceleration_multiplier
    }
    fn world_space_lock_efficiency(&self) -> &AimingWorldSpaceLockEfficiencyData {
        &self.world_space_lock_efficiency
    }
    fn world_space_lock_efficiency_mut(&mut self) -> &mut AimingWorldSpaceLockEfficiencyData {
        &mut self.world_space_lock_efficiency
    }
    fn leave_soldier_in_place(&self) -> &bool {
        &self.leave_soldier_in_place
    }
    fn leave_soldier_in_place_mut(&mut self) -> &mut bool {
        &mut self.leave_soldier_in_place
    }
    fn clamp_soldier_offset_to_bounding_box(&self) -> &bool {
        &self.clamp_soldier_offset_to_bounding_box
    }
    fn clamp_soldier_offset_to_bounding_box_mut(&mut self) -> &mut bool {
        &mut self.clamp_soldier_offset_to_bounding_box
    }
    fn clamp_soldier_y_offset_to_floor(&self) -> &bool {
        &self.clamp_soldier_y_offset_to_floor
    }
    fn clamp_soldier_y_offset_to_floor_mut(&mut self) -> &mut bool {
        &mut self.clamp_soldier_y_offset_to_floor
    }
    fn hide_vehicle_hud(&self) -> &bool {
        &self.hide_vehicle_hud
    }
    fn hide_vehicle_hud_mut(&mut self) -> &mut bool {
        &mut self.hide_vehicle_hud
    }
}

impl super::game_shared::CharacterEntryComponentDataTrait for SoldierEntryComponentData {
    fn aiming_constraints(&self) -> &super::gameplay_sim::AimingConstraintsData {
        self._glacier_base.aiming_constraints()
    }
    fn aiming_constraints_mut(&mut self) -> &mut super::gameplay_sim::AimingConstraintsData {
        self._glacier_base.aiming_constraints_mut()
    }
}

impl super::game_shared::GameEntryComponentDataTrait for SoldierEntryComponentData {
    fn lock_soldier_aiming_to_entry(&self) -> &bool {
        self._glacier_base.lock_soldier_aiming_to_entry()
    }
    fn lock_soldier_aiming_to_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.lock_soldier_aiming_to_entry_mut()
    }
    fn soldier_offset(&self) -> &super::core::Vec3 {
        self._glacier_base.soldier_offset()
    }
    fn soldier_offset_mut(&mut self) -> &mut super::core::Vec3 {
        self._glacier_base.soldier_offset_mut()
    }
}

impl super::gameplay_sim::EntryComponentDataTrait for SoldierEntryComponentData {
    fn entry_class(&self) -> &super::gameplay_sim::EntryClass {
        self._glacier_base.entry_class()
    }
    fn entry_class_mut(&mut self) -> &mut super::gameplay_sim::EntryClass {
        self._glacier_base.entry_class_mut()
    }
    fn a_i_data(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::GameAIEntryDataTrait>>> {
        self._glacier_base.a_i_data()
    }
    fn a_i_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::GameAIEntryDataTrait>>> {
        self._glacier_base.a_i_data_mut()
    }
    fn forbidden_for_human(&self) -> &bool {
        self._glacier_base.forbidden_for_human()
    }
    fn forbidden_for_human_mut(&mut self) -> &mut bool {
        self._glacier_base.forbidden_for_human_mut()
    }
    fn input_graph(&self) -> &Option<Arc<Mutex<dyn super::input_shared::InputGraphTrait>>> {
        self._glacier_base.input_graph()
    }
    fn input_graph_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::input_shared::InputGraphTrait>>> {
        self._glacier_base.input_graph_mut()
    }
    fn input_concept_definition(&self) -> &Option<Arc<Mutex<dyn super::input_shared::InputActionMapsDataTrait>>> {
        self._glacier_base.input_concept_definition()
    }
    fn input_concept_definition_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::input_shared::InputActionMapsDataTrait>>> {
        self._glacier_base.input_concept_definition_mut()
    }
    fn action_map_settings_flip_y_scheme_override(&self) -> &i32 {
        self._glacier_base.action_map_settings_flip_y_scheme_override()
    }
    fn action_map_settings_flip_y_scheme_override_mut(&mut self) -> &mut i32 {
        self._glacier_base.action_map_settings_flip_y_scheme_override_mut()
    }
    fn input_mapping(&self) -> &Option<Arc<Mutex<dyn super::input_shared::InputConceptToEntryInputActionMappingsTrait>>> {
        self._glacier_base.input_mapping()
    }
    fn input_mapping_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::input_shared::InputConceptToEntryInputActionMappingsTrait>>> {
        self._glacier_base.input_mapping_mut()
    }
    fn input_curves(&self) -> &Vec<Option<Arc<Mutex<dyn super::gameplay_sim::InputCurveDataTrait>>>> {
        self._glacier_base.input_curves()
    }
    fn input_curves_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::gameplay_sim::InputCurveDataTrait>>>> {
        self._glacier_base.input_curves_mut()
    }
    fn hud_data(&self) -> &super::gameplay_sim::EntryComponentHudData {
        self._glacier_base.hud_data()
    }
    fn hud_data_mut(&mut self) -> &mut super::gameplay_sim::EntryComponentHudData {
        self._glacier_base.hud_data_mut()
    }
    fn entry_order_number(&self) -> &i32 {
        self._glacier_base.entry_order_number()
    }
    fn entry_order_number_mut(&mut self) -> &mut i32 {
        self._glacier_base.entry_order_number_mut()
    }
    fn enter_impulse(&self) -> &f32 {
        self._glacier_base.enter_impulse()
    }
    fn enter_impulse_mut(&mut self) -> &mut f32 {
        self._glacier_base.enter_impulse_mut()
    }
    fn entry_radius(&self) -> &f32 {
        self._glacier_base.entry_radius()
    }
    fn entry_radius_mut(&mut self) -> &mut f32 {
        self._glacier_base.entry_radius_mut()
    }
    fn is_allowed_to_exit_in_air(&self) -> &bool {
        self._glacier_base.is_allowed_to_exit_in_air()
    }
    fn is_allowed_to_exit_in_air_mut(&mut self) -> &mut bool {
        self._glacier_base.is_allowed_to_exit_in_air_mut()
    }
    fn clear_path_to_exit_point_start_offset(&self) -> &super::core::Vec3 {
        self._glacier_base.clear_path_to_exit_point_start_offset()
    }
    fn clear_path_to_exit_point_start_offset_mut(&mut self) -> &mut super::core::Vec3 {
        self._glacier_base.clear_path_to_exit_point_start_offset_mut()
    }
    fn is_shielded(&self) -> &bool {
        self._glacier_base.is_shielded()
    }
    fn is_shielded_mut(&mut self) -> &mut bool {
        self._glacier_base.is_shielded_mut()
    }
    fn show_soldier_in_entry(&self) -> &bool {
        self._glacier_base.show_soldier_in_entry()
    }
    fn show_soldier_in_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.show_soldier_in_entry_mut()
    }
    fn show1p_soldier_in_entry(&self) -> &bool {
        self._glacier_base.show1p_soldier_in_entry()
    }
    fn show1p_soldier_in_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.show1p_soldier_in_entry_mut()
    }
    fn soldier_transition_invisble_time(&self) -> &f32 {
        self._glacier_base.soldier_transition_invisble_time()
    }
    fn soldier_transition_invisble_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.soldier_transition_invisble_time_mut()
    }
    fn entry_spotting_settings(&self) -> &super::gameplay_sim::EntrySpottingSettings {
        self._glacier_base.entry_spotting_settings()
    }
    fn entry_spotting_settings_mut(&mut self) -> &mut super::gameplay_sim::EntrySpottingSettings {
        self._glacier_base.entry_spotting_settings_mut()
    }
    fn show_soldier_weapon_in_entry(&self) -> &bool {
        self._glacier_base.show_soldier_weapon_in_entry()
    }
    fn show_soldier_weapon_in_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.show_soldier_weapon_in_entry_mut()
    }
    fn show1p_soldier_in_entry_for_player_only(&self) -> &bool {
        self._glacier_base.show1p_soldier_in_entry_for_player_only()
    }
    fn show1p_soldier_in_entry_for_player_only_mut(&mut self) -> &mut bool {
        self._glacier_base.show1p_soldier_in_entry_for_player_only_mut()
    }
    fn show3p_soldier_weapon_in_entry(&self) -> &bool {
        self._glacier_base.show3p_soldier_weapon_in_entry()
    }
    fn show3p_soldier_weapon_in_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.show3p_soldier_weapon_in_entry_mut()
    }
    fn show_soldier_gear_in_entry(&self) -> &bool {
        self._glacier_base.show_soldier_gear_in_entry()
    }
    fn show_soldier_gear_in_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.show_soldier_gear_in_entry_mut()
    }
    fn pose_constraints(&self) -> &super::gameplay_sim::PoseConstraintsData {
        self._glacier_base.pose_constraints()
    }
    fn pose_constraints_mut(&mut self) -> &mut super::gameplay_sim::PoseConstraintsData {
        self._glacier_base.pose_constraints_mut()
    }
    fn use_local_transform(&self) -> &bool {
        self._glacier_base.use_local_transform()
    }
    fn use_local_transform_mut(&mut self) -> &mut bool {
        self._glacier_base.use_local_transform_mut()
    }
    fn trigger_event_on_key(&self) -> &i32 {
        self._glacier_base.trigger_event_on_key()
    }
    fn trigger_event_on_key_mut(&mut self) -> &mut i32 {
        self._glacier_base.trigger_event_on_key_mut()
    }
    fn allow_ragdoll_from_entry(&self) -> &bool {
        self._glacier_base.allow_ragdoll_from_entry()
    }
    fn allow_ragdoll_from_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.allow_ragdoll_from_entry_mut()
    }
    fn camera_index(&self) -> &i32 {
        self._glacier_base.camera_index()
    }
    fn camera_index_mut(&mut self) -> &mut i32 {
        self._glacier_base.camera_index_mut()
    }
}

impl super::entity::GameComponentDataTrait for SoldierEntryComponentData {
}

impl super::entity::ComponentDataTrait for SoldierEntryComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for SoldierEntryComponentData {
}

impl super::core::DataBusPeerTrait for SoldierEntryComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SoldierEntryComponentData {
}

impl super::core::DataContainerTrait for SoldierEntryComponentData {
}

pub static SOLDIERENTRYCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierEntryComponentData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::game_shared::CHARACTERENTRYCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierEntryComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AntEntryEnumeration",
                flags: MemberInfoFlags::new(0),
                field_type: "AntEnumeration",
                rust_offset: offset_of!(SoldierEntryComponentData, ant_entry_enumeration),
            },
            FieldInfoData {
                name: "AnimationAccelerationMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SoldierEntryComponentData, animation_acceleration_multiplier),
            },
            FieldInfoData {
                name: "WorldSpaceLockEfficiency",
                flags: MemberInfoFlags::new(0),
                field_type: "AimingWorldSpaceLockEfficiencyData",
                rust_offset: offset_of!(SoldierEntryComponentData, world_space_lock_efficiency),
            },
            FieldInfoData {
                name: "LeaveSoldierInPlace",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierEntryComponentData, leave_soldier_in_place),
            },
            FieldInfoData {
                name: "ClampSoldierOffsetToBoundingBox",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierEntryComponentData, clamp_soldier_offset_to_bounding_box),
            },
            FieldInfoData {
                name: "ClampSoldierYOffsetToFloor",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierEntryComponentData, clamp_soldier_y_offset_to_floor),
            },
            FieldInfoData {
                name: "HideVehicleHud",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierEntryComponentData, hide_vehicle_hud),
            },
        ],
    }),
    array_type: Some(SOLDIERENTRYCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SoldierEntryComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERENTRYCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOLDIERENTRYCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierEntryComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SoldierEntryComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AimingWorldSpaceLockEfficiencyData {
    pub efficiency_yaw: f32,
    pub efficiency_pitch: f32,
    pub efficiency_yaw_zoom: f32,
    pub efficiency_pitch_zoom: f32,
}

pub trait AimingWorldSpaceLockEfficiencyDataTrait: TypeObject {
    fn efficiency_yaw(&self) -> &f32;
    fn efficiency_yaw_mut(&mut self) -> &mut f32;
    fn efficiency_pitch(&self) -> &f32;
    fn efficiency_pitch_mut(&mut self) -> &mut f32;
    fn efficiency_yaw_zoom(&self) -> &f32;
    fn efficiency_yaw_zoom_mut(&mut self) -> &mut f32;
    fn efficiency_pitch_zoom(&self) -> &f32;
    fn efficiency_pitch_zoom_mut(&mut self) -> &mut f32;
}

impl AimingWorldSpaceLockEfficiencyDataTrait for AimingWorldSpaceLockEfficiencyData {
    fn efficiency_yaw(&self) -> &f32 {
        &self.efficiency_yaw
    }
    fn efficiency_yaw_mut(&mut self) -> &mut f32 {
        &mut self.efficiency_yaw
    }
    fn efficiency_pitch(&self) -> &f32 {
        &self.efficiency_pitch
    }
    fn efficiency_pitch_mut(&mut self) -> &mut f32 {
        &mut self.efficiency_pitch
    }
    fn efficiency_yaw_zoom(&self) -> &f32 {
        &self.efficiency_yaw_zoom
    }
    fn efficiency_yaw_zoom_mut(&mut self) -> &mut f32 {
        &mut self.efficiency_yaw_zoom
    }
    fn efficiency_pitch_zoom(&self) -> &f32 {
        &self.efficiency_pitch_zoom
    }
    fn efficiency_pitch_zoom_mut(&mut self) -> &mut f32 {
        &mut self.efficiency_pitch_zoom
    }
}

pub static AIMINGWORLDSPACELOCKEFFICIENCYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AimingWorldSpaceLockEfficiencyData",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AimingWorldSpaceLockEfficiencyData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "EfficiencyYaw",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AimingWorldSpaceLockEfficiencyData, efficiency_yaw),
            },
            FieldInfoData {
                name: "EfficiencyPitch",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AimingWorldSpaceLockEfficiencyData, efficiency_pitch),
            },
            FieldInfoData {
                name: "EfficiencyYawZoom",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AimingWorldSpaceLockEfficiencyData, efficiency_yaw_zoom),
            },
            FieldInfoData {
                name: "EfficiencyPitchZoom",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AimingWorldSpaceLockEfficiencyData, efficiency_pitch_zoom),
            },
        ],
    }),
    array_type: Some(AIMINGWORLDSPACELOCKEFFICIENCYDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AimingWorldSpaceLockEfficiencyData {
    fn type_info(&self) -> &'static TypeInfo {
        AIMINGWORLDSPACELOCKEFFICIENCYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AIMINGWORLDSPACELOCKEFFICIENCYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AimingWorldSpaceLockEfficiencyData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("AimingWorldSpaceLockEfficiencyData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoldierThirdPersonCameraData {
    pub _glacier_base: SoldierCameraData,
    pub max_pitch: f32,
    pub reduce_arm_length_looking_up: bool,
    pub max_reduced_arm_length: f32,
    pub reduce_min_pitch: f32,
    pub reduce_max_pitch: f32,
    pub collision_width_padding: f32,
    pub collision_blend_in: f32,
    pub collision_blend_out: f32,
}

pub trait SoldierThirdPersonCameraDataTrait: SoldierCameraDataTrait {
    fn max_pitch(&self) -> &f32;
    fn max_pitch_mut(&mut self) -> &mut f32;
    fn reduce_arm_length_looking_up(&self) -> &bool;
    fn reduce_arm_length_looking_up_mut(&mut self) -> &mut bool;
    fn max_reduced_arm_length(&self) -> &f32;
    fn max_reduced_arm_length_mut(&mut self) -> &mut f32;
    fn reduce_min_pitch(&self) -> &f32;
    fn reduce_min_pitch_mut(&mut self) -> &mut f32;
    fn reduce_max_pitch(&self) -> &f32;
    fn reduce_max_pitch_mut(&mut self) -> &mut f32;
    fn collision_width_padding(&self) -> &f32;
    fn collision_width_padding_mut(&mut self) -> &mut f32;
    fn collision_blend_in(&self) -> &f32;
    fn collision_blend_in_mut(&mut self) -> &mut f32;
    fn collision_blend_out(&self) -> &f32;
    fn collision_blend_out_mut(&mut self) -> &mut f32;
}

impl SoldierThirdPersonCameraDataTrait for SoldierThirdPersonCameraData {
    fn max_pitch(&self) -> &f32 {
        &self.max_pitch
    }
    fn max_pitch_mut(&mut self) -> &mut f32 {
        &mut self.max_pitch
    }
    fn reduce_arm_length_looking_up(&self) -> &bool {
        &self.reduce_arm_length_looking_up
    }
    fn reduce_arm_length_looking_up_mut(&mut self) -> &mut bool {
        &mut self.reduce_arm_length_looking_up
    }
    fn max_reduced_arm_length(&self) -> &f32 {
        &self.max_reduced_arm_length
    }
    fn max_reduced_arm_length_mut(&mut self) -> &mut f32 {
        &mut self.max_reduced_arm_length
    }
    fn reduce_min_pitch(&self) -> &f32 {
        &self.reduce_min_pitch
    }
    fn reduce_min_pitch_mut(&mut self) -> &mut f32 {
        &mut self.reduce_min_pitch
    }
    fn reduce_max_pitch(&self) -> &f32 {
        &self.reduce_max_pitch
    }
    fn reduce_max_pitch_mut(&mut self) -> &mut f32 {
        &mut self.reduce_max_pitch
    }
    fn collision_width_padding(&self) -> &f32 {
        &self.collision_width_padding
    }
    fn collision_width_padding_mut(&mut self) -> &mut f32 {
        &mut self.collision_width_padding
    }
    fn collision_blend_in(&self) -> &f32 {
        &self.collision_blend_in
    }
    fn collision_blend_in_mut(&mut self) -> &mut f32 {
        &mut self.collision_blend_in
    }
    fn collision_blend_out(&self) -> &f32 {
        &self.collision_blend_out
    }
    fn collision_blend_out_mut(&mut self) -> &mut f32 {
        &mut self.collision_blend_out
    }
}

impl SoldierCameraDataTrait for SoldierThirdPersonCameraData {
}

impl super::gameplay_sim::CameraDataTrait for SoldierThirdPersonCameraData {
    fn occlusion_ray_offset(&self) -> &super::core::Vec3 {
        self._glacier_base.occlusion_ray_offset()
    }
    fn occlusion_ray_offset_mut(&mut self) -> &mut super::core::Vec3 {
        self._glacier_base.occlusion_ray_offset_mut()
    }
    fn pre_fade_time(&self) -> &f32 {
        self._glacier_base.pre_fade_time()
    }
    fn pre_fade_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.pre_fade_time_mut()
    }
    fn fade_time(&self) -> &f32 {
        self._glacier_base.fade_time()
    }
    fn fade_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.fade_time_mut()
    }
    fn fade_wait_time(&self) -> &f32 {
        self._glacier_base.fade_wait_time()
    }
    fn fade_wait_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.fade_wait_time_mut()
    }
    fn stay_faded_while_streaming(&self) -> &bool {
        self._glacier_base.stay_faded_while_streaming()
    }
    fn stay_faded_while_streaming_mut(&mut self) -> &mut bool {
        self._glacier_base.stay_faded_while_streaming_mut()
    }
    fn near_plane(&self) -> &f32 {
        self._glacier_base.near_plane()
    }
    fn near_plane_mut(&mut self) -> &mut f32 {
        self._glacier_base.near_plane_mut()
    }
    fn shadow_view_distance_scale(&self) -> &f32 {
        self._glacier_base.shadow_view_distance_scale()
    }
    fn shadow_view_distance_scale_mut(&mut self) -> &mut f32 {
        self._glacier_base.shadow_view_distance_scale_mut()
    }
    fn sound_occlusion(&self) -> &f32 {
        self._glacier_base.sound_occlusion()
    }
    fn sound_occlusion_mut(&mut self) -> &mut f32 {
        self._glacier_base.sound_occlusion_mut()
    }
    fn sound_listener_radius(&self) -> &f32 {
        self._glacier_base.sound_listener_radius()
    }
    fn sound_listener_radius_mut(&mut self) -> &mut f32 {
        self._glacier_base.sound_listener_radius_mut()
    }
    fn sound_listener_fov(&self) -> &f32 {
        self._glacier_base.sound_listener_fov()
    }
    fn sound_listener_fov_mut(&mut self) -> &mut f32 {
        self._glacier_base.sound_listener_fov_mut()
    }
    fn shake_factor(&self) -> &f32 {
        self._glacier_base.shake_factor()
    }
    fn shake_factor_mut(&mut self) -> &mut f32 {
        self._glacier_base.shake_factor_mut()
    }
    fn view_id(&self) -> &super::render_base::LocalPlayerViewId {
        self._glacier_base.view_id()
    }
    fn view_id_mut(&mut self) -> &mut super::render_base::LocalPlayerViewId {
        self._glacier_base.view_id_mut()
    }
    fn transition_data_pack(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::CameraTransitionEffectDataPackTrait>>> {
        self._glacier_base.transition_data_pack()
    }
    fn transition_data_pack_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::CameraTransitionEffectDataPackTrait>>> {
        self._glacier_base.transition_data_pack_mut()
    }
}

impl super::entity::GameObjectDataTrait for SoldierThirdPersonCameraData {
}

impl super::core::DataBusPeerTrait for SoldierThirdPersonCameraData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SoldierThirdPersonCameraData {
}

impl super::core::DataContainerTrait for SoldierThirdPersonCameraData {
}

pub static SOLDIERTHIRDPERSONCAMERADATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierThirdPersonCameraData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOLDIERCAMERADATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierThirdPersonCameraData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MaxPitch",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierThirdPersonCameraData, max_pitch),
            },
            FieldInfoData {
                name: "ReduceArmLengthLookingUp",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierThirdPersonCameraData, reduce_arm_length_looking_up),
            },
            FieldInfoData {
                name: "MaxReducedArmLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierThirdPersonCameraData, max_reduced_arm_length),
            },
            FieldInfoData {
                name: "ReduceMinPitch",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierThirdPersonCameraData, reduce_min_pitch),
            },
            FieldInfoData {
                name: "ReduceMaxPitch",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierThirdPersonCameraData, reduce_max_pitch),
            },
            FieldInfoData {
                name: "CollisionWidthPadding",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierThirdPersonCameraData, collision_width_padding),
            },
            FieldInfoData {
                name: "CollisionBlendIn",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierThirdPersonCameraData, collision_blend_in),
            },
            FieldInfoData {
                name: "CollisionBlendOut",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierThirdPersonCameraData, collision_blend_out),
            },
        ],
    }),
    array_type: Some(SOLDIERTHIRDPERSONCAMERADATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SoldierThirdPersonCameraData {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERTHIRDPERSONCAMERADATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOLDIERTHIRDPERSONCAMERADATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierThirdPersonCameraData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SoldierThirdPersonCameraData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoldierFirstPersonCameraData {
    pub _glacier_base: SoldierCameraData,
}

pub trait SoldierFirstPersonCameraDataTrait: SoldierCameraDataTrait {
}

impl SoldierFirstPersonCameraDataTrait for SoldierFirstPersonCameraData {
}

impl SoldierCameraDataTrait for SoldierFirstPersonCameraData {
}

impl super::gameplay_sim::CameraDataTrait for SoldierFirstPersonCameraData {
    fn occlusion_ray_offset(&self) -> &super::core::Vec3 {
        self._glacier_base.occlusion_ray_offset()
    }
    fn occlusion_ray_offset_mut(&mut self) -> &mut super::core::Vec3 {
        self._glacier_base.occlusion_ray_offset_mut()
    }
    fn pre_fade_time(&self) -> &f32 {
        self._glacier_base.pre_fade_time()
    }
    fn pre_fade_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.pre_fade_time_mut()
    }
    fn fade_time(&self) -> &f32 {
        self._glacier_base.fade_time()
    }
    fn fade_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.fade_time_mut()
    }
    fn fade_wait_time(&self) -> &f32 {
        self._glacier_base.fade_wait_time()
    }
    fn fade_wait_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.fade_wait_time_mut()
    }
    fn stay_faded_while_streaming(&self) -> &bool {
        self._glacier_base.stay_faded_while_streaming()
    }
    fn stay_faded_while_streaming_mut(&mut self) -> &mut bool {
        self._glacier_base.stay_faded_while_streaming_mut()
    }
    fn near_plane(&self) -> &f32 {
        self._glacier_base.near_plane()
    }
    fn near_plane_mut(&mut self) -> &mut f32 {
        self._glacier_base.near_plane_mut()
    }
    fn shadow_view_distance_scale(&self) -> &f32 {
        self._glacier_base.shadow_view_distance_scale()
    }
    fn shadow_view_distance_scale_mut(&mut self) -> &mut f32 {
        self._glacier_base.shadow_view_distance_scale_mut()
    }
    fn sound_occlusion(&self) -> &f32 {
        self._glacier_base.sound_occlusion()
    }
    fn sound_occlusion_mut(&mut self) -> &mut f32 {
        self._glacier_base.sound_occlusion_mut()
    }
    fn sound_listener_radius(&self) -> &f32 {
        self._glacier_base.sound_listener_radius()
    }
    fn sound_listener_radius_mut(&mut self) -> &mut f32 {
        self._glacier_base.sound_listener_radius_mut()
    }
    fn sound_listener_fov(&self) -> &f32 {
        self._glacier_base.sound_listener_fov()
    }
    fn sound_listener_fov_mut(&mut self) -> &mut f32 {
        self._glacier_base.sound_listener_fov_mut()
    }
    fn shake_factor(&self) -> &f32 {
        self._glacier_base.shake_factor()
    }
    fn shake_factor_mut(&mut self) -> &mut f32 {
        self._glacier_base.shake_factor_mut()
    }
    fn view_id(&self) -> &super::render_base::LocalPlayerViewId {
        self._glacier_base.view_id()
    }
    fn view_id_mut(&mut self) -> &mut super::render_base::LocalPlayerViewId {
        self._glacier_base.view_id_mut()
    }
    fn transition_data_pack(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::CameraTransitionEffectDataPackTrait>>> {
        self._glacier_base.transition_data_pack()
    }
    fn transition_data_pack_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::CameraTransitionEffectDataPackTrait>>> {
        self._glacier_base.transition_data_pack_mut()
    }
}

impl super::entity::GameObjectDataTrait for SoldierFirstPersonCameraData {
}

impl super::core::DataBusPeerTrait for SoldierFirstPersonCameraData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SoldierFirstPersonCameraData {
}

impl super::core::DataContainerTrait for SoldierFirstPersonCameraData {
}

pub static SOLDIERFIRSTPERSONCAMERADATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierFirstPersonCameraData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOLDIERCAMERADATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierFirstPersonCameraData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SOLDIERFIRSTPERSONCAMERADATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SoldierFirstPersonCameraData {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERFIRSTPERSONCAMERADATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOLDIERFIRSTPERSONCAMERADATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierFirstPersonCameraData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SoldierFirstPersonCameraData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoldierCameraData {
    pub _glacier_base: super::gameplay_sim::CameraData,
}

pub trait SoldierCameraDataTrait: super::gameplay_sim::CameraDataTrait {
}

impl SoldierCameraDataTrait for SoldierCameraData {
}

impl super::gameplay_sim::CameraDataTrait for SoldierCameraData {
    fn occlusion_ray_offset(&self) -> &super::core::Vec3 {
        self._glacier_base.occlusion_ray_offset()
    }
    fn occlusion_ray_offset_mut(&mut self) -> &mut super::core::Vec3 {
        self._glacier_base.occlusion_ray_offset_mut()
    }
    fn pre_fade_time(&self) -> &f32 {
        self._glacier_base.pre_fade_time()
    }
    fn pre_fade_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.pre_fade_time_mut()
    }
    fn fade_time(&self) -> &f32 {
        self._glacier_base.fade_time()
    }
    fn fade_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.fade_time_mut()
    }
    fn fade_wait_time(&self) -> &f32 {
        self._glacier_base.fade_wait_time()
    }
    fn fade_wait_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.fade_wait_time_mut()
    }
    fn stay_faded_while_streaming(&self) -> &bool {
        self._glacier_base.stay_faded_while_streaming()
    }
    fn stay_faded_while_streaming_mut(&mut self) -> &mut bool {
        self._glacier_base.stay_faded_while_streaming_mut()
    }
    fn near_plane(&self) -> &f32 {
        self._glacier_base.near_plane()
    }
    fn near_plane_mut(&mut self) -> &mut f32 {
        self._glacier_base.near_plane_mut()
    }
    fn shadow_view_distance_scale(&self) -> &f32 {
        self._glacier_base.shadow_view_distance_scale()
    }
    fn shadow_view_distance_scale_mut(&mut self) -> &mut f32 {
        self._glacier_base.shadow_view_distance_scale_mut()
    }
    fn sound_occlusion(&self) -> &f32 {
        self._glacier_base.sound_occlusion()
    }
    fn sound_occlusion_mut(&mut self) -> &mut f32 {
        self._glacier_base.sound_occlusion_mut()
    }
    fn sound_listener_radius(&self) -> &f32 {
        self._glacier_base.sound_listener_radius()
    }
    fn sound_listener_radius_mut(&mut self) -> &mut f32 {
        self._glacier_base.sound_listener_radius_mut()
    }
    fn sound_listener_fov(&self) -> &f32 {
        self._glacier_base.sound_listener_fov()
    }
    fn sound_listener_fov_mut(&mut self) -> &mut f32 {
        self._glacier_base.sound_listener_fov_mut()
    }
    fn shake_factor(&self) -> &f32 {
        self._glacier_base.shake_factor()
    }
    fn shake_factor_mut(&mut self) -> &mut f32 {
        self._glacier_base.shake_factor_mut()
    }
    fn view_id(&self) -> &super::render_base::LocalPlayerViewId {
        self._glacier_base.view_id()
    }
    fn view_id_mut(&mut self) -> &mut super::render_base::LocalPlayerViewId {
        self._glacier_base.view_id_mut()
    }
    fn transition_data_pack(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::CameraTransitionEffectDataPackTrait>>> {
        self._glacier_base.transition_data_pack()
    }
    fn transition_data_pack_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::CameraTransitionEffectDataPackTrait>>> {
        self._glacier_base.transition_data_pack_mut()
    }
}

impl super::entity::GameObjectDataTrait for SoldierCameraData {
}

impl super::core::DataBusPeerTrait for SoldierCameraData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SoldierCameraData {
}

impl super::core::DataContainerTrait for SoldierCameraData {
}

pub static SOLDIERCAMERADATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierCameraData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::CAMERADATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierCameraData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SOLDIERCAMERADATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SoldierCameraData {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERCAMERADATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOLDIERCAMERADATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierCameraData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SoldierCameraData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoldierWeaponAsset {
    pub _glacier_base: SoldierWeaponBlueprint,
}

pub trait SoldierWeaponAssetTrait: SoldierWeaponBlueprintTrait {
}

impl SoldierWeaponAssetTrait for SoldierWeaponAsset {
}

impl SoldierWeaponBlueprintTrait for SoldierWeaponAsset {
}

impl super::entity::ObjectBlueprintTrait for SoldierWeaponAsset {
    fn object(&self) -> &Option<Arc<Mutex<dyn super::entity::EntityDataTrait>>> {
        self._glacier_base.object()
    }
    fn object_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::EntityDataTrait>>> {
        self._glacier_base.object_mut()
    }
}

impl super::entity::BlueprintTrait for SoldierWeaponAsset {
    fn objects(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.objects()
    }
    fn objects_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.objects_mut()
    }
    fn schematics(&self) -> &Option<Arc<Mutex<dyn super::schematics::SchematicsBaseAssetTrait>>> {
        self._glacier_base.schematics()
    }
    fn schematics_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::schematics::SchematicsBaseAssetTrait>>> {
        self._glacier_base.schematics_mut()
    }
}

impl super::entity::EntityBusDataTrait for SoldierWeaponAsset {
    fn event_connections(&self) -> &Vec<super::entity::EventConnection> {
        self._glacier_base.event_connections()
    }
    fn event_connections_mut(&mut self) -> &mut Vec<super::entity::EventConnection> {
        self._glacier_base.event_connections_mut()
    }
}

impl super::core::DataBusDataTrait for SoldierWeaponAsset {
    fn flags(&self) -> &u16 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.flags_mut()
    }
    fn property_connections(&self) -> &Vec<super::core::PropertyConnection> {
        self._glacier_base.property_connections()
    }
    fn property_connections_mut(&mut self) -> &mut Vec<super::core::PropertyConnection> {
        self._glacier_base.property_connections_mut()
    }
    fn link_connections(&self) -> &Vec<super::core::LinkConnection> {
        self._glacier_base.link_connections()
    }
    fn link_connections_mut(&mut self) -> &mut Vec<super::core::LinkConnection> {
        self._glacier_base.link_connections_mut()
    }
    fn interface(&self) -> &Option<Arc<Mutex<dyn super::core::DynamicDataContainerTrait>>> {
        self._glacier_base.interface()
    }
    fn interface_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::DynamicDataContainerTrait>>> {
        self._glacier_base.interface_mut()
    }
}

impl super::core::AssetTrait for SoldierWeaponAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for SoldierWeaponAsset {
}

pub static SOLDIERWEAPONASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierWeaponAsset",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOLDIERWEAPONBLUEPRINT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierWeaponAsset as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SOLDIERWEAPONASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoldierWeaponAsset {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERWEAPONASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOLDIERWEAPONASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierWeaponAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SoldierWeaponAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoldierAsset {
    pub _glacier_base: SoldierBlueprint,
}

pub trait SoldierAssetTrait: SoldierBlueprintTrait {
}

impl SoldierAssetTrait for SoldierAsset {
}

impl SoldierBlueprintTrait for SoldierAsset {
}

impl super::game_shared::CharacterBlueprintTrait for SoldierAsset {
    fn time_delta_type(&self) -> &super::entity::TimeDeltaType {
        self._glacier_base.time_delta_type()
    }
    fn time_delta_type_mut(&mut self) -> &mut super::entity::TimeDeltaType {
        self._glacier_base.time_delta_type_mut()
    }
}

impl super::entity::ObjectBlueprintTrait for SoldierAsset {
    fn object(&self) -> &Option<Arc<Mutex<dyn super::entity::EntityDataTrait>>> {
        self._glacier_base.object()
    }
    fn object_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::EntityDataTrait>>> {
        self._glacier_base.object_mut()
    }
}

impl super::entity::BlueprintTrait for SoldierAsset {
    fn objects(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.objects()
    }
    fn objects_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.objects_mut()
    }
    fn schematics(&self) -> &Option<Arc<Mutex<dyn super::schematics::SchematicsBaseAssetTrait>>> {
        self._glacier_base.schematics()
    }
    fn schematics_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::schematics::SchematicsBaseAssetTrait>>> {
        self._glacier_base.schematics_mut()
    }
}

impl super::entity::EntityBusDataTrait for SoldierAsset {
    fn event_connections(&self) -> &Vec<super::entity::EventConnection> {
        self._glacier_base.event_connections()
    }
    fn event_connections_mut(&mut self) -> &mut Vec<super::entity::EventConnection> {
        self._glacier_base.event_connections_mut()
    }
}

impl super::core::DataBusDataTrait for SoldierAsset {
    fn flags(&self) -> &u16 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.flags_mut()
    }
    fn property_connections(&self) -> &Vec<super::core::PropertyConnection> {
        self._glacier_base.property_connections()
    }
    fn property_connections_mut(&mut self) -> &mut Vec<super::core::PropertyConnection> {
        self._glacier_base.property_connections_mut()
    }
    fn link_connections(&self) -> &Vec<super::core::LinkConnection> {
        self._glacier_base.link_connections()
    }
    fn link_connections_mut(&mut self) -> &mut Vec<super::core::LinkConnection> {
        self._glacier_base.link_connections_mut()
    }
    fn interface(&self) -> &Option<Arc<Mutex<dyn super::core::DynamicDataContainerTrait>>> {
        self._glacier_base.interface()
    }
    fn interface_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::DynamicDataContainerTrait>>> {
        self._glacier_base.interface_mut()
    }
}

impl super::core::AssetTrait for SoldierAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for SoldierAsset {
}

pub static SOLDIERASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierAsset",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOLDIERBLUEPRINT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierAsset as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SOLDIERASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoldierAsset {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOLDIERASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SoldierAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoldierWeaponBlueprint {
    pub _glacier_base: super::entity::ObjectBlueprint,
}

pub trait SoldierWeaponBlueprintTrait: super::entity::ObjectBlueprintTrait {
}

impl SoldierWeaponBlueprintTrait for SoldierWeaponBlueprint {
}

impl super::entity::ObjectBlueprintTrait for SoldierWeaponBlueprint {
    fn object(&self) -> &Option<Arc<Mutex<dyn super::entity::EntityDataTrait>>> {
        self._glacier_base.object()
    }
    fn object_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::EntityDataTrait>>> {
        self._glacier_base.object_mut()
    }
}

impl super::entity::BlueprintTrait for SoldierWeaponBlueprint {
    fn objects(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.objects()
    }
    fn objects_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.objects_mut()
    }
    fn schematics(&self) -> &Option<Arc<Mutex<dyn super::schematics::SchematicsBaseAssetTrait>>> {
        self._glacier_base.schematics()
    }
    fn schematics_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::schematics::SchematicsBaseAssetTrait>>> {
        self._glacier_base.schematics_mut()
    }
}

impl super::entity::EntityBusDataTrait for SoldierWeaponBlueprint {
    fn event_connections(&self) -> &Vec<super::entity::EventConnection> {
        self._glacier_base.event_connections()
    }
    fn event_connections_mut(&mut self) -> &mut Vec<super::entity::EventConnection> {
        self._glacier_base.event_connections_mut()
    }
}

impl super::core::DataBusDataTrait for SoldierWeaponBlueprint {
    fn flags(&self) -> &u16 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.flags_mut()
    }
    fn property_connections(&self) -> &Vec<super::core::PropertyConnection> {
        self._glacier_base.property_connections()
    }
    fn property_connections_mut(&mut self) -> &mut Vec<super::core::PropertyConnection> {
        self._glacier_base.property_connections_mut()
    }
    fn link_connections(&self) -> &Vec<super::core::LinkConnection> {
        self._glacier_base.link_connections()
    }
    fn link_connections_mut(&mut self) -> &mut Vec<super::core::LinkConnection> {
        self._glacier_base.link_connections_mut()
    }
    fn interface(&self) -> &Option<Arc<Mutex<dyn super::core::DynamicDataContainerTrait>>> {
        self._glacier_base.interface()
    }
    fn interface_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::DynamicDataContainerTrait>>> {
        self._glacier_base.interface_mut()
    }
}

impl super::core::AssetTrait for SoldierWeaponBlueprint {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for SoldierWeaponBlueprint {
}

pub static SOLDIERWEAPONBLUEPRINT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierWeaponBlueprint",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::OBJECTBLUEPRINT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierWeaponBlueprint as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SOLDIERWEAPONBLUEPRINT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoldierWeaponBlueprint {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERWEAPONBLUEPRINT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOLDIERWEAPONBLUEPRINT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierWeaponBlueprint-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SoldierWeaponBlueprint"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoldierBlueprint {
    pub _glacier_base: super::game_shared::CharacterBlueprint,
}

pub trait SoldierBlueprintTrait: super::game_shared::CharacterBlueprintTrait {
}

impl SoldierBlueprintTrait for SoldierBlueprint {
}

impl super::game_shared::CharacterBlueprintTrait for SoldierBlueprint {
    fn time_delta_type(&self) -> &super::entity::TimeDeltaType {
        self._glacier_base.time_delta_type()
    }
    fn time_delta_type_mut(&mut self) -> &mut super::entity::TimeDeltaType {
        self._glacier_base.time_delta_type_mut()
    }
}

impl super::entity::ObjectBlueprintTrait for SoldierBlueprint {
    fn object(&self) -> &Option<Arc<Mutex<dyn super::entity::EntityDataTrait>>> {
        self._glacier_base.object()
    }
    fn object_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::EntityDataTrait>>> {
        self._glacier_base.object_mut()
    }
}

impl super::entity::BlueprintTrait for SoldierBlueprint {
    fn objects(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.objects()
    }
    fn objects_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.objects_mut()
    }
    fn schematics(&self) -> &Option<Arc<Mutex<dyn super::schematics::SchematicsBaseAssetTrait>>> {
        self._glacier_base.schematics()
    }
    fn schematics_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::schematics::SchematicsBaseAssetTrait>>> {
        self._glacier_base.schematics_mut()
    }
}

impl super::entity::EntityBusDataTrait for SoldierBlueprint {
    fn event_connections(&self) -> &Vec<super::entity::EventConnection> {
        self._glacier_base.event_connections()
    }
    fn event_connections_mut(&mut self) -> &mut Vec<super::entity::EventConnection> {
        self._glacier_base.event_connections_mut()
    }
}

impl super::core::DataBusDataTrait for SoldierBlueprint {
    fn flags(&self) -> &u16 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.flags_mut()
    }
    fn property_connections(&self) -> &Vec<super::core::PropertyConnection> {
        self._glacier_base.property_connections()
    }
    fn property_connections_mut(&mut self) -> &mut Vec<super::core::PropertyConnection> {
        self._glacier_base.property_connections_mut()
    }
    fn link_connections(&self) -> &Vec<super::core::LinkConnection> {
        self._glacier_base.link_connections()
    }
    fn link_connections_mut(&mut self) -> &mut Vec<super::core::LinkConnection> {
        self._glacier_base.link_connections_mut()
    }
    fn interface(&self) -> &Option<Arc<Mutex<dyn super::core::DynamicDataContainerTrait>>> {
        self._glacier_base.interface()
    }
    fn interface_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::DynamicDataContainerTrait>>> {
        self._glacier_base.interface_mut()
    }
}

impl super::core::AssetTrait for SoldierBlueprint {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for SoldierBlueprint {
}

pub static SOLDIERBLUEPRINT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierBlueprint",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::game_shared::CHARACTERBLUEPRINT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierBlueprint as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SOLDIERBLUEPRINT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoldierBlueprint {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERBLUEPRINT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOLDIERBLUEPRINT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierBlueprint-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SoldierBlueprint"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoldierHealthModuleBinding {
    pub head_shot: super::ant::AntRef,
    pub left_arm_hit: super::ant::AntRef,
    pub right_arm_hit: super::ant::AntRef,
    pub left_leg_hit: super::ant::AntRef,
    pub right_leg_hit: super::ant::AntRef,
    pub on_ground: super::ant::AntRef,
    pub death_animation_triggered: super::ant::AntRef,
    pub random_animation_index: super::ant::AntRef,
    pub sprinting: super::ant::AntRef,
    pub hit_left: super::ant::AntRef,
    pub hit_right: super::ant::AntRef,
    pub hit_front: super::ant::AntRef,
    pub hit_back: super::ant::AntRef,
    pub death_hit_direction: super::ant::AntRef,
    pub explosion: super::ant::AntRef,
    pub dead: super::ant::AntRef,
    pub revived: super::ant::AntRef,
    pub random_value: super::ant::AntRef,
    pub pose: super::ant::AntRef,
    pub right_speed: super::ant::AntRef,
    pub forward_speed: super::ant::AntRef,
    pub critically_hit: super::ant::AntRef,
    pub interactive_man_down: super::ant::AntRef,
    pub health: super::ant::AntRef,
}

pub trait SoldierHealthModuleBindingTrait: TypeObject {
    fn head_shot(&self) -> &super::ant::AntRef;
    fn head_shot_mut(&mut self) -> &mut super::ant::AntRef;
    fn left_arm_hit(&self) -> &super::ant::AntRef;
    fn left_arm_hit_mut(&mut self) -> &mut super::ant::AntRef;
    fn right_arm_hit(&self) -> &super::ant::AntRef;
    fn right_arm_hit_mut(&mut self) -> &mut super::ant::AntRef;
    fn left_leg_hit(&self) -> &super::ant::AntRef;
    fn left_leg_hit_mut(&mut self) -> &mut super::ant::AntRef;
    fn right_leg_hit(&self) -> &super::ant::AntRef;
    fn right_leg_hit_mut(&mut self) -> &mut super::ant::AntRef;
    fn on_ground(&self) -> &super::ant::AntRef;
    fn on_ground_mut(&mut self) -> &mut super::ant::AntRef;
    fn death_animation_triggered(&self) -> &super::ant::AntRef;
    fn death_animation_triggered_mut(&mut self) -> &mut super::ant::AntRef;
    fn random_animation_index(&self) -> &super::ant::AntRef;
    fn random_animation_index_mut(&mut self) -> &mut super::ant::AntRef;
    fn sprinting(&self) -> &super::ant::AntRef;
    fn sprinting_mut(&mut self) -> &mut super::ant::AntRef;
    fn hit_left(&self) -> &super::ant::AntRef;
    fn hit_left_mut(&mut self) -> &mut super::ant::AntRef;
    fn hit_right(&self) -> &super::ant::AntRef;
    fn hit_right_mut(&mut self) -> &mut super::ant::AntRef;
    fn hit_front(&self) -> &super::ant::AntRef;
    fn hit_front_mut(&mut self) -> &mut super::ant::AntRef;
    fn hit_back(&self) -> &super::ant::AntRef;
    fn hit_back_mut(&mut self) -> &mut super::ant::AntRef;
    fn death_hit_direction(&self) -> &super::ant::AntRef;
    fn death_hit_direction_mut(&mut self) -> &mut super::ant::AntRef;
    fn explosion(&self) -> &super::ant::AntRef;
    fn explosion_mut(&mut self) -> &mut super::ant::AntRef;
    fn dead(&self) -> &super::ant::AntRef;
    fn dead_mut(&mut self) -> &mut super::ant::AntRef;
    fn revived(&self) -> &super::ant::AntRef;
    fn revived_mut(&mut self) -> &mut super::ant::AntRef;
    fn random_value(&self) -> &super::ant::AntRef;
    fn random_value_mut(&mut self) -> &mut super::ant::AntRef;
    fn pose(&self) -> &super::ant::AntRef;
    fn pose_mut(&mut self) -> &mut super::ant::AntRef;
    fn right_speed(&self) -> &super::ant::AntRef;
    fn right_speed_mut(&mut self) -> &mut super::ant::AntRef;
    fn forward_speed(&self) -> &super::ant::AntRef;
    fn forward_speed_mut(&mut self) -> &mut super::ant::AntRef;
    fn critically_hit(&self) -> &super::ant::AntRef;
    fn critically_hit_mut(&mut self) -> &mut super::ant::AntRef;
    fn interactive_man_down(&self) -> &super::ant::AntRef;
    fn interactive_man_down_mut(&mut self) -> &mut super::ant::AntRef;
    fn health(&self) -> &super::ant::AntRef;
    fn health_mut(&mut self) -> &mut super::ant::AntRef;
}

impl SoldierHealthModuleBindingTrait for SoldierHealthModuleBinding {
    fn head_shot(&self) -> &super::ant::AntRef {
        &self.head_shot
    }
    fn head_shot_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.head_shot
    }
    fn left_arm_hit(&self) -> &super::ant::AntRef {
        &self.left_arm_hit
    }
    fn left_arm_hit_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.left_arm_hit
    }
    fn right_arm_hit(&self) -> &super::ant::AntRef {
        &self.right_arm_hit
    }
    fn right_arm_hit_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.right_arm_hit
    }
    fn left_leg_hit(&self) -> &super::ant::AntRef {
        &self.left_leg_hit
    }
    fn left_leg_hit_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.left_leg_hit
    }
    fn right_leg_hit(&self) -> &super::ant::AntRef {
        &self.right_leg_hit
    }
    fn right_leg_hit_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.right_leg_hit
    }
    fn on_ground(&self) -> &super::ant::AntRef {
        &self.on_ground
    }
    fn on_ground_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.on_ground
    }
    fn death_animation_triggered(&self) -> &super::ant::AntRef {
        &self.death_animation_triggered
    }
    fn death_animation_triggered_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.death_animation_triggered
    }
    fn random_animation_index(&self) -> &super::ant::AntRef {
        &self.random_animation_index
    }
    fn random_animation_index_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.random_animation_index
    }
    fn sprinting(&self) -> &super::ant::AntRef {
        &self.sprinting
    }
    fn sprinting_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.sprinting
    }
    fn hit_left(&self) -> &super::ant::AntRef {
        &self.hit_left
    }
    fn hit_left_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.hit_left
    }
    fn hit_right(&self) -> &super::ant::AntRef {
        &self.hit_right
    }
    fn hit_right_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.hit_right
    }
    fn hit_front(&self) -> &super::ant::AntRef {
        &self.hit_front
    }
    fn hit_front_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.hit_front
    }
    fn hit_back(&self) -> &super::ant::AntRef {
        &self.hit_back
    }
    fn hit_back_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.hit_back
    }
    fn death_hit_direction(&self) -> &super::ant::AntRef {
        &self.death_hit_direction
    }
    fn death_hit_direction_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.death_hit_direction
    }
    fn explosion(&self) -> &super::ant::AntRef {
        &self.explosion
    }
    fn explosion_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.explosion
    }
    fn dead(&self) -> &super::ant::AntRef {
        &self.dead
    }
    fn dead_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.dead
    }
    fn revived(&self) -> &super::ant::AntRef {
        &self.revived
    }
    fn revived_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.revived
    }
    fn random_value(&self) -> &super::ant::AntRef {
        &self.random_value
    }
    fn random_value_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.random_value
    }
    fn pose(&self) -> &super::ant::AntRef {
        &self.pose
    }
    fn pose_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.pose
    }
    fn right_speed(&self) -> &super::ant::AntRef {
        &self.right_speed
    }
    fn right_speed_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.right_speed
    }
    fn forward_speed(&self) -> &super::ant::AntRef {
        &self.forward_speed
    }
    fn forward_speed_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.forward_speed
    }
    fn critically_hit(&self) -> &super::ant::AntRef {
        &self.critically_hit
    }
    fn critically_hit_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.critically_hit
    }
    fn interactive_man_down(&self) -> &super::ant::AntRef {
        &self.interactive_man_down
    }
    fn interactive_man_down_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.interactive_man_down
    }
    fn health(&self) -> &super::ant::AntRef {
        &self.health
    }
    fn health_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.health
    }
}

pub static SOLDIERHEALTHMODULEBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierHealthModuleBinding",
    flags: MemberInfoFlags::new(32841),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierHealthModuleBinding as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "HeadShot",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(SoldierHealthModuleBinding, head_shot),
            },
            FieldInfoData {
                name: "LeftArmHit",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(SoldierHealthModuleBinding, left_arm_hit),
            },
            FieldInfoData {
                name: "RightArmHit",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(SoldierHealthModuleBinding, right_arm_hit),
            },
            FieldInfoData {
                name: "LeftLegHit",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(SoldierHealthModuleBinding, left_leg_hit),
            },
            FieldInfoData {
                name: "RightLegHit",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(SoldierHealthModuleBinding, right_leg_hit),
            },
            FieldInfoData {
                name: "OnGround",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(SoldierHealthModuleBinding, on_ground),
            },
            FieldInfoData {
                name: "DeathAnimationTriggered",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(SoldierHealthModuleBinding, death_animation_triggered),
            },
            FieldInfoData {
                name: "RandomAnimationIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(SoldierHealthModuleBinding, random_animation_index),
            },
            FieldInfoData {
                name: "Sprinting",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(SoldierHealthModuleBinding, sprinting),
            },
            FieldInfoData {
                name: "HitLeft",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(SoldierHealthModuleBinding, hit_left),
            },
            FieldInfoData {
                name: "HitRight",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(SoldierHealthModuleBinding, hit_right),
            },
            FieldInfoData {
                name: "HitFront",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(SoldierHealthModuleBinding, hit_front),
            },
            FieldInfoData {
                name: "HitBack",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(SoldierHealthModuleBinding, hit_back),
            },
            FieldInfoData {
                name: "DeathHitDirection",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(SoldierHealthModuleBinding, death_hit_direction),
            },
            FieldInfoData {
                name: "Explosion",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(SoldierHealthModuleBinding, explosion),
            },
            FieldInfoData {
                name: "Dead",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(SoldierHealthModuleBinding, dead),
            },
            FieldInfoData {
                name: "Revived",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(SoldierHealthModuleBinding, revived),
            },
            FieldInfoData {
                name: "RandomValue",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(SoldierHealthModuleBinding, random_value),
            },
            FieldInfoData {
                name: "Pose",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(SoldierHealthModuleBinding, pose),
            },
            FieldInfoData {
                name: "RightSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(SoldierHealthModuleBinding, right_speed),
            },
            FieldInfoData {
                name: "ForwardSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(SoldierHealthModuleBinding, forward_speed),
            },
            FieldInfoData {
                name: "CriticallyHit",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(SoldierHealthModuleBinding, critically_hit),
            },
            FieldInfoData {
                name: "InteractiveManDown",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(SoldierHealthModuleBinding, interactive_man_down),
            },
            FieldInfoData {
                name: "Health",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(SoldierHealthModuleBinding, health),
            },
        ],
    }),
    array_type: Some(SOLDIERHEALTHMODULEBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for SoldierHealthModuleBinding {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERHEALTHMODULEBINDING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SOLDIERHEALTHMODULEBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierHealthModuleBinding-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SoldierHealthModuleBinding"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum AIDeathReactionAnimationType {
    #[default]
    AIDeathReactionAnimationType_1 = 0,
    AIDeathReactionAnimationType_2 = 1,
    AIDeathReactionAnimationType_3 = 2,
    AIDeathReactionAnimationType_4 = 3,
    AIDeathReactionAnimationType_5 = 4,
    AIDeathReactionAnimationType_Count = 5,
}

pub static AIDEATHREACTIONANIMATIONTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIDeathReactionAnimationType",
    flags: MemberInfoFlags::new(49429),
    module: "SoldierShared",
    data: TypeInfoData::Enum,
    array_type: Some(AIDEATHREACTIONANIMATIONTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AIDeathReactionAnimationType {
    fn type_info(&self) -> &'static TypeInfo {
        AIDEATHREACTIONANIMATIONTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AIDEATHREACTIONANIMATIONTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIDeathReactionAnimationType-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("AIDeathReactionAnimationType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AnimatedWeaponBinding {
    pub deploy: super::ant::AntRef,
    pub alt_deploy: super::ant::AntRef,
    pub undeploy: super::ant::AntRef,
    pub quick_switch: super::ant::AntRef,
    pub reload: super::ant::AntRef,
    pub reload_stage: super::ant::AntRef,
    pub reload_shotgun: super::ant::AntRef,
    pub fire: super::ant::AntRef,
    pub fire_single: super::ant::AntRef,
    pub fire_hold_and_release: super::ant::AntRef,
    pub fire_simple: super::ant::AntRef,
    pub first_shot_spawned: super::ant::AntRef,
    pub bolt_action: super::ant::AntRef,
    pub pump_action: super::ant::AntRef,
    pub melee_attack: super::ant::AntRef,
    pub quick_throw: super::ant::AntRef,
    pub quick_throw_type: super::ant::AntRef,
    pub aim_body: super::ant::AntRef,
    pub lower_gun: super::ant::AntRef,
    pub breath_control: super::ant::AntRef,
    pub zoom: super::ant::AntRef,
    pub canted_zoom: super::ant::AntRef,
    pub magnifier_sight_toggle: super::ant::AntRef,
    pub zoom_parameter: super::ant::AntRef,
    pub dispersion: super::ant::AntRef,
    pub zoom_out_speed: super::ant::AntRef,
    pub zoom_in_speed: super::ant::AntRef,
    pub fire_mode_changed: super::ant::AntRef,
    pub gun_down: super::ant::AntRef,
    pub allow_switching_to_weapon_in_water: super::ant::AntRef,
    pub number_of_bullets_left_in_gun: super::ant::AntRef,
    pub bullets_left_in_gun: super::ant::AntRef,
    pub abort_vehicle_deploy: super::ant::AntRef,
    pub weapon_action_e_s_i_g: super::ant::AntRef,
    pub is_sprinting: super::ant::AntRef,
    pub kickback_magnitude_factor: super::ant::AntRef,
    pub kickback_speed_factor: super::ant::AntRef,
    pub offset_x: super::ant::AntRef,
    pub offset_y: super::ant::AntRef,
    pub offset_z: super::ant::AntRef,
}

pub trait AnimatedWeaponBindingTrait: TypeObject {
    fn deploy(&self) -> &super::ant::AntRef;
    fn deploy_mut(&mut self) -> &mut super::ant::AntRef;
    fn alt_deploy(&self) -> &super::ant::AntRef;
    fn alt_deploy_mut(&mut self) -> &mut super::ant::AntRef;
    fn undeploy(&self) -> &super::ant::AntRef;
    fn undeploy_mut(&mut self) -> &mut super::ant::AntRef;
    fn quick_switch(&self) -> &super::ant::AntRef;
    fn quick_switch_mut(&mut self) -> &mut super::ant::AntRef;
    fn reload(&self) -> &super::ant::AntRef;
    fn reload_mut(&mut self) -> &mut super::ant::AntRef;
    fn reload_stage(&self) -> &super::ant::AntRef;
    fn reload_stage_mut(&mut self) -> &mut super::ant::AntRef;
    fn reload_shotgun(&self) -> &super::ant::AntRef;
    fn reload_shotgun_mut(&mut self) -> &mut super::ant::AntRef;
    fn fire(&self) -> &super::ant::AntRef;
    fn fire_mut(&mut self) -> &mut super::ant::AntRef;
    fn fire_single(&self) -> &super::ant::AntRef;
    fn fire_single_mut(&mut self) -> &mut super::ant::AntRef;
    fn fire_hold_and_release(&self) -> &super::ant::AntRef;
    fn fire_hold_and_release_mut(&mut self) -> &mut super::ant::AntRef;
    fn fire_simple(&self) -> &super::ant::AntRef;
    fn fire_simple_mut(&mut self) -> &mut super::ant::AntRef;
    fn first_shot_spawned(&self) -> &super::ant::AntRef;
    fn first_shot_spawned_mut(&mut self) -> &mut super::ant::AntRef;
    fn bolt_action(&self) -> &super::ant::AntRef;
    fn bolt_action_mut(&mut self) -> &mut super::ant::AntRef;
    fn pump_action(&self) -> &super::ant::AntRef;
    fn pump_action_mut(&mut self) -> &mut super::ant::AntRef;
    fn melee_attack(&self) -> &super::ant::AntRef;
    fn melee_attack_mut(&mut self) -> &mut super::ant::AntRef;
    fn quick_throw(&self) -> &super::ant::AntRef;
    fn quick_throw_mut(&mut self) -> &mut super::ant::AntRef;
    fn quick_throw_type(&self) -> &super::ant::AntRef;
    fn quick_throw_type_mut(&mut self) -> &mut super::ant::AntRef;
    fn aim_body(&self) -> &super::ant::AntRef;
    fn aim_body_mut(&mut self) -> &mut super::ant::AntRef;
    fn lower_gun(&self) -> &super::ant::AntRef;
    fn lower_gun_mut(&mut self) -> &mut super::ant::AntRef;
    fn breath_control(&self) -> &super::ant::AntRef;
    fn breath_control_mut(&mut self) -> &mut super::ant::AntRef;
    fn zoom(&self) -> &super::ant::AntRef;
    fn zoom_mut(&mut self) -> &mut super::ant::AntRef;
    fn canted_zoom(&self) -> &super::ant::AntRef;
    fn canted_zoom_mut(&mut self) -> &mut super::ant::AntRef;
    fn magnifier_sight_toggle(&self) -> &super::ant::AntRef;
    fn magnifier_sight_toggle_mut(&mut self) -> &mut super::ant::AntRef;
    fn zoom_parameter(&self) -> &super::ant::AntRef;
    fn zoom_parameter_mut(&mut self) -> &mut super::ant::AntRef;
    fn dispersion(&self) -> &super::ant::AntRef;
    fn dispersion_mut(&mut self) -> &mut super::ant::AntRef;
    fn zoom_out_speed(&self) -> &super::ant::AntRef;
    fn zoom_out_speed_mut(&mut self) -> &mut super::ant::AntRef;
    fn zoom_in_speed(&self) -> &super::ant::AntRef;
    fn zoom_in_speed_mut(&mut self) -> &mut super::ant::AntRef;
    fn fire_mode_changed(&self) -> &super::ant::AntRef;
    fn fire_mode_changed_mut(&mut self) -> &mut super::ant::AntRef;
    fn gun_down(&self) -> &super::ant::AntRef;
    fn gun_down_mut(&mut self) -> &mut super::ant::AntRef;
    fn allow_switching_to_weapon_in_water(&self) -> &super::ant::AntRef;
    fn allow_switching_to_weapon_in_water_mut(&mut self) -> &mut super::ant::AntRef;
    fn number_of_bullets_left_in_gun(&self) -> &super::ant::AntRef;
    fn number_of_bullets_left_in_gun_mut(&mut self) -> &mut super::ant::AntRef;
    fn bullets_left_in_gun(&self) -> &super::ant::AntRef;
    fn bullets_left_in_gun_mut(&mut self) -> &mut super::ant::AntRef;
    fn abort_vehicle_deploy(&self) -> &super::ant::AntRef;
    fn abort_vehicle_deploy_mut(&mut self) -> &mut super::ant::AntRef;
    fn weapon_action_e_s_i_g(&self) -> &super::ant::AntRef;
    fn weapon_action_e_s_i_g_mut(&mut self) -> &mut super::ant::AntRef;
    fn is_sprinting(&self) -> &super::ant::AntRef;
    fn is_sprinting_mut(&mut self) -> &mut super::ant::AntRef;
    fn kickback_magnitude_factor(&self) -> &super::ant::AntRef;
    fn kickback_magnitude_factor_mut(&mut self) -> &mut super::ant::AntRef;
    fn kickback_speed_factor(&self) -> &super::ant::AntRef;
    fn kickback_speed_factor_mut(&mut self) -> &mut super::ant::AntRef;
    fn offset_x(&self) -> &super::ant::AntRef;
    fn offset_x_mut(&mut self) -> &mut super::ant::AntRef;
    fn offset_y(&self) -> &super::ant::AntRef;
    fn offset_y_mut(&mut self) -> &mut super::ant::AntRef;
    fn offset_z(&self) -> &super::ant::AntRef;
    fn offset_z_mut(&mut self) -> &mut super::ant::AntRef;
}

impl AnimatedWeaponBindingTrait for AnimatedWeaponBinding {
    fn deploy(&self) -> &super::ant::AntRef {
        &self.deploy
    }
    fn deploy_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.deploy
    }
    fn alt_deploy(&self) -> &super::ant::AntRef {
        &self.alt_deploy
    }
    fn alt_deploy_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.alt_deploy
    }
    fn undeploy(&self) -> &super::ant::AntRef {
        &self.undeploy
    }
    fn undeploy_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.undeploy
    }
    fn quick_switch(&self) -> &super::ant::AntRef {
        &self.quick_switch
    }
    fn quick_switch_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.quick_switch
    }
    fn reload(&self) -> &super::ant::AntRef {
        &self.reload
    }
    fn reload_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.reload
    }
    fn reload_stage(&self) -> &super::ant::AntRef {
        &self.reload_stage
    }
    fn reload_stage_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.reload_stage
    }
    fn reload_shotgun(&self) -> &super::ant::AntRef {
        &self.reload_shotgun
    }
    fn reload_shotgun_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.reload_shotgun
    }
    fn fire(&self) -> &super::ant::AntRef {
        &self.fire
    }
    fn fire_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.fire
    }
    fn fire_single(&self) -> &super::ant::AntRef {
        &self.fire_single
    }
    fn fire_single_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.fire_single
    }
    fn fire_hold_and_release(&self) -> &super::ant::AntRef {
        &self.fire_hold_and_release
    }
    fn fire_hold_and_release_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.fire_hold_and_release
    }
    fn fire_simple(&self) -> &super::ant::AntRef {
        &self.fire_simple
    }
    fn fire_simple_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.fire_simple
    }
    fn first_shot_spawned(&self) -> &super::ant::AntRef {
        &self.first_shot_spawned
    }
    fn first_shot_spawned_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.first_shot_spawned
    }
    fn bolt_action(&self) -> &super::ant::AntRef {
        &self.bolt_action
    }
    fn bolt_action_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.bolt_action
    }
    fn pump_action(&self) -> &super::ant::AntRef {
        &self.pump_action
    }
    fn pump_action_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.pump_action
    }
    fn melee_attack(&self) -> &super::ant::AntRef {
        &self.melee_attack
    }
    fn melee_attack_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.melee_attack
    }
    fn quick_throw(&self) -> &super::ant::AntRef {
        &self.quick_throw
    }
    fn quick_throw_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.quick_throw
    }
    fn quick_throw_type(&self) -> &super::ant::AntRef {
        &self.quick_throw_type
    }
    fn quick_throw_type_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.quick_throw_type
    }
    fn aim_body(&self) -> &super::ant::AntRef {
        &self.aim_body
    }
    fn aim_body_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.aim_body
    }
    fn lower_gun(&self) -> &super::ant::AntRef {
        &self.lower_gun
    }
    fn lower_gun_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.lower_gun
    }
    fn breath_control(&self) -> &super::ant::AntRef {
        &self.breath_control
    }
    fn breath_control_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.breath_control
    }
    fn zoom(&self) -> &super::ant::AntRef {
        &self.zoom
    }
    fn zoom_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.zoom
    }
    fn canted_zoom(&self) -> &super::ant::AntRef {
        &self.canted_zoom
    }
    fn canted_zoom_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.canted_zoom
    }
    fn magnifier_sight_toggle(&self) -> &super::ant::AntRef {
        &self.magnifier_sight_toggle
    }
    fn magnifier_sight_toggle_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.magnifier_sight_toggle
    }
    fn zoom_parameter(&self) -> &super::ant::AntRef {
        &self.zoom_parameter
    }
    fn zoom_parameter_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.zoom_parameter
    }
    fn dispersion(&self) -> &super::ant::AntRef {
        &self.dispersion
    }
    fn dispersion_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.dispersion
    }
    fn zoom_out_speed(&self) -> &super::ant::AntRef {
        &self.zoom_out_speed
    }
    fn zoom_out_speed_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.zoom_out_speed
    }
    fn zoom_in_speed(&self) -> &super::ant::AntRef {
        &self.zoom_in_speed
    }
    fn zoom_in_speed_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.zoom_in_speed
    }
    fn fire_mode_changed(&self) -> &super::ant::AntRef {
        &self.fire_mode_changed
    }
    fn fire_mode_changed_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.fire_mode_changed
    }
    fn gun_down(&self) -> &super::ant::AntRef {
        &self.gun_down
    }
    fn gun_down_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.gun_down
    }
    fn allow_switching_to_weapon_in_water(&self) -> &super::ant::AntRef {
        &self.allow_switching_to_weapon_in_water
    }
    fn allow_switching_to_weapon_in_water_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.allow_switching_to_weapon_in_water
    }
    fn number_of_bullets_left_in_gun(&self) -> &super::ant::AntRef {
        &self.number_of_bullets_left_in_gun
    }
    fn number_of_bullets_left_in_gun_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.number_of_bullets_left_in_gun
    }
    fn bullets_left_in_gun(&self) -> &super::ant::AntRef {
        &self.bullets_left_in_gun
    }
    fn bullets_left_in_gun_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.bullets_left_in_gun
    }
    fn abort_vehicle_deploy(&self) -> &super::ant::AntRef {
        &self.abort_vehicle_deploy
    }
    fn abort_vehicle_deploy_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.abort_vehicle_deploy
    }
    fn weapon_action_e_s_i_g(&self) -> &super::ant::AntRef {
        &self.weapon_action_e_s_i_g
    }
    fn weapon_action_e_s_i_g_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.weapon_action_e_s_i_g
    }
    fn is_sprinting(&self) -> &super::ant::AntRef {
        &self.is_sprinting
    }
    fn is_sprinting_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.is_sprinting
    }
    fn kickback_magnitude_factor(&self) -> &super::ant::AntRef {
        &self.kickback_magnitude_factor
    }
    fn kickback_magnitude_factor_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.kickback_magnitude_factor
    }
    fn kickback_speed_factor(&self) -> &super::ant::AntRef {
        &self.kickback_speed_factor
    }
    fn kickback_speed_factor_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.kickback_speed_factor
    }
    fn offset_x(&self) -> &super::ant::AntRef {
        &self.offset_x
    }
    fn offset_x_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.offset_x
    }
    fn offset_y(&self) -> &super::ant::AntRef {
        &self.offset_y
    }
    fn offset_y_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.offset_y
    }
    fn offset_z(&self) -> &super::ant::AntRef {
        &self.offset_z
    }
    fn offset_z_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.offset_z
    }
}

pub static ANIMATEDWEAPONBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimatedWeaponBinding",
    flags: MemberInfoFlags::new(32841),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AnimatedWeaponBinding as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Deploy",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedWeaponBinding, deploy),
            },
            FieldInfoData {
                name: "AltDeploy",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedWeaponBinding, alt_deploy),
            },
            FieldInfoData {
                name: "Undeploy",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedWeaponBinding, undeploy),
            },
            FieldInfoData {
                name: "QuickSwitch",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedWeaponBinding, quick_switch),
            },
            FieldInfoData {
                name: "Reload",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedWeaponBinding, reload),
            },
            FieldInfoData {
                name: "ReloadStage",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedWeaponBinding, reload_stage),
            },
            FieldInfoData {
                name: "ReloadShotgun",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedWeaponBinding, reload_shotgun),
            },
            FieldInfoData {
                name: "Fire",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedWeaponBinding, fire),
            },
            FieldInfoData {
                name: "FireSingle",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedWeaponBinding, fire_single),
            },
            FieldInfoData {
                name: "FireHoldAndRelease",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedWeaponBinding, fire_hold_and_release),
            },
            FieldInfoData {
                name: "FireSimple",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedWeaponBinding, fire_simple),
            },
            FieldInfoData {
                name: "FirstShotSpawned",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedWeaponBinding, first_shot_spawned),
            },
            FieldInfoData {
                name: "BoltAction",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedWeaponBinding, bolt_action),
            },
            FieldInfoData {
                name: "PumpAction",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedWeaponBinding, pump_action),
            },
            FieldInfoData {
                name: "MeleeAttack",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedWeaponBinding, melee_attack),
            },
            FieldInfoData {
                name: "QuickThrow",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedWeaponBinding, quick_throw),
            },
            FieldInfoData {
                name: "QuickThrowType",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedWeaponBinding, quick_throw_type),
            },
            FieldInfoData {
                name: "AimBody",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedWeaponBinding, aim_body),
            },
            FieldInfoData {
                name: "LowerGun",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedWeaponBinding, lower_gun),
            },
            FieldInfoData {
                name: "BreathControl",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedWeaponBinding, breath_control),
            },
            FieldInfoData {
                name: "Zoom",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedWeaponBinding, zoom),
            },
            FieldInfoData {
                name: "CantedZoom",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedWeaponBinding, canted_zoom),
            },
            FieldInfoData {
                name: "MagnifierSightToggle",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedWeaponBinding, magnifier_sight_toggle),
            },
            FieldInfoData {
                name: "ZoomParameter",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedWeaponBinding, zoom_parameter),
            },
            FieldInfoData {
                name: "Dispersion",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedWeaponBinding, dispersion),
            },
            FieldInfoData {
                name: "ZoomOutSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedWeaponBinding, zoom_out_speed),
            },
            FieldInfoData {
                name: "ZoomInSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedWeaponBinding, zoom_in_speed),
            },
            FieldInfoData {
                name: "FireModeChanged",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedWeaponBinding, fire_mode_changed),
            },
            FieldInfoData {
                name: "GunDown",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedWeaponBinding, gun_down),
            },
            FieldInfoData {
                name: "AllowSwitchingToWeaponInWater",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedWeaponBinding, allow_switching_to_weapon_in_water),
            },
            FieldInfoData {
                name: "NumberOfBulletsLeftInGun",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedWeaponBinding, number_of_bullets_left_in_gun),
            },
            FieldInfoData {
                name: "BulletsLeftInGun",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedWeaponBinding, bullets_left_in_gun),
            },
            FieldInfoData {
                name: "AbortVehicleDeploy",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedWeaponBinding, abort_vehicle_deploy),
            },
            FieldInfoData {
                name: "WeaponActionESIG",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedWeaponBinding, weapon_action_e_s_i_g),
            },
            FieldInfoData {
                name: "IsSprinting",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedWeaponBinding, is_sprinting),
            },
            FieldInfoData {
                name: "KickbackMagnitudeFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedWeaponBinding, kickback_magnitude_factor),
            },
            FieldInfoData {
                name: "KickbackSpeedFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedWeaponBinding, kickback_speed_factor),
            },
            FieldInfoData {
                name: "OffsetX",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedWeaponBinding, offset_x),
            },
            FieldInfoData {
                name: "OffsetY",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedWeaponBinding, offset_y),
            },
            FieldInfoData {
                name: "OffsetZ",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedWeaponBinding, offset_z),
            },
        ],
    }),
    array_type: Some(ANIMATEDWEAPONBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AnimatedWeaponBinding {
    fn type_info(&self) -> &'static TypeInfo {
        ANIMATEDWEAPONBINDING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ANIMATEDWEAPONBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimatedWeaponBinding-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("AnimatedWeaponBinding"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AnimatedStaticWeaponBinding {
    pub weapon_chooser_signal: super::ant::AntRef,
    pub weapon_class_signal: super::ant::AntRef,
    pub anim_type: super::ant::AntRef,
    pub always_aim_head: super::ant::AntRef,
    pub one_handed: super::ant::AntRef,
    pub one_handed_aiming: super::ant::AntRef,
    pub aiming_enabled: super::ant::AntRef,
    pub un_deploy_speed: super::ant::AntRef,
    pub deploy_speed: super::ant::AntRef,
    pub zoom_scale_factor: super::ant::AntRef,
    pub rfl_type: super::ant::AntRef,
    pub pstl_type: super::ant::AntRef,
    pub hgr_type: super::ant::AntRef,
    pub a_t_type: super::ant::AntRef,
    pub shg_type: super::ant::AntRef,
    pub l_m_g_type: super::ant::AntRef,
    pub bag_type: super::ant::AntRef,
    pub snp_type: super::ant::AntRef,
}

pub trait AnimatedStaticWeaponBindingTrait: TypeObject {
    fn weapon_chooser_signal(&self) -> &super::ant::AntRef;
    fn weapon_chooser_signal_mut(&mut self) -> &mut super::ant::AntRef;
    fn weapon_class_signal(&self) -> &super::ant::AntRef;
    fn weapon_class_signal_mut(&mut self) -> &mut super::ant::AntRef;
    fn anim_type(&self) -> &super::ant::AntRef;
    fn anim_type_mut(&mut self) -> &mut super::ant::AntRef;
    fn always_aim_head(&self) -> &super::ant::AntRef;
    fn always_aim_head_mut(&mut self) -> &mut super::ant::AntRef;
    fn one_handed(&self) -> &super::ant::AntRef;
    fn one_handed_mut(&mut self) -> &mut super::ant::AntRef;
    fn one_handed_aiming(&self) -> &super::ant::AntRef;
    fn one_handed_aiming_mut(&mut self) -> &mut super::ant::AntRef;
    fn aiming_enabled(&self) -> &super::ant::AntRef;
    fn aiming_enabled_mut(&mut self) -> &mut super::ant::AntRef;
    fn un_deploy_speed(&self) -> &super::ant::AntRef;
    fn un_deploy_speed_mut(&mut self) -> &mut super::ant::AntRef;
    fn deploy_speed(&self) -> &super::ant::AntRef;
    fn deploy_speed_mut(&mut self) -> &mut super::ant::AntRef;
    fn zoom_scale_factor(&self) -> &super::ant::AntRef;
    fn zoom_scale_factor_mut(&mut self) -> &mut super::ant::AntRef;
    fn rfl_type(&self) -> &super::ant::AntRef;
    fn rfl_type_mut(&mut self) -> &mut super::ant::AntRef;
    fn pstl_type(&self) -> &super::ant::AntRef;
    fn pstl_type_mut(&mut self) -> &mut super::ant::AntRef;
    fn hgr_type(&self) -> &super::ant::AntRef;
    fn hgr_type_mut(&mut self) -> &mut super::ant::AntRef;
    fn a_t_type(&self) -> &super::ant::AntRef;
    fn a_t_type_mut(&mut self) -> &mut super::ant::AntRef;
    fn shg_type(&self) -> &super::ant::AntRef;
    fn shg_type_mut(&mut self) -> &mut super::ant::AntRef;
    fn l_m_g_type(&self) -> &super::ant::AntRef;
    fn l_m_g_type_mut(&mut self) -> &mut super::ant::AntRef;
    fn bag_type(&self) -> &super::ant::AntRef;
    fn bag_type_mut(&mut self) -> &mut super::ant::AntRef;
    fn snp_type(&self) -> &super::ant::AntRef;
    fn snp_type_mut(&mut self) -> &mut super::ant::AntRef;
}

impl AnimatedStaticWeaponBindingTrait for AnimatedStaticWeaponBinding {
    fn weapon_chooser_signal(&self) -> &super::ant::AntRef {
        &self.weapon_chooser_signal
    }
    fn weapon_chooser_signal_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.weapon_chooser_signal
    }
    fn weapon_class_signal(&self) -> &super::ant::AntRef {
        &self.weapon_class_signal
    }
    fn weapon_class_signal_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.weapon_class_signal
    }
    fn anim_type(&self) -> &super::ant::AntRef {
        &self.anim_type
    }
    fn anim_type_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.anim_type
    }
    fn always_aim_head(&self) -> &super::ant::AntRef {
        &self.always_aim_head
    }
    fn always_aim_head_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.always_aim_head
    }
    fn one_handed(&self) -> &super::ant::AntRef {
        &self.one_handed
    }
    fn one_handed_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.one_handed
    }
    fn one_handed_aiming(&self) -> &super::ant::AntRef {
        &self.one_handed_aiming
    }
    fn one_handed_aiming_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.one_handed_aiming
    }
    fn aiming_enabled(&self) -> &super::ant::AntRef {
        &self.aiming_enabled
    }
    fn aiming_enabled_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.aiming_enabled
    }
    fn un_deploy_speed(&self) -> &super::ant::AntRef {
        &self.un_deploy_speed
    }
    fn un_deploy_speed_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.un_deploy_speed
    }
    fn deploy_speed(&self) -> &super::ant::AntRef {
        &self.deploy_speed
    }
    fn deploy_speed_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.deploy_speed
    }
    fn zoom_scale_factor(&self) -> &super::ant::AntRef {
        &self.zoom_scale_factor
    }
    fn zoom_scale_factor_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.zoom_scale_factor
    }
    fn rfl_type(&self) -> &super::ant::AntRef {
        &self.rfl_type
    }
    fn rfl_type_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.rfl_type
    }
    fn pstl_type(&self) -> &super::ant::AntRef {
        &self.pstl_type
    }
    fn pstl_type_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.pstl_type
    }
    fn hgr_type(&self) -> &super::ant::AntRef {
        &self.hgr_type
    }
    fn hgr_type_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.hgr_type
    }
    fn a_t_type(&self) -> &super::ant::AntRef {
        &self.a_t_type
    }
    fn a_t_type_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.a_t_type
    }
    fn shg_type(&self) -> &super::ant::AntRef {
        &self.shg_type
    }
    fn shg_type_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.shg_type
    }
    fn l_m_g_type(&self) -> &super::ant::AntRef {
        &self.l_m_g_type
    }
    fn l_m_g_type_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.l_m_g_type
    }
    fn bag_type(&self) -> &super::ant::AntRef {
        &self.bag_type
    }
    fn bag_type_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.bag_type
    }
    fn snp_type(&self) -> &super::ant::AntRef {
        &self.snp_type
    }
    fn snp_type_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.snp_type
    }
}

pub static ANIMATEDSTATICWEAPONBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimatedStaticWeaponBinding",
    flags: MemberInfoFlags::new(32841),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AnimatedStaticWeaponBinding as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "WeaponChooserSignal",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedStaticWeaponBinding, weapon_chooser_signal),
            },
            FieldInfoData {
                name: "WeaponClassSignal",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedStaticWeaponBinding, weapon_class_signal),
            },
            FieldInfoData {
                name: "AnimType",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedStaticWeaponBinding, anim_type),
            },
            FieldInfoData {
                name: "AlwaysAimHead",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedStaticWeaponBinding, always_aim_head),
            },
            FieldInfoData {
                name: "OneHanded",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedStaticWeaponBinding, one_handed),
            },
            FieldInfoData {
                name: "OneHandedAiming",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedStaticWeaponBinding, one_handed_aiming),
            },
            FieldInfoData {
                name: "AimingEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedStaticWeaponBinding, aiming_enabled),
            },
            FieldInfoData {
                name: "UnDeploySpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedStaticWeaponBinding, un_deploy_speed),
            },
            FieldInfoData {
                name: "DeploySpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedStaticWeaponBinding, deploy_speed),
            },
            FieldInfoData {
                name: "ZoomScaleFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedStaticWeaponBinding, zoom_scale_factor),
            },
            FieldInfoData {
                name: "RflType",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedStaticWeaponBinding, rfl_type),
            },
            FieldInfoData {
                name: "PstlType",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedStaticWeaponBinding, pstl_type),
            },
            FieldInfoData {
                name: "HgrType",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedStaticWeaponBinding, hgr_type),
            },
            FieldInfoData {
                name: "ATType",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedStaticWeaponBinding, a_t_type),
            },
            FieldInfoData {
                name: "ShgType",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedStaticWeaponBinding, shg_type),
            },
            FieldInfoData {
                name: "LMGType",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedStaticWeaponBinding, l_m_g_type),
            },
            FieldInfoData {
                name: "BagType",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedStaticWeaponBinding, bag_type),
            },
            FieldInfoData {
                name: "SnpType",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedStaticWeaponBinding, snp_type),
            },
        ],
    }),
    array_type: Some(ANIMATEDSTATICWEAPONBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AnimatedStaticWeaponBinding {
    fn type_info(&self) -> &'static TypeInfo {
        ANIMATEDSTATICWEAPONBINDING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ANIMATEDSTATICWEAPONBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimatedStaticWeaponBinding-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("AnimatedStaticWeaponBinding"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Animated3pOnlyWeaponBinding {
    pub deploy3_p: super::ant::AntRef,
    pub hide_weapon3p: super::ant::AntRef,
    pub weapon_assembled3p: super::ant::AntRef,
}

pub trait Animated3pOnlyWeaponBindingTrait: TypeObject {
    fn deploy3_p(&self) -> &super::ant::AntRef;
    fn deploy3_p_mut(&mut self) -> &mut super::ant::AntRef;
    fn hide_weapon3p(&self) -> &super::ant::AntRef;
    fn hide_weapon3p_mut(&mut self) -> &mut super::ant::AntRef;
    fn weapon_assembled3p(&self) -> &super::ant::AntRef;
    fn weapon_assembled3p_mut(&mut self) -> &mut super::ant::AntRef;
}

impl Animated3pOnlyWeaponBindingTrait for Animated3pOnlyWeaponBinding {
    fn deploy3_p(&self) -> &super::ant::AntRef {
        &self.deploy3_p
    }
    fn deploy3_p_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.deploy3_p
    }
    fn hide_weapon3p(&self) -> &super::ant::AntRef {
        &self.hide_weapon3p
    }
    fn hide_weapon3p_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.hide_weapon3p
    }
    fn weapon_assembled3p(&self) -> &super::ant::AntRef {
        &self.weapon_assembled3p
    }
    fn weapon_assembled3p_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.weapon_assembled3p
    }
}

pub static ANIMATED3PONLYWEAPONBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Animated3pOnlyWeaponBinding",
    flags: MemberInfoFlags::new(32841),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Animated3pOnlyWeaponBinding as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Deploy3P",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(Animated3pOnlyWeaponBinding, deploy3_p),
            },
            FieldInfoData {
                name: "HideWeapon3p",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(Animated3pOnlyWeaponBinding, hide_weapon3p),
            },
            FieldInfoData {
                name: "WeaponAssembled3p",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(Animated3pOnlyWeaponBinding, weapon_assembled3p),
            },
        ],
    }),
    array_type: Some(ANIMATED3PONLYWEAPONBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for Animated3pOnlyWeaponBinding {
    fn type_info(&self) -> &'static TypeInfo {
        ANIMATED3PONLYWEAPONBINDING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ANIMATED3PONLYWEAPONBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Animated3pOnlyWeaponBinding-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("Animated3pOnlyWeaponBinding"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Animated1pOnlyWeaponBinding {
    pub undeploy_finished: super::ant::AntRef,
    pub deploy1_p: super::ant::AntRef,
    pub hide_weapon1p: super::ant::AntRef,
}

pub trait Animated1pOnlyWeaponBindingTrait: TypeObject {
    fn undeploy_finished(&self) -> &super::ant::AntRef;
    fn undeploy_finished_mut(&mut self) -> &mut super::ant::AntRef;
    fn deploy1_p(&self) -> &super::ant::AntRef;
    fn deploy1_p_mut(&mut self) -> &mut super::ant::AntRef;
    fn hide_weapon1p(&self) -> &super::ant::AntRef;
    fn hide_weapon1p_mut(&mut self) -> &mut super::ant::AntRef;
}

impl Animated1pOnlyWeaponBindingTrait for Animated1pOnlyWeaponBinding {
    fn undeploy_finished(&self) -> &super::ant::AntRef {
        &self.undeploy_finished
    }
    fn undeploy_finished_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.undeploy_finished
    }
    fn deploy1_p(&self) -> &super::ant::AntRef {
        &self.deploy1_p
    }
    fn deploy1_p_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.deploy1_p
    }
    fn hide_weapon1p(&self) -> &super::ant::AntRef {
        &self.hide_weapon1p
    }
    fn hide_weapon1p_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.hide_weapon1p
    }
}

pub static ANIMATED1PONLYWEAPONBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Animated1pOnlyWeaponBinding",
    flags: MemberInfoFlags::new(32841),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Animated1pOnlyWeaponBinding as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "UndeployFinished",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(Animated1pOnlyWeaponBinding, undeploy_finished),
            },
            FieldInfoData {
                name: "Deploy1P",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(Animated1pOnlyWeaponBinding, deploy1_p),
            },
            FieldInfoData {
                name: "HideWeapon1p",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(Animated1pOnlyWeaponBinding, hide_weapon1p),
            },
        ],
    }),
    array_type: Some(ANIMATED1PONLYWEAPONBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for Animated1pOnlyWeaponBinding {
    fn type_info(&self) -> &'static TypeInfo {
        ANIMATED1PONLYWEAPONBINDING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ANIMATED1PONLYWEAPONBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Animated1pOnlyWeaponBinding-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("Animated1pOnlyWeaponBinding"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AimingSimulationEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub aiming_controllers: Vec<Option<Arc<Mutex<dyn SoldierAimingSimulationDataTrait>>>>,
    pub current_index: i32,
}

pub trait AimingSimulationEntityDataTrait: super::entity::EntityDataTrait {
    fn aiming_controllers(&self) -> &Vec<Option<Arc<Mutex<dyn SoldierAimingSimulationDataTrait>>>>;
    fn aiming_controllers_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn SoldierAimingSimulationDataTrait>>>>;
    fn current_index(&self) -> &i32;
    fn current_index_mut(&mut self) -> &mut i32;
}

impl AimingSimulationEntityDataTrait for AimingSimulationEntityData {
    fn aiming_controllers(&self) -> &Vec<Option<Arc<Mutex<dyn SoldierAimingSimulationDataTrait>>>> {
        &self.aiming_controllers
    }
    fn aiming_controllers_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn SoldierAimingSimulationDataTrait>>>> {
        &mut self.aiming_controllers
    }
    fn current_index(&self) -> &i32 {
        &self.current_index
    }
    fn current_index_mut(&mut self) -> &mut i32 {
        &mut self.current_index
    }
}

impl super::entity::EntityDataTrait for AimingSimulationEntityData {
}

impl super::entity::GameObjectDataTrait for AimingSimulationEntityData {
}

impl super::core::DataBusPeerTrait for AimingSimulationEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AimingSimulationEntityData {
}

impl super::core::DataContainerTrait for AimingSimulationEntityData {
}

pub static AIMINGSIMULATIONENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AimingSimulationEntityData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AimingSimulationEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AimingControllers",
                flags: MemberInfoFlags::new(144),
                field_type: "SoldierAimingSimulationData-Array",
                rust_offset: offset_of!(AimingSimulationEntityData, aiming_controllers),
            },
            FieldInfoData {
                name: "CurrentIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AimingSimulationEntityData, current_index),
            },
        ],
    }),
    array_type: Some(AIMINGSIMULATIONENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AimingSimulationEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AIMINGSIMULATIONENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIMINGSIMULATIONENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AimingSimulationEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("AimingSimulationEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AimingScaleDataProviderEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub enabled: bool,
    pub scale_priority: i32,
    pub aiming_scale: AimingScaleData,
}

pub trait AimingScaleDataProviderEntityDataTrait: super::entity::EntityDataTrait {
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
    fn scale_priority(&self) -> &i32;
    fn scale_priority_mut(&mut self) -> &mut i32;
    fn aiming_scale(&self) -> &AimingScaleData;
    fn aiming_scale_mut(&mut self) -> &mut AimingScaleData;
}

impl AimingScaleDataProviderEntityDataTrait for AimingScaleDataProviderEntityData {
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
    fn scale_priority(&self) -> &i32 {
        &self.scale_priority
    }
    fn scale_priority_mut(&mut self) -> &mut i32 {
        &mut self.scale_priority
    }
    fn aiming_scale(&self) -> &AimingScaleData {
        &self.aiming_scale
    }
    fn aiming_scale_mut(&mut self) -> &mut AimingScaleData {
        &mut self.aiming_scale
    }
}

impl super::entity::EntityDataTrait for AimingScaleDataProviderEntityData {
}

impl super::entity::GameObjectDataTrait for AimingScaleDataProviderEntityData {
}

impl super::core::DataBusPeerTrait for AimingScaleDataProviderEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AimingScaleDataProviderEntityData {
}

impl super::core::DataContainerTrait for AimingScaleDataProviderEntityData {
}

pub static AIMINGSCALEDATAPROVIDERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AimingScaleDataProviderEntityData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AimingScaleDataProviderEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AimingScaleDataProviderEntityData, enabled),
            },
            FieldInfoData {
                name: "ScalePriority",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AimingScaleDataProviderEntityData, scale_priority),
            },
            FieldInfoData {
                name: "AimingScale",
                flags: MemberInfoFlags::new(0),
                field_type: "AimingScaleData",
                rust_offset: offset_of!(AimingScaleDataProviderEntityData, aiming_scale),
            },
        ],
    }),
    array_type: Some(AIMINGSCALEDATAPROVIDERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AimingScaleDataProviderEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AIMINGSCALEDATAPROVIDERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIMINGSCALEDATAPROVIDERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AimingScaleDataProviderEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("AimingScaleDataProviderEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AimingScaleData {
    pub yaw_scale: f32,
    pub pitch_scale: f32,
}

pub trait AimingScaleDataTrait: TypeObject {
    fn yaw_scale(&self) -> &f32;
    fn yaw_scale_mut(&mut self) -> &mut f32;
    fn pitch_scale(&self) -> &f32;
    fn pitch_scale_mut(&mut self) -> &mut f32;
}

impl AimingScaleDataTrait for AimingScaleData {
    fn yaw_scale(&self) -> &f32 {
        &self.yaw_scale
    }
    fn yaw_scale_mut(&mut self) -> &mut f32 {
        &mut self.yaw_scale
    }
    fn pitch_scale(&self) -> &f32 {
        &self.pitch_scale
    }
    fn pitch_scale_mut(&mut self) -> &mut f32 {
        &mut self.pitch_scale
    }
}

pub static AIMINGSCALEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AimingScaleData",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AimingScaleData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "YawScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AimingScaleData, yaw_scale),
            },
            FieldInfoData {
                name: "PitchScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AimingScaleData, pitch_scale),
            },
        ],
    }),
    array_type: Some(AIMINGSCALEDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AimingScaleData {
    fn type_info(&self) -> &'static TypeInfo {
        AIMINGSCALEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AIMINGSCALEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AimingScaleData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("AimingScaleData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AimingAngularSpeedConstraintDataProviderEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub enabled: bool,
    pub constraint_priority: i32,
    pub aiming_angular_speed_constraints: AimingAngularSpeedConstraintData,
}

pub trait AimingAngularSpeedConstraintDataProviderEntityDataTrait: super::entity::EntityDataTrait {
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
    fn constraint_priority(&self) -> &i32;
    fn constraint_priority_mut(&mut self) -> &mut i32;
    fn aiming_angular_speed_constraints(&self) -> &AimingAngularSpeedConstraintData;
    fn aiming_angular_speed_constraints_mut(&mut self) -> &mut AimingAngularSpeedConstraintData;
}

impl AimingAngularSpeedConstraintDataProviderEntityDataTrait for AimingAngularSpeedConstraintDataProviderEntityData {
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
    fn constraint_priority(&self) -> &i32 {
        &self.constraint_priority
    }
    fn constraint_priority_mut(&mut self) -> &mut i32 {
        &mut self.constraint_priority
    }
    fn aiming_angular_speed_constraints(&self) -> &AimingAngularSpeedConstraintData {
        &self.aiming_angular_speed_constraints
    }
    fn aiming_angular_speed_constraints_mut(&mut self) -> &mut AimingAngularSpeedConstraintData {
        &mut self.aiming_angular_speed_constraints
    }
}

impl super::entity::EntityDataTrait for AimingAngularSpeedConstraintDataProviderEntityData {
}

impl super::entity::GameObjectDataTrait for AimingAngularSpeedConstraintDataProviderEntityData {
}

impl super::core::DataBusPeerTrait for AimingAngularSpeedConstraintDataProviderEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AimingAngularSpeedConstraintDataProviderEntityData {
}

impl super::core::DataContainerTrait for AimingAngularSpeedConstraintDataProviderEntityData {
}

pub static AIMINGANGULARSPEEDCONSTRAINTDATAPROVIDERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AimingAngularSpeedConstraintDataProviderEntityData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AimingAngularSpeedConstraintDataProviderEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AimingAngularSpeedConstraintDataProviderEntityData, enabled),
            },
            FieldInfoData {
                name: "ConstraintPriority",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AimingAngularSpeedConstraintDataProviderEntityData, constraint_priority),
            },
            FieldInfoData {
                name: "AimingAngularSpeedConstraints",
                flags: MemberInfoFlags::new(0),
                field_type: "AimingAngularSpeedConstraintData",
                rust_offset: offset_of!(AimingAngularSpeedConstraintDataProviderEntityData, aiming_angular_speed_constraints),
            },
        ],
    }),
    array_type: Some(AIMINGANGULARSPEEDCONSTRAINTDATAPROVIDERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AimingAngularSpeedConstraintDataProviderEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AIMINGANGULARSPEEDCONSTRAINTDATAPROVIDERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIMINGANGULARSPEEDCONSTRAINTDATAPROVIDERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AimingAngularSpeedConstraintDataProviderEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("AimingAngularSpeedConstraintDataProviderEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AimingAngularSpeedConstraintData {
    pub yaw_speed: f32,
    pub pitch_speed: f32,
}

pub trait AimingAngularSpeedConstraintDataTrait: TypeObject {
    fn yaw_speed(&self) -> &f32;
    fn yaw_speed_mut(&mut self) -> &mut f32;
    fn pitch_speed(&self) -> &f32;
    fn pitch_speed_mut(&mut self) -> &mut f32;
}

impl AimingAngularSpeedConstraintDataTrait for AimingAngularSpeedConstraintData {
    fn yaw_speed(&self) -> &f32 {
        &self.yaw_speed
    }
    fn yaw_speed_mut(&mut self) -> &mut f32 {
        &mut self.yaw_speed
    }
    fn pitch_speed(&self) -> &f32 {
        &self.pitch_speed
    }
    fn pitch_speed_mut(&mut self) -> &mut f32 {
        &mut self.pitch_speed
    }
}

pub static AIMINGANGULARSPEEDCONSTRAINTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AimingAngularSpeedConstraintData",
    flags: MemberInfoFlags::new(36937),
    module: "SoldierShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AimingAngularSpeedConstraintData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "YawSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AimingAngularSpeedConstraintData, yaw_speed),
            },
            FieldInfoData {
                name: "PitchSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AimingAngularSpeedConstraintData, pitch_speed),
            },
        ],
    }),
    array_type: Some(AIMINGANGULARSPEEDCONSTRAINTDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AimingAngularSpeedConstraintData {
    fn type_info(&self) -> &'static TypeInfo {
        AIMINGANGULARSPEEDCONSTRAINTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AIMINGANGULARSPEEDCONSTRAINTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AimingAngularSpeedConstraintData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("AimingAngularSpeedConstraintData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ReplicatedAimEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
}

pub trait ReplicatedAimEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
}

impl ReplicatedAimEntityDataTrait for ReplicatedAimEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
}

impl super::entity::EntityDataTrait for ReplicatedAimEntityData {
}

impl super::entity::GameObjectDataTrait for ReplicatedAimEntityData {
}

impl super::core::DataBusPeerTrait for ReplicatedAimEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ReplicatedAimEntityData {
}

impl super::core::DataContainerTrait for ReplicatedAimEntityData {
}

pub static REPLICATEDAIMENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReplicatedAimEntityData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ReplicatedAimEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(ReplicatedAimEntityData, realm),
            },
        ],
    }),
    array_type: Some(REPLICATEDAIMENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ReplicatedAimEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        REPLICATEDAIMENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static REPLICATEDAIMENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReplicatedAimEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("ReplicatedAimEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SchematicsAimEntityData {
    pub _glacier_base: AimEntityBaseData,
    pub hit_position: super::core::Vec3,
}

pub trait SchematicsAimEntityDataTrait: AimEntityBaseDataTrait {
    fn hit_position(&self) -> &super::core::Vec3;
    fn hit_position_mut(&mut self) -> &mut super::core::Vec3;
}

impl SchematicsAimEntityDataTrait for SchematicsAimEntityData {
    fn hit_position(&self) -> &super::core::Vec3 {
        &self.hit_position
    }
    fn hit_position_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.hit_position
    }
}

impl AimEntityBaseDataTrait for SchematicsAimEntityData {
}

impl super::entity::EntityDataTrait for SchematicsAimEntityData {
}

impl super::entity::GameObjectDataTrait for SchematicsAimEntityData {
}

impl super::core::DataBusPeerTrait for SchematicsAimEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SchematicsAimEntityData {
}

impl super::core::DataContainerTrait for SchematicsAimEntityData {
}

pub static SCHEMATICSAIMENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SchematicsAimEntityData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIMENTITYBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SchematicsAimEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "HitPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SchematicsAimEntityData, hit_position),
            },
        ],
    }),
    array_type: Some(SCHEMATICSAIMENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SchematicsAimEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SCHEMATICSAIMENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SCHEMATICSAIMENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SchematicsAimEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("SchematicsAimEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AimEntityData {
    pub _glacier_base: AimEntityBaseData,
    pub excluded: bool,
    pub default_aiming_controller: Option<Arc<Mutex<dyn SoldierAimingSimulationDataTrait>>>,
    pub yaw_input: i32,
    pub pitch_input: i32,
    pub throttle_input: i32,
    pub strafe_input: i32,
    pub time_to_delay_after_collision: f32,
    pub collision_blend_out: f32,
    pub allow_blend_out: bool,
    pub override_aim: bool,
    pub aim_override_transform: super::core::LinearTransform,
    pub aim_override_mode_blend: bool,
    pub aim_at_last_hit_position: bool,
    pub follow_offset: super::core::Vec3,
    pub suppression_value: f32,
}

pub trait AimEntityDataTrait: AimEntityBaseDataTrait {
    fn excluded(&self) -> &bool;
    fn excluded_mut(&mut self) -> &mut bool;
    fn default_aiming_controller(&self) -> &Option<Arc<Mutex<dyn SoldierAimingSimulationDataTrait>>>;
    fn default_aiming_controller_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoldierAimingSimulationDataTrait>>>;
    fn yaw_input(&self) -> &i32;
    fn yaw_input_mut(&mut self) -> &mut i32;
    fn pitch_input(&self) -> &i32;
    fn pitch_input_mut(&mut self) -> &mut i32;
    fn throttle_input(&self) -> &i32;
    fn throttle_input_mut(&mut self) -> &mut i32;
    fn strafe_input(&self) -> &i32;
    fn strafe_input_mut(&mut self) -> &mut i32;
    fn time_to_delay_after_collision(&self) -> &f32;
    fn time_to_delay_after_collision_mut(&mut self) -> &mut f32;
    fn collision_blend_out(&self) -> &f32;
    fn collision_blend_out_mut(&mut self) -> &mut f32;
    fn allow_blend_out(&self) -> &bool;
    fn allow_blend_out_mut(&mut self) -> &mut bool;
    fn override_aim(&self) -> &bool;
    fn override_aim_mut(&mut self) -> &mut bool;
    fn aim_override_transform(&self) -> &super::core::LinearTransform;
    fn aim_override_transform_mut(&mut self) -> &mut super::core::LinearTransform;
    fn aim_override_mode_blend(&self) -> &bool;
    fn aim_override_mode_blend_mut(&mut self) -> &mut bool;
    fn aim_at_last_hit_position(&self) -> &bool;
    fn aim_at_last_hit_position_mut(&mut self) -> &mut bool;
    fn follow_offset(&self) -> &super::core::Vec3;
    fn follow_offset_mut(&mut self) -> &mut super::core::Vec3;
    fn suppression_value(&self) -> &f32;
    fn suppression_value_mut(&mut self) -> &mut f32;
}

impl AimEntityDataTrait for AimEntityData {
    fn excluded(&self) -> &bool {
        &self.excluded
    }
    fn excluded_mut(&mut self) -> &mut bool {
        &mut self.excluded
    }
    fn default_aiming_controller(&self) -> &Option<Arc<Mutex<dyn SoldierAimingSimulationDataTrait>>> {
        &self.default_aiming_controller
    }
    fn default_aiming_controller_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoldierAimingSimulationDataTrait>>> {
        &mut self.default_aiming_controller
    }
    fn yaw_input(&self) -> &i32 {
        &self.yaw_input
    }
    fn yaw_input_mut(&mut self) -> &mut i32 {
        &mut self.yaw_input
    }
    fn pitch_input(&self) -> &i32 {
        &self.pitch_input
    }
    fn pitch_input_mut(&mut self) -> &mut i32 {
        &mut self.pitch_input
    }
    fn throttle_input(&self) -> &i32 {
        &self.throttle_input
    }
    fn throttle_input_mut(&mut self) -> &mut i32 {
        &mut self.throttle_input
    }
    fn strafe_input(&self) -> &i32 {
        &self.strafe_input
    }
    fn strafe_input_mut(&mut self) -> &mut i32 {
        &mut self.strafe_input
    }
    fn time_to_delay_after_collision(&self) -> &f32 {
        &self.time_to_delay_after_collision
    }
    fn time_to_delay_after_collision_mut(&mut self) -> &mut f32 {
        &mut self.time_to_delay_after_collision
    }
    fn collision_blend_out(&self) -> &f32 {
        &self.collision_blend_out
    }
    fn collision_blend_out_mut(&mut self) -> &mut f32 {
        &mut self.collision_blend_out
    }
    fn allow_blend_out(&self) -> &bool {
        &self.allow_blend_out
    }
    fn allow_blend_out_mut(&mut self) -> &mut bool {
        &mut self.allow_blend_out
    }
    fn override_aim(&self) -> &bool {
        &self.override_aim
    }
    fn override_aim_mut(&mut self) -> &mut bool {
        &mut self.override_aim
    }
    fn aim_override_transform(&self) -> &super::core::LinearTransform {
        &self.aim_override_transform
    }
    fn aim_override_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.aim_override_transform
    }
    fn aim_override_mode_blend(&self) -> &bool {
        &self.aim_override_mode_blend
    }
    fn aim_override_mode_blend_mut(&mut self) -> &mut bool {
        &mut self.aim_override_mode_blend
    }
    fn aim_at_last_hit_position(&self) -> &bool {
        &self.aim_at_last_hit_position
    }
    fn aim_at_last_hit_position_mut(&mut self) -> &mut bool {
        &mut self.aim_at_last_hit_position
    }
    fn follow_offset(&self) -> &super::core::Vec3 {
        &self.follow_offset
    }
    fn follow_offset_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.follow_offset
    }
    fn suppression_value(&self) -> &f32 {
        &self.suppression_value
    }
    fn suppression_value_mut(&mut self) -> &mut f32 {
        &mut self.suppression_value
    }
}

impl AimEntityBaseDataTrait for AimEntityData {
}

impl super::entity::EntityDataTrait for AimEntityData {
}

impl super::entity::GameObjectDataTrait for AimEntityData {
}

impl super::core::DataBusPeerTrait for AimEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AimEntityData {
}

impl super::core::DataContainerTrait for AimEntityData {
}

pub static AIMENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AimEntityData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIMENTITYBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AimEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Excluded",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AimEntityData, excluded),
            },
            FieldInfoData {
                name: "DefaultAimingController",
                flags: MemberInfoFlags::new(0),
                field_type: "SoldierAimingSimulationData",
                rust_offset: offset_of!(AimEntityData, default_aiming_controller),
            },
            FieldInfoData {
                name: "YawInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AimEntityData, yaw_input),
            },
            FieldInfoData {
                name: "PitchInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AimEntityData, pitch_input),
            },
            FieldInfoData {
                name: "ThrottleInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AimEntityData, throttle_input),
            },
            FieldInfoData {
                name: "StrafeInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AimEntityData, strafe_input),
            },
            FieldInfoData {
                name: "TimeToDelayAfterCollision",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AimEntityData, time_to_delay_after_collision),
            },
            FieldInfoData {
                name: "CollisionBlendOut",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AimEntityData, collision_blend_out),
            },
            FieldInfoData {
                name: "AllowBlendOut",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AimEntityData, allow_blend_out),
            },
            FieldInfoData {
                name: "OverrideAim",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AimEntityData, override_aim),
            },
            FieldInfoData {
                name: "AimOverrideTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(AimEntityData, aim_override_transform),
            },
            FieldInfoData {
                name: "AimOverrideModeBlend",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AimEntityData, aim_override_mode_blend),
            },
            FieldInfoData {
                name: "AimAtLastHitPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AimEntityData, aim_at_last_hit_position),
            },
            FieldInfoData {
                name: "FollowOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(AimEntityData, follow_offset),
            },
            FieldInfoData {
                name: "SuppressionValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AimEntityData, suppression_value),
            },
        ],
    }),
    array_type: Some(AIMENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AimEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AIMENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIMENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AimEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("AimEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AimEntityBaseData {
    pub _glacier_base: super::entity::EntityData,
}

pub trait AimEntityBaseDataTrait: super::entity::EntityDataTrait {
}

impl AimEntityBaseDataTrait for AimEntityBaseData {
}

impl super::entity::EntityDataTrait for AimEntityBaseData {
}

impl super::entity::GameObjectDataTrait for AimEntityBaseData {
}

impl super::core::DataBusPeerTrait for AimEntityBaseData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AimEntityBaseData {
}

impl super::core::DataContainerTrait for AimEntityBaseData {
}

pub static AIMENTITYBASEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AimEntityBaseData",
    flags: MemberInfoFlags::new(101),
    module: "SoldierShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AimEntityBaseData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(AIMENTITYBASEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AimEntityBaseData {
    fn type_info(&self) -> &'static TypeInfo {
        AIMENTITYBASEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIMENTITYBASEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AimEntityBaseData-Array",
    flags: MemberInfoFlags::new(145),
    module: "SoldierShared",
    data: TypeInfoData::Array("AimEntityBaseData"),
    array_type: None,
    alignment: 8,
};


