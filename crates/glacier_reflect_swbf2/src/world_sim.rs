use std::{mem::offset_of, any::Any, option::Option, sync::Arc};
use tokio::sync::Mutex;

use glacier_reflect::{
    member::MemberInfoFlags,
    type_info::{
        ClassInfoData, ValueTypeInfoData, FieldInfoData, TypeInfo, TypeInfoData, TypeObject, TypeFunctions,
    }, type_registry::TypeRegistry,
};

pub(crate) fn register_world_sim_types(registry: &mut TypeRegistry) {
    registry.register_type(FORCEMANAGERSETTINGS_TYPE_INFO);
    registry.register_type(FORCEMANAGERSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(LOCALWINDFORCEBAKED3DAS2X2DTEXENTITYDATA_TYPE_INFO);
    registry.register_type(LOCALWINDFORCEBAKED3DAS2X2DTEXENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOCALWINDFORCECONEENTITYDATA_TYPE_INFO);
    registry.register_type(LOCALWINDFORCECONEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOCALWINDFORCESPHEREENTITYDATA_TYPE_INFO);
    registry.register_type(LOCALWINDFORCESPHEREENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOCALWINDFORCESAMPLERENTITYDATA_TYPE_INFO);
    registry.register_type(LOCALWINDFORCESAMPLERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOCALWINDFORCEENTITYBASEDATA_TYPE_INFO);
    registry.register_type(LOCALWINDFORCEENTITYBASEDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOCALWINDFORCEDYNAMICSTATE_TYPE_INFO);
    registry.register_type(LOCALWINDFORCEDYNAMICSTATE_ARRAY_TYPE_INFO);
    registry.register_type(LOCALWINDFORCESTATICSTATE_TYPE_INFO);
    registry.register_type(LOCALWINDFORCESTATICSTATE_ARRAY_TYPE_INFO);
    registry.register_type(FORCEGROUPASSET_TYPE_INFO);
    registry.register_type(FORCEGROUPASSET_ARRAY_TYPE_INFO);
    registry.register_type(LOCALWINDFORCEBAKED3DAS2X2DTEXCOMPONENTDATA_TYPE_INFO);
    registry.register_type(LOCALWINDFORCEBAKED3DAS2X2DTEXCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOCALWINDFORCECONECOMPONENTDATA_TYPE_INFO);
    registry.register_type(LOCALWINDFORCECONECOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOCALWINDFORCESPHERECOMPONENTDATA_TYPE_INFO);
    registry.register_type(LOCALWINDFORCESPHERECOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOCALWINDFORCECOMPONENTBASEDATA_TYPE_INFO);
    registry.register_type(LOCALWINDFORCECOMPONENTBASEDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOGICVISUALENVIRONMENTREFERENCEOBJECTDATA_TYPE_INFO);
    registry.register_type(LOGICVISUALENVIRONMENTREFERENCEOBJECTDATA_ARRAY_TYPE_INFO);
    registry.register_type(VISUALENVIRONMENTREFERENCEOBJECTDATA_TYPE_INFO);
    registry.register_type(VISUALENVIRONMENTREFERENCEOBJECTDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOGICVISUALENVIRONMENTENTITYDATA_TYPE_INFO);
    registry.register_type(LOGICVISUALENVIRONMENTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VISUALENVIRONMENTBLUEPRINT_TYPE_INFO);
    registry.register_type(VISUALENVIRONMENTBLUEPRINT_ARRAY_TYPE_INFO);
    registry.register_type(VISUALENVIRONMENTENTITYDATA_TYPE_INFO);
    registry.register_type(VISUALENVIRONMENTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VISUALENVIRONMENTPRIORITYOFFSET_TYPE_INFO);
    registry.register_type(VISUALENVIRONMENTPRIORITYOFFSET_ARRAY_TYPE_INFO);
    registry.register_type(VISUALENVIRONMENTBLENDMODE_TYPE_INFO);
    registry.register_type(VISUALENVIRONMENTBLENDMODE_ARRAY_TYPE_INFO);
    registry.register_type(SONARPARAMSCOMPONENTDATA_TYPE_INFO);
    registry.register_type(SONARPARAMSCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(HOLOGRAMPARAMSCOMPONENTDATA_TYPE_INFO);
    registry.register_type(HOLOGRAMPARAMSCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(THREATALERTHIGHLIGHTPARAMSCOMPONENTDATA_TYPE_INFO);
    registry.register_type(THREATALERTHIGHLIGHTPARAMSCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(OBJECTHIGHLIGHTPARAMSCOMPONENTDATA_TYPE_INFO);
    registry.register_type(OBJECTHIGHLIGHTPARAMSCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(FILMICEFFECTSCOMPONENTDATA_TYPE_INFO);
    registry.register_type(FILMICEFFECTSCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(DEBUGCOMPONENTDATA_TYPE_INFO);
    registry.register_type(DEBUGCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(LENSSCOPECOMPONENTDATA_TYPE_INFO);
    registry.register_type(LENSSCOPECOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(FILMGRAINCOMPONENTDATA_TYPE_INFO);
    registry.register_type(FILMGRAINCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(VIGNETTECOMPONENTDATA_TYPE_INFO);
    registry.register_type(VIGNETTECOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(DOFCOMPONENTDATA_TYPE_INFO);
    registry.register_type(DOFCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(COLORCORRECTIONCOMPONENTDATA_TYPE_INFO);
    registry.register_type(COLORCORRECTIONCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(TONEMAPCOMPONENTDATA_TYPE_INFO);
    registry.register_type(TONEMAPCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(SKYCELESTIALMULTICOMPONENTDATA_TYPE_INFO);
    registry.register_type(SKYCELESTIALMULTICOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(SKYCELESTIALSINGLECOMPONENTDATA_TYPE_INFO);
    registry.register_type(SKYCELESTIALSINGLECOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(SKYCELESTIALROTATIONCOMPONENTDATA_TYPE_INFO);
    registry.register_type(SKYCELESTIALROTATIONCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(EMITTERPARAMGLOBALCOMPONENTDATA_TYPE_INFO);
    registry.register_type(EMITTERPARAMGLOBALCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(EMITTERPARAMCOMPONENTDATA_TYPE_INFO);
    registry.register_type(EMITTERPARAMCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(RAYTRACEREFLECTIONCOMPONENTDATA_TYPE_INFO);
    registry.register_type(RAYTRACEREFLECTIONCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(SCREENSPACERAYTRACECOMPONENTDATA_TYPE_INFO);
    registry.register_type(SCREENSPACERAYTRACECOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(MOTIONBLURCOMPONENTDATA_TYPE_INFO);
    registry.register_type(MOTIONBLURCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERLIGHTINGCOMPONENTDATA_TYPE_INFO);
    registry.register_type(CHARACTERLIGHTINGCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(DAMAGEEFFECTCOMPONENTDATA_TYPE_INFO);
    registry.register_type(DAMAGEEFFECTCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(SCREENEFFECTCOMPONENTDATA_TYPE_INFO);
    registry.register_type(SCREENEFFECTCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(SHADOWSCOMPONENTDATA_TYPE_INFO);
    registry.register_type(SHADOWSCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(MESHSETTINGSCOMPONENTDATA_TYPE_INFO);
    registry.register_type(MESHSETTINGSCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(CAMERAPARAMSCOMPONENTDATA_TYPE_INFO);
    registry.register_type(CAMERAPARAMSCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(SHADERCOLORPARAMSCOMPONENTDATA_TYPE_INFO);
    registry.register_type(SHADERCOLORPARAMSCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(SHADERPARAMSCOMPONENTDATA_TYPE_INFO);
    registry.register_type(SHADERPARAMSCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(ENLIGHTENCOMPONENTDATA_TYPE_INFO);
    registry.register_type(ENLIGHTENCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(SUBSURFACESCATTERINGCOMPONENTDATA_TYPE_INFO);
    registry.register_type(SUBSURFACESCATTERINGCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(DYNAMICAOCOMPONENTDATA_TYPE_INFO);
    registry.register_type(DYNAMICAOCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANTIALIASCOMPONENTDATA_TYPE_INFO);
    registry.register_type(ANTIALIASCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(LENSREFLECTIONCOMPONENTDATA_TYPE_INFO);
    registry.register_type(LENSREFLECTIONCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(SUNFLARECOMPONENTDATA_TYPE_INFO);
    registry.register_type(SUNFLARECOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(CLOUDCOMPONENTDATA_TYPE_INFO);
    registry.register_type(CLOUDCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(WINDCOMPONENTDATA_TYPE_INFO);
    registry.register_type(WINDCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(DYNAMICENVMAPCOMPONENTDATA_TYPE_INFO);
    registry.register_type(DYNAMICENVMAPCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(PLANARREFLECTIONCOMPONENTDATA_TYPE_INFO);
    registry.register_type(PLANARREFLECTIONCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(SKYCOMPONENTDATA_TYPE_INFO);
    registry.register_type(SKYCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(FOGCOMPONENTDATA_TYPE_INFO);
    registry.register_type(FOGCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(OUTDOORLIGHTCOMPONENTDATA_TYPE_INFO);
    registry.register_type(OUTDOORLIGHTCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(INDIRECTSPECULARCOMPONENTDATA_TYPE_INFO);
    registry.register_type(INDIRECTSPECULARCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(VISUALENVIRONMENTCOMPONENTDATA_TYPE_INFO);
    registry.register_type(VISUALENVIRONMENTCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(CUSTOMSTRINGPARAM_TYPE_INFO);
    registry.register_type(CUSTOMSTRINGPARAM_ARRAY_TYPE_INFO);
    registry.register_type(FILEFRAMENAMINGENUM_TYPE_INFO);
    registry.register_type(FILEFRAMENAMINGENUM_ARRAY_TYPE_INFO);
    registry.register_type(LAYERMODEENUM_TYPE_INFO);
    registry.register_type(LAYERMODEENUM_ARRAY_TYPE_INFO);
    registry.register_type(IMAGETYPEENUM_TYPE_INFO);
    registry.register_type(IMAGETYPEENUM_ARRAY_TYPE_INFO);
    registry.register_type(RENDERFRAMESTRACKDATA_TYPE_INFO);
    registry.register_type(RENDERFRAMESTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(RENDERFRAMESKEYFRAME_TYPE_INFO);
    registry.register_type(RENDERFRAMESKEYFRAME_ARRAY_TYPE_INFO);
    registry.register_type(SIMPLEVOLUMETRICSENTITYDATA_TYPE_INFO);
    registry.register_type(SIMPLEVOLUMETRICSENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SCREENSHOTCAPTUREENTITYDATA_TYPE_INFO);
    registry.register_type(SCREENSHOTCAPTUREENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(OCCLUDERVOLUMEENTITYDATA_TYPE_INFO);
    registry.register_type(OCCLUDERVOLUMEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(OCCLUDERPLANEENTITYDATA_TYPE_INFO);
    registry.register_type(OCCLUDERPLANEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(OCCLUDERMESHENTITYDATA_TYPE_INFO);
    registry.register_type(OCCLUDERMESHENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VISIBLEAREAENTITYDATA_TYPE_INFO);
    registry.register_type(VISIBLEAREAENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PLANARREFLECTIONLOCATORENTITYDATA_TYPE_INFO);
    registry.register_type(PLANARREFLECTIONLOCATORENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(LIGHTPROBEVOLUMEDATA_TYPE_INFO);
    registry.register_type(LIGHTPROBEVOLUMEDATA_ARRAY_TYPE_INFO);
    registry.register_type(STATICENLIGHTENENTITYDATA_TYPE_INFO);
    registry.register_type(STATICENLIGHTENENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(DYNAMICENLIGHTENENTITYDATA_TYPE_INFO);
    registry.register_type(DYNAMICENLIGHTENENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(ENLIGHTENENTITYDATA_TYPE_INFO);
    registry.register_type(ENLIGHTENENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(RADIOSITYMODIFIERENTITYDATA_TYPE_INFO);
    registry.register_type(RADIOSITYMODIFIERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(RADIOSITYMATERIALOPACITYTRIGGERENTITYDATA_TYPE_INFO);
    registry.register_type(RADIOSITYMATERIALOPACITYTRIGGERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(RADIOSITYMATERIALINSTANCEENTITYDATA_TYPE_INFO);
    registry.register_type(RADIOSITYMATERIALINSTANCEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(RADIOSITYMATERIALENTITYDATA_TYPE_INFO);
    registry.register_type(RADIOSITYMATERIALENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(GROUNDHEIGHTENTITYDATA_TYPE_INFO);
    registry.register_type(GROUNDHEIGHTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(RENDERVOLUMEENTITYDATA_TYPE_INFO);
    registry.register_type(RENDERVOLUMEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(MESHPROXYENTITYDATA_TYPE_INFO);
    registry.register_type(MESHPROXYENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PARTICIPATINGMEDIAMATERIALENTITYDATA_TYPE_INFO);
    registry.register_type(PARTICIPATINGMEDIAMATERIALENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOCALFOGVOLUMEENTITYDATA_TYPE_INFO);
    registry.register_type(LOCALFOGVOLUMEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOCALVOLUMETRICENTITYDATA_TYPE_INFO);
    registry.register_type(LOCALVOLUMETRICENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(REFLECTIONVOLUMESYNCHRONIZERENTITYDATA_TYPE_INFO);
    registry.register_type(REFLECTIONVOLUMESYNCHRONIZERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOCALPLANARREFLECTIONENTITYDATA_TYPE_INFO);
    registry.register_type(LOCALPLANARREFLECTIONENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PBRDISTANTREFLECTIONVOLUMEENTITYDATA_TYPE_INFO);
    registry.register_type(PBRDISTANTREFLECTIONVOLUMEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PBRBOXREFLECTIONVOLUMEENTITYDATA_TYPE_INFO);
    registry.register_type(PBRBOXREFLECTIONVOLUMEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PBRGENERICBOXREFLECTIONVOLUMEENTITYDATA_TYPE_INFO);
    registry.register_type(PBRGENERICBOXREFLECTIONVOLUMEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PBRSPHEREREFLECTIONVOLUMEENTITYDATA_TYPE_INFO);
    registry.register_type(PBRSPHEREREFLECTIONVOLUMEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PBRREFLECTIONVOLUMEENTITYDATA_TYPE_INFO);
    registry.register_type(PBRREFLECTIONVOLUMEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PBRRECTANGULARLIGHTENTITYDATA_TYPE_INFO);
    registry.register_type(PBRRECTANGULARLIGHTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PBRTUBELIGHTENTITYDATA_TYPE_INFO);
    registry.register_type(PBRTUBELIGHTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PBRSPOTLIGHTENTITYDATA_TYPE_INFO);
    registry.register_type(PBRSPOTLIGHTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PBRSPHERELIGHTENTITYDATA_TYPE_INFO);
    registry.register_type(PBRSPHERELIGHTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PBRANALYTICLIGHTENTITYDATA_TYPE_INFO);
    registry.register_type(PBRANALYTICLIGHTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SPOTLIGHTENTITYDATA_TYPE_INFO);
    registry.register_type(SPOTLIGHTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(POINTLIGHTENTITYDATA_TYPE_INFO);
    registry.register_type(POINTLIGHTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOCALLIGHTENTITYDATA_TYPE_INFO);
    registry.register_type(LOCALLIGHTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(LENSFLAREREFERENCEOBJECTDATA_TYPE_INFO);
    registry.register_type(LENSFLAREREFERENCEOBJECTDATA_ARRAY_TYPE_INFO);
    registry.register_type(LENSFLAREBLUEPRINT_TYPE_INFO);
    registry.register_type(LENSFLAREBLUEPRINT_ARRAY_TYPE_INFO);
    registry.register_type(LENSFLAREENTITYDATA_TYPE_INFO);
    registry.register_type(LENSFLAREENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(FOGEXCLUSIONVOLUMEENTITYDATA_TYPE_INFO);
    registry.register_type(FOGEXCLUSIONVOLUMEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(DISTANTSHADOWCACHEVOLUMEENTITYDATA_TYPE_INFO);
    registry.register_type(DISTANTSHADOWCACHEVOLUMEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SIMPLEVOLUMETRICSENTITY_TYPE_INFO);
    registry.register_type(SIMPLEVOLUMETRICSENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SCREENSHOTCAPTUREENTITY_TYPE_INFO);
    registry.register_type(SCREENSHOTCAPTUREENTITY_ARRAY_TYPE_INFO);
    registry.register_type(RENDERVOLUMEENTITY_TYPE_INFO);
    registry.register_type(RENDERVOLUMEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(RADIOSITYMODIFIERENTITY_TYPE_INFO);
    registry.register_type(RADIOSITYMODIFIERENTITY_ARRAY_TYPE_INFO);
    registry.register_type(RADIOSITYMATERIALOPACITYTRIGGERENTITY_TYPE_INFO);
    registry.register_type(RADIOSITYMATERIALOPACITYTRIGGERENTITY_ARRAY_TYPE_INFO);
    registry.register_type(RADIOSITYMATERIALINSTANCEENTITY_TYPE_INFO);
    registry.register_type(RADIOSITYMATERIALINSTANCEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(RADIOSITYMATERIALENTITY_TYPE_INFO);
    registry.register_type(RADIOSITYMATERIALENTITY_ARRAY_TYPE_INFO);
    registry.register_type(PLANARREFLECTIONLOCATORENTITY_TYPE_INFO);
    registry.register_type(PLANARREFLECTIONLOCATORENTITY_ARRAY_TYPE_INFO);
    registry.register_type(OCCLUDERVOLUMEENTITY_TYPE_INFO);
    registry.register_type(OCCLUDERVOLUMEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(OCCLUDERPLANEENTITY_TYPE_INFO);
    registry.register_type(OCCLUDERPLANEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(OCCLUDERMESHENTITY_TYPE_INFO);
    registry.register_type(OCCLUDERMESHENTITY_ARRAY_TYPE_INFO);
    registry.register_type(MESHPROXYENTITY_TYPE_INFO);
    registry.register_type(MESHPROXYENTITY_ARRAY_TYPE_INFO);
    registry.register_type(PARTICIPATINGMEDIAMATERIALENTITY_TYPE_INFO);
    registry.register_type(PARTICIPATINGMEDIAMATERIALENTITY_ARRAY_TYPE_INFO);
    registry.register_type(LOCALFOGVOLUMEENTITY_TYPE_INFO);
    registry.register_type(LOCALFOGVOLUMEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(LOCALPLANARREFLECTIONENTITY_TYPE_INFO);
    registry.register_type(LOCALPLANARREFLECTIONENTITY_ARRAY_TYPE_INFO);
    registry.register_type(REFLECTIONVOLUMESYNCHRONIZERENTITY_TYPE_INFO);
    registry.register_type(REFLECTIONVOLUMESYNCHRONIZERENTITY_ARRAY_TYPE_INFO);
    registry.register_type(DISTANTIBLENTITY_TYPE_INFO);
    registry.register_type(DISTANTIBLENTITY_ARRAY_TYPE_INFO);
    registry.register_type(LOCALBOXIBLENTITY_TYPE_INFO);
    registry.register_type(LOCALBOXIBLENTITY_ARRAY_TYPE_INFO);
    registry.register_type(LOCALSPHEREIBLENTITY_TYPE_INFO);
    registry.register_type(LOCALSPHEREIBLENTITY_ARRAY_TYPE_INFO);
    registry.register_type(PBRRECTANGULARLIGHTENTITY_TYPE_INFO);
    registry.register_type(PBRRECTANGULARLIGHTENTITY_ARRAY_TYPE_INFO);
    registry.register_type(PBRTUBELIGHTENTITY_TYPE_INFO);
    registry.register_type(PBRTUBELIGHTENTITY_ARRAY_TYPE_INFO);
    registry.register_type(PBRSPOTLIGHTENTITY_TYPE_INFO);
    registry.register_type(PBRSPOTLIGHTENTITY_ARRAY_TYPE_INFO);
    registry.register_type(PBRSPHERELIGHTENTITY_TYPE_INFO);
    registry.register_type(PBRSPHERELIGHTENTITY_ARRAY_TYPE_INFO);
    registry.register_type(OLDSPOTLIGHTENTITY_TYPE_INFO);
    registry.register_type(OLDSPOTLIGHTENTITY_ARRAY_TYPE_INFO);
    registry.register_type(OLDPOINTLIGHTENTITY_TYPE_INFO);
    registry.register_type(OLDPOINTLIGHTENTITY_ARRAY_TYPE_INFO);
    registry.register_type(LOCALLIGHTENTITY_TYPE_INFO);
    registry.register_type(LOCALLIGHTENTITY_ARRAY_TYPE_INFO);
    registry.register_type(LENSFLAREENTITY_TYPE_INFO);
    registry.register_type(LENSFLAREENTITY_ARRAY_TYPE_INFO);
    registry.register_type(GROUNDHEIGHTENTITY_TYPE_INFO);
    registry.register_type(GROUNDHEIGHTENTITY_ARRAY_TYPE_INFO);
    registry.register_type(FOGEXCLUSIONVOLUMEENTITY_TYPE_INFO);
    registry.register_type(FOGEXCLUSIONVOLUMEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(DYNAMICENLIGHTENENTITY_TYPE_INFO);
    registry.register_type(DYNAMICENLIGHTENENTITY_ARRAY_TYPE_INFO);
    registry.register_type(DISTANTSHADOWCACHEVOLUMEENTITY_TYPE_INFO);
    registry.register_type(DISTANTSHADOWCACHEVOLUMEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(BAKEABLETEXTUREENTITYDATA_TYPE_INFO);
    registry.register_type(BAKEABLETEXTUREENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(WINDFORCESPHEREENTITY_TYPE_INFO);
    registry.register_type(WINDFORCESPHEREENTITY_ARRAY_TYPE_INFO);
    registry.register_type(WINDFORCESPHERECOMPONENT_TYPE_INFO);
    registry.register_type(WINDFORCESPHERECOMPONENT_ARRAY_TYPE_INFO);
    registry.register_type(WINDFORCESAMPLERENTITY_TYPE_INFO);
    registry.register_type(WINDFORCESAMPLERENTITY_ARRAY_TYPE_INFO);
    registry.register_type(WINDFORCEENTITY_TYPE_INFO);
    registry.register_type(WINDFORCEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(WINDFORCECONEENTITY_TYPE_INFO);
    registry.register_type(WINDFORCECONEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(WINDFORCECONECOMPONENT_TYPE_INFO);
    registry.register_type(WINDFORCECONECOMPONENT_ARRAY_TYPE_INFO);
    registry.register_type(WINDFORCECOMPONENT_TYPE_INFO);
    registry.register_type(WINDFORCECOMPONENT_ARRAY_TYPE_INFO);
    registry.register_type(WINDFORCEBAKED3DAS2X2DTEXENTITY_TYPE_INFO);
    registry.register_type(WINDFORCEBAKED3DAS2X2DTEXENTITY_ARRAY_TYPE_INFO);
    registry.register_type(WINDFORCEBAKED3DAS2X2DTEXCOMPONENT_TYPE_INFO);
    registry.register_type(WINDFORCEBAKED3DAS2X2DTEXCOMPONENT_ARRAY_TYPE_INFO);
    registry.register_type(VISUALENVIRONMENTENTITY_TYPE_INFO);
    registry.register_type(VISUALENVIRONMENTENTITY_ARRAY_TYPE_INFO);
    registry.register_type(RAYTRACEREFLECTIONCOMPONENT_TYPE_INFO);
    registry.register_type(RAYTRACEREFLECTIONCOMPONENT_ARRAY_TYPE_INFO);
    registry.register_type(SONARPARAMSCOMPONENT_TYPE_INFO);
    registry.register_type(SONARPARAMSCOMPONENT_ARRAY_TYPE_INFO);
    registry.register_type(HOLOGRAMPARAMSCOMPONENT_TYPE_INFO);
    registry.register_type(HOLOGRAMPARAMSCOMPONENT_ARRAY_TYPE_INFO);
    registry.register_type(THREATALERTHIGHLIGHTPARAMSCOMPONENT_TYPE_INFO);
    registry.register_type(THREATALERTHIGHLIGHTPARAMSCOMPONENT_ARRAY_TYPE_INFO);
    registry.register_type(OBJECTHIGHLIGHTPARAMSCOMPONENT_TYPE_INFO);
    registry.register_type(OBJECTHIGHLIGHTPARAMSCOMPONENT_ARRAY_TYPE_INFO);
    registry.register_type(ANTIALIASCOMPONENT_TYPE_INFO);
    registry.register_type(ANTIALIASCOMPONENT_ARRAY_TYPE_INFO);
    registry.register_type(SCREENSPACERAYTRACECOMPONENT_TYPE_INFO);
    registry.register_type(SCREENSPACERAYTRACECOMPONENT_ARRAY_TYPE_INFO);
    registry.register_type(DEBUGCOMPONENT_TYPE_INFO);
    registry.register_type(DEBUGCOMPONENT_ARRAY_TYPE_INFO);
    registry.register_type(LENSREFLECTIONCOMPONENT_TYPE_INFO);
    registry.register_type(LENSREFLECTIONCOMPONENT_ARRAY_TYPE_INFO);
    registry.register_type(SKYCELESTIALROTATIONCOMPONENT_TYPE_INFO);
    registry.register_type(SKYCELESTIALROTATIONCOMPONENT_ARRAY_TYPE_INFO);
    registry.register_type(SKYCELESTIALMULTICOMPONENT_TYPE_INFO);
    registry.register_type(SKYCELESTIALMULTICOMPONENT_ARRAY_TYPE_INFO);
    registry.register_type(SKYCELESTIALSINGLECOMPONENT_TYPE_INFO);
    registry.register_type(SKYCELESTIALSINGLECOMPONENT_ARRAY_TYPE_INFO);
    registry.register_type(EMITTERPARAMGLOBALCOMPONENT_TYPE_INFO);
    registry.register_type(EMITTERPARAMGLOBALCOMPONENT_ARRAY_TYPE_INFO);
    registry.register_type(EMITTERPARAMCOMPONENT_TYPE_INFO);
    registry.register_type(EMITTERPARAMCOMPONENT_ARRAY_TYPE_INFO);
    registry.register_type(SHADERPARAMSCOMPONENT_TYPE_INFO);
    registry.register_type(SHADERPARAMSCOMPONENT_ARRAY_TYPE_INFO);
    registry.register_type(MOTIONBLURCOMPONENT_TYPE_INFO);
    registry.register_type(MOTIONBLURCOMPONENT_ARRAY_TYPE_INFO);
    registry.register_type(SUBSURFACESCATTERINGCOMPONENT_TYPE_INFO);
    registry.register_type(SUBSURFACESCATTERINGCOMPONENT_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERLIGHTINGCOMPONENT_TYPE_INFO);
    registry.register_type(CHARACTERLIGHTINGCOMPONENT_ARRAY_TYPE_INFO);
    registry.register_type(DYNAMICENVMAPCOMPONENT_TYPE_INFO);
    registry.register_type(DYNAMICENVMAPCOMPONENT_ARRAY_TYPE_INFO);
    registry.register_type(PLANARREFLECTIONCOMPONENT_TYPE_INFO);
    registry.register_type(PLANARREFLECTIONCOMPONENT_ARRAY_TYPE_INFO);
    registry.register_type(DAMAGEEFFECTCOMPONENT_TYPE_INFO);
    registry.register_type(DAMAGEEFFECTCOMPONENT_ARRAY_TYPE_INFO);
    registry.register_type(SCREENEFFECTCOMPONENT_TYPE_INFO);
    registry.register_type(SCREENEFFECTCOMPONENT_ARRAY_TYPE_INFO);
    registry.register_type(SHADOWSCOMPONENT_TYPE_INFO);
    registry.register_type(SHADOWSCOMPONENT_ARRAY_TYPE_INFO);
    registry.register_type(MESHSETTINGSCOMPONENT_TYPE_INFO);
    registry.register_type(MESHSETTINGSCOMPONENT_ARRAY_TYPE_INFO);
    registry.register_type(CAMERAPARAMSCOMPONENT_TYPE_INFO);
    registry.register_type(CAMERAPARAMSCOMPONENT_ARRAY_TYPE_INFO);
    registry.register_type(LENSSCOPECOMPONENT_TYPE_INFO);
    registry.register_type(LENSSCOPECOMPONENT_ARRAY_TYPE_INFO);
    registry.register_type(FILMGRAINCOMPONENT_TYPE_INFO);
    registry.register_type(FILMGRAINCOMPONENT_ARRAY_TYPE_INFO);
    registry.register_type(VIGNETTECOMPONENT_TYPE_INFO);
    registry.register_type(VIGNETTECOMPONENT_ARRAY_TYPE_INFO);
    registry.register_type(DOFCOMPONENT_TYPE_INFO);
    registry.register_type(DOFCOMPONENT_ARRAY_TYPE_INFO);
    registry.register_type(FILMICEFFECTSCOMPONENT_TYPE_INFO);
    registry.register_type(FILMICEFFECTSCOMPONENT_ARRAY_TYPE_INFO);
    registry.register_type(DYNAMICAOCOMPONENT_TYPE_INFO);
    registry.register_type(DYNAMICAOCOMPONENT_ARRAY_TYPE_INFO);
    registry.register_type(SUNFLARECOMPONENT_TYPE_INFO);
    registry.register_type(SUNFLARECOMPONENT_ARRAY_TYPE_INFO);
    registry.register_type(CLOUDCOMPONENT_TYPE_INFO);
    registry.register_type(CLOUDCOMPONENT_ARRAY_TYPE_INFO);
    registry.register_type(WINDCOMPONENT_TYPE_INFO);
    registry.register_type(WINDCOMPONENT_ARRAY_TYPE_INFO);
    registry.register_type(FOGCOMPONENT_TYPE_INFO);
    registry.register_type(FOGCOMPONENT_ARRAY_TYPE_INFO);
    registry.register_type(COLORCORRECTIONCOMPONENT_TYPE_INFO);
    registry.register_type(COLORCORRECTIONCOMPONENT_ARRAY_TYPE_INFO);
    registry.register_type(TONEMAPCOMPONENT_TYPE_INFO);
    registry.register_type(TONEMAPCOMPONENT_ARRAY_TYPE_INFO);
    registry.register_type(ENLIGHTENCOMPONENT_TYPE_INFO);
    registry.register_type(ENLIGHTENCOMPONENT_ARRAY_TYPE_INFO);
    registry.register_type(OUTDOORLIGHTCOMPONENT_TYPE_INFO);
    registry.register_type(OUTDOORLIGHTCOMPONENT_ARRAY_TYPE_INFO);
    registry.register_type(INDIRECTSPECULARCOMPONENT_TYPE_INFO);
    registry.register_type(INDIRECTSPECULARCOMPONENT_ARRAY_TYPE_INFO);
    registry.register_type(SKYCOMPONENT_TYPE_INFO);
    registry.register_type(SKYCOMPONENT_ARRAY_TYPE_INFO);
    registry.register_type(RENDERFRAMESTRACK_TYPE_INFO);
    registry.register_type(RENDERFRAMESTRACK_ARRAY_TYPE_INFO);
    registry.register_type(SERVERVISIBLEAREAENTITY_TYPE_INFO);
    registry.register_type(SERVERVISIBLEAREAENTITY_ARRAY_TYPE_INFO);
    registry.register_type(CLIENTVISIBLEAREAENTITY_TYPE_INFO);
    registry.register_type(CLIENTVISIBLEAREAENTITY_ARRAY_TYPE_INFO);
    registry.register_type(STATICENLIGHTENENTITY_TYPE_INFO);
    registry.register_type(STATICENLIGHTENENTITY_ARRAY_TYPE_INFO);
}

#[derive(Clone, Debug, Default)]
pub struct ForceManagerSettings {
    pub _glacier_base: super::core::DataContainer,
    pub vector_field_norm_value: f32,
    pub vector_field_cell_size: f32,
    pub vector_field_planar_height_position: f32,
    pub wind_enable: bool,
    pub forces_enable: bool,
    pub draw_stats: bool,
    pub draw_wind_graph: bool,
    pub draw_bounding_volumes: bool,
    pub draw_selection_bounding_volumes: bool,
    pub draw_selection_vector_field: bool,
    pub draw_selection_force_vector_field: bool,
    pub draw_planar_vector_field: bool,
    pub draw_external_vector_field: bool,
    pub vector_field_enable_wind: bool,
    pub vector_field_enable_sphere: bool,
    pub vector_field_enable_cone: bool,
    pub vector_field_enable_baked: bool,
    pub vector_field_camera_centered: bool,
    pub vector_field_size_x: f32,
    pub vector_field_size_y: f32,
    pub vector_field_size_z: f32,
    pub vector_field_center_x: f32,
    pub vector_field_center_y: f32,
    pub vector_field_center_z: f32,
    pub vector_field_point_size: f32,
    pub vector_field_arrow: bool,
    pub vector_field_lock_selection: bool,
}

pub trait ForceManagerSettingsTrait: super::core::DataContainerTrait {
    fn vector_field_norm_value(&self) -> &f32;
    fn vector_field_norm_value_mut(&mut self) -> &mut f32;
    fn vector_field_cell_size(&self) -> &f32;
    fn vector_field_cell_size_mut(&mut self) -> &mut f32;
    fn vector_field_planar_height_position(&self) -> &f32;
    fn vector_field_planar_height_position_mut(&mut self) -> &mut f32;
    fn wind_enable(&self) -> &bool;
    fn wind_enable_mut(&mut self) -> &mut bool;
    fn forces_enable(&self) -> &bool;
    fn forces_enable_mut(&mut self) -> &mut bool;
    fn draw_stats(&self) -> &bool;
    fn draw_stats_mut(&mut self) -> &mut bool;
    fn draw_wind_graph(&self) -> &bool;
    fn draw_wind_graph_mut(&mut self) -> &mut bool;
    fn draw_bounding_volumes(&self) -> &bool;
    fn draw_bounding_volumes_mut(&mut self) -> &mut bool;
    fn draw_selection_bounding_volumes(&self) -> &bool;
    fn draw_selection_bounding_volumes_mut(&mut self) -> &mut bool;
    fn draw_selection_vector_field(&self) -> &bool;
    fn draw_selection_vector_field_mut(&mut self) -> &mut bool;
    fn draw_selection_force_vector_field(&self) -> &bool;
    fn draw_selection_force_vector_field_mut(&mut self) -> &mut bool;
    fn draw_planar_vector_field(&self) -> &bool;
    fn draw_planar_vector_field_mut(&mut self) -> &mut bool;
    fn draw_external_vector_field(&self) -> &bool;
    fn draw_external_vector_field_mut(&mut self) -> &mut bool;
    fn vector_field_enable_wind(&self) -> &bool;
    fn vector_field_enable_wind_mut(&mut self) -> &mut bool;
    fn vector_field_enable_sphere(&self) -> &bool;
    fn vector_field_enable_sphere_mut(&mut self) -> &mut bool;
    fn vector_field_enable_cone(&self) -> &bool;
    fn vector_field_enable_cone_mut(&mut self) -> &mut bool;
    fn vector_field_enable_baked(&self) -> &bool;
    fn vector_field_enable_baked_mut(&mut self) -> &mut bool;
    fn vector_field_camera_centered(&self) -> &bool;
    fn vector_field_camera_centered_mut(&mut self) -> &mut bool;
    fn vector_field_size_x(&self) -> &f32;
    fn vector_field_size_x_mut(&mut self) -> &mut f32;
    fn vector_field_size_y(&self) -> &f32;
    fn vector_field_size_y_mut(&mut self) -> &mut f32;
    fn vector_field_size_z(&self) -> &f32;
    fn vector_field_size_z_mut(&mut self) -> &mut f32;
    fn vector_field_center_x(&self) -> &f32;
    fn vector_field_center_x_mut(&mut self) -> &mut f32;
    fn vector_field_center_y(&self) -> &f32;
    fn vector_field_center_y_mut(&mut self) -> &mut f32;
    fn vector_field_center_z(&self) -> &f32;
    fn vector_field_center_z_mut(&mut self) -> &mut f32;
    fn vector_field_point_size(&self) -> &f32;
    fn vector_field_point_size_mut(&mut self) -> &mut f32;
    fn vector_field_arrow(&self) -> &bool;
    fn vector_field_arrow_mut(&mut self) -> &mut bool;
    fn vector_field_lock_selection(&self) -> &bool;
    fn vector_field_lock_selection_mut(&mut self) -> &mut bool;
}

impl ForceManagerSettingsTrait for ForceManagerSettings {
    fn vector_field_norm_value(&self) -> &f32 {
        &self.vector_field_norm_value
    }
    fn vector_field_norm_value_mut(&mut self) -> &mut f32 {
        &mut self.vector_field_norm_value
    }
    fn vector_field_cell_size(&self) -> &f32 {
        &self.vector_field_cell_size
    }
    fn vector_field_cell_size_mut(&mut self) -> &mut f32 {
        &mut self.vector_field_cell_size
    }
    fn vector_field_planar_height_position(&self) -> &f32 {
        &self.vector_field_planar_height_position
    }
    fn vector_field_planar_height_position_mut(&mut self) -> &mut f32 {
        &mut self.vector_field_planar_height_position
    }
    fn wind_enable(&self) -> &bool {
        &self.wind_enable
    }
    fn wind_enable_mut(&mut self) -> &mut bool {
        &mut self.wind_enable
    }
    fn forces_enable(&self) -> &bool {
        &self.forces_enable
    }
    fn forces_enable_mut(&mut self) -> &mut bool {
        &mut self.forces_enable
    }
    fn draw_stats(&self) -> &bool {
        &self.draw_stats
    }
    fn draw_stats_mut(&mut self) -> &mut bool {
        &mut self.draw_stats
    }
    fn draw_wind_graph(&self) -> &bool {
        &self.draw_wind_graph
    }
    fn draw_wind_graph_mut(&mut self) -> &mut bool {
        &mut self.draw_wind_graph
    }
    fn draw_bounding_volumes(&self) -> &bool {
        &self.draw_bounding_volumes
    }
    fn draw_bounding_volumes_mut(&mut self) -> &mut bool {
        &mut self.draw_bounding_volumes
    }
    fn draw_selection_bounding_volumes(&self) -> &bool {
        &self.draw_selection_bounding_volumes
    }
    fn draw_selection_bounding_volumes_mut(&mut self) -> &mut bool {
        &mut self.draw_selection_bounding_volumes
    }
    fn draw_selection_vector_field(&self) -> &bool {
        &self.draw_selection_vector_field
    }
    fn draw_selection_vector_field_mut(&mut self) -> &mut bool {
        &mut self.draw_selection_vector_field
    }
    fn draw_selection_force_vector_field(&self) -> &bool {
        &self.draw_selection_force_vector_field
    }
    fn draw_selection_force_vector_field_mut(&mut self) -> &mut bool {
        &mut self.draw_selection_force_vector_field
    }
    fn draw_planar_vector_field(&self) -> &bool {
        &self.draw_planar_vector_field
    }
    fn draw_planar_vector_field_mut(&mut self) -> &mut bool {
        &mut self.draw_planar_vector_field
    }
    fn draw_external_vector_field(&self) -> &bool {
        &self.draw_external_vector_field
    }
    fn draw_external_vector_field_mut(&mut self) -> &mut bool {
        &mut self.draw_external_vector_field
    }
    fn vector_field_enable_wind(&self) -> &bool {
        &self.vector_field_enable_wind
    }
    fn vector_field_enable_wind_mut(&mut self) -> &mut bool {
        &mut self.vector_field_enable_wind
    }
    fn vector_field_enable_sphere(&self) -> &bool {
        &self.vector_field_enable_sphere
    }
    fn vector_field_enable_sphere_mut(&mut self) -> &mut bool {
        &mut self.vector_field_enable_sphere
    }
    fn vector_field_enable_cone(&self) -> &bool {
        &self.vector_field_enable_cone
    }
    fn vector_field_enable_cone_mut(&mut self) -> &mut bool {
        &mut self.vector_field_enable_cone
    }
    fn vector_field_enable_baked(&self) -> &bool {
        &self.vector_field_enable_baked
    }
    fn vector_field_enable_baked_mut(&mut self) -> &mut bool {
        &mut self.vector_field_enable_baked
    }
    fn vector_field_camera_centered(&self) -> &bool {
        &self.vector_field_camera_centered
    }
    fn vector_field_camera_centered_mut(&mut self) -> &mut bool {
        &mut self.vector_field_camera_centered
    }
    fn vector_field_size_x(&self) -> &f32 {
        &self.vector_field_size_x
    }
    fn vector_field_size_x_mut(&mut self) -> &mut f32 {
        &mut self.vector_field_size_x
    }
    fn vector_field_size_y(&self) -> &f32 {
        &self.vector_field_size_y
    }
    fn vector_field_size_y_mut(&mut self) -> &mut f32 {
        &mut self.vector_field_size_y
    }
    fn vector_field_size_z(&self) -> &f32 {
        &self.vector_field_size_z
    }
    fn vector_field_size_z_mut(&mut self) -> &mut f32 {
        &mut self.vector_field_size_z
    }
    fn vector_field_center_x(&self) -> &f32 {
        &self.vector_field_center_x
    }
    fn vector_field_center_x_mut(&mut self) -> &mut f32 {
        &mut self.vector_field_center_x
    }
    fn vector_field_center_y(&self) -> &f32 {
        &self.vector_field_center_y
    }
    fn vector_field_center_y_mut(&mut self) -> &mut f32 {
        &mut self.vector_field_center_y
    }
    fn vector_field_center_z(&self) -> &f32 {
        &self.vector_field_center_z
    }
    fn vector_field_center_z_mut(&mut self) -> &mut f32 {
        &mut self.vector_field_center_z
    }
    fn vector_field_point_size(&self) -> &f32 {
        &self.vector_field_point_size
    }
    fn vector_field_point_size_mut(&mut self) -> &mut f32 {
        &mut self.vector_field_point_size
    }
    fn vector_field_arrow(&self) -> &bool {
        &self.vector_field_arrow
    }
    fn vector_field_arrow_mut(&mut self) -> &mut bool {
        &mut self.vector_field_arrow
    }
    fn vector_field_lock_selection(&self) -> &bool {
        &self.vector_field_lock_selection
    }
    fn vector_field_lock_selection_mut(&mut self) -> &mut bool {
        &mut self.vector_field_lock_selection
    }
}

impl super::core::DataContainerTrait for ForceManagerSettings {
}

pub static FORCEMANAGERSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ForceManagerSettings",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ForceManagerSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "VectorFieldNormValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ForceManagerSettings, vector_field_norm_value),
            },
            FieldInfoData {
                name: "VectorFieldCellSize",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ForceManagerSettings, vector_field_cell_size),
            },
            FieldInfoData {
                name: "VectorFieldPlanarHeightPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ForceManagerSettings, vector_field_planar_height_position),
            },
            FieldInfoData {
                name: "WindEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ForceManagerSettings, wind_enable),
            },
            FieldInfoData {
                name: "ForcesEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ForceManagerSettings, forces_enable),
            },
            FieldInfoData {
                name: "DrawStats",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ForceManagerSettings, draw_stats),
            },
            FieldInfoData {
                name: "DrawWindGraph",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ForceManagerSettings, draw_wind_graph),
            },
            FieldInfoData {
                name: "DrawBoundingVolumes",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ForceManagerSettings, draw_bounding_volumes),
            },
            FieldInfoData {
                name: "DrawSelectionBoundingVolumes",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ForceManagerSettings, draw_selection_bounding_volumes),
            },
            FieldInfoData {
                name: "DrawSelectionVectorField",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ForceManagerSettings, draw_selection_vector_field),
            },
            FieldInfoData {
                name: "DrawSelectionForceVectorField",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ForceManagerSettings, draw_selection_force_vector_field),
            },
            FieldInfoData {
                name: "DrawPlanarVectorField",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ForceManagerSettings, draw_planar_vector_field),
            },
            FieldInfoData {
                name: "DrawExternalVectorField",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ForceManagerSettings, draw_external_vector_field),
            },
            FieldInfoData {
                name: "VectorFieldEnableWind",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ForceManagerSettings, vector_field_enable_wind),
            },
            FieldInfoData {
                name: "VectorFieldEnableSphere",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ForceManagerSettings, vector_field_enable_sphere),
            },
            FieldInfoData {
                name: "VectorFieldEnableCone",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ForceManagerSettings, vector_field_enable_cone),
            },
            FieldInfoData {
                name: "VectorFieldEnableBaked",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ForceManagerSettings, vector_field_enable_baked),
            },
            FieldInfoData {
                name: "VectorFieldCameraCentered",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ForceManagerSettings, vector_field_camera_centered),
            },
            FieldInfoData {
                name: "VectorFieldSizeX",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ForceManagerSettings, vector_field_size_x),
            },
            FieldInfoData {
                name: "VectorFieldSizeY",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ForceManagerSettings, vector_field_size_y),
            },
            FieldInfoData {
                name: "VectorFieldSizeZ",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ForceManagerSettings, vector_field_size_z),
            },
            FieldInfoData {
                name: "VectorFieldCenterX",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ForceManagerSettings, vector_field_center_x),
            },
            FieldInfoData {
                name: "VectorFieldCenterY",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ForceManagerSettings, vector_field_center_y),
            },
            FieldInfoData {
                name: "VectorFieldCenterZ",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ForceManagerSettings, vector_field_center_z),
            },
            FieldInfoData {
                name: "VectorFieldPointSize",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ForceManagerSettings, vector_field_point_size),
            },
            FieldInfoData {
                name: "VectorFieldArrow",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ForceManagerSettings, vector_field_arrow),
            },
            FieldInfoData {
                name: "VectorFieldLockSelection",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ForceManagerSettings, vector_field_lock_selection),
            },
        ],
    }),
    array_type: Some(FORCEMANAGERSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ForceManagerSettings {
    fn type_info(&self) -> &'static TypeInfo {
        FORCEMANAGERSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FORCEMANAGERSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ForceManagerSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("ForceManagerSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LocalWindForceBaked3DAs2x2DTexEntityData {
    pub _glacier_base: LocalWindForceEntityBaseData,
    pub size_x: f32,
    pub size_y: f32,
    pub size_z: f32,
    pub attenuation: f32,
    pub volume_slice_z_x: Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>,
    pub volume_slice_z_x_scale: super::core::Vec3,
    pub volume_slice_z_y: Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>,
    pub volume_slice_z_y_scale: super::core::Vec3,
}

pub trait LocalWindForceBaked3DAs2x2DTexEntityDataTrait: LocalWindForceEntityBaseDataTrait {
    fn size_x(&self) -> &f32;
    fn size_x_mut(&mut self) -> &mut f32;
    fn size_y(&self) -> &f32;
    fn size_y_mut(&mut self) -> &mut f32;
    fn size_z(&self) -> &f32;
    fn size_z_mut(&mut self) -> &mut f32;
    fn attenuation(&self) -> &f32;
    fn attenuation_mut(&mut self) -> &mut f32;
    fn volume_slice_z_x(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn volume_slice_z_x_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn volume_slice_z_x_scale(&self) -> &super::core::Vec3;
    fn volume_slice_z_x_scale_mut(&mut self) -> &mut super::core::Vec3;
    fn volume_slice_z_y(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn volume_slice_z_y_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn volume_slice_z_y_scale(&self) -> &super::core::Vec3;
    fn volume_slice_z_y_scale_mut(&mut self) -> &mut super::core::Vec3;
}

impl LocalWindForceBaked3DAs2x2DTexEntityDataTrait for LocalWindForceBaked3DAs2x2DTexEntityData {
    fn size_x(&self) -> &f32 {
        &self.size_x
    }
    fn size_x_mut(&mut self) -> &mut f32 {
        &mut self.size_x
    }
    fn size_y(&self) -> &f32 {
        &self.size_y
    }
    fn size_y_mut(&mut self) -> &mut f32 {
        &mut self.size_y
    }
    fn size_z(&self) -> &f32 {
        &self.size_z
    }
    fn size_z_mut(&mut self) -> &mut f32 {
        &mut self.size_z
    }
    fn attenuation(&self) -> &f32 {
        &self.attenuation
    }
    fn attenuation_mut(&mut self) -> &mut f32 {
        &mut self.attenuation
    }
    fn volume_slice_z_x(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &self.volume_slice_z_x
    }
    fn volume_slice_z_x_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &mut self.volume_slice_z_x
    }
    fn volume_slice_z_x_scale(&self) -> &super::core::Vec3 {
        &self.volume_slice_z_x_scale
    }
    fn volume_slice_z_x_scale_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.volume_slice_z_x_scale
    }
    fn volume_slice_z_y(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &self.volume_slice_z_y
    }
    fn volume_slice_z_y_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &mut self.volume_slice_z_y
    }
    fn volume_slice_z_y_scale(&self) -> &super::core::Vec3 {
        &self.volume_slice_z_y_scale
    }
    fn volume_slice_z_y_scale_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.volume_slice_z_y_scale
    }
}

impl LocalWindForceEntityBaseDataTrait for LocalWindForceBaked3DAs2x2DTexEntityData {
    fn force_group(&self) -> &Option<Arc<Mutex<dyn ForceGroupAssetTrait>>> {
        self._glacier_base.force_group()
    }
    fn force_group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ForceGroupAssetTrait>>> {
        self._glacier_base.force_group_mut()
    }
    fn strength(&self) -> &f32 {
        self._glacier_base.strength()
    }
    fn strength_mut(&mut self) -> &mut f32 {
        self._glacier_base.strength_mut()
    }
    fn variation(&self) -> &f32 {
        self._glacier_base.variation()
    }
    fn variation_mut(&mut self) -> &mut f32 {
        self._glacier_base.variation_mut()
    }
    fn variation_rate(&self) -> &f32 {
        self._glacier_base.variation_rate()
    }
    fn variation_rate_mut(&mut self) -> &mut f32 {
        self._glacier_base.variation_rate_mut()
    }
    fn micro_variation(&self) -> &f32 {
        self._glacier_base.micro_variation()
    }
    fn micro_variation_mut(&mut self) -> &mut f32 {
        self._glacier_base.micro_variation_mut()
    }
    fn hardness(&self) -> &f32 {
        self._glacier_base.hardness()
    }
    fn hardness_mut(&mut self) -> &mut f32 {
        self._glacier_base.hardness_mut()
    }
    fn force_as_instant_velocity(&self) -> &f32 {
        self._glacier_base.force_as_instant_velocity()
    }
    fn force_as_instant_velocity_mut(&mut self) -> &mut f32 {
        self._glacier_base.force_as_instant_velocity_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for LocalWindForceBaked3DAs2x2DTexEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for LocalWindForceBaked3DAs2x2DTexEntityData {
}

impl super::entity::GameObjectDataTrait for LocalWindForceBaked3DAs2x2DTexEntityData {
}

impl super::core::DataBusPeerTrait for LocalWindForceBaked3DAs2x2DTexEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for LocalWindForceBaked3DAs2x2DTexEntityData {
}

impl super::core::DataContainerTrait for LocalWindForceBaked3DAs2x2DTexEntityData {
}

pub static LOCALWINDFORCEBAKED3DAS2X2DTEXENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalWindForceBaked3DAs2x2DTexEntityData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(LOCALWINDFORCEENTITYBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LocalWindForceBaked3DAs2x2DTexEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SizeX",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LocalWindForceBaked3DAs2x2DTexEntityData, size_x),
            },
            FieldInfoData {
                name: "SizeY",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LocalWindForceBaked3DAs2x2DTexEntityData, size_y),
            },
            FieldInfoData {
                name: "SizeZ",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LocalWindForceBaked3DAs2x2DTexEntityData, size_z),
            },
            FieldInfoData {
                name: "Attenuation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LocalWindForceBaked3DAs2x2DTexEntityData, attenuation),
            },
            FieldInfoData {
                name: "VolumeSliceZX",
                flags: MemberInfoFlags::new(0),
                field_type: "TextureBaseAsset",
                rust_offset: offset_of!(LocalWindForceBaked3DAs2x2DTexEntityData, volume_slice_z_x),
            },
            FieldInfoData {
                name: "VolumeSliceZXScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(LocalWindForceBaked3DAs2x2DTexEntityData, volume_slice_z_x_scale),
            },
            FieldInfoData {
                name: "VolumeSliceZY",
                flags: MemberInfoFlags::new(0),
                field_type: "TextureBaseAsset",
                rust_offset: offset_of!(LocalWindForceBaked3DAs2x2DTexEntityData, volume_slice_z_y),
            },
            FieldInfoData {
                name: "VolumeSliceZYScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(LocalWindForceBaked3DAs2x2DTexEntityData, volume_slice_z_y_scale),
            },
        ],
    }),
    array_type: Some(LOCALWINDFORCEBAKED3DAS2X2DTEXENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for LocalWindForceBaked3DAs2x2DTexEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        LOCALWINDFORCEBAKED3DAS2X2DTEXENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LOCALWINDFORCEBAKED3DAS2X2DTEXENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalWindForceBaked3DAs2x2DTexEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("LocalWindForceBaked3DAs2x2DTexEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LocalWindForceConeEntityData {
    pub _glacier_base: LocalWindForceEntityBaseData,
    pub inner_radius: f32,
    pub outer_radius: f32,
    pub cone_inner_angle: f32,
    pub cone_outer_angle: f32,
}

pub trait LocalWindForceConeEntityDataTrait: LocalWindForceEntityBaseDataTrait {
    fn inner_radius(&self) -> &f32;
    fn inner_radius_mut(&mut self) -> &mut f32;
    fn outer_radius(&self) -> &f32;
    fn outer_radius_mut(&mut self) -> &mut f32;
    fn cone_inner_angle(&self) -> &f32;
    fn cone_inner_angle_mut(&mut self) -> &mut f32;
    fn cone_outer_angle(&self) -> &f32;
    fn cone_outer_angle_mut(&mut self) -> &mut f32;
}

impl LocalWindForceConeEntityDataTrait for LocalWindForceConeEntityData {
    fn inner_radius(&self) -> &f32 {
        &self.inner_radius
    }
    fn inner_radius_mut(&mut self) -> &mut f32 {
        &mut self.inner_radius
    }
    fn outer_radius(&self) -> &f32 {
        &self.outer_radius
    }
    fn outer_radius_mut(&mut self) -> &mut f32 {
        &mut self.outer_radius
    }
    fn cone_inner_angle(&self) -> &f32 {
        &self.cone_inner_angle
    }
    fn cone_inner_angle_mut(&mut self) -> &mut f32 {
        &mut self.cone_inner_angle
    }
    fn cone_outer_angle(&self) -> &f32 {
        &self.cone_outer_angle
    }
    fn cone_outer_angle_mut(&mut self) -> &mut f32 {
        &mut self.cone_outer_angle
    }
}

impl LocalWindForceEntityBaseDataTrait for LocalWindForceConeEntityData {
    fn force_group(&self) -> &Option<Arc<Mutex<dyn ForceGroupAssetTrait>>> {
        self._glacier_base.force_group()
    }
    fn force_group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ForceGroupAssetTrait>>> {
        self._glacier_base.force_group_mut()
    }
    fn strength(&self) -> &f32 {
        self._glacier_base.strength()
    }
    fn strength_mut(&mut self) -> &mut f32 {
        self._glacier_base.strength_mut()
    }
    fn variation(&self) -> &f32 {
        self._glacier_base.variation()
    }
    fn variation_mut(&mut self) -> &mut f32 {
        self._glacier_base.variation_mut()
    }
    fn variation_rate(&self) -> &f32 {
        self._glacier_base.variation_rate()
    }
    fn variation_rate_mut(&mut self) -> &mut f32 {
        self._glacier_base.variation_rate_mut()
    }
    fn micro_variation(&self) -> &f32 {
        self._glacier_base.micro_variation()
    }
    fn micro_variation_mut(&mut self) -> &mut f32 {
        self._glacier_base.micro_variation_mut()
    }
    fn hardness(&self) -> &f32 {
        self._glacier_base.hardness()
    }
    fn hardness_mut(&mut self) -> &mut f32 {
        self._glacier_base.hardness_mut()
    }
    fn force_as_instant_velocity(&self) -> &f32 {
        self._glacier_base.force_as_instant_velocity()
    }
    fn force_as_instant_velocity_mut(&mut self) -> &mut f32 {
        self._glacier_base.force_as_instant_velocity_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for LocalWindForceConeEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for LocalWindForceConeEntityData {
}

impl super::entity::GameObjectDataTrait for LocalWindForceConeEntityData {
}

impl super::core::DataBusPeerTrait for LocalWindForceConeEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for LocalWindForceConeEntityData {
}

impl super::core::DataContainerTrait for LocalWindForceConeEntityData {
}

pub static LOCALWINDFORCECONEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalWindForceConeEntityData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(LOCALWINDFORCEENTITYBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LocalWindForceConeEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "InnerRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LocalWindForceConeEntityData, inner_radius),
            },
            FieldInfoData {
                name: "OuterRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LocalWindForceConeEntityData, outer_radius),
            },
            FieldInfoData {
                name: "ConeInnerAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LocalWindForceConeEntityData, cone_inner_angle),
            },
            FieldInfoData {
                name: "ConeOuterAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LocalWindForceConeEntityData, cone_outer_angle),
            },
        ],
    }),
    array_type: Some(LOCALWINDFORCECONEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for LocalWindForceConeEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        LOCALWINDFORCECONEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LOCALWINDFORCECONEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalWindForceConeEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("LocalWindForceConeEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LocalWindForceSphereEntityData {
    pub _glacier_base: LocalWindForceEntityBaseData,
    pub radius: f32,
}

pub trait LocalWindForceSphereEntityDataTrait: LocalWindForceEntityBaseDataTrait {
    fn radius(&self) -> &f32;
    fn radius_mut(&mut self) -> &mut f32;
}

impl LocalWindForceSphereEntityDataTrait for LocalWindForceSphereEntityData {
    fn radius(&self) -> &f32 {
        &self.radius
    }
    fn radius_mut(&mut self) -> &mut f32 {
        &mut self.radius
    }
}

impl LocalWindForceEntityBaseDataTrait for LocalWindForceSphereEntityData {
    fn force_group(&self) -> &Option<Arc<Mutex<dyn ForceGroupAssetTrait>>> {
        self._glacier_base.force_group()
    }
    fn force_group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ForceGroupAssetTrait>>> {
        self._glacier_base.force_group_mut()
    }
    fn strength(&self) -> &f32 {
        self._glacier_base.strength()
    }
    fn strength_mut(&mut self) -> &mut f32 {
        self._glacier_base.strength_mut()
    }
    fn variation(&self) -> &f32 {
        self._glacier_base.variation()
    }
    fn variation_mut(&mut self) -> &mut f32 {
        self._glacier_base.variation_mut()
    }
    fn variation_rate(&self) -> &f32 {
        self._glacier_base.variation_rate()
    }
    fn variation_rate_mut(&mut self) -> &mut f32 {
        self._glacier_base.variation_rate_mut()
    }
    fn micro_variation(&self) -> &f32 {
        self._glacier_base.micro_variation()
    }
    fn micro_variation_mut(&mut self) -> &mut f32 {
        self._glacier_base.micro_variation_mut()
    }
    fn hardness(&self) -> &f32 {
        self._glacier_base.hardness()
    }
    fn hardness_mut(&mut self) -> &mut f32 {
        self._glacier_base.hardness_mut()
    }
    fn force_as_instant_velocity(&self) -> &f32 {
        self._glacier_base.force_as_instant_velocity()
    }
    fn force_as_instant_velocity_mut(&mut self) -> &mut f32 {
        self._glacier_base.force_as_instant_velocity_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for LocalWindForceSphereEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for LocalWindForceSphereEntityData {
}

impl super::entity::GameObjectDataTrait for LocalWindForceSphereEntityData {
}

impl super::core::DataBusPeerTrait for LocalWindForceSphereEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for LocalWindForceSphereEntityData {
}

impl super::core::DataContainerTrait for LocalWindForceSphereEntityData {
}

pub static LOCALWINDFORCESPHEREENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalWindForceSphereEntityData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(LOCALWINDFORCEENTITYBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LocalWindForceSphereEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Radius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LocalWindForceSphereEntityData, radius),
            },
        ],
    }),
    array_type: Some(LOCALWINDFORCESPHEREENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for LocalWindForceSphereEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        LOCALWINDFORCESPHEREENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LOCALWINDFORCESPHEREENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalWindForceSphereEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("LocalWindForceSphereEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LocalWindForceSamplerEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub radius: f32,
}

pub trait LocalWindForceSamplerEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn radius(&self) -> &f32;
    fn radius_mut(&mut self) -> &mut f32;
}

impl LocalWindForceSamplerEntityDataTrait for LocalWindForceSamplerEntityData {
    fn radius(&self) -> &f32 {
        &self.radius
    }
    fn radius_mut(&mut self) -> &mut f32 {
        &mut self.radius
    }
}

impl super::entity::SpatialEntityDataTrait for LocalWindForceSamplerEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for LocalWindForceSamplerEntityData {
}

impl super::entity::GameObjectDataTrait for LocalWindForceSamplerEntityData {
}

impl super::core::DataBusPeerTrait for LocalWindForceSamplerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for LocalWindForceSamplerEntityData {
}

impl super::core::DataContainerTrait for LocalWindForceSamplerEntityData {
}

pub static LOCALWINDFORCESAMPLERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalWindForceSamplerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LocalWindForceSamplerEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Radius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LocalWindForceSamplerEntityData, radius),
            },
        ],
    }),
    array_type: Some(LOCALWINDFORCESAMPLERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for LocalWindForceSamplerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        LOCALWINDFORCESAMPLERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LOCALWINDFORCESAMPLERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalWindForceSamplerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("LocalWindForceSamplerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LocalWindForceEntityBaseData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub force_group: Option<Arc<Mutex<dyn ForceGroupAssetTrait>>>,
    pub strength: f32,
    pub variation: f32,
    pub variation_rate: f32,
    pub micro_variation: f32,
    pub hardness: f32,
    pub force_as_instant_velocity: f32,
}

pub trait LocalWindForceEntityBaseDataTrait: super::entity::SpatialEntityDataTrait {
    fn force_group(&self) -> &Option<Arc<Mutex<dyn ForceGroupAssetTrait>>>;
    fn force_group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ForceGroupAssetTrait>>>;
    fn strength(&self) -> &f32;
    fn strength_mut(&mut self) -> &mut f32;
    fn variation(&self) -> &f32;
    fn variation_mut(&mut self) -> &mut f32;
    fn variation_rate(&self) -> &f32;
    fn variation_rate_mut(&mut self) -> &mut f32;
    fn micro_variation(&self) -> &f32;
    fn micro_variation_mut(&mut self) -> &mut f32;
    fn hardness(&self) -> &f32;
    fn hardness_mut(&mut self) -> &mut f32;
    fn force_as_instant_velocity(&self) -> &f32;
    fn force_as_instant_velocity_mut(&mut self) -> &mut f32;
}

impl LocalWindForceEntityBaseDataTrait for LocalWindForceEntityBaseData {
    fn force_group(&self) -> &Option<Arc<Mutex<dyn ForceGroupAssetTrait>>> {
        &self.force_group
    }
    fn force_group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ForceGroupAssetTrait>>> {
        &mut self.force_group
    }
    fn strength(&self) -> &f32 {
        &self.strength
    }
    fn strength_mut(&mut self) -> &mut f32 {
        &mut self.strength
    }
    fn variation(&self) -> &f32 {
        &self.variation
    }
    fn variation_mut(&mut self) -> &mut f32 {
        &mut self.variation
    }
    fn variation_rate(&self) -> &f32 {
        &self.variation_rate
    }
    fn variation_rate_mut(&mut self) -> &mut f32 {
        &mut self.variation_rate
    }
    fn micro_variation(&self) -> &f32 {
        &self.micro_variation
    }
    fn micro_variation_mut(&mut self) -> &mut f32 {
        &mut self.micro_variation
    }
    fn hardness(&self) -> &f32 {
        &self.hardness
    }
    fn hardness_mut(&mut self) -> &mut f32 {
        &mut self.hardness
    }
    fn force_as_instant_velocity(&self) -> &f32 {
        &self.force_as_instant_velocity
    }
    fn force_as_instant_velocity_mut(&mut self) -> &mut f32 {
        &mut self.force_as_instant_velocity
    }
}

impl super::entity::SpatialEntityDataTrait for LocalWindForceEntityBaseData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for LocalWindForceEntityBaseData {
}

impl super::entity::GameObjectDataTrait for LocalWindForceEntityBaseData {
}

impl super::core::DataBusPeerTrait for LocalWindForceEntityBaseData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for LocalWindForceEntityBaseData {
}

impl super::core::DataContainerTrait for LocalWindForceEntityBaseData {
}

pub static LOCALWINDFORCEENTITYBASEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalWindForceEntityBaseData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LocalWindForceEntityBaseData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ForceGroup",
                flags: MemberInfoFlags::new(0),
                field_type: "ForceGroupAsset",
                rust_offset: offset_of!(LocalWindForceEntityBaseData, force_group),
            },
            FieldInfoData {
                name: "Strength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LocalWindForceEntityBaseData, strength),
            },
            FieldInfoData {
                name: "Variation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LocalWindForceEntityBaseData, variation),
            },
            FieldInfoData {
                name: "VariationRate",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LocalWindForceEntityBaseData, variation_rate),
            },
            FieldInfoData {
                name: "MicroVariation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LocalWindForceEntityBaseData, micro_variation),
            },
            FieldInfoData {
                name: "Hardness",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LocalWindForceEntityBaseData, hardness),
            },
            FieldInfoData {
                name: "ForceAsInstantVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LocalWindForceEntityBaseData, force_as_instant_velocity),
            },
        ],
    }),
    array_type: Some(LOCALWINDFORCEENTITYBASEDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for LocalWindForceEntityBaseData {
    fn type_info(&self) -> &'static TypeInfo {
        LOCALWINDFORCEENTITYBASEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LOCALWINDFORCEENTITYBASEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalWindForceEntityBaseData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("LocalWindForceEntityBaseData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LocalWindForceDynamicState {
    pub strength: f32,
    pub variation: f32,
    pub variation_rate: f32,
    pub micro_variation: f32,
    pub hardness: f32,
    pub force_as_instant_velocity: f32,
}

pub trait LocalWindForceDynamicStateTrait: TypeObject {
    fn strength(&self) -> &f32;
    fn strength_mut(&mut self) -> &mut f32;
    fn variation(&self) -> &f32;
    fn variation_mut(&mut self) -> &mut f32;
    fn variation_rate(&self) -> &f32;
    fn variation_rate_mut(&mut self) -> &mut f32;
    fn micro_variation(&self) -> &f32;
    fn micro_variation_mut(&mut self) -> &mut f32;
    fn hardness(&self) -> &f32;
    fn hardness_mut(&mut self) -> &mut f32;
    fn force_as_instant_velocity(&self) -> &f32;
    fn force_as_instant_velocity_mut(&mut self) -> &mut f32;
}

impl LocalWindForceDynamicStateTrait for LocalWindForceDynamicState {
    fn strength(&self) -> &f32 {
        &self.strength
    }
    fn strength_mut(&mut self) -> &mut f32 {
        &mut self.strength
    }
    fn variation(&self) -> &f32 {
        &self.variation
    }
    fn variation_mut(&mut self) -> &mut f32 {
        &mut self.variation
    }
    fn variation_rate(&self) -> &f32 {
        &self.variation_rate
    }
    fn variation_rate_mut(&mut self) -> &mut f32 {
        &mut self.variation_rate
    }
    fn micro_variation(&self) -> &f32 {
        &self.micro_variation
    }
    fn micro_variation_mut(&mut self) -> &mut f32 {
        &mut self.micro_variation
    }
    fn hardness(&self) -> &f32 {
        &self.hardness
    }
    fn hardness_mut(&mut self) -> &mut f32 {
        &mut self.hardness
    }
    fn force_as_instant_velocity(&self) -> &f32 {
        &self.force_as_instant_velocity
    }
    fn force_as_instant_velocity_mut(&mut self) -> &mut f32 {
        &mut self.force_as_instant_velocity
    }
}

pub static LOCALWINDFORCEDYNAMICSTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalWindForceDynamicState",
    flags: MemberInfoFlags::new(36937),
    module: "WorldSim",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LocalWindForceDynamicState as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Strength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LocalWindForceDynamicState, strength),
            },
            FieldInfoData {
                name: "Variation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LocalWindForceDynamicState, variation),
            },
            FieldInfoData {
                name: "VariationRate",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LocalWindForceDynamicState, variation_rate),
            },
            FieldInfoData {
                name: "MicroVariation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LocalWindForceDynamicState, micro_variation),
            },
            FieldInfoData {
                name: "Hardness",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LocalWindForceDynamicState, hardness),
            },
            FieldInfoData {
                name: "ForceAsInstantVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LocalWindForceDynamicState, force_as_instant_velocity),
            },
        ],
    }),
    array_type: Some(LOCALWINDFORCEDYNAMICSTATE_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for LocalWindForceDynamicState {
    fn type_info(&self) -> &'static TypeInfo {
        LOCALWINDFORCEDYNAMICSTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static LOCALWINDFORCEDYNAMICSTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalWindForceDynamicState-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("LocalWindForceDynamicState"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LocalWindForceStaticState {
    pub force_group: Option<Arc<Mutex<dyn ForceGroupAssetTrait>>>,
}

pub trait LocalWindForceStaticStateTrait: TypeObject {
    fn force_group(&self) -> &Option<Arc<Mutex<dyn ForceGroupAssetTrait>>>;
    fn force_group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ForceGroupAssetTrait>>>;
}

impl LocalWindForceStaticStateTrait for LocalWindForceStaticState {
    fn force_group(&self) -> &Option<Arc<Mutex<dyn ForceGroupAssetTrait>>> {
        &self.force_group
    }
    fn force_group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ForceGroupAssetTrait>>> {
        &mut self.force_group
    }
}

pub static LOCALWINDFORCESTATICSTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalWindForceStaticState",
    flags: MemberInfoFlags::new(73),
    module: "WorldSim",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LocalWindForceStaticState as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ForceGroup",
                flags: MemberInfoFlags::new(0),
                field_type: "ForceGroupAsset",
                rust_offset: offset_of!(LocalWindForceStaticState, force_group),
            },
        ],
    }),
    array_type: Some(LOCALWINDFORCESTATICSTATE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LocalWindForceStaticState {
    fn type_info(&self) -> &'static TypeInfo {
        LOCALWINDFORCESTATICSTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static LOCALWINDFORCESTATICSTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalWindForceStaticState-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("LocalWindForceStaticState"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ForceGroupAsset {
    pub _glacier_base: super::core::Asset,
    pub mesh_scattering: bool,
    pub vegetation: bool,
    pub effects: bool,
    pub cloth: bool,
    pub physics: bool,
}

pub trait ForceGroupAssetTrait: super::core::AssetTrait {
    fn mesh_scattering(&self) -> &bool;
    fn mesh_scattering_mut(&mut self) -> &mut bool;
    fn vegetation(&self) -> &bool;
    fn vegetation_mut(&mut self) -> &mut bool;
    fn effects(&self) -> &bool;
    fn effects_mut(&mut self) -> &mut bool;
    fn cloth(&self) -> &bool;
    fn cloth_mut(&mut self) -> &mut bool;
    fn physics(&self) -> &bool;
    fn physics_mut(&mut self) -> &mut bool;
}

impl ForceGroupAssetTrait for ForceGroupAsset {
    fn mesh_scattering(&self) -> &bool {
        &self.mesh_scattering
    }
    fn mesh_scattering_mut(&mut self) -> &mut bool {
        &mut self.mesh_scattering
    }
    fn vegetation(&self) -> &bool {
        &self.vegetation
    }
    fn vegetation_mut(&mut self) -> &mut bool {
        &mut self.vegetation
    }
    fn effects(&self) -> &bool {
        &self.effects
    }
    fn effects_mut(&mut self) -> &mut bool {
        &mut self.effects
    }
    fn cloth(&self) -> &bool {
        &self.cloth
    }
    fn cloth_mut(&mut self) -> &mut bool {
        &mut self.cloth
    }
    fn physics(&self) -> &bool {
        &self.physics
    }
    fn physics_mut(&mut self) -> &mut bool {
        &mut self.physics
    }
}

impl super::core::AssetTrait for ForceGroupAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for ForceGroupAsset {
}

pub static FORCEGROUPASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ForceGroupAsset",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ForceGroupAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MeshScattering",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ForceGroupAsset, mesh_scattering),
            },
            FieldInfoData {
                name: "Vegetation",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ForceGroupAsset, vegetation),
            },
            FieldInfoData {
                name: "Effects",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ForceGroupAsset, effects),
            },
            FieldInfoData {
                name: "Cloth",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ForceGroupAsset, cloth),
            },
            FieldInfoData {
                name: "Physics",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ForceGroupAsset, physics),
            },
        ],
    }),
    array_type: Some(FORCEGROUPASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ForceGroupAsset {
    fn type_info(&self) -> &'static TypeInfo {
        FORCEGROUPASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FORCEGROUPASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ForceGroupAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("ForceGroupAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LocalWindForceBaked3DAs2x2DTexComponentData {
    pub _glacier_base: LocalWindForceComponentBaseData,
    pub size_x: f32,
    pub size_y: f32,
    pub size_z: f32,
    pub attenuation: f32,
    pub volume_slice_z_x: Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>,
    pub volume_slice_z_x_scale: super::core::Vec3,
    pub volume_slice_z_y: Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>,
    pub volume_slice_z_y_scale: super::core::Vec3,
}

pub trait LocalWindForceBaked3DAs2x2DTexComponentDataTrait: LocalWindForceComponentBaseDataTrait {
    fn size_x(&self) -> &f32;
    fn size_x_mut(&mut self) -> &mut f32;
    fn size_y(&self) -> &f32;
    fn size_y_mut(&mut self) -> &mut f32;
    fn size_z(&self) -> &f32;
    fn size_z_mut(&mut self) -> &mut f32;
    fn attenuation(&self) -> &f32;
    fn attenuation_mut(&mut self) -> &mut f32;
    fn volume_slice_z_x(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn volume_slice_z_x_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn volume_slice_z_x_scale(&self) -> &super::core::Vec3;
    fn volume_slice_z_x_scale_mut(&mut self) -> &mut super::core::Vec3;
    fn volume_slice_z_y(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn volume_slice_z_y_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn volume_slice_z_y_scale(&self) -> &super::core::Vec3;
    fn volume_slice_z_y_scale_mut(&mut self) -> &mut super::core::Vec3;
}

impl LocalWindForceBaked3DAs2x2DTexComponentDataTrait for LocalWindForceBaked3DAs2x2DTexComponentData {
    fn size_x(&self) -> &f32 {
        &self.size_x
    }
    fn size_x_mut(&mut self) -> &mut f32 {
        &mut self.size_x
    }
    fn size_y(&self) -> &f32 {
        &self.size_y
    }
    fn size_y_mut(&mut self) -> &mut f32 {
        &mut self.size_y
    }
    fn size_z(&self) -> &f32 {
        &self.size_z
    }
    fn size_z_mut(&mut self) -> &mut f32 {
        &mut self.size_z
    }
    fn attenuation(&self) -> &f32 {
        &self.attenuation
    }
    fn attenuation_mut(&mut self) -> &mut f32 {
        &mut self.attenuation
    }
    fn volume_slice_z_x(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &self.volume_slice_z_x
    }
    fn volume_slice_z_x_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &mut self.volume_slice_z_x
    }
    fn volume_slice_z_x_scale(&self) -> &super::core::Vec3 {
        &self.volume_slice_z_x_scale
    }
    fn volume_slice_z_x_scale_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.volume_slice_z_x_scale
    }
    fn volume_slice_z_y(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &self.volume_slice_z_y
    }
    fn volume_slice_z_y_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &mut self.volume_slice_z_y
    }
    fn volume_slice_z_y_scale(&self) -> &super::core::Vec3 {
        &self.volume_slice_z_y_scale
    }
    fn volume_slice_z_y_scale_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.volume_slice_z_y_scale
    }
}

impl LocalWindForceComponentBaseDataTrait for LocalWindForceBaked3DAs2x2DTexComponentData {
    fn force_group(&self) -> &Option<Arc<Mutex<dyn ForceGroupAssetTrait>>> {
        self._glacier_base.force_group()
    }
    fn force_group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ForceGroupAssetTrait>>> {
        self._glacier_base.force_group_mut()
    }
    fn strength(&self) -> &f32 {
        self._glacier_base.strength()
    }
    fn strength_mut(&mut self) -> &mut f32 {
        self._glacier_base.strength_mut()
    }
    fn variation(&self) -> &f32 {
        self._glacier_base.variation()
    }
    fn variation_mut(&mut self) -> &mut f32 {
        self._glacier_base.variation_mut()
    }
    fn variation_rate(&self) -> &f32 {
        self._glacier_base.variation_rate()
    }
    fn variation_rate_mut(&mut self) -> &mut f32 {
        self._glacier_base.variation_rate_mut()
    }
    fn micro_variation(&self) -> &f32 {
        self._glacier_base.micro_variation()
    }
    fn micro_variation_mut(&mut self) -> &mut f32 {
        self._glacier_base.micro_variation_mut()
    }
    fn hardness(&self) -> &f32 {
        self._glacier_base.hardness()
    }
    fn hardness_mut(&mut self) -> &mut f32 {
        self._glacier_base.hardness_mut()
    }
    fn force_as_instant_velocity(&self) -> &f32 {
        self._glacier_base.force_as_instant_velocity()
    }
    fn force_as_instant_velocity_mut(&mut self) -> &mut f32 {
        self._glacier_base.force_as_instant_velocity_mut()
    }
}

impl super::entity::GameComponentDataTrait for LocalWindForceBaked3DAs2x2DTexComponentData {
}

impl super::entity::ComponentDataTrait for LocalWindForceBaked3DAs2x2DTexComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for LocalWindForceBaked3DAs2x2DTexComponentData {
}

impl super::core::DataBusPeerTrait for LocalWindForceBaked3DAs2x2DTexComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for LocalWindForceBaked3DAs2x2DTexComponentData {
}

impl super::core::DataContainerTrait for LocalWindForceBaked3DAs2x2DTexComponentData {
}

pub static LOCALWINDFORCEBAKED3DAS2X2DTEXCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalWindForceBaked3DAs2x2DTexComponentData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(LOCALWINDFORCECOMPONENTBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LocalWindForceBaked3DAs2x2DTexComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SizeX",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LocalWindForceBaked3DAs2x2DTexComponentData, size_x),
            },
            FieldInfoData {
                name: "SizeY",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LocalWindForceBaked3DAs2x2DTexComponentData, size_y),
            },
            FieldInfoData {
                name: "SizeZ",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LocalWindForceBaked3DAs2x2DTexComponentData, size_z),
            },
            FieldInfoData {
                name: "Attenuation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LocalWindForceBaked3DAs2x2DTexComponentData, attenuation),
            },
            FieldInfoData {
                name: "VolumeSliceZX",
                flags: MemberInfoFlags::new(0),
                field_type: "TextureBaseAsset",
                rust_offset: offset_of!(LocalWindForceBaked3DAs2x2DTexComponentData, volume_slice_z_x),
            },
            FieldInfoData {
                name: "VolumeSliceZXScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(LocalWindForceBaked3DAs2x2DTexComponentData, volume_slice_z_x_scale),
            },
            FieldInfoData {
                name: "VolumeSliceZY",
                flags: MemberInfoFlags::new(0),
                field_type: "TextureBaseAsset",
                rust_offset: offset_of!(LocalWindForceBaked3DAs2x2DTexComponentData, volume_slice_z_y),
            },
            FieldInfoData {
                name: "VolumeSliceZYScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(LocalWindForceBaked3DAs2x2DTexComponentData, volume_slice_z_y_scale),
            },
        ],
    }),
    array_type: Some(LOCALWINDFORCEBAKED3DAS2X2DTEXCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for LocalWindForceBaked3DAs2x2DTexComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        LOCALWINDFORCEBAKED3DAS2X2DTEXCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LOCALWINDFORCEBAKED3DAS2X2DTEXCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalWindForceBaked3DAs2x2DTexComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("LocalWindForceBaked3DAs2x2DTexComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LocalWindForceConeComponentData {
    pub _glacier_base: LocalWindForceComponentBaseData,
    pub inner_radius: f32,
    pub outer_radius: f32,
    pub cone_inner_angle: f32,
    pub cone_outer_angle: f32,
}

pub trait LocalWindForceConeComponentDataTrait: LocalWindForceComponentBaseDataTrait {
    fn inner_radius(&self) -> &f32;
    fn inner_radius_mut(&mut self) -> &mut f32;
    fn outer_radius(&self) -> &f32;
    fn outer_radius_mut(&mut self) -> &mut f32;
    fn cone_inner_angle(&self) -> &f32;
    fn cone_inner_angle_mut(&mut self) -> &mut f32;
    fn cone_outer_angle(&self) -> &f32;
    fn cone_outer_angle_mut(&mut self) -> &mut f32;
}

impl LocalWindForceConeComponentDataTrait for LocalWindForceConeComponentData {
    fn inner_radius(&self) -> &f32 {
        &self.inner_radius
    }
    fn inner_radius_mut(&mut self) -> &mut f32 {
        &mut self.inner_radius
    }
    fn outer_radius(&self) -> &f32 {
        &self.outer_radius
    }
    fn outer_radius_mut(&mut self) -> &mut f32 {
        &mut self.outer_radius
    }
    fn cone_inner_angle(&self) -> &f32 {
        &self.cone_inner_angle
    }
    fn cone_inner_angle_mut(&mut self) -> &mut f32 {
        &mut self.cone_inner_angle
    }
    fn cone_outer_angle(&self) -> &f32 {
        &self.cone_outer_angle
    }
    fn cone_outer_angle_mut(&mut self) -> &mut f32 {
        &mut self.cone_outer_angle
    }
}

impl LocalWindForceComponentBaseDataTrait for LocalWindForceConeComponentData {
    fn force_group(&self) -> &Option<Arc<Mutex<dyn ForceGroupAssetTrait>>> {
        self._glacier_base.force_group()
    }
    fn force_group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ForceGroupAssetTrait>>> {
        self._glacier_base.force_group_mut()
    }
    fn strength(&self) -> &f32 {
        self._glacier_base.strength()
    }
    fn strength_mut(&mut self) -> &mut f32 {
        self._glacier_base.strength_mut()
    }
    fn variation(&self) -> &f32 {
        self._glacier_base.variation()
    }
    fn variation_mut(&mut self) -> &mut f32 {
        self._glacier_base.variation_mut()
    }
    fn variation_rate(&self) -> &f32 {
        self._glacier_base.variation_rate()
    }
    fn variation_rate_mut(&mut self) -> &mut f32 {
        self._glacier_base.variation_rate_mut()
    }
    fn micro_variation(&self) -> &f32 {
        self._glacier_base.micro_variation()
    }
    fn micro_variation_mut(&mut self) -> &mut f32 {
        self._glacier_base.micro_variation_mut()
    }
    fn hardness(&self) -> &f32 {
        self._glacier_base.hardness()
    }
    fn hardness_mut(&mut self) -> &mut f32 {
        self._glacier_base.hardness_mut()
    }
    fn force_as_instant_velocity(&self) -> &f32 {
        self._glacier_base.force_as_instant_velocity()
    }
    fn force_as_instant_velocity_mut(&mut self) -> &mut f32 {
        self._glacier_base.force_as_instant_velocity_mut()
    }
}

impl super::entity::GameComponentDataTrait for LocalWindForceConeComponentData {
}

impl super::entity::ComponentDataTrait for LocalWindForceConeComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for LocalWindForceConeComponentData {
}

impl super::core::DataBusPeerTrait for LocalWindForceConeComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for LocalWindForceConeComponentData {
}

impl super::core::DataContainerTrait for LocalWindForceConeComponentData {
}

pub static LOCALWINDFORCECONECOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalWindForceConeComponentData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(LOCALWINDFORCECOMPONENTBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LocalWindForceConeComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "InnerRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LocalWindForceConeComponentData, inner_radius),
            },
            FieldInfoData {
                name: "OuterRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LocalWindForceConeComponentData, outer_radius),
            },
            FieldInfoData {
                name: "ConeInnerAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LocalWindForceConeComponentData, cone_inner_angle),
            },
            FieldInfoData {
                name: "ConeOuterAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LocalWindForceConeComponentData, cone_outer_angle),
            },
        ],
    }),
    array_type: Some(LOCALWINDFORCECONECOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for LocalWindForceConeComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        LOCALWINDFORCECONECOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LOCALWINDFORCECONECOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalWindForceConeComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("LocalWindForceConeComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LocalWindForceSphereComponentData {
    pub _glacier_base: LocalWindForceComponentBaseData,
    pub radius: f32,
}

pub trait LocalWindForceSphereComponentDataTrait: LocalWindForceComponentBaseDataTrait {
    fn radius(&self) -> &f32;
    fn radius_mut(&mut self) -> &mut f32;
}

impl LocalWindForceSphereComponentDataTrait for LocalWindForceSphereComponentData {
    fn radius(&self) -> &f32 {
        &self.radius
    }
    fn radius_mut(&mut self) -> &mut f32 {
        &mut self.radius
    }
}

impl LocalWindForceComponentBaseDataTrait for LocalWindForceSphereComponentData {
    fn force_group(&self) -> &Option<Arc<Mutex<dyn ForceGroupAssetTrait>>> {
        self._glacier_base.force_group()
    }
    fn force_group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ForceGroupAssetTrait>>> {
        self._glacier_base.force_group_mut()
    }
    fn strength(&self) -> &f32 {
        self._glacier_base.strength()
    }
    fn strength_mut(&mut self) -> &mut f32 {
        self._glacier_base.strength_mut()
    }
    fn variation(&self) -> &f32 {
        self._glacier_base.variation()
    }
    fn variation_mut(&mut self) -> &mut f32 {
        self._glacier_base.variation_mut()
    }
    fn variation_rate(&self) -> &f32 {
        self._glacier_base.variation_rate()
    }
    fn variation_rate_mut(&mut self) -> &mut f32 {
        self._glacier_base.variation_rate_mut()
    }
    fn micro_variation(&self) -> &f32 {
        self._glacier_base.micro_variation()
    }
    fn micro_variation_mut(&mut self) -> &mut f32 {
        self._glacier_base.micro_variation_mut()
    }
    fn hardness(&self) -> &f32 {
        self._glacier_base.hardness()
    }
    fn hardness_mut(&mut self) -> &mut f32 {
        self._glacier_base.hardness_mut()
    }
    fn force_as_instant_velocity(&self) -> &f32 {
        self._glacier_base.force_as_instant_velocity()
    }
    fn force_as_instant_velocity_mut(&mut self) -> &mut f32 {
        self._glacier_base.force_as_instant_velocity_mut()
    }
}

impl super::entity::GameComponentDataTrait for LocalWindForceSphereComponentData {
}

impl super::entity::ComponentDataTrait for LocalWindForceSphereComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for LocalWindForceSphereComponentData {
}

impl super::core::DataBusPeerTrait for LocalWindForceSphereComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for LocalWindForceSphereComponentData {
}

impl super::core::DataContainerTrait for LocalWindForceSphereComponentData {
}

pub static LOCALWINDFORCESPHERECOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalWindForceSphereComponentData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(LOCALWINDFORCECOMPONENTBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LocalWindForceSphereComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Radius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LocalWindForceSphereComponentData, radius),
            },
        ],
    }),
    array_type: Some(LOCALWINDFORCESPHERECOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for LocalWindForceSphereComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        LOCALWINDFORCESPHERECOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LOCALWINDFORCESPHERECOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalWindForceSphereComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("LocalWindForceSphereComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LocalWindForceComponentBaseData {
    pub _glacier_base: super::entity::GameComponentData,
    pub force_group: Option<Arc<Mutex<dyn ForceGroupAssetTrait>>>,
    pub strength: f32,
    pub variation: f32,
    pub variation_rate: f32,
    pub micro_variation: f32,
    pub hardness: f32,
    pub force_as_instant_velocity: f32,
}

pub trait LocalWindForceComponentBaseDataTrait: super::entity::GameComponentDataTrait {
    fn force_group(&self) -> &Option<Arc<Mutex<dyn ForceGroupAssetTrait>>>;
    fn force_group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ForceGroupAssetTrait>>>;
    fn strength(&self) -> &f32;
    fn strength_mut(&mut self) -> &mut f32;
    fn variation(&self) -> &f32;
    fn variation_mut(&mut self) -> &mut f32;
    fn variation_rate(&self) -> &f32;
    fn variation_rate_mut(&mut self) -> &mut f32;
    fn micro_variation(&self) -> &f32;
    fn micro_variation_mut(&mut self) -> &mut f32;
    fn hardness(&self) -> &f32;
    fn hardness_mut(&mut self) -> &mut f32;
    fn force_as_instant_velocity(&self) -> &f32;
    fn force_as_instant_velocity_mut(&mut self) -> &mut f32;
}

impl LocalWindForceComponentBaseDataTrait for LocalWindForceComponentBaseData {
    fn force_group(&self) -> &Option<Arc<Mutex<dyn ForceGroupAssetTrait>>> {
        &self.force_group
    }
    fn force_group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ForceGroupAssetTrait>>> {
        &mut self.force_group
    }
    fn strength(&self) -> &f32 {
        &self.strength
    }
    fn strength_mut(&mut self) -> &mut f32 {
        &mut self.strength
    }
    fn variation(&self) -> &f32 {
        &self.variation
    }
    fn variation_mut(&mut self) -> &mut f32 {
        &mut self.variation
    }
    fn variation_rate(&self) -> &f32 {
        &self.variation_rate
    }
    fn variation_rate_mut(&mut self) -> &mut f32 {
        &mut self.variation_rate
    }
    fn micro_variation(&self) -> &f32 {
        &self.micro_variation
    }
    fn micro_variation_mut(&mut self) -> &mut f32 {
        &mut self.micro_variation
    }
    fn hardness(&self) -> &f32 {
        &self.hardness
    }
    fn hardness_mut(&mut self) -> &mut f32 {
        &mut self.hardness
    }
    fn force_as_instant_velocity(&self) -> &f32 {
        &self.force_as_instant_velocity
    }
    fn force_as_instant_velocity_mut(&mut self) -> &mut f32 {
        &mut self.force_as_instant_velocity
    }
}

impl super::entity::GameComponentDataTrait for LocalWindForceComponentBaseData {
}

impl super::entity::ComponentDataTrait for LocalWindForceComponentBaseData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for LocalWindForceComponentBaseData {
}

impl super::core::DataBusPeerTrait for LocalWindForceComponentBaseData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for LocalWindForceComponentBaseData {
}

impl super::core::DataContainerTrait for LocalWindForceComponentBaseData {
}

pub static LOCALWINDFORCECOMPONENTBASEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalWindForceComponentBaseData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LocalWindForceComponentBaseData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ForceGroup",
                flags: MemberInfoFlags::new(0),
                field_type: "ForceGroupAsset",
                rust_offset: offset_of!(LocalWindForceComponentBaseData, force_group),
            },
            FieldInfoData {
                name: "Strength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LocalWindForceComponentBaseData, strength),
            },
            FieldInfoData {
                name: "Variation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LocalWindForceComponentBaseData, variation),
            },
            FieldInfoData {
                name: "VariationRate",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LocalWindForceComponentBaseData, variation_rate),
            },
            FieldInfoData {
                name: "MicroVariation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LocalWindForceComponentBaseData, micro_variation),
            },
            FieldInfoData {
                name: "Hardness",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LocalWindForceComponentBaseData, hardness),
            },
            FieldInfoData {
                name: "ForceAsInstantVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LocalWindForceComponentBaseData, force_as_instant_velocity),
            },
        ],
    }),
    array_type: Some(LOCALWINDFORCECOMPONENTBASEDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for LocalWindForceComponentBaseData {
    fn type_info(&self) -> &'static TypeInfo {
        LOCALWINDFORCECOMPONENTBASEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LOCALWINDFORCECOMPONENTBASEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalWindForceComponentBaseData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("LocalWindForceComponentBaseData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LogicVisualEnvironmentReferenceObjectData {
    pub _glacier_base: VisualEnvironmentReferenceObjectData,
}

pub trait LogicVisualEnvironmentReferenceObjectDataTrait: VisualEnvironmentReferenceObjectDataTrait {
}

impl LogicVisualEnvironmentReferenceObjectDataTrait for LogicVisualEnvironmentReferenceObjectData {
}

impl VisualEnvironmentReferenceObjectDataTrait for LogicVisualEnvironmentReferenceObjectData {
    fn priority(&self) -> &i32 {
        self._glacier_base.priority()
    }
    fn priority_mut(&mut self) -> &mut i32 {
        self._glacier_base.priority_mut()
    }
    fn override_visibility(&self) -> &bool {
        self._glacier_base.override_visibility()
    }
    fn override_visibility_mut(&mut self) -> &mut bool {
        self._glacier_base.override_visibility_mut()
    }
    fn owned_by_lighting_context_pad(&self) -> &bool {
        self._glacier_base.owned_by_lighting_context_pad()
    }
    fn owned_by_lighting_context_pad_mut(&mut self) -> &mut bool {
        self._glacier_base.owned_by_lighting_context_pad_mut()
    }
}

impl super::entity::LogicReferenceObjectDataTrait for LogicVisualEnvironmentReferenceObjectData {
    fn local_player_id(&self) -> &super::core::LocalPlayerId {
        self._glacier_base.local_player_id()
    }
    fn local_player_id_mut(&mut self) -> &mut super::core::LocalPlayerId {
        self._glacier_base.local_player_id_mut()
    }
    fn sub_realm(&self) -> &super::entity::SubRealm {
        self._glacier_base.sub_realm()
    }
    fn sub_realm_mut(&mut self) -> &mut super::entity::SubRealm {
        self._glacier_base.sub_realm_mut()
    }
}

impl super::entity::ReferenceObjectDataTrait for LogicVisualEnvironmentReferenceObjectData {
    fn blueprint_transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.blueprint_transform()
    }
    fn blueprint_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.blueprint_transform_mut()
    }
    fn blueprint(&self) -> &Option<Arc<Mutex<dyn super::entity::BlueprintTrait>>> {
        self._glacier_base.blueprint()
    }
    fn blueprint_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::BlueprintTrait>>> {
        self._glacier_base.blueprint_mut()
    }
    fn object_variation(&self) -> &Option<Arc<Mutex<dyn super::entity::ObjectVariationTrait>>> {
        self._glacier_base.object_variation()
    }
    fn object_variation_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::ObjectVariationTrait>>> {
        self._glacier_base.object_variation_mut()
    }
    fn stream_realm(&self) -> &super::entity::StreamRealm {
        self._glacier_base.stream_realm()
    }
    fn stream_realm_mut(&mut self) -> &mut super::entity::StreamRealm {
        self._glacier_base.stream_realm_mut()
    }
    fn radiosity_type_override(&self) -> &super::core::RadiosityTypeOverride {
        self._glacier_base.radiosity_type_override()
    }
    fn radiosity_type_override_mut(&mut self) -> &mut super::core::RadiosityTypeOverride {
        self._glacier_base.radiosity_type_override_mut()
    }
    fn lightmap_resolution_scale(&self) -> &u32 {
        self._glacier_base.lightmap_resolution_scale()
    }
    fn lightmap_resolution_scale_mut(&mut self) -> &mut u32 {
        self._glacier_base.lightmap_resolution_scale_mut()
    }
    fn lightmap_scale_with_size(&self) -> &bool {
        self._glacier_base.lightmap_scale_with_size()
    }
    fn lightmap_scale_with_size_mut(&mut self) -> &mut bool {
        self._glacier_base.lightmap_scale_with_size_mut()
    }
    fn rendering_overrides(&self) -> &super::core::RenderingOverrides {
        self._glacier_base.rendering_overrides()
    }
    fn rendering_overrides_mut(&mut self) -> &mut super::core::RenderingOverrides {
        self._glacier_base.rendering_overrides_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
    fn create_indestructible_entity(&self) -> &bool {
        self._glacier_base.create_indestructible_entity()
    }
    fn create_indestructible_entity_mut(&mut self) -> &mut bool {
        self._glacier_base.create_indestructible_entity_mut()
    }
}

impl super::entity::GameObjectDataTrait for LogicVisualEnvironmentReferenceObjectData {
}

impl super::core::DataBusPeerTrait for LogicVisualEnvironmentReferenceObjectData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for LogicVisualEnvironmentReferenceObjectData {
}

impl super::core::DataContainerTrait for LogicVisualEnvironmentReferenceObjectData {
}

pub static LOGICVISUALENVIRONMENTREFERENCEOBJECTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LogicVisualEnvironmentReferenceObjectData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VISUALENVIRONMENTREFERENCEOBJECTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LogicVisualEnvironmentReferenceObjectData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(LOGICVISUALENVIRONMENTREFERENCEOBJECTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for LogicVisualEnvironmentReferenceObjectData {
    fn type_info(&self) -> &'static TypeInfo {
        LOGICVISUALENVIRONMENTREFERENCEOBJECTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LOGICVISUALENVIRONMENTREFERENCEOBJECTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LogicVisualEnvironmentReferenceObjectData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("LogicVisualEnvironmentReferenceObjectData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VisualEnvironmentReferenceObjectData {
    pub _glacier_base: super::entity::LogicReferenceObjectData,
    pub priority: i32,
    pub override_visibility: bool,
    pub owned_by_lighting_context_pad: bool,
}

pub trait VisualEnvironmentReferenceObjectDataTrait: super::entity::LogicReferenceObjectDataTrait {
    fn priority(&self) -> &i32;
    fn priority_mut(&mut self) -> &mut i32;
    fn override_visibility(&self) -> &bool;
    fn override_visibility_mut(&mut self) -> &mut bool;
    fn owned_by_lighting_context_pad(&self) -> &bool;
    fn owned_by_lighting_context_pad_mut(&mut self) -> &mut bool;
}

impl VisualEnvironmentReferenceObjectDataTrait for VisualEnvironmentReferenceObjectData {
    fn priority(&self) -> &i32 {
        &self.priority
    }
    fn priority_mut(&mut self) -> &mut i32 {
        &mut self.priority
    }
    fn override_visibility(&self) -> &bool {
        &self.override_visibility
    }
    fn override_visibility_mut(&mut self) -> &mut bool {
        &mut self.override_visibility
    }
    fn owned_by_lighting_context_pad(&self) -> &bool {
        &self.owned_by_lighting_context_pad
    }
    fn owned_by_lighting_context_pad_mut(&mut self) -> &mut bool {
        &mut self.owned_by_lighting_context_pad
    }
}

impl super::entity::LogicReferenceObjectDataTrait for VisualEnvironmentReferenceObjectData {
    fn local_player_id(&self) -> &super::core::LocalPlayerId {
        self._glacier_base.local_player_id()
    }
    fn local_player_id_mut(&mut self) -> &mut super::core::LocalPlayerId {
        self._glacier_base.local_player_id_mut()
    }
    fn sub_realm(&self) -> &super::entity::SubRealm {
        self._glacier_base.sub_realm()
    }
    fn sub_realm_mut(&mut self) -> &mut super::entity::SubRealm {
        self._glacier_base.sub_realm_mut()
    }
}

impl super::entity::ReferenceObjectDataTrait for VisualEnvironmentReferenceObjectData {
    fn blueprint_transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.blueprint_transform()
    }
    fn blueprint_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.blueprint_transform_mut()
    }
    fn blueprint(&self) -> &Option<Arc<Mutex<dyn super::entity::BlueprintTrait>>> {
        self._glacier_base.blueprint()
    }
    fn blueprint_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::BlueprintTrait>>> {
        self._glacier_base.blueprint_mut()
    }
    fn object_variation(&self) -> &Option<Arc<Mutex<dyn super::entity::ObjectVariationTrait>>> {
        self._glacier_base.object_variation()
    }
    fn object_variation_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::ObjectVariationTrait>>> {
        self._glacier_base.object_variation_mut()
    }
    fn stream_realm(&self) -> &super::entity::StreamRealm {
        self._glacier_base.stream_realm()
    }
    fn stream_realm_mut(&mut self) -> &mut super::entity::StreamRealm {
        self._glacier_base.stream_realm_mut()
    }
    fn radiosity_type_override(&self) -> &super::core::RadiosityTypeOverride {
        self._glacier_base.radiosity_type_override()
    }
    fn radiosity_type_override_mut(&mut self) -> &mut super::core::RadiosityTypeOverride {
        self._glacier_base.radiosity_type_override_mut()
    }
    fn lightmap_resolution_scale(&self) -> &u32 {
        self._glacier_base.lightmap_resolution_scale()
    }
    fn lightmap_resolution_scale_mut(&mut self) -> &mut u32 {
        self._glacier_base.lightmap_resolution_scale_mut()
    }
    fn lightmap_scale_with_size(&self) -> &bool {
        self._glacier_base.lightmap_scale_with_size()
    }
    fn lightmap_scale_with_size_mut(&mut self) -> &mut bool {
        self._glacier_base.lightmap_scale_with_size_mut()
    }
    fn rendering_overrides(&self) -> &super::core::RenderingOverrides {
        self._glacier_base.rendering_overrides()
    }
    fn rendering_overrides_mut(&mut self) -> &mut super::core::RenderingOverrides {
        self._glacier_base.rendering_overrides_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
    fn create_indestructible_entity(&self) -> &bool {
        self._glacier_base.create_indestructible_entity()
    }
    fn create_indestructible_entity_mut(&mut self) -> &mut bool {
        self._glacier_base.create_indestructible_entity_mut()
    }
}

impl super::entity::GameObjectDataTrait for VisualEnvironmentReferenceObjectData {
}

impl super::core::DataBusPeerTrait for VisualEnvironmentReferenceObjectData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for VisualEnvironmentReferenceObjectData {
}

impl super::core::DataContainerTrait for VisualEnvironmentReferenceObjectData {
}

pub static VISUALENVIRONMENTREFERENCEOBJECTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VisualEnvironmentReferenceObjectData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::LOGICREFERENCEOBJECTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VisualEnvironmentReferenceObjectData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Priority",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(VisualEnvironmentReferenceObjectData, priority),
            },
            FieldInfoData {
                name: "OverrideVisibility",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VisualEnvironmentReferenceObjectData, override_visibility),
            },
            FieldInfoData {
                name: "OwnedByLightingContextPad",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VisualEnvironmentReferenceObjectData, owned_by_lighting_context_pad),
            },
        ],
    }),
    array_type: Some(VISUALENVIRONMENTREFERENCEOBJECTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VisualEnvironmentReferenceObjectData {
    fn type_info(&self) -> &'static TypeInfo {
        VISUALENVIRONMENTREFERENCEOBJECTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VISUALENVIRONMENTREFERENCEOBJECTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VisualEnvironmentReferenceObjectData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("VisualEnvironmentReferenceObjectData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LogicVisualEnvironmentEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub visual_environment: Option<Arc<Mutex<dyn VisualEnvironmentBlueprintTrait>>>,
    pub visibility: f32,
}

pub trait LogicVisualEnvironmentEntityDataTrait: super::entity::EntityDataTrait {
    fn visual_environment(&self) -> &Option<Arc<Mutex<dyn VisualEnvironmentBlueprintTrait>>>;
    fn visual_environment_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VisualEnvironmentBlueprintTrait>>>;
    fn visibility(&self) -> &f32;
    fn visibility_mut(&mut self) -> &mut f32;
}

impl LogicVisualEnvironmentEntityDataTrait for LogicVisualEnvironmentEntityData {
    fn visual_environment(&self) -> &Option<Arc<Mutex<dyn VisualEnvironmentBlueprintTrait>>> {
        &self.visual_environment
    }
    fn visual_environment_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VisualEnvironmentBlueprintTrait>>> {
        &mut self.visual_environment
    }
    fn visibility(&self) -> &f32 {
        &self.visibility
    }
    fn visibility_mut(&mut self) -> &mut f32 {
        &mut self.visibility
    }
}

impl super::entity::EntityDataTrait for LogicVisualEnvironmentEntityData {
}

impl super::entity::GameObjectDataTrait for LogicVisualEnvironmentEntityData {
}

impl super::core::DataBusPeerTrait for LogicVisualEnvironmentEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for LogicVisualEnvironmentEntityData {
}

impl super::core::DataContainerTrait for LogicVisualEnvironmentEntityData {
}

pub static LOGICVISUALENVIRONMENTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LogicVisualEnvironmentEntityData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LogicVisualEnvironmentEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "VisualEnvironment",
                flags: MemberInfoFlags::new(0),
                field_type: "VisualEnvironmentBlueprint",
                rust_offset: offset_of!(LogicVisualEnvironmentEntityData, visual_environment),
            },
            FieldInfoData {
                name: "Visibility",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LogicVisualEnvironmentEntityData, visibility),
            },
        ],
    }),
    array_type: Some(LOGICVISUALENVIRONMENTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LogicVisualEnvironmentEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        LOGICVISUALENVIRONMENTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LOGICVISUALENVIRONMENTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LogicVisualEnvironmentEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("LogicVisualEnvironmentEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VisualEnvironmentBlueprint {
    pub _glacier_base: super::entity::ObjectBlueprint,
    pub time_delta_type: super::entity::TimeDeltaType,
}

pub trait VisualEnvironmentBlueprintTrait: super::entity::ObjectBlueprintTrait {
    fn time_delta_type(&self) -> &super::entity::TimeDeltaType;
    fn time_delta_type_mut(&mut self) -> &mut super::entity::TimeDeltaType;
}

impl VisualEnvironmentBlueprintTrait for VisualEnvironmentBlueprint {
    fn time_delta_type(&self) -> &super::entity::TimeDeltaType {
        &self.time_delta_type
    }
    fn time_delta_type_mut(&mut self) -> &mut super::entity::TimeDeltaType {
        &mut self.time_delta_type
    }
}

impl super::entity::ObjectBlueprintTrait for VisualEnvironmentBlueprint {
    fn object(&self) -> &Option<Arc<Mutex<dyn super::entity::EntityDataTrait>>> {
        self._glacier_base.object()
    }
    fn object_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::EntityDataTrait>>> {
        self._glacier_base.object_mut()
    }
}

impl super::entity::BlueprintTrait for VisualEnvironmentBlueprint {
    fn objects(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.objects()
    }
    fn objects_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.objects_mut()
    }
    fn schematics(&self) -> &Option<Arc<Mutex<dyn super::schematics::SchematicsBaseAssetTrait>>> {
        self._glacier_base.schematics()
    }
    fn schematics_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::schematics::SchematicsBaseAssetTrait>>> {
        self._glacier_base.schematics_mut()
    }
}

impl super::entity::EntityBusDataTrait for VisualEnvironmentBlueprint {
    fn event_connections(&self) -> &Vec<super::entity::EventConnection> {
        self._glacier_base.event_connections()
    }
    fn event_connections_mut(&mut self) -> &mut Vec<super::entity::EventConnection> {
        self._glacier_base.event_connections_mut()
    }
}

impl super::core::DataBusDataTrait for VisualEnvironmentBlueprint {
    fn flags(&self) -> &u16 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.flags_mut()
    }
    fn property_connections(&self) -> &Vec<super::core::PropertyConnection> {
        self._glacier_base.property_connections()
    }
    fn property_connections_mut(&mut self) -> &mut Vec<super::core::PropertyConnection> {
        self._glacier_base.property_connections_mut()
    }
    fn link_connections(&self) -> &Vec<super::core::LinkConnection> {
        self._glacier_base.link_connections()
    }
    fn link_connections_mut(&mut self) -> &mut Vec<super::core::LinkConnection> {
        self._glacier_base.link_connections_mut()
    }
    fn interface(&self) -> &Option<Arc<Mutex<dyn super::core::DynamicDataContainerTrait>>> {
        self._glacier_base.interface()
    }
    fn interface_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::DynamicDataContainerTrait>>> {
        self._glacier_base.interface_mut()
    }
}

impl super::core::AssetTrait for VisualEnvironmentBlueprint {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for VisualEnvironmentBlueprint {
}

pub static VISUALENVIRONMENTBLUEPRINT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VisualEnvironmentBlueprint",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::OBJECTBLUEPRINT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VisualEnvironmentBlueprint as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "TimeDeltaType",
                flags: MemberInfoFlags::new(0),
                field_type: "TimeDeltaType",
                rust_offset: offset_of!(VisualEnvironmentBlueprint, time_delta_type),
            },
        ],
    }),
    array_type: Some(VISUALENVIRONMENTBLUEPRINT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VisualEnvironmentBlueprint {
    fn type_info(&self) -> &'static TypeInfo {
        VISUALENVIRONMENTBLUEPRINT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VISUALENVIRONMENTBLUEPRINT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VisualEnvironmentBlueprint-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("VisualEnvironmentBlueprint"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VisualEnvironmentEntityData {
    pub _glacier_base: super::entity::GameComponentEntityData,
    pub visibility: f32,
    pub priority: i32,
    pub local_player_view_id: super::render_base::LocalPlayerViewId,
    pub explicit_priority_enable: bool,
    pub blend_mode: VisualEnvironmentBlendMode,
    pub view_id: super::render_base::LocalPlayerViewId,
}

pub trait VisualEnvironmentEntityDataTrait: super::entity::GameComponentEntityDataTrait {
    fn visibility(&self) -> &f32;
    fn visibility_mut(&mut self) -> &mut f32;
    fn priority(&self) -> &i32;
    fn priority_mut(&mut self) -> &mut i32;
    fn local_player_view_id(&self) -> &super::render_base::LocalPlayerViewId;
    fn local_player_view_id_mut(&mut self) -> &mut super::render_base::LocalPlayerViewId;
    fn explicit_priority_enable(&self) -> &bool;
    fn explicit_priority_enable_mut(&mut self) -> &mut bool;
    fn blend_mode(&self) -> &VisualEnvironmentBlendMode;
    fn blend_mode_mut(&mut self) -> &mut VisualEnvironmentBlendMode;
    fn view_id(&self) -> &super::render_base::LocalPlayerViewId;
    fn view_id_mut(&mut self) -> &mut super::render_base::LocalPlayerViewId;
}

impl VisualEnvironmentEntityDataTrait for VisualEnvironmentEntityData {
    fn visibility(&self) -> &f32 {
        &self.visibility
    }
    fn visibility_mut(&mut self) -> &mut f32 {
        &mut self.visibility
    }
    fn priority(&self) -> &i32 {
        &self.priority
    }
    fn priority_mut(&mut self) -> &mut i32 {
        &mut self.priority
    }
    fn local_player_view_id(&self) -> &super::render_base::LocalPlayerViewId {
        &self.local_player_view_id
    }
    fn local_player_view_id_mut(&mut self) -> &mut super::render_base::LocalPlayerViewId {
        &mut self.local_player_view_id
    }
    fn explicit_priority_enable(&self) -> &bool {
        &self.explicit_priority_enable
    }
    fn explicit_priority_enable_mut(&mut self) -> &mut bool {
        &mut self.explicit_priority_enable
    }
    fn blend_mode(&self) -> &VisualEnvironmentBlendMode {
        &self.blend_mode
    }
    fn blend_mode_mut(&mut self) -> &mut VisualEnvironmentBlendMode {
        &mut self.blend_mode
    }
    fn view_id(&self) -> &super::render_base::LocalPlayerViewId {
        &self.view_id
    }
    fn view_id_mut(&mut self) -> &mut super::render_base::LocalPlayerViewId {
        &mut self.view_id
    }
}

impl super::entity::GameComponentEntityDataTrait for VisualEnvironmentEntityData {
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::ComponentEntityDataTrait for VisualEnvironmentEntityData {
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn part_bounding_boxes(&self) -> &Vec<super::core::AxisAlignedBox> {
        self._glacier_base.part_bounding_boxes()
    }
    fn part_bounding_boxes_mut(&mut self) -> &mut Vec<super::core::AxisAlignedBox> {
        self._glacier_base.part_bounding_boxes_mut()
    }
    fn client_runtime_component_count(&self) -> &u8 {
        self._glacier_base.client_runtime_component_count()
    }
    fn client_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_component_count_mut()
    }
    fn server_runtime_component_count(&self) -> &u8 {
        self._glacier_base.server_runtime_component_count()
    }
    fn server_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_component_count_mut()
    }
    fn client_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.client_runtime_transformation_count()
    }
    fn client_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_transformation_count_mut()
    }
    fn server_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.server_runtime_transformation_count()
    }
    fn server_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_transformation_count_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for VisualEnvironmentEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for VisualEnvironmentEntityData {
}

impl super::entity::GameObjectDataTrait for VisualEnvironmentEntityData {
}

impl super::core::DataBusPeerTrait for VisualEnvironmentEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for VisualEnvironmentEntityData {
}

impl super::core::DataContainerTrait for VisualEnvironmentEntityData {
}

pub static VISUALENVIRONMENTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VisualEnvironmentEntityData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VisualEnvironmentEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Visibility",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VisualEnvironmentEntityData, visibility),
            },
            FieldInfoData {
                name: "Priority",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(VisualEnvironmentEntityData, priority),
            },
            FieldInfoData {
                name: "LocalPlayerViewId",
                flags: MemberInfoFlags::new(0),
                field_type: "LocalPlayerViewId",
                rust_offset: offset_of!(VisualEnvironmentEntityData, local_player_view_id),
            },
            FieldInfoData {
                name: "ExplicitPriorityEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VisualEnvironmentEntityData, explicit_priority_enable),
            },
            FieldInfoData {
                name: "BlendMode",
                flags: MemberInfoFlags::new(0),
                field_type: "VisualEnvironmentBlendMode",
                rust_offset: offset_of!(VisualEnvironmentEntityData, blend_mode),
            },
            FieldInfoData {
                name: "ViewId",
                flags: MemberInfoFlags::new(0),
                field_type: "LocalPlayerViewId",
                rust_offset: offset_of!(VisualEnvironmentEntityData, view_id),
            },
        ],
    }),
    array_type: Some(VISUALENVIRONMENTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VisualEnvironmentEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VISUALENVIRONMENTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VISUALENVIRONMENTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VisualEnvironmentEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("VisualEnvironmentEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum VisualEnvironmentPriorityOffset {
    #[default]
    VisualEnvironmentPriorityOffset_Camera = 10000,
    VisualEnvironmentPriorityOffset_Logic = 10000000,
}

pub static VISUALENVIRONMENTPRIORITYOFFSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VisualEnvironmentPriorityOffset",
    flags: MemberInfoFlags::new(49429),
    module: "WorldSim",
    data: TypeInfoData::Enum,
    array_type: Some(VISUALENVIRONMENTPRIORITYOFFSET_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for VisualEnvironmentPriorityOffset {
    fn type_info(&self) -> &'static TypeInfo {
        VISUALENVIRONMENTPRIORITYOFFSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VISUALENVIRONMENTPRIORITYOFFSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VisualEnvironmentPriorityOffset-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("VisualEnvironmentPriorityOffset"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum VisualEnvironmentBlendMode {
    #[default]
    VisualEnvironmentBlendMode_Lerp = 0,
    VisualEnvironmentBlendMode_Add = 1,
    VisualEnvironmentBlendMode_Subtract = 2,
}

pub static VISUALENVIRONMENTBLENDMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VisualEnvironmentBlendMode",
    flags: MemberInfoFlags::new(49429),
    module: "WorldSim",
    data: TypeInfoData::Enum,
    array_type: Some(VISUALENVIRONMENTBLENDMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for VisualEnvironmentBlendMode {
    fn type_info(&self) -> &'static TypeInfo {
        VISUALENVIRONMENTBLENDMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VISUALENVIRONMENTBLENDMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VisualEnvironmentBlendMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("VisualEnvironmentBlendMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SonarParamsComponentData {
    pub _glacier_base: VisualEnvironmentComponentData,
    pub enable: bool,
    pub color1: super::core::Vec3,
    pub color2: super::core::Vec3,
    pub color3: super::core::Vec3,
    pub field_flag_override0: u8,
}

pub trait SonarParamsComponentDataTrait: VisualEnvironmentComponentDataTrait {
    fn enable(&self) -> &bool;
    fn enable_mut(&mut self) -> &mut bool;
    fn color1(&self) -> &super::core::Vec3;
    fn color1_mut(&mut self) -> &mut super::core::Vec3;
    fn color2(&self) -> &super::core::Vec3;
    fn color2_mut(&mut self) -> &mut super::core::Vec3;
    fn color3(&self) -> &super::core::Vec3;
    fn color3_mut(&mut self) -> &mut super::core::Vec3;
    fn field_flag_override0(&self) -> &u8;
    fn field_flag_override0_mut(&mut self) -> &mut u8;
}

impl SonarParamsComponentDataTrait for SonarParamsComponentData {
    fn enable(&self) -> &bool {
        &self.enable
    }
    fn enable_mut(&mut self) -> &mut bool {
        &mut self.enable
    }
    fn color1(&self) -> &super::core::Vec3 {
        &self.color1
    }
    fn color1_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.color1
    }
    fn color2(&self) -> &super::core::Vec3 {
        &self.color2
    }
    fn color2_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.color2
    }
    fn color3(&self) -> &super::core::Vec3 {
        &self.color3
    }
    fn color3_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.color3
    }
    fn field_flag_override0(&self) -> &u8 {
        &self.field_flag_override0
    }
    fn field_flag_override0_mut(&mut self) -> &mut u8 {
        &mut self.field_flag_override0
    }
}

impl VisualEnvironmentComponentDataTrait for SonarParamsComponentData {
    fn property_overrides(&self) -> &Vec<String> {
        self._glacier_base.property_overrides()
    }
    fn property_overrides_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.property_overrides_mut()
    }
}

impl super::entity::ComponentDataTrait for SonarParamsComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for SonarParamsComponentData {
}

impl super::core::DataBusPeerTrait for SonarParamsComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SonarParamsComponentData {
}

impl super::core::DataContainerTrait for SonarParamsComponentData {
}

pub static SONARPARAMSCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SonarParamsComponentData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VISUALENVIRONMENTCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SonarParamsComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SonarParamsComponentData, enable),
            },
            FieldInfoData {
                name: "Color1",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SonarParamsComponentData, color1),
            },
            FieldInfoData {
                name: "Color2",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SonarParamsComponentData, color2),
            },
            FieldInfoData {
                name: "Color3",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SonarParamsComponentData, color3),
            },
            FieldInfoData {
                name: "FieldFlagOverride0",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(SonarParamsComponentData, field_flag_override0),
            },
        ],
    }),
    array_type: Some(SONARPARAMSCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SonarParamsComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        SONARPARAMSCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SONARPARAMSCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SonarParamsComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("SonarParamsComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct HologramParamsComponentData {
    pub _glacier_base: VisualEnvironmentComponentData,
    pub enable: bool,
    pub render_mode: super::world_base::HologramRenderMode,
    pub key_illuminance: super::core::Vec3,
    pub key_light_dir: super::core::Vec3,
    pub resolution_scale: f32,
    pub color1: super::core::Vec3,
    pub color2: super::core::Vec3,
    pub color3: super::core::Vec3,
    pub color4: super::core::Vec3,
    pub color5: super::core::Vec3,
    pub float1: f32,
    pub float2: f32,
    pub float3: f32,
    pub float4: f32,
    pub float5: f32,
    pub float6: f32,
    pub float7: f32,
    pub float8: f32,
    pub float9: f32,
    pub brightness2: f32,
    pub brightness3: f32,
    pub brightness4: f32,
    pub brightness5: f32,
    pub streaks_enabled: bool,
    pub time_offset: f32,
    pub opacity1: f32,
    pub distortion_scale1: f32,
    pub source_pos1: super::core::Vec3,
    pub target_pos1: super::core::Vec3,
    pub source_radius1: f32,
    pub target_radius1: f32,
    pub opacity2: f32,
    pub distortion_scale2: f32,
    pub source_pos2: super::core::Vec3,
    pub target_pos2: super::core::Vec3,
    pub source_radius2: f32,
    pub target_radius2: f32,
    pub opacity3: f32,
    pub distortion_scale3: f32,
    pub source_pos3: super::core::Vec3,
    pub target_pos3: super::core::Vec3,
    pub source_radius3: f32,
    pub target_radius3: f32,
    pub opacity4: f32,
    pub distortion_scale4: f32,
    pub source_pos4: super::core::Vec3,
    pub target_pos4: super::core::Vec3,
    pub source_radius4: f32,
    pub target_radius4: f32,
    pub opacity5: f32,
    pub distortion_scale5: f32,
    pub source_pos5: super::core::Vec3,
    pub target_pos5: super::core::Vec3,
    pub source_radius5: f32,
    pub target_radius5: f32,
    pub field_flag_override0: u32,
    pub field_flag_override1: u32,
}

pub trait HologramParamsComponentDataTrait: VisualEnvironmentComponentDataTrait {
    fn enable(&self) -> &bool;
    fn enable_mut(&mut self) -> &mut bool;
    fn render_mode(&self) -> &super::world_base::HologramRenderMode;
    fn render_mode_mut(&mut self) -> &mut super::world_base::HologramRenderMode;
    fn key_illuminance(&self) -> &super::core::Vec3;
    fn key_illuminance_mut(&mut self) -> &mut super::core::Vec3;
    fn key_light_dir(&self) -> &super::core::Vec3;
    fn key_light_dir_mut(&mut self) -> &mut super::core::Vec3;
    fn resolution_scale(&self) -> &f32;
    fn resolution_scale_mut(&mut self) -> &mut f32;
    fn color1(&self) -> &super::core::Vec3;
    fn color1_mut(&mut self) -> &mut super::core::Vec3;
    fn color2(&self) -> &super::core::Vec3;
    fn color2_mut(&mut self) -> &mut super::core::Vec3;
    fn color3(&self) -> &super::core::Vec3;
    fn color3_mut(&mut self) -> &mut super::core::Vec3;
    fn color4(&self) -> &super::core::Vec3;
    fn color4_mut(&mut self) -> &mut super::core::Vec3;
    fn color5(&self) -> &super::core::Vec3;
    fn color5_mut(&mut self) -> &mut super::core::Vec3;
    fn float1(&self) -> &f32;
    fn float1_mut(&mut self) -> &mut f32;
    fn float2(&self) -> &f32;
    fn float2_mut(&mut self) -> &mut f32;
    fn float3(&self) -> &f32;
    fn float3_mut(&mut self) -> &mut f32;
    fn float4(&self) -> &f32;
    fn float4_mut(&mut self) -> &mut f32;
    fn float5(&self) -> &f32;
    fn float5_mut(&mut self) -> &mut f32;
    fn float6(&self) -> &f32;
    fn float6_mut(&mut self) -> &mut f32;
    fn float7(&self) -> &f32;
    fn float7_mut(&mut self) -> &mut f32;
    fn float8(&self) -> &f32;
    fn float8_mut(&mut self) -> &mut f32;
    fn float9(&self) -> &f32;
    fn float9_mut(&mut self) -> &mut f32;
    fn brightness2(&self) -> &f32;
    fn brightness2_mut(&mut self) -> &mut f32;
    fn brightness3(&self) -> &f32;
    fn brightness3_mut(&mut self) -> &mut f32;
    fn brightness4(&self) -> &f32;
    fn brightness4_mut(&mut self) -> &mut f32;
    fn brightness5(&self) -> &f32;
    fn brightness5_mut(&mut self) -> &mut f32;
    fn streaks_enabled(&self) -> &bool;
    fn streaks_enabled_mut(&mut self) -> &mut bool;
    fn time_offset(&self) -> &f32;
    fn time_offset_mut(&mut self) -> &mut f32;
    fn opacity1(&self) -> &f32;
    fn opacity1_mut(&mut self) -> &mut f32;
    fn distortion_scale1(&self) -> &f32;
    fn distortion_scale1_mut(&mut self) -> &mut f32;
    fn source_pos1(&self) -> &super::core::Vec3;
    fn source_pos1_mut(&mut self) -> &mut super::core::Vec3;
    fn target_pos1(&self) -> &super::core::Vec3;
    fn target_pos1_mut(&mut self) -> &mut super::core::Vec3;
    fn source_radius1(&self) -> &f32;
    fn source_radius1_mut(&mut self) -> &mut f32;
    fn target_radius1(&self) -> &f32;
    fn target_radius1_mut(&mut self) -> &mut f32;
    fn opacity2(&self) -> &f32;
    fn opacity2_mut(&mut self) -> &mut f32;
    fn distortion_scale2(&self) -> &f32;
    fn distortion_scale2_mut(&mut self) -> &mut f32;
    fn source_pos2(&self) -> &super::core::Vec3;
    fn source_pos2_mut(&mut self) -> &mut super::core::Vec3;
    fn target_pos2(&self) -> &super::core::Vec3;
    fn target_pos2_mut(&mut self) -> &mut super::core::Vec3;
    fn source_radius2(&self) -> &f32;
    fn source_radius2_mut(&mut self) -> &mut f32;
    fn target_radius2(&self) -> &f32;
    fn target_radius2_mut(&mut self) -> &mut f32;
    fn opacity3(&self) -> &f32;
    fn opacity3_mut(&mut self) -> &mut f32;
    fn distortion_scale3(&self) -> &f32;
    fn distortion_scale3_mut(&mut self) -> &mut f32;
    fn source_pos3(&self) -> &super::core::Vec3;
    fn source_pos3_mut(&mut self) -> &mut super::core::Vec3;
    fn target_pos3(&self) -> &super::core::Vec3;
    fn target_pos3_mut(&mut self) -> &mut super::core::Vec3;
    fn source_radius3(&self) -> &f32;
    fn source_radius3_mut(&mut self) -> &mut f32;
    fn target_radius3(&self) -> &f32;
    fn target_radius3_mut(&mut self) -> &mut f32;
    fn opacity4(&self) -> &f32;
    fn opacity4_mut(&mut self) -> &mut f32;
    fn distortion_scale4(&self) -> &f32;
    fn distortion_scale4_mut(&mut self) -> &mut f32;
    fn source_pos4(&self) -> &super::core::Vec3;
    fn source_pos4_mut(&mut self) -> &mut super::core::Vec3;
    fn target_pos4(&self) -> &super::core::Vec3;
    fn target_pos4_mut(&mut self) -> &mut super::core::Vec3;
    fn source_radius4(&self) -> &f32;
    fn source_radius4_mut(&mut self) -> &mut f32;
    fn target_radius4(&self) -> &f32;
    fn target_radius4_mut(&mut self) -> &mut f32;
    fn opacity5(&self) -> &f32;
    fn opacity5_mut(&mut self) -> &mut f32;
    fn distortion_scale5(&self) -> &f32;
    fn distortion_scale5_mut(&mut self) -> &mut f32;
    fn source_pos5(&self) -> &super::core::Vec3;
    fn source_pos5_mut(&mut self) -> &mut super::core::Vec3;
    fn target_pos5(&self) -> &super::core::Vec3;
    fn target_pos5_mut(&mut self) -> &mut super::core::Vec3;
    fn source_radius5(&self) -> &f32;
    fn source_radius5_mut(&mut self) -> &mut f32;
    fn target_radius5(&self) -> &f32;
    fn target_radius5_mut(&mut self) -> &mut f32;
    fn field_flag_override0(&self) -> &u32;
    fn field_flag_override0_mut(&mut self) -> &mut u32;
    fn field_flag_override1(&self) -> &u32;
    fn field_flag_override1_mut(&mut self) -> &mut u32;
}

impl HologramParamsComponentDataTrait for HologramParamsComponentData {
    fn enable(&self) -> &bool {
        &self.enable
    }
    fn enable_mut(&mut self) -> &mut bool {
        &mut self.enable
    }
    fn render_mode(&self) -> &super::world_base::HologramRenderMode {
        &self.render_mode
    }
    fn render_mode_mut(&mut self) -> &mut super::world_base::HologramRenderMode {
        &mut self.render_mode
    }
    fn key_illuminance(&self) -> &super::core::Vec3 {
        &self.key_illuminance
    }
    fn key_illuminance_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.key_illuminance
    }
    fn key_light_dir(&self) -> &super::core::Vec3 {
        &self.key_light_dir
    }
    fn key_light_dir_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.key_light_dir
    }
    fn resolution_scale(&self) -> &f32 {
        &self.resolution_scale
    }
    fn resolution_scale_mut(&mut self) -> &mut f32 {
        &mut self.resolution_scale
    }
    fn color1(&self) -> &super::core::Vec3 {
        &self.color1
    }
    fn color1_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.color1
    }
    fn color2(&self) -> &super::core::Vec3 {
        &self.color2
    }
    fn color2_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.color2
    }
    fn color3(&self) -> &super::core::Vec3 {
        &self.color3
    }
    fn color3_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.color3
    }
    fn color4(&self) -> &super::core::Vec3 {
        &self.color4
    }
    fn color4_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.color4
    }
    fn color5(&self) -> &super::core::Vec3 {
        &self.color5
    }
    fn color5_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.color5
    }
    fn float1(&self) -> &f32 {
        &self.float1
    }
    fn float1_mut(&mut self) -> &mut f32 {
        &mut self.float1
    }
    fn float2(&self) -> &f32 {
        &self.float2
    }
    fn float2_mut(&mut self) -> &mut f32 {
        &mut self.float2
    }
    fn float3(&self) -> &f32 {
        &self.float3
    }
    fn float3_mut(&mut self) -> &mut f32 {
        &mut self.float3
    }
    fn float4(&self) -> &f32 {
        &self.float4
    }
    fn float4_mut(&mut self) -> &mut f32 {
        &mut self.float4
    }
    fn float5(&self) -> &f32 {
        &self.float5
    }
    fn float5_mut(&mut self) -> &mut f32 {
        &mut self.float5
    }
    fn float6(&self) -> &f32 {
        &self.float6
    }
    fn float6_mut(&mut self) -> &mut f32 {
        &mut self.float6
    }
    fn float7(&self) -> &f32 {
        &self.float7
    }
    fn float7_mut(&mut self) -> &mut f32 {
        &mut self.float7
    }
    fn float8(&self) -> &f32 {
        &self.float8
    }
    fn float8_mut(&mut self) -> &mut f32 {
        &mut self.float8
    }
    fn float9(&self) -> &f32 {
        &self.float9
    }
    fn float9_mut(&mut self) -> &mut f32 {
        &mut self.float9
    }
    fn brightness2(&self) -> &f32 {
        &self.brightness2
    }
    fn brightness2_mut(&mut self) -> &mut f32 {
        &mut self.brightness2
    }
    fn brightness3(&self) -> &f32 {
        &self.brightness3
    }
    fn brightness3_mut(&mut self) -> &mut f32 {
        &mut self.brightness3
    }
    fn brightness4(&self) -> &f32 {
        &self.brightness4
    }
    fn brightness4_mut(&mut self) -> &mut f32 {
        &mut self.brightness4
    }
    fn brightness5(&self) -> &f32 {
        &self.brightness5
    }
    fn brightness5_mut(&mut self) -> &mut f32 {
        &mut self.brightness5
    }
    fn streaks_enabled(&self) -> &bool {
        &self.streaks_enabled
    }
    fn streaks_enabled_mut(&mut self) -> &mut bool {
        &mut self.streaks_enabled
    }
    fn time_offset(&self) -> &f32 {
        &self.time_offset
    }
    fn time_offset_mut(&mut self) -> &mut f32 {
        &mut self.time_offset
    }
    fn opacity1(&self) -> &f32 {
        &self.opacity1
    }
    fn opacity1_mut(&mut self) -> &mut f32 {
        &mut self.opacity1
    }
    fn distortion_scale1(&self) -> &f32 {
        &self.distortion_scale1
    }
    fn distortion_scale1_mut(&mut self) -> &mut f32 {
        &mut self.distortion_scale1
    }
    fn source_pos1(&self) -> &super::core::Vec3 {
        &self.source_pos1
    }
    fn source_pos1_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.source_pos1
    }
    fn target_pos1(&self) -> &super::core::Vec3 {
        &self.target_pos1
    }
    fn target_pos1_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.target_pos1
    }
    fn source_radius1(&self) -> &f32 {
        &self.source_radius1
    }
    fn source_radius1_mut(&mut self) -> &mut f32 {
        &mut self.source_radius1
    }
    fn target_radius1(&self) -> &f32 {
        &self.target_radius1
    }
    fn target_radius1_mut(&mut self) -> &mut f32 {
        &mut self.target_radius1
    }
    fn opacity2(&self) -> &f32 {
        &self.opacity2
    }
    fn opacity2_mut(&mut self) -> &mut f32 {
        &mut self.opacity2
    }
    fn distortion_scale2(&self) -> &f32 {
        &self.distortion_scale2
    }
    fn distortion_scale2_mut(&mut self) -> &mut f32 {
        &mut self.distortion_scale2
    }
    fn source_pos2(&self) -> &super::core::Vec3 {
        &self.source_pos2
    }
    fn source_pos2_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.source_pos2
    }
    fn target_pos2(&self) -> &super::core::Vec3 {
        &self.target_pos2
    }
    fn target_pos2_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.target_pos2
    }
    fn source_radius2(&self) -> &f32 {
        &self.source_radius2
    }
    fn source_radius2_mut(&mut self) -> &mut f32 {
        &mut self.source_radius2
    }
    fn target_radius2(&self) -> &f32 {
        &self.target_radius2
    }
    fn target_radius2_mut(&mut self) -> &mut f32 {
        &mut self.target_radius2
    }
    fn opacity3(&self) -> &f32 {
        &self.opacity3
    }
    fn opacity3_mut(&mut self) -> &mut f32 {
        &mut self.opacity3
    }
    fn distortion_scale3(&self) -> &f32 {
        &self.distortion_scale3
    }
    fn distortion_scale3_mut(&mut self) -> &mut f32 {
        &mut self.distortion_scale3
    }
    fn source_pos3(&self) -> &super::core::Vec3 {
        &self.source_pos3
    }
    fn source_pos3_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.source_pos3
    }
    fn target_pos3(&self) -> &super::core::Vec3 {
        &self.target_pos3
    }
    fn target_pos3_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.target_pos3
    }
    fn source_radius3(&self) -> &f32 {
        &self.source_radius3
    }
    fn source_radius3_mut(&mut self) -> &mut f32 {
        &mut self.source_radius3
    }
    fn target_radius3(&self) -> &f32 {
        &self.target_radius3
    }
    fn target_radius3_mut(&mut self) -> &mut f32 {
        &mut self.target_radius3
    }
    fn opacity4(&self) -> &f32 {
        &self.opacity4
    }
    fn opacity4_mut(&mut self) -> &mut f32 {
        &mut self.opacity4
    }
    fn distortion_scale4(&self) -> &f32 {
        &self.distortion_scale4
    }
    fn distortion_scale4_mut(&mut self) -> &mut f32 {
        &mut self.distortion_scale4
    }
    fn source_pos4(&self) -> &super::core::Vec3 {
        &self.source_pos4
    }
    fn source_pos4_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.source_pos4
    }
    fn target_pos4(&self) -> &super::core::Vec3 {
        &self.target_pos4
    }
    fn target_pos4_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.target_pos4
    }
    fn source_radius4(&self) -> &f32 {
        &self.source_radius4
    }
    fn source_radius4_mut(&mut self) -> &mut f32 {
        &mut self.source_radius4
    }
    fn target_radius4(&self) -> &f32 {
        &self.target_radius4
    }
    fn target_radius4_mut(&mut self) -> &mut f32 {
        &mut self.target_radius4
    }
    fn opacity5(&self) -> &f32 {
        &self.opacity5
    }
    fn opacity5_mut(&mut self) -> &mut f32 {
        &mut self.opacity5
    }
    fn distortion_scale5(&self) -> &f32 {
        &self.distortion_scale5
    }
    fn distortion_scale5_mut(&mut self) -> &mut f32 {
        &mut self.distortion_scale5
    }
    fn source_pos5(&self) -> &super::core::Vec3 {
        &self.source_pos5
    }
    fn source_pos5_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.source_pos5
    }
    fn target_pos5(&self) -> &super::core::Vec3 {
        &self.target_pos5
    }
    fn target_pos5_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.target_pos5
    }
    fn source_radius5(&self) -> &f32 {
        &self.source_radius5
    }
    fn source_radius5_mut(&mut self) -> &mut f32 {
        &mut self.source_radius5
    }
    fn target_radius5(&self) -> &f32 {
        &self.target_radius5
    }
    fn target_radius5_mut(&mut self) -> &mut f32 {
        &mut self.target_radius5
    }
    fn field_flag_override0(&self) -> &u32 {
        &self.field_flag_override0
    }
    fn field_flag_override0_mut(&mut self) -> &mut u32 {
        &mut self.field_flag_override0
    }
    fn field_flag_override1(&self) -> &u32 {
        &self.field_flag_override1
    }
    fn field_flag_override1_mut(&mut self) -> &mut u32 {
        &mut self.field_flag_override1
    }
}

impl VisualEnvironmentComponentDataTrait for HologramParamsComponentData {
    fn property_overrides(&self) -> &Vec<String> {
        self._glacier_base.property_overrides()
    }
    fn property_overrides_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.property_overrides_mut()
    }
}

impl super::entity::ComponentDataTrait for HologramParamsComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for HologramParamsComponentData {
}

impl super::core::DataBusPeerTrait for HologramParamsComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for HologramParamsComponentData {
}

impl super::core::DataContainerTrait for HologramParamsComponentData {
}

pub static HOLOGRAMPARAMSCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HologramParamsComponentData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VISUALENVIRONMENTCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<HologramParamsComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(HologramParamsComponentData, enable),
            },
            FieldInfoData {
                name: "RenderMode",
                flags: MemberInfoFlags::new(0),
                field_type: "HologramRenderMode",
                rust_offset: offset_of!(HologramParamsComponentData, render_mode),
            },
            FieldInfoData {
                name: "KeyIlluminance",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(HologramParamsComponentData, key_illuminance),
            },
            FieldInfoData {
                name: "KeyLightDir",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(HologramParamsComponentData, key_light_dir),
            },
            FieldInfoData {
                name: "ResolutionScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HologramParamsComponentData, resolution_scale),
            },
            FieldInfoData {
                name: "Color1",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(HologramParamsComponentData, color1),
            },
            FieldInfoData {
                name: "Color2",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(HologramParamsComponentData, color2),
            },
            FieldInfoData {
                name: "Color3",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(HologramParamsComponentData, color3),
            },
            FieldInfoData {
                name: "Color4",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(HologramParamsComponentData, color4),
            },
            FieldInfoData {
                name: "Color5",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(HologramParamsComponentData, color5),
            },
            FieldInfoData {
                name: "Float1",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HologramParamsComponentData, float1),
            },
            FieldInfoData {
                name: "Float2",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HologramParamsComponentData, float2),
            },
            FieldInfoData {
                name: "Float3",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HologramParamsComponentData, float3),
            },
            FieldInfoData {
                name: "Float4",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HologramParamsComponentData, float4),
            },
            FieldInfoData {
                name: "Float5",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HologramParamsComponentData, float5),
            },
            FieldInfoData {
                name: "Float6",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HologramParamsComponentData, float6),
            },
            FieldInfoData {
                name: "Float7",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HologramParamsComponentData, float7),
            },
            FieldInfoData {
                name: "Float8",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HologramParamsComponentData, float8),
            },
            FieldInfoData {
                name: "Float9",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HologramParamsComponentData, float9),
            },
            FieldInfoData {
                name: "Brightness2",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HologramParamsComponentData, brightness2),
            },
            FieldInfoData {
                name: "Brightness3",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HologramParamsComponentData, brightness3),
            },
            FieldInfoData {
                name: "Brightness4",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HologramParamsComponentData, brightness4),
            },
            FieldInfoData {
                name: "Brightness5",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HologramParamsComponentData, brightness5),
            },
            FieldInfoData {
                name: "StreaksEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(HologramParamsComponentData, streaks_enabled),
            },
            FieldInfoData {
                name: "TimeOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HologramParamsComponentData, time_offset),
            },
            FieldInfoData {
                name: "Opacity1",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HologramParamsComponentData, opacity1),
            },
            FieldInfoData {
                name: "DistortionScale1",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HologramParamsComponentData, distortion_scale1),
            },
            FieldInfoData {
                name: "SourcePos1",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(HologramParamsComponentData, source_pos1),
            },
            FieldInfoData {
                name: "TargetPos1",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(HologramParamsComponentData, target_pos1),
            },
            FieldInfoData {
                name: "SourceRadius1",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HologramParamsComponentData, source_radius1),
            },
            FieldInfoData {
                name: "TargetRadius1",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HologramParamsComponentData, target_radius1),
            },
            FieldInfoData {
                name: "Opacity2",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HologramParamsComponentData, opacity2),
            },
            FieldInfoData {
                name: "DistortionScale2",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HologramParamsComponentData, distortion_scale2),
            },
            FieldInfoData {
                name: "SourcePos2",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(HologramParamsComponentData, source_pos2),
            },
            FieldInfoData {
                name: "TargetPos2",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(HologramParamsComponentData, target_pos2),
            },
            FieldInfoData {
                name: "SourceRadius2",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HologramParamsComponentData, source_radius2),
            },
            FieldInfoData {
                name: "TargetRadius2",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HologramParamsComponentData, target_radius2),
            },
            FieldInfoData {
                name: "Opacity3",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HologramParamsComponentData, opacity3),
            },
            FieldInfoData {
                name: "DistortionScale3",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HologramParamsComponentData, distortion_scale3),
            },
            FieldInfoData {
                name: "SourcePos3",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(HologramParamsComponentData, source_pos3),
            },
            FieldInfoData {
                name: "TargetPos3",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(HologramParamsComponentData, target_pos3),
            },
            FieldInfoData {
                name: "SourceRadius3",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HologramParamsComponentData, source_radius3),
            },
            FieldInfoData {
                name: "TargetRadius3",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HologramParamsComponentData, target_radius3),
            },
            FieldInfoData {
                name: "Opacity4",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HologramParamsComponentData, opacity4),
            },
            FieldInfoData {
                name: "DistortionScale4",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HologramParamsComponentData, distortion_scale4),
            },
            FieldInfoData {
                name: "SourcePos4",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(HologramParamsComponentData, source_pos4),
            },
            FieldInfoData {
                name: "TargetPos4",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(HologramParamsComponentData, target_pos4),
            },
            FieldInfoData {
                name: "SourceRadius4",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HologramParamsComponentData, source_radius4),
            },
            FieldInfoData {
                name: "TargetRadius4",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HologramParamsComponentData, target_radius4),
            },
            FieldInfoData {
                name: "Opacity5",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HologramParamsComponentData, opacity5),
            },
            FieldInfoData {
                name: "DistortionScale5",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HologramParamsComponentData, distortion_scale5),
            },
            FieldInfoData {
                name: "SourcePos5",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(HologramParamsComponentData, source_pos5),
            },
            FieldInfoData {
                name: "TargetPos5",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(HologramParamsComponentData, target_pos5),
            },
            FieldInfoData {
                name: "SourceRadius5",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HologramParamsComponentData, source_radius5),
            },
            FieldInfoData {
                name: "TargetRadius5",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HologramParamsComponentData, target_radius5),
            },
            FieldInfoData {
                name: "FieldFlagOverride0",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(HologramParamsComponentData, field_flag_override0),
            },
            FieldInfoData {
                name: "FieldFlagOverride1",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(HologramParamsComponentData, field_flag_override1),
            },
        ],
    }),
    array_type: Some(HOLOGRAMPARAMSCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for HologramParamsComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        HOLOGRAMPARAMSCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static HOLOGRAMPARAMSCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HologramParamsComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("HologramParamsComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ThreatAlertHighlightParamsComponentData {
    pub _glacier_base: VisualEnvironmentComponentData,
    pub enable: bool,
    pub color1: super::core::Vec3,
    pub color2: super::core::Vec3,
    pub color3: super::core::Vec3,
    pub color4: super::core::Vec3,
    pub color5: super::core::Vec3,
    pub use_outline: bool,
    pub outline_opacity: f32,
    pub use_scan_lines: bool,
    pub scan_line_offset: i32,
    pub scan_line_opacity: f32,
    pub scan_line_thickness: i32,
    pub scan_line_spacing: i32,
    pub use_horizontal_scan_lines: bool,
    pub use_alt_lines: bool,
    pub alt_line_offset: i32,
    pub alt_line_opacity: f32,
    pub alt_line_thickness: i32,
    pub alt_line_spacing: i32,
    pub use_horizontal_alt_lines: bool,
    pub field_flag_override0: u32,
}

pub trait ThreatAlertHighlightParamsComponentDataTrait: VisualEnvironmentComponentDataTrait {
    fn enable(&self) -> &bool;
    fn enable_mut(&mut self) -> &mut bool;
    fn color1(&self) -> &super::core::Vec3;
    fn color1_mut(&mut self) -> &mut super::core::Vec3;
    fn color2(&self) -> &super::core::Vec3;
    fn color2_mut(&mut self) -> &mut super::core::Vec3;
    fn color3(&self) -> &super::core::Vec3;
    fn color3_mut(&mut self) -> &mut super::core::Vec3;
    fn color4(&self) -> &super::core::Vec3;
    fn color4_mut(&mut self) -> &mut super::core::Vec3;
    fn color5(&self) -> &super::core::Vec3;
    fn color5_mut(&mut self) -> &mut super::core::Vec3;
    fn use_outline(&self) -> &bool;
    fn use_outline_mut(&mut self) -> &mut bool;
    fn outline_opacity(&self) -> &f32;
    fn outline_opacity_mut(&mut self) -> &mut f32;
    fn use_scan_lines(&self) -> &bool;
    fn use_scan_lines_mut(&mut self) -> &mut bool;
    fn scan_line_offset(&self) -> &i32;
    fn scan_line_offset_mut(&mut self) -> &mut i32;
    fn scan_line_opacity(&self) -> &f32;
    fn scan_line_opacity_mut(&mut self) -> &mut f32;
    fn scan_line_thickness(&self) -> &i32;
    fn scan_line_thickness_mut(&mut self) -> &mut i32;
    fn scan_line_spacing(&self) -> &i32;
    fn scan_line_spacing_mut(&mut self) -> &mut i32;
    fn use_horizontal_scan_lines(&self) -> &bool;
    fn use_horizontal_scan_lines_mut(&mut self) -> &mut bool;
    fn use_alt_lines(&self) -> &bool;
    fn use_alt_lines_mut(&mut self) -> &mut bool;
    fn alt_line_offset(&self) -> &i32;
    fn alt_line_offset_mut(&mut self) -> &mut i32;
    fn alt_line_opacity(&self) -> &f32;
    fn alt_line_opacity_mut(&mut self) -> &mut f32;
    fn alt_line_thickness(&self) -> &i32;
    fn alt_line_thickness_mut(&mut self) -> &mut i32;
    fn alt_line_spacing(&self) -> &i32;
    fn alt_line_spacing_mut(&mut self) -> &mut i32;
    fn use_horizontal_alt_lines(&self) -> &bool;
    fn use_horizontal_alt_lines_mut(&mut self) -> &mut bool;
    fn field_flag_override0(&self) -> &u32;
    fn field_flag_override0_mut(&mut self) -> &mut u32;
}

impl ThreatAlertHighlightParamsComponentDataTrait for ThreatAlertHighlightParamsComponentData {
    fn enable(&self) -> &bool {
        &self.enable
    }
    fn enable_mut(&mut self) -> &mut bool {
        &mut self.enable
    }
    fn color1(&self) -> &super::core::Vec3 {
        &self.color1
    }
    fn color1_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.color1
    }
    fn color2(&self) -> &super::core::Vec3 {
        &self.color2
    }
    fn color2_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.color2
    }
    fn color3(&self) -> &super::core::Vec3 {
        &self.color3
    }
    fn color3_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.color3
    }
    fn color4(&self) -> &super::core::Vec3 {
        &self.color4
    }
    fn color4_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.color4
    }
    fn color5(&self) -> &super::core::Vec3 {
        &self.color5
    }
    fn color5_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.color5
    }
    fn use_outline(&self) -> &bool {
        &self.use_outline
    }
    fn use_outline_mut(&mut self) -> &mut bool {
        &mut self.use_outline
    }
    fn outline_opacity(&self) -> &f32 {
        &self.outline_opacity
    }
    fn outline_opacity_mut(&mut self) -> &mut f32 {
        &mut self.outline_opacity
    }
    fn use_scan_lines(&self) -> &bool {
        &self.use_scan_lines
    }
    fn use_scan_lines_mut(&mut self) -> &mut bool {
        &mut self.use_scan_lines
    }
    fn scan_line_offset(&self) -> &i32 {
        &self.scan_line_offset
    }
    fn scan_line_offset_mut(&mut self) -> &mut i32 {
        &mut self.scan_line_offset
    }
    fn scan_line_opacity(&self) -> &f32 {
        &self.scan_line_opacity
    }
    fn scan_line_opacity_mut(&mut self) -> &mut f32 {
        &mut self.scan_line_opacity
    }
    fn scan_line_thickness(&self) -> &i32 {
        &self.scan_line_thickness
    }
    fn scan_line_thickness_mut(&mut self) -> &mut i32 {
        &mut self.scan_line_thickness
    }
    fn scan_line_spacing(&self) -> &i32 {
        &self.scan_line_spacing
    }
    fn scan_line_spacing_mut(&mut self) -> &mut i32 {
        &mut self.scan_line_spacing
    }
    fn use_horizontal_scan_lines(&self) -> &bool {
        &self.use_horizontal_scan_lines
    }
    fn use_horizontal_scan_lines_mut(&mut self) -> &mut bool {
        &mut self.use_horizontal_scan_lines
    }
    fn use_alt_lines(&self) -> &bool {
        &self.use_alt_lines
    }
    fn use_alt_lines_mut(&mut self) -> &mut bool {
        &mut self.use_alt_lines
    }
    fn alt_line_offset(&self) -> &i32 {
        &self.alt_line_offset
    }
    fn alt_line_offset_mut(&mut self) -> &mut i32 {
        &mut self.alt_line_offset
    }
    fn alt_line_opacity(&self) -> &f32 {
        &self.alt_line_opacity
    }
    fn alt_line_opacity_mut(&mut self) -> &mut f32 {
        &mut self.alt_line_opacity
    }
    fn alt_line_thickness(&self) -> &i32 {
        &self.alt_line_thickness
    }
    fn alt_line_thickness_mut(&mut self) -> &mut i32 {
        &mut self.alt_line_thickness
    }
    fn alt_line_spacing(&self) -> &i32 {
        &self.alt_line_spacing
    }
    fn alt_line_spacing_mut(&mut self) -> &mut i32 {
        &mut self.alt_line_spacing
    }
    fn use_horizontal_alt_lines(&self) -> &bool {
        &self.use_horizontal_alt_lines
    }
    fn use_horizontal_alt_lines_mut(&mut self) -> &mut bool {
        &mut self.use_horizontal_alt_lines
    }
    fn field_flag_override0(&self) -> &u32 {
        &self.field_flag_override0
    }
    fn field_flag_override0_mut(&mut self) -> &mut u32 {
        &mut self.field_flag_override0
    }
}

impl VisualEnvironmentComponentDataTrait for ThreatAlertHighlightParamsComponentData {
    fn property_overrides(&self) -> &Vec<String> {
        self._glacier_base.property_overrides()
    }
    fn property_overrides_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.property_overrides_mut()
    }
}

impl super::entity::ComponentDataTrait for ThreatAlertHighlightParamsComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for ThreatAlertHighlightParamsComponentData {
}

impl super::core::DataBusPeerTrait for ThreatAlertHighlightParamsComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ThreatAlertHighlightParamsComponentData {
}

impl super::core::DataContainerTrait for ThreatAlertHighlightParamsComponentData {
}

pub static THREATALERTHIGHLIGHTPARAMSCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ThreatAlertHighlightParamsComponentData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VISUALENVIRONMENTCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ThreatAlertHighlightParamsComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ThreatAlertHighlightParamsComponentData, enable),
            },
            FieldInfoData {
                name: "Color1",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(ThreatAlertHighlightParamsComponentData, color1),
            },
            FieldInfoData {
                name: "Color2",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(ThreatAlertHighlightParamsComponentData, color2),
            },
            FieldInfoData {
                name: "Color3",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(ThreatAlertHighlightParamsComponentData, color3),
            },
            FieldInfoData {
                name: "Color4",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(ThreatAlertHighlightParamsComponentData, color4),
            },
            FieldInfoData {
                name: "Color5",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(ThreatAlertHighlightParamsComponentData, color5),
            },
            FieldInfoData {
                name: "UseOutline",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ThreatAlertHighlightParamsComponentData, use_outline),
            },
            FieldInfoData {
                name: "OutlineOpacity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ThreatAlertHighlightParamsComponentData, outline_opacity),
            },
            FieldInfoData {
                name: "UseScanLines",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ThreatAlertHighlightParamsComponentData, use_scan_lines),
            },
            FieldInfoData {
                name: "ScanLineOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ThreatAlertHighlightParamsComponentData, scan_line_offset),
            },
            FieldInfoData {
                name: "ScanLineOpacity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ThreatAlertHighlightParamsComponentData, scan_line_opacity),
            },
            FieldInfoData {
                name: "ScanLineThickness",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ThreatAlertHighlightParamsComponentData, scan_line_thickness),
            },
            FieldInfoData {
                name: "ScanLineSpacing",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ThreatAlertHighlightParamsComponentData, scan_line_spacing),
            },
            FieldInfoData {
                name: "UseHorizontalScanLines",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ThreatAlertHighlightParamsComponentData, use_horizontal_scan_lines),
            },
            FieldInfoData {
                name: "UseAltLines",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ThreatAlertHighlightParamsComponentData, use_alt_lines),
            },
            FieldInfoData {
                name: "AltLineOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ThreatAlertHighlightParamsComponentData, alt_line_offset),
            },
            FieldInfoData {
                name: "AltLineOpacity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ThreatAlertHighlightParamsComponentData, alt_line_opacity),
            },
            FieldInfoData {
                name: "AltLineThickness",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ThreatAlertHighlightParamsComponentData, alt_line_thickness),
            },
            FieldInfoData {
                name: "AltLineSpacing",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ThreatAlertHighlightParamsComponentData, alt_line_spacing),
            },
            FieldInfoData {
                name: "UseHorizontalAltLines",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ThreatAlertHighlightParamsComponentData, use_horizontal_alt_lines),
            },
            FieldInfoData {
                name: "FieldFlagOverride0",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(ThreatAlertHighlightParamsComponentData, field_flag_override0),
            },
        ],
    }),
    array_type: Some(THREATALERTHIGHLIGHTPARAMSCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ThreatAlertHighlightParamsComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        THREATALERTHIGHLIGHTPARAMSCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static THREATALERTHIGHLIGHTPARAMSCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ThreatAlertHighlightParamsComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("ThreatAlertHighlightParamsComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ObjectHighlightParamsComponentData {
    pub _glacier_base: VisualEnvironmentComponentData,
    pub enable: bool,
    pub brightness: f32,
    pub color1: super::core::Vec3,
    pub color1_alpha: f32,
    pub color2: super::core::Vec3,
    pub color2_alpha: f32,
    pub color3: super::core::Vec3,
    pub color3_alpha: f32,
    pub color4: super::core::Vec3,
    pub color4_alpha: f32,
    pub field_flag_override0: u16,
}

pub trait ObjectHighlightParamsComponentDataTrait: VisualEnvironmentComponentDataTrait {
    fn enable(&self) -> &bool;
    fn enable_mut(&mut self) -> &mut bool;
    fn brightness(&self) -> &f32;
    fn brightness_mut(&mut self) -> &mut f32;
    fn color1(&self) -> &super::core::Vec3;
    fn color1_mut(&mut self) -> &mut super::core::Vec3;
    fn color1_alpha(&self) -> &f32;
    fn color1_alpha_mut(&mut self) -> &mut f32;
    fn color2(&self) -> &super::core::Vec3;
    fn color2_mut(&mut self) -> &mut super::core::Vec3;
    fn color2_alpha(&self) -> &f32;
    fn color2_alpha_mut(&mut self) -> &mut f32;
    fn color3(&self) -> &super::core::Vec3;
    fn color3_mut(&mut self) -> &mut super::core::Vec3;
    fn color3_alpha(&self) -> &f32;
    fn color3_alpha_mut(&mut self) -> &mut f32;
    fn color4(&self) -> &super::core::Vec3;
    fn color4_mut(&mut self) -> &mut super::core::Vec3;
    fn color4_alpha(&self) -> &f32;
    fn color4_alpha_mut(&mut self) -> &mut f32;
    fn field_flag_override0(&self) -> &u16;
    fn field_flag_override0_mut(&mut self) -> &mut u16;
}

impl ObjectHighlightParamsComponentDataTrait for ObjectHighlightParamsComponentData {
    fn enable(&self) -> &bool {
        &self.enable
    }
    fn enable_mut(&mut self) -> &mut bool {
        &mut self.enable
    }
    fn brightness(&self) -> &f32 {
        &self.brightness
    }
    fn brightness_mut(&mut self) -> &mut f32 {
        &mut self.brightness
    }
    fn color1(&self) -> &super::core::Vec3 {
        &self.color1
    }
    fn color1_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.color1
    }
    fn color1_alpha(&self) -> &f32 {
        &self.color1_alpha
    }
    fn color1_alpha_mut(&mut self) -> &mut f32 {
        &mut self.color1_alpha
    }
    fn color2(&self) -> &super::core::Vec3 {
        &self.color2
    }
    fn color2_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.color2
    }
    fn color2_alpha(&self) -> &f32 {
        &self.color2_alpha
    }
    fn color2_alpha_mut(&mut self) -> &mut f32 {
        &mut self.color2_alpha
    }
    fn color3(&self) -> &super::core::Vec3 {
        &self.color3
    }
    fn color3_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.color3
    }
    fn color3_alpha(&self) -> &f32 {
        &self.color3_alpha
    }
    fn color3_alpha_mut(&mut self) -> &mut f32 {
        &mut self.color3_alpha
    }
    fn color4(&self) -> &super::core::Vec3 {
        &self.color4
    }
    fn color4_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.color4
    }
    fn color4_alpha(&self) -> &f32 {
        &self.color4_alpha
    }
    fn color4_alpha_mut(&mut self) -> &mut f32 {
        &mut self.color4_alpha
    }
    fn field_flag_override0(&self) -> &u16 {
        &self.field_flag_override0
    }
    fn field_flag_override0_mut(&mut self) -> &mut u16 {
        &mut self.field_flag_override0
    }
}

impl VisualEnvironmentComponentDataTrait for ObjectHighlightParamsComponentData {
    fn property_overrides(&self) -> &Vec<String> {
        self._glacier_base.property_overrides()
    }
    fn property_overrides_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.property_overrides_mut()
    }
}

impl super::entity::ComponentDataTrait for ObjectHighlightParamsComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for ObjectHighlightParamsComponentData {
}

impl super::core::DataBusPeerTrait for ObjectHighlightParamsComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ObjectHighlightParamsComponentData {
}

impl super::core::DataContainerTrait for ObjectHighlightParamsComponentData {
}

pub static OBJECTHIGHLIGHTPARAMSCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectHighlightParamsComponentData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VISUALENVIRONMENTCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ObjectHighlightParamsComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ObjectHighlightParamsComponentData, enable),
            },
            FieldInfoData {
                name: "Brightness",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ObjectHighlightParamsComponentData, brightness),
            },
            FieldInfoData {
                name: "Color1",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(ObjectHighlightParamsComponentData, color1),
            },
            FieldInfoData {
                name: "Color1Alpha",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ObjectHighlightParamsComponentData, color1_alpha),
            },
            FieldInfoData {
                name: "Color2",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(ObjectHighlightParamsComponentData, color2),
            },
            FieldInfoData {
                name: "Color2Alpha",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ObjectHighlightParamsComponentData, color2_alpha),
            },
            FieldInfoData {
                name: "Color3",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(ObjectHighlightParamsComponentData, color3),
            },
            FieldInfoData {
                name: "Color3Alpha",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ObjectHighlightParamsComponentData, color3_alpha),
            },
            FieldInfoData {
                name: "Color4",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(ObjectHighlightParamsComponentData, color4),
            },
            FieldInfoData {
                name: "Color4Alpha",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ObjectHighlightParamsComponentData, color4_alpha),
            },
            FieldInfoData {
                name: "FieldFlagOverride0",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint16",
                rust_offset: offset_of!(ObjectHighlightParamsComponentData, field_flag_override0),
            },
        ],
    }),
    array_type: Some(OBJECTHIGHLIGHTPARAMSCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ObjectHighlightParamsComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        OBJECTHIGHLIGHTPARAMSCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static OBJECTHIGHLIGHTPARAMSCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectHighlightParamsComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("ObjectHighlightParamsComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FilmicEffectsComponentData {
    pub _glacier_base: VisualEnvironmentComponentData,
    pub enable: bool,
    pub enable_chromatic_abberation: bool,
    pub chromatic_abberation_scale: f32,
    pub chromatic_abberation_aspect_ratio: f32,
    pub enable_vignetting: bool,
    pub vignetting_falloff: f32,
    pub vignetting_luminance_percent: f32,
    pub enable_lens_distortion: bool,
    pub lens_distortion_gain: f32,
    pub lens_distortion_cubic_gain: f32,
    pub lens_distortion_stretch: f32,
    pub enable_frame_flash: bool,
    pub frame_flash_gain: f32,
    pub enable_depth_flash: bool,
    pub depth_flash_atmos_color: super::core::Vec3,
    pub depth_flash_half_distance: f32,
    pub enable_distance_blur: bool,
    pub distance_blur_gain: f32,
    pub distance_blur_half_distance: f32,
    pub enable_edge_blur: bool,
    pub edge_blur_gain: f32,
    pub edge_blur_depth_target_scale: f32,
    pub edge_blur_fade_near_depth: f32,
    pub edge_blur_fade_far_depth: f32,
    pub edge_blur_matte_dilate_size: f32,
    pub edge_blur_matte_blur_kernel_size: f32,
    pub enable_heat_ripple: bool,
    pub heat_ripple_gain: f32,
    pub heat_ripple_horizontal_speed: f32,
    pub heat_ripple_vertical_speed: f32,
    pub heat_ripple_noise_scale: f32,
    pub heat_ripple_near_distance: f32,
    pub heat_ripple_far_distance: f32,
    pub heat_ripple_near_gain: f32,
    pub heat_ripple_far_gain: f32,
    pub heat_ripple_texture: Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>,
    pub field_flag_override0: u32,
    pub field_flag_override1: u8,
}

pub trait FilmicEffectsComponentDataTrait: VisualEnvironmentComponentDataTrait {
    fn enable(&self) -> &bool;
    fn enable_mut(&mut self) -> &mut bool;
    fn enable_chromatic_abberation(&self) -> &bool;
    fn enable_chromatic_abberation_mut(&mut self) -> &mut bool;
    fn chromatic_abberation_scale(&self) -> &f32;
    fn chromatic_abberation_scale_mut(&mut self) -> &mut f32;
    fn chromatic_abberation_aspect_ratio(&self) -> &f32;
    fn chromatic_abberation_aspect_ratio_mut(&mut self) -> &mut f32;
    fn enable_vignetting(&self) -> &bool;
    fn enable_vignetting_mut(&mut self) -> &mut bool;
    fn vignetting_falloff(&self) -> &f32;
    fn vignetting_falloff_mut(&mut self) -> &mut f32;
    fn vignetting_luminance_percent(&self) -> &f32;
    fn vignetting_luminance_percent_mut(&mut self) -> &mut f32;
    fn enable_lens_distortion(&self) -> &bool;
    fn enable_lens_distortion_mut(&mut self) -> &mut bool;
    fn lens_distortion_gain(&self) -> &f32;
    fn lens_distortion_gain_mut(&mut self) -> &mut f32;
    fn lens_distortion_cubic_gain(&self) -> &f32;
    fn lens_distortion_cubic_gain_mut(&mut self) -> &mut f32;
    fn lens_distortion_stretch(&self) -> &f32;
    fn lens_distortion_stretch_mut(&mut self) -> &mut f32;
    fn enable_frame_flash(&self) -> &bool;
    fn enable_frame_flash_mut(&mut self) -> &mut bool;
    fn frame_flash_gain(&self) -> &f32;
    fn frame_flash_gain_mut(&mut self) -> &mut f32;
    fn enable_depth_flash(&self) -> &bool;
    fn enable_depth_flash_mut(&mut self) -> &mut bool;
    fn depth_flash_atmos_color(&self) -> &super::core::Vec3;
    fn depth_flash_atmos_color_mut(&mut self) -> &mut super::core::Vec3;
    fn depth_flash_half_distance(&self) -> &f32;
    fn depth_flash_half_distance_mut(&mut self) -> &mut f32;
    fn enable_distance_blur(&self) -> &bool;
    fn enable_distance_blur_mut(&mut self) -> &mut bool;
    fn distance_blur_gain(&self) -> &f32;
    fn distance_blur_gain_mut(&mut self) -> &mut f32;
    fn distance_blur_half_distance(&self) -> &f32;
    fn distance_blur_half_distance_mut(&mut self) -> &mut f32;
    fn enable_edge_blur(&self) -> &bool;
    fn enable_edge_blur_mut(&mut self) -> &mut bool;
    fn edge_blur_gain(&self) -> &f32;
    fn edge_blur_gain_mut(&mut self) -> &mut f32;
    fn edge_blur_depth_target_scale(&self) -> &f32;
    fn edge_blur_depth_target_scale_mut(&mut self) -> &mut f32;
    fn edge_blur_fade_near_depth(&self) -> &f32;
    fn edge_blur_fade_near_depth_mut(&mut self) -> &mut f32;
    fn edge_blur_fade_far_depth(&self) -> &f32;
    fn edge_blur_fade_far_depth_mut(&mut self) -> &mut f32;
    fn edge_blur_matte_dilate_size(&self) -> &f32;
    fn edge_blur_matte_dilate_size_mut(&mut self) -> &mut f32;
    fn edge_blur_matte_blur_kernel_size(&self) -> &f32;
    fn edge_blur_matte_blur_kernel_size_mut(&mut self) -> &mut f32;
    fn enable_heat_ripple(&self) -> &bool;
    fn enable_heat_ripple_mut(&mut self) -> &mut bool;
    fn heat_ripple_gain(&self) -> &f32;
    fn heat_ripple_gain_mut(&mut self) -> &mut f32;
    fn heat_ripple_horizontal_speed(&self) -> &f32;
    fn heat_ripple_horizontal_speed_mut(&mut self) -> &mut f32;
    fn heat_ripple_vertical_speed(&self) -> &f32;
    fn heat_ripple_vertical_speed_mut(&mut self) -> &mut f32;
    fn heat_ripple_noise_scale(&self) -> &f32;
    fn heat_ripple_noise_scale_mut(&mut self) -> &mut f32;
    fn heat_ripple_near_distance(&self) -> &f32;
    fn heat_ripple_near_distance_mut(&mut self) -> &mut f32;
    fn heat_ripple_far_distance(&self) -> &f32;
    fn heat_ripple_far_distance_mut(&mut self) -> &mut f32;
    fn heat_ripple_near_gain(&self) -> &f32;
    fn heat_ripple_near_gain_mut(&mut self) -> &mut f32;
    fn heat_ripple_far_gain(&self) -> &f32;
    fn heat_ripple_far_gain_mut(&mut self) -> &mut f32;
    fn heat_ripple_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn heat_ripple_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn field_flag_override0(&self) -> &u32;
    fn field_flag_override0_mut(&mut self) -> &mut u32;
    fn field_flag_override1(&self) -> &u8;
    fn field_flag_override1_mut(&mut self) -> &mut u8;
}

impl FilmicEffectsComponentDataTrait for FilmicEffectsComponentData {
    fn enable(&self) -> &bool {
        &self.enable
    }
    fn enable_mut(&mut self) -> &mut bool {
        &mut self.enable
    }
    fn enable_chromatic_abberation(&self) -> &bool {
        &self.enable_chromatic_abberation
    }
    fn enable_chromatic_abberation_mut(&mut self) -> &mut bool {
        &mut self.enable_chromatic_abberation
    }
    fn chromatic_abberation_scale(&self) -> &f32 {
        &self.chromatic_abberation_scale
    }
    fn chromatic_abberation_scale_mut(&mut self) -> &mut f32 {
        &mut self.chromatic_abberation_scale
    }
    fn chromatic_abberation_aspect_ratio(&self) -> &f32 {
        &self.chromatic_abberation_aspect_ratio
    }
    fn chromatic_abberation_aspect_ratio_mut(&mut self) -> &mut f32 {
        &mut self.chromatic_abberation_aspect_ratio
    }
    fn enable_vignetting(&self) -> &bool {
        &self.enable_vignetting
    }
    fn enable_vignetting_mut(&mut self) -> &mut bool {
        &mut self.enable_vignetting
    }
    fn vignetting_falloff(&self) -> &f32 {
        &self.vignetting_falloff
    }
    fn vignetting_falloff_mut(&mut self) -> &mut f32 {
        &mut self.vignetting_falloff
    }
    fn vignetting_luminance_percent(&self) -> &f32 {
        &self.vignetting_luminance_percent
    }
    fn vignetting_luminance_percent_mut(&mut self) -> &mut f32 {
        &mut self.vignetting_luminance_percent
    }
    fn enable_lens_distortion(&self) -> &bool {
        &self.enable_lens_distortion
    }
    fn enable_lens_distortion_mut(&mut self) -> &mut bool {
        &mut self.enable_lens_distortion
    }
    fn lens_distortion_gain(&self) -> &f32 {
        &self.lens_distortion_gain
    }
    fn lens_distortion_gain_mut(&mut self) -> &mut f32 {
        &mut self.lens_distortion_gain
    }
    fn lens_distortion_cubic_gain(&self) -> &f32 {
        &self.lens_distortion_cubic_gain
    }
    fn lens_distortion_cubic_gain_mut(&mut self) -> &mut f32 {
        &mut self.lens_distortion_cubic_gain
    }
    fn lens_distortion_stretch(&self) -> &f32 {
        &self.lens_distortion_stretch
    }
    fn lens_distortion_stretch_mut(&mut self) -> &mut f32 {
        &mut self.lens_distortion_stretch
    }
    fn enable_frame_flash(&self) -> &bool {
        &self.enable_frame_flash
    }
    fn enable_frame_flash_mut(&mut self) -> &mut bool {
        &mut self.enable_frame_flash
    }
    fn frame_flash_gain(&self) -> &f32 {
        &self.frame_flash_gain
    }
    fn frame_flash_gain_mut(&mut self) -> &mut f32 {
        &mut self.frame_flash_gain
    }
    fn enable_depth_flash(&self) -> &bool {
        &self.enable_depth_flash
    }
    fn enable_depth_flash_mut(&mut self) -> &mut bool {
        &mut self.enable_depth_flash
    }
    fn depth_flash_atmos_color(&self) -> &super::core::Vec3 {
        &self.depth_flash_atmos_color
    }
    fn depth_flash_atmos_color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.depth_flash_atmos_color
    }
    fn depth_flash_half_distance(&self) -> &f32 {
        &self.depth_flash_half_distance
    }
    fn depth_flash_half_distance_mut(&mut self) -> &mut f32 {
        &mut self.depth_flash_half_distance
    }
    fn enable_distance_blur(&self) -> &bool {
        &self.enable_distance_blur
    }
    fn enable_distance_blur_mut(&mut self) -> &mut bool {
        &mut self.enable_distance_blur
    }
    fn distance_blur_gain(&self) -> &f32 {
        &self.distance_blur_gain
    }
    fn distance_blur_gain_mut(&mut self) -> &mut f32 {
        &mut self.distance_blur_gain
    }
    fn distance_blur_half_distance(&self) -> &f32 {
        &self.distance_blur_half_distance
    }
    fn distance_blur_half_distance_mut(&mut self) -> &mut f32 {
        &mut self.distance_blur_half_distance
    }
    fn enable_edge_blur(&self) -> &bool {
        &self.enable_edge_blur
    }
    fn enable_edge_blur_mut(&mut self) -> &mut bool {
        &mut self.enable_edge_blur
    }
    fn edge_blur_gain(&self) -> &f32 {
        &self.edge_blur_gain
    }
    fn edge_blur_gain_mut(&mut self) -> &mut f32 {
        &mut self.edge_blur_gain
    }
    fn edge_blur_depth_target_scale(&self) -> &f32 {
        &self.edge_blur_depth_target_scale
    }
    fn edge_blur_depth_target_scale_mut(&mut self) -> &mut f32 {
        &mut self.edge_blur_depth_target_scale
    }
    fn edge_blur_fade_near_depth(&self) -> &f32 {
        &self.edge_blur_fade_near_depth
    }
    fn edge_blur_fade_near_depth_mut(&mut self) -> &mut f32 {
        &mut self.edge_blur_fade_near_depth
    }
    fn edge_blur_fade_far_depth(&self) -> &f32 {
        &self.edge_blur_fade_far_depth
    }
    fn edge_blur_fade_far_depth_mut(&mut self) -> &mut f32 {
        &mut self.edge_blur_fade_far_depth
    }
    fn edge_blur_matte_dilate_size(&self) -> &f32 {
        &self.edge_blur_matte_dilate_size
    }
    fn edge_blur_matte_dilate_size_mut(&mut self) -> &mut f32 {
        &mut self.edge_blur_matte_dilate_size
    }
    fn edge_blur_matte_blur_kernel_size(&self) -> &f32 {
        &self.edge_blur_matte_blur_kernel_size
    }
    fn edge_blur_matte_blur_kernel_size_mut(&mut self) -> &mut f32 {
        &mut self.edge_blur_matte_blur_kernel_size
    }
    fn enable_heat_ripple(&self) -> &bool {
        &self.enable_heat_ripple
    }
    fn enable_heat_ripple_mut(&mut self) -> &mut bool {
        &mut self.enable_heat_ripple
    }
    fn heat_ripple_gain(&self) -> &f32 {
        &self.heat_ripple_gain
    }
    fn heat_ripple_gain_mut(&mut self) -> &mut f32 {
        &mut self.heat_ripple_gain
    }
    fn heat_ripple_horizontal_speed(&self) -> &f32 {
        &self.heat_ripple_horizontal_speed
    }
    fn heat_ripple_horizontal_speed_mut(&mut self) -> &mut f32 {
        &mut self.heat_ripple_horizontal_speed
    }
    fn heat_ripple_vertical_speed(&self) -> &f32 {
        &self.heat_ripple_vertical_speed
    }
    fn heat_ripple_vertical_speed_mut(&mut self) -> &mut f32 {
        &mut self.heat_ripple_vertical_speed
    }
    fn heat_ripple_noise_scale(&self) -> &f32 {
        &self.heat_ripple_noise_scale
    }
    fn heat_ripple_noise_scale_mut(&mut self) -> &mut f32 {
        &mut self.heat_ripple_noise_scale
    }
    fn heat_ripple_near_distance(&self) -> &f32 {
        &self.heat_ripple_near_distance
    }
    fn heat_ripple_near_distance_mut(&mut self) -> &mut f32 {
        &mut self.heat_ripple_near_distance
    }
    fn heat_ripple_far_distance(&self) -> &f32 {
        &self.heat_ripple_far_distance
    }
    fn heat_ripple_far_distance_mut(&mut self) -> &mut f32 {
        &mut self.heat_ripple_far_distance
    }
    fn heat_ripple_near_gain(&self) -> &f32 {
        &self.heat_ripple_near_gain
    }
    fn heat_ripple_near_gain_mut(&mut self) -> &mut f32 {
        &mut self.heat_ripple_near_gain
    }
    fn heat_ripple_far_gain(&self) -> &f32 {
        &self.heat_ripple_far_gain
    }
    fn heat_ripple_far_gain_mut(&mut self) -> &mut f32 {
        &mut self.heat_ripple_far_gain
    }
    fn heat_ripple_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &self.heat_ripple_texture
    }
    fn heat_ripple_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &mut self.heat_ripple_texture
    }
    fn field_flag_override0(&self) -> &u32 {
        &self.field_flag_override0
    }
    fn field_flag_override0_mut(&mut self) -> &mut u32 {
        &mut self.field_flag_override0
    }
    fn field_flag_override1(&self) -> &u8 {
        &self.field_flag_override1
    }
    fn field_flag_override1_mut(&mut self) -> &mut u8 {
        &mut self.field_flag_override1
    }
}

impl VisualEnvironmentComponentDataTrait for FilmicEffectsComponentData {
    fn property_overrides(&self) -> &Vec<String> {
        self._glacier_base.property_overrides()
    }
    fn property_overrides_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.property_overrides_mut()
    }
}

impl super::entity::ComponentDataTrait for FilmicEffectsComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for FilmicEffectsComponentData {
}

impl super::core::DataBusPeerTrait for FilmicEffectsComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for FilmicEffectsComponentData {
}

impl super::core::DataContainerTrait for FilmicEffectsComponentData {
}

pub static FILMICEFFECTSCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FilmicEffectsComponentData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VISUALENVIRONMENTCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FilmicEffectsComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FilmicEffectsComponentData, enable),
            },
            FieldInfoData {
                name: "EnableChromaticAbberation",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FilmicEffectsComponentData, enable_chromatic_abberation),
            },
            FieldInfoData {
                name: "ChromaticAbberationScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FilmicEffectsComponentData, chromatic_abberation_scale),
            },
            FieldInfoData {
                name: "ChromaticAbberationAspectRatio",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FilmicEffectsComponentData, chromatic_abberation_aspect_ratio),
            },
            FieldInfoData {
                name: "EnableVignetting",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FilmicEffectsComponentData, enable_vignetting),
            },
            FieldInfoData {
                name: "VignettingFalloff",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FilmicEffectsComponentData, vignetting_falloff),
            },
            FieldInfoData {
                name: "VignettingLuminancePercent",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FilmicEffectsComponentData, vignetting_luminance_percent),
            },
            FieldInfoData {
                name: "EnableLensDistortion",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FilmicEffectsComponentData, enable_lens_distortion),
            },
            FieldInfoData {
                name: "LensDistortionGain",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FilmicEffectsComponentData, lens_distortion_gain),
            },
            FieldInfoData {
                name: "LensDistortionCubicGain",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FilmicEffectsComponentData, lens_distortion_cubic_gain),
            },
            FieldInfoData {
                name: "LensDistortionStretch",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FilmicEffectsComponentData, lens_distortion_stretch),
            },
            FieldInfoData {
                name: "EnableFrameFlash",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FilmicEffectsComponentData, enable_frame_flash),
            },
            FieldInfoData {
                name: "FrameFlashGain",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FilmicEffectsComponentData, frame_flash_gain),
            },
            FieldInfoData {
                name: "EnableDepthFlash",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FilmicEffectsComponentData, enable_depth_flash),
            },
            FieldInfoData {
                name: "DepthFlashAtmosColor",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(FilmicEffectsComponentData, depth_flash_atmos_color),
            },
            FieldInfoData {
                name: "DepthFlashHalfDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FilmicEffectsComponentData, depth_flash_half_distance),
            },
            FieldInfoData {
                name: "EnableDistanceBlur",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FilmicEffectsComponentData, enable_distance_blur),
            },
            FieldInfoData {
                name: "DistanceBlurGain",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FilmicEffectsComponentData, distance_blur_gain),
            },
            FieldInfoData {
                name: "DistanceBlurHalfDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FilmicEffectsComponentData, distance_blur_half_distance),
            },
            FieldInfoData {
                name: "EnableEdgeBlur",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FilmicEffectsComponentData, enable_edge_blur),
            },
            FieldInfoData {
                name: "EdgeBlurGain",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FilmicEffectsComponentData, edge_blur_gain),
            },
            FieldInfoData {
                name: "EdgeBlurDepthTargetScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FilmicEffectsComponentData, edge_blur_depth_target_scale),
            },
            FieldInfoData {
                name: "EdgeBlurFadeNearDepth",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FilmicEffectsComponentData, edge_blur_fade_near_depth),
            },
            FieldInfoData {
                name: "EdgeBlurFadeFarDepth",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FilmicEffectsComponentData, edge_blur_fade_far_depth),
            },
            FieldInfoData {
                name: "EdgeBlurMatteDilateSize",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FilmicEffectsComponentData, edge_blur_matte_dilate_size),
            },
            FieldInfoData {
                name: "EdgeBlurMatteBlurKernelSize",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FilmicEffectsComponentData, edge_blur_matte_blur_kernel_size),
            },
            FieldInfoData {
                name: "EnableHeatRipple",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FilmicEffectsComponentData, enable_heat_ripple),
            },
            FieldInfoData {
                name: "HeatRippleGain",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FilmicEffectsComponentData, heat_ripple_gain),
            },
            FieldInfoData {
                name: "HeatRippleHorizontalSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FilmicEffectsComponentData, heat_ripple_horizontal_speed),
            },
            FieldInfoData {
                name: "HeatRippleVerticalSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FilmicEffectsComponentData, heat_ripple_vertical_speed),
            },
            FieldInfoData {
                name: "HeatRippleNoiseScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FilmicEffectsComponentData, heat_ripple_noise_scale),
            },
            FieldInfoData {
                name: "HeatRippleNearDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FilmicEffectsComponentData, heat_ripple_near_distance),
            },
            FieldInfoData {
                name: "HeatRippleFarDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FilmicEffectsComponentData, heat_ripple_far_distance),
            },
            FieldInfoData {
                name: "HeatRippleNearGain",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FilmicEffectsComponentData, heat_ripple_near_gain),
            },
            FieldInfoData {
                name: "HeatRippleFarGain",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FilmicEffectsComponentData, heat_ripple_far_gain),
            },
            FieldInfoData {
                name: "HeatRippleTexture",
                flags: MemberInfoFlags::new(0),
                field_type: "TextureBaseAsset",
                rust_offset: offset_of!(FilmicEffectsComponentData, heat_ripple_texture),
            },
            FieldInfoData {
                name: "FieldFlagOverride0",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(FilmicEffectsComponentData, field_flag_override0),
            },
            FieldInfoData {
                name: "FieldFlagOverride1",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(FilmicEffectsComponentData, field_flag_override1),
            },
        ],
    }),
    array_type: Some(FILMICEFFECTSCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for FilmicEffectsComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        FILMICEFFECTSCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FILMICEFFECTSCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FilmicEffectsComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("FilmicEffectsComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DebugComponentData {
    pub _glacier_base: VisualEnvironmentComponentData,
    pub enable: bool,
    pub fullscreen: bool,
    pub debug_texture: Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>,
    pub field_flag_override0: u8,
}

pub trait DebugComponentDataTrait: VisualEnvironmentComponentDataTrait {
    fn enable(&self) -> &bool;
    fn enable_mut(&mut self) -> &mut bool;
    fn fullscreen(&self) -> &bool;
    fn fullscreen_mut(&mut self) -> &mut bool;
    fn debug_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn debug_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn field_flag_override0(&self) -> &u8;
    fn field_flag_override0_mut(&mut self) -> &mut u8;
}

impl DebugComponentDataTrait for DebugComponentData {
    fn enable(&self) -> &bool {
        &self.enable
    }
    fn enable_mut(&mut self) -> &mut bool {
        &mut self.enable
    }
    fn fullscreen(&self) -> &bool {
        &self.fullscreen
    }
    fn fullscreen_mut(&mut self) -> &mut bool {
        &mut self.fullscreen
    }
    fn debug_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &self.debug_texture
    }
    fn debug_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &mut self.debug_texture
    }
    fn field_flag_override0(&self) -> &u8 {
        &self.field_flag_override0
    }
    fn field_flag_override0_mut(&mut self) -> &mut u8 {
        &mut self.field_flag_override0
    }
}

impl VisualEnvironmentComponentDataTrait for DebugComponentData {
    fn property_overrides(&self) -> &Vec<String> {
        self._glacier_base.property_overrides()
    }
    fn property_overrides_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.property_overrides_mut()
    }
}

impl super::entity::ComponentDataTrait for DebugComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for DebugComponentData {
}

impl super::core::DataBusPeerTrait for DebugComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for DebugComponentData {
}

impl super::core::DataContainerTrait for DebugComponentData {
}

pub static DEBUGCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DebugComponentData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VISUALENVIRONMENTCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DebugComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DebugComponentData, enable),
            },
            FieldInfoData {
                name: "Fullscreen",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DebugComponentData, fullscreen),
            },
            FieldInfoData {
                name: "DebugTexture",
                flags: MemberInfoFlags::new(0),
                field_type: "TextureBaseAsset",
                rust_offset: offset_of!(DebugComponentData, debug_texture),
            },
            FieldInfoData {
                name: "FieldFlagOverride0",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(DebugComponentData, field_flag_override0),
            },
        ],
    }),
    array_type: Some(DEBUGCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for DebugComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        DEBUGCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DEBUGCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DebugComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("DebugComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LensScopeComponentData {
    pub _glacier_base: VisualEnvironmentComponentData,
    pub enable: bool,
    pub blur_scale: f32,
    pub blur_center: super::core::Vec2,
    pub chromatic_aberration_color1: super::core::Vec3,
    pub chromatic_aberration_color2: super::core::Vec3,
    pub chromatic_aberration_strengths: super::core::Vec2,
    pub chromatic_aberration_displacement1: super::core::Vec2,
    pub chromatic_aberration_displacement2: super::core::Vec2,
    pub radial_blend_distance_coefficients: super::core::Vec2,
    pub field_flag_override0: u16,
}

pub trait LensScopeComponentDataTrait: VisualEnvironmentComponentDataTrait {
    fn enable(&self) -> &bool;
    fn enable_mut(&mut self) -> &mut bool;
    fn blur_scale(&self) -> &f32;
    fn blur_scale_mut(&mut self) -> &mut f32;
    fn blur_center(&self) -> &super::core::Vec2;
    fn blur_center_mut(&mut self) -> &mut super::core::Vec2;
    fn chromatic_aberration_color1(&self) -> &super::core::Vec3;
    fn chromatic_aberration_color1_mut(&mut self) -> &mut super::core::Vec3;
    fn chromatic_aberration_color2(&self) -> &super::core::Vec3;
    fn chromatic_aberration_color2_mut(&mut self) -> &mut super::core::Vec3;
    fn chromatic_aberration_strengths(&self) -> &super::core::Vec2;
    fn chromatic_aberration_strengths_mut(&mut self) -> &mut super::core::Vec2;
    fn chromatic_aberration_displacement1(&self) -> &super::core::Vec2;
    fn chromatic_aberration_displacement1_mut(&mut self) -> &mut super::core::Vec2;
    fn chromatic_aberration_displacement2(&self) -> &super::core::Vec2;
    fn chromatic_aberration_displacement2_mut(&mut self) -> &mut super::core::Vec2;
    fn radial_blend_distance_coefficients(&self) -> &super::core::Vec2;
    fn radial_blend_distance_coefficients_mut(&mut self) -> &mut super::core::Vec2;
    fn field_flag_override0(&self) -> &u16;
    fn field_flag_override0_mut(&mut self) -> &mut u16;
}

impl LensScopeComponentDataTrait for LensScopeComponentData {
    fn enable(&self) -> &bool {
        &self.enable
    }
    fn enable_mut(&mut self) -> &mut bool {
        &mut self.enable
    }
    fn blur_scale(&self) -> &f32 {
        &self.blur_scale
    }
    fn blur_scale_mut(&mut self) -> &mut f32 {
        &mut self.blur_scale
    }
    fn blur_center(&self) -> &super::core::Vec2 {
        &self.blur_center
    }
    fn blur_center_mut(&mut self) -> &mut super::core::Vec2 {
        &mut self.blur_center
    }
    fn chromatic_aberration_color1(&self) -> &super::core::Vec3 {
        &self.chromatic_aberration_color1
    }
    fn chromatic_aberration_color1_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.chromatic_aberration_color1
    }
    fn chromatic_aberration_color2(&self) -> &super::core::Vec3 {
        &self.chromatic_aberration_color2
    }
    fn chromatic_aberration_color2_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.chromatic_aberration_color2
    }
    fn chromatic_aberration_strengths(&self) -> &super::core::Vec2 {
        &self.chromatic_aberration_strengths
    }
    fn chromatic_aberration_strengths_mut(&mut self) -> &mut super::core::Vec2 {
        &mut self.chromatic_aberration_strengths
    }
    fn chromatic_aberration_displacement1(&self) -> &super::core::Vec2 {
        &self.chromatic_aberration_displacement1
    }
    fn chromatic_aberration_displacement1_mut(&mut self) -> &mut super::core::Vec2 {
        &mut self.chromatic_aberration_displacement1
    }
    fn chromatic_aberration_displacement2(&self) -> &super::core::Vec2 {
        &self.chromatic_aberration_displacement2
    }
    fn chromatic_aberration_displacement2_mut(&mut self) -> &mut super::core::Vec2 {
        &mut self.chromatic_aberration_displacement2
    }
    fn radial_blend_distance_coefficients(&self) -> &super::core::Vec2 {
        &self.radial_blend_distance_coefficients
    }
    fn radial_blend_distance_coefficients_mut(&mut self) -> &mut super::core::Vec2 {
        &mut self.radial_blend_distance_coefficients
    }
    fn field_flag_override0(&self) -> &u16 {
        &self.field_flag_override0
    }
    fn field_flag_override0_mut(&mut self) -> &mut u16 {
        &mut self.field_flag_override0
    }
}

impl VisualEnvironmentComponentDataTrait for LensScopeComponentData {
    fn property_overrides(&self) -> &Vec<String> {
        self._glacier_base.property_overrides()
    }
    fn property_overrides_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.property_overrides_mut()
    }
}

impl super::entity::ComponentDataTrait for LensScopeComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for LensScopeComponentData {
}

impl super::core::DataBusPeerTrait for LensScopeComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for LensScopeComponentData {
}

impl super::core::DataContainerTrait for LensScopeComponentData {
}

pub static LENSSCOPECOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LensScopeComponentData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VISUALENVIRONMENTCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LensScopeComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LensScopeComponentData, enable),
            },
            FieldInfoData {
                name: "BlurScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LensScopeComponentData, blur_scale),
            },
            FieldInfoData {
                name: "BlurCenter",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(LensScopeComponentData, blur_center),
            },
            FieldInfoData {
                name: "ChromaticAberrationColor1",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(LensScopeComponentData, chromatic_aberration_color1),
            },
            FieldInfoData {
                name: "ChromaticAberrationColor2",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(LensScopeComponentData, chromatic_aberration_color2),
            },
            FieldInfoData {
                name: "ChromaticAberrationStrengths",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(LensScopeComponentData, chromatic_aberration_strengths),
            },
            FieldInfoData {
                name: "ChromaticAberrationDisplacement1",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(LensScopeComponentData, chromatic_aberration_displacement1),
            },
            FieldInfoData {
                name: "ChromaticAberrationDisplacement2",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(LensScopeComponentData, chromatic_aberration_displacement2),
            },
            FieldInfoData {
                name: "RadialBlendDistanceCoefficients",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(LensScopeComponentData, radial_blend_distance_coefficients),
            },
            FieldInfoData {
                name: "FieldFlagOverride0",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint16",
                rust_offset: offset_of!(LensScopeComponentData, field_flag_override0),
            },
        ],
    }),
    array_type: Some(LENSSCOPECOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for LensScopeComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        LENSSCOPECOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LENSSCOPECOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LensScopeComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("LensScopeComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FilmGrainComponentData {
    pub _glacier_base: VisualEnvironmentComponentData,
    pub enable: bool,
    pub texture_scale: super::core::Vec2,
    pub color_scale: super::core::Vec3,
    pub linear_filtering_enable: bool,
    pub random_enable: bool,
    pub texture: Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>,
    pub grain_grey_fraction: f32,
    pub grain_luminance_control_enable: bool,
    pub grain_shadow_threshold: f32,
    pub grain_highlight_threshold: f32,
    pub grain_shadow_intensity: f32,
    pub grain_highlight_intensity: f32,
    pub field_flag_override0: u16,
}

pub trait FilmGrainComponentDataTrait: VisualEnvironmentComponentDataTrait {
    fn enable(&self) -> &bool;
    fn enable_mut(&mut self) -> &mut bool;
    fn texture_scale(&self) -> &super::core::Vec2;
    fn texture_scale_mut(&mut self) -> &mut super::core::Vec2;
    fn color_scale(&self) -> &super::core::Vec3;
    fn color_scale_mut(&mut self) -> &mut super::core::Vec3;
    fn linear_filtering_enable(&self) -> &bool;
    fn linear_filtering_enable_mut(&mut self) -> &mut bool;
    fn random_enable(&self) -> &bool;
    fn random_enable_mut(&mut self) -> &mut bool;
    fn texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn grain_grey_fraction(&self) -> &f32;
    fn grain_grey_fraction_mut(&mut self) -> &mut f32;
    fn grain_luminance_control_enable(&self) -> &bool;
    fn grain_luminance_control_enable_mut(&mut self) -> &mut bool;
    fn grain_shadow_threshold(&self) -> &f32;
    fn grain_shadow_threshold_mut(&mut self) -> &mut f32;
    fn grain_highlight_threshold(&self) -> &f32;
    fn grain_highlight_threshold_mut(&mut self) -> &mut f32;
    fn grain_shadow_intensity(&self) -> &f32;
    fn grain_shadow_intensity_mut(&mut self) -> &mut f32;
    fn grain_highlight_intensity(&self) -> &f32;
    fn grain_highlight_intensity_mut(&mut self) -> &mut f32;
    fn field_flag_override0(&self) -> &u16;
    fn field_flag_override0_mut(&mut self) -> &mut u16;
}

impl FilmGrainComponentDataTrait for FilmGrainComponentData {
    fn enable(&self) -> &bool {
        &self.enable
    }
    fn enable_mut(&mut self) -> &mut bool {
        &mut self.enable
    }
    fn texture_scale(&self) -> &super::core::Vec2 {
        &self.texture_scale
    }
    fn texture_scale_mut(&mut self) -> &mut super::core::Vec2 {
        &mut self.texture_scale
    }
    fn color_scale(&self) -> &super::core::Vec3 {
        &self.color_scale
    }
    fn color_scale_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.color_scale
    }
    fn linear_filtering_enable(&self) -> &bool {
        &self.linear_filtering_enable
    }
    fn linear_filtering_enable_mut(&mut self) -> &mut bool {
        &mut self.linear_filtering_enable
    }
    fn random_enable(&self) -> &bool {
        &self.random_enable
    }
    fn random_enable_mut(&mut self) -> &mut bool {
        &mut self.random_enable
    }
    fn texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &self.texture
    }
    fn texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &mut self.texture
    }
    fn grain_grey_fraction(&self) -> &f32 {
        &self.grain_grey_fraction
    }
    fn grain_grey_fraction_mut(&mut self) -> &mut f32 {
        &mut self.grain_grey_fraction
    }
    fn grain_luminance_control_enable(&self) -> &bool {
        &self.grain_luminance_control_enable
    }
    fn grain_luminance_control_enable_mut(&mut self) -> &mut bool {
        &mut self.grain_luminance_control_enable
    }
    fn grain_shadow_threshold(&self) -> &f32 {
        &self.grain_shadow_threshold
    }
    fn grain_shadow_threshold_mut(&mut self) -> &mut f32 {
        &mut self.grain_shadow_threshold
    }
    fn grain_highlight_threshold(&self) -> &f32 {
        &self.grain_highlight_threshold
    }
    fn grain_highlight_threshold_mut(&mut self) -> &mut f32 {
        &mut self.grain_highlight_threshold
    }
    fn grain_shadow_intensity(&self) -> &f32 {
        &self.grain_shadow_intensity
    }
    fn grain_shadow_intensity_mut(&mut self) -> &mut f32 {
        &mut self.grain_shadow_intensity
    }
    fn grain_highlight_intensity(&self) -> &f32 {
        &self.grain_highlight_intensity
    }
    fn grain_highlight_intensity_mut(&mut self) -> &mut f32 {
        &mut self.grain_highlight_intensity
    }
    fn field_flag_override0(&self) -> &u16 {
        &self.field_flag_override0
    }
    fn field_flag_override0_mut(&mut self) -> &mut u16 {
        &mut self.field_flag_override0
    }
}

impl VisualEnvironmentComponentDataTrait for FilmGrainComponentData {
    fn property_overrides(&self) -> &Vec<String> {
        self._glacier_base.property_overrides()
    }
    fn property_overrides_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.property_overrides_mut()
    }
}

impl super::entity::ComponentDataTrait for FilmGrainComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for FilmGrainComponentData {
}

impl super::core::DataBusPeerTrait for FilmGrainComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for FilmGrainComponentData {
}

impl super::core::DataContainerTrait for FilmGrainComponentData {
}

pub static FILMGRAINCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FilmGrainComponentData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VISUALENVIRONMENTCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FilmGrainComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FilmGrainComponentData, enable),
            },
            FieldInfoData {
                name: "TextureScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(FilmGrainComponentData, texture_scale),
            },
            FieldInfoData {
                name: "ColorScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(FilmGrainComponentData, color_scale),
            },
            FieldInfoData {
                name: "LinearFilteringEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FilmGrainComponentData, linear_filtering_enable),
            },
            FieldInfoData {
                name: "RandomEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FilmGrainComponentData, random_enable),
            },
            FieldInfoData {
                name: "Texture",
                flags: MemberInfoFlags::new(0),
                field_type: "TextureBaseAsset",
                rust_offset: offset_of!(FilmGrainComponentData, texture),
            },
            FieldInfoData {
                name: "GrainGreyFraction",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FilmGrainComponentData, grain_grey_fraction),
            },
            FieldInfoData {
                name: "GrainLuminanceControlEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FilmGrainComponentData, grain_luminance_control_enable),
            },
            FieldInfoData {
                name: "GrainShadowThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FilmGrainComponentData, grain_shadow_threshold),
            },
            FieldInfoData {
                name: "GrainHighlightThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FilmGrainComponentData, grain_highlight_threshold),
            },
            FieldInfoData {
                name: "GrainShadowIntensity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FilmGrainComponentData, grain_shadow_intensity),
            },
            FieldInfoData {
                name: "GrainHighlightIntensity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FilmGrainComponentData, grain_highlight_intensity),
            },
            FieldInfoData {
                name: "FieldFlagOverride0",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint16",
                rust_offset: offset_of!(FilmGrainComponentData, field_flag_override0),
            },
        ],
    }),
    array_type: Some(FILMGRAINCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for FilmGrainComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        FILMGRAINCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FILMGRAINCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FilmGrainComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("FilmGrainComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VignetteComponentData {
    pub _glacier_base: VisualEnvironmentComponentData,
    pub enable: bool,
    pub scale: super::core::Vec2,
    pub exponent: f32,
    pub color: super::core::Vec3,
    pub opacity: f32,
    pub field_flag_override0: u8,
}

pub trait VignetteComponentDataTrait: VisualEnvironmentComponentDataTrait {
    fn enable(&self) -> &bool;
    fn enable_mut(&mut self) -> &mut bool;
    fn scale(&self) -> &super::core::Vec2;
    fn scale_mut(&mut self) -> &mut super::core::Vec2;
    fn exponent(&self) -> &f32;
    fn exponent_mut(&mut self) -> &mut f32;
    fn color(&self) -> &super::core::Vec3;
    fn color_mut(&mut self) -> &mut super::core::Vec3;
    fn opacity(&self) -> &f32;
    fn opacity_mut(&mut self) -> &mut f32;
    fn field_flag_override0(&self) -> &u8;
    fn field_flag_override0_mut(&mut self) -> &mut u8;
}

impl VignetteComponentDataTrait for VignetteComponentData {
    fn enable(&self) -> &bool {
        &self.enable
    }
    fn enable_mut(&mut self) -> &mut bool {
        &mut self.enable
    }
    fn scale(&self) -> &super::core::Vec2 {
        &self.scale
    }
    fn scale_mut(&mut self) -> &mut super::core::Vec2 {
        &mut self.scale
    }
    fn exponent(&self) -> &f32 {
        &self.exponent
    }
    fn exponent_mut(&mut self) -> &mut f32 {
        &mut self.exponent
    }
    fn color(&self) -> &super::core::Vec3 {
        &self.color
    }
    fn color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.color
    }
    fn opacity(&self) -> &f32 {
        &self.opacity
    }
    fn opacity_mut(&mut self) -> &mut f32 {
        &mut self.opacity
    }
    fn field_flag_override0(&self) -> &u8 {
        &self.field_flag_override0
    }
    fn field_flag_override0_mut(&mut self) -> &mut u8 {
        &mut self.field_flag_override0
    }
}

impl VisualEnvironmentComponentDataTrait for VignetteComponentData {
    fn property_overrides(&self) -> &Vec<String> {
        self._glacier_base.property_overrides()
    }
    fn property_overrides_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.property_overrides_mut()
    }
}

impl super::entity::ComponentDataTrait for VignetteComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for VignetteComponentData {
}

impl super::core::DataBusPeerTrait for VignetteComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for VignetteComponentData {
}

impl super::core::DataContainerTrait for VignetteComponentData {
}

pub static VIGNETTECOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VignetteComponentData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VISUALENVIRONMENTCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VignetteComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VignetteComponentData, enable),
            },
            FieldInfoData {
                name: "Scale",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(VignetteComponentData, scale),
            },
            FieldInfoData {
                name: "Exponent",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VignetteComponentData, exponent),
            },
            FieldInfoData {
                name: "Color",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(VignetteComponentData, color),
            },
            FieldInfoData {
                name: "Opacity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VignetteComponentData, opacity),
            },
            FieldInfoData {
                name: "FieldFlagOverride0",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(VignetteComponentData, field_flag_override0),
            },
        ],
    }),
    array_type: Some(VIGNETTECOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VignetteComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        VIGNETTECOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VIGNETTECOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VignetteComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("VignetteComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DofComponentData {
    pub _glacier_base: VisualEnvironmentComponentData,
    pub enable: bool,
    pub physical_camera_tweak_enable: bool,
    pub pbc_background_blur_add: f32,
    pub pbc_foreground_blur_add: f32,
    pub pbc_focus_range_add: f32,
    pub dof_source: super::render_base::DofSource,
    pub debug_draw_focus_plane: bool,
    pub focus_dof_max_blur: f32,
    pub blur_factor: f32,
    pub blur_add: f32,
    pub focus_distance: f32,
    pub radial_blur_enable_common_dof: bool,
    pub radial_blur_amount_common_dof: f32,
    pub radial_blur_start_radius_common_dof: f32,
    pub radial_blur_transition_width_common_dof: f32,
    pub radial_blur_tilt_common_dof: f32,
    pub radial_blur_horizontal_scale_common_dof: f32,
    pub radial_blur_aspect_ratio_blend: f32,
    pub radial_blur_position_common_dof: super::core::Vec2,
    pub simple_dof_blur_filter: super::render_base::BlurFilter,
    pub simple_dof_standard_deviation: f32,
    pub sprite_dof_bokeh_texture: Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>,
    pub focus_dof_near_start: f32,
    pub focus_dof_near_end: f32,
    pub focus_dof_far_start: f32,
    pub focus_dof_far_end: f32,
    pub pbr_focus_length_dof: f32,
    pub pbr_film_width_dof: f32,
    pub pbr_f_stop_dof: f32,
    pub optical_vignetting_enable: bool,
    pub optical_vignetting_amount: f32,
    pub optical_vignetting_aspect_ratio: f32,
    pub optical_vignetting_anamorphic_squeeze: f32,
    pub optical_vignetting_size_compensation: f32,
    pub optical_vignetting_operation: super::render_base::VignettingOperation,
    pub r_g_b_bokeh_texture_enable: bool,
    pub bokeh_chromatic_aberration_enable: bool,
    pub bokeh_chromatic_aberration_scale: f32,
    pub bokeh_chromatic_aberration_radius: f32,
    pub bokeh_chromatic_aberration_width: f32,
    pub bokeh_chromatic_aberration_radius_threshold: f32,
    pub bokeh_chromatic_aberration_radius_threshold_width: f32,
    pub bokeh_chromatic_aberration_energy_threshold: f32,
    pub bokeh_chromatic_aberration_fg_color: super::core::Vec3,
    pub bokeh_chromatic_aberration_bg_color: super::core::Vec3,
    pub ironsights_dof_active: bool,
    pub ironsights_dof_extra_blur: bool,
    pub hip_to_ironsights_fade: f32,
    pub ironsights_dof_start_fade: f32,
    pub ironsights_focal_distance: f32,
    pub ironsights_dof_circle_blur: bool,
    pub ironsights_dof_circle_distance: f32,
    pub ironsights_dof_circle_fade_distance: f32,
    pub masked_blur_enabled: bool,
    pub masked_blur_amount: f32,
    pub masked_blur_texture: Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>,
    pub circular_dof_anti_band_artifact: bool,
    pub use_camera_settings: bool,
    pub simple_dof_max_blur: f32,
    pub simple_dof_near_start: f32,
    pub simple_dof_near_end: f32,
    pub simple_dof_far_start: f32,
    pub simple_dof_far_end: f32,
    pub sprite_dof_near_start: f32,
    pub sprite_dof_near_end: f32,
    pub sprite_dof_far_start: f32,
    pub sprite_dof_far_end: f32,
    pub sprite_dof_max_blur: f32,
    pub anisotropy: f32,
    pub full_screen_blur_add_common_dof: f32,
    pub field_flag_override0: u32,
    pub field_flag_override1: u32,
    pub field_flag_override2: u8,
}

pub trait DofComponentDataTrait: VisualEnvironmentComponentDataTrait {
    fn enable(&self) -> &bool;
    fn enable_mut(&mut self) -> &mut bool;
    fn physical_camera_tweak_enable(&self) -> &bool;
    fn physical_camera_tweak_enable_mut(&mut self) -> &mut bool;
    fn pbc_background_blur_add(&self) -> &f32;
    fn pbc_background_blur_add_mut(&mut self) -> &mut f32;
    fn pbc_foreground_blur_add(&self) -> &f32;
    fn pbc_foreground_blur_add_mut(&mut self) -> &mut f32;
    fn pbc_focus_range_add(&self) -> &f32;
    fn pbc_focus_range_add_mut(&mut self) -> &mut f32;
    fn dof_source(&self) -> &super::render_base::DofSource;
    fn dof_source_mut(&mut self) -> &mut super::render_base::DofSource;
    fn debug_draw_focus_plane(&self) -> &bool;
    fn debug_draw_focus_plane_mut(&mut self) -> &mut bool;
    fn focus_dof_max_blur(&self) -> &f32;
    fn focus_dof_max_blur_mut(&mut self) -> &mut f32;
    fn blur_factor(&self) -> &f32;
    fn blur_factor_mut(&mut self) -> &mut f32;
    fn blur_add(&self) -> &f32;
    fn blur_add_mut(&mut self) -> &mut f32;
    fn focus_distance(&self) -> &f32;
    fn focus_distance_mut(&mut self) -> &mut f32;
    fn radial_blur_enable_common_dof(&self) -> &bool;
    fn radial_blur_enable_common_dof_mut(&mut self) -> &mut bool;
    fn radial_blur_amount_common_dof(&self) -> &f32;
    fn radial_blur_amount_common_dof_mut(&mut self) -> &mut f32;
    fn radial_blur_start_radius_common_dof(&self) -> &f32;
    fn radial_blur_start_radius_common_dof_mut(&mut self) -> &mut f32;
    fn radial_blur_transition_width_common_dof(&self) -> &f32;
    fn radial_blur_transition_width_common_dof_mut(&mut self) -> &mut f32;
    fn radial_blur_tilt_common_dof(&self) -> &f32;
    fn radial_blur_tilt_common_dof_mut(&mut self) -> &mut f32;
    fn radial_blur_horizontal_scale_common_dof(&self) -> &f32;
    fn radial_blur_horizontal_scale_common_dof_mut(&mut self) -> &mut f32;
    fn radial_blur_aspect_ratio_blend(&self) -> &f32;
    fn radial_blur_aspect_ratio_blend_mut(&mut self) -> &mut f32;
    fn radial_blur_position_common_dof(&self) -> &super::core::Vec2;
    fn radial_blur_position_common_dof_mut(&mut self) -> &mut super::core::Vec2;
    fn simple_dof_blur_filter(&self) -> &super::render_base::BlurFilter;
    fn simple_dof_blur_filter_mut(&mut self) -> &mut super::render_base::BlurFilter;
    fn simple_dof_standard_deviation(&self) -> &f32;
    fn simple_dof_standard_deviation_mut(&mut self) -> &mut f32;
    fn sprite_dof_bokeh_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn sprite_dof_bokeh_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn focus_dof_near_start(&self) -> &f32;
    fn focus_dof_near_start_mut(&mut self) -> &mut f32;
    fn focus_dof_near_end(&self) -> &f32;
    fn focus_dof_near_end_mut(&mut self) -> &mut f32;
    fn focus_dof_far_start(&self) -> &f32;
    fn focus_dof_far_start_mut(&mut self) -> &mut f32;
    fn focus_dof_far_end(&self) -> &f32;
    fn focus_dof_far_end_mut(&mut self) -> &mut f32;
    fn pbr_focus_length_dof(&self) -> &f32;
    fn pbr_focus_length_dof_mut(&mut self) -> &mut f32;
    fn pbr_film_width_dof(&self) -> &f32;
    fn pbr_film_width_dof_mut(&mut self) -> &mut f32;
    fn pbr_f_stop_dof(&self) -> &f32;
    fn pbr_f_stop_dof_mut(&mut self) -> &mut f32;
    fn optical_vignetting_enable(&self) -> &bool;
    fn optical_vignetting_enable_mut(&mut self) -> &mut bool;
    fn optical_vignetting_amount(&self) -> &f32;
    fn optical_vignetting_amount_mut(&mut self) -> &mut f32;
    fn optical_vignetting_aspect_ratio(&self) -> &f32;
    fn optical_vignetting_aspect_ratio_mut(&mut self) -> &mut f32;
    fn optical_vignetting_anamorphic_squeeze(&self) -> &f32;
    fn optical_vignetting_anamorphic_squeeze_mut(&mut self) -> &mut f32;
    fn optical_vignetting_size_compensation(&self) -> &f32;
    fn optical_vignetting_size_compensation_mut(&mut self) -> &mut f32;
    fn optical_vignetting_operation(&self) -> &super::render_base::VignettingOperation;
    fn optical_vignetting_operation_mut(&mut self) -> &mut super::render_base::VignettingOperation;
    fn r_g_b_bokeh_texture_enable(&self) -> &bool;
    fn r_g_b_bokeh_texture_enable_mut(&mut self) -> &mut bool;
    fn bokeh_chromatic_aberration_enable(&self) -> &bool;
    fn bokeh_chromatic_aberration_enable_mut(&mut self) -> &mut bool;
    fn bokeh_chromatic_aberration_scale(&self) -> &f32;
    fn bokeh_chromatic_aberration_scale_mut(&mut self) -> &mut f32;
    fn bokeh_chromatic_aberration_radius(&self) -> &f32;
    fn bokeh_chromatic_aberration_radius_mut(&mut self) -> &mut f32;
    fn bokeh_chromatic_aberration_width(&self) -> &f32;
    fn bokeh_chromatic_aberration_width_mut(&mut self) -> &mut f32;
    fn bokeh_chromatic_aberration_radius_threshold(&self) -> &f32;
    fn bokeh_chromatic_aberration_radius_threshold_mut(&mut self) -> &mut f32;
    fn bokeh_chromatic_aberration_radius_threshold_width(&self) -> &f32;
    fn bokeh_chromatic_aberration_radius_threshold_width_mut(&mut self) -> &mut f32;
    fn bokeh_chromatic_aberration_energy_threshold(&self) -> &f32;
    fn bokeh_chromatic_aberration_energy_threshold_mut(&mut self) -> &mut f32;
    fn bokeh_chromatic_aberration_fg_color(&self) -> &super::core::Vec3;
    fn bokeh_chromatic_aberration_fg_color_mut(&mut self) -> &mut super::core::Vec3;
    fn bokeh_chromatic_aberration_bg_color(&self) -> &super::core::Vec3;
    fn bokeh_chromatic_aberration_bg_color_mut(&mut self) -> &mut super::core::Vec3;
    fn ironsights_dof_active(&self) -> &bool;
    fn ironsights_dof_active_mut(&mut self) -> &mut bool;
    fn ironsights_dof_extra_blur(&self) -> &bool;
    fn ironsights_dof_extra_blur_mut(&mut self) -> &mut bool;
    fn hip_to_ironsights_fade(&self) -> &f32;
    fn hip_to_ironsights_fade_mut(&mut self) -> &mut f32;
    fn ironsights_dof_start_fade(&self) -> &f32;
    fn ironsights_dof_start_fade_mut(&mut self) -> &mut f32;
    fn ironsights_focal_distance(&self) -> &f32;
    fn ironsights_focal_distance_mut(&mut self) -> &mut f32;
    fn ironsights_dof_circle_blur(&self) -> &bool;
    fn ironsights_dof_circle_blur_mut(&mut self) -> &mut bool;
    fn ironsights_dof_circle_distance(&self) -> &f32;
    fn ironsights_dof_circle_distance_mut(&mut self) -> &mut f32;
    fn ironsights_dof_circle_fade_distance(&self) -> &f32;
    fn ironsights_dof_circle_fade_distance_mut(&mut self) -> &mut f32;
    fn masked_blur_enabled(&self) -> &bool;
    fn masked_blur_enabled_mut(&mut self) -> &mut bool;
    fn masked_blur_amount(&self) -> &f32;
    fn masked_blur_amount_mut(&mut self) -> &mut f32;
    fn masked_blur_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn masked_blur_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn circular_dof_anti_band_artifact(&self) -> &bool;
    fn circular_dof_anti_band_artifact_mut(&mut self) -> &mut bool;
    fn use_camera_settings(&self) -> &bool;
    fn use_camera_settings_mut(&mut self) -> &mut bool;
    fn simple_dof_max_blur(&self) -> &f32;
    fn simple_dof_max_blur_mut(&mut self) -> &mut f32;
    fn simple_dof_near_start(&self) -> &f32;
    fn simple_dof_near_start_mut(&mut self) -> &mut f32;
    fn simple_dof_near_end(&self) -> &f32;
    fn simple_dof_near_end_mut(&mut self) -> &mut f32;
    fn simple_dof_far_start(&self) -> &f32;
    fn simple_dof_far_start_mut(&mut self) -> &mut f32;
    fn simple_dof_far_end(&self) -> &f32;
    fn simple_dof_far_end_mut(&mut self) -> &mut f32;
    fn sprite_dof_near_start(&self) -> &f32;
    fn sprite_dof_near_start_mut(&mut self) -> &mut f32;
    fn sprite_dof_near_end(&self) -> &f32;
    fn sprite_dof_near_end_mut(&mut self) -> &mut f32;
    fn sprite_dof_far_start(&self) -> &f32;
    fn sprite_dof_far_start_mut(&mut self) -> &mut f32;
    fn sprite_dof_far_end(&self) -> &f32;
    fn sprite_dof_far_end_mut(&mut self) -> &mut f32;
    fn sprite_dof_max_blur(&self) -> &f32;
    fn sprite_dof_max_blur_mut(&mut self) -> &mut f32;
    fn anisotropy(&self) -> &f32;
    fn anisotropy_mut(&mut self) -> &mut f32;
    fn full_screen_blur_add_common_dof(&self) -> &f32;
    fn full_screen_blur_add_common_dof_mut(&mut self) -> &mut f32;
    fn field_flag_override0(&self) -> &u32;
    fn field_flag_override0_mut(&mut self) -> &mut u32;
    fn field_flag_override1(&self) -> &u32;
    fn field_flag_override1_mut(&mut self) -> &mut u32;
    fn field_flag_override2(&self) -> &u8;
    fn field_flag_override2_mut(&mut self) -> &mut u8;
}

impl DofComponentDataTrait for DofComponentData {
    fn enable(&self) -> &bool {
        &self.enable
    }
    fn enable_mut(&mut self) -> &mut bool {
        &mut self.enable
    }
    fn physical_camera_tweak_enable(&self) -> &bool {
        &self.physical_camera_tweak_enable
    }
    fn physical_camera_tweak_enable_mut(&mut self) -> &mut bool {
        &mut self.physical_camera_tweak_enable
    }
    fn pbc_background_blur_add(&self) -> &f32 {
        &self.pbc_background_blur_add
    }
    fn pbc_background_blur_add_mut(&mut self) -> &mut f32 {
        &mut self.pbc_background_blur_add
    }
    fn pbc_foreground_blur_add(&self) -> &f32 {
        &self.pbc_foreground_blur_add
    }
    fn pbc_foreground_blur_add_mut(&mut self) -> &mut f32 {
        &mut self.pbc_foreground_blur_add
    }
    fn pbc_focus_range_add(&self) -> &f32 {
        &self.pbc_focus_range_add
    }
    fn pbc_focus_range_add_mut(&mut self) -> &mut f32 {
        &mut self.pbc_focus_range_add
    }
    fn dof_source(&self) -> &super::render_base::DofSource {
        &self.dof_source
    }
    fn dof_source_mut(&mut self) -> &mut super::render_base::DofSource {
        &mut self.dof_source
    }
    fn debug_draw_focus_plane(&self) -> &bool {
        &self.debug_draw_focus_plane
    }
    fn debug_draw_focus_plane_mut(&mut self) -> &mut bool {
        &mut self.debug_draw_focus_plane
    }
    fn focus_dof_max_blur(&self) -> &f32 {
        &self.focus_dof_max_blur
    }
    fn focus_dof_max_blur_mut(&mut self) -> &mut f32 {
        &mut self.focus_dof_max_blur
    }
    fn blur_factor(&self) -> &f32 {
        &self.blur_factor
    }
    fn blur_factor_mut(&mut self) -> &mut f32 {
        &mut self.blur_factor
    }
    fn blur_add(&self) -> &f32 {
        &self.blur_add
    }
    fn blur_add_mut(&mut self) -> &mut f32 {
        &mut self.blur_add
    }
    fn focus_distance(&self) -> &f32 {
        &self.focus_distance
    }
    fn focus_distance_mut(&mut self) -> &mut f32 {
        &mut self.focus_distance
    }
    fn radial_blur_enable_common_dof(&self) -> &bool {
        &self.radial_blur_enable_common_dof
    }
    fn radial_blur_enable_common_dof_mut(&mut self) -> &mut bool {
        &mut self.radial_blur_enable_common_dof
    }
    fn radial_blur_amount_common_dof(&self) -> &f32 {
        &self.radial_blur_amount_common_dof
    }
    fn radial_blur_amount_common_dof_mut(&mut self) -> &mut f32 {
        &mut self.radial_blur_amount_common_dof
    }
    fn radial_blur_start_radius_common_dof(&self) -> &f32 {
        &self.radial_blur_start_radius_common_dof
    }
    fn radial_blur_start_radius_common_dof_mut(&mut self) -> &mut f32 {
        &mut self.radial_blur_start_radius_common_dof
    }
    fn radial_blur_transition_width_common_dof(&self) -> &f32 {
        &self.radial_blur_transition_width_common_dof
    }
    fn radial_blur_transition_width_common_dof_mut(&mut self) -> &mut f32 {
        &mut self.radial_blur_transition_width_common_dof
    }
    fn radial_blur_tilt_common_dof(&self) -> &f32 {
        &self.radial_blur_tilt_common_dof
    }
    fn radial_blur_tilt_common_dof_mut(&mut self) -> &mut f32 {
        &mut self.radial_blur_tilt_common_dof
    }
    fn radial_blur_horizontal_scale_common_dof(&self) -> &f32 {
        &self.radial_blur_horizontal_scale_common_dof
    }
    fn radial_blur_horizontal_scale_common_dof_mut(&mut self) -> &mut f32 {
        &mut self.radial_blur_horizontal_scale_common_dof
    }
    fn radial_blur_aspect_ratio_blend(&self) -> &f32 {
        &self.radial_blur_aspect_ratio_blend
    }
    fn radial_blur_aspect_ratio_blend_mut(&mut self) -> &mut f32 {
        &mut self.radial_blur_aspect_ratio_blend
    }
    fn radial_blur_position_common_dof(&self) -> &super::core::Vec2 {
        &self.radial_blur_position_common_dof
    }
    fn radial_blur_position_common_dof_mut(&mut self) -> &mut super::core::Vec2 {
        &mut self.radial_blur_position_common_dof
    }
    fn simple_dof_blur_filter(&self) -> &super::render_base::BlurFilter {
        &self.simple_dof_blur_filter
    }
    fn simple_dof_blur_filter_mut(&mut self) -> &mut super::render_base::BlurFilter {
        &mut self.simple_dof_blur_filter
    }
    fn simple_dof_standard_deviation(&self) -> &f32 {
        &self.simple_dof_standard_deviation
    }
    fn simple_dof_standard_deviation_mut(&mut self) -> &mut f32 {
        &mut self.simple_dof_standard_deviation
    }
    fn sprite_dof_bokeh_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &self.sprite_dof_bokeh_texture
    }
    fn sprite_dof_bokeh_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &mut self.sprite_dof_bokeh_texture
    }
    fn focus_dof_near_start(&self) -> &f32 {
        &self.focus_dof_near_start
    }
    fn focus_dof_near_start_mut(&mut self) -> &mut f32 {
        &mut self.focus_dof_near_start
    }
    fn focus_dof_near_end(&self) -> &f32 {
        &self.focus_dof_near_end
    }
    fn focus_dof_near_end_mut(&mut self) -> &mut f32 {
        &mut self.focus_dof_near_end
    }
    fn focus_dof_far_start(&self) -> &f32 {
        &self.focus_dof_far_start
    }
    fn focus_dof_far_start_mut(&mut self) -> &mut f32 {
        &mut self.focus_dof_far_start
    }
    fn focus_dof_far_end(&self) -> &f32 {
        &self.focus_dof_far_end
    }
    fn focus_dof_far_end_mut(&mut self) -> &mut f32 {
        &mut self.focus_dof_far_end
    }
    fn pbr_focus_length_dof(&self) -> &f32 {
        &self.pbr_focus_length_dof
    }
    fn pbr_focus_length_dof_mut(&mut self) -> &mut f32 {
        &mut self.pbr_focus_length_dof
    }
    fn pbr_film_width_dof(&self) -> &f32 {
        &self.pbr_film_width_dof
    }
    fn pbr_film_width_dof_mut(&mut self) -> &mut f32 {
        &mut self.pbr_film_width_dof
    }
    fn pbr_f_stop_dof(&self) -> &f32 {
        &self.pbr_f_stop_dof
    }
    fn pbr_f_stop_dof_mut(&mut self) -> &mut f32 {
        &mut self.pbr_f_stop_dof
    }
    fn optical_vignetting_enable(&self) -> &bool {
        &self.optical_vignetting_enable
    }
    fn optical_vignetting_enable_mut(&mut self) -> &mut bool {
        &mut self.optical_vignetting_enable
    }
    fn optical_vignetting_amount(&self) -> &f32 {
        &self.optical_vignetting_amount
    }
    fn optical_vignetting_amount_mut(&mut self) -> &mut f32 {
        &mut self.optical_vignetting_amount
    }
    fn optical_vignetting_aspect_ratio(&self) -> &f32 {
        &self.optical_vignetting_aspect_ratio
    }
    fn optical_vignetting_aspect_ratio_mut(&mut self) -> &mut f32 {
        &mut self.optical_vignetting_aspect_ratio
    }
    fn optical_vignetting_anamorphic_squeeze(&self) -> &f32 {
        &self.optical_vignetting_anamorphic_squeeze
    }
    fn optical_vignetting_anamorphic_squeeze_mut(&mut self) -> &mut f32 {
        &mut self.optical_vignetting_anamorphic_squeeze
    }
    fn optical_vignetting_size_compensation(&self) -> &f32 {
        &self.optical_vignetting_size_compensation
    }
    fn optical_vignetting_size_compensation_mut(&mut self) -> &mut f32 {
        &mut self.optical_vignetting_size_compensation
    }
    fn optical_vignetting_operation(&self) -> &super::render_base::VignettingOperation {
        &self.optical_vignetting_operation
    }
    fn optical_vignetting_operation_mut(&mut self) -> &mut super::render_base::VignettingOperation {
        &mut self.optical_vignetting_operation
    }
    fn r_g_b_bokeh_texture_enable(&self) -> &bool {
        &self.r_g_b_bokeh_texture_enable
    }
    fn r_g_b_bokeh_texture_enable_mut(&mut self) -> &mut bool {
        &mut self.r_g_b_bokeh_texture_enable
    }
    fn bokeh_chromatic_aberration_enable(&self) -> &bool {
        &self.bokeh_chromatic_aberration_enable
    }
    fn bokeh_chromatic_aberration_enable_mut(&mut self) -> &mut bool {
        &mut self.bokeh_chromatic_aberration_enable
    }
    fn bokeh_chromatic_aberration_scale(&self) -> &f32 {
        &self.bokeh_chromatic_aberration_scale
    }
    fn bokeh_chromatic_aberration_scale_mut(&mut self) -> &mut f32 {
        &mut self.bokeh_chromatic_aberration_scale
    }
    fn bokeh_chromatic_aberration_radius(&self) -> &f32 {
        &self.bokeh_chromatic_aberration_radius
    }
    fn bokeh_chromatic_aberration_radius_mut(&mut self) -> &mut f32 {
        &mut self.bokeh_chromatic_aberration_radius
    }
    fn bokeh_chromatic_aberration_width(&self) -> &f32 {
        &self.bokeh_chromatic_aberration_width
    }
    fn bokeh_chromatic_aberration_width_mut(&mut self) -> &mut f32 {
        &mut self.bokeh_chromatic_aberration_width
    }
    fn bokeh_chromatic_aberration_radius_threshold(&self) -> &f32 {
        &self.bokeh_chromatic_aberration_radius_threshold
    }
    fn bokeh_chromatic_aberration_radius_threshold_mut(&mut self) -> &mut f32 {
        &mut self.bokeh_chromatic_aberration_radius_threshold
    }
    fn bokeh_chromatic_aberration_radius_threshold_width(&self) -> &f32 {
        &self.bokeh_chromatic_aberration_radius_threshold_width
    }
    fn bokeh_chromatic_aberration_radius_threshold_width_mut(&mut self) -> &mut f32 {
        &mut self.bokeh_chromatic_aberration_radius_threshold_width
    }
    fn bokeh_chromatic_aberration_energy_threshold(&self) -> &f32 {
        &self.bokeh_chromatic_aberration_energy_threshold
    }
    fn bokeh_chromatic_aberration_energy_threshold_mut(&mut self) -> &mut f32 {
        &mut self.bokeh_chromatic_aberration_energy_threshold
    }
    fn bokeh_chromatic_aberration_fg_color(&self) -> &super::core::Vec3 {
        &self.bokeh_chromatic_aberration_fg_color
    }
    fn bokeh_chromatic_aberration_fg_color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.bokeh_chromatic_aberration_fg_color
    }
    fn bokeh_chromatic_aberration_bg_color(&self) -> &super::core::Vec3 {
        &self.bokeh_chromatic_aberration_bg_color
    }
    fn bokeh_chromatic_aberration_bg_color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.bokeh_chromatic_aberration_bg_color
    }
    fn ironsights_dof_active(&self) -> &bool {
        &self.ironsights_dof_active
    }
    fn ironsights_dof_active_mut(&mut self) -> &mut bool {
        &mut self.ironsights_dof_active
    }
    fn ironsights_dof_extra_blur(&self) -> &bool {
        &self.ironsights_dof_extra_blur
    }
    fn ironsights_dof_extra_blur_mut(&mut self) -> &mut bool {
        &mut self.ironsights_dof_extra_blur
    }
    fn hip_to_ironsights_fade(&self) -> &f32 {
        &self.hip_to_ironsights_fade
    }
    fn hip_to_ironsights_fade_mut(&mut self) -> &mut f32 {
        &mut self.hip_to_ironsights_fade
    }
    fn ironsights_dof_start_fade(&self) -> &f32 {
        &self.ironsights_dof_start_fade
    }
    fn ironsights_dof_start_fade_mut(&mut self) -> &mut f32 {
        &mut self.ironsights_dof_start_fade
    }
    fn ironsights_focal_distance(&self) -> &f32 {
        &self.ironsights_focal_distance
    }
    fn ironsights_focal_distance_mut(&mut self) -> &mut f32 {
        &mut self.ironsights_focal_distance
    }
    fn ironsights_dof_circle_blur(&self) -> &bool {
        &self.ironsights_dof_circle_blur
    }
    fn ironsights_dof_circle_blur_mut(&mut self) -> &mut bool {
        &mut self.ironsights_dof_circle_blur
    }
    fn ironsights_dof_circle_distance(&self) -> &f32 {
        &self.ironsights_dof_circle_distance
    }
    fn ironsights_dof_circle_distance_mut(&mut self) -> &mut f32 {
        &mut self.ironsights_dof_circle_distance
    }
    fn ironsights_dof_circle_fade_distance(&self) -> &f32 {
        &self.ironsights_dof_circle_fade_distance
    }
    fn ironsights_dof_circle_fade_distance_mut(&mut self) -> &mut f32 {
        &mut self.ironsights_dof_circle_fade_distance
    }
    fn masked_blur_enabled(&self) -> &bool {
        &self.masked_blur_enabled
    }
    fn masked_blur_enabled_mut(&mut self) -> &mut bool {
        &mut self.masked_blur_enabled
    }
    fn masked_blur_amount(&self) -> &f32 {
        &self.masked_blur_amount
    }
    fn masked_blur_amount_mut(&mut self) -> &mut f32 {
        &mut self.masked_blur_amount
    }
    fn masked_blur_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &self.masked_blur_texture
    }
    fn masked_blur_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &mut self.masked_blur_texture
    }
    fn circular_dof_anti_band_artifact(&self) -> &bool {
        &self.circular_dof_anti_band_artifact
    }
    fn circular_dof_anti_band_artifact_mut(&mut self) -> &mut bool {
        &mut self.circular_dof_anti_band_artifact
    }
    fn use_camera_settings(&self) -> &bool {
        &self.use_camera_settings
    }
    fn use_camera_settings_mut(&mut self) -> &mut bool {
        &mut self.use_camera_settings
    }
    fn simple_dof_max_blur(&self) -> &f32 {
        &self.simple_dof_max_blur
    }
    fn simple_dof_max_blur_mut(&mut self) -> &mut f32 {
        &mut self.simple_dof_max_blur
    }
    fn simple_dof_near_start(&self) -> &f32 {
        &self.simple_dof_near_start
    }
    fn simple_dof_near_start_mut(&mut self) -> &mut f32 {
        &mut self.simple_dof_near_start
    }
    fn simple_dof_near_end(&self) -> &f32 {
        &self.simple_dof_near_end
    }
    fn simple_dof_near_end_mut(&mut self) -> &mut f32 {
        &mut self.simple_dof_near_end
    }
    fn simple_dof_far_start(&self) -> &f32 {
        &self.simple_dof_far_start
    }
    fn simple_dof_far_start_mut(&mut self) -> &mut f32 {
        &mut self.simple_dof_far_start
    }
    fn simple_dof_far_end(&self) -> &f32 {
        &self.simple_dof_far_end
    }
    fn simple_dof_far_end_mut(&mut self) -> &mut f32 {
        &mut self.simple_dof_far_end
    }
    fn sprite_dof_near_start(&self) -> &f32 {
        &self.sprite_dof_near_start
    }
    fn sprite_dof_near_start_mut(&mut self) -> &mut f32 {
        &mut self.sprite_dof_near_start
    }
    fn sprite_dof_near_end(&self) -> &f32 {
        &self.sprite_dof_near_end
    }
    fn sprite_dof_near_end_mut(&mut self) -> &mut f32 {
        &mut self.sprite_dof_near_end
    }
    fn sprite_dof_far_start(&self) -> &f32 {
        &self.sprite_dof_far_start
    }
    fn sprite_dof_far_start_mut(&mut self) -> &mut f32 {
        &mut self.sprite_dof_far_start
    }
    fn sprite_dof_far_end(&self) -> &f32 {
        &self.sprite_dof_far_end
    }
    fn sprite_dof_far_end_mut(&mut self) -> &mut f32 {
        &mut self.sprite_dof_far_end
    }
    fn sprite_dof_max_blur(&self) -> &f32 {
        &self.sprite_dof_max_blur
    }
    fn sprite_dof_max_blur_mut(&mut self) -> &mut f32 {
        &mut self.sprite_dof_max_blur
    }
    fn anisotropy(&self) -> &f32 {
        &self.anisotropy
    }
    fn anisotropy_mut(&mut self) -> &mut f32 {
        &mut self.anisotropy
    }
    fn full_screen_blur_add_common_dof(&self) -> &f32 {
        &self.full_screen_blur_add_common_dof
    }
    fn full_screen_blur_add_common_dof_mut(&mut self) -> &mut f32 {
        &mut self.full_screen_blur_add_common_dof
    }
    fn field_flag_override0(&self) -> &u32 {
        &self.field_flag_override0
    }
    fn field_flag_override0_mut(&mut self) -> &mut u32 {
        &mut self.field_flag_override0
    }
    fn field_flag_override1(&self) -> &u32 {
        &self.field_flag_override1
    }
    fn field_flag_override1_mut(&mut self) -> &mut u32 {
        &mut self.field_flag_override1
    }
    fn field_flag_override2(&self) -> &u8 {
        &self.field_flag_override2
    }
    fn field_flag_override2_mut(&mut self) -> &mut u8 {
        &mut self.field_flag_override2
    }
}

impl VisualEnvironmentComponentDataTrait for DofComponentData {
    fn property_overrides(&self) -> &Vec<String> {
        self._glacier_base.property_overrides()
    }
    fn property_overrides_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.property_overrides_mut()
    }
}

impl super::entity::ComponentDataTrait for DofComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for DofComponentData {
}

impl super::core::DataBusPeerTrait for DofComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for DofComponentData {
}

impl super::core::DataContainerTrait for DofComponentData {
}

pub static DOFCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DofComponentData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VISUALENVIRONMENTCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DofComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DofComponentData, enable),
            },
            FieldInfoData {
                name: "PhysicalCameraTweakEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DofComponentData, physical_camera_tweak_enable),
            },
            FieldInfoData {
                name: "PbcBackgroundBlurAdd",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DofComponentData, pbc_background_blur_add),
            },
            FieldInfoData {
                name: "PbcForegroundBlurAdd",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DofComponentData, pbc_foreground_blur_add),
            },
            FieldInfoData {
                name: "PbcFocusRangeAdd",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DofComponentData, pbc_focus_range_add),
            },
            FieldInfoData {
                name: "DofSource",
                flags: MemberInfoFlags::new(0),
                field_type: "DofSource",
                rust_offset: offset_of!(DofComponentData, dof_source),
            },
            FieldInfoData {
                name: "DebugDrawFocusPlane",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DofComponentData, debug_draw_focus_plane),
            },
            FieldInfoData {
                name: "FocusDofMaxBlur",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DofComponentData, focus_dof_max_blur),
            },
            FieldInfoData {
                name: "BlurFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DofComponentData, blur_factor),
            },
            FieldInfoData {
                name: "BlurAdd",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DofComponentData, blur_add),
            },
            FieldInfoData {
                name: "FocusDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DofComponentData, focus_distance),
            },
            FieldInfoData {
                name: "RadialBlurEnableCommonDof",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DofComponentData, radial_blur_enable_common_dof),
            },
            FieldInfoData {
                name: "RadialBlurAmountCommonDof",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DofComponentData, radial_blur_amount_common_dof),
            },
            FieldInfoData {
                name: "RadialBlurStartRadiusCommonDof",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DofComponentData, radial_blur_start_radius_common_dof),
            },
            FieldInfoData {
                name: "RadialBlurTransitionWidthCommonDof",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DofComponentData, radial_blur_transition_width_common_dof),
            },
            FieldInfoData {
                name: "RadialBlurTiltCommonDof",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DofComponentData, radial_blur_tilt_common_dof),
            },
            FieldInfoData {
                name: "RadialBlurHorizontalScaleCommonDof",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DofComponentData, radial_blur_horizontal_scale_common_dof),
            },
            FieldInfoData {
                name: "RadialBlurAspectRatioBlend",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DofComponentData, radial_blur_aspect_ratio_blend),
            },
            FieldInfoData {
                name: "RadialBlurPositionCommonDof",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(DofComponentData, radial_blur_position_common_dof),
            },
            FieldInfoData {
                name: "SimpleDofBlurFilter",
                flags: MemberInfoFlags::new(0),
                field_type: "BlurFilter",
                rust_offset: offset_of!(DofComponentData, simple_dof_blur_filter),
            },
            FieldInfoData {
                name: "SimpleDofStandardDeviation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DofComponentData, simple_dof_standard_deviation),
            },
            FieldInfoData {
                name: "SpriteDofBokehTexture",
                flags: MemberInfoFlags::new(0),
                field_type: "TextureBaseAsset",
                rust_offset: offset_of!(DofComponentData, sprite_dof_bokeh_texture),
            },
            FieldInfoData {
                name: "FocusDofNearStart",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DofComponentData, focus_dof_near_start),
            },
            FieldInfoData {
                name: "FocusDofNearEnd",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DofComponentData, focus_dof_near_end),
            },
            FieldInfoData {
                name: "FocusDofFarStart",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DofComponentData, focus_dof_far_start),
            },
            FieldInfoData {
                name: "FocusDofFarEnd",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DofComponentData, focus_dof_far_end),
            },
            FieldInfoData {
                name: "PbrFocusLengthDof",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DofComponentData, pbr_focus_length_dof),
            },
            FieldInfoData {
                name: "PbrFilmWidthDof",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DofComponentData, pbr_film_width_dof),
            },
            FieldInfoData {
                name: "PbrFStopDof",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DofComponentData, pbr_f_stop_dof),
            },
            FieldInfoData {
                name: "OpticalVignettingEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DofComponentData, optical_vignetting_enable),
            },
            FieldInfoData {
                name: "OpticalVignettingAmount",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DofComponentData, optical_vignetting_amount),
            },
            FieldInfoData {
                name: "OpticalVignettingAspectRatio",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DofComponentData, optical_vignetting_aspect_ratio),
            },
            FieldInfoData {
                name: "OpticalVignettingAnamorphicSqueeze",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DofComponentData, optical_vignetting_anamorphic_squeeze),
            },
            FieldInfoData {
                name: "OpticalVignettingSizeCompensation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DofComponentData, optical_vignetting_size_compensation),
            },
            FieldInfoData {
                name: "OpticalVignettingOperation",
                flags: MemberInfoFlags::new(0),
                field_type: "VignettingOperation",
                rust_offset: offset_of!(DofComponentData, optical_vignetting_operation),
            },
            FieldInfoData {
                name: "RGBBokehTextureEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DofComponentData, r_g_b_bokeh_texture_enable),
            },
            FieldInfoData {
                name: "BokehChromaticAberrationEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DofComponentData, bokeh_chromatic_aberration_enable),
            },
            FieldInfoData {
                name: "BokehChromaticAberrationScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DofComponentData, bokeh_chromatic_aberration_scale),
            },
            FieldInfoData {
                name: "BokehChromaticAberrationRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DofComponentData, bokeh_chromatic_aberration_radius),
            },
            FieldInfoData {
                name: "BokehChromaticAberrationWidth",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DofComponentData, bokeh_chromatic_aberration_width),
            },
            FieldInfoData {
                name: "BokehChromaticAberrationRadiusThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DofComponentData, bokeh_chromatic_aberration_radius_threshold),
            },
            FieldInfoData {
                name: "BokehChromaticAberrationRadiusThresholdWidth",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DofComponentData, bokeh_chromatic_aberration_radius_threshold_width),
            },
            FieldInfoData {
                name: "BokehChromaticAberrationEnergyThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DofComponentData, bokeh_chromatic_aberration_energy_threshold),
            },
            FieldInfoData {
                name: "BokehChromaticAberrationFgColor",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(DofComponentData, bokeh_chromatic_aberration_fg_color),
            },
            FieldInfoData {
                name: "BokehChromaticAberrationBgColor",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(DofComponentData, bokeh_chromatic_aberration_bg_color),
            },
            FieldInfoData {
                name: "IronsightsDofActive",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DofComponentData, ironsights_dof_active),
            },
            FieldInfoData {
                name: "IronsightsDofExtraBlur",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DofComponentData, ironsights_dof_extra_blur),
            },
            FieldInfoData {
                name: "HipToIronsightsFade",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DofComponentData, hip_to_ironsights_fade),
            },
            FieldInfoData {
                name: "IronsightsDofStartFade",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DofComponentData, ironsights_dof_start_fade),
            },
            FieldInfoData {
                name: "IronsightsFocalDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DofComponentData, ironsights_focal_distance),
            },
            FieldInfoData {
                name: "IronsightsDofCircleBlur",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DofComponentData, ironsights_dof_circle_blur),
            },
            FieldInfoData {
                name: "IronsightsDofCircleDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DofComponentData, ironsights_dof_circle_distance),
            },
            FieldInfoData {
                name: "IronsightsDofCircleFadeDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DofComponentData, ironsights_dof_circle_fade_distance),
            },
            FieldInfoData {
                name: "MaskedBlurEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DofComponentData, masked_blur_enabled),
            },
            FieldInfoData {
                name: "MaskedBlurAmount",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DofComponentData, masked_blur_amount),
            },
            FieldInfoData {
                name: "MaskedBlurTexture",
                flags: MemberInfoFlags::new(0),
                field_type: "TextureBaseAsset",
                rust_offset: offset_of!(DofComponentData, masked_blur_texture),
            },
            FieldInfoData {
                name: "CircularDofAntiBandArtifact",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DofComponentData, circular_dof_anti_band_artifact),
            },
            FieldInfoData {
                name: "UseCameraSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DofComponentData, use_camera_settings),
            },
            FieldInfoData {
                name: "SimpleDofMaxBlur",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DofComponentData, simple_dof_max_blur),
            },
            FieldInfoData {
                name: "SimpleDofNearStart",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DofComponentData, simple_dof_near_start),
            },
            FieldInfoData {
                name: "SimpleDofNearEnd",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DofComponentData, simple_dof_near_end),
            },
            FieldInfoData {
                name: "SimpleDofFarStart",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DofComponentData, simple_dof_far_start),
            },
            FieldInfoData {
                name: "SimpleDofFarEnd",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DofComponentData, simple_dof_far_end),
            },
            FieldInfoData {
                name: "SpriteDofNearStart",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DofComponentData, sprite_dof_near_start),
            },
            FieldInfoData {
                name: "SpriteDofNearEnd",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DofComponentData, sprite_dof_near_end),
            },
            FieldInfoData {
                name: "SpriteDofFarStart",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DofComponentData, sprite_dof_far_start),
            },
            FieldInfoData {
                name: "SpriteDofFarEnd",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DofComponentData, sprite_dof_far_end),
            },
            FieldInfoData {
                name: "SpriteDofMaxBlur",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DofComponentData, sprite_dof_max_blur),
            },
            FieldInfoData {
                name: "Anisotropy",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DofComponentData, anisotropy),
            },
            FieldInfoData {
                name: "FullScreenBlurAddCommonDof",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DofComponentData, full_screen_blur_add_common_dof),
            },
            FieldInfoData {
                name: "FieldFlagOverride0",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(DofComponentData, field_flag_override0),
            },
            FieldInfoData {
                name: "FieldFlagOverride1",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(DofComponentData, field_flag_override1),
            },
            FieldInfoData {
                name: "FieldFlagOverride2",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(DofComponentData, field_flag_override2),
            },
        ],
    }),
    array_type: Some(DOFCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for DofComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        DOFCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DOFCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DofComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("DofComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ColorCorrectionComponentData {
    pub _glacier_base: VisualEnvironmentComponentData,
    pub enable: bool,
    pub brightness: super::core::Vec3,
    pub contrast: super::core::Vec3,
    pub saturation: super::core::Vec3,
    pub hue: f32,
    pub color_grading_enable: bool,
    pub color_grading_texture: Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>,
    pub color_grading_max_hdr_value: f32,
    pub hdr_color_grading_lut: Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>,
    pub field_flag_override0: u16,
}

pub trait ColorCorrectionComponentDataTrait: VisualEnvironmentComponentDataTrait {
    fn enable(&self) -> &bool;
    fn enable_mut(&mut self) -> &mut bool;
    fn brightness(&self) -> &super::core::Vec3;
    fn brightness_mut(&mut self) -> &mut super::core::Vec3;
    fn contrast(&self) -> &super::core::Vec3;
    fn contrast_mut(&mut self) -> &mut super::core::Vec3;
    fn saturation(&self) -> &super::core::Vec3;
    fn saturation_mut(&mut self) -> &mut super::core::Vec3;
    fn hue(&self) -> &f32;
    fn hue_mut(&mut self) -> &mut f32;
    fn color_grading_enable(&self) -> &bool;
    fn color_grading_enable_mut(&mut self) -> &mut bool;
    fn color_grading_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn color_grading_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn color_grading_max_hdr_value(&self) -> &f32;
    fn color_grading_max_hdr_value_mut(&mut self) -> &mut f32;
    fn hdr_color_grading_lut(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn hdr_color_grading_lut_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn field_flag_override0(&self) -> &u16;
    fn field_flag_override0_mut(&mut self) -> &mut u16;
}

impl ColorCorrectionComponentDataTrait for ColorCorrectionComponentData {
    fn enable(&self) -> &bool {
        &self.enable
    }
    fn enable_mut(&mut self) -> &mut bool {
        &mut self.enable
    }
    fn brightness(&self) -> &super::core::Vec3 {
        &self.brightness
    }
    fn brightness_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.brightness
    }
    fn contrast(&self) -> &super::core::Vec3 {
        &self.contrast
    }
    fn contrast_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.contrast
    }
    fn saturation(&self) -> &super::core::Vec3 {
        &self.saturation
    }
    fn saturation_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.saturation
    }
    fn hue(&self) -> &f32 {
        &self.hue
    }
    fn hue_mut(&mut self) -> &mut f32 {
        &mut self.hue
    }
    fn color_grading_enable(&self) -> &bool {
        &self.color_grading_enable
    }
    fn color_grading_enable_mut(&mut self) -> &mut bool {
        &mut self.color_grading_enable
    }
    fn color_grading_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &self.color_grading_texture
    }
    fn color_grading_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &mut self.color_grading_texture
    }
    fn color_grading_max_hdr_value(&self) -> &f32 {
        &self.color_grading_max_hdr_value
    }
    fn color_grading_max_hdr_value_mut(&mut self) -> &mut f32 {
        &mut self.color_grading_max_hdr_value
    }
    fn hdr_color_grading_lut(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &self.hdr_color_grading_lut
    }
    fn hdr_color_grading_lut_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &mut self.hdr_color_grading_lut
    }
    fn field_flag_override0(&self) -> &u16 {
        &self.field_flag_override0
    }
    fn field_flag_override0_mut(&mut self) -> &mut u16 {
        &mut self.field_flag_override0
    }
}

impl VisualEnvironmentComponentDataTrait for ColorCorrectionComponentData {
    fn property_overrides(&self) -> &Vec<String> {
        self._glacier_base.property_overrides()
    }
    fn property_overrides_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.property_overrides_mut()
    }
}

impl super::entity::ComponentDataTrait for ColorCorrectionComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for ColorCorrectionComponentData {
}

impl super::core::DataBusPeerTrait for ColorCorrectionComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ColorCorrectionComponentData {
}

impl super::core::DataContainerTrait for ColorCorrectionComponentData {
}

pub static COLORCORRECTIONCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ColorCorrectionComponentData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VISUALENVIRONMENTCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ColorCorrectionComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ColorCorrectionComponentData, enable),
            },
            FieldInfoData {
                name: "Brightness",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(ColorCorrectionComponentData, brightness),
            },
            FieldInfoData {
                name: "Contrast",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(ColorCorrectionComponentData, contrast),
            },
            FieldInfoData {
                name: "Saturation",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(ColorCorrectionComponentData, saturation),
            },
            FieldInfoData {
                name: "Hue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ColorCorrectionComponentData, hue),
            },
            FieldInfoData {
                name: "ColorGradingEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ColorCorrectionComponentData, color_grading_enable),
            },
            FieldInfoData {
                name: "ColorGradingTexture",
                flags: MemberInfoFlags::new(0),
                field_type: "TextureBaseAsset",
                rust_offset: offset_of!(ColorCorrectionComponentData, color_grading_texture),
            },
            FieldInfoData {
                name: "ColorGradingMaxHdrValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ColorCorrectionComponentData, color_grading_max_hdr_value),
            },
            FieldInfoData {
                name: "HdrColorGradingLut",
                flags: MemberInfoFlags::new(0),
                field_type: "TextureBaseAsset",
                rust_offset: offset_of!(ColorCorrectionComponentData, hdr_color_grading_lut),
            },
            FieldInfoData {
                name: "FieldFlagOverride0",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint16",
                rust_offset: offset_of!(ColorCorrectionComponentData, field_flag_override0),
            },
        ],
    }),
    array_type: Some(COLORCORRECTIONCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ColorCorrectionComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        COLORCORRECTIONCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COLORCORRECTIONCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ColorCorrectionComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("ColorCorrectionComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TonemapComponentData {
    pub _glacier_base: VisualEnvironmentComponentData,
    pub e_v: f32,
    pub exposure_compensation: f32,
    pub auto_exposure_darkest_exclude: f32,
    pub auto_exposure_brightest_exclude: f32,
    pub dark_adaptation_time: f32,
    pub light_adaptation_time: f32,
    pub automatic_exposure: bool,
    pub auto_exposure_method: super::render_base::AutoExposureMethod,
    pub auto_exposure_higher_threshold: f32,
    pub auto_exposure_lower_threshold: f32,
    pub clamp_e_v: bool,
    pub min_e_v: f32,
    pub max_e_v: f32,
    pub spot_meter_scale: f32,
    pub spot_meter_offset_x: f32,
    pub spot_meter_offset_y: f32,
    pub tonemap_method: super::render_base::TonemapMethod,
    pub bloom_direction: super::render_base::BloomDirection,
    pub directional_bloom_clamp: f32,
    pub bloom_scale: super::core::Vec3,
    pub bloom_soft_clip: f32,
    pub bloom_method: super::render_base::BloomMethod,
    pub gaussian_sharpness: f32,
    pub gaussian1_color: super::core::Vec3,
    pub gaussian1_weight: f32,
    pub gaussian2_color: super::core::Vec3,
    pub gaussian2_weight: f32,
    pub gaussian3_color: super::core::Vec3,
    pub gaussian3_weight: f32,
    pub gaussian4_color: super::core::Vec3,
    pub gaussian4_weight: f32,
    pub gaussian5_color: super::core::Vec3,
    pub gaussian5_weight: f32,
    pub f_f_t_threshold: f32,
    pub f_f_t_cutoff: f32,
    pub f_f_t_kernel_scale: f32,
    pub f_f_t_kernel_rotation: f32,
    pub f_f_t_spike_scale_limit_enable: bool,
    pub f_f_t_spike_scale_limit: f32,
    pub f_f_t_kernel_texture: Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>,
    pub chromostereopsis_enable: bool,
    pub chromostereopsis_scale: f32,
    pub chromostereopsis_offset: f32,
    pub lens_dirt_texture: Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>,
    pub lens_dirt_bias: super::core::Vec3,
    pub lens_dirt_factor: super::core::Vec3,
    pub lens_dirt_exponent: super::core::Vec3,
    pub field_flag_override0: u32,
    pub field_flag_override1: u16,
}

pub trait TonemapComponentDataTrait: VisualEnvironmentComponentDataTrait {
    fn e_v(&self) -> &f32;
    fn e_v_mut(&mut self) -> &mut f32;
    fn exposure_compensation(&self) -> &f32;
    fn exposure_compensation_mut(&mut self) -> &mut f32;
    fn auto_exposure_darkest_exclude(&self) -> &f32;
    fn auto_exposure_darkest_exclude_mut(&mut self) -> &mut f32;
    fn auto_exposure_brightest_exclude(&self) -> &f32;
    fn auto_exposure_brightest_exclude_mut(&mut self) -> &mut f32;
    fn dark_adaptation_time(&self) -> &f32;
    fn dark_adaptation_time_mut(&mut self) -> &mut f32;
    fn light_adaptation_time(&self) -> &f32;
    fn light_adaptation_time_mut(&mut self) -> &mut f32;
    fn automatic_exposure(&self) -> &bool;
    fn automatic_exposure_mut(&mut self) -> &mut bool;
    fn auto_exposure_method(&self) -> &super::render_base::AutoExposureMethod;
    fn auto_exposure_method_mut(&mut self) -> &mut super::render_base::AutoExposureMethod;
    fn auto_exposure_higher_threshold(&self) -> &f32;
    fn auto_exposure_higher_threshold_mut(&mut self) -> &mut f32;
    fn auto_exposure_lower_threshold(&self) -> &f32;
    fn auto_exposure_lower_threshold_mut(&mut self) -> &mut f32;
    fn clamp_e_v(&self) -> &bool;
    fn clamp_e_v_mut(&mut self) -> &mut bool;
    fn min_e_v(&self) -> &f32;
    fn min_e_v_mut(&mut self) -> &mut f32;
    fn max_e_v(&self) -> &f32;
    fn max_e_v_mut(&mut self) -> &mut f32;
    fn spot_meter_scale(&self) -> &f32;
    fn spot_meter_scale_mut(&mut self) -> &mut f32;
    fn spot_meter_offset_x(&self) -> &f32;
    fn spot_meter_offset_x_mut(&mut self) -> &mut f32;
    fn spot_meter_offset_y(&self) -> &f32;
    fn spot_meter_offset_y_mut(&mut self) -> &mut f32;
    fn tonemap_method(&self) -> &super::render_base::TonemapMethod;
    fn tonemap_method_mut(&mut self) -> &mut super::render_base::TonemapMethod;
    fn bloom_direction(&self) -> &super::render_base::BloomDirection;
    fn bloom_direction_mut(&mut self) -> &mut super::render_base::BloomDirection;
    fn directional_bloom_clamp(&self) -> &f32;
    fn directional_bloom_clamp_mut(&mut self) -> &mut f32;
    fn bloom_scale(&self) -> &super::core::Vec3;
    fn bloom_scale_mut(&mut self) -> &mut super::core::Vec3;
    fn bloom_soft_clip(&self) -> &f32;
    fn bloom_soft_clip_mut(&mut self) -> &mut f32;
    fn bloom_method(&self) -> &super::render_base::BloomMethod;
    fn bloom_method_mut(&mut self) -> &mut super::render_base::BloomMethod;
    fn gaussian_sharpness(&self) -> &f32;
    fn gaussian_sharpness_mut(&mut self) -> &mut f32;
    fn gaussian1_color(&self) -> &super::core::Vec3;
    fn gaussian1_color_mut(&mut self) -> &mut super::core::Vec3;
    fn gaussian1_weight(&self) -> &f32;
    fn gaussian1_weight_mut(&mut self) -> &mut f32;
    fn gaussian2_color(&self) -> &super::core::Vec3;
    fn gaussian2_color_mut(&mut self) -> &mut super::core::Vec3;
    fn gaussian2_weight(&self) -> &f32;
    fn gaussian2_weight_mut(&mut self) -> &mut f32;
    fn gaussian3_color(&self) -> &super::core::Vec3;
    fn gaussian3_color_mut(&mut self) -> &mut super::core::Vec3;
    fn gaussian3_weight(&self) -> &f32;
    fn gaussian3_weight_mut(&mut self) -> &mut f32;
    fn gaussian4_color(&self) -> &super::core::Vec3;
    fn gaussian4_color_mut(&mut self) -> &mut super::core::Vec3;
    fn gaussian4_weight(&self) -> &f32;
    fn gaussian4_weight_mut(&mut self) -> &mut f32;
    fn gaussian5_color(&self) -> &super::core::Vec3;
    fn gaussian5_color_mut(&mut self) -> &mut super::core::Vec3;
    fn gaussian5_weight(&self) -> &f32;
    fn gaussian5_weight_mut(&mut self) -> &mut f32;
    fn f_f_t_threshold(&self) -> &f32;
    fn f_f_t_threshold_mut(&mut self) -> &mut f32;
    fn f_f_t_cutoff(&self) -> &f32;
    fn f_f_t_cutoff_mut(&mut self) -> &mut f32;
    fn f_f_t_kernel_scale(&self) -> &f32;
    fn f_f_t_kernel_scale_mut(&mut self) -> &mut f32;
    fn f_f_t_kernel_rotation(&self) -> &f32;
    fn f_f_t_kernel_rotation_mut(&mut self) -> &mut f32;
    fn f_f_t_spike_scale_limit_enable(&self) -> &bool;
    fn f_f_t_spike_scale_limit_enable_mut(&mut self) -> &mut bool;
    fn f_f_t_spike_scale_limit(&self) -> &f32;
    fn f_f_t_spike_scale_limit_mut(&mut self) -> &mut f32;
    fn f_f_t_kernel_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn f_f_t_kernel_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn chromostereopsis_enable(&self) -> &bool;
    fn chromostereopsis_enable_mut(&mut self) -> &mut bool;
    fn chromostereopsis_scale(&self) -> &f32;
    fn chromostereopsis_scale_mut(&mut self) -> &mut f32;
    fn chromostereopsis_offset(&self) -> &f32;
    fn chromostereopsis_offset_mut(&mut self) -> &mut f32;
    fn lens_dirt_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn lens_dirt_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn lens_dirt_bias(&self) -> &super::core::Vec3;
    fn lens_dirt_bias_mut(&mut self) -> &mut super::core::Vec3;
    fn lens_dirt_factor(&self) -> &super::core::Vec3;
    fn lens_dirt_factor_mut(&mut self) -> &mut super::core::Vec3;
    fn lens_dirt_exponent(&self) -> &super::core::Vec3;
    fn lens_dirt_exponent_mut(&mut self) -> &mut super::core::Vec3;
    fn field_flag_override0(&self) -> &u32;
    fn field_flag_override0_mut(&mut self) -> &mut u32;
    fn field_flag_override1(&self) -> &u16;
    fn field_flag_override1_mut(&mut self) -> &mut u16;
}

impl TonemapComponentDataTrait for TonemapComponentData {
    fn e_v(&self) -> &f32 {
        &self.e_v
    }
    fn e_v_mut(&mut self) -> &mut f32 {
        &mut self.e_v
    }
    fn exposure_compensation(&self) -> &f32 {
        &self.exposure_compensation
    }
    fn exposure_compensation_mut(&mut self) -> &mut f32 {
        &mut self.exposure_compensation
    }
    fn auto_exposure_darkest_exclude(&self) -> &f32 {
        &self.auto_exposure_darkest_exclude
    }
    fn auto_exposure_darkest_exclude_mut(&mut self) -> &mut f32 {
        &mut self.auto_exposure_darkest_exclude
    }
    fn auto_exposure_brightest_exclude(&self) -> &f32 {
        &self.auto_exposure_brightest_exclude
    }
    fn auto_exposure_brightest_exclude_mut(&mut self) -> &mut f32 {
        &mut self.auto_exposure_brightest_exclude
    }
    fn dark_adaptation_time(&self) -> &f32 {
        &self.dark_adaptation_time
    }
    fn dark_adaptation_time_mut(&mut self) -> &mut f32 {
        &mut self.dark_adaptation_time
    }
    fn light_adaptation_time(&self) -> &f32 {
        &self.light_adaptation_time
    }
    fn light_adaptation_time_mut(&mut self) -> &mut f32 {
        &mut self.light_adaptation_time
    }
    fn automatic_exposure(&self) -> &bool {
        &self.automatic_exposure
    }
    fn automatic_exposure_mut(&mut self) -> &mut bool {
        &mut self.automatic_exposure
    }
    fn auto_exposure_method(&self) -> &super::render_base::AutoExposureMethod {
        &self.auto_exposure_method
    }
    fn auto_exposure_method_mut(&mut self) -> &mut super::render_base::AutoExposureMethod {
        &mut self.auto_exposure_method
    }
    fn auto_exposure_higher_threshold(&self) -> &f32 {
        &self.auto_exposure_higher_threshold
    }
    fn auto_exposure_higher_threshold_mut(&mut self) -> &mut f32 {
        &mut self.auto_exposure_higher_threshold
    }
    fn auto_exposure_lower_threshold(&self) -> &f32 {
        &self.auto_exposure_lower_threshold
    }
    fn auto_exposure_lower_threshold_mut(&mut self) -> &mut f32 {
        &mut self.auto_exposure_lower_threshold
    }
    fn clamp_e_v(&self) -> &bool {
        &self.clamp_e_v
    }
    fn clamp_e_v_mut(&mut self) -> &mut bool {
        &mut self.clamp_e_v
    }
    fn min_e_v(&self) -> &f32 {
        &self.min_e_v
    }
    fn min_e_v_mut(&mut self) -> &mut f32 {
        &mut self.min_e_v
    }
    fn max_e_v(&self) -> &f32 {
        &self.max_e_v
    }
    fn max_e_v_mut(&mut self) -> &mut f32 {
        &mut self.max_e_v
    }
    fn spot_meter_scale(&self) -> &f32 {
        &self.spot_meter_scale
    }
    fn spot_meter_scale_mut(&mut self) -> &mut f32 {
        &mut self.spot_meter_scale
    }
    fn spot_meter_offset_x(&self) -> &f32 {
        &self.spot_meter_offset_x
    }
    fn spot_meter_offset_x_mut(&mut self) -> &mut f32 {
        &mut self.spot_meter_offset_x
    }
    fn spot_meter_offset_y(&self) -> &f32 {
        &self.spot_meter_offset_y
    }
    fn spot_meter_offset_y_mut(&mut self) -> &mut f32 {
        &mut self.spot_meter_offset_y
    }
    fn tonemap_method(&self) -> &super::render_base::TonemapMethod {
        &self.tonemap_method
    }
    fn tonemap_method_mut(&mut self) -> &mut super::render_base::TonemapMethod {
        &mut self.tonemap_method
    }
    fn bloom_direction(&self) -> &super::render_base::BloomDirection {
        &self.bloom_direction
    }
    fn bloom_direction_mut(&mut self) -> &mut super::render_base::BloomDirection {
        &mut self.bloom_direction
    }
    fn directional_bloom_clamp(&self) -> &f32 {
        &self.directional_bloom_clamp
    }
    fn directional_bloom_clamp_mut(&mut self) -> &mut f32 {
        &mut self.directional_bloom_clamp
    }
    fn bloom_scale(&self) -> &super::core::Vec3 {
        &self.bloom_scale
    }
    fn bloom_scale_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.bloom_scale
    }
    fn bloom_soft_clip(&self) -> &f32 {
        &self.bloom_soft_clip
    }
    fn bloom_soft_clip_mut(&mut self) -> &mut f32 {
        &mut self.bloom_soft_clip
    }
    fn bloom_method(&self) -> &super::render_base::BloomMethod {
        &self.bloom_method
    }
    fn bloom_method_mut(&mut self) -> &mut super::render_base::BloomMethod {
        &mut self.bloom_method
    }
    fn gaussian_sharpness(&self) -> &f32 {
        &self.gaussian_sharpness
    }
    fn gaussian_sharpness_mut(&mut self) -> &mut f32 {
        &mut self.gaussian_sharpness
    }
    fn gaussian1_color(&self) -> &super::core::Vec3 {
        &self.gaussian1_color
    }
    fn gaussian1_color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.gaussian1_color
    }
    fn gaussian1_weight(&self) -> &f32 {
        &self.gaussian1_weight
    }
    fn gaussian1_weight_mut(&mut self) -> &mut f32 {
        &mut self.gaussian1_weight
    }
    fn gaussian2_color(&self) -> &super::core::Vec3 {
        &self.gaussian2_color
    }
    fn gaussian2_color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.gaussian2_color
    }
    fn gaussian2_weight(&self) -> &f32 {
        &self.gaussian2_weight
    }
    fn gaussian2_weight_mut(&mut self) -> &mut f32 {
        &mut self.gaussian2_weight
    }
    fn gaussian3_color(&self) -> &super::core::Vec3 {
        &self.gaussian3_color
    }
    fn gaussian3_color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.gaussian3_color
    }
    fn gaussian3_weight(&self) -> &f32 {
        &self.gaussian3_weight
    }
    fn gaussian3_weight_mut(&mut self) -> &mut f32 {
        &mut self.gaussian3_weight
    }
    fn gaussian4_color(&self) -> &super::core::Vec3 {
        &self.gaussian4_color
    }
    fn gaussian4_color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.gaussian4_color
    }
    fn gaussian4_weight(&self) -> &f32 {
        &self.gaussian4_weight
    }
    fn gaussian4_weight_mut(&mut self) -> &mut f32 {
        &mut self.gaussian4_weight
    }
    fn gaussian5_color(&self) -> &super::core::Vec3 {
        &self.gaussian5_color
    }
    fn gaussian5_color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.gaussian5_color
    }
    fn gaussian5_weight(&self) -> &f32 {
        &self.gaussian5_weight
    }
    fn gaussian5_weight_mut(&mut self) -> &mut f32 {
        &mut self.gaussian5_weight
    }
    fn f_f_t_threshold(&self) -> &f32 {
        &self.f_f_t_threshold
    }
    fn f_f_t_threshold_mut(&mut self) -> &mut f32 {
        &mut self.f_f_t_threshold
    }
    fn f_f_t_cutoff(&self) -> &f32 {
        &self.f_f_t_cutoff
    }
    fn f_f_t_cutoff_mut(&mut self) -> &mut f32 {
        &mut self.f_f_t_cutoff
    }
    fn f_f_t_kernel_scale(&self) -> &f32 {
        &self.f_f_t_kernel_scale
    }
    fn f_f_t_kernel_scale_mut(&mut self) -> &mut f32 {
        &mut self.f_f_t_kernel_scale
    }
    fn f_f_t_kernel_rotation(&self) -> &f32 {
        &self.f_f_t_kernel_rotation
    }
    fn f_f_t_kernel_rotation_mut(&mut self) -> &mut f32 {
        &mut self.f_f_t_kernel_rotation
    }
    fn f_f_t_spike_scale_limit_enable(&self) -> &bool {
        &self.f_f_t_spike_scale_limit_enable
    }
    fn f_f_t_spike_scale_limit_enable_mut(&mut self) -> &mut bool {
        &mut self.f_f_t_spike_scale_limit_enable
    }
    fn f_f_t_spike_scale_limit(&self) -> &f32 {
        &self.f_f_t_spike_scale_limit
    }
    fn f_f_t_spike_scale_limit_mut(&mut self) -> &mut f32 {
        &mut self.f_f_t_spike_scale_limit
    }
    fn f_f_t_kernel_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &self.f_f_t_kernel_texture
    }
    fn f_f_t_kernel_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &mut self.f_f_t_kernel_texture
    }
    fn chromostereopsis_enable(&self) -> &bool {
        &self.chromostereopsis_enable
    }
    fn chromostereopsis_enable_mut(&mut self) -> &mut bool {
        &mut self.chromostereopsis_enable
    }
    fn chromostereopsis_scale(&self) -> &f32 {
        &self.chromostereopsis_scale
    }
    fn chromostereopsis_scale_mut(&mut self) -> &mut f32 {
        &mut self.chromostereopsis_scale
    }
    fn chromostereopsis_offset(&self) -> &f32 {
        &self.chromostereopsis_offset
    }
    fn chromostereopsis_offset_mut(&mut self) -> &mut f32 {
        &mut self.chromostereopsis_offset
    }
    fn lens_dirt_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &self.lens_dirt_texture
    }
    fn lens_dirt_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &mut self.lens_dirt_texture
    }
    fn lens_dirt_bias(&self) -> &super::core::Vec3 {
        &self.lens_dirt_bias
    }
    fn lens_dirt_bias_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.lens_dirt_bias
    }
    fn lens_dirt_factor(&self) -> &super::core::Vec3 {
        &self.lens_dirt_factor
    }
    fn lens_dirt_factor_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.lens_dirt_factor
    }
    fn lens_dirt_exponent(&self) -> &super::core::Vec3 {
        &self.lens_dirt_exponent
    }
    fn lens_dirt_exponent_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.lens_dirt_exponent
    }
    fn field_flag_override0(&self) -> &u32 {
        &self.field_flag_override0
    }
    fn field_flag_override0_mut(&mut self) -> &mut u32 {
        &mut self.field_flag_override0
    }
    fn field_flag_override1(&self) -> &u16 {
        &self.field_flag_override1
    }
    fn field_flag_override1_mut(&mut self) -> &mut u16 {
        &mut self.field_flag_override1
    }
}

impl VisualEnvironmentComponentDataTrait for TonemapComponentData {
    fn property_overrides(&self) -> &Vec<String> {
        self._glacier_base.property_overrides()
    }
    fn property_overrides_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.property_overrides_mut()
    }
}

impl super::entity::ComponentDataTrait for TonemapComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for TonemapComponentData {
}

impl super::core::DataBusPeerTrait for TonemapComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TonemapComponentData {
}

impl super::core::DataContainerTrait for TonemapComponentData {
}

pub static TONEMAPCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TonemapComponentData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VISUALENVIRONMENTCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TonemapComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "EV",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TonemapComponentData, e_v),
            },
            FieldInfoData {
                name: "ExposureCompensation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TonemapComponentData, exposure_compensation),
            },
            FieldInfoData {
                name: "AutoExposureDarkestExclude",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TonemapComponentData, auto_exposure_darkest_exclude),
            },
            FieldInfoData {
                name: "AutoExposureBrightestExclude",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TonemapComponentData, auto_exposure_brightest_exclude),
            },
            FieldInfoData {
                name: "DarkAdaptationTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TonemapComponentData, dark_adaptation_time),
            },
            FieldInfoData {
                name: "LightAdaptationTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TonemapComponentData, light_adaptation_time),
            },
            FieldInfoData {
                name: "AutomaticExposure",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TonemapComponentData, automatic_exposure),
            },
            FieldInfoData {
                name: "AutoExposureMethod",
                flags: MemberInfoFlags::new(0),
                field_type: "AutoExposureMethod",
                rust_offset: offset_of!(TonemapComponentData, auto_exposure_method),
            },
            FieldInfoData {
                name: "AutoExposureHigherThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TonemapComponentData, auto_exposure_higher_threshold),
            },
            FieldInfoData {
                name: "AutoExposureLowerThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TonemapComponentData, auto_exposure_lower_threshold),
            },
            FieldInfoData {
                name: "ClampEV",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TonemapComponentData, clamp_e_v),
            },
            FieldInfoData {
                name: "MinEV",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TonemapComponentData, min_e_v),
            },
            FieldInfoData {
                name: "MaxEV",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TonemapComponentData, max_e_v),
            },
            FieldInfoData {
                name: "SpotMeterScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TonemapComponentData, spot_meter_scale),
            },
            FieldInfoData {
                name: "SpotMeterOffsetX",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TonemapComponentData, spot_meter_offset_x),
            },
            FieldInfoData {
                name: "SpotMeterOffsetY",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TonemapComponentData, spot_meter_offset_y),
            },
            FieldInfoData {
                name: "TonemapMethod",
                flags: MemberInfoFlags::new(0),
                field_type: "TonemapMethod",
                rust_offset: offset_of!(TonemapComponentData, tonemap_method),
            },
            FieldInfoData {
                name: "BloomDirection",
                flags: MemberInfoFlags::new(0),
                field_type: "BloomDirection",
                rust_offset: offset_of!(TonemapComponentData, bloom_direction),
            },
            FieldInfoData {
                name: "DirectionalBloomClamp",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TonemapComponentData, directional_bloom_clamp),
            },
            FieldInfoData {
                name: "BloomScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(TonemapComponentData, bloom_scale),
            },
            FieldInfoData {
                name: "BloomSoftClip",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TonemapComponentData, bloom_soft_clip),
            },
            FieldInfoData {
                name: "BloomMethod",
                flags: MemberInfoFlags::new(0),
                field_type: "BloomMethod",
                rust_offset: offset_of!(TonemapComponentData, bloom_method),
            },
            FieldInfoData {
                name: "GaussianSharpness",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TonemapComponentData, gaussian_sharpness),
            },
            FieldInfoData {
                name: "Gaussian1Color",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(TonemapComponentData, gaussian1_color),
            },
            FieldInfoData {
                name: "Gaussian1Weight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TonemapComponentData, gaussian1_weight),
            },
            FieldInfoData {
                name: "Gaussian2Color",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(TonemapComponentData, gaussian2_color),
            },
            FieldInfoData {
                name: "Gaussian2Weight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TonemapComponentData, gaussian2_weight),
            },
            FieldInfoData {
                name: "Gaussian3Color",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(TonemapComponentData, gaussian3_color),
            },
            FieldInfoData {
                name: "Gaussian3Weight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TonemapComponentData, gaussian3_weight),
            },
            FieldInfoData {
                name: "Gaussian4Color",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(TonemapComponentData, gaussian4_color),
            },
            FieldInfoData {
                name: "Gaussian4Weight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TonemapComponentData, gaussian4_weight),
            },
            FieldInfoData {
                name: "Gaussian5Color",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(TonemapComponentData, gaussian5_color),
            },
            FieldInfoData {
                name: "Gaussian5Weight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TonemapComponentData, gaussian5_weight),
            },
            FieldInfoData {
                name: "FFTThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TonemapComponentData, f_f_t_threshold),
            },
            FieldInfoData {
                name: "FFTCutoff",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TonemapComponentData, f_f_t_cutoff),
            },
            FieldInfoData {
                name: "FFTKernelScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TonemapComponentData, f_f_t_kernel_scale),
            },
            FieldInfoData {
                name: "FFTKernelRotation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TonemapComponentData, f_f_t_kernel_rotation),
            },
            FieldInfoData {
                name: "FFTSpikeScaleLimitEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TonemapComponentData, f_f_t_spike_scale_limit_enable),
            },
            FieldInfoData {
                name: "FFTSpikeScaleLimit",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TonemapComponentData, f_f_t_spike_scale_limit),
            },
            FieldInfoData {
                name: "FFTKernelTexture",
                flags: MemberInfoFlags::new(0),
                field_type: "TextureBaseAsset",
                rust_offset: offset_of!(TonemapComponentData, f_f_t_kernel_texture),
            },
            FieldInfoData {
                name: "ChromostereopsisEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TonemapComponentData, chromostereopsis_enable),
            },
            FieldInfoData {
                name: "ChromostereopsisScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TonemapComponentData, chromostereopsis_scale),
            },
            FieldInfoData {
                name: "ChromostereopsisOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TonemapComponentData, chromostereopsis_offset),
            },
            FieldInfoData {
                name: "LensDirtTexture",
                flags: MemberInfoFlags::new(0),
                field_type: "TextureBaseAsset",
                rust_offset: offset_of!(TonemapComponentData, lens_dirt_texture),
            },
            FieldInfoData {
                name: "LensDirtBias",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(TonemapComponentData, lens_dirt_bias),
            },
            FieldInfoData {
                name: "LensDirtFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(TonemapComponentData, lens_dirt_factor),
            },
            FieldInfoData {
                name: "LensDirtExponent",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(TonemapComponentData, lens_dirt_exponent),
            },
            FieldInfoData {
                name: "FieldFlagOverride0",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(TonemapComponentData, field_flag_override0),
            },
            FieldInfoData {
                name: "FieldFlagOverride1",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint16",
                rust_offset: offset_of!(TonemapComponentData, field_flag_override1),
            },
        ],
    }),
    array_type: Some(TONEMAPCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for TonemapComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        TONEMAPCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TONEMAPCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TonemapComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("TonemapComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SkyCelestialMultiComponentData {
    pub _glacier_base: VisualEnvironmentComponentData,
    pub enable: bool,
    pub enabled_on_quality_levels: super::core::QualityScalableBool,
    pub draw_order: u32,
    pub planar_reflection: super::core::QualityScalableBool,
    pub render_in_sky_env_map: bool,
    pub write_alpha: bool,
    pub quad_count: super::core::QualityScalableInt,
    pub texture: Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>,
    pub u_v_start: super::core::Vec2,
    pub u_v_end: super::core::Vec2,
    pub u_v_grid: super::core::Vec2,
    pub tint: super::core::Vec3,
    pub sky_envmap_tint_scale: f32,
    pub random_seed: i32,
    pub min_scale: f32,
    pub max_scale: f32,
    pub scale_multiplier: f32,
    pub zenith_stop: f32,
    pub nadir_stop: f32,
    pub field_flag_override0: u32,
}

pub trait SkyCelestialMultiComponentDataTrait: VisualEnvironmentComponentDataTrait {
    fn enable(&self) -> &bool;
    fn enable_mut(&mut self) -> &mut bool;
    fn enabled_on_quality_levels(&self) -> &super::core::QualityScalableBool;
    fn enabled_on_quality_levels_mut(&mut self) -> &mut super::core::QualityScalableBool;
    fn draw_order(&self) -> &u32;
    fn draw_order_mut(&mut self) -> &mut u32;
    fn planar_reflection(&self) -> &super::core::QualityScalableBool;
    fn planar_reflection_mut(&mut self) -> &mut super::core::QualityScalableBool;
    fn render_in_sky_env_map(&self) -> &bool;
    fn render_in_sky_env_map_mut(&mut self) -> &mut bool;
    fn write_alpha(&self) -> &bool;
    fn write_alpha_mut(&mut self) -> &mut bool;
    fn quad_count(&self) -> &super::core::QualityScalableInt;
    fn quad_count_mut(&mut self) -> &mut super::core::QualityScalableInt;
    fn texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn u_v_start(&self) -> &super::core::Vec2;
    fn u_v_start_mut(&mut self) -> &mut super::core::Vec2;
    fn u_v_end(&self) -> &super::core::Vec2;
    fn u_v_end_mut(&mut self) -> &mut super::core::Vec2;
    fn u_v_grid(&self) -> &super::core::Vec2;
    fn u_v_grid_mut(&mut self) -> &mut super::core::Vec2;
    fn tint(&self) -> &super::core::Vec3;
    fn tint_mut(&mut self) -> &mut super::core::Vec3;
    fn sky_envmap_tint_scale(&self) -> &f32;
    fn sky_envmap_tint_scale_mut(&mut self) -> &mut f32;
    fn random_seed(&self) -> &i32;
    fn random_seed_mut(&mut self) -> &mut i32;
    fn min_scale(&self) -> &f32;
    fn min_scale_mut(&mut self) -> &mut f32;
    fn max_scale(&self) -> &f32;
    fn max_scale_mut(&mut self) -> &mut f32;
    fn scale_multiplier(&self) -> &f32;
    fn scale_multiplier_mut(&mut self) -> &mut f32;
    fn zenith_stop(&self) -> &f32;
    fn zenith_stop_mut(&mut self) -> &mut f32;
    fn nadir_stop(&self) -> &f32;
    fn nadir_stop_mut(&mut self) -> &mut f32;
    fn field_flag_override0(&self) -> &u32;
    fn field_flag_override0_mut(&mut self) -> &mut u32;
}

impl SkyCelestialMultiComponentDataTrait for SkyCelestialMultiComponentData {
    fn enable(&self) -> &bool {
        &self.enable
    }
    fn enable_mut(&mut self) -> &mut bool {
        &mut self.enable
    }
    fn enabled_on_quality_levels(&self) -> &super::core::QualityScalableBool {
        &self.enabled_on_quality_levels
    }
    fn enabled_on_quality_levels_mut(&mut self) -> &mut super::core::QualityScalableBool {
        &mut self.enabled_on_quality_levels
    }
    fn draw_order(&self) -> &u32 {
        &self.draw_order
    }
    fn draw_order_mut(&mut self) -> &mut u32 {
        &mut self.draw_order
    }
    fn planar_reflection(&self) -> &super::core::QualityScalableBool {
        &self.planar_reflection
    }
    fn planar_reflection_mut(&mut self) -> &mut super::core::QualityScalableBool {
        &mut self.planar_reflection
    }
    fn render_in_sky_env_map(&self) -> &bool {
        &self.render_in_sky_env_map
    }
    fn render_in_sky_env_map_mut(&mut self) -> &mut bool {
        &mut self.render_in_sky_env_map
    }
    fn write_alpha(&self) -> &bool {
        &self.write_alpha
    }
    fn write_alpha_mut(&mut self) -> &mut bool {
        &mut self.write_alpha
    }
    fn quad_count(&self) -> &super::core::QualityScalableInt {
        &self.quad_count
    }
    fn quad_count_mut(&mut self) -> &mut super::core::QualityScalableInt {
        &mut self.quad_count
    }
    fn texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &self.texture
    }
    fn texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &mut self.texture
    }
    fn u_v_start(&self) -> &super::core::Vec2 {
        &self.u_v_start
    }
    fn u_v_start_mut(&mut self) -> &mut super::core::Vec2 {
        &mut self.u_v_start
    }
    fn u_v_end(&self) -> &super::core::Vec2 {
        &self.u_v_end
    }
    fn u_v_end_mut(&mut self) -> &mut super::core::Vec2 {
        &mut self.u_v_end
    }
    fn u_v_grid(&self) -> &super::core::Vec2 {
        &self.u_v_grid
    }
    fn u_v_grid_mut(&mut self) -> &mut super::core::Vec2 {
        &mut self.u_v_grid
    }
    fn tint(&self) -> &super::core::Vec3 {
        &self.tint
    }
    fn tint_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.tint
    }
    fn sky_envmap_tint_scale(&self) -> &f32 {
        &self.sky_envmap_tint_scale
    }
    fn sky_envmap_tint_scale_mut(&mut self) -> &mut f32 {
        &mut self.sky_envmap_tint_scale
    }
    fn random_seed(&self) -> &i32 {
        &self.random_seed
    }
    fn random_seed_mut(&mut self) -> &mut i32 {
        &mut self.random_seed
    }
    fn min_scale(&self) -> &f32 {
        &self.min_scale
    }
    fn min_scale_mut(&mut self) -> &mut f32 {
        &mut self.min_scale
    }
    fn max_scale(&self) -> &f32 {
        &self.max_scale
    }
    fn max_scale_mut(&mut self) -> &mut f32 {
        &mut self.max_scale
    }
    fn scale_multiplier(&self) -> &f32 {
        &self.scale_multiplier
    }
    fn scale_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.scale_multiplier
    }
    fn zenith_stop(&self) -> &f32 {
        &self.zenith_stop
    }
    fn zenith_stop_mut(&mut self) -> &mut f32 {
        &mut self.zenith_stop
    }
    fn nadir_stop(&self) -> &f32 {
        &self.nadir_stop
    }
    fn nadir_stop_mut(&mut self) -> &mut f32 {
        &mut self.nadir_stop
    }
    fn field_flag_override0(&self) -> &u32 {
        &self.field_flag_override0
    }
    fn field_flag_override0_mut(&mut self) -> &mut u32 {
        &mut self.field_flag_override0
    }
}

impl VisualEnvironmentComponentDataTrait for SkyCelestialMultiComponentData {
    fn property_overrides(&self) -> &Vec<String> {
        self._glacier_base.property_overrides()
    }
    fn property_overrides_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.property_overrides_mut()
    }
}

impl super::entity::ComponentDataTrait for SkyCelestialMultiComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for SkyCelestialMultiComponentData {
}

impl super::core::DataBusPeerTrait for SkyCelestialMultiComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SkyCelestialMultiComponentData {
}

impl super::core::DataContainerTrait for SkyCelestialMultiComponentData {
}

pub static SKYCELESTIALMULTICOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SkyCelestialMultiComponentData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VISUALENVIRONMENTCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SkyCelestialMultiComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SkyCelestialMultiComponentData, enable),
            },
            FieldInfoData {
                name: "EnabledOnQualityLevels",
                flags: MemberInfoFlags::new(0),
                field_type: "QualityScalableBool",
                rust_offset: offset_of!(SkyCelestialMultiComponentData, enabled_on_quality_levels),
            },
            FieldInfoData {
                name: "DrawOrder",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(SkyCelestialMultiComponentData, draw_order),
            },
            FieldInfoData {
                name: "PlanarReflection",
                flags: MemberInfoFlags::new(0),
                field_type: "QualityScalableBool",
                rust_offset: offset_of!(SkyCelestialMultiComponentData, planar_reflection),
            },
            FieldInfoData {
                name: "RenderInSkyEnvMap",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SkyCelestialMultiComponentData, render_in_sky_env_map),
            },
            FieldInfoData {
                name: "WriteAlpha",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SkyCelestialMultiComponentData, write_alpha),
            },
            FieldInfoData {
                name: "QuadCount",
                flags: MemberInfoFlags::new(0),
                field_type: "QualityScalableInt",
                rust_offset: offset_of!(SkyCelestialMultiComponentData, quad_count),
            },
            FieldInfoData {
                name: "Texture",
                flags: MemberInfoFlags::new(0),
                field_type: "TextureBaseAsset",
                rust_offset: offset_of!(SkyCelestialMultiComponentData, texture),
            },
            FieldInfoData {
                name: "UVStart",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(SkyCelestialMultiComponentData, u_v_start),
            },
            FieldInfoData {
                name: "UVEnd",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(SkyCelestialMultiComponentData, u_v_end),
            },
            FieldInfoData {
                name: "UVGrid",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(SkyCelestialMultiComponentData, u_v_grid),
            },
            FieldInfoData {
                name: "Tint",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SkyCelestialMultiComponentData, tint),
            },
            FieldInfoData {
                name: "SkyEnvmapTintScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyCelestialMultiComponentData, sky_envmap_tint_scale),
            },
            FieldInfoData {
                name: "RandomSeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SkyCelestialMultiComponentData, random_seed),
            },
            FieldInfoData {
                name: "MinScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyCelestialMultiComponentData, min_scale),
            },
            FieldInfoData {
                name: "MaxScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyCelestialMultiComponentData, max_scale),
            },
            FieldInfoData {
                name: "ScaleMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyCelestialMultiComponentData, scale_multiplier),
            },
            FieldInfoData {
                name: "ZenithStop",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyCelestialMultiComponentData, zenith_stop),
            },
            FieldInfoData {
                name: "NadirStop",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyCelestialMultiComponentData, nadir_stop),
            },
            FieldInfoData {
                name: "FieldFlagOverride0",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(SkyCelestialMultiComponentData, field_flag_override0),
            },
        ],
    }),
    array_type: Some(SKYCELESTIALMULTICOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SkyCelestialMultiComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        SKYCELESTIALMULTICOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SKYCELESTIALMULTICOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SkyCelestialMultiComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("SkyCelestialMultiComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SkyCelestialSingleComponentData {
    pub _glacier_base: VisualEnvironmentComponentData,
    pub enable: bool,
    pub enabled_on_quality_levels: super::core::QualityScalableBool,
    pub draw_order: u32,
    pub planar_reflection: super::core::QualityScalableBool,
    pub render_in_sky_env_map: bool,
    pub write_alpha: bool,
    pub texture: Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>,
    pub u_v_start: super::core::Vec2,
    pub u_v_end: super::core::Vec2,
    pub tint: super::core::Vec3,
    pub sky_envmap_tint_scale: f32,
    pub longitude: f32,
    pub latitude: f32,
    pub rotation: f32,
    pub scale: super::core::Vec2,
    pub field_flag_override0: u16,
}

pub trait SkyCelestialSingleComponentDataTrait: VisualEnvironmentComponentDataTrait {
    fn enable(&self) -> &bool;
    fn enable_mut(&mut self) -> &mut bool;
    fn enabled_on_quality_levels(&self) -> &super::core::QualityScalableBool;
    fn enabled_on_quality_levels_mut(&mut self) -> &mut super::core::QualityScalableBool;
    fn draw_order(&self) -> &u32;
    fn draw_order_mut(&mut self) -> &mut u32;
    fn planar_reflection(&self) -> &super::core::QualityScalableBool;
    fn planar_reflection_mut(&mut self) -> &mut super::core::QualityScalableBool;
    fn render_in_sky_env_map(&self) -> &bool;
    fn render_in_sky_env_map_mut(&mut self) -> &mut bool;
    fn write_alpha(&self) -> &bool;
    fn write_alpha_mut(&mut self) -> &mut bool;
    fn texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn u_v_start(&self) -> &super::core::Vec2;
    fn u_v_start_mut(&mut self) -> &mut super::core::Vec2;
    fn u_v_end(&self) -> &super::core::Vec2;
    fn u_v_end_mut(&mut self) -> &mut super::core::Vec2;
    fn tint(&self) -> &super::core::Vec3;
    fn tint_mut(&mut self) -> &mut super::core::Vec3;
    fn sky_envmap_tint_scale(&self) -> &f32;
    fn sky_envmap_tint_scale_mut(&mut self) -> &mut f32;
    fn longitude(&self) -> &f32;
    fn longitude_mut(&mut self) -> &mut f32;
    fn latitude(&self) -> &f32;
    fn latitude_mut(&mut self) -> &mut f32;
    fn rotation(&self) -> &f32;
    fn rotation_mut(&mut self) -> &mut f32;
    fn scale(&self) -> &super::core::Vec2;
    fn scale_mut(&mut self) -> &mut super::core::Vec2;
    fn field_flag_override0(&self) -> &u16;
    fn field_flag_override0_mut(&mut self) -> &mut u16;
}

impl SkyCelestialSingleComponentDataTrait for SkyCelestialSingleComponentData {
    fn enable(&self) -> &bool {
        &self.enable
    }
    fn enable_mut(&mut self) -> &mut bool {
        &mut self.enable
    }
    fn enabled_on_quality_levels(&self) -> &super::core::QualityScalableBool {
        &self.enabled_on_quality_levels
    }
    fn enabled_on_quality_levels_mut(&mut self) -> &mut super::core::QualityScalableBool {
        &mut self.enabled_on_quality_levels
    }
    fn draw_order(&self) -> &u32 {
        &self.draw_order
    }
    fn draw_order_mut(&mut self) -> &mut u32 {
        &mut self.draw_order
    }
    fn planar_reflection(&self) -> &super::core::QualityScalableBool {
        &self.planar_reflection
    }
    fn planar_reflection_mut(&mut self) -> &mut super::core::QualityScalableBool {
        &mut self.planar_reflection
    }
    fn render_in_sky_env_map(&self) -> &bool {
        &self.render_in_sky_env_map
    }
    fn render_in_sky_env_map_mut(&mut self) -> &mut bool {
        &mut self.render_in_sky_env_map
    }
    fn write_alpha(&self) -> &bool {
        &self.write_alpha
    }
    fn write_alpha_mut(&mut self) -> &mut bool {
        &mut self.write_alpha
    }
    fn texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &self.texture
    }
    fn texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &mut self.texture
    }
    fn u_v_start(&self) -> &super::core::Vec2 {
        &self.u_v_start
    }
    fn u_v_start_mut(&mut self) -> &mut super::core::Vec2 {
        &mut self.u_v_start
    }
    fn u_v_end(&self) -> &super::core::Vec2 {
        &self.u_v_end
    }
    fn u_v_end_mut(&mut self) -> &mut super::core::Vec2 {
        &mut self.u_v_end
    }
    fn tint(&self) -> &super::core::Vec3 {
        &self.tint
    }
    fn tint_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.tint
    }
    fn sky_envmap_tint_scale(&self) -> &f32 {
        &self.sky_envmap_tint_scale
    }
    fn sky_envmap_tint_scale_mut(&mut self) -> &mut f32 {
        &mut self.sky_envmap_tint_scale
    }
    fn longitude(&self) -> &f32 {
        &self.longitude
    }
    fn longitude_mut(&mut self) -> &mut f32 {
        &mut self.longitude
    }
    fn latitude(&self) -> &f32 {
        &self.latitude
    }
    fn latitude_mut(&mut self) -> &mut f32 {
        &mut self.latitude
    }
    fn rotation(&self) -> &f32 {
        &self.rotation
    }
    fn rotation_mut(&mut self) -> &mut f32 {
        &mut self.rotation
    }
    fn scale(&self) -> &super::core::Vec2 {
        &self.scale
    }
    fn scale_mut(&mut self) -> &mut super::core::Vec2 {
        &mut self.scale
    }
    fn field_flag_override0(&self) -> &u16 {
        &self.field_flag_override0
    }
    fn field_flag_override0_mut(&mut self) -> &mut u16 {
        &mut self.field_flag_override0
    }
}

impl VisualEnvironmentComponentDataTrait for SkyCelestialSingleComponentData {
    fn property_overrides(&self) -> &Vec<String> {
        self._glacier_base.property_overrides()
    }
    fn property_overrides_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.property_overrides_mut()
    }
}

impl super::entity::ComponentDataTrait for SkyCelestialSingleComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for SkyCelestialSingleComponentData {
}

impl super::core::DataBusPeerTrait for SkyCelestialSingleComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SkyCelestialSingleComponentData {
}

impl super::core::DataContainerTrait for SkyCelestialSingleComponentData {
}

pub static SKYCELESTIALSINGLECOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SkyCelestialSingleComponentData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VISUALENVIRONMENTCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SkyCelestialSingleComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SkyCelestialSingleComponentData, enable),
            },
            FieldInfoData {
                name: "EnabledOnQualityLevels",
                flags: MemberInfoFlags::new(0),
                field_type: "QualityScalableBool",
                rust_offset: offset_of!(SkyCelestialSingleComponentData, enabled_on_quality_levels),
            },
            FieldInfoData {
                name: "DrawOrder",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(SkyCelestialSingleComponentData, draw_order),
            },
            FieldInfoData {
                name: "PlanarReflection",
                flags: MemberInfoFlags::new(0),
                field_type: "QualityScalableBool",
                rust_offset: offset_of!(SkyCelestialSingleComponentData, planar_reflection),
            },
            FieldInfoData {
                name: "RenderInSkyEnvMap",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SkyCelestialSingleComponentData, render_in_sky_env_map),
            },
            FieldInfoData {
                name: "WriteAlpha",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SkyCelestialSingleComponentData, write_alpha),
            },
            FieldInfoData {
                name: "Texture",
                flags: MemberInfoFlags::new(0),
                field_type: "TextureBaseAsset",
                rust_offset: offset_of!(SkyCelestialSingleComponentData, texture),
            },
            FieldInfoData {
                name: "UVStart",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(SkyCelestialSingleComponentData, u_v_start),
            },
            FieldInfoData {
                name: "UVEnd",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(SkyCelestialSingleComponentData, u_v_end),
            },
            FieldInfoData {
                name: "Tint",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SkyCelestialSingleComponentData, tint),
            },
            FieldInfoData {
                name: "SkyEnvmapTintScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyCelestialSingleComponentData, sky_envmap_tint_scale),
            },
            FieldInfoData {
                name: "Longitude",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyCelestialSingleComponentData, longitude),
            },
            FieldInfoData {
                name: "Latitude",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyCelestialSingleComponentData, latitude),
            },
            FieldInfoData {
                name: "Rotation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyCelestialSingleComponentData, rotation),
            },
            FieldInfoData {
                name: "Scale",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(SkyCelestialSingleComponentData, scale),
            },
            FieldInfoData {
                name: "FieldFlagOverride0",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint16",
                rust_offset: offset_of!(SkyCelestialSingleComponentData, field_flag_override0),
            },
        ],
    }),
    array_type: Some(SKYCELESTIALSINGLECOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SkyCelestialSingleComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        SKYCELESTIALSINGLECOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SKYCELESTIALSINGLECOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SkyCelestialSingleComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("SkyCelestialSingleComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SkyCelestialRotationComponentData {
    pub _glacier_base: VisualEnvironmentComponentData,
    pub enable: bool,
    pub rotation: f32,
    pub rotation_axis: super::core::Vec3,
    pub field_flag_override0: u8,
}

pub trait SkyCelestialRotationComponentDataTrait: VisualEnvironmentComponentDataTrait {
    fn enable(&self) -> &bool;
    fn enable_mut(&mut self) -> &mut bool;
    fn rotation(&self) -> &f32;
    fn rotation_mut(&mut self) -> &mut f32;
    fn rotation_axis(&self) -> &super::core::Vec3;
    fn rotation_axis_mut(&mut self) -> &mut super::core::Vec3;
    fn field_flag_override0(&self) -> &u8;
    fn field_flag_override0_mut(&mut self) -> &mut u8;
}

impl SkyCelestialRotationComponentDataTrait for SkyCelestialRotationComponentData {
    fn enable(&self) -> &bool {
        &self.enable
    }
    fn enable_mut(&mut self) -> &mut bool {
        &mut self.enable
    }
    fn rotation(&self) -> &f32 {
        &self.rotation
    }
    fn rotation_mut(&mut self) -> &mut f32 {
        &mut self.rotation
    }
    fn rotation_axis(&self) -> &super::core::Vec3 {
        &self.rotation_axis
    }
    fn rotation_axis_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.rotation_axis
    }
    fn field_flag_override0(&self) -> &u8 {
        &self.field_flag_override0
    }
    fn field_flag_override0_mut(&mut self) -> &mut u8 {
        &mut self.field_flag_override0
    }
}

impl VisualEnvironmentComponentDataTrait for SkyCelestialRotationComponentData {
    fn property_overrides(&self) -> &Vec<String> {
        self._glacier_base.property_overrides()
    }
    fn property_overrides_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.property_overrides_mut()
    }
}

impl super::entity::ComponentDataTrait for SkyCelestialRotationComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for SkyCelestialRotationComponentData {
}

impl super::core::DataBusPeerTrait for SkyCelestialRotationComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SkyCelestialRotationComponentData {
}

impl super::core::DataContainerTrait for SkyCelestialRotationComponentData {
}

pub static SKYCELESTIALROTATIONCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SkyCelestialRotationComponentData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VISUALENVIRONMENTCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SkyCelestialRotationComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SkyCelestialRotationComponentData, enable),
            },
            FieldInfoData {
                name: "Rotation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyCelestialRotationComponentData, rotation),
            },
            FieldInfoData {
                name: "RotationAxis",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SkyCelestialRotationComponentData, rotation_axis),
            },
            FieldInfoData {
                name: "FieldFlagOverride0",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(SkyCelestialRotationComponentData, field_flag_override0),
            },
        ],
    }),
    array_type: Some(SKYCELESTIALROTATIONCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SkyCelestialRotationComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        SKYCELESTIALROTATIONCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SKYCELESTIALROTATIONCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SkyCelestialRotationComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("SkyCelestialRotationComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EmitterParamGlobalComponentData {
    pub _glacier_base: VisualEnvironmentComponentData,
    pub parameter: Option<Arc<Mutex<dyn super::effect_base::EffectParameterTrait>>>,
    pub value: super::core::Vec4,
    pub field_flag_override0: u8,
}

pub trait EmitterParamGlobalComponentDataTrait: VisualEnvironmentComponentDataTrait {
    fn parameter(&self) -> &Option<Arc<Mutex<dyn super::effect_base::EffectParameterTrait>>>;
    fn parameter_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::effect_base::EffectParameterTrait>>>;
    fn value(&self) -> &super::core::Vec4;
    fn value_mut(&mut self) -> &mut super::core::Vec4;
    fn field_flag_override0(&self) -> &u8;
    fn field_flag_override0_mut(&mut self) -> &mut u8;
}

impl EmitterParamGlobalComponentDataTrait for EmitterParamGlobalComponentData {
    fn parameter(&self) -> &Option<Arc<Mutex<dyn super::effect_base::EffectParameterTrait>>> {
        &self.parameter
    }
    fn parameter_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::effect_base::EffectParameterTrait>>> {
        &mut self.parameter
    }
    fn value(&self) -> &super::core::Vec4 {
        &self.value
    }
    fn value_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.value
    }
    fn field_flag_override0(&self) -> &u8 {
        &self.field_flag_override0
    }
    fn field_flag_override0_mut(&mut self) -> &mut u8 {
        &mut self.field_flag_override0
    }
}

impl VisualEnvironmentComponentDataTrait for EmitterParamGlobalComponentData {
    fn property_overrides(&self) -> &Vec<String> {
        self._glacier_base.property_overrides()
    }
    fn property_overrides_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.property_overrides_mut()
    }
}

impl super::entity::ComponentDataTrait for EmitterParamGlobalComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for EmitterParamGlobalComponentData {
}

impl super::core::DataBusPeerTrait for EmitterParamGlobalComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for EmitterParamGlobalComponentData {
}

impl super::core::DataContainerTrait for EmitterParamGlobalComponentData {
}

pub static EMITTERPARAMGLOBALCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EmitterParamGlobalComponentData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VISUALENVIRONMENTCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EmitterParamGlobalComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Parameter",
                flags: MemberInfoFlags::new(0),
                field_type: "EffectParameter",
                rust_offset: offset_of!(EmitterParamGlobalComponentData, parameter),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(EmitterParamGlobalComponentData, value),
            },
            FieldInfoData {
                name: "FieldFlagOverride0",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(EmitterParamGlobalComponentData, field_flag_override0),
            },
        ],
    }),
    array_type: Some(EMITTERPARAMGLOBALCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for EmitterParamGlobalComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        EMITTERPARAMGLOBALCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EMITTERPARAMGLOBALCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EmitterParamGlobalComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("EmitterParamGlobalComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EmitterParamComponentData {
    pub _glacier_base: VisualEnvironmentComponentData,
    pub parameter: super::world_base::EmitterParamOverride,
    pub value: f32,
    pub field_flag_override0: u8,
}

pub trait EmitterParamComponentDataTrait: VisualEnvironmentComponentDataTrait {
    fn parameter(&self) -> &super::world_base::EmitterParamOverride;
    fn parameter_mut(&mut self) -> &mut super::world_base::EmitterParamOverride;
    fn value(&self) -> &f32;
    fn value_mut(&mut self) -> &mut f32;
    fn field_flag_override0(&self) -> &u8;
    fn field_flag_override0_mut(&mut self) -> &mut u8;
}

impl EmitterParamComponentDataTrait for EmitterParamComponentData {
    fn parameter(&self) -> &super::world_base::EmitterParamOverride {
        &self.parameter
    }
    fn parameter_mut(&mut self) -> &mut super::world_base::EmitterParamOverride {
        &mut self.parameter
    }
    fn value(&self) -> &f32 {
        &self.value
    }
    fn value_mut(&mut self) -> &mut f32 {
        &mut self.value
    }
    fn field_flag_override0(&self) -> &u8 {
        &self.field_flag_override0
    }
    fn field_flag_override0_mut(&mut self) -> &mut u8 {
        &mut self.field_flag_override0
    }
}

impl VisualEnvironmentComponentDataTrait for EmitterParamComponentData {
    fn property_overrides(&self) -> &Vec<String> {
        self._glacier_base.property_overrides()
    }
    fn property_overrides_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.property_overrides_mut()
    }
}

impl super::entity::ComponentDataTrait for EmitterParamComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for EmitterParamComponentData {
}

impl super::core::DataBusPeerTrait for EmitterParamComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for EmitterParamComponentData {
}

impl super::core::DataContainerTrait for EmitterParamComponentData {
}

pub static EMITTERPARAMCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EmitterParamComponentData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VISUALENVIRONMENTCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EmitterParamComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Parameter",
                flags: MemberInfoFlags::new(0),
                field_type: "EmitterParamOverride",
                rust_offset: offset_of!(EmitterParamComponentData, parameter),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EmitterParamComponentData, value),
            },
            FieldInfoData {
                name: "FieldFlagOverride0",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(EmitterParamComponentData, field_flag_override0),
            },
        ],
    }),
    array_type: Some(EMITTERPARAMCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for EmitterParamComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        EMITTERPARAMCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EMITTERPARAMCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EmitterParamComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("EmitterParamComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RaytraceReflectionComponentData {
    pub _glacier_base: VisualEnvironmentComponentData,
    pub enable: bool,
    pub min_smoothness: f32,
    pub field_flag_override0: u8,
}

pub trait RaytraceReflectionComponentDataTrait: VisualEnvironmentComponentDataTrait {
    fn enable(&self) -> &bool;
    fn enable_mut(&mut self) -> &mut bool;
    fn min_smoothness(&self) -> &f32;
    fn min_smoothness_mut(&mut self) -> &mut f32;
    fn field_flag_override0(&self) -> &u8;
    fn field_flag_override0_mut(&mut self) -> &mut u8;
}

impl RaytraceReflectionComponentDataTrait for RaytraceReflectionComponentData {
    fn enable(&self) -> &bool {
        &self.enable
    }
    fn enable_mut(&mut self) -> &mut bool {
        &mut self.enable
    }
    fn min_smoothness(&self) -> &f32 {
        &self.min_smoothness
    }
    fn min_smoothness_mut(&mut self) -> &mut f32 {
        &mut self.min_smoothness
    }
    fn field_flag_override0(&self) -> &u8 {
        &self.field_flag_override0
    }
    fn field_flag_override0_mut(&mut self) -> &mut u8 {
        &mut self.field_flag_override0
    }
}

impl VisualEnvironmentComponentDataTrait for RaytraceReflectionComponentData {
    fn property_overrides(&self) -> &Vec<String> {
        self._glacier_base.property_overrides()
    }
    fn property_overrides_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.property_overrides_mut()
    }
}

impl super::entity::ComponentDataTrait for RaytraceReflectionComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for RaytraceReflectionComponentData {
}

impl super::core::DataBusPeerTrait for RaytraceReflectionComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for RaytraceReflectionComponentData {
}

impl super::core::DataContainerTrait for RaytraceReflectionComponentData {
}

pub static RAYTRACEREFLECTIONCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RaytraceReflectionComponentData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VISUALENVIRONMENTCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RaytraceReflectionComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RaytraceReflectionComponentData, enable),
            },
            FieldInfoData {
                name: "MinSmoothness",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RaytraceReflectionComponentData, min_smoothness),
            },
            FieldInfoData {
                name: "FieldFlagOverride0",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(RaytraceReflectionComponentData, field_flag_override0),
            },
        ],
    }),
    array_type: Some(RAYTRACEREFLECTIONCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for RaytraceReflectionComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        RAYTRACEREFLECTIONCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RAYTRACEREFLECTIONCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RaytraceReflectionComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("RaytraceReflectionComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ScreenSpaceRaytraceComponentData {
    pub _glacier_base: VisualEnvironmentComponentData,
    pub raytrace_enable: bool,
    pub camera_fade_start: f32,
    pub camera_fade_length: f32,
    pub radial_fade_start: f32,
    pub radial_fade_length: f32,
    pub distance_fade_start: f32,
    pub distance_fade_length: f32,
    pub screen_fade_start: f32,
    pub screen_fade_length: f32,
    pub border_fade_start: f32,
    pub border_fade_length: f32,
    pub mirror_fade_start: f32,
    pub mirror_fade_length: f32,
    pub thickness_fade_start: f32,
    pub thickness_fade_length: f32,
    pub roughness_fade_start: f32,
    pub roughness_fade_length: f32,
    pub normal_fade_texture: Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>,
    pub min_samples: u32,
    pub max_samples: u32,
    pub temporal_samples: u32,
    pub temporal_period: u32,
    pub min_roughness: f32,
    pub max_roughness: f32,
    pub resolve_samples: u32,
    pub noise_threshold: f32,
    pub clamp_threshold: f32,
    pub importance_sampling_bias: f32,
    pub filter_bias: f32,
    pub filter_angular_bias: f32,
    pub temporal_filter_responsiveness: f32,
    pub field_flag_override0: u32,
}

pub trait ScreenSpaceRaytraceComponentDataTrait: VisualEnvironmentComponentDataTrait {
    fn raytrace_enable(&self) -> &bool;
    fn raytrace_enable_mut(&mut self) -> &mut bool;
    fn camera_fade_start(&self) -> &f32;
    fn camera_fade_start_mut(&mut self) -> &mut f32;
    fn camera_fade_length(&self) -> &f32;
    fn camera_fade_length_mut(&mut self) -> &mut f32;
    fn radial_fade_start(&self) -> &f32;
    fn radial_fade_start_mut(&mut self) -> &mut f32;
    fn radial_fade_length(&self) -> &f32;
    fn radial_fade_length_mut(&mut self) -> &mut f32;
    fn distance_fade_start(&self) -> &f32;
    fn distance_fade_start_mut(&mut self) -> &mut f32;
    fn distance_fade_length(&self) -> &f32;
    fn distance_fade_length_mut(&mut self) -> &mut f32;
    fn screen_fade_start(&self) -> &f32;
    fn screen_fade_start_mut(&mut self) -> &mut f32;
    fn screen_fade_length(&self) -> &f32;
    fn screen_fade_length_mut(&mut self) -> &mut f32;
    fn border_fade_start(&self) -> &f32;
    fn border_fade_start_mut(&mut self) -> &mut f32;
    fn border_fade_length(&self) -> &f32;
    fn border_fade_length_mut(&mut self) -> &mut f32;
    fn mirror_fade_start(&self) -> &f32;
    fn mirror_fade_start_mut(&mut self) -> &mut f32;
    fn mirror_fade_length(&self) -> &f32;
    fn mirror_fade_length_mut(&mut self) -> &mut f32;
    fn thickness_fade_start(&self) -> &f32;
    fn thickness_fade_start_mut(&mut self) -> &mut f32;
    fn thickness_fade_length(&self) -> &f32;
    fn thickness_fade_length_mut(&mut self) -> &mut f32;
    fn roughness_fade_start(&self) -> &f32;
    fn roughness_fade_start_mut(&mut self) -> &mut f32;
    fn roughness_fade_length(&self) -> &f32;
    fn roughness_fade_length_mut(&mut self) -> &mut f32;
    fn normal_fade_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn normal_fade_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn min_samples(&self) -> &u32;
    fn min_samples_mut(&mut self) -> &mut u32;
    fn max_samples(&self) -> &u32;
    fn max_samples_mut(&mut self) -> &mut u32;
    fn temporal_samples(&self) -> &u32;
    fn temporal_samples_mut(&mut self) -> &mut u32;
    fn temporal_period(&self) -> &u32;
    fn temporal_period_mut(&mut self) -> &mut u32;
    fn min_roughness(&self) -> &f32;
    fn min_roughness_mut(&mut self) -> &mut f32;
    fn max_roughness(&self) -> &f32;
    fn max_roughness_mut(&mut self) -> &mut f32;
    fn resolve_samples(&self) -> &u32;
    fn resolve_samples_mut(&mut self) -> &mut u32;
    fn noise_threshold(&self) -> &f32;
    fn noise_threshold_mut(&mut self) -> &mut f32;
    fn clamp_threshold(&self) -> &f32;
    fn clamp_threshold_mut(&mut self) -> &mut f32;
    fn importance_sampling_bias(&self) -> &f32;
    fn importance_sampling_bias_mut(&mut self) -> &mut f32;
    fn filter_bias(&self) -> &f32;
    fn filter_bias_mut(&mut self) -> &mut f32;
    fn filter_angular_bias(&self) -> &f32;
    fn filter_angular_bias_mut(&mut self) -> &mut f32;
    fn temporal_filter_responsiveness(&self) -> &f32;
    fn temporal_filter_responsiveness_mut(&mut self) -> &mut f32;
    fn field_flag_override0(&self) -> &u32;
    fn field_flag_override0_mut(&mut self) -> &mut u32;
}

impl ScreenSpaceRaytraceComponentDataTrait for ScreenSpaceRaytraceComponentData {
    fn raytrace_enable(&self) -> &bool {
        &self.raytrace_enable
    }
    fn raytrace_enable_mut(&mut self) -> &mut bool {
        &mut self.raytrace_enable
    }
    fn camera_fade_start(&self) -> &f32 {
        &self.camera_fade_start
    }
    fn camera_fade_start_mut(&mut self) -> &mut f32 {
        &mut self.camera_fade_start
    }
    fn camera_fade_length(&self) -> &f32 {
        &self.camera_fade_length
    }
    fn camera_fade_length_mut(&mut self) -> &mut f32 {
        &mut self.camera_fade_length
    }
    fn radial_fade_start(&self) -> &f32 {
        &self.radial_fade_start
    }
    fn radial_fade_start_mut(&mut self) -> &mut f32 {
        &mut self.radial_fade_start
    }
    fn radial_fade_length(&self) -> &f32 {
        &self.radial_fade_length
    }
    fn radial_fade_length_mut(&mut self) -> &mut f32 {
        &mut self.radial_fade_length
    }
    fn distance_fade_start(&self) -> &f32 {
        &self.distance_fade_start
    }
    fn distance_fade_start_mut(&mut self) -> &mut f32 {
        &mut self.distance_fade_start
    }
    fn distance_fade_length(&self) -> &f32 {
        &self.distance_fade_length
    }
    fn distance_fade_length_mut(&mut self) -> &mut f32 {
        &mut self.distance_fade_length
    }
    fn screen_fade_start(&self) -> &f32 {
        &self.screen_fade_start
    }
    fn screen_fade_start_mut(&mut self) -> &mut f32 {
        &mut self.screen_fade_start
    }
    fn screen_fade_length(&self) -> &f32 {
        &self.screen_fade_length
    }
    fn screen_fade_length_mut(&mut self) -> &mut f32 {
        &mut self.screen_fade_length
    }
    fn border_fade_start(&self) -> &f32 {
        &self.border_fade_start
    }
    fn border_fade_start_mut(&mut self) -> &mut f32 {
        &mut self.border_fade_start
    }
    fn border_fade_length(&self) -> &f32 {
        &self.border_fade_length
    }
    fn border_fade_length_mut(&mut self) -> &mut f32 {
        &mut self.border_fade_length
    }
    fn mirror_fade_start(&self) -> &f32 {
        &self.mirror_fade_start
    }
    fn mirror_fade_start_mut(&mut self) -> &mut f32 {
        &mut self.mirror_fade_start
    }
    fn mirror_fade_length(&self) -> &f32 {
        &self.mirror_fade_length
    }
    fn mirror_fade_length_mut(&mut self) -> &mut f32 {
        &mut self.mirror_fade_length
    }
    fn thickness_fade_start(&self) -> &f32 {
        &self.thickness_fade_start
    }
    fn thickness_fade_start_mut(&mut self) -> &mut f32 {
        &mut self.thickness_fade_start
    }
    fn thickness_fade_length(&self) -> &f32 {
        &self.thickness_fade_length
    }
    fn thickness_fade_length_mut(&mut self) -> &mut f32 {
        &mut self.thickness_fade_length
    }
    fn roughness_fade_start(&self) -> &f32 {
        &self.roughness_fade_start
    }
    fn roughness_fade_start_mut(&mut self) -> &mut f32 {
        &mut self.roughness_fade_start
    }
    fn roughness_fade_length(&self) -> &f32 {
        &self.roughness_fade_length
    }
    fn roughness_fade_length_mut(&mut self) -> &mut f32 {
        &mut self.roughness_fade_length
    }
    fn normal_fade_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &self.normal_fade_texture
    }
    fn normal_fade_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &mut self.normal_fade_texture
    }
    fn min_samples(&self) -> &u32 {
        &self.min_samples
    }
    fn min_samples_mut(&mut self) -> &mut u32 {
        &mut self.min_samples
    }
    fn max_samples(&self) -> &u32 {
        &self.max_samples
    }
    fn max_samples_mut(&mut self) -> &mut u32 {
        &mut self.max_samples
    }
    fn temporal_samples(&self) -> &u32 {
        &self.temporal_samples
    }
    fn temporal_samples_mut(&mut self) -> &mut u32 {
        &mut self.temporal_samples
    }
    fn temporal_period(&self) -> &u32 {
        &self.temporal_period
    }
    fn temporal_period_mut(&mut self) -> &mut u32 {
        &mut self.temporal_period
    }
    fn min_roughness(&self) -> &f32 {
        &self.min_roughness
    }
    fn min_roughness_mut(&mut self) -> &mut f32 {
        &mut self.min_roughness
    }
    fn max_roughness(&self) -> &f32 {
        &self.max_roughness
    }
    fn max_roughness_mut(&mut self) -> &mut f32 {
        &mut self.max_roughness
    }
    fn resolve_samples(&self) -> &u32 {
        &self.resolve_samples
    }
    fn resolve_samples_mut(&mut self) -> &mut u32 {
        &mut self.resolve_samples
    }
    fn noise_threshold(&self) -> &f32 {
        &self.noise_threshold
    }
    fn noise_threshold_mut(&mut self) -> &mut f32 {
        &mut self.noise_threshold
    }
    fn clamp_threshold(&self) -> &f32 {
        &self.clamp_threshold
    }
    fn clamp_threshold_mut(&mut self) -> &mut f32 {
        &mut self.clamp_threshold
    }
    fn importance_sampling_bias(&self) -> &f32 {
        &self.importance_sampling_bias
    }
    fn importance_sampling_bias_mut(&mut self) -> &mut f32 {
        &mut self.importance_sampling_bias
    }
    fn filter_bias(&self) -> &f32 {
        &self.filter_bias
    }
    fn filter_bias_mut(&mut self) -> &mut f32 {
        &mut self.filter_bias
    }
    fn filter_angular_bias(&self) -> &f32 {
        &self.filter_angular_bias
    }
    fn filter_angular_bias_mut(&mut self) -> &mut f32 {
        &mut self.filter_angular_bias
    }
    fn temporal_filter_responsiveness(&self) -> &f32 {
        &self.temporal_filter_responsiveness
    }
    fn temporal_filter_responsiveness_mut(&mut self) -> &mut f32 {
        &mut self.temporal_filter_responsiveness
    }
    fn field_flag_override0(&self) -> &u32 {
        &self.field_flag_override0
    }
    fn field_flag_override0_mut(&mut self) -> &mut u32 {
        &mut self.field_flag_override0
    }
}

impl VisualEnvironmentComponentDataTrait for ScreenSpaceRaytraceComponentData {
    fn property_overrides(&self) -> &Vec<String> {
        self._glacier_base.property_overrides()
    }
    fn property_overrides_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.property_overrides_mut()
    }
}

impl super::entity::ComponentDataTrait for ScreenSpaceRaytraceComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for ScreenSpaceRaytraceComponentData {
}

impl super::core::DataBusPeerTrait for ScreenSpaceRaytraceComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ScreenSpaceRaytraceComponentData {
}

impl super::core::DataContainerTrait for ScreenSpaceRaytraceComponentData {
}

pub static SCREENSPACERAYTRACECOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScreenSpaceRaytraceComponentData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VISUALENVIRONMENTCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ScreenSpaceRaytraceComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "RaytraceEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ScreenSpaceRaytraceComponentData, raytrace_enable),
            },
            FieldInfoData {
                name: "CameraFadeStart",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ScreenSpaceRaytraceComponentData, camera_fade_start),
            },
            FieldInfoData {
                name: "CameraFadeLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ScreenSpaceRaytraceComponentData, camera_fade_length),
            },
            FieldInfoData {
                name: "RadialFadeStart",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ScreenSpaceRaytraceComponentData, radial_fade_start),
            },
            FieldInfoData {
                name: "RadialFadeLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ScreenSpaceRaytraceComponentData, radial_fade_length),
            },
            FieldInfoData {
                name: "DistanceFadeStart",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ScreenSpaceRaytraceComponentData, distance_fade_start),
            },
            FieldInfoData {
                name: "DistanceFadeLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ScreenSpaceRaytraceComponentData, distance_fade_length),
            },
            FieldInfoData {
                name: "ScreenFadeStart",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ScreenSpaceRaytraceComponentData, screen_fade_start),
            },
            FieldInfoData {
                name: "ScreenFadeLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ScreenSpaceRaytraceComponentData, screen_fade_length),
            },
            FieldInfoData {
                name: "BorderFadeStart",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ScreenSpaceRaytraceComponentData, border_fade_start),
            },
            FieldInfoData {
                name: "BorderFadeLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ScreenSpaceRaytraceComponentData, border_fade_length),
            },
            FieldInfoData {
                name: "MirrorFadeStart",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ScreenSpaceRaytraceComponentData, mirror_fade_start),
            },
            FieldInfoData {
                name: "MirrorFadeLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ScreenSpaceRaytraceComponentData, mirror_fade_length),
            },
            FieldInfoData {
                name: "ThicknessFadeStart",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ScreenSpaceRaytraceComponentData, thickness_fade_start),
            },
            FieldInfoData {
                name: "ThicknessFadeLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ScreenSpaceRaytraceComponentData, thickness_fade_length),
            },
            FieldInfoData {
                name: "RoughnessFadeStart",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ScreenSpaceRaytraceComponentData, roughness_fade_start),
            },
            FieldInfoData {
                name: "RoughnessFadeLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ScreenSpaceRaytraceComponentData, roughness_fade_length),
            },
            FieldInfoData {
                name: "NormalFadeTexture",
                flags: MemberInfoFlags::new(0),
                field_type: "TextureBaseAsset",
                rust_offset: offset_of!(ScreenSpaceRaytraceComponentData, normal_fade_texture),
            },
            FieldInfoData {
                name: "MinSamples",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(ScreenSpaceRaytraceComponentData, min_samples),
            },
            FieldInfoData {
                name: "MaxSamples",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(ScreenSpaceRaytraceComponentData, max_samples),
            },
            FieldInfoData {
                name: "TemporalSamples",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(ScreenSpaceRaytraceComponentData, temporal_samples),
            },
            FieldInfoData {
                name: "TemporalPeriod",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(ScreenSpaceRaytraceComponentData, temporal_period),
            },
            FieldInfoData {
                name: "MinRoughness",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ScreenSpaceRaytraceComponentData, min_roughness),
            },
            FieldInfoData {
                name: "MaxRoughness",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ScreenSpaceRaytraceComponentData, max_roughness),
            },
            FieldInfoData {
                name: "ResolveSamples",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(ScreenSpaceRaytraceComponentData, resolve_samples),
            },
            FieldInfoData {
                name: "NoiseThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ScreenSpaceRaytraceComponentData, noise_threshold),
            },
            FieldInfoData {
                name: "ClampThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ScreenSpaceRaytraceComponentData, clamp_threshold),
            },
            FieldInfoData {
                name: "ImportanceSamplingBias",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ScreenSpaceRaytraceComponentData, importance_sampling_bias),
            },
            FieldInfoData {
                name: "FilterBias",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ScreenSpaceRaytraceComponentData, filter_bias),
            },
            FieldInfoData {
                name: "FilterAngularBias",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ScreenSpaceRaytraceComponentData, filter_angular_bias),
            },
            FieldInfoData {
                name: "TemporalFilterResponsiveness",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ScreenSpaceRaytraceComponentData, temporal_filter_responsiveness),
            },
            FieldInfoData {
                name: "FieldFlagOverride0",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(ScreenSpaceRaytraceComponentData, field_flag_override0),
            },
        ],
    }),
    array_type: Some(SCREENSPACERAYTRACECOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ScreenSpaceRaytraceComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        SCREENSPACERAYTRACECOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SCREENSPACERAYTRACECOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScreenSpaceRaytraceComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("ScreenSpaceRaytraceComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MotionBlurComponentData {
    pub _glacier_base: VisualEnvironmentComponentData,
    pub motion_blur_enable: bool,
    pub motion_blur_scale: f32,
    pub motion_blur_centered: bool,
    pub depth_check_max_distance: f32,
    pub radial_blur_enable: bool,
    pub radial_blur_center: super::core::Vec2,
    pub radial_blur_offset: f32,
    pub circular_offset_factor: f32,
    pub radial_blur_scale: f32,
    pub field_flag_override0: u16,
}

pub trait MotionBlurComponentDataTrait: VisualEnvironmentComponentDataTrait {
    fn motion_blur_enable(&self) -> &bool;
    fn motion_blur_enable_mut(&mut self) -> &mut bool;
    fn motion_blur_scale(&self) -> &f32;
    fn motion_blur_scale_mut(&mut self) -> &mut f32;
    fn motion_blur_centered(&self) -> &bool;
    fn motion_blur_centered_mut(&mut self) -> &mut bool;
    fn depth_check_max_distance(&self) -> &f32;
    fn depth_check_max_distance_mut(&mut self) -> &mut f32;
    fn radial_blur_enable(&self) -> &bool;
    fn radial_blur_enable_mut(&mut self) -> &mut bool;
    fn radial_blur_center(&self) -> &super::core::Vec2;
    fn radial_blur_center_mut(&mut self) -> &mut super::core::Vec2;
    fn radial_blur_offset(&self) -> &f32;
    fn radial_blur_offset_mut(&mut self) -> &mut f32;
    fn circular_offset_factor(&self) -> &f32;
    fn circular_offset_factor_mut(&mut self) -> &mut f32;
    fn radial_blur_scale(&self) -> &f32;
    fn radial_blur_scale_mut(&mut self) -> &mut f32;
    fn field_flag_override0(&self) -> &u16;
    fn field_flag_override0_mut(&mut self) -> &mut u16;
}

impl MotionBlurComponentDataTrait for MotionBlurComponentData {
    fn motion_blur_enable(&self) -> &bool {
        &self.motion_blur_enable
    }
    fn motion_blur_enable_mut(&mut self) -> &mut bool {
        &mut self.motion_blur_enable
    }
    fn motion_blur_scale(&self) -> &f32 {
        &self.motion_blur_scale
    }
    fn motion_blur_scale_mut(&mut self) -> &mut f32 {
        &mut self.motion_blur_scale
    }
    fn motion_blur_centered(&self) -> &bool {
        &self.motion_blur_centered
    }
    fn motion_blur_centered_mut(&mut self) -> &mut bool {
        &mut self.motion_blur_centered
    }
    fn depth_check_max_distance(&self) -> &f32 {
        &self.depth_check_max_distance
    }
    fn depth_check_max_distance_mut(&mut self) -> &mut f32 {
        &mut self.depth_check_max_distance
    }
    fn radial_blur_enable(&self) -> &bool {
        &self.radial_blur_enable
    }
    fn radial_blur_enable_mut(&mut self) -> &mut bool {
        &mut self.radial_blur_enable
    }
    fn radial_blur_center(&self) -> &super::core::Vec2 {
        &self.radial_blur_center
    }
    fn radial_blur_center_mut(&mut self) -> &mut super::core::Vec2 {
        &mut self.radial_blur_center
    }
    fn radial_blur_offset(&self) -> &f32 {
        &self.radial_blur_offset
    }
    fn radial_blur_offset_mut(&mut self) -> &mut f32 {
        &mut self.radial_blur_offset
    }
    fn circular_offset_factor(&self) -> &f32 {
        &self.circular_offset_factor
    }
    fn circular_offset_factor_mut(&mut self) -> &mut f32 {
        &mut self.circular_offset_factor
    }
    fn radial_blur_scale(&self) -> &f32 {
        &self.radial_blur_scale
    }
    fn radial_blur_scale_mut(&mut self) -> &mut f32 {
        &mut self.radial_blur_scale
    }
    fn field_flag_override0(&self) -> &u16 {
        &self.field_flag_override0
    }
    fn field_flag_override0_mut(&mut self) -> &mut u16 {
        &mut self.field_flag_override0
    }
}

impl VisualEnvironmentComponentDataTrait for MotionBlurComponentData {
    fn property_overrides(&self) -> &Vec<String> {
        self._glacier_base.property_overrides()
    }
    fn property_overrides_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.property_overrides_mut()
    }
}

impl super::entity::ComponentDataTrait for MotionBlurComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for MotionBlurComponentData {
}

impl super::core::DataBusPeerTrait for MotionBlurComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for MotionBlurComponentData {
}

impl super::core::DataContainerTrait for MotionBlurComponentData {
}

pub static MOTIONBLURCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MotionBlurComponentData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VISUALENVIRONMENTCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MotionBlurComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MotionBlurEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MotionBlurComponentData, motion_blur_enable),
            },
            FieldInfoData {
                name: "MotionBlurScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MotionBlurComponentData, motion_blur_scale),
            },
            FieldInfoData {
                name: "MotionBlurCentered",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MotionBlurComponentData, motion_blur_centered),
            },
            FieldInfoData {
                name: "DepthCheckMaxDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MotionBlurComponentData, depth_check_max_distance),
            },
            FieldInfoData {
                name: "RadialBlurEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MotionBlurComponentData, radial_blur_enable),
            },
            FieldInfoData {
                name: "RadialBlurCenter",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(MotionBlurComponentData, radial_blur_center),
            },
            FieldInfoData {
                name: "RadialBlurOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MotionBlurComponentData, radial_blur_offset),
            },
            FieldInfoData {
                name: "CircularOffsetFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MotionBlurComponentData, circular_offset_factor),
            },
            FieldInfoData {
                name: "RadialBlurScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MotionBlurComponentData, radial_blur_scale),
            },
            FieldInfoData {
                name: "FieldFlagOverride0",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint16",
                rust_offset: offset_of!(MotionBlurComponentData, field_flag_override0),
            },
        ],
    }),
    array_type: Some(MOTIONBLURCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for MotionBlurComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        MOTIONBLURCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MOTIONBLURCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MotionBlurComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("MotionBlurComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterLightingComponentData {
    pub _glacier_base: VisualEnvironmentComponentData,
    pub character_light_enable: bool,
    pub first_person_enable: bool,
    pub lock_to_camera_direction: bool,
    pub camera_up_rotation: f32,
    pub character_lighting_mode: super::world_base::CharacterLightingMode,
    pub blend_factor: f32,
    pub top_light: super::core::Vec3,
    pub bottom_light: super::core::Vec3,
    pub top_light_dir_x: f32,
    pub top_light_dir_y: f32,
    pub start_fade_distance: f32,
    pub end_fade_distance: f32,
    pub field_flag_override0: u16,
}

pub trait CharacterLightingComponentDataTrait: VisualEnvironmentComponentDataTrait {
    fn character_light_enable(&self) -> &bool;
    fn character_light_enable_mut(&mut self) -> &mut bool;
    fn first_person_enable(&self) -> &bool;
    fn first_person_enable_mut(&mut self) -> &mut bool;
    fn lock_to_camera_direction(&self) -> &bool;
    fn lock_to_camera_direction_mut(&mut self) -> &mut bool;
    fn camera_up_rotation(&self) -> &f32;
    fn camera_up_rotation_mut(&mut self) -> &mut f32;
    fn character_lighting_mode(&self) -> &super::world_base::CharacterLightingMode;
    fn character_lighting_mode_mut(&mut self) -> &mut super::world_base::CharacterLightingMode;
    fn blend_factor(&self) -> &f32;
    fn blend_factor_mut(&mut self) -> &mut f32;
    fn top_light(&self) -> &super::core::Vec3;
    fn top_light_mut(&mut self) -> &mut super::core::Vec3;
    fn bottom_light(&self) -> &super::core::Vec3;
    fn bottom_light_mut(&mut self) -> &mut super::core::Vec3;
    fn top_light_dir_x(&self) -> &f32;
    fn top_light_dir_x_mut(&mut self) -> &mut f32;
    fn top_light_dir_y(&self) -> &f32;
    fn top_light_dir_y_mut(&mut self) -> &mut f32;
    fn start_fade_distance(&self) -> &f32;
    fn start_fade_distance_mut(&mut self) -> &mut f32;
    fn end_fade_distance(&self) -> &f32;
    fn end_fade_distance_mut(&mut self) -> &mut f32;
    fn field_flag_override0(&self) -> &u16;
    fn field_flag_override0_mut(&mut self) -> &mut u16;
}

impl CharacterLightingComponentDataTrait for CharacterLightingComponentData {
    fn character_light_enable(&self) -> &bool {
        &self.character_light_enable
    }
    fn character_light_enable_mut(&mut self) -> &mut bool {
        &mut self.character_light_enable
    }
    fn first_person_enable(&self) -> &bool {
        &self.first_person_enable
    }
    fn first_person_enable_mut(&mut self) -> &mut bool {
        &mut self.first_person_enable
    }
    fn lock_to_camera_direction(&self) -> &bool {
        &self.lock_to_camera_direction
    }
    fn lock_to_camera_direction_mut(&mut self) -> &mut bool {
        &mut self.lock_to_camera_direction
    }
    fn camera_up_rotation(&self) -> &f32 {
        &self.camera_up_rotation
    }
    fn camera_up_rotation_mut(&mut self) -> &mut f32 {
        &mut self.camera_up_rotation
    }
    fn character_lighting_mode(&self) -> &super::world_base::CharacterLightingMode {
        &self.character_lighting_mode
    }
    fn character_lighting_mode_mut(&mut self) -> &mut super::world_base::CharacterLightingMode {
        &mut self.character_lighting_mode
    }
    fn blend_factor(&self) -> &f32 {
        &self.blend_factor
    }
    fn blend_factor_mut(&mut self) -> &mut f32 {
        &mut self.blend_factor
    }
    fn top_light(&self) -> &super::core::Vec3 {
        &self.top_light
    }
    fn top_light_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.top_light
    }
    fn bottom_light(&self) -> &super::core::Vec3 {
        &self.bottom_light
    }
    fn bottom_light_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.bottom_light
    }
    fn top_light_dir_x(&self) -> &f32 {
        &self.top_light_dir_x
    }
    fn top_light_dir_x_mut(&mut self) -> &mut f32 {
        &mut self.top_light_dir_x
    }
    fn top_light_dir_y(&self) -> &f32 {
        &self.top_light_dir_y
    }
    fn top_light_dir_y_mut(&mut self) -> &mut f32 {
        &mut self.top_light_dir_y
    }
    fn start_fade_distance(&self) -> &f32 {
        &self.start_fade_distance
    }
    fn start_fade_distance_mut(&mut self) -> &mut f32 {
        &mut self.start_fade_distance
    }
    fn end_fade_distance(&self) -> &f32 {
        &self.end_fade_distance
    }
    fn end_fade_distance_mut(&mut self) -> &mut f32 {
        &mut self.end_fade_distance
    }
    fn field_flag_override0(&self) -> &u16 {
        &self.field_flag_override0
    }
    fn field_flag_override0_mut(&mut self) -> &mut u16 {
        &mut self.field_flag_override0
    }
}

impl VisualEnvironmentComponentDataTrait for CharacterLightingComponentData {
    fn property_overrides(&self) -> &Vec<String> {
        self._glacier_base.property_overrides()
    }
    fn property_overrides_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.property_overrides_mut()
    }
}

impl super::entity::ComponentDataTrait for CharacterLightingComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for CharacterLightingComponentData {
}

impl super::core::DataBusPeerTrait for CharacterLightingComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CharacterLightingComponentData {
}

impl super::core::DataContainerTrait for CharacterLightingComponentData {
}

pub static CHARACTERLIGHTINGCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterLightingComponentData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VISUALENVIRONMENTCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterLightingComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "CharacterLightEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterLightingComponentData, character_light_enable),
            },
            FieldInfoData {
                name: "FirstPersonEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterLightingComponentData, first_person_enable),
            },
            FieldInfoData {
                name: "LockToCameraDirection",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterLightingComponentData, lock_to_camera_direction),
            },
            FieldInfoData {
                name: "CameraUpRotation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterLightingComponentData, camera_up_rotation),
            },
            FieldInfoData {
                name: "CharacterLightingMode",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterLightingMode",
                rust_offset: offset_of!(CharacterLightingComponentData, character_lighting_mode),
            },
            FieldInfoData {
                name: "BlendFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterLightingComponentData, blend_factor),
            },
            FieldInfoData {
                name: "TopLight",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(CharacterLightingComponentData, top_light),
            },
            FieldInfoData {
                name: "BottomLight",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(CharacterLightingComponentData, bottom_light),
            },
            FieldInfoData {
                name: "TopLightDirX",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterLightingComponentData, top_light_dir_x),
            },
            FieldInfoData {
                name: "TopLightDirY",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterLightingComponentData, top_light_dir_y),
            },
            FieldInfoData {
                name: "StartFadeDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterLightingComponentData, start_fade_distance),
            },
            FieldInfoData {
                name: "EndFadeDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterLightingComponentData, end_fade_distance),
            },
            FieldInfoData {
                name: "FieldFlagOverride0",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint16",
                rust_offset: offset_of!(CharacterLightingComponentData, field_flag_override0),
            },
        ],
    }),
    array_type: Some(CHARACTERLIGHTINGCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CharacterLightingComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERLIGHTINGCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERLIGHTINGCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterLightingComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("CharacterLightingComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DamageEffectComponentData {
    pub _glacier_base: VisualEnvironmentComponentData,
    pub shader: Option<Arc<Mutex<dyn super::render_base::SurfaceShaderBaseAssetTrait>>>,
    pub frame_width: f32,
    pub outer_frame_opacity: f32,
    pub inner_frame_opacity: f32,
    pub fallof_time: f32,
    pub min_damage_percentage_threshold: f32,
    pub max_opacity_damage_percentage: f32,
    pub start_critical_effect_health_threshold: f32,
    pub end_critical_effect_health_threshold: f32,
    pub debug_damage: bool,
    pub top_damage: super::core::Vec4,
    pub left_damage: super::core::Vec4,
    pub bottom_damage: super::core::Vec4,
    pub right_damage: super::core::Vec4,
    pub field_flag_override0: u16,
}

pub trait DamageEffectComponentDataTrait: VisualEnvironmentComponentDataTrait {
    fn shader(&self) -> &Option<Arc<Mutex<dyn super::render_base::SurfaceShaderBaseAssetTrait>>>;
    fn shader_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::SurfaceShaderBaseAssetTrait>>>;
    fn frame_width(&self) -> &f32;
    fn frame_width_mut(&mut self) -> &mut f32;
    fn outer_frame_opacity(&self) -> &f32;
    fn outer_frame_opacity_mut(&mut self) -> &mut f32;
    fn inner_frame_opacity(&self) -> &f32;
    fn inner_frame_opacity_mut(&mut self) -> &mut f32;
    fn fallof_time(&self) -> &f32;
    fn fallof_time_mut(&mut self) -> &mut f32;
    fn min_damage_percentage_threshold(&self) -> &f32;
    fn min_damage_percentage_threshold_mut(&mut self) -> &mut f32;
    fn max_opacity_damage_percentage(&self) -> &f32;
    fn max_opacity_damage_percentage_mut(&mut self) -> &mut f32;
    fn start_critical_effect_health_threshold(&self) -> &f32;
    fn start_critical_effect_health_threshold_mut(&mut self) -> &mut f32;
    fn end_critical_effect_health_threshold(&self) -> &f32;
    fn end_critical_effect_health_threshold_mut(&mut self) -> &mut f32;
    fn debug_damage(&self) -> &bool;
    fn debug_damage_mut(&mut self) -> &mut bool;
    fn top_damage(&self) -> &super::core::Vec4;
    fn top_damage_mut(&mut self) -> &mut super::core::Vec4;
    fn left_damage(&self) -> &super::core::Vec4;
    fn left_damage_mut(&mut self) -> &mut super::core::Vec4;
    fn bottom_damage(&self) -> &super::core::Vec4;
    fn bottom_damage_mut(&mut self) -> &mut super::core::Vec4;
    fn right_damage(&self) -> &super::core::Vec4;
    fn right_damage_mut(&mut self) -> &mut super::core::Vec4;
    fn field_flag_override0(&self) -> &u16;
    fn field_flag_override0_mut(&mut self) -> &mut u16;
}

impl DamageEffectComponentDataTrait for DamageEffectComponentData {
    fn shader(&self) -> &Option<Arc<Mutex<dyn super::render_base::SurfaceShaderBaseAssetTrait>>> {
        &self.shader
    }
    fn shader_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::SurfaceShaderBaseAssetTrait>>> {
        &mut self.shader
    }
    fn frame_width(&self) -> &f32 {
        &self.frame_width
    }
    fn frame_width_mut(&mut self) -> &mut f32 {
        &mut self.frame_width
    }
    fn outer_frame_opacity(&self) -> &f32 {
        &self.outer_frame_opacity
    }
    fn outer_frame_opacity_mut(&mut self) -> &mut f32 {
        &mut self.outer_frame_opacity
    }
    fn inner_frame_opacity(&self) -> &f32 {
        &self.inner_frame_opacity
    }
    fn inner_frame_opacity_mut(&mut self) -> &mut f32 {
        &mut self.inner_frame_opacity
    }
    fn fallof_time(&self) -> &f32 {
        &self.fallof_time
    }
    fn fallof_time_mut(&mut self) -> &mut f32 {
        &mut self.fallof_time
    }
    fn min_damage_percentage_threshold(&self) -> &f32 {
        &self.min_damage_percentage_threshold
    }
    fn min_damage_percentage_threshold_mut(&mut self) -> &mut f32 {
        &mut self.min_damage_percentage_threshold
    }
    fn max_opacity_damage_percentage(&self) -> &f32 {
        &self.max_opacity_damage_percentage
    }
    fn max_opacity_damage_percentage_mut(&mut self) -> &mut f32 {
        &mut self.max_opacity_damage_percentage
    }
    fn start_critical_effect_health_threshold(&self) -> &f32 {
        &self.start_critical_effect_health_threshold
    }
    fn start_critical_effect_health_threshold_mut(&mut self) -> &mut f32 {
        &mut self.start_critical_effect_health_threshold
    }
    fn end_critical_effect_health_threshold(&self) -> &f32 {
        &self.end_critical_effect_health_threshold
    }
    fn end_critical_effect_health_threshold_mut(&mut self) -> &mut f32 {
        &mut self.end_critical_effect_health_threshold
    }
    fn debug_damage(&self) -> &bool {
        &self.debug_damage
    }
    fn debug_damage_mut(&mut self) -> &mut bool {
        &mut self.debug_damage
    }
    fn top_damage(&self) -> &super::core::Vec4 {
        &self.top_damage
    }
    fn top_damage_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.top_damage
    }
    fn left_damage(&self) -> &super::core::Vec4 {
        &self.left_damage
    }
    fn left_damage_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.left_damage
    }
    fn bottom_damage(&self) -> &super::core::Vec4 {
        &self.bottom_damage
    }
    fn bottom_damage_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.bottom_damage
    }
    fn right_damage(&self) -> &super::core::Vec4 {
        &self.right_damage
    }
    fn right_damage_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.right_damage
    }
    fn field_flag_override0(&self) -> &u16 {
        &self.field_flag_override0
    }
    fn field_flag_override0_mut(&mut self) -> &mut u16 {
        &mut self.field_flag_override0
    }
}

impl VisualEnvironmentComponentDataTrait for DamageEffectComponentData {
    fn property_overrides(&self) -> &Vec<String> {
        self._glacier_base.property_overrides()
    }
    fn property_overrides_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.property_overrides_mut()
    }
}

impl super::entity::ComponentDataTrait for DamageEffectComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for DamageEffectComponentData {
}

impl super::core::DataBusPeerTrait for DamageEffectComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for DamageEffectComponentData {
}

impl super::core::DataContainerTrait for DamageEffectComponentData {
}

pub static DAMAGEEFFECTCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DamageEffectComponentData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VISUALENVIRONMENTCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DamageEffectComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Shader",
                flags: MemberInfoFlags::new(0),
                field_type: "SurfaceShaderBaseAsset",
                rust_offset: offset_of!(DamageEffectComponentData, shader),
            },
            FieldInfoData {
                name: "FrameWidth",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DamageEffectComponentData, frame_width),
            },
            FieldInfoData {
                name: "OuterFrameOpacity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DamageEffectComponentData, outer_frame_opacity),
            },
            FieldInfoData {
                name: "InnerFrameOpacity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DamageEffectComponentData, inner_frame_opacity),
            },
            FieldInfoData {
                name: "FallofTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DamageEffectComponentData, fallof_time),
            },
            FieldInfoData {
                name: "MinDamagePercentageThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DamageEffectComponentData, min_damage_percentage_threshold),
            },
            FieldInfoData {
                name: "MaxOpacityDamagePercentage",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DamageEffectComponentData, max_opacity_damage_percentage),
            },
            FieldInfoData {
                name: "StartCriticalEffectHealthThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DamageEffectComponentData, start_critical_effect_health_threshold),
            },
            FieldInfoData {
                name: "EndCriticalEffectHealthThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DamageEffectComponentData, end_critical_effect_health_threshold),
            },
            FieldInfoData {
                name: "DebugDamage",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DamageEffectComponentData, debug_damage),
            },
            FieldInfoData {
                name: "TopDamage",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(DamageEffectComponentData, top_damage),
            },
            FieldInfoData {
                name: "LeftDamage",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(DamageEffectComponentData, left_damage),
            },
            FieldInfoData {
                name: "BottomDamage",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(DamageEffectComponentData, bottom_damage),
            },
            FieldInfoData {
                name: "RightDamage",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(DamageEffectComponentData, right_damage),
            },
            FieldInfoData {
                name: "FieldFlagOverride0",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint16",
                rust_offset: offset_of!(DamageEffectComponentData, field_flag_override0),
            },
        ],
    }),
    array_type: Some(DAMAGEEFFECTCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for DamageEffectComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        DAMAGEEFFECTCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DAMAGEEFFECTCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DamageEffectComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("DamageEffectComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ScreenEffectComponentData {
    pub _glacier_base: VisualEnvironmentComponentData,
    pub frame_type: super::world_base::ScreenEffectFrameType,
    pub shader: Option<Arc<Mutex<dyn super::render_base::SurfaceShaderBaseAssetTrait>>>,
    pub frame_width: f32,
    pub outer_frame_opacity: f32,
    pub inner_frame_opacity: f32,
    pub angle: f32,
    pub screen_effect_params: super::core::Vec4,
    pub field_flag_override0: u16,
}

pub trait ScreenEffectComponentDataTrait: VisualEnvironmentComponentDataTrait {
    fn frame_type(&self) -> &super::world_base::ScreenEffectFrameType;
    fn frame_type_mut(&mut self) -> &mut super::world_base::ScreenEffectFrameType;
    fn shader(&self) -> &Option<Arc<Mutex<dyn super::render_base::SurfaceShaderBaseAssetTrait>>>;
    fn shader_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::SurfaceShaderBaseAssetTrait>>>;
    fn frame_width(&self) -> &f32;
    fn frame_width_mut(&mut self) -> &mut f32;
    fn outer_frame_opacity(&self) -> &f32;
    fn outer_frame_opacity_mut(&mut self) -> &mut f32;
    fn inner_frame_opacity(&self) -> &f32;
    fn inner_frame_opacity_mut(&mut self) -> &mut f32;
    fn angle(&self) -> &f32;
    fn angle_mut(&mut self) -> &mut f32;
    fn screen_effect_params(&self) -> &super::core::Vec4;
    fn screen_effect_params_mut(&mut self) -> &mut super::core::Vec4;
    fn field_flag_override0(&self) -> &u16;
    fn field_flag_override0_mut(&mut self) -> &mut u16;
}

impl ScreenEffectComponentDataTrait for ScreenEffectComponentData {
    fn frame_type(&self) -> &super::world_base::ScreenEffectFrameType {
        &self.frame_type
    }
    fn frame_type_mut(&mut self) -> &mut super::world_base::ScreenEffectFrameType {
        &mut self.frame_type
    }
    fn shader(&self) -> &Option<Arc<Mutex<dyn super::render_base::SurfaceShaderBaseAssetTrait>>> {
        &self.shader
    }
    fn shader_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::SurfaceShaderBaseAssetTrait>>> {
        &mut self.shader
    }
    fn frame_width(&self) -> &f32 {
        &self.frame_width
    }
    fn frame_width_mut(&mut self) -> &mut f32 {
        &mut self.frame_width
    }
    fn outer_frame_opacity(&self) -> &f32 {
        &self.outer_frame_opacity
    }
    fn outer_frame_opacity_mut(&mut self) -> &mut f32 {
        &mut self.outer_frame_opacity
    }
    fn inner_frame_opacity(&self) -> &f32 {
        &self.inner_frame_opacity
    }
    fn inner_frame_opacity_mut(&mut self) -> &mut f32 {
        &mut self.inner_frame_opacity
    }
    fn angle(&self) -> &f32 {
        &self.angle
    }
    fn angle_mut(&mut self) -> &mut f32 {
        &mut self.angle
    }
    fn screen_effect_params(&self) -> &super::core::Vec4 {
        &self.screen_effect_params
    }
    fn screen_effect_params_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.screen_effect_params
    }
    fn field_flag_override0(&self) -> &u16 {
        &self.field_flag_override0
    }
    fn field_flag_override0_mut(&mut self) -> &mut u16 {
        &mut self.field_flag_override0
    }
}

impl VisualEnvironmentComponentDataTrait for ScreenEffectComponentData {
    fn property_overrides(&self) -> &Vec<String> {
        self._glacier_base.property_overrides()
    }
    fn property_overrides_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.property_overrides_mut()
    }
}

impl super::entity::ComponentDataTrait for ScreenEffectComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for ScreenEffectComponentData {
}

impl super::core::DataBusPeerTrait for ScreenEffectComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ScreenEffectComponentData {
}

impl super::core::DataContainerTrait for ScreenEffectComponentData {
}

pub static SCREENEFFECTCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScreenEffectComponentData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VISUALENVIRONMENTCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ScreenEffectComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "FrameType",
                flags: MemberInfoFlags::new(0),
                field_type: "ScreenEffectFrameType",
                rust_offset: offset_of!(ScreenEffectComponentData, frame_type),
            },
            FieldInfoData {
                name: "Shader",
                flags: MemberInfoFlags::new(0),
                field_type: "SurfaceShaderBaseAsset",
                rust_offset: offset_of!(ScreenEffectComponentData, shader),
            },
            FieldInfoData {
                name: "FrameWidth",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ScreenEffectComponentData, frame_width),
            },
            FieldInfoData {
                name: "OuterFrameOpacity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ScreenEffectComponentData, outer_frame_opacity),
            },
            FieldInfoData {
                name: "InnerFrameOpacity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ScreenEffectComponentData, inner_frame_opacity),
            },
            FieldInfoData {
                name: "Angle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ScreenEffectComponentData, angle),
            },
            FieldInfoData {
                name: "ScreenEffectParams",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(ScreenEffectComponentData, screen_effect_params),
            },
            FieldInfoData {
                name: "FieldFlagOverride0",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint16",
                rust_offset: offset_of!(ScreenEffectComponentData, field_flag_override0),
            },
        ],
    }),
    array_type: Some(SCREENEFFECTCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ScreenEffectComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        SCREENEFFECTCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SCREENEFFECTCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScreenEffectComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("ScreenEffectComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ShadowsComponentData {
    pub _glacier_base: VisualEnvironmentComponentData,
    pub def_sun_shadowmap_view_distance: f32,
    pub sun_shadowmap_view_distance: super::core::QualityScalableFloat,
    pub sun_shadowmap_extrusion_length: f32,
    pub sun_shadowmap_slice_scheme_weight: f32,
    pub sun_shadowmap_first_slice_scale: f32,
    pub sun_shadowmap_first_slice_extrusion_length: f32,
    pub smooth_transition_to_distant_shadows: bool,
    pub sun_shadowmap_slice_count_offset: super::core::QualityScalableInt,
    pub sun_shadowmap_slice_count_min: super::core::QualityScalableInt,
    pub sun_shadowmap_slice_count_max: super::core::QualityScalableInt,
    pub sun_shadowmap_slice_resolution_scale: super::core::QualityScalableFloat,
    pub field_flag_override0: u16,
}

pub trait ShadowsComponentDataTrait: VisualEnvironmentComponentDataTrait {
    fn def_sun_shadowmap_view_distance(&self) -> &f32;
    fn def_sun_shadowmap_view_distance_mut(&mut self) -> &mut f32;
    fn sun_shadowmap_view_distance(&self) -> &super::core::QualityScalableFloat;
    fn sun_shadowmap_view_distance_mut(&mut self) -> &mut super::core::QualityScalableFloat;
    fn sun_shadowmap_extrusion_length(&self) -> &f32;
    fn sun_shadowmap_extrusion_length_mut(&mut self) -> &mut f32;
    fn sun_shadowmap_slice_scheme_weight(&self) -> &f32;
    fn sun_shadowmap_slice_scheme_weight_mut(&mut self) -> &mut f32;
    fn sun_shadowmap_first_slice_scale(&self) -> &f32;
    fn sun_shadowmap_first_slice_scale_mut(&mut self) -> &mut f32;
    fn sun_shadowmap_first_slice_extrusion_length(&self) -> &f32;
    fn sun_shadowmap_first_slice_extrusion_length_mut(&mut self) -> &mut f32;
    fn smooth_transition_to_distant_shadows(&self) -> &bool;
    fn smooth_transition_to_distant_shadows_mut(&mut self) -> &mut bool;
    fn sun_shadowmap_slice_count_offset(&self) -> &super::core::QualityScalableInt;
    fn sun_shadowmap_slice_count_offset_mut(&mut self) -> &mut super::core::QualityScalableInt;
    fn sun_shadowmap_slice_count_min(&self) -> &super::core::QualityScalableInt;
    fn sun_shadowmap_slice_count_min_mut(&mut self) -> &mut super::core::QualityScalableInt;
    fn sun_shadowmap_slice_count_max(&self) -> &super::core::QualityScalableInt;
    fn sun_shadowmap_slice_count_max_mut(&mut self) -> &mut super::core::QualityScalableInt;
    fn sun_shadowmap_slice_resolution_scale(&self) -> &super::core::QualityScalableFloat;
    fn sun_shadowmap_slice_resolution_scale_mut(&mut self) -> &mut super::core::QualityScalableFloat;
    fn field_flag_override0(&self) -> &u16;
    fn field_flag_override0_mut(&mut self) -> &mut u16;
}

impl ShadowsComponentDataTrait for ShadowsComponentData {
    fn def_sun_shadowmap_view_distance(&self) -> &f32 {
        &self.def_sun_shadowmap_view_distance
    }
    fn def_sun_shadowmap_view_distance_mut(&mut self) -> &mut f32 {
        &mut self.def_sun_shadowmap_view_distance
    }
    fn sun_shadowmap_view_distance(&self) -> &super::core::QualityScalableFloat {
        &self.sun_shadowmap_view_distance
    }
    fn sun_shadowmap_view_distance_mut(&mut self) -> &mut super::core::QualityScalableFloat {
        &mut self.sun_shadowmap_view_distance
    }
    fn sun_shadowmap_extrusion_length(&self) -> &f32 {
        &self.sun_shadowmap_extrusion_length
    }
    fn sun_shadowmap_extrusion_length_mut(&mut self) -> &mut f32 {
        &mut self.sun_shadowmap_extrusion_length
    }
    fn sun_shadowmap_slice_scheme_weight(&self) -> &f32 {
        &self.sun_shadowmap_slice_scheme_weight
    }
    fn sun_shadowmap_slice_scheme_weight_mut(&mut self) -> &mut f32 {
        &mut self.sun_shadowmap_slice_scheme_weight
    }
    fn sun_shadowmap_first_slice_scale(&self) -> &f32 {
        &self.sun_shadowmap_first_slice_scale
    }
    fn sun_shadowmap_first_slice_scale_mut(&mut self) -> &mut f32 {
        &mut self.sun_shadowmap_first_slice_scale
    }
    fn sun_shadowmap_first_slice_extrusion_length(&self) -> &f32 {
        &self.sun_shadowmap_first_slice_extrusion_length
    }
    fn sun_shadowmap_first_slice_extrusion_length_mut(&mut self) -> &mut f32 {
        &mut self.sun_shadowmap_first_slice_extrusion_length
    }
    fn smooth_transition_to_distant_shadows(&self) -> &bool {
        &self.smooth_transition_to_distant_shadows
    }
    fn smooth_transition_to_distant_shadows_mut(&mut self) -> &mut bool {
        &mut self.smooth_transition_to_distant_shadows
    }
    fn sun_shadowmap_slice_count_offset(&self) -> &super::core::QualityScalableInt {
        &self.sun_shadowmap_slice_count_offset
    }
    fn sun_shadowmap_slice_count_offset_mut(&mut self) -> &mut super::core::QualityScalableInt {
        &mut self.sun_shadowmap_slice_count_offset
    }
    fn sun_shadowmap_slice_count_min(&self) -> &super::core::QualityScalableInt {
        &self.sun_shadowmap_slice_count_min
    }
    fn sun_shadowmap_slice_count_min_mut(&mut self) -> &mut super::core::QualityScalableInt {
        &mut self.sun_shadowmap_slice_count_min
    }
    fn sun_shadowmap_slice_count_max(&self) -> &super::core::QualityScalableInt {
        &self.sun_shadowmap_slice_count_max
    }
    fn sun_shadowmap_slice_count_max_mut(&mut self) -> &mut super::core::QualityScalableInt {
        &mut self.sun_shadowmap_slice_count_max
    }
    fn sun_shadowmap_slice_resolution_scale(&self) -> &super::core::QualityScalableFloat {
        &self.sun_shadowmap_slice_resolution_scale
    }
    fn sun_shadowmap_slice_resolution_scale_mut(&mut self) -> &mut super::core::QualityScalableFloat {
        &mut self.sun_shadowmap_slice_resolution_scale
    }
    fn field_flag_override0(&self) -> &u16 {
        &self.field_flag_override0
    }
    fn field_flag_override0_mut(&mut self) -> &mut u16 {
        &mut self.field_flag_override0
    }
}

impl VisualEnvironmentComponentDataTrait for ShadowsComponentData {
    fn property_overrides(&self) -> &Vec<String> {
        self._glacier_base.property_overrides()
    }
    fn property_overrides_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.property_overrides_mut()
    }
}

impl super::entity::ComponentDataTrait for ShadowsComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for ShadowsComponentData {
}

impl super::core::DataBusPeerTrait for ShadowsComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ShadowsComponentData {
}

impl super::core::DataContainerTrait for ShadowsComponentData {
}

pub static SHADOWSCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ShadowsComponentData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VISUALENVIRONMENTCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ShadowsComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DefSunShadowmapViewDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ShadowsComponentData, def_sun_shadowmap_view_distance),
            },
            FieldInfoData {
                name: "SunShadowmapViewDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "QualityScalableFloat",
                rust_offset: offset_of!(ShadowsComponentData, sun_shadowmap_view_distance),
            },
            FieldInfoData {
                name: "SunShadowmapExtrusionLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ShadowsComponentData, sun_shadowmap_extrusion_length),
            },
            FieldInfoData {
                name: "SunShadowmapSliceSchemeWeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ShadowsComponentData, sun_shadowmap_slice_scheme_weight),
            },
            FieldInfoData {
                name: "SunShadowmapFirstSliceScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ShadowsComponentData, sun_shadowmap_first_slice_scale),
            },
            FieldInfoData {
                name: "SunShadowmapFirstSliceExtrusionLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ShadowsComponentData, sun_shadowmap_first_slice_extrusion_length),
            },
            FieldInfoData {
                name: "SmoothTransitionToDistantShadows",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ShadowsComponentData, smooth_transition_to_distant_shadows),
            },
            FieldInfoData {
                name: "SunShadowmapSliceCountOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "QualityScalableInt",
                rust_offset: offset_of!(ShadowsComponentData, sun_shadowmap_slice_count_offset),
            },
            FieldInfoData {
                name: "SunShadowmapSliceCountMin",
                flags: MemberInfoFlags::new(0),
                field_type: "QualityScalableInt",
                rust_offset: offset_of!(ShadowsComponentData, sun_shadowmap_slice_count_min),
            },
            FieldInfoData {
                name: "SunShadowmapSliceCountMax",
                flags: MemberInfoFlags::new(0),
                field_type: "QualityScalableInt",
                rust_offset: offset_of!(ShadowsComponentData, sun_shadowmap_slice_count_max),
            },
            FieldInfoData {
                name: "SunShadowmapSliceResolutionScale",
                flags: MemberInfoFlags::new(0),
                field_type: "QualityScalableFloat",
                rust_offset: offset_of!(ShadowsComponentData, sun_shadowmap_slice_resolution_scale),
            },
            FieldInfoData {
                name: "FieldFlagOverride0",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint16",
                rust_offset: offset_of!(ShadowsComponentData, field_flag_override0),
            },
        ],
    }),
    array_type: Some(SHADOWSCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ShadowsComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        SHADOWSCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SHADOWSCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ShadowsComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("ShadowsComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MeshSettingsComponentData {
    pub _glacier_base: VisualEnvironmentComponentData,
    pub lod_scale: f32,
    pub force_lod: i32,
    pub cull_screen_area_scale: f32,
    pub shadow_distance_scale: f32,
    pub field_flag_override0: u8,
}

pub trait MeshSettingsComponentDataTrait: VisualEnvironmentComponentDataTrait {
    fn lod_scale(&self) -> &f32;
    fn lod_scale_mut(&mut self) -> &mut f32;
    fn force_lod(&self) -> &i32;
    fn force_lod_mut(&mut self) -> &mut i32;
    fn cull_screen_area_scale(&self) -> &f32;
    fn cull_screen_area_scale_mut(&mut self) -> &mut f32;
    fn shadow_distance_scale(&self) -> &f32;
    fn shadow_distance_scale_mut(&mut self) -> &mut f32;
    fn field_flag_override0(&self) -> &u8;
    fn field_flag_override0_mut(&mut self) -> &mut u8;
}

impl MeshSettingsComponentDataTrait for MeshSettingsComponentData {
    fn lod_scale(&self) -> &f32 {
        &self.lod_scale
    }
    fn lod_scale_mut(&mut self) -> &mut f32 {
        &mut self.lod_scale
    }
    fn force_lod(&self) -> &i32 {
        &self.force_lod
    }
    fn force_lod_mut(&mut self) -> &mut i32 {
        &mut self.force_lod
    }
    fn cull_screen_area_scale(&self) -> &f32 {
        &self.cull_screen_area_scale
    }
    fn cull_screen_area_scale_mut(&mut self) -> &mut f32 {
        &mut self.cull_screen_area_scale
    }
    fn shadow_distance_scale(&self) -> &f32 {
        &self.shadow_distance_scale
    }
    fn shadow_distance_scale_mut(&mut self) -> &mut f32 {
        &mut self.shadow_distance_scale
    }
    fn field_flag_override0(&self) -> &u8 {
        &self.field_flag_override0
    }
    fn field_flag_override0_mut(&mut self) -> &mut u8 {
        &mut self.field_flag_override0
    }
}

impl VisualEnvironmentComponentDataTrait for MeshSettingsComponentData {
    fn property_overrides(&self) -> &Vec<String> {
        self._glacier_base.property_overrides()
    }
    fn property_overrides_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.property_overrides_mut()
    }
}

impl super::entity::ComponentDataTrait for MeshSettingsComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for MeshSettingsComponentData {
}

impl super::core::DataBusPeerTrait for MeshSettingsComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for MeshSettingsComponentData {
}

impl super::core::DataContainerTrait for MeshSettingsComponentData {
}

pub static MESHSETTINGSCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MeshSettingsComponentData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VISUALENVIRONMENTCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MeshSettingsComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "LodScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MeshSettingsComponentData, lod_scale),
            },
            FieldInfoData {
                name: "ForceLod",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MeshSettingsComponentData, force_lod),
            },
            FieldInfoData {
                name: "CullScreenAreaScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MeshSettingsComponentData, cull_screen_area_scale),
            },
            FieldInfoData {
                name: "ShadowDistanceScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MeshSettingsComponentData, shadow_distance_scale),
            },
            FieldInfoData {
                name: "FieldFlagOverride0",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(MeshSettingsComponentData, field_flag_override0),
            },
        ],
    }),
    array_type: Some(MESHSETTINGSCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for MeshSettingsComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        MESHSETTINGSCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MESHSETTINGSCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MeshSettingsComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("MeshSettingsComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CameraParamsComponentData {
    pub _glacier_base: VisualEnvironmentComponentData,
    pub view_distance: f32,
    pub near_plane: f32,
    pub vegetation_max_wiggle_distance: f32,
    pub field_flag_override0: u8,
}

pub trait CameraParamsComponentDataTrait: VisualEnvironmentComponentDataTrait {
    fn view_distance(&self) -> &f32;
    fn view_distance_mut(&mut self) -> &mut f32;
    fn near_plane(&self) -> &f32;
    fn near_plane_mut(&mut self) -> &mut f32;
    fn vegetation_max_wiggle_distance(&self) -> &f32;
    fn vegetation_max_wiggle_distance_mut(&mut self) -> &mut f32;
    fn field_flag_override0(&self) -> &u8;
    fn field_flag_override0_mut(&mut self) -> &mut u8;
}

impl CameraParamsComponentDataTrait for CameraParamsComponentData {
    fn view_distance(&self) -> &f32 {
        &self.view_distance
    }
    fn view_distance_mut(&mut self) -> &mut f32 {
        &mut self.view_distance
    }
    fn near_plane(&self) -> &f32 {
        &self.near_plane
    }
    fn near_plane_mut(&mut self) -> &mut f32 {
        &mut self.near_plane
    }
    fn vegetation_max_wiggle_distance(&self) -> &f32 {
        &self.vegetation_max_wiggle_distance
    }
    fn vegetation_max_wiggle_distance_mut(&mut self) -> &mut f32 {
        &mut self.vegetation_max_wiggle_distance
    }
    fn field_flag_override0(&self) -> &u8 {
        &self.field_flag_override0
    }
    fn field_flag_override0_mut(&mut self) -> &mut u8 {
        &mut self.field_flag_override0
    }
}

impl VisualEnvironmentComponentDataTrait for CameraParamsComponentData {
    fn property_overrides(&self) -> &Vec<String> {
        self._glacier_base.property_overrides()
    }
    fn property_overrides_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.property_overrides_mut()
    }
}

impl super::entity::ComponentDataTrait for CameraParamsComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for CameraParamsComponentData {
}

impl super::core::DataBusPeerTrait for CameraParamsComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CameraParamsComponentData {
}

impl super::core::DataContainerTrait for CameraParamsComponentData {
}

pub static CAMERAPARAMSCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraParamsComponentData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VISUALENVIRONMENTCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraParamsComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ViewDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraParamsComponentData, view_distance),
            },
            FieldInfoData {
                name: "NearPlane",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraParamsComponentData, near_plane),
            },
            FieldInfoData {
                name: "VegetationMaxWiggleDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraParamsComponentData, vegetation_max_wiggle_distance),
            },
            FieldInfoData {
                name: "FieldFlagOverride0",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(CameraParamsComponentData, field_flag_override0),
            },
        ],
    }),
    array_type: Some(CAMERAPARAMSCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CameraParamsComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERAPARAMSCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CAMERAPARAMSCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraParamsComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("CameraParamsComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ShaderColorParamsComponentData {
    pub _glacier_base: VisualEnvironmentComponentData,
    pub vec4_value: super::core::Vec4,
    pub parameter_name: String,
    pub field_flag_override0: u8,
}

pub trait ShaderColorParamsComponentDataTrait: VisualEnvironmentComponentDataTrait {
    fn vec4_value(&self) -> &super::core::Vec4;
    fn vec4_value_mut(&mut self) -> &mut super::core::Vec4;
    fn parameter_name(&self) -> &String;
    fn parameter_name_mut(&mut self) -> &mut String;
    fn field_flag_override0(&self) -> &u8;
    fn field_flag_override0_mut(&mut self) -> &mut u8;
}

impl ShaderColorParamsComponentDataTrait for ShaderColorParamsComponentData {
    fn vec4_value(&self) -> &super::core::Vec4 {
        &self.vec4_value
    }
    fn vec4_value_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.vec4_value
    }
    fn parameter_name(&self) -> &String {
        &self.parameter_name
    }
    fn parameter_name_mut(&mut self) -> &mut String {
        &mut self.parameter_name
    }
    fn field_flag_override0(&self) -> &u8 {
        &self.field_flag_override0
    }
    fn field_flag_override0_mut(&mut self) -> &mut u8 {
        &mut self.field_flag_override0
    }
}

impl VisualEnvironmentComponentDataTrait for ShaderColorParamsComponentData {
    fn property_overrides(&self) -> &Vec<String> {
        self._glacier_base.property_overrides()
    }
    fn property_overrides_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.property_overrides_mut()
    }
}

impl super::entity::ComponentDataTrait for ShaderColorParamsComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for ShaderColorParamsComponentData {
}

impl super::core::DataBusPeerTrait for ShaderColorParamsComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ShaderColorParamsComponentData {
}

impl super::core::DataContainerTrait for ShaderColorParamsComponentData {
}

pub static SHADERCOLORPARAMSCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ShaderColorParamsComponentData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VISUALENVIRONMENTCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ShaderColorParamsComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Vec4Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(ShaderColorParamsComponentData, vec4_value),
            },
            FieldInfoData {
                name: "ParameterName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ShaderColorParamsComponentData, parameter_name),
            },
            FieldInfoData {
                name: "FieldFlagOverride0",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(ShaderColorParamsComponentData, field_flag_override0),
            },
        ],
    }),
    array_type: Some(SHADERCOLORPARAMSCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ShaderColorParamsComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        SHADERCOLORPARAMSCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SHADERCOLORPARAMSCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ShaderColorParamsComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("ShaderColorParamsComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ShaderParamsComponentData {
    pub _glacier_base: VisualEnvironmentComponentData,
    pub vec4_value: super::core::Vec4,
    pub bool_value: bool,
    pub texture_value: Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>,
    pub value_type: super::render_base::ExternalValueConstantType,
    pub conditional_value: u32,
    pub conditional_name: String,
    pub parameter_name: String,
    pub field_flag_override0: u8,
}

pub trait ShaderParamsComponentDataTrait: VisualEnvironmentComponentDataTrait {
    fn vec4_value(&self) -> &super::core::Vec4;
    fn vec4_value_mut(&mut self) -> &mut super::core::Vec4;
    fn bool_value(&self) -> &bool;
    fn bool_value_mut(&mut self) -> &mut bool;
    fn texture_value(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn texture_value_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn value_type(&self) -> &super::render_base::ExternalValueConstantType;
    fn value_type_mut(&mut self) -> &mut super::render_base::ExternalValueConstantType;
    fn conditional_value(&self) -> &u32;
    fn conditional_value_mut(&mut self) -> &mut u32;
    fn conditional_name(&self) -> &String;
    fn conditional_name_mut(&mut self) -> &mut String;
    fn parameter_name(&self) -> &String;
    fn parameter_name_mut(&mut self) -> &mut String;
    fn field_flag_override0(&self) -> &u8;
    fn field_flag_override0_mut(&mut self) -> &mut u8;
}

impl ShaderParamsComponentDataTrait for ShaderParamsComponentData {
    fn vec4_value(&self) -> &super::core::Vec4 {
        &self.vec4_value
    }
    fn vec4_value_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.vec4_value
    }
    fn bool_value(&self) -> &bool {
        &self.bool_value
    }
    fn bool_value_mut(&mut self) -> &mut bool {
        &mut self.bool_value
    }
    fn texture_value(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &self.texture_value
    }
    fn texture_value_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &mut self.texture_value
    }
    fn value_type(&self) -> &super::render_base::ExternalValueConstantType {
        &self.value_type
    }
    fn value_type_mut(&mut self) -> &mut super::render_base::ExternalValueConstantType {
        &mut self.value_type
    }
    fn conditional_value(&self) -> &u32 {
        &self.conditional_value
    }
    fn conditional_value_mut(&mut self) -> &mut u32 {
        &mut self.conditional_value
    }
    fn conditional_name(&self) -> &String {
        &self.conditional_name
    }
    fn conditional_name_mut(&mut self) -> &mut String {
        &mut self.conditional_name
    }
    fn parameter_name(&self) -> &String {
        &self.parameter_name
    }
    fn parameter_name_mut(&mut self) -> &mut String {
        &mut self.parameter_name
    }
    fn field_flag_override0(&self) -> &u8 {
        &self.field_flag_override0
    }
    fn field_flag_override0_mut(&mut self) -> &mut u8 {
        &mut self.field_flag_override0
    }
}

impl VisualEnvironmentComponentDataTrait for ShaderParamsComponentData {
    fn property_overrides(&self) -> &Vec<String> {
        self._glacier_base.property_overrides()
    }
    fn property_overrides_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.property_overrides_mut()
    }
}

impl super::entity::ComponentDataTrait for ShaderParamsComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for ShaderParamsComponentData {
}

impl super::core::DataBusPeerTrait for ShaderParamsComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ShaderParamsComponentData {
}

impl super::core::DataContainerTrait for ShaderParamsComponentData {
}

pub static SHADERPARAMSCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ShaderParamsComponentData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VISUALENVIRONMENTCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ShaderParamsComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Vec4Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(ShaderParamsComponentData, vec4_value),
            },
            FieldInfoData {
                name: "BoolValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ShaderParamsComponentData, bool_value),
            },
            FieldInfoData {
                name: "TextureValue",
                flags: MemberInfoFlags::new(0),
                field_type: "TextureBaseAsset",
                rust_offset: offset_of!(ShaderParamsComponentData, texture_value),
            },
            FieldInfoData {
                name: "ValueType",
                flags: MemberInfoFlags::new(0),
                field_type: "ExternalValueConstantType",
                rust_offset: offset_of!(ShaderParamsComponentData, value_type),
            },
            FieldInfoData {
                name: "ConditionalValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(ShaderParamsComponentData, conditional_value),
            },
            FieldInfoData {
                name: "ConditionalName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ShaderParamsComponentData, conditional_name),
            },
            FieldInfoData {
                name: "ParameterName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ShaderParamsComponentData, parameter_name),
            },
            FieldInfoData {
                name: "FieldFlagOverride0",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(ShaderParamsComponentData, field_flag_override0),
            },
        ],
    }),
    array_type: Some(SHADERPARAMSCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ShaderParamsComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        SHADERPARAMSCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SHADERPARAMSCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ShaderParamsComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("ShaderParamsComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EnlightenComponentData {
    pub _glacier_base: VisualEnvironmentComponentData,
    pub bounce_scale: f32,
    pub sun_scale: f32,
    pub sun_direct_lightmap_enable: bool,
    pub terrain_color: super::core::Vec3,
    pub cull_distance: f32,
    pub cull_radius: f32,
    pub sky_box_enable: bool,
    pub sky_box_cut_bottom: bool,
    pub sky_box_blend_mode: super::world_base::SkyBoxBlendMode,
    pub sky_box_blend: f32,
    pub sky_box_sky_color: super::core::Vec3,
    pub sky_box_ground_color: super::core::Vec3,
    pub sky_box_sun_light_color: super::core::Vec3,
    pub sky_box_sun_light_color_size: f32,
    pub sky_box_back_light_color: super::core::Vec3,
    pub sky_box_back_light_color_size: f32,
    pub sky_box_back_light_rotation_x: f32,
    pub sky_box_back_light_rotation_y: f32,
    pub opaque_alpha_test_simple_scale: super::core::Vec3,
    pub field_flag_override0: u32,
}

pub trait EnlightenComponentDataTrait: VisualEnvironmentComponentDataTrait {
    fn bounce_scale(&self) -> &f32;
    fn bounce_scale_mut(&mut self) -> &mut f32;
    fn sun_scale(&self) -> &f32;
    fn sun_scale_mut(&mut self) -> &mut f32;
    fn sun_direct_lightmap_enable(&self) -> &bool;
    fn sun_direct_lightmap_enable_mut(&mut self) -> &mut bool;
    fn terrain_color(&self) -> &super::core::Vec3;
    fn terrain_color_mut(&mut self) -> &mut super::core::Vec3;
    fn cull_distance(&self) -> &f32;
    fn cull_distance_mut(&mut self) -> &mut f32;
    fn cull_radius(&self) -> &f32;
    fn cull_radius_mut(&mut self) -> &mut f32;
    fn sky_box_enable(&self) -> &bool;
    fn sky_box_enable_mut(&mut self) -> &mut bool;
    fn sky_box_cut_bottom(&self) -> &bool;
    fn sky_box_cut_bottom_mut(&mut self) -> &mut bool;
    fn sky_box_blend_mode(&self) -> &super::world_base::SkyBoxBlendMode;
    fn sky_box_blend_mode_mut(&mut self) -> &mut super::world_base::SkyBoxBlendMode;
    fn sky_box_blend(&self) -> &f32;
    fn sky_box_blend_mut(&mut self) -> &mut f32;
    fn sky_box_sky_color(&self) -> &super::core::Vec3;
    fn sky_box_sky_color_mut(&mut self) -> &mut super::core::Vec3;
    fn sky_box_ground_color(&self) -> &super::core::Vec3;
    fn sky_box_ground_color_mut(&mut self) -> &mut super::core::Vec3;
    fn sky_box_sun_light_color(&self) -> &super::core::Vec3;
    fn sky_box_sun_light_color_mut(&mut self) -> &mut super::core::Vec3;
    fn sky_box_sun_light_color_size(&self) -> &f32;
    fn sky_box_sun_light_color_size_mut(&mut self) -> &mut f32;
    fn sky_box_back_light_color(&self) -> &super::core::Vec3;
    fn sky_box_back_light_color_mut(&mut self) -> &mut super::core::Vec3;
    fn sky_box_back_light_color_size(&self) -> &f32;
    fn sky_box_back_light_color_size_mut(&mut self) -> &mut f32;
    fn sky_box_back_light_rotation_x(&self) -> &f32;
    fn sky_box_back_light_rotation_x_mut(&mut self) -> &mut f32;
    fn sky_box_back_light_rotation_y(&self) -> &f32;
    fn sky_box_back_light_rotation_y_mut(&mut self) -> &mut f32;
    fn opaque_alpha_test_simple_scale(&self) -> &super::core::Vec3;
    fn opaque_alpha_test_simple_scale_mut(&mut self) -> &mut super::core::Vec3;
    fn field_flag_override0(&self) -> &u32;
    fn field_flag_override0_mut(&mut self) -> &mut u32;
}

impl EnlightenComponentDataTrait for EnlightenComponentData {
    fn bounce_scale(&self) -> &f32 {
        &self.bounce_scale
    }
    fn bounce_scale_mut(&mut self) -> &mut f32 {
        &mut self.bounce_scale
    }
    fn sun_scale(&self) -> &f32 {
        &self.sun_scale
    }
    fn sun_scale_mut(&mut self) -> &mut f32 {
        &mut self.sun_scale
    }
    fn sun_direct_lightmap_enable(&self) -> &bool {
        &self.sun_direct_lightmap_enable
    }
    fn sun_direct_lightmap_enable_mut(&mut self) -> &mut bool {
        &mut self.sun_direct_lightmap_enable
    }
    fn terrain_color(&self) -> &super::core::Vec3 {
        &self.terrain_color
    }
    fn terrain_color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.terrain_color
    }
    fn cull_distance(&self) -> &f32 {
        &self.cull_distance
    }
    fn cull_distance_mut(&mut self) -> &mut f32 {
        &mut self.cull_distance
    }
    fn cull_radius(&self) -> &f32 {
        &self.cull_radius
    }
    fn cull_radius_mut(&mut self) -> &mut f32 {
        &mut self.cull_radius
    }
    fn sky_box_enable(&self) -> &bool {
        &self.sky_box_enable
    }
    fn sky_box_enable_mut(&mut self) -> &mut bool {
        &mut self.sky_box_enable
    }
    fn sky_box_cut_bottom(&self) -> &bool {
        &self.sky_box_cut_bottom
    }
    fn sky_box_cut_bottom_mut(&mut self) -> &mut bool {
        &mut self.sky_box_cut_bottom
    }
    fn sky_box_blend_mode(&self) -> &super::world_base::SkyBoxBlendMode {
        &self.sky_box_blend_mode
    }
    fn sky_box_blend_mode_mut(&mut self) -> &mut super::world_base::SkyBoxBlendMode {
        &mut self.sky_box_blend_mode
    }
    fn sky_box_blend(&self) -> &f32 {
        &self.sky_box_blend
    }
    fn sky_box_blend_mut(&mut self) -> &mut f32 {
        &mut self.sky_box_blend
    }
    fn sky_box_sky_color(&self) -> &super::core::Vec3 {
        &self.sky_box_sky_color
    }
    fn sky_box_sky_color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.sky_box_sky_color
    }
    fn sky_box_ground_color(&self) -> &super::core::Vec3 {
        &self.sky_box_ground_color
    }
    fn sky_box_ground_color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.sky_box_ground_color
    }
    fn sky_box_sun_light_color(&self) -> &super::core::Vec3 {
        &self.sky_box_sun_light_color
    }
    fn sky_box_sun_light_color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.sky_box_sun_light_color
    }
    fn sky_box_sun_light_color_size(&self) -> &f32 {
        &self.sky_box_sun_light_color_size
    }
    fn sky_box_sun_light_color_size_mut(&mut self) -> &mut f32 {
        &mut self.sky_box_sun_light_color_size
    }
    fn sky_box_back_light_color(&self) -> &super::core::Vec3 {
        &self.sky_box_back_light_color
    }
    fn sky_box_back_light_color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.sky_box_back_light_color
    }
    fn sky_box_back_light_color_size(&self) -> &f32 {
        &self.sky_box_back_light_color_size
    }
    fn sky_box_back_light_color_size_mut(&mut self) -> &mut f32 {
        &mut self.sky_box_back_light_color_size
    }
    fn sky_box_back_light_rotation_x(&self) -> &f32 {
        &self.sky_box_back_light_rotation_x
    }
    fn sky_box_back_light_rotation_x_mut(&mut self) -> &mut f32 {
        &mut self.sky_box_back_light_rotation_x
    }
    fn sky_box_back_light_rotation_y(&self) -> &f32 {
        &self.sky_box_back_light_rotation_y
    }
    fn sky_box_back_light_rotation_y_mut(&mut self) -> &mut f32 {
        &mut self.sky_box_back_light_rotation_y
    }
    fn opaque_alpha_test_simple_scale(&self) -> &super::core::Vec3 {
        &self.opaque_alpha_test_simple_scale
    }
    fn opaque_alpha_test_simple_scale_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.opaque_alpha_test_simple_scale
    }
    fn field_flag_override0(&self) -> &u32 {
        &self.field_flag_override0
    }
    fn field_flag_override0_mut(&mut self) -> &mut u32 {
        &mut self.field_flag_override0
    }
}

impl VisualEnvironmentComponentDataTrait for EnlightenComponentData {
    fn property_overrides(&self) -> &Vec<String> {
        self._glacier_base.property_overrides()
    }
    fn property_overrides_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.property_overrides_mut()
    }
}

impl super::entity::ComponentDataTrait for EnlightenComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for EnlightenComponentData {
}

impl super::core::DataBusPeerTrait for EnlightenComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for EnlightenComponentData {
}

impl super::core::DataContainerTrait for EnlightenComponentData {
}

pub static ENLIGHTENCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnlightenComponentData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VISUALENVIRONMENTCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EnlightenComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "BounceScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EnlightenComponentData, bounce_scale),
            },
            FieldInfoData {
                name: "SunScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EnlightenComponentData, sun_scale),
            },
            FieldInfoData {
                name: "SunDirectLightmapEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EnlightenComponentData, sun_direct_lightmap_enable),
            },
            FieldInfoData {
                name: "TerrainColor",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(EnlightenComponentData, terrain_color),
            },
            FieldInfoData {
                name: "CullDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EnlightenComponentData, cull_distance),
            },
            FieldInfoData {
                name: "CullRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EnlightenComponentData, cull_radius),
            },
            FieldInfoData {
                name: "SkyBoxEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EnlightenComponentData, sky_box_enable),
            },
            FieldInfoData {
                name: "SkyBoxCutBottom",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EnlightenComponentData, sky_box_cut_bottom),
            },
            FieldInfoData {
                name: "SkyBoxBlendMode",
                flags: MemberInfoFlags::new(0),
                field_type: "SkyBoxBlendMode",
                rust_offset: offset_of!(EnlightenComponentData, sky_box_blend_mode),
            },
            FieldInfoData {
                name: "SkyBoxBlend",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EnlightenComponentData, sky_box_blend),
            },
            FieldInfoData {
                name: "SkyBoxSkyColor",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(EnlightenComponentData, sky_box_sky_color),
            },
            FieldInfoData {
                name: "SkyBoxGroundColor",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(EnlightenComponentData, sky_box_ground_color),
            },
            FieldInfoData {
                name: "SkyBoxSunLightColor",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(EnlightenComponentData, sky_box_sun_light_color),
            },
            FieldInfoData {
                name: "SkyBoxSunLightColorSize",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EnlightenComponentData, sky_box_sun_light_color_size),
            },
            FieldInfoData {
                name: "SkyBoxBackLightColor",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(EnlightenComponentData, sky_box_back_light_color),
            },
            FieldInfoData {
                name: "SkyBoxBackLightColorSize",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EnlightenComponentData, sky_box_back_light_color_size),
            },
            FieldInfoData {
                name: "SkyBoxBackLightRotationX",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EnlightenComponentData, sky_box_back_light_rotation_x),
            },
            FieldInfoData {
                name: "SkyBoxBackLightRotationY",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EnlightenComponentData, sky_box_back_light_rotation_y),
            },
            FieldInfoData {
                name: "OpaqueAlphaTestSimpleScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(EnlightenComponentData, opaque_alpha_test_simple_scale),
            },
            FieldInfoData {
                name: "FieldFlagOverride0",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(EnlightenComponentData, field_flag_override0),
            },
        ],
    }),
    array_type: Some(ENLIGHTENCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for EnlightenComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        ENLIGHTENCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ENLIGHTENCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnlightenComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("EnlightenComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SubSurfaceScatteringComponentData {
    pub _glacier_base: VisualEnvironmentComponentData,
    pub simple_sss_color: super::core::Vec3,
    pub simple_sss_rolloff_key_light: f32,
    pub simple_sss_rolloff_local_light: f32,
    pub local_light_translucency_enable: bool,
    pub profile0: super::render_base::SubSurfaceProfile,
    pub profile1: super::render_base::SubSurfaceProfile,
    pub profile2: super::render_base::SubSurfaceProfile,
    pub profile3: super::render_base::SubSurfaceProfile,
    pub profile4: super::render_base::SubSurfaceProfile,
    pub profile5: super::render_base::SubSurfaceProfile,
    pub profile6: super::render_base::SubSurfaceProfile,
    pub profile_o_a_t_s: super::render_base::SubSurfaceProfile,
    pub field_flag_override0: u16,
}

pub trait SubSurfaceScatteringComponentDataTrait: VisualEnvironmentComponentDataTrait {
    fn simple_sss_color(&self) -> &super::core::Vec3;
    fn simple_sss_color_mut(&mut self) -> &mut super::core::Vec3;
    fn simple_sss_rolloff_key_light(&self) -> &f32;
    fn simple_sss_rolloff_key_light_mut(&mut self) -> &mut f32;
    fn simple_sss_rolloff_local_light(&self) -> &f32;
    fn simple_sss_rolloff_local_light_mut(&mut self) -> &mut f32;
    fn local_light_translucency_enable(&self) -> &bool;
    fn local_light_translucency_enable_mut(&mut self) -> &mut bool;
    fn profile0(&self) -> &super::render_base::SubSurfaceProfile;
    fn profile0_mut(&mut self) -> &mut super::render_base::SubSurfaceProfile;
    fn profile1(&self) -> &super::render_base::SubSurfaceProfile;
    fn profile1_mut(&mut self) -> &mut super::render_base::SubSurfaceProfile;
    fn profile2(&self) -> &super::render_base::SubSurfaceProfile;
    fn profile2_mut(&mut self) -> &mut super::render_base::SubSurfaceProfile;
    fn profile3(&self) -> &super::render_base::SubSurfaceProfile;
    fn profile3_mut(&mut self) -> &mut super::render_base::SubSurfaceProfile;
    fn profile4(&self) -> &super::render_base::SubSurfaceProfile;
    fn profile4_mut(&mut self) -> &mut super::render_base::SubSurfaceProfile;
    fn profile5(&self) -> &super::render_base::SubSurfaceProfile;
    fn profile5_mut(&mut self) -> &mut super::render_base::SubSurfaceProfile;
    fn profile6(&self) -> &super::render_base::SubSurfaceProfile;
    fn profile6_mut(&mut self) -> &mut super::render_base::SubSurfaceProfile;
    fn profile_o_a_t_s(&self) -> &super::render_base::SubSurfaceProfile;
    fn profile_o_a_t_s_mut(&mut self) -> &mut super::render_base::SubSurfaceProfile;
    fn field_flag_override0(&self) -> &u16;
    fn field_flag_override0_mut(&mut self) -> &mut u16;
}

impl SubSurfaceScatteringComponentDataTrait for SubSurfaceScatteringComponentData {
    fn simple_sss_color(&self) -> &super::core::Vec3 {
        &self.simple_sss_color
    }
    fn simple_sss_color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.simple_sss_color
    }
    fn simple_sss_rolloff_key_light(&self) -> &f32 {
        &self.simple_sss_rolloff_key_light
    }
    fn simple_sss_rolloff_key_light_mut(&mut self) -> &mut f32 {
        &mut self.simple_sss_rolloff_key_light
    }
    fn simple_sss_rolloff_local_light(&self) -> &f32 {
        &self.simple_sss_rolloff_local_light
    }
    fn simple_sss_rolloff_local_light_mut(&mut self) -> &mut f32 {
        &mut self.simple_sss_rolloff_local_light
    }
    fn local_light_translucency_enable(&self) -> &bool {
        &self.local_light_translucency_enable
    }
    fn local_light_translucency_enable_mut(&mut self) -> &mut bool {
        &mut self.local_light_translucency_enable
    }
    fn profile0(&self) -> &super::render_base::SubSurfaceProfile {
        &self.profile0
    }
    fn profile0_mut(&mut self) -> &mut super::render_base::SubSurfaceProfile {
        &mut self.profile0
    }
    fn profile1(&self) -> &super::render_base::SubSurfaceProfile {
        &self.profile1
    }
    fn profile1_mut(&mut self) -> &mut super::render_base::SubSurfaceProfile {
        &mut self.profile1
    }
    fn profile2(&self) -> &super::render_base::SubSurfaceProfile {
        &self.profile2
    }
    fn profile2_mut(&mut self) -> &mut super::render_base::SubSurfaceProfile {
        &mut self.profile2
    }
    fn profile3(&self) -> &super::render_base::SubSurfaceProfile {
        &self.profile3
    }
    fn profile3_mut(&mut self) -> &mut super::render_base::SubSurfaceProfile {
        &mut self.profile3
    }
    fn profile4(&self) -> &super::render_base::SubSurfaceProfile {
        &self.profile4
    }
    fn profile4_mut(&mut self) -> &mut super::render_base::SubSurfaceProfile {
        &mut self.profile4
    }
    fn profile5(&self) -> &super::render_base::SubSurfaceProfile {
        &self.profile5
    }
    fn profile5_mut(&mut self) -> &mut super::render_base::SubSurfaceProfile {
        &mut self.profile5
    }
    fn profile6(&self) -> &super::render_base::SubSurfaceProfile {
        &self.profile6
    }
    fn profile6_mut(&mut self) -> &mut super::render_base::SubSurfaceProfile {
        &mut self.profile6
    }
    fn profile_o_a_t_s(&self) -> &super::render_base::SubSurfaceProfile {
        &self.profile_o_a_t_s
    }
    fn profile_o_a_t_s_mut(&mut self) -> &mut super::render_base::SubSurfaceProfile {
        &mut self.profile_o_a_t_s
    }
    fn field_flag_override0(&self) -> &u16 {
        &self.field_flag_override0
    }
    fn field_flag_override0_mut(&mut self) -> &mut u16 {
        &mut self.field_flag_override0
    }
}

impl VisualEnvironmentComponentDataTrait for SubSurfaceScatteringComponentData {
    fn property_overrides(&self) -> &Vec<String> {
        self._glacier_base.property_overrides()
    }
    fn property_overrides_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.property_overrides_mut()
    }
}

impl super::entity::ComponentDataTrait for SubSurfaceScatteringComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for SubSurfaceScatteringComponentData {
}

impl super::core::DataBusPeerTrait for SubSurfaceScatteringComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SubSurfaceScatteringComponentData {
}

impl super::core::DataContainerTrait for SubSurfaceScatteringComponentData {
}

pub static SUBSURFACESCATTERINGCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubSurfaceScatteringComponentData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VISUALENVIRONMENTCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SubSurfaceScatteringComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SimpleSssColor",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SubSurfaceScatteringComponentData, simple_sss_color),
            },
            FieldInfoData {
                name: "SimpleSssRolloffKeyLight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SubSurfaceScatteringComponentData, simple_sss_rolloff_key_light),
            },
            FieldInfoData {
                name: "SimpleSssRolloffLocalLight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SubSurfaceScatteringComponentData, simple_sss_rolloff_local_light),
            },
            FieldInfoData {
                name: "LocalLightTranslucencyEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SubSurfaceScatteringComponentData, local_light_translucency_enable),
            },
            FieldInfoData {
                name: "Profile0",
                flags: MemberInfoFlags::new(0),
                field_type: "SubSurfaceProfile",
                rust_offset: offset_of!(SubSurfaceScatteringComponentData, profile0),
            },
            FieldInfoData {
                name: "Profile1",
                flags: MemberInfoFlags::new(0),
                field_type: "SubSurfaceProfile",
                rust_offset: offset_of!(SubSurfaceScatteringComponentData, profile1),
            },
            FieldInfoData {
                name: "Profile2",
                flags: MemberInfoFlags::new(0),
                field_type: "SubSurfaceProfile",
                rust_offset: offset_of!(SubSurfaceScatteringComponentData, profile2),
            },
            FieldInfoData {
                name: "Profile3",
                flags: MemberInfoFlags::new(0),
                field_type: "SubSurfaceProfile",
                rust_offset: offset_of!(SubSurfaceScatteringComponentData, profile3),
            },
            FieldInfoData {
                name: "Profile4",
                flags: MemberInfoFlags::new(0),
                field_type: "SubSurfaceProfile",
                rust_offset: offset_of!(SubSurfaceScatteringComponentData, profile4),
            },
            FieldInfoData {
                name: "Profile5",
                flags: MemberInfoFlags::new(0),
                field_type: "SubSurfaceProfile",
                rust_offset: offset_of!(SubSurfaceScatteringComponentData, profile5),
            },
            FieldInfoData {
                name: "Profile6",
                flags: MemberInfoFlags::new(0),
                field_type: "SubSurfaceProfile",
                rust_offset: offset_of!(SubSurfaceScatteringComponentData, profile6),
            },
            FieldInfoData {
                name: "ProfileOATS",
                flags: MemberInfoFlags::new(0),
                field_type: "SubSurfaceProfile",
                rust_offset: offset_of!(SubSurfaceScatteringComponentData, profile_o_a_t_s),
            },
            FieldInfoData {
                name: "FieldFlagOverride0",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint16",
                rust_offset: offset_of!(SubSurfaceScatteringComponentData, field_flag_override0),
            },
        ],
    }),
    array_type: Some(SUBSURFACESCATTERINGCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SubSurfaceScatteringComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        SUBSURFACESCATTERINGCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SUBSURFACESCATTERINGCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubSurfaceScatteringComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("SubSurfaceScatteringComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DynamicAOComponentData {
    pub _glacier_base: VisualEnvironmentComponentData,
    pub enable: bool,
    pub affect_outdoor_light: bool,
    pub affect_local_light: bool,
    pub dynamic_a_o_factor: f32,
    pub ssao_fade: f32,
    pub ssao_radius: f32,
    pub ssao_max_distance_inner: f32,
    pub ssao_max_distance_outer: f32,
    pub hbao_radius: f32,
    pub hbao_angle_bias: f32,
    pub hbao_attenuation: f32,
    pub hbao_contrast: f32,
    pub hbao_max_footprint_radius: f32,
    pub hbao_power_exponent: f32,
    pub hbao_blur_radius: f32,
    pub hbao_blur_sharpness: f32,
    pub temporal_filter_enable: bool,
    pub aao_dynamic_weight: bool,
    pub aao_bias: f32,
    pub aao_intensity: f32,
    pub aao_contrast: f32,
    pub aao_range_reduction: f32,
    pub aao_screen_radius: f32,
    pub aao_near_occlusion_max: f32,
    pub aao_near_falloff_threshold: f32,
    pub aao_clip_distance: f32,
    pub aao_clip_fade_distance: f32,
    pub aao_blur_depth_threshold: f32,
    pub aao_blur_const_falloff: f32,
    pub field_flag_override0: u32,
}

pub trait DynamicAOComponentDataTrait: VisualEnvironmentComponentDataTrait {
    fn enable(&self) -> &bool;
    fn enable_mut(&mut self) -> &mut bool;
    fn affect_outdoor_light(&self) -> &bool;
    fn affect_outdoor_light_mut(&mut self) -> &mut bool;
    fn affect_local_light(&self) -> &bool;
    fn affect_local_light_mut(&mut self) -> &mut bool;
    fn dynamic_a_o_factor(&self) -> &f32;
    fn dynamic_a_o_factor_mut(&mut self) -> &mut f32;
    fn ssao_fade(&self) -> &f32;
    fn ssao_fade_mut(&mut self) -> &mut f32;
    fn ssao_radius(&self) -> &f32;
    fn ssao_radius_mut(&mut self) -> &mut f32;
    fn ssao_max_distance_inner(&self) -> &f32;
    fn ssao_max_distance_inner_mut(&mut self) -> &mut f32;
    fn ssao_max_distance_outer(&self) -> &f32;
    fn ssao_max_distance_outer_mut(&mut self) -> &mut f32;
    fn hbao_radius(&self) -> &f32;
    fn hbao_radius_mut(&mut self) -> &mut f32;
    fn hbao_angle_bias(&self) -> &f32;
    fn hbao_angle_bias_mut(&mut self) -> &mut f32;
    fn hbao_attenuation(&self) -> &f32;
    fn hbao_attenuation_mut(&mut self) -> &mut f32;
    fn hbao_contrast(&self) -> &f32;
    fn hbao_contrast_mut(&mut self) -> &mut f32;
    fn hbao_max_footprint_radius(&self) -> &f32;
    fn hbao_max_footprint_radius_mut(&mut self) -> &mut f32;
    fn hbao_power_exponent(&self) -> &f32;
    fn hbao_power_exponent_mut(&mut self) -> &mut f32;
    fn hbao_blur_radius(&self) -> &f32;
    fn hbao_blur_radius_mut(&mut self) -> &mut f32;
    fn hbao_blur_sharpness(&self) -> &f32;
    fn hbao_blur_sharpness_mut(&mut self) -> &mut f32;
    fn temporal_filter_enable(&self) -> &bool;
    fn temporal_filter_enable_mut(&mut self) -> &mut bool;
    fn aao_dynamic_weight(&self) -> &bool;
    fn aao_dynamic_weight_mut(&mut self) -> &mut bool;
    fn aao_bias(&self) -> &f32;
    fn aao_bias_mut(&mut self) -> &mut f32;
    fn aao_intensity(&self) -> &f32;
    fn aao_intensity_mut(&mut self) -> &mut f32;
    fn aao_contrast(&self) -> &f32;
    fn aao_contrast_mut(&mut self) -> &mut f32;
    fn aao_range_reduction(&self) -> &f32;
    fn aao_range_reduction_mut(&mut self) -> &mut f32;
    fn aao_screen_radius(&self) -> &f32;
    fn aao_screen_radius_mut(&mut self) -> &mut f32;
    fn aao_near_occlusion_max(&self) -> &f32;
    fn aao_near_occlusion_max_mut(&mut self) -> &mut f32;
    fn aao_near_falloff_threshold(&self) -> &f32;
    fn aao_near_falloff_threshold_mut(&mut self) -> &mut f32;
    fn aao_clip_distance(&self) -> &f32;
    fn aao_clip_distance_mut(&mut self) -> &mut f32;
    fn aao_clip_fade_distance(&self) -> &f32;
    fn aao_clip_fade_distance_mut(&mut self) -> &mut f32;
    fn aao_blur_depth_threshold(&self) -> &f32;
    fn aao_blur_depth_threshold_mut(&mut self) -> &mut f32;
    fn aao_blur_const_falloff(&self) -> &f32;
    fn aao_blur_const_falloff_mut(&mut self) -> &mut f32;
    fn field_flag_override0(&self) -> &u32;
    fn field_flag_override0_mut(&mut self) -> &mut u32;
}

impl DynamicAOComponentDataTrait for DynamicAOComponentData {
    fn enable(&self) -> &bool {
        &self.enable
    }
    fn enable_mut(&mut self) -> &mut bool {
        &mut self.enable
    }
    fn affect_outdoor_light(&self) -> &bool {
        &self.affect_outdoor_light
    }
    fn affect_outdoor_light_mut(&mut self) -> &mut bool {
        &mut self.affect_outdoor_light
    }
    fn affect_local_light(&self) -> &bool {
        &self.affect_local_light
    }
    fn affect_local_light_mut(&mut self) -> &mut bool {
        &mut self.affect_local_light
    }
    fn dynamic_a_o_factor(&self) -> &f32 {
        &self.dynamic_a_o_factor
    }
    fn dynamic_a_o_factor_mut(&mut self) -> &mut f32 {
        &mut self.dynamic_a_o_factor
    }
    fn ssao_fade(&self) -> &f32 {
        &self.ssao_fade
    }
    fn ssao_fade_mut(&mut self) -> &mut f32 {
        &mut self.ssao_fade
    }
    fn ssao_radius(&self) -> &f32 {
        &self.ssao_radius
    }
    fn ssao_radius_mut(&mut self) -> &mut f32 {
        &mut self.ssao_radius
    }
    fn ssao_max_distance_inner(&self) -> &f32 {
        &self.ssao_max_distance_inner
    }
    fn ssao_max_distance_inner_mut(&mut self) -> &mut f32 {
        &mut self.ssao_max_distance_inner
    }
    fn ssao_max_distance_outer(&self) -> &f32 {
        &self.ssao_max_distance_outer
    }
    fn ssao_max_distance_outer_mut(&mut self) -> &mut f32 {
        &mut self.ssao_max_distance_outer
    }
    fn hbao_radius(&self) -> &f32 {
        &self.hbao_radius
    }
    fn hbao_radius_mut(&mut self) -> &mut f32 {
        &mut self.hbao_radius
    }
    fn hbao_angle_bias(&self) -> &f32 {
        &self.hbao_angle_bias
    }
    fn hbao_angle_bias_mut(&mut self) -> &mut f32 {
        &mut self.hbao_angle_bias
    }
    fn hbao_attenuation(&self) -> &f32 {
        &self.hbao_attenuation
    }
    fn hbao_attenuation_mut(&mut self) -> &mut f32 {
        &mut self.hbao_attenuation
    }
    fn hbao_contrast(&self) -> &f32 {
        &self.hbao_contrast
    }
    fn hbao_contrast_mut(&mut self) -> &mut f32 {
        &mut self.hbao_contrast
    }
    fn hbao_max_footprint_radius(&self) -> &f32 {
        &self.hbao_max_footprint_radius
    }
    fn hbao_max_footprint_radius_mut(&mut self) -> &mut f32 {
        &mut self.hbao_max_footprint_radius
    }
    fn hbao_power_exponent(&self) -> &f32 {
        &self.hbao_power_exponent
    }
    fn hbao_power_exponent_mut(&mut self) -> &mut f32 {
        &mut self.hbao_power_exponent
    }
    fn hbao_blur_radius(&self) -> &f32 {
        &self.hbao_blur_radius
    }
    fn hbao_blur_radius_mut(&mut self) -> &mut f32 {
        &mut self.hbao_blur_radius
    }
    fn hbao_blur_sharpness(&self) -> &f32 {
        &self.hbao_blur_sharpness
    }
    fn hbao_blur_sharpness_mut(&mut self) -> &mut f32 {
        &mut self.hbao_blur_sharpness
    }
    fn temporal_filter_enable(&self) -> &bool {
        &self.temporal_filter_enable
    }
    fn temporal_filter_enable_mut(&mut self) -> &mut bool {
        &mut self.temporal_filter_enable
    }
    fn aao_dynamic_weight(&self) -> &bool {
        &self.aao_dynamic_weight
    }
    fn aao_dynamic_weight_mut(&mut self) -> &mut bool {
        &mut self.aao_dynamic_weight
    }
    fn aao_bias(&self) -> &f32 {
        &self.aao_bias
    }
    fn aao_bias_mut(&mut self) -> &mut f32 {
        &mut self.aao_bias
    }
    fn aao_intensity(&self) -> &f32 {
        &self.aao_intensity
    }
    fn aao_intensity_mut(&mut self) -> &mut f32 {
        &mut self.aao_intensity
    }
    fn aao_contrast(&self) -> &f32 {
        &self.aao_contrast
    }
    fn aao_contrast_mut(&mut self) -> &mut f32 {
        &mut self.aao_contrast
    }
    fn aao_range_reduction(&self) -> &f32 {
        &self.aao_range_reduction
    }
    fn aao_range_reduction_mut(&mut self) -> &mut f32 {
        &mut self.aao_range_reduction
    }
    fn aao_screen_radius(&self) -> &f32 {
        &self.aao_screen_radius
    }
    fn aao_screen_radius_mut(&mut self) -> &mut f32 {
        &mut self.aao_screen_radius
    }
    fn aao_near_occlusion_max(&self) -> &f32 {
        &self.aao_near_occlusion_max
    }
    fn aao_near_occlusion_max_mut(&mut self) -> &mut f32 {
        &mut self.aao_near_occlusion_max
    }
    fn aao_near_falloff_threshold(&self) -> &f32 {
        &self.aao_near_falloff_threshold
    }
    fn aao_near_falloff_threshold_mut(&mut self) -> &mut f32 {
        &mut self.aao_near_falloff_threshold
    }
    fn aao_clip_distance(&self) -> &f32 {
        &self.aao_clip_distance
    }
    fn aao_clip_distance_mut(&mut self) -> &mut f32 {
        &mut self.aao_clip_distance
    }
    fn aao_clip_fade_distance(&self) -> &f32 {
        &self.aao_clip_fade_distance
    }
    fn aao_clip_fade_distance_mut(&mut self) -> &mut f32 {
        &mut self.aao_clip_fade_distance
    }
    fn aao_blur_depth_threshold(&self) -> &f32 {
        &self.aao_blur_depth_threshold
    }
    fn aao_blur_depth_threshold_mut(&mut self) -> &mut f32 {
        &mut self.aao_blur_depth_threshold
    }
    fn aao_blur_const_falloff(&self) -> &f32 {
        &self.aao_blur_const_falloff
    }
    fn aao_blur_const_falloff_mut(&mut self) -> &mut f32 {
        &mut self.aao_blur_const_falloff
    }
    fn field_flag_override0(&self) -> &u32 {
        &self.field_flag_override0
    }
    fn field_flag_override0_mut(&mut self) -> &mut u32 {
        &mut self.field_flag_override0
    }
}

impl VisualEnvironmentComponentDataTrait for DynamicAOComponentData {
    fn property_overrides(&self) -> &Vec<String> {
        self._glacier_base.property_overrides()
    }
    fn property_overrides_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.property_overrides_mut()
    }
}

impl super::entity::ComponentDataTrait for DynamicAOComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for DynamicAOComponentData {
}

impl super::core::DataBusPeerTrait for DynamicAOComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for DynamicAOComponentData {
}

impl super::core::DataContainerTrait for DynamicAOComponentData {
}

pub static DYNAMICAOCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicAOComponentData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VISUALENVIRONMENTCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DynamicAOComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DynamicAOComponentData, enable),
            },
            FieldInfoData {
                name: "AffectOutdoorLight",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DynamicAOComponentData, affect_outdoor_light),
            },
            FieldInfoData {
                name: "AffectLocalLight",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DynamicAOComponentData, affect_local_light),
            },
            FieldInfoData {
                name: "DynamicAOFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicAOComponentData, dynamic_a_o_factor),
            },
            FieldInfoData {
                name: "SsaoFade",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicAOComponentData, ssao_fade),
            },
            FieldInfoData {
                name: "SsaoRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicAOComponentData, ssao_radius),
            },
            FieldInfoData {
                name: "SsaoMaxDistanceInner",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicAOComponentData, ssao_max_distance_inner),
            },
            FieldInfoData {
                name: "SsaoMaxDistanceOuter",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicAOComponentData, ssao_max_distance_outer),
            },
            FieldInfoData {
                name: "HbaoRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicAOComponentData, hbao_radius),
            },
            FieldInfoData {
                name: "HbaoAngleBias",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicAOComponentData, hbao_angle_bias),
            },
            FieldInfoData {
                name: "HbaoAttenuation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicAOComponentData, hbao_attenuation),
            },
            FieldInfoData {
                name: "HbaoContrast",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicAOComponentData, hbao_contrast),
            },
            FieldInfoData {
                name: "HbaoMaxFootprintRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicAOComponentData, hbao_max_footprint_radius),
            },
            FieldInfoData {
                name: "HbaoPowerExponent",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicAOComponentData, hbao_power_exponent),
            },
            FieldInfoData {
                name: "HbaoBlurRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicAOComponentData, hbao_blur_radius),
            },
            FieldInfoData {
                name: "HbaoBlurSharpness",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicAOComponentData, hbao_blur_sharpness),
            },
            FieldInfoData {
                name: "TemporalFilterEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DynamicAOComponentData, temporal_filter_enable),
            },
            FieldInfoData {
                name: "AaoDynamicWeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DynamicAOComponentData, aao_dynamic_weight),
            },
            FieldInfoData {
                name: "AaoBias",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicAOComponentData, aao_bias),
            },
            FieldInfoData {
                name: "AaoIntensity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicAOComponentData, aao_intensity),
            },
            FieldInfoData {
                name: "AaoContrast",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicAOComponentData, aao_contrast),
            },
            FieldInfoData {
                name: "AaoRangeReduction",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicAOComponentData, aao_range_reduction),
            },
            FieldInfoData {
                name: "AaoScreenRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicAOComponentData, aao_screen_radius),
            },
            FieldInfoData {
                name: "AaoNearOcclusionMax",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicAOComponentData, aao_near_occlusion_max),
            },
            FieldInfoData {
                name: "AaoNearFalloffThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicAOComponentData, aao_near_falloff_threshold),
            },
            FieldInfoData {
                name: "AaoClipDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicAOComponentData, aao_clip_distance),
            },
            FieldInfoData {
                name: "AaoClipFadeDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicAOComponentData, aao_clip_fade_distance),
            },
            FieldInfoData {
                name: "AaoBlurDepthThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicAOComponentData, aao_blur_depth_threshold),
            },
            FieldInfoData {
                name: "AaoBlurConstFalloff",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicAOComponentData, aao_blur_const_falloff),
            },
            FieldInfoData {
                name: "FieldFlagOverride0",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(DynamicAOComponentData, field_flag_override0),
            },
        ],
    }),
    array_type: Some(DYNAMICAOCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for DynamicAOComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        DYNAMICAOCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DYNAMICAOCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicAOComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("DynamicAOComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AntiAliasComponentData {
    pub _glacier_base: VisualEnvironmentComponentData,
    pub enable: bool,
    pub disocclusion_rejection_factor: f32,
    pub field_flag_override0: u8,
}

pub trait AntiAliasComponentDataTrait: VisualEnvironmentComponentDataTrait {
    fn enable(&self) -> &bool;
    fn enable_mut(&mut self) -> &mut bool;
    fn disocclusion_rejection_factor(&self) -> &f32;
    fn disocclusion_rejection_factor_mut(&mut self) -> &mut f32;
    fn field_flag_override0(&self) -> &u8;
    fn field_flag_override0_mut(&mut self) -> &mut u8;
}

impl AntiAliasComponentDataTrait for AntiAliasComponentData {
    fn enable(&self) -> &bool {
        &self.enable
    }
    fn enable_mut(&mut self) -> &mut bool {
        &mut self.enable
    }
    fn disocclusion_rejection_factor(&self) -> &f32 {
        &self.disocclusion_rejection_factor
    }
    fn disocclusion_rejection_factor_mut(&mut self) -> &mut f32 {
        &mut self.disocclusion_rejection_factor
    }
    fn field_flag_override0(&self) -> &u8 {
        &self.field_flag_override0
    }
    fn field_flag_override0_mut(&mut self) -> &mut u8 {
        &mut self.field_flag_override0
    }
}

impl VisualEnvironmentComponentDataTrait for AntiAliasComponentData {
    fn property_overrides(&self) -> &Vec<String> {
        self._glacier_base.property_overrides()
    }
    fn property_overrides_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.property_overrides_mut()
    }
}

impl super::entity::ComponentDataTrait for AntiAliasComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for AntiAliasComponentData {
}

impl super::core::DataBusPeerTrait for AntiAliasComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AntiAliasComponentData {
}

impl super::core::DataContainerTrait for AntiAliasComponentData {
}

pub static ANTIALIASCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntiAliasComponentData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VISUALENVIRONMENTCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AntiAliasComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AntiAliasComponentData, enable),
            },
            FieldInfoData {
                name: "DisocclusionRejectionFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AntiAliasComponentData, disocclusion_rejection_factor),
            },
            FieldInfoData {
                name: "FieldFlagOverride0",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(AntiAliasComponentData, field_flag_override0),
            },
        ],
    }),
    array_type: Some(ANTIALIASCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AntiAliasComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        ANTIALIASCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANTIALIASCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntiAliasComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("AntiAliasComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LensReflectionComponentData {
    pub _glacier_base: VisualEnvironmentComponentData,
    pub enable: bool,
    pub inner_color: super::core::Vec3,
    pub outer_color: super::core::Vec3,
    pub mix_start: f32,
    pub mix_stop: f32,
    pub input_exponent: f32,
    pub luminance_threshold: f32,
    pub input_scale: f32,
    pub max_opacity: f32,
    pub transpose_reflection: bool,
    pub scale: f32,
    pub distortion_factor: f32,
    pub vertical_stretch: f32,
    pub field_flag_override0: u16,
}

pub trait LensReflectionComponentDataTrait: VisualEnvironmentComponentDataTrait {
    fn enable(&self) -> &bool;
    fn enable_mut(&mut self) -> &mut bool;
    fn inner_color(&self) -> &super::core::Vec3;
    fn inner_color_mut(&mut self) -> &mut super::core::Vec3;
    fn outer_color(&self) -> &super::core::Vec3;
    fn outer_color_mut(&mut self) -> &mut super::core::Vec3;
    fn mix_start(&self) -> &f32;
    fn mix_start_mut(&mut self) -> &mut f32;
    fn mix_stop(&self) -> &f32;
    fn mix_stop_mut(&mut self) -> &mut f32;
    fn input_exponent(&self) -> &f32;
    fn input_exponent_mut(&mut self) -> &mut f32;
    fn luminance_threshold(&self) -> &f32;
    fn luminance_threshold_mut(&mut self) -> &mut f32;
    fn input_scale(&self) -> &f32;
    fn input_scale_mut(&mut self) -> &mut f32;
    fn max_opacity(&self) -> &f32;
    fn max_opacity_mut(&mut self) -> &mut f32;
    fn transpose_reflection(&self) -> &bool;
    fn transpose_reflection_mut(&mut self) -> &mut bool;
    fn scale(&self) -> &f32;
    fn scale_mut(&mut self) -> &mut f32;
    fn distortion_factor(&self) -> &f32;
    fn distortion_factor_mut(&mut self) -> &mut f32;
    fn vertical_stretch(&self) -> &f32;
    fn vertical_stretch_mut(&mut self) -> &mut f32;
    fn field_flag_override0(&self) -> &u16;
    fn field_flag_override0_mut(&mut self) -> &mut u16;
}

impl LensReflectionComponentDataTrait for LensReflectionComponentData {
    fn enable(&self) -> &bool {
        &self.enable
    }
    fn enable_mut(&mut self) -> &mut bool {
        &mut self.enable
    }
    fn inner_color(&self) -> &super::core::Vec3 {
        &self.inner_color
    }
    fn inner_color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.inner_color
    }
    fn outer_color(&self) -> &super::core::Vec3 {
        &self.outer_color
    }
    fn outer_color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.outer_color
    }
    fn mix_start(&self) -> &f32 {
        &self.mix_start
    }
    fn mix_start_mut(&mut self) -> &mut f32 {
        &mut self.mix_start
    }
    fn mix_stop(&self) -> &f32 {
        &self.mix_stop
    }
    fn mix_stop_mut(&mut self) -> &mut f32 {
        &mut self.mix_stop
    }
    fn input_exponent(&self) -> &f32 {
        &self.input_exponent
    }
    fn input_exponent_mut(&mut self) -> &mut f32 {
        &mut self.input_exponent
    }
    fn luminance_threshold(&self) -> &f32 {
        &self.luminance_threshold
    }
    fn luminance_threshold_mut(&mut self) -> &mut f32 {
        &mut self.luminance_threshold
    }
    fn input_scale(&self) -> &f32 {
        &self.input_scale
    }
    fn input_scale_mut(&mut self) -> &mut f32 {
        &mut self.input_scale
    }
    fn max_opacity(&self) -> &f32 {
        &self.max_opacity
    }
    fn max_opacity_mut(&mut self) -> &mut f32 {
        &mut self.max_opacity
    }
    fn transpose_reflection(&self) -> &bool {
        &self.transpose_reflection
    }
    fn transpose_reflection_mut(&mut self) -> &mut bool {
        &mut self.transpose_reflection
    }
    fn scale(&self) -> &f32 {
        &self.scale
    }
    fn scale_mut(&mut self) -> &mut f32 {
        &mut self.scale
    }
    fn distortion_factor(&self) -> &f32 {
        &self.distortion_factor
    }
    fn distortion_factor_mut(&mut self) -> &mut f32 {
        &mut self.distortion_factor
    }
    fn vertical_stretch(&self) -> &f32 {
        &self.vertical_stretch
    }
    fn vertical_stretch_mut(&mut self) -> &mut f32 {
        &mut self.vertical_stretch
    }
    fn field_flag_override0(&self) -> &u16 {
        &self.field_flag_override0
    }
    fn field_flag_override0_mut(&mut self) -> &mut u16 {
        &mut self.field_flag_override0
    }
}

impl VisualEnvironmentComponentDataTrait for LensReflectionComponentData {
    fn property_overrides(&self) -> &Vec<String> {
        self._glacier_base.property_overrides()
    }
    fn property_overrides_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.property_overrides_mut()
    }
}

impl super::entity::ComponentDataTrait for LensReflectionComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for LensReflectionComponentData {
}

impl super::core::DataBusPeerTrait for LensReflectionComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for LensReflectionComponentData {
}

impl super::core::DataContainerTrait for LensReflectionComponentData {
}

pub static LENSREFLECTIONCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LensReflectionComponentData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VISUALENVIRONMENTCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LensReflectionComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LensReflectionComponentData, enable),
            },
            FieldInfoData {
                name: "InnerColor",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(LensReflectionComponentData, inner_color),
            },
            FieldInfoData {
                name: "OuterColor",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(LensReflectionComponentData, outer_color),
            },
            FieldInfoData {
                name: "MixStart",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LensReflectionComponentData, mix_start),
            },
            FieldInfoData {
                name: "MixStop",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LensReflectionComponentData, mix_stop),
            },
            FieldInfoData {
                name: "InputExponent",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LensReflectionComponentData, input_exponent),
            },
            FieldInfoData {
                name: "LuminanceThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LensReflectionComponentData, luminance_threshold),
            },
            FieldInfoData {
                name: "InputScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LensReflectionComponentData, input_scale),
            },
            FieldInfoData {
                name: "MaxOpacity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LensReflectionComponentData, max_opacity),
            },
            FieldInfoData {
                name: "TransposeReflection",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LensReflectionComponentData, transpose_reflection),
            },
            FieldInfoData {
                name: "Scale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LensReflectionComponentData, scale),
            },
            FieldInfoData {
                name: "DistortionFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LensReflectionComponentData, distortion_factor),
            },
            FieldInfoData {
                name: "VerticalStretch",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LensReflectionComponentData, vertical_stretch),
            },
            FieldInfoData {
                name: "FieldFlagOverride0",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint16",
                rust_offset: offset_of!(LensReflectionComponentData, field_flag_override0),
            },
        ],
    }),
    array_type: Some(LENSREFLECTIONCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for LensReflectionComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        LENSREFLECTIONCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LENSREFLECTIONCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LensReflectionComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("LensReflectionComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SunFlareComponentData {
    pub _glacier_base: VisualEnvironmentComponentData,
    pub enable: bool,
    pub debug_draw_occluder: bool,
    pub occluder_size: f32,
    pub screen_clip: bool,
    pub render_mode: super::world_base::LensFlareRenderMode,
    pub use_sun_position: bool,
    pub rotation_x: f32,
    pub rotation_y: f32,
    pub element1_enable: bool,
    pub element1_shader: super::render_base::SurfaceShaderInstanceDataStruct,
    pub element1_ray_distance: f32,
    pub element1_size: super::core::Vec2,
    pub element1_size_occluder_curve: super::core::Vec4,
    pub element1_size_screen_pos_curve: super::core::Vec4,
    pub element1_alpha_occluder_curve: super::core::Vec4,
    pub element1_alpha_screen_pos_curve: super::core::Vec4,
    pub element1_rotation_local: f32,
    pub element1_rotation_aligned_to_ray: bool,
    pub element1_rotation_dist_curve: super::core::Vec4,
    pub element1_rotation_dist_multiplier: f32,
    pub element2_enable: bool,
    pub element2_shader: super::render_base::SurfaceShaderInstanceDataStruct,
    pub element2_ray_distance: f32,
    pub element2_size: super::core::Vec2,
    pub element2_size_occluder_curve: super::core::Vec4,
    pub element2_size_screen_pos_curve: super::core::Vec4,
    pub element2_alpha_occluder_curve: super::core::Vec4,
    pub element2_alpha_screen_pos_curve: super::core::Vec4,
    pub element2_rotation_local: f32,
    pub element2_rotation_aligned_to_ray: bool,
    pub element2_rotation_dist_curve: super::core::Vec4,
    pub element2_rotation_dist_multiplier: f32,
    pub element3_enable: bool,
    pub element3_shader: super::render_base::SurfaceShaderInstanceDataStruct,
    pub element3_ray_distance: f32,
    pub element3_size: super::core::Vec2,
    pub element3_size_occluder_curve: super::core::Vec4,
    pub element3_size_screen_pos_curve: super::core::Vec4,
    pub element3_alpha_occluder_curve: super::core::Vec4,
    pub element3_alpha_screen_pos_curve: super::core::Vec4,
    pub element3_rotation_local: f32,
    pub element3_rotation_aligned_to_ray: bool,
    pub element3_rotation_dist_curve: super::core::Vec4,
    pub element3_rotation_dist_multiplier: f32,
    pub element4_enable: bool,
    pub element4_shader: super::render_base::SurfaceShaderInstanceDataStruct,
    pub element4_ray_distance: f32,
    pub element4_size: super::core::Vec2,
    pub element4_size_occluder_curve: super::core::Vec4,
    pub element4_size_screen_pos_curve: super::core::Vec4,
    pub element4_alpha_occluder_curve: super::core::Vec4,
    pub element4_alpha_screen_pos_curve: super::core::Vec4,
    pub element4_rotation_local: f32,
    pub element4_rotation_aligned_to_ray: bool,
    pub element4_rotation_dist_curve: super::core::Vec4,
    pub element4_rotation_dist_multiplier: f32,
    pub element5_enable: bool,
    pub element5_shader: super::render_base::SurfaceShaderInstanceDataStruct,
    pub element5_ray_distance: f32,
    pub element5_size: super::core::Vec2,
    pub element5_size_occluder_curve: super::core::Vec4,
    pub element5_size_screen_pos_curve: super::core::Vec4,
    pub element5_alpha_occluder_curve: super::core::Vec4,
    pub element5_alpha_screen_pos_curve: super::core::Vec4,
    pub element5_rotation_local: f32,
    pub element5_rotation_aligned_to_ray: bool,
    pub element5_rotation_dist_curve: super::core::Vec4,
    pub element5_rotation_dist_multiplier: f32,
    pub field_flag_override0: u32,
    pub field_flag_override1: u32,
    pub field_flag_override2: u8,
}

pub trait SunFlareComponentDataTrait: VisualEnvironmentComponentDataTrait {
    fn enable(&self) -> &bool;
    fn enable_mut(&mut self) -> &mut bool;
    fn debug_draw_occluder(&self) -> &bool;
    fn debug_draw_occluder_mut(&mut self) -> &mut bool;
    fn occluder_size(&self) -> &f32;
    fn occluder_size_mut(&mut self) -> &mut f32;
    fn screen_clip(&self) -> &bool;
    fn screen_clip_mut(&mut self) -> &mut bool;
    fn render_mode(&self) -> &super::world_base::LensFlareRenderMode;
    fn render_mode_mut(&mut self) -> &mut super::world_base::LensFlareRenderMode;
    fn use_sun_position(&self) -> &bool;
    fn use_sun_position_mut(&mut self) -> &mut bool;
    fn rotation_x(&self) -> &f32;
    fn rotation_x_mut(&mut self) -> &mut f32;
    fn rotation_y(&self) -> &f32;
    fn rotation_y_mut(&mut self) -> &mut f32;
    fn element1_enable(&self) -> &bool;
    fn element1_enable_mut(&mut self) -> &mut bool;
    fn element1_shader(&self) -> &super::render_base::SurfaceShaderInstanceDataStruct;
    fn element1_shader_mut(&mut self) -> &mut super::render_base::SurfaceShaderInstanceDataStruct;
    fn element1_ray_distance(&self) -> &f32;
    fn element1_ray_distance_mut(&mut self) -> &mut f32;
    fn element1_size(&self) -> &super::core::Vec2;
    fn element1_size_mut(&mut self) -> &mut super::core::Vec2;
    fn element1_size_occluder_curve(&self) -> &super::core::Vec4;
    fn element1_size_occluder_curve_mut(&mut self) -> &mut super::core::Vec4;
    fn element1_size_screen_pos_curve(&self) -> &super::core::Vec4;
    fn element1_size_screen_pos_curve_mut(&mut self) -> &mut super::core::Vec4;
    fn element1_alpha_occluder_curve(&self) -> &super::core::Vec4;
    fn element1_alpha_occluder_curve_mut(&mut self) -> &mut super::core::Vec4;
    fn element1_alpha_screen_pos_curve(&self) -> &super::core::Vec4;
    fn element1_alpha_screen_pos_curve_mut(&mut self) -> &mut super::core::Vec4;
    fn element1_rotation_local(&self) -> &f32;
    fn element1_rotation_local_mut(&mut self) -> &mut f32;
    fn element1_rotation_aligned_to_ray(&self) -> &bool;
    fn element1_rotation_aligned_to_ray_mut(&mut self) -> &mut bool;
    fn element1_rotation_dist_curve(&self) -> &super::core::Vec4;
    fn element1_rotation_dist_curve_mut(&mut self) -> &mut super::core::Vec4;
    fn element1_rotation_dist_multiplier(&self) -> &f32;
    fn element1_rotation_dist_multiplier_mut(&mut self) -> &mut f32;
    fn element2_enable(&self) -> &bool;
    fn element2_enable_mut(&mut self) -> &mut bool;
    fn element2_shader(&self) -> &super::render_base::SurfaceShaderInstanceDataStruct;
    fn element2_shader_mut(&mut self) -> &mut super::render_base::SurfaceShaderInstanceDataStruct;
    fn element2_ray_distance(&self) -> &f32;
    fn element2_ray_distance_mut(&mut self) -> &mut f32;
    fn element2_size(&self) -> &super::core::Vec2;
    fn element2_size_mut(&mut self) -> &mut super::core::Vec2;
    fn element2_size_occluder_curve(&self) -> &super::core::Vec4;
    fn element2_size_occluder_curve_mut(&mut self) -> &mut super::core::Vec4;
    fn element2_size_screen_pos_curve(&self) -> &super::core::Vec4;
    fn element2_size_screen_pos_curve_mut(&mut self) -> &mut super::core::Vec4;
    fn element2_alpha_occluder_curve(&self) -> &super::core::Vec4;
    fn element2_alpha_occluder_curve_mut(&mut self) -> &mut super::core::Vec4;
    fn element2_alpha_screen_pos_curve(&self) -> &super::core::Vec4;
    fn element2_alpha_screen_pos_curve_mut(&mut self) -> &mut super::core::Vec4;
    fn element2_rotation_local(&self) -> &f32;
    fn element2_rotation_local_mut(&mut self) -> &mut f32;
    fn element2_rotation_aligned_to_ray(&self) -> &bool;
    fn element2_rotation_aligned_to_ray_mut(&mut self) -> &mut bool;
    fn element2_rotation_dist_curve(&self) -> &super::core::Vec4;
    fn element2_rotation_dist_curve_mut(&mut self) -> &mut super::core::Vec4;
    fn element2_rotation_dist_multiplier(&self) -> &f32;
    fn element2_rotation_dist_multiplier_mut(&mut self) -> &mut f32;
    fn element3_enable(&self) -> &bool;
    fn element3_enable_mut(&mut self) -> &mut bool;
    fn element3_shader(&self) -> &super::render_base::SurfaceShaderInstanceDataStruct;
    fn element3_shader_mut(&mut self) -> &mut super::render_base::SurfaceShaderInstanceDataStruct;
    fn element3_ray_distance(&self) -> &f32;
    fn element3_ray_distance_mut(&mut self) -> &mut f32;
    fn element3_size(&self) -> &super::core::Vec2;
    fn element3_size_mut(&mut self) -> &mut super::core::Vec2;
    fn element3_size_occluder_curve(&self) -> &super::core::Vec4;
    fn element3_size_occluder_curve_mut(&mut self) -> &mut super::core::Vec4;
    fn element3_size_screen_pos_curve(&self) -> &super::core::Vec4;
    fn element3_size_screen_pos_curve_mut(&mut self) -> &mut super::core::Vec4;
    fn element3_alpha_occluder_curve(&self) -> &super::core::Vec4;
    fn element3_alpha_occluder_curve_mut(&mut self) -> &mut super::core::Vec4;
    fn element3_alpha_screen_pos_curve(&self) -> &super::core::Vec4;
    fn element3_alpha_screen_pos_curve_mut(&mut self) -> &mut super::core::Vec4;
    fn element3_rotation_local(&self) -> &f32;
    fn element3_rotation_local_mut(&mut self) -> &mut f32;
    fn element3_rotation_aligned_to_ray(&self) -> &bool;
    fn element3_rotation_aligned_to_ray_mut(&mut self) -> &mut bool;
    fn element3_rotation_dist_curve(&self) -> &super::core::Vec4;
    fn element3_rotation_dist_curve_mut(&mut self) -> &mut super::core::Vec4;
    fn element3_rotation_dist_multiplier(&self) -> &f32;
    fn element3_rotation_dist_multiplier_mut(&mut self) -> &mut f32;
    fn element4_enable(&self) -> &bool;
    fn element4_enable_mut(&mut self) -> &mut bool;
    fn element4_shader(&self) -> &super::render_base::SurfaceShaderInstanceDataStruct;
    fn element4_shader_mut(&mut self) -> &mut super::render_base::SurfaceShaderInstanceDataStruct;
    fn element4_ray_distance(&self) -> &f32;
    fn element4_ray_distance_mut(&mut self) -> &mut f32;
    fn element4_size(&self) -> &super::core::Vec2;
    fn element4_size_mut(&mut self) -> &mut super::core::Vec2;
    fn element4_size_occluder_curve(&self) -> &super::core::Vec4;
    fn element4_size_occluder_curve_mut(&mut self) -> &mut super::core::Vec4;
    fn element4_size_screen_pos_curve(&self) -> &super::core::Vec4;
    fn element4_size_screen_pos_curve_mut(&mut self) -> &mut super::core::Vec4;
    fn element4_alpha_occluder_curve(&self) -> &super::core::Vec4;
    fn element4_alpha_occluder_curve_mut(&mut self) -> &mut super::core::Vec4;
    fn element4_alpha_screen_pos_curve(&self) -> &super::core::Vec4;
    fn element4_alpha_screen_pos_curve_mut(&mut self) -> &mut super::core::Vec4;
    fn element4_rotation_local(&self) -> &f32;
    fn element4_rotation_local_mut(&mut self) -> &mut f32;
    fn element4_rotation_aligned_to_ray(&self) -> &bool;
    fn element4_rotation_aligned_to_ray_mut(&mut self) -> &mut bool;
    fn element4_rotation_dist_curve(&self) -> &super::core::Vec4;
    fn element4_rotation_dist_curve_mut(&mut self) -> &mut super::core::Vec4;
    fn element4_rotation_dist_multiplier(&self) -> &f32;
    fn element4_rotation_dist_multiplier_mut(&mut self) -> &mut f32;
    fn element5_enable(&self) -> &bool;
    fn element5_enable_mut(&mut self) -> &mut bool;
    fn element5_shader(&self) -> &super::render_base::SurfaceShaderInstanceDataStruct;
    fn element5_shader_mut(&mut self) -> &mut super::render_base::SurfaceShaderInstanceDataStruct;
    fn element5_ray_distance(&self) -> &f32;
    fn element5_ray_distance_mut(&mut self) -> &mut f32;
    fn element5_size(&self) -> &super::core::Vec2;
    fn element5_size_mut(&mut self) -> &mut super::core::Vec2;
    fn element5_size_occluder_curve(&self) -> &super::core::Vec4;
    fn element5_size_occluder_curve_mut(&mut self) -> &mut super::core::Vec4;
    fn element5_size_screen_pos_curve(&self) -> &super::core::Vec4;
    fn element5_size_screen_pos_curve_mut(&mut self) -> &mut super::core::Vec4;
    fn element5_alpha_occluder_curve(&self) -> &super::core::Vec4;
    fn element5_alpha_occluder_curve_mut(&mut self) -> &mut super::core::Vec4;
    fn element5_alpha_screen_pos_curve(&self) -> &super::core::Vec4;
    fn element5_alpha_screen_pos_curve_mut(&mut self) -> &mut super::core::Vec4;
    fn element5_rotation_local(&self) -> &f32;
    fn element5_rotation_local_mut(&mut self) -> &mut f32;
    fn element5_rotation_aligned_to_ray(&self) -> &bool;
    fn element5_rotation_aligned_to_ray_mut(&mut self) -> &mut bool;
    fn element5_rotation_dist_curve(&self) -> &super::core::Vec4;
    fn element5_rotation_dist_curve_mut(&mut self) -> &mut super::core::Vec4;
    fn element5_rotation_dist_multiplier(&self) -> &f32;
    fn element5_rotation_dist_multiplier_mut(&mut self) -> &mut f32;
    fn field_flag_override0(&self) -> &u32;
    fn field_flag_override0_mut(&mut self) -> &mut u32;
    fn field_flag_override1(&self) -> &u32;
    fn field_flag_override1_mut(&mut self) -> &mut u32;
    fn field_flag_override2(&self) -> &u8;
    fn field_flag_override2_mut(&mut self) -> &mut u8;
}

impl SunFlareComponentDataTrait for SunFlareComponentData {
    fn enable(&self) -> &bool {
        &self.enable
    }
    fn enable_mut(&mut self) -> &mut bool {
        &mut self.enable
    }
    fn debug_draw_occluder(&self) -> &bool {
        &self.debug_draw_occluder
    }
    fn debug_draw_occluder_mut(&mut self) -> &mut bool {
        &mut self.debug_draw_occluder
    }
    fn occluder_size(&self) -> &f32 {
        &self.occluder_size
    }
    fn occluder_size_mut(&mut self) -> &mut f32 {
        &mut self.occluder_size
    }
    fn screen_clip(&self) -> &bool {
        &self.screen_clip
    }
    fn screen_clip_mut(&mut self) -> &mut bool {
        &mut self.screen_clip
    }
    fn render_mode(&self) -> &super::world_base::LensFlareRenderMode {
        &self.render_mode
    }
    fn render_mode_mut(&mut self) -> &mut super::world_base::LensFlareRenderMode {
        &mut self.render_mode
    }
    fn use_sun_position(&self) -> &bool {
        &self.use_sun_position
    }
    fn use_sun_position_mut(&mut self) -> &mut bool {
        &mut self.use_sun_position
    }
    fn rotation_x(&self) -> &f32 {
        &self.rotation_x
    }
    fn rotation_x_mut(&mut self) -> &mut f32 {
        &mut self.rotation_x
    }
    fn rotation_y(&self) -> &f32 {
        &self.rotation_y
    }
    fn rotation_y_mut(&mut self) -> &mut f32 {
        &mut self.rotation_y
    }
    fn element1_enable(&self) -> &bool {
        &self.element1_enable
    }
    fn element1_enable_mut(&mut self) -> &mut bool {
        &mut self.element1_enable
    }
    fn element1_shader(&self) -> &super::render_base::SurfaceShaderInstanceDataStruct {
        &self.element1_shader
    }
    fn element1_shader_mut(&mut self) -> &mut super::render_base::SurfaceShaderInstanceDataStruct {
        &mut self.element1_shader
    }
    fn element1_ray_distance(&self) -> &f32 {
        &self.element1_ray_distance
    }
    fn element1_ray_distance_mut(&mut self) -> &mut f32 {
        &mut self.element1_ray_distance
    }
    fn element1_size(&self) -> &super::core::Vec2 {
        &self.element1_size
    }
    fn element1_size_mut(&mut self) -> &mut super::core::Vec2 {
        &mut self.element1_size
    }
    fn element1_size_occluder_curve(&self) -> &super::core::Vec4 {
        &self.element1_size_occluder_curve
    }
    fn element1_size_occluder_curve_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.element1_size_occluder_curve
    }
    fn element1_size_screen_pos_curve(&self) -> &super::core::Vec4 {
        &self.element1_size_screen_pos_curve
    }
    fn element1_size_screen_pos_curve_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.element1_size_screen_pos_curve
    }
    fn element1_alpha_occluder_curve(&self) -> &super::core::Vec4 {
        &self.element1_alpha_occluder_curve
    }
    fn element1_alpha_occluder_curve_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.element1_alpha_occluder_curve
    }
    fn element1_alpha_screen_pos_curve(&self) -> &super::core::Vec4 {
        &self.element1_alpha_screen_pos_curve
    }
    fn element1_alpha_screen_pos_curve_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.element1_alpha_screen_pos_curve
    }
    fn element1_rotation_local(&self) -> &f32 {
        &self.element1_rotation_local
    }
    fn element1_rotation_local_mut(&mut self) -> &mut f32 {
        &mut self.element1_rotation_local
    }
    fn element1_rotation_aligned_to_ray(&self) -> &bool {
        &self.element1_rotation_aligned_to_ray
    }
    fn element1_rotation_aligned_to_ray_mut(&mut self) -> &mut bool {
        &mut self.element1_rotation_aligned_to_ray
    }
    fn element1_rotation_dist_curve(&self) -> &super::core::Vec4 {
        &self.element1_rotation_dist_curve
    }
    fn element1_rotation_dist_curve_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.element1_rotation_dist_curve
    }
    fn element1_rotation_dist_multiplier(&self) -> &f32 {
        &self.element1_rotation_dist_multiplier
    }
    fn element1_rotation_dist_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.element1_rotation_dist_multiplier
    }
    fn element2_enable(&self) -> &bool {
        &self.element2_enable
    }
    fn element2_enable_mut(&mut self) -> &mut bool {
        &mut self.element2_enable
    }
    fn element2_shader(&self) -> &super::render_base::SurfaceShaderInstanceDataStruct {
        &self.element2_shader
    }
    fn element2_shader_mut(&mut self) -> &mut super::render_base::SurfaceShaderInstanceDataStruct {
        &mut self.element2_shader
    }
    fn element2_ray_distance(&self) -> &f32 {
        &self.element2_ray_distance
    }
    fn element2_ray_distance_mut(&mut self) -> &mut f32 {
        &mut self.element2_ray_distance
    }
    fn element2_size(&self) -> &super::core::Vec2 {
        &self.element2_size
    }
    fn element2_size_mut(&mut self) -> &mut super::core::Vec2 {
        &mut self.element2_size
    }
    fn element2_size_occluder_curve(&self) -> &super::core::Vec4 {
        &self.element2_size_occluder_curve
    }
    fn element2_size_occluder_curve_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.element2_size_occluder_curve
    }
    fn element2_size_screen_pos_curve(&self) -> &super::core::Vec4 {
        &self.element2_size_screen_pos_curve
    }
    fn element2_size_screen_pos_curve_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.element2_size_screen_pos_curve
    }
    fn element2_alpha_occluder_curve(&self) -> &super::core::Vec4 {
        &self.element2_alpha_occluder_curve
    }
    fn element2_alpha_occluder_curve_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.element2_alpha_occluder_curve
    }
    fn element2_alpha_screen_pos_curve(&self) -> &super::core::Vec4 {
        &self.element2_alpha_screen_pos_curve
    }
    fn element2_alpha_screen_pos_curve_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.element2_alpha_screen_pos_curve
    }
    fn element2_rotation_local(&self) -> &f32 {
        &self.element2_rotation_local
    }
    fn element2_rotation_local_mut(&mut self) -> &mut f32 {
        &mut self.element2_rotation_local
    }
    fn element2_rotation_aligned_to_ray(&self) -> &bool {
        &self.element2_rotation_aligned_to_ray
    }
    fn element2_rotation_aligned_to_ray_mut(&mut self) -> &mut bool {
        &mut self.element2_rotation_aligned_to_ray
    }
    fn element2_rotation_dist_curve(&self) -> &super::core::Vec4 {
        &self.element2_rotation_dist_curve
    }
    fn element2_rotation_dist_curve_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.element2_rotation_dist_curve
    }
    fn element2_rotation_dist_multiplier(&self) -> &f32 {
        &self.element2_rotation_dist_multiplier
    }
    fn element2_rotation_dist_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.element2_rotation_dist_multiplier
    }
    fn element3_enable(&self) -> &bool {
        &self.element3_enable
    }
    fn element3_enable_mut(&mut self) -> &mut bool {
        &mut self.element3_enable
    }
    fn element3_shader(&self) -> &super::render_base::SurfaceShaderInstanceDataStruct {
        &self.element3_shader
    }
    fn element3_shader_mut(&mut self) -> &mut super::render_base::SurfaceShaderInstanceDataStruct {
        &mut self.element3_shader
    }
    fn element3_ray_distance(&self) -> &f32 {
        &self.element3_ray_distance
    }
    fn element3_ray_distance_mut(&mut self) -> &mut f32 {
        &mut self.element3_ray_distance
    }
    fn element3_size(&self) -> &super::core::Vec2 {
        &self.element3_size
    }
    fn element3_size_mut(&mut self) -> &mut super::core::Vec2 {
        &mut self.element3_size
    }
    fn element3_size_occluder_curve(&self) -> &super::core::Vec4 {
        &self.element3_size_occluder_curve
    }
    fn element3_size_occluder_curve_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.element3_size_occluder_curve
    }
    fn element3_size_screen_pos_curve(&self) -> &super::core::Vec4 {
        &self.element3_size_screen_pos_curve
    }
    fn element3_size_screen_pos_curve_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.element3_size_screen_pos_curve
    }
    fn element3_alpha_occluder_curve(&self) -> &super::core::Vec4 {
        &self.element3_alpha_occluder_curve
    }
    fn element3_alpha_occluder_curve_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.element3_alpha_occluder_curve
    }
    fn element3_alpha_screen_pos_curve(&self) -> &super::core::Vec4 {
        &self.element3_alpha_screen_pos_curve
    }
    fn element3_alpha_screen_pos_curve_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.element3_alpha_screen_pos_curve
    }
    fn element3_rotation_local(&self) -> &f32 {
        &self.element3_rotation_local
    }
    fn element3_rotation_local_mut(&mut self) -> &mut f32 {
        &mut self.element3_rotation_local
    }
    fn element3_rotation_aligned_to_ray(&self) -> &bool {
        &self.element3_rotation_aligned_to_ray
    }
    fn element3_rotation_aligned_to_ray_mut(&mut self) -> &mut bool {
        &mut self.element3_rotation_aligned_to_ray
    }
    fn element3_rotation_dist_curve(&self) -> &super::core::Vec4 {
        &self.element3_rotation_dist_curve
    }
    fn element3_rotation_dist_curve_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.element3_rotation_dist_curve
    }
    fn element3_rotation_dist_multiplier(&self) -> &f32 {
        &self.element3_rotation_dist_multiplier
    }
    fn element3_rotation_dist_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.element3_rotation_dist_multiplier
    }
    fn element4_enable(&self) -> &bool {
        &self.element4_enable
    }
    fn element4_enable_mut(&mut self) -> &mut bool {
        &mut self.element4_enable
    }
    fn element4_shader(&self) -> &super::render_base::SurfaceShaderInstanceDataStruct {
        &self.element4_shader
    }
    fn element4_shader_mut(&mut self) -> &mut super::render_base::SurfaceShaderInstanceDataStruct {
        &mut self.element4_shader
    }
    fn element4_ray_distance(&self) -> &f32 {
        &self.element4_ray_distance
    }
    fn element4_ray_distance_mut(&mut self) -> &mut f32 {
        &mut self.element4_ray_distance
    }
    fn element4_size(&self) -> &super::core::Vec2 {
        &self.element4_size
    }
    fn element4_size_mut(&mut self) -> &mut super::core::Vec2 {
        &mut self.element4_size
    }
    fn element4_size_occluder_curve(&self) -> &super::core::Vec4 {
        &self.element4_size_occluder_curve
    }
    fn element4_size_occluder_curve_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.element4_size_occluder_curve
    }
    fn element4_size_screen_pos_curve(&self) -> &super::core::Vec4 {
        &self.element4_size_screen_pos_curve
    }
    fn element4_size_screen_pos_curve_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.element4_size_screen_pos_curve
    }
    fn element4_alpha_occluder_curve(&self) -> &super::core::Vec4 {
        &self.element4_alpha_occluder_curve
    }
    fn element4_alpha_occluder_curve_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.element4_alpha_occluder_curve
    }
    fn element4_alpha_screen_pos_curve(&self) -> &super::core::Vec4 {
        &self.element4_alpha_screen_pos_curve
    }
    fn element4_alpha_screen_pos_curve_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.element4_alpha_screen_pos_curve
    }
    fn element4_rotation_local(&self) -> &f32 {
        &self.element4_rotation_local
    }
    fn element4_rotation_local_mut(&mut self) -> &mut f32 {
        &mut self.element4_rotation_local
    }
    fn element4_rotation_aligned_to_ray(&self) -> &bool {
        &self.element4_rotation_aligned_to_ray
    }
    fn element4_rotation_aligned_to_ray_mut(&mut self) -> &mut bool {
        &mut self.element4_rotation_aligned_to_ray
    }
    fn element4_rotation_dist_curve(&self) -> &super::core::Vec4 {
        &self.element4_rotation_dist_curve
    }
    fn element4_rotation_dist_curve_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.element4_rotation_dist_curve
    }
    fn element4_rotation_dist_multiplier(&self) -> &f32 {
        &self.element4_rotation_dist_multiplier
    }
    fn element4_rotation_dist_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.element4_rotation_dist_multiplier
    }
    fn element5_enable(&self) -> &bool {
        &self.element5_enable
    }
    fn element5_enable_mut(&mut self) -> &mut bool {
        &mut self.element5_enable
    }
    fn element5_shader(&self) -> &super::render_base::SurfaceShaderInstanceDataStruct {
        &self.element5_shader
    }
    fn element5_shader_mut(&mut self) -> &mut super::render_base::SurfaceShaderInstanceDataStruct {
        &mut self.element5_shader
    }
    fn element5_ray_distance(&self) -> &f32 {
        &self.element5_ray_distance
    }
    fn element5_ray_distance_mut(&mut self) -> &mut f32 {
        &mut self.element5_ray_distance
    }
    fn element5_size(&self) -> &super::core::Vec2 {
        &self.element5_size
    }
    fn element5_size_mut(&mut self) -> &mut super::core::Vec2 {
        &mut self.element5_size
    }
    fn element5_size_occluder_curve(&self) -> &super::core::Vec4 {
        &self.element5_size_occluder_curve
    }
    fn element5_size_occluder_curve_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.element5_size_occluder_curve
    }
    fn element5_size_screen_pos_curve(&self) -> &super::core::Vec4 {
        &self.element5_size_screen_pos_curve
    }
    fn element5_size_screen_pos_curve_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.element5_size_screen_pos_curve
    }
    fn element5_alpha_occluder_curve(&self) -> &super::core::Vec4 {
        &self.element5_alpha_occluder_curve
    }
    fn element5_alpha_occluder_curve_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.element5_alpha_occluder_curve
    }
    fn element5_alpha_screen_pos_curve(&self) -> &super::core::Vec4 {
        &self.element5_alpha_screen_pos_curve
    }
    fn element5_alpha_screen_pos_curve_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.element5_alpha_screen_pos_curve
    }
    fn element5_rotation_local(&self) -> &f32 {
        &self.element5_rotation_local
    }
    fn element5_rotation_local_mut(&mut self) -> &mut f32 {
        &mut self.element5_rotation_local
    }
    fn element5_rotation_aligned_to_ray(&self) -> &bool {
        &self.element5_rotation_aligned_to_ray
    }
    fn element5_rotation_aligned_to_ray_mut(&mut self) -> &mut bool {
        &mut self.element5_rotation_aligned_to_ray
    }
    fn element5_rotation_dist_curve(&self) -> &super::core::Vec4 {
        &self.element5_rotation_dist_curve
    }
    fn element5_rotation_dist_curve_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.element5_rotation_dist_curve
    }
    fn element5_rotation_dist_multiplier(&self) -> &f32 {
        &self.element5_rotation_dist_multiplier
    }
    fn element5_rotation_dist_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.element5_rotation_dist_multiplier
    }
    fn field_flag_override0(&self) -> &u32 {
        &self.field_flag_override0
    }
    fn field_flag_override0_mut(&mut self) -> &mut u32 {
        &mut self.field_flag_override0
    }
    fn field_flag_override1(&self) -> &u32 {
        &self.field_flag_override1
    }
    fn field_flag_override1_mut(&mut self) -> &mut u32 {
        &mut self.field_flag_override1
    }
    fn field_flag_override2(&self) -> &u8 {
        &self.field_flag_override2
    }
    fn field_flag_override2_mut(&mut self) -> &mut u8 {
        &mut self.field_flag_override2
    }
}

impl VisualEnvironmentComponentDataTrait for SunFlareComponentData {
    fn property_overrides(&self) -> &Vec<String> {
        self._glacier_base.property_overrides()
    }
    fn property_overrides_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.property_overrides_mut()
    }
}

impl super::entity::ComponentDataTrait for SunFlareComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for SunFlareComponentData {
}

impl super::core::DataBusPeerTrait for SunFlareComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SunFlareComponentData {
}

impl super::core::DataContainerTrait for SunFlareComponentData {
}

pub static SUNFLARECOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SunFlareComponentData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VISUALENVIRONMENTCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SunFlareComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SunFlareComponentData, enable),
            },
            FieldInfoData {
                name: "DebugDrawOccluder",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SunFlareComponentData, debug_draw_occluder),
            },
            FieldInfoData {
                name: "OccluderSize",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SunFlareComponentData, occluder_size),
            },
            FieldInfoData {
                name: "ScreenClip",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SunFlareComponentData, screen_clip),
            },
            FieldInfoData {
                name: "RenderMode",
                flags: MemberInfoFlags::new(0),
                field_type: "LensFlareRenderMode",
                rust_offset: offset_of!(SunFlareComponentData, render_mode),
            },
            FieldInfoData {
                name: "UseSunPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SunFlareComponentData, use_sun_position),
            },
            FieldInfoData {
                name: "RotationX",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SunFlareComponentData, rotation_x),
            },
            FieldInfoData {
                name: "RotationY",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SunFlareComponentData, rotation_y),
            },
            FieldInfoData {
                name: "Element1Enable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SunFlareComponentData, element1_enable),
            },
            FieldInfoData {
                name: "Element1Shader",
                flags: MemberInfoFlags::new(0),
                field_type: "SurfaceShaderInstanceDataStruct",
                rust_offset: offset_of!(SunFlareComponentData, element1_shader),
            },
            FieldInfoData {
                name: "Element1RayDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SunFlareComponentData, element1_ray_distance),
            },
            FieldInfoData {
                name: "Element1Size",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(SunFlareComponentData, element1_size),
            },
            FieldInfoData {
                name: "Element1SizeOccluderCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(SunFlareComponentData, element1_size_occluder_curve),
            },
            FieldInfoData {
                name: "Element1SizeScreenPosCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(SunFlareComponentData, element1_size_screen_pos_curve),
            },
            FieldInfoData {
                name: "Element1AlphaOccluderCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(SunFlareComponentData, element1_alpha_occluder_curve),
            },
            FieldInfoData {
                name: "Element1AlphaScreenPosCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(SunFlareComponentData, element1_alpha_screen_pos_curve),
            },
            FieldInfoData {
                name: "Element1RotationLocal",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SunFlareComponentData, element1_rotation_local),
            },
            FieldInfoData {
                name: "Element1RotationAlignedToRay",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SunFlareComponentData, element1_rotation_aligned_to_ray),
            },
            FieldInfoData {
                name: "Element1RotationDistCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(SunFlareComponentData, element1_rotation_dist_curve),
            },
            FieldInfoData {
                name: "Element1RotationDistMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SunFlareComponentData, element1_rotation_dist_multiplier),
            },
            FieldInfoData {
                name: "Element2Enable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SunFlareComponentData, element2_enable),
            },
            FieldInfoData {
                name: "Element2Shader",
                flags: MemberInfoFlags::new(0),
                field_type: "SurfaceShaderInstanceDataStruct",
                rust_offset: offset_of!(SunFlareComponentData, element2_shader),
            },
            FieldInfoData {
                name: "Element2RayDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SunFlareComponentData, element2_ray_distance),
            },
            FieldInfoData {
                name: "Element2Size",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(SunFlareComponentData, element2_size),
            },
            FieldInfoData {
                name: "Element2SizeOccluderCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(SunFlareComponentData, element2_size_occluder_curve),
            },
            FieldInfoData {
                name: "Element2SizeScreenPosCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(SunFlareComponentData, element2_size_screen_pos_curve),
            },
            FieldInfoData {
                name: "Element2AlphaOccluderCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(SunFlareComponentData, element2_alpha_occluder_curve),
            },
            FieldInfoData {
                name: "Element2AlphaScreenPosCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(SunFlareComponentData, element2_alpha_screen_pos_curve),
            },
            FieldInfoData {
                name: "Element2RotationLocal",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SunFlareComponentData, element2_rotation_local),
            },
            FieldInfoData {
                name: "Element2RotationAlignedToRay",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SunFlareComponentData, element2_rotation_aligned_to_ray),
            },
            FieldInfoData {
                name: "Element2RotationDistCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(SunFlareComponentData, element2_rotation_dist_curve),
            },
            FieldInfoData {
                name: "Element2RotationDistMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SunFlareComponentData, element2_rotation_dist_multiplier),
            },
            FieldInfoData {
                name: "Element3Enable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SunFlareComponentData, element3_enable),
            },
            FieldInfoData {
                name: "Element3Shader",
                flags: MemberInfoFlags::new(0),
                field_type: "SurfaceShaderInstanceDataStruct",
                rust_offset: offset_of!(SunFlareComponentData, element3_shader),
            },
            FieldInfoData {
                name: "Element3RayDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SunFlareComponentData, element3_ray_distance),
            },
            FieldInfoData {
                name: "Element3Size",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(SunFlareComponentData, element3_size),
            },
            FieldInfoData {
                name: "Element3SizeOccluderCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(SunFlareComponentData, element3_size_occluder_curve),
            },
            FieldInfoData {
                name: "Element3SizeScreenPosCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(SunFlareComponentData, element3_size_screen_pos_curve),
            },
            FieldInfoData {
                name: "Element3AlphaOccluderCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(SunFlareComponentData, element3_alpha_occluder_curve),
            },
            FieldInfoData {
                name: "Element3AlphaScreenPosCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(SunFlareComponentData, element3_alpha_screen_pos_curve),
            },
            FieldInfoData {
                name: "Element3RotationLocal",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SunFlareComponentData, element3_rotation_local),
            },
            FieldInfoData {
                name: "Element3RotationAlignedToRay",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SunFlareComponentData, element3_rotation_aligned_to_ray),
            },
            FieldInfoData {
                name: "Element3RotationDistCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(SunFlareComponentData, element3_rotation_dist_curve),
            },
            FieldInfoData {
                name: "Element3RotationDistMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SunFlareComponentData, element3_rotation_dist_multiplier),
            },
            FieldInfoData {
                name: "Element4Enable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SunFlareComponentData, element4_enable),
            },
            FieldInfoData {
                name: "Element4Shader",
                flags: MemberInfoFlags::new(0),
                field_type: "SurfaceShaderInstanceDataStruct",
                rust_offset: offset_of!(SunFlareComponentData, element4_shader),
            },
            FieldInfoData {
                name: "Element4RayDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SunFlareComponentData, element4_ray_distance),
            },
            FieldInfoData {
                name: "Element4Size",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(SunFlareComponentData, element4_size),
            },
            FieldInfoData {
                name: "Element4SizeOccluderCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(SunFlareComponentData, element4_size_occluder_curve),
            },
            FieldInfoData {
                name: "Element4SizeScreenPosCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(SunFlareComponentData, element4_size_screen_pos_curve),
            },
            FieldInfoData {
                name: "Element4AlphaOccluderCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(SunFlareComponentData, element4_alpha_occluder_curve),
            },
            FieldInfoData {
                name: "Element4AlphaScreenPosCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(SunFlareComponentData, element4_alpha_screen_pos_curve),
            },
            FieldInfoData {
                name: "Element4RotationLocal",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SunFlareComponentData, element4_rotation_local),
            },
            FieldInfoData {
                name: "Element4RotationAlignedToRay",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SunFlareComponentData, element4_rotation_aligned_to_ray),
            },
            FieldInfoData {
                name: "Element4RotationDistCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(SunFlareComponentData, element4_rotation_dist_curve),
            },
            FieldInfoData {
                name: "Element4RotationDistMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SunFlareComponentData, element4_rotation_dist_multiplier),
            },
            FieldInfoData {
                name: "Element5Enable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SunFlareComponentData, element5_enable),
            },
            FieldInfoData {
                name: "Element5Shader",
                flags: MemberInfoFlags::new(0),
                field_type: "SurfaceShaderInstanceDataStruct",
                rust_offset: offset_of!(SunFlareComponentData, element5_shader),
            },
            FieldInfoData {
                name: "Element5RayDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SunFlareComponentData, element5_ray_distance),
            },
            FieldInfoData {
                name: "Element5Size",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(SunFlareComponentData, element5_size),
            },
            FieldInfoData {
                name: "Element5SizeOccluderCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(SunFlareComponentData, element5_size_occluder_curve),
            },
            FieldInfoData {
                name: "Element5SizeScreenPosCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(SunFlareComponentData, element5_size_screen_pos_curve),
            },
            FieldInfoData {
                name: "Element5AlphaOccluderCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(SunFlareComponentData, element5_alpha_occluder_curve),
            },
            FieldInfoData {
                name: "Element5AlphaScreenPosCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(SunFlareComponentData, element5_alpha_screen_pos_curve),
            },
            FieldInfoData {
                name: "Element5RotationLocal",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SunFlareComponentData, element5_rotation_local),
            },
            FieldInfoData {
                name: "Element5RotationAlignedToRay",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SunFlareComponentData, element5_rotation_aligned_to_ray),
            },
            FieldInfoData {
                name: "Element5RotationDistCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(SunFlareComponentData, element5_rotation_dist_curve),
            },
            FieldInfoData {
                name: "Element5RotationDistMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SunFlareComponentData, element5_rotation_dist_multiplier),
            },
            FieldInfoData {
                name: "FieldFlagOverride0",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(SunFlareComponentData, field_flag_override0),
            },
            FieldInfoData {
                name: "FieldFlagOverride1",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(SunFlareComponentData, field_flag_override1),
            },
            FieldInfoData {
                name: "FieldFlagOverride2",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(SunFlareComponentData, field_flag_override2),
            },
        ],
    }),
    array_type: Some(SUNFLARECOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SunFlareComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        SUNFLARECOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SUNFLARECOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SunFlareComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("SunFlareComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CloudComponentData {
    pub _glacier_base: VisualEnvironmentComponentData,
    pub enable: bool,
    pub base_to_top_multiplier: f32,
    pub edge_detail_multiplier: f32,
    pub cloud_density_multiplier: f32,
    pub absorption: super::core::Vec3,
    pub scattering: super::core::Vec3,
    pub phase_g0: f32,
    pub phase_g1: f32,
    pub phase_blend: f32,
    pub ambient_multiplicator: f32,
    pub ambient_desaturate: f32,
    pub aerial_perspective_scale: f32,
    pub enable_shadow: bool,
    pub scattering_order: i32,
    pub scattering_factor: f32,
    pub extinction_factor: f32,
    pub phase_factor: f32,
    pub shape_texture: Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>,
    pub shape_texture_scale: f32,
    pub shape_texture_contrast: f32,
    pub detail_texture: Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>,
    pub detail_texture_scale: f32,
    pub weather_texture: Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>,
    pub weather_texture_scale: f32,
    pub cloud_type_density_gradient_texture: Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>,
    pub planet_radius: f32,
    pub cut_off_distance: f32,
    pub cloud_layer_start_height: f32,
    pub cloud_layer_thickness: f32,
    pub wind_scale: f32,
    pub offset: super::core::Vec2,
    pub field_flag_override0: u32,
}

pub trait CloudComponentDataTrait: VisualEnvironmentComponentDataTrait {
    fn enable(&self) -> &bool;
    fn enable_mut(&mut self) -> &mut bool;
    fn base_to_top_multiplier(&self) -> &f32;
    fn base_to_top_multiplier_mut(&mut self) -> &mut f32;
    fn edge_detail_multiplier(&self) -> &f32;
    fn edge_detail_multiplier_mut(&mut self) -> &mut f32;
    fn cloud_density_multiplier(&self) -> &f32;
    fn cloud_density_multiplier_mut(&mut self) -> &mut f32;
    fn absorption(&self) -> &super::core::Vec3;
    fn absorption_mut(&mut self) -> &mut super::core::Vec3;
    fn scattering(&self) -> &super::core::Vec3;
    fn scattering_mut(&mut self) -> &mut super::core::Vec3;
    fn phase_g0(&self) -> &f32;
    fn phase_g0_mut(&mut self) -> &mut f32;
    fn phase_g1(&self) -> &f32;
    fn phase_g1_mut(&mut self) -> &mut f32;
    fn phase_blend(&self) -> &f32;
    fn phase_blend_mut(&mut self) -> &mut f32;
    fn ambient_multiplicator(&self) -> &f32;
    fn ambient_multiplicator_mut(&mut self) -> &mut f32;
    fn ambient_desaturate(&self) -> &f32;
    fn ambient_desaturate_mut(&mut self) -> &mut f32;
    fn aerial_perspective_scale(&self) -> &f32;
    fn aerial_perspective_scale_mut(&mut self) -> &mut f32;
    fn enable_shadow(&self) -> &bool;
    fn enable_shadow_mut(&mut self) -> &mut bool;
    fn scattering_order(&self) -> &i32;
    fn scattering_order_mut(&mut self) -> &mut i32;
    fn scattering_factor(&self) -> &f32;
    fn scattering_factor_mut(&mut self) -> &mut f32;
    fn extinction_factor(&self) -> &f32;
    fn extinction_factor_mut(&mut self) -> &mut f32;
    fn phase_factor(&self) -> &f32;
    fn phase_factor_mut(&mut self) -> &mut f32;
    fn shape_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn shape_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn shape_texture_scale(&self) -> &f32;
    fn shape_texture_scale_mut(&mut self) -> &mut f32;
    fn shape_texture_contrast(&self) -> &f32;
    fn shape_texture_contrast_mut(&mut self) -> &mut f32;
    fn detail_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn detail_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn detail_texture_scale(&self) -> &f32;
    fn detail_texture_scale_mut(&mut self) -> &mut f32;
    fn weather_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn weather_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn weather_texture_scale(&self) -> &f32;
    fn weather_texture_scale_mut(&mut self) -> &mut f32;
    fn cloud_type_density_gradient_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn cloud_type_density_gradient_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn planet_radius(&self) -> &f32;
    fn planet_radius_mut(&mut self) -> &mut f32;
    fn cut_off_distance(&self) -> &f32;
    fn cut_off_distance_mut(&mut self) -> &mut f32;
    fn cloud_layer_start_height(&self) -> &f32;
    fn cloud_layer_start_height_mut(&mut self) -> &mut f32;
    fn cloud_layer_thickness(&self) -> &f32;
    fn cloud_layer_thickness_mut(&mut self) -> &mut f32;
    fn wind_scale(&self) -> &f32;
    fn wind_scale_mut(&mut self) -> &mut f32;
    fn offset(&self) -> &super::core::Vec2;
    fn offset_mut(&mut self) -> &mut super::core::Vec2;
    fn field_flag_override0(&self) -> &u32;
    fn field_flag_override0_mut(&mut self) -> &mut u32;
}

impl CloudComponentDataTrait for CloudComponentData {
    fn enable(&self) -> &bool {
        &self.enable
    }
    fn enable_mut(&mut self) -> &mut bool {
        &mut self.enable
    }
    fn base_to_top_multiplier(&self) -> &f32 {
        &self.base_to_top_multiplier
    }
    fn base_to_top_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.base_to_top_multiplier
    }
    fn edge_detail_multiplier(&self) -> &f32 {
        &self.edge_detail_multiplier
    }
    fn edge_detail_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.edge_detail_multiplier
    }
    fn cloud_density_multiplier(&self) -> &f32 {
        &self.cloud_density_multiplier
    }
    fn cloud_density_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.cloud_density_multiplier
    }
    fn absorption(&self) -> &super::core::Vec3 {
        &self.absorption
    }
    fn absorption_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.absorption
    }
    fn scattering(&self) -> &super::core::Vec3 {
        &self.scattering
    }
    fn scattering_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.scattering
    }
    fn phase_g0(&self) -> &f32 {
        &self.phase_g0
    }
    fn phase_g0_mut(&mut self) -> &mut f32 {
        &mut self.phase_g0
    }
    fn phase_g1(&self) -> &f32 {
        &self.phase_g1
    }
    fn phase_g1_mut(&mut self) -> &mut f32 {
        &mut self.phase_g1
    }
    fn phase_blend(&self) -> &f32 {
        &self.phase_blend
    }
    fn phase_blend_mut(&mut self) -> &mut f32 {
        &mut self.phase_blend
    }
    fn ambient_multiplicator(&self) -> &f32 {
        &self.ambient_multiplicator
    }
    fn ambient_multiplicator_mut(&mut self) -> &mut f32 {
        &mut self.ambient_multiplicator
    }
    fn ambient_desaturate(&self) -> &f32 {
        &self.ambient_desaturate
    }
    fn ambient_desaturate_mut(&mut self) -> &mut f32 {
        &mut self.ambient_desaturate
    }
    fn aerial_perspective_scale(&self) -> &f32 {
        &self.aerial_perspective_scale
    }
    fn aerial_perspective_scale_mut(&mut self) -> &mut f32 {
        &mut self.aerial_perspective_scale
    }
    fn enable_shadow(&self) -> &bool {
        &self.enable_shadow
    }
    fn enable_shadow_mut(&mut self) -> &mut bool {
        &mut self.enable_shadow
    }
    fn scattering_order(&self) -> &i32 {
        &self.scattering_order
    }
    fn scattering_order_mut(&mut self) -> &mut i32 {
        &mut self.scattering_order
    }
    fn scattering_factor(&self) -> &f32 {
        &self.scattering_factor
    }
    fn scattering_factor_mut(&mut self) -> &mut f32 {
        &mut self.scattering_factor
    }
    fn extinction_factor(&self) -> &f32 {
        &self.extinction_factor
    }
    fn extinction_factor_mut(&mut self) -> &mut f32 {
        &mut self.extinction_factor
    }
    fn phase_factor(&self) -> &f32 {
        &self.phase_factor
    }
    fn phase_factor_mut(&mut self) -> &mut f32 {
        &mut self.phase_factor
    }
    fn shape_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &self.shape_texture
    }
    fn shape_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &mut self.shape_texture
    }
    fn shape_texture_scale(&self) -> &f32 {
        &self.shape_texture_scale
    }
    fn shape_texture_scale_mut(&mut self) -> &mut f32 {
        &mut self.shape_texture_scale
    }
    fn shape_texture_contrast(&self) -> &f32 {
        &self.shape_texture_contrast
    }
    fn shape_texture_contrast_mut(&mut self) -> &mut f32 {
        &mut self.shape_texture_contrast
    }
    fn detail_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &self.detail_texture
    }
    fn detail_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &mut self.detail_texture
    }
    fn detail_texture_scale(&self) -> &f32 {
        &self.detail_texture_scale
    }
    fn detail_texture_scale_mut(&mut self) -> &mut f32 {
        &mut self.detail_texture_scale
    }
    fn weather_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &self.weather_texture
    }
    fn weather_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &mut self.weather_texture
    }
    fn weather_texture_scale(&self) -> &f32 {
        &self.weather_texture_scale
    }
    fn weather_texture_scale_mut(&mut self) -> &mut f32 {
        &mut self.weather_texture_scale
    }
    fn cloud_type_density_gradient_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &self.cloud_type_density_gradient_texture
    }
    fn cloud_type_density_gradient_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &mut self.cloud_type_density_gradient_texture
    }
    fn planet_radius(&self) -> &f32 {
        &self.planet_radius
    }
    fn planet_radius_mut(&mut self) -> &mut f32 {
        &mut self.planet_radius
    }
    fn cut_off_distance(&self) -> &f32 {
        &self.cut_off_distance
    }
    fn cut_off_distance_mut(&mut self) -> &mut f32 {
        &mut self.cut_off_distance
    }
    fn cloud_layer_start_height(&self) -> &f32 {
        &self.cloud_layer_start_height
    }
    fn cloud_layer_start_height_mut(&mut self) -> &mut f32 {
        &mut self.cloud_layer_start_height
    }
    fn cloud_layer_thickness(&self) -> &f32 {
        &self.cloud_layer_thickness
    }
    fn cloud_layer_thickness_mut(&mut self) -> &mut f32 {
        &mut self.cloud_layer_thickness
    }
    fn wind_scale(&self) -> &f32 {
        &self.wind_scale
    }
    fn wind_scale_mut(&mut self) -> &mut f32 {
        &mut self.wind_scale
    }
    fn offset(&self) -> &super::core::Vec2 {
        &self.offset
    }
    fn offset_mut(&mut self) -> &mut super::core::Vec2 {
        &mut self.offset
    }
    fn field_flag_override0(&self) -> &u32 {
        &self.field_flag_override0
    }
    fn field_flag_override0_mut(&mut self) -> &mut u32 {
        &mut self.field_flag_override0
    }
}

impl VisualEnvironmentComponentDataTrait for CloudComponentData {
    fn property_overrides(&self) -> &Vec<String> {
        self._glacier_base.property_overrides()
    }
    fn property_overrides_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.property_overrides_mut()
    }
}

impl super::entity::ComponentDataTrait for CloudComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for CloudComponentData {
}

impl super::core::DataBusPeerTrait for CloudComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CloudComponentData {
}

impl super::core::DataContainerTrait for CloudComponentData {
}

pub static CLOUDCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CloudComponentData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VISUALENVIRONMENTCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CloudComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CloudComponentData, enable),
            },
            FieldInfoData {
                name: "BaseToTopMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CloudComponentData, base_to_top_multiplier),
            },
            FieldInfoData {
                name: "EdgeDetailMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CloudComponentData, edge_detail_multiplier),
            },
            FieldInfoData {
                name: "CloudDensityMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CloudComponentData, cloud_density_multiplier),
            },
            FieldInfoData {
                name: "Absorption",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(CloudComponentData, absorption),
            },
            FieldInfoData {
                name: "Scattering",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(CloudComponentData, scattering),
            },
            FieldInfoData {
                name: "PhaseG0",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CloudComponentData, phase_g0),
            },
            FieldInfoData {
                name: "PhaseG1",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CloudComponentData, phase_g1),
            },
            FieldInfoData {
                name: "PhaseBlend",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CloudComponentData, phase_blend),
            },
            FieldInfoData {
                name: "AmbientMultiplicator",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CloudComponentData, ambient_multiplicator),
            },
            FieldInfoData {
                name: "AmbientDesaturate",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CloudComponentData, ambient_desaturate),
            },
            FieldInfoData {
                name: "AerialPerspectiveScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CloudComponentData, aerial_perspective_scale),
            },
            FieldInfoData {
                name: "EnableShadow",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CloudComponentData, enable_shadow),
            },
            FieldInfoData {
                name: "ScatteringOrder",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CloudComponentData, scattering_order),
            },
            FieldInfoData {
                name: "ScatteringFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CloudComponentData, scattering_factor),
            },
            FieldInfoData {
                name: "ExtinctionFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CloudComponentData, extinction_factor),
            },
            FieldInfoData {
                name: "PhaseFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CloudComponentData, phase_factor),
            },
            FieldInfoData {
                name: "ShapeTexture",
                flags: MemberInfoFlags::new(0),
                field_type: "TextureBaseAsset",
                rust_offset: offset_of!(CloudComponentData, shape_texture),
            },
            FieldInfoData {
                name: "ShapeTextureScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CloudComponentData, shape_texture_scale),
            },
            FieldInfoData {
                name: "ShapeTextureContrast",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CloudComponentData, shape_texture_contrast),
            },
            FieldInfoData {
                name: "DetailTexture",
                flags: MemberInfoFlags::new(0),
                field_type: "TextureBaseAsset",
                rust_offset: offset_of!(CloudComponentData, detail_texture),
            },
            FieldInfoData {
                name: "DetailTextureScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CloudComponentData, detail_texture_scale),
            },
            FieldInfoData {
                name: "WeatherTexture",
                flags: MemberInfoFlags::new(0),
                field_type: "TextureBaseAsset",
                rust_offset: offset_of!(CloudComponentData, weather_texture),
            },
            FieldInfoData {
                name: "WeatherTextureScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CloudComponentData, weather_texture_scale),
            },
            FieldInfoData {
                name: "CloudTypeDensityGradientTexture",
                flags: MemberInfoFlags::new(0),
                field_type: "TextureBaseAsset",
                rust_offset: offset_of!(CloudComponentData, cloud_type_density_gradient_texture),
            },
            FieldInfoData {
                name: "PlanetRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CloudComponentData, planet_radius),
            },
            FieldInfoData {
                name: "CutOffDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CloudComponentData, cut_off_distance),
            },
            FieldInfoData {
                name: "CloudLayerStartHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CloudComponentData, cloud_layer_start_height),
            },
            FieldInfoData {
                name: "CloudLayerThickness",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CloudComponentData, cloud_layer_thickness),
            },
            FieldInfoData {
                name: "WindScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CloudComponentData, wind_scale),
            },
            FieldInfoData {
                name: "Offset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(CloudComponentData, offset),
            },
            FieldInfoData {
                name: "FieldFlagOverride0",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(CloudComponentData, field_flag_override0),
            },
        ],
    }),
    array_type: Some(CLOUDCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CloudComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        CLOUDCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CLOUDCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CloudComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("CloudComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WindComponentData {
    pub _glacier_base: VisualEnvironmentComponentData,
    pub wind_direction: f32,
    pub wind_strength: f32,
    pub wind_variation_multiplier: f32,
    pub wind_variation_rate_multiplier: f32,
    pub wind_micro_variation_multiplier: f32,
    pub turbulence_multiplier: f32,
    pub turbulence_scale: f32,
    pub field_flag_override0: u8,
}

pub trait WindComponentDataTrait: VisualEnvironmentComponentDataTrait {
    fn wind_direction(&self) -> &f32;
    fn wind_direction_mut(&mut self) -> &mut f32;
    fn wind_strength(&self) -> &f32;
    fn wind_strength_mut(&mut self) -> &mut f32;
    fn wind_variation_multiplier(&self) -> &f32;
    fn wind_variation_multiplier_mut(&mut self) -> &mut f32;
    fn wind_variation_rate_multiplier(&self) -> &f32;
    fn wind_variation_rate_multiplier_mut(&mut self) -> &mut f32;
    fn wind_micro_variation_multiplier(&self) -> &f32;
    fn wind_micro_variation_multiplier_mut(&mut self) -> &mut f32;
    fn turbulence_multiplier(&self) -> &f32;
    fn turbulence_multiplier_mut(&mut self) -> &mut f32;
    fn turbulence_scale(&self) -> &f32;
    fn turbulence_scale_mut(&mut self) -> &mut f32;
    fn field_flag_override0(&self) -> &u8;
    fn field_flag_override0_mut(&mut self) -> &mut u8;
}

impl WindComponentDataTrait for WindComponentData {
    fn wind_direction(&self) -> &f32 {
        &self.wind_direction
    }
    fn wind_direction_mut(&mut self) -> &mut f32 {
        &mut self.wind_direction
    }
    fn wind_strength(&self) -> &f32 {
        &self.wind_strength
    }
    fn wind_strength_mut(&mut self) -> &mut f32 {
        &mut self.wind_strength
    }
    fn wind_variation_multiplier(&self) -> &f32 {
        &self.wind_variation_multiplier
    }
    fn wind_variation_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.wind_variation_multiplier
    }
    fn wind_variation_rate_multiplier(&self) -> &f32 {
        &self.wind_variation_rate_multiplier
    }
    fn wind_variation_rate_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.wind_variation_rate_multiplier
    }
    fn wind_micro_variation_multiplier(&self) -> &f32 {
        &self.wind_micro_variation_multiplier
    }
    fn wind_micro_variation_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.wind_micro_variation_multiplier
    }
    fn turbulence_multiplier(&self) -> &f32 {
        &self.turbulence_multiplier
    }
    fn turbulence_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.turbulence_multiplier
    }
    fn turbulence_scale(&self) -> &f32 {
        &self.turbulence_scale
    }
    fn turbulence_scale_mut(&mut self) -> &mut f32 {
        &mut self.turbulence_scale
    }
    fn field_flag_override0(&self) -> &u8 {
        &self.field_flag_override0
    }
    fn field_flag_override0_mut(&mut self) -> &mut u8 {
        &mut self.field_flag_override0
    }
}

impl VisualEnvironmentComponentDataTrait for WindComponentData {
    fn property_overrides(&self) -> &Vec<String> {
        self._glacier_base.property_overrides()
    }
    fn property_overrides_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.property_overrides_mut()
    }
}

impl super::entity::ComponentDataTrait for WindComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for WindComponentData {
}

impl super::core::DataBusPeerTrait for WindComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for WindComponentData {
}

impl super::core::DataContainerTrait for WindComponentData {
}

pub static WINDCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WindComponentData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VISUALENVIRONMENTCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WindComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "WindDirection",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WindComponentData, wind_direction),
            },
            FieldInfoData {
                name: "WindStrength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WindComponentData, wind_strength),
            },
            FieldInfoData {
                name: "WindVariationMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WindComponentData, wind_variation_multiplier),
            },
            FieldInfoData {
                name: "WindVariationRateMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WindComponentData, wind_variation_rate_multiplier),
            },
            FieldInfoData {
                name: "WindMicroVariationMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WindComponentData, wind_micro_variation_multiplier),
            },
            FieldInfoData {
                name: "TurbulenceMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WindComponentData, turbulence_multiplier),
            },
            FieldInfoData {
                name: "TurbulenceScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WindComponentData, turbulence_scale),
            },
            FieldInfoData {
                name: "FieldFlagOverride0",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(WindComponentData, field_flag_override0),
            },
        ],
    }),
    array_type: Some(WINDCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for WindComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        WINDCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WINDCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WindComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("WindComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DynamicEnvmapComponentData {
    pub _glacier_base: VisualEnvironmentComponentData,
    pub enable: bool,
    pub terrain_reflections_enable: bool,
    pub key_color_envmap: super::core::Vec3,
    pub sky_color_envmap: super::core::Vec3,
    pub ground_color_envmap: super::core::Vec3,
    pub field_flag_override0: u8,
}

pub trait DynamicEnvmapComponentDataTrait: VisualEnvironmentComponentDataTrait {
    fn enable(&self) -> &bool;
    fn enable_mut(&mut self) -> &mut bool;
    fn terrain_reflections_enable(&self) -> &bool;
    fn terrain_reflections_enable_mut(&mut self) -> &mut bool;
    fn key_color_envmap(&self) -> &super::core::Vec3;
    fn key_color_envmap_mut(&mut self) -> &mut super::core::Vec3;
    fn sky_color_envmap(&self) -> &super::core::Vec3;
    fn sky_color_envmap_mut(&mut self) -> &mut super::core::Vec3;
    fn ground_color_envmap(&self) -> &super::core::Vec3;
    fn ground_color_envmap_mut(&mut self) -> &mut super::core::Vec3;
    fn field_flag_override0(&self) -> &u8;
    fn field_flag_override0_mut(&mut self) -> &mut u8;
}

impl DynamicEnvmapComponentDataTrait for DynamicEnvmapComponentData {
    fn enable(&self) -> &bool {
        &self.enable
    }
    fn enable_mut(&mut self) -> &mut bool {
        &mut self.enable
    }
    fn terrain_reflections_enable(&self) -> &bool {
        &self.terrain_reflections_enable
    }
    fn terrain_reflections_enable_mut(&mut self) -> &mut bool {
        &mut self.terrain_reflections_enable
    }
    fn key_color_envmap(&self) -> &super::core::Vec3 {
        &self.key_color_envmap
    }
    fn key_color_envmap_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.key_color_envmap
    }
    fn sky_color_envmap(&self) -> &super::core::Vec3 {
        &self.sky_color_envmap
    }
    fn sky_color_envmap_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.sky_color_envmap
    }
    fn ground_color_envmap(&self) -> &super::core::Vec3 {
        &self.ground_color_envmap
    }
    fn ground_color_envmap_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.ground_color_envmap
    }
    fn field_flag_override0(&self) -> &u8 {
        &self.field_flag_override0
    }
    fn field_flag_override0_mut(&mut self) -> &mut u8 {
        &mut self.field_flag_override0
    }
}

impl VisualEnvironmentComponentDataTrait for DynamicEnvmapComponentData {
    fn property_overrides(&self) -> &Vec<String> {
        self._glacier_base.property_overrides()
    }
    fn property_overrides_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.property_overrides_mut()
    }
}

impl super::entity::ComponentDataTrait for DynamicEnvmapComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for DynamicEnvmapComponentData {
}

impl super::core::DataBusPeerTrait for DynamicEnvmapComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for DynamicEnvmapComponentData {
}

impl super::core::DataContainerTrait for DynamicEnvmapComponentData {
}

pub static DYNAMICENVMAPCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicEnvmapComponentData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VISUALENVIRONMENTCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DynamicEnvmapComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DynamicEnvmapComponentData, enable),
            },
            FieldInfoData {
                name: "TerrainReflectionsEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DynamicEnvmapComponentData, terrain_reflections_enable),
            },
            FieldInfoData {
                name: "KeyColorEnvmap",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(DynamicEnvmapComponentData, key_color_envmap),
            },
            FieldInfoData {
                name: "SkyColorEnvmap",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(DynamicEnvmapComponentData, sky_color_envmap),
            },
            FieldInfoData {
                name: "GroundColorEnvmap",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(DynamicEnvmapComponentData, ground_color_envmap),
            },
            FieldInfoData {
                name: "FieldFlagOverride0",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(DynamicEnvmapComponentData, field_flag_override0),
            },
        ],
    }),
    array_type: Some(DYNAMICENVMAPCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for DynamicEnvmapComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        DYNAMICENVMAPCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DYNAMICENVMAPCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicEnvmapComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("DynamicEnvmapComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlanarReflectionComponentData {
    pub _glacier_base: VisualEnvironmentComponentData,
    pub enable: bool,
    pub terrain_reflections_enable: bool,
    pub sky_render_enable: bool,
    pub ground_height: f32,
    pub view_distance: f32,
    pub vertical_blur_filter: super::render_base::BlurFilter,
    pub vertical_deviation: f32,
    pub horizontal_blur_filter: super::render_base::BlurFilter,
    pub horizontal_deviation: f32,
    pub clipping_offset: f32,
    pub overide_outdoor_light_colors: bool,
    pub key_color_reflection: super::core::Vec3,
    pub sky_color_reflection: super::core::Vec3,
    pub ground_color_reflection: super::core::Vec3,
    pub field_flag_override0: u16,
}

pub trait PlanarReflectionComponentDataTrait: VisualEnvironmentComponentDataTrait {
    fn enable(&self) -> &bool;
    fn enable_mut(&mut self) -> &mut bool;
    fn terrain_reflections_enable(&self) -> &bool;
    fn terrain_reflections_enable_mut(&mut self) -> &mut bool;
    fn sky_render_enable(&self) -> &bool;
    fn sky_render_enable_mut(&mut self) -> &mut bool;
    fn ground_height(&self) -> &f32;
    fn ground_height_mut(&mut self) -> &mut f32;
    fn view_distance(&self) -> &f32;
    fn view_distance_mut(&mut self) -> &mut f32;
    fn vertical_blur_filter(&self) -> &super::render_base::BlurFilter;
    fn vertical_blur_filter_mut(&mut self) -> &mut super::render_base::BlurFilter;
    fn vertical_deviation(&self) -> &f32;
    fn vertical_deviation_mut(&mut self) -> &mut f32;
    fn horizontal_blur_filter(&self) -> &super::render_base::BlurFilter;
    fn horizontal_blur_filter_mut(&mut self) -> &mut super::render_base::BlurFilter;
    fn horizontal_deviation(&self) -> &f32;
    fn horizontal_deviation_mut(&mut self) -> &mut f32;
    fn clipping_offset(&self) -> &f32;
    fn clipping_offset_mut(&mut self) -> &mut f32;
    fn overide_outdoor_light_colors(&self) -> &bool;
    fn overide_outdoor_light_colors_mut(&mut self) -> &mut bool;
    fn key_color_reflection(&self) -> &super::core::Vec3;
    fn key_color_reflection_mut(&mut self) -> &mut super::core::Vec3;
    fn sky_color_reflection(&self) -> &super::core::Vec3;
    fn sky_color_reflection_mut(&mut self) -> &mut super::core::Vec3;
    fn ground_color_reflection(&self) -> &super::core::Vec3;
    fn ground_color_reflection_mut(&mut self) -> &mut super::core::Vec3;
    fn field_flag_override0(&self) -> &u16;
    fn field_flag_override0_mut(&mut self) -> &mut u16;
}

impl PlanarReflectionComponentDataTrait for PlanarReflectionComponentData {
    fn enable(&self) -> &bool {
        &self.enable
    }
    fn enable_mut(&mut self) -> &mut bool {
        &mut self.enable
    }
    fn terrain_reflections_enable(&self) -> &bool {
        &self.terrain_reflections_enable
    }
    fn terrain_reflections_enable_mut(&mut self) -> &mut bool {
        &mut self.terrain_reflections_enable
    }
    fn sky_render_enable(&self) -> &bool {
        &self.sky_render_enable
    }
    fn sky_render_enable_mut(&mut self) -> &mut bool {
        &mut self.sky_render_enable
    }
    fn ground_height(&self) -> &f32 {
        &self.ground_height
    }
    fn ground_height_mut(&mut self) -> &mut f32 {
        &mut self.ground_height
    }
    fn view_distance(&self) -> &f32 {
        &self.view_distance
    }
    fn view_distance_mut(&mut self) -> &mut f32 {
        &mut self.view_distance
    }
    fn vertical_blur_filter(&self) -> &super::render_base::BlurFilter {
        &self.vertical_blur_filter
    }
    fn vertical_blur_filter_mut(&mut self) -> &mut super::render_base::BlurFilter {
        &mut self.vertical_blur_filter
    }
    fn vertical_deviation(&self) -> &f32 {
        &self.vertical_deviation
    }
    fn vertical_deviation_mut(&mut self) -> &mut f32 {
        &mut self.vertical_deviation
    }
    fn horizontal_blur_filter(&self) -> &super::render_base::BlurFilter {
        &self.horizontal_blur_filter
    }
    fn horizontal_blur_filter_mut(&mut self) -> &mut super::render_base::BlurFilter {
        &mut self.horizontal_blur_filter
    }
    fn horizontal_deviation(&self) -> &f32 {
        &self.horizontal_deviation
    }
    fn horizontal_deviation_mut(&mut self) -> &mut f32 {
        &mut self.horizontal_deviation
    }
    fn clipping_offset(&self) -> &f32 {
        &self.clipping_offset
    }
    fn clipping_offset_mut(&mut self) -> &mut f32 {
        &mut self.clipping_offset
    }
    fn overide_outdoor_light_colors(&self) -> &bool {
        &self.overide_outdoor_light_colors
    }
    fn overide_outdoor_light_colors_mut(&mut self) -> &mut bool {
        &mut self.overide_outdoor_light_colors
    }
    fn key_color_reflection(&self) -> &super::core::Vec3 {
        &self.key_color_reflection
    }
    fn key_color_reflection_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.key_color_reflection
    }
    fn sky_color_reflection(&self) -> &super::core::Vec3 {
        &self.sky_color_reflection
    }
    fn sky_color_reflection_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.sky_color_reflection
    }
    fn ground_color_reflection(&self) -> &super::core::Vec3 {
        &self.ground_color_reflection
    }
    fn ground_color_reflection_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.ground_color_reflection
    }
    fn field_flag_override0(&self) -> &u16 {
        &self.field_flag_override0
    }
    fn field_flag_override0_mut(&mut self) -> &mut u16 {
        &mut self.field_flag_override0
    }
}

impl VisualEnvironmentComponentDataTrait for PlanarReflectionComponentData {
    fn property_overrides(&self) -> &Vec<String> {
        self._glacier_base.property_overrides()
    }
    fn property_overrides_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.property_overrides_mut()
    }
}

impl super::entity::ComponentDataTrait for PlanarReflectionComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for PlanarReflectionComponentData {
}

impl super::core::DataBusPeerTrait for PlanarReflectionComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PlanarReflectionComponentData {
}

impl super::core::DataContainerTrait for PlanarReflectionComponentData {
}

pub static PLANARREFLECTIONCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlanarReflectionComponentData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VISUALENVIRONMENTCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlanarReflectionComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlanarReflectionComponentData, enable),
            },
            FieldInfoData {
                name: "TerrainReflectionsEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlanarReflectionComponentData, terrain_reflections_enable),
            },
            FieldInfoData {
                name: "SkyRenderEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlanarReflectionComponentData, sky_render_enable),
            },
            FieldInfoData {
                name: "GroundHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PlanarReflectionComponentData, ground_height),
            },
            FieldInfoData {
                name: "ViewDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PlanarReflectionComponentData, view_distance),
            },
            FieldInfoData {
                name: "VerticalBlurFilter",
                flags: MemberInfoFlags::new(0),
                field_type: "BlurFilter",
                rust_offset: offset_of!(PlanarReflectionComponentData, vertical_blur_filter),
            },
            FieldInfoData {
                name: "VerticalDeviation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PlanarReflectionComponentData, vertical_deviation),
            },
            FieldInfoData {
                name: "HorizontalBlurFilter",
                flags: MemberInfoFlags::new(0),
                field_type: "BlurFilter",
                rust_offset: offset_of!(PlanarReflectionComponentData, horizontal_blur_filter),
            },
            FieldInfoData {
                name: "HorizontalDeviation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PlanarReflectionComponentData, horizontal_deviation),
            },
            FieldInfoData {
                name: "ClippingOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PlanarReflectionComponentData, clipping_offset),
            },
            FieldInfoData {
                name: "OverideOutdoorLightColors",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlanarReflectionComponentData, overide_outdoor_light_colors),
            },
            FieldInfoData {
                name: "KeyColorReflection",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(PlanarReflectionComponentData, key_color_reflection),
            },
            FieldInfoData {
                name: "SkyColorReflection",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(PlanarReflectionComponentData, sky_color_reflection),
            },
            FieldInfoData {
                name: "GroundColorReflection",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(PlanarReflectionComponentData, ground_color_reflection),
            },
            FieldInfoData {
                name: "FieldFlagOverride0",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint16",
                rust_offset: offset_of!(PlanarReflectionComponentData, field_flag_override0),
            },
        ],
    }),
    array_type: Some(PLANARREFLECTIONCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PlanarReflectionComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        PLANARREFLECTIONCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PLANARREFLECTIONCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlanarReflectionComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("PlanarReflectionComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SkyComponentData {
    pub _glacier_base: VisualEnvironmentComponentData,
    pub enable: bool,
    pub draw_sky_geo: bool,
    pub sky_type: super::world_base::SkyType,
    pub luminance_scale: f32,
    pub sky_gradient_texture: Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>,
    pub alpha_output: super::world_base::AlphaOutputMode,
    pub use_sky_visibility_as_a_o: bool,
    pub hdri_rotation: f32,
    pub hdri_texture: Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>,
    pub sun_size: f32,
    pub sun_scale: f32,
    pub panoramic_u_v_min_x: f32,
    pub panoramic_u_v_max_x: f32,
    pub panoramic_u_v_min_y: f32,
    pub panoramic_u_v_max_y: f32,
    pub panoramic_tile_factor: f32,
    pub panoramic_rotation: f32,
    pub panoramic_texture: Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>,
    pub panoramic_alpha_texture: Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>,
    pub sky_gradient_follows_panoramic_u_vs: bool,
    pub flow_enable: bool,
    pub flow_period: f32,
    pub flow_distance: f32,
    pub flow_direction: f32,
    pub flow_height_mask_scale: f32,
    pub flow_height_mask_bias: f32,
    pub flow_mask_texture: Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>,
    pub cloud_layer_sun_color: super::core::Vec3,
    pub cloud_layer_mask_texture: Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>,
    pub cloud_layer1_altitude: f32,
    pub cloud_layer1_tile_factor: f32,
    pub cloud_layer1_rotation: f32,
    pub cloud_layer1_speed: f32,
    pub cloud_layer1_sun_light_intensity: f32,
    pub cloud_layer1_sun_light_power: f32,
    pub cloud_layer1_ambient_light_intensity: f32,
    pub cloud_layer1_color: super::core::Vec3,
    pub cloud_layer1_alpha_mul: f32,
    pub cloud_layer1_texture: Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>,
    pub cloud_layer1_absorption: f32,
    pub cloud_layer1_scattering: f32,
    pub cloud_layer1_phase: f32,
    pub cloud_layer1_thickness: f32,
    pub cloud_layer2_altitude: f32,
    pub cloud_layer2_tile_factor: f32,
    pub cloud_layer2_rotation: f32,
    pub cloud_layer2_speed: f32,
    pub cloud_layer2_sun_light_intensity: f32,
    pub cloud_layer2_sun_light_power: f32,
    pub cloud_layer2_ambient_light_intensity: f32,
    pub cloud_layer2_color: super::core::Vec3,
    pub cloud_layer2_alpha_mul: f32,
    pub cloud_layer2_texture: Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>,
    pub cloud_layer2_absorption: f32,
    pub cloud_layer2_scattering: f32,
    pub cloud_layer2_phase: f32,
    pub cloud_layer2_thickness: f32,
    pub static_envmap_texture: Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>,
    pub static_envmap_scale: f32,
    pub sky_envmap8_bit_tex_scale: f32,
    pub custom_envmap_texture: Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>,
    pub custom_envmap_scale: f32,
    pub custom_envmap_ambient: f32,
    pub sky_visibility_exponent: f32,
    pub interior_envmap_texture: Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>,
    pub interior_envmap_exp: super::core::Vec4,
    pub interior_envmap_scale: super::core::Vec4,
    pub interior_envmap_bias: super::core::Vec4,
    pub interior_envmap_sky_visibility_fade_start: f32,
    pub interior_envmap_sky_visibility_fade_length: f32,
    pub earth_radius: f32,
    pub atmosphere_radius: f32,
    pub mie_scattering_coefficient: f32,
    pub mie_g: f32,
    pub mie_extinction_coefficient_relation: f32,
    pub scale_height_mie: f32,
    pub rayleigh_scattering_coefficient: super::core::Vec3,
    pub rayleigh_scattering_coefficient_scale: f32,
    pub rayleigh_extinction_coefficient_relation: f32,
    pub scale_height_rayleigh: f32,
    pub use_ozone: bool,
    pub ozone_percentage: f32,
    pub use_aerial_perspective: bool,
    pub aerial_perspective_scale: f32,
    pub aerial_perspective_intensity: f32,
    pub aerial_perspective_dithering: f32,
    pub light1_color: super::core::Vec3,
    pub light1_intensity: f32,
    pub light1_follow_outdoor_light: bool,
    pub light1_takes_color_from_outdoor_light: bool,
    pub light1_rot_x: f32,
    pub light1_rot_y: f32,
    pub light2_color: super::core::Vec3,
    pub light2_intensity: f32,
    pub use_light_source2: bool,
    pub light2_rot_x: f32,
    pub light2_rot_y: f32,
    pub use_noise: bool,
    pub fog_start_distance: f32,
    pub rayleigh_polarization: super::core::Vec3,
    pub mie_polarization: super::core::Vec3,
    pub outdoor_light_scale: super::core::Vec3,
    pub draw_sun_disc: bool,
    pub forward_scattering_depth_visibility: super::core::Vec4,
    pub forward_scattering_start_depth: f32,
    pub forward_scattering_end_depth: f32,
    pub forward_scattering_takes_color_from_outdoor_light: f32,
    pub forward_scattering_outdoor_light_tint: super::core::Vec3,
    pub height_fog_color_add: super::core::Vec3,
    pub height_fog_color_mult: super::core::Vec3,
    pub min_height_fog_transmittance: f32,
    pub field_flag_override0: u32,
    pub field_flag_override1: u32,
    pub field_flag_override2: u32,
    pub field_flag_override3: u32,
}

pub trait SkyComponentDataTrait: VisualEnvironmentComponentDataTrait {
    fn enable(&self) -> &bool;
    fn enable_mut(&mut self) -> &mut bool;
    fn draw_sky_geo(&self) -> &bool;
    fn draw_sky_geo_mut(&mut self) -> &mut bool;
    fn sky_type(&self) -> &super::world_base::SkyType;
    fn sky_type_mut(&mut self) -> &mut super::world_base::SkyType;
    fn luminance_scale(&self) -> &f32;
    fn luminance_scale_mut(&mut self) -> &mut f32;
    fn sky_gradient_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn sky_gradient_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn alpha_output(&self) -> &super::world_base::AlphaOutputMode;
    fn alpha_output_mut(&mut self) -> &mut super::world_base::AlphaOutputMode;
    fn use_sky_visibility_as_a_o(&self) -> &bool;
    fn use_sky_visibility_as_a_o_mut(&mut self) -> &mut bool;
    fn hdri_rotation(&self) -> &f32;
    fn hdri_rotation_mut(&mut self) -> &mut f32;
    fn hdri_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn hdri_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn sun_size(&self) -> &f32;
    fn sun_size_mut(&mut self) -> &mut f32;
    fn sun_scale(&self) -> &f32;
    fn sun_scale_mut(&mut self) -> &mut f32;
    fn panoramic_u_v_min_x(&self) -> &f32;
    fn panoramic_u_v_min_x_mut(&mut self) -> &mut f32;
    fn panoramic_u_v_max_x(&self) -> &f32;
    fn panoramic_u_v_max_x_mut(&mut self) -> &mut f32;
    fn panoramic_u_v_min_y(&self) -> &f32;
    fn panoramic_u_v_min_y_mut(&mut self) -> &mut f32;
    fn panoramic_u_v_max_y(&self) -> &f32;
    fn panoramic_u_v_max_y_mut(&mut self) -> &mut f32;
    fn panoramic_tile_factor(&self) -> &f32;
    fn panoramic_tile_factor_mut(&mut self) -> &mut f32;
    fn panoramic_rotation(&self) -> &f32;
    fn panoramic_rotation_mut(&mut self) -> &mut f32;
    fn panoramic_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn panoramic_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn panoramic_alpha_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn panoramic_alpha_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn sky_gradient_follows_panoramic_u_vs(&self) -> &bool;
    fn sky_gradient_follows_panoramic_u_vs_mut(&mut self) -> &mut bool;
    fn flow_enable(&self) -> &bool;
    fn flow_enable_mut(&mut self) -> &mut bool;
    fn flow_period(&self) -> &f32;
    fn flow_period_mut(&mut self) -> &mut f32;
    fn flow_distance(&self) -> &f32;
    fn flow_distance_mut(&mut self) -> &mut f32;
    fn flow_direction(&self) -> &f32;
    fn flow_direction_mut(&mut self) -> &mut f32;
    fn flow_height_mask_scale(&self) -> &f32;
    fn flow_height_mask_scale_mut(&mut self) -> &mut f32;
    fn flow_height_mask_bias(&self) -> &f32;
    fn flow_height_mask_bias_mut(&mut self) -> &mut f32;
    fn flow_mask_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn flow_mask_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn cloud_layer_sun_color(&self) -> &super::core::Vec3;
    fn cloud_layer_sun_color_mut(&mut self) -> &mut super::core::Vec3;
    fn cloud_layer_mask_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn cloud_layer_mask_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn cloud_layer1_altitude(&self) -> &f32;
    fn cloud_layer1_altitude_mut(&mut self) -> &mut f32;
    fn cloud_layer1_tile_factor(&self) -> &f32;
    fn cloud_layer1_tile_factor_mut(&mut self) -> &mut f32;
    fn cloud_layer1_rotation(&self) -> &f32;
    fn cloud_layer1_rotation_mut(&mut self) -> &mut f32;
    fn cloud_layer1_speed(&self) -> &f32;
    fn cloud_layer1_speed_mut(&mut self) -> &mut f32;
    fn cloud_layer1_sun_light_intensity(&self) -> &f32;
    fn cloud_layer1_sun_light_intensity_mut(&mut self) -> &mut f32;
    fn cloud_layer1_sun_light_power(&self) -> &f32;
    fn cloud_layer1_sun_light_power_mut(&mut self) -> &mut f32;
    fn cloud_layer1_ambient_light_intensity(&self) -> &f32;
    fn cloud_layer1_ambient_light_intensity_mut(&mut self) -> &mut f32;
    fn cloud_layer1_color(&self) -> &super::core::Vec3;
    fn cloud_layer1_color_mut(&mut self) -> &mut super::core::Vec3;
    fn cloud_layer1_alpha_mul(&self) -> &f32;
    fn cloud_layer1_alpha_mul_mut(&mut self) -> &mut f32;
    fn cloud_layer1_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn cloud_layer1_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn cloud_layer1_absorption(&self) -> &f32;
    fn cloud_layer1_absorption_mut(&mut self) -> &mut f32;
    fn cloud_layer1_scattering(&self) -> &f32;
    fn cloud_layer1_scattering_mut(&mut self) -> &mut f32;
    fn cloud_layer1_phase(&self) -> &f32;
    fn cloud_layer1_phase_mut(&mut self) -> &mut f32;
    fn cloud_layer1_thickness(&self) -> &f32;
    fn cloud_layer1_thickness_mut(&mut self) -> &mut f32;
    fn cloud_layer2_altitude(&self) -> &f32;
    fn cloud_layer2_altitude_mut(&mut self) -> &mut f32;
    fn cloud_layer2_tile_factor(&self) -> &f32;
    fn cloud_layer2_tile_factor_mut(&mut self) -> &mut f32;
    fn cloud_layer2_rotation(&self) -> &f32;
    fn cloud_layer2_rotation_mut(&mut self) -> &mut f32;
    fn cloud_layer2_speed(&self) -> &f32;
    fn cloud_layer2_speed_mut(&mut self) -> &mut f32;
    fn cloud_layer2_sun_light_intensity(&self) -> &f32;
    fn cloud_layer2_sun_light_intensity_mut(&mut self) -> &mut f32;
    fn cloud_layer2_sun_light_power(&self) -> &f32;
    fn cloud_layer2_sun_light_power_mut(&mut self) -> &mut f32;
    fn cloud_layer2_ambient_light_intensity(&self) -> &f32;
    fn cloud_layer2_ambient_light_intensity_mut(&mut self) -> &mut f32;
    fn cloud_layer2_color(&self) -> &super::core::Vec3;
    fn cloud_layer2_color_mut(&mut self) -> &mut super::core::Vec3;
    fn cloud_layer2_alpha_mul(&self) -> &f32;
    fn cloud_layer2_alpha_mul_mut(&mut self) -> &mut f32;
    fn cloud_layer2_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn cloud_layer2_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn cloud_layer2_absorption(&self) -> &f32;
    fn cloud_layer2_absorption_mut(&mut self) -> &mut f32;
    fn cloud_layer2_scattering(&self) -> &f32;
    fn cloud_layer2_scattering_mut(&mut self) -> &mut f32;
    fn cloud_layer2_phase(&self) -> &f32;
    fn cloud_layer2_phase_mut(&mut self) -> &mut f32;
    fn cloud_layer2_thickness(&self) -> &f32;
    fn cloud_layer2_thickness_mut(&mut self) -> &mut f32;
    fn static_envmap_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn static_envmap_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn static_envmap_scale(&self) -> &f32;
    fn static_envmap_scale_mut(&mut self) -> &mut f32;
    fn sky_envmap8_bit_tex_scale(&self) -> &f32;
    fn sky_envmap8_bit_tex_scale_mut(&mut self) -> &mut f32;
    fn custom_envmap_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn custom_envmap_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn custom_envmap_scale(&self) -> &f32;
    fn custom_envmap_scale_mut(&mut self) -> &mut f32;
    fn custom_envmap_ambient(&self) -> &f32;
    fn custom_envmap_ambient_mut(&mut self) -> &mut f32;
    fn sky_visibility_exponent(&self) -> &f32;
    fn sky_visibility_exponent_mut(&mut self) -> &mut f32;
    fn interior_envmap_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn interior_envmap_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn interior_envmap_exp(&self) -> &super::core::Vec4;
    fn interior_envmap_exp_mut(&mut self) -> &mut super::core::Vec4;
    fn interior_envmap_scale(&self) -> &super::core::Vec4;
    fn interior_envmap_scale_mut(&mut self) -> &mut super::core::Vec4;
    fn interior_envmap_bias(&self) -> &super::core::Vec4;
    fn interior_envmap_bias_mut(&mut self) -> &mut super::core::Vec4;
    fn interior_envmap_sky_visibility_fade_start(&self) -> &f32;
    fn interior_envmap_sky_visibility_fade_start_mut(&mut self) -> &mut f32;
    fn interior_envmap_sky_visibility_fade_length(&self) -> &f32;
    fn interior_envmap_sky_visibility_fade_length_mut(&mut self) -> &mut f32;
    fn earth_radius(&self) -> &f32;
    fn earth_radius_mut(&mut self) -> &mut f32;
    fn atmosphere_radius(&self) -> &f32;
    fn atmosphere_radius_mut(&mut self) -> &mut f32;
    fn mie_scattering_coefficient(&self) -> &f32;
    fn mie_scattering_coefficient_mut(&mut self) -> &mut f32;
    fn mie_g(&self) -> &f32;
    fn mie_g_mut(&mut self) -> &mut f32;
    fn mie_extinction_coefficient_relation(&self) -> &f32;
    fn mie_extinction_coefficient_relation_mut(&mut self) -> &mut f32;
    fn scale_height_mie(&self) -> &f32;
    fn scale_height_mie_mut(&mut self) -> &mut f32;
    fn rayleigh_scattering_coefficient(&self) -> &super::core::Vec3;
    fn rayleigh_scattering_coefficient_mut(&mut self) -> &mut super::core::Vec3;
    fn rayleigh_scattering_coefficient_scale(&self) -> &f32;
    fn rayleigh_scattering_coefficient_scale_mut(&mut self) -> &mut f32;
    fn rayleigh_extinction_coefficient_relation(&self) -> &f32;
    fn rayleigh_extinction_coefficient_relation_mut(&mut self) -> &mut f32;
    fn scale_height_rayleigh(&self) -> &f32;
    fn scale_height_rayleigh_mut(&mut self) -> &mut f32;
    fn use_ozone(&self) -> &bool;
    fn use_ozone_mut(&mut self) -> &mut bool;
    fn ozone_percentage(&self) -> &f32;
    fn ozone_percentage_mut(&mut self) -> &mut f32;
    fn use_aerial_perspective(&self) -> &bool;
    fn use_aerial_perspective_mut(&mut self) -> &mut bool;
    fn aerial_perspective_scale(&self) -> &f32;
    fn aerial_perspective_scale_mut(&mut self) -> &mut f32;
    fn aerial_perspective_intensity(&self) -> &f32;
    fn aerial_perspective_intensity_mut(&mut self) -> &mut f32;
    fn aerial_perspective_dithering(&self) -> &f32;
    fn aerial_perspective_dithering_mut(&mut self) -> &mut f32;
    fn light1_color(&self) -> &super::core::Vec3;
    fn light1_color_mut(&mut self) -> &mut super::core::Vec3;
    fn light1_intensity(&self) -> &f32;
    fn light1_intensity_mut(&mut self) -> &mut f32;
    fn light1_follow_outdoor_light(&self) -> &bool;
    fn light1_follow_outdoor_light_mut(&mut self) -> &mut bool;
    fn light1_takes_color_from_outdoor_light(&self) -> &bool;
    fn light1_takes_color_from_outdoor_light_mut(&mut self) -> &mut bool;
    fn light1_rot_x(&self) -> &f32;
    fn light1_rot_x_mut(&mut self) -> &mut f32;
    fn light1_rot_y(&self) -> &f32;
    fn light1_rot_y_mut(&mut self) -> &mut f32;
    fn light2_color(&self) -> &super::core::Vec3;
    fn light2_color_mut(&mut self) -> &mut super::core::Vec3;
    fn light2_intensity(&self) -> &f32;
    fn light2_intensity_mut(&mut self) -> &mut f32;
    fn use_light_source2(&self) -> &bool;
    fn use_light_source2_mut(&mut self) -> &mut bool;
    fn light2_rot_x(&self) -> &f32;
    fn light2_rot_x_mut(&mut self) -> &mut f32;
    fn light2_rot_y(&self) -> &f32;
    fn light2_rot_y_mut(&mut self) -> &mut f32;
    fn use_noise(&self) -> &bool;
    fn use_noise_mut(&mut self) -> &mut bool;
    fn fog_start_distance(&self) -> &f32;
    fn fog_start_distance_mut(&mut self) -> &mut f32;
    fn rayleigh_polarization(&self) -> &super::core::Vec3;
    fn rayleigh_polarization_mut(&mut self) -> &mut super::core::Vec3;
    fn mie_polarization(&self) -> &super::core::Vec3;
    fn mie_polarization_mut(&mut self) -> &mut super::core::Vec3;
    fn outdoor_light_scale(&self) -> &super::core::Vec3;
    fn outdoor_light_scale_mut(&mut self) -> &mut super::core::Vec3;
    fn draw_sun_disc(&self) -> &bool;
    fn draw_sun_disc_mut(&mut self) -> &mut bool;
    fn forward_scattering_depth_visibility(&self) -> &super::core::Vec4;
    fn forward_scattering_depth_visibility_mut(&mut self) -> &mut super::core::Vec4;
    fn forward_scattering_start_depth(&self) -> &f32;
    fn forward_scattering_start_depth_mut(&mut self) -> &mut f32;
    fn forward_scattering_end_depth(&self) -> &f32;
    fn forward_scattering_end_depth_mut(&mut self) -> &mut f32;
    fn forward_scattering_takes_color_from_outdoor_light(&self) -> &f32;
    fn forward_scattering_takes_color_from_outdoor_light_mut(&mut self) -> &mut f32;
    fn forward_scattering_outdoor_light_tint(&self) -> &super::core::Vec3;
    fn forward_scattering_outdoor_light_tint_mut(&mut self) -> &mut super::core::Vec3;
    fn height_fog_color_add(&self) -> &super::core::Vec3;
    fn height_fog_color_add_mut(&mut self) -> &mut super::core::Vec3;
    fn height_fog_color_mult(&self) -> &super::core::Vec3;
    fn height_fog_color_mult_mut(&mut self) -> &mut super::core::Vec3;
    fn min_height_fog_transmittance(&self) -> &f32;
    fn min_height_fog_transmittance_mut(&mut self) -> &mut f32;
    fn field_flag_override0(&self) -> &u32;
    fn field_flag_override0_mut(&mut self) -> &mut u32;
    fn field_flag_override1(&self) -> &u32;
    fn field_flag_override1_mut(&mut self) -> &mut u32;
    fn field_flag_override2(&self) -> &u32;
    fn field_flag_override2_mut(&mut self) -> &mut u32;
    fn field_flag_override3(&self) -> &u32;
    fn field_flag_override3_mut(&mut self) -> &mut u32;
}

impl SkyComponentDataTrait for SkyComponentData {
    fn enable(&self) -> &bool {
        &self.enable
    }
    fn enable_mut(&mut self) -> &mut bool {
        &mut self.enable
    }
    fn draw_sky_geo(&self) -> &bool {
        &self.draw_sky_geo
    }
    fn draw_sky_geo_mut(&mut self) -> &mut bool {
        &mut self.draw_sky_geo
    }
    fn sky_type(&self) -> &super::world_base::SkyType {
        &self.sky_type
    }
    fn sky_type_mut(&mut self) -> &mut super::world_base::SkyType {
        &mut self.sky_type
    }
    fn luminance_scale(&self) -> &f32 {
        &self.luminance_scale
    }
    fn luminance_scale_mut(&mut self) -> &mut f32 {
        &mut self.luminance_scale
    }
    fn sky_gradient_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &self.sky_gradient_texture
    }
    fn sky_gradient_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &mut self.sky_gradient_texture
    }
    fn alpha_output(&self) -> &super::world_base::AlphaOutputMode {
        &self.alpha_output
    }
    fn alpha_output_mut(&mut self) -> &mut super::world_base::AlphaOutputMode {
        &mut self.alpha_output
    }
    fn use_sky_visibility_as_a_o(&self) -> &bool {
        &self.use_sky_visibility_as_a_o
    }
    fn use_sky_visibility_as_a_o_mut(&mut self) -> &mut bool {
        &mut self.use_sky_visibility_as_a_o
    }
    fn hdri_rotation(&self) -> &f32 {
        &self.hdri_rotation
    }
    fn hdri_rotation_mut(&mut self) -> &mut f32 {
        &mut self.hdri_rotation
    }
    fn hdri_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &self.hdri_texture
    }
    fn hdri_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &mut self.hdri_texture
    }
    fn sun_size(&self) -> &f32 {
        &self.sun_size
    }
    fn sun_size_mut(&mut self) -> &mut f32 {
        &mut self.sun_size
    }
    fn sun_scale(&self) -> &f32 {
        &self.sun_scale
    }
    fn sun_scale_mut(&mut self) -> &mut f32 {
        &mut self.sun_scale
    }
    fn panoramic_u_v_min_x(&self) -> &f32 {
        &self.panoramic_u_v_min_x
    }
    fn panoramic_u_v_min_x_mut(&mut self) -> &mut f32 {
        &mut self.panoramic_u_v_min_x
    }
    fn panoramic_u_v_max_x(&self) -> &f32 {
        &self.panoramic_u_v_max_x
    }
    fn panoramic_u_v_max_x_mut(&mut self) -> &mut f32 {
        &mut self.panoramic_u_v_max_x
    }
    fn panoramic_u_v_min_y(&self) -> &f32 {
        &self.panoramic_u_v_min_y
    }
    fn panoramic_u_v_min_y_mut(&mut self) -> &mut f32 {
        &mut self.panoramic_u_v_min_y
    }
    fn panoramic_u_v_max_y(&self) -> &f32 {
        &self.panoramic_u_v_max_y
    }
    fn panoramic_u_v_max_y_mut(&mut self) -> &mut f32 {
        &mut self.panoramic_u_v_max_y
    }
    fn panoramic_tile_factor(&self) -> &f32 {
        &self.panoramic_tile_factor
    }
    fn panoramic_tile_factor_mut(&mut self) -> &mut f32 {
        &mut self.panoramic_tile_factor
    }
    fn panoramic_rotation(&self) -> &f32 {
        &self.panoramic_rotation
    }
    fn panoramic_rotation_mut(&mut self) -> &mut f32 {
        &mut self.panoramic_rotation
    }
    fn panoramic_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &self.panoramic_texture
    }
    fn panoramic_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &mut self.panoramic_texture
    }
    fn panoramic_alpha_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &self.panoramic_alpha_texture
    }
    fn panoramic_alpha_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &mut self.panoramic_alpha_texture
    }
    fn sky_gradient_follows_panoramic_u_vs(&self) -> &bool {
        &self.sky_gradient_follows_panoramic_u_vs
    }
    fn sky_gradient_follows_panoramic_u_vs_mut(&mut self) -> &mut bool {
        &mut self.sky_gradient_follows_panoramic_u_vs
    }
    fn flow_enable(&self) -> &bool {
        &self.flow_enable
    }
    fn flow_enable_mut(&mut self) -> &mut bool {
        &mut self.flow_enable
    }
    fn flow_period(&self) -> &f32 {
        &self.flow_period
    }
    fn flow_period_mut(&mut self) -> &mut f32 {
        &mut self.flow_period
    }
    fn flow_distance(&self) -> &f32 {
        &self.flow_distance
    }
    fn flow_distance_mut(&mut self) -> &mut f32 {
        &mut self.flow_distance
    }
    fn flow_direction(&self) -> &f32 {
        &self.flow_direction
    }
    fn flow_direction_mut(&mut self) -> &mut f32 {
        &mut self.flow_direction
    }
    fn flow_height_mask_scale(&self) -> &f32 {
        &self.flow_height_mask_scale
    }
    fn flow_height_mask_scale_mut(&mut self) -> &mut f32 {
        &mut self.flow_height_mask_scale
    }
    fn flow_height_mask_bias(&self) -> &f32 {
        &self.flow_height_mask_bias
    }
    fn flow_height_mask_bias_mut(&mut self) -> &mut f32 {
        &mut self.flow_height_mask_bias
    }
    fn flow_mask_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &self.flow_mask_texture
    }
    fn flow_mask_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &mut self.flow_mask_texture
    }
    fn cloud_layer_sun_color(&self) -> &super::core::Vec3 {
        &self.cloud_layer_sun_color
    }
    fn cloud_layer_sun_color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.cloud_layer_sun_color
    }
    fn cloud_layer_mask_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &self.cloud_layer_mask_texture
    }
    fn cloud_layer_mask_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &mut self.cloud_layer_mask_texture
    }
    fn cloud_layer1_altitude(&self) -> &f32 {
        &self.cloud_layer1_altitude
    }
    fn cloud_layer1_altitude_mut(&mut self) -> &mut f32 {
        &mut self.cloud_layer1_altitude
    }
    fn cloud_layer1_tile_factor(&self) -> &f32 {
        &self.cloud_layer1_tile_factor
    }
    fn cloud_layer1_tile_factor_mut(&mut self) -> &mut f32 {
        &mut self.cloud_layer1_tile_factor
    }
    fn cloud_layer1_rotation(&self) -> &f32 {
        &self.cloud_layer1_rotation
    }
    fn cloud_layer1_rotation_mut(&mut self) -> &mut f32 {
        &mut self.cloud_layer1_rotation
    }
    fn cloud_layer1_speed(&self) -> &f32 {
        &self.cloud_layer1_speed
    }
    fn cloud_layer1_speed_mut(&mut self) -> &mut f32 {
        &mut self.cloud_layer1_speed
    }
    fn cloud_layer1_sun_light_intensity(&self) -> &f32 {
        &self.cloud_layer1_sun_light_intensity
    }
    fn cloud_layer1_sun_light_intensity_mut(&mut self) -> &mut f32 {
        &mut self.cloud_layer1_sun_light_intensity
    }
    fn cloud_layer1_sun_light_power(&self) -> &f32 {
        &self.cloud_layer1_sun_light_power
    }
    fn cloud_layer1_sun_light_power_mut(&mut self) -> &mut f32 {
        &mut self.cloud_layer1_sun_light_power
    }
    fn cloud_layer1_ambient_light_intensity(&self) -> &f32 {
        &self.cloud_layer1_ambient_light_intensity
    }
    fn cloud_layer1_ambient_light_intensity_mut(&mut self) -> &mut f32 {
        &mut self.cloud_layer1_ambient_light_intensity
    }
    fn cloud_layer1_color(&self) -> &super::core::Vec3 {
        &self.cloud_layer1_color
    }
    fn cloud_layer1_color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.cloud_layer1_color
    }
    fn cloud_layer1_alpha_mul(&self) -> &f32 {
        &self.cloud_layer1_alpha_mul
    }
    fn cloud_layer1_alpha_mul_mut(&mut self) -> &mut f32 {
        &mut self.cloud_layer1_alpha_mul
    }
    fn cloud_layer1_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &self.cloud_layer1_texture
    }
    fn cloud_layer1_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &mut self.cloud_layer1_texture
    }
    fn cloud_layer1_absorption(&self) -> &f32 {
        &self.cloud_layer1_absorption
    }
    fn cloud_layer1_absorption_mut(&mut self) -> &mut f32 {
        &mut self.cloud_layer1_absorption
    }
    fn cloud_layer1_scattering(&self) -> &f32 {
        &self.cloud_layer1_scattering
    }
    fn cloud_layer1_scattering_mut(&mut self) -> &mut f32 {
        &mut self.cloud_layer1_scattering
    }
    fn cloud_layer1_phase(&self) -> &f32 {
        &self.cloud_layer1_phase
    }
    fn cloud_layer1_phase_mut(&mut self) -> &mut f32 {
        &mut self.cloud_layer1_phase
    }
    fn cloud_layer1_thickness(&self) -> &f32 {
        &self.cloud_layer1_thickness
    }
    fn cloud_layer1_thickness_mut(&mut self) -> &mut f32 {
        &mut self.cloud_layer1_thickness
    }
    fn cloud_layer2_altitude(&self) -> &f32 {
        &self.cloud_layer2_altitude
    }
    fn cloud_layer2_altitude_mut(&mut self) -> &mut f32 {
        &mut self.cloud_layer2_altitude
    }
    fn cloud_layer2_tile_factor(&self) -> &f32 {
        &self.cloud_layer2_tile_factor
    }
    fn cloud_layer2_tile_factor_mut(&mut self) -> &mut f32 {
        &mut self.cloud_layer2_tile_factor
    }
    fn cloud_layer2_rotation(&self) -> &f32 {
        &self.cloud_layer2_rotation
    }
    fn cloud_layer2_rotation_mut(&mut self) -> &mut f32 {
        &mut self.cloud_layer2_rotation
    }
    fn cloud_layer2_speed(&self) -> &f32 {
        &self.cloud_layer2_speed
    }
    fn cloud_layer2_speed_mut(&mut self) -> &mut f32 {
        &mut self.cloud_layer2_speed
    }
    fn cloud_layer2_sun_light_intensity(&self) -> &f32 {
        &self.cloud_layer2_sun_light_intensity
    }
    fn cloud_layer2_sun_light_intensity_mut(&mut self) -> &mut f32 {
        &mut self.cloud_layer2_sun_light_intensity
    }
    fn cloud_layer2_sun_light_power(&self) -> &f32 {
        &self.cloud_layer2_sun_light_power
    }
    fn cloud_layer2_sun_light_power_mut(&mut self) -> &mut f32 {
        &mut self.cloud_layer2_sun_light_power
    }
    fn cloud_layer2_ambient_light_intensity(&self) -> &f32 {
        &self.cloud_layer2_ambient_light_intensity
    }
    fn cloud_layer2_ambient_light_intensity_mut(&mut self) -> &mut f32 {
        &mut self.cloud_layer2_ambient_light_intensity
    }
    fn cloud_layer2_color(&self) -> &super::core::Vec3 {
        &self.cloud_layer2_color
    }
    fn cloud_layer2_color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.cloud_layer2_color
    }
    fn cloud_layer2_alpha_mul(&self) -> &f32 {
        &self.cloud_layer2_alpha_mul
    }
    fn cloud_layer2_alpha_mul_mut(&mut self) -> &mut f32 {
        &mut self.cloud_layer2_alpha_mul
    }
    fn cloud_layer2_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &self.cloud_layer2_texture
    }
    fn cloud_layer2_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &mut self.cloud_layer2_texture
    }
    fn cloud_layer2_absorption(&self) -> &f32 {
        &self.cloud_layer2_absorption
    }
    fn cloud_layer2_absorption_mut(&mut self) -> &mut f32 {
        &mut self.cloud_layer2_absorption
    }
    fn cloud_layer2_scattering(&self) -> &f32 {
        &self.cloud_layer2_scattering
    }
    fn cloud_layer2_scattering_mut(&mut self) -> &mut f32 {
        &mut self.cloud_layer2_scattering
    }
    fn cloud_layer2_phase(&self) -> &f32 {
        &self.cloud_layer2_phase
    }
    fn cloud_layer2_phase_mut(&mut self) -> &mut f32 {
        &mut self.cloud_layer2_phase
    }
    fn cloud_layer2_thickness(&self) -> &f32 {
        &self.cloud_layer2_thickness
    }
    fn cloud_layer2_thickness_mut(&mut self) -> &mut f32 {
        &mut self.cloud_layer2_thickness
    }
    fn static_envmap_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &self.static_envmap_texture
    }
    fn static_envmap_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &mut self.static_envmap_texture
    }
    fn static_envmap_scale(&self) -> &f32 {
        &self.static_envmap_scale
    }
    fn static_envmap_scale_mut(&mut self) -> &mut f32 {
        &mut self.static_envmap_scale
    }
    fn sky_envmap8_bit_tex_scale(&self) -> &f32 {
        &self.sky_envmap8_bit_tex_scale
    }
    fn sky_envmap8_bit_tex_scale_mut(&mut self) -> &mut f32 {
        &mut self.sky_envmap8_bit_tex_scale
    }
    fn custom_envmap_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &self.custom_envmap_texture
    }
    fn custom_envmap_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &mut self.custom_envmap_texture
    }
    fn custom_envmap_scale(&self) -> &f32 {
        &self.custom_envmap_scale
    }
    fn custom_envmap_scale_mut(&mut self) -> &mut f32 {
        &mut self.custom_envmap_scale
    }
    fn custom_envmap_ambient(&self) -> &f32 {
        &self.custom_envmap_ambient
    }
    fn custom_envmap_ambient_mut(&mut self) -> &mut f32 {
        &mut self.custom_envmap_ambient
    }
    fn sky_visibility_exponent(&self) -> &f32 {
        &self.sky_visibility_exponent
    }
    fn sky_visibility_exponent_mut(&mut self) -> &mut f32 {
        &mut self.sky_visibility_exponent
    }
    fn interior_envmap_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &self.interior_envmap_texture
    }
    fn interior_envmap_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &mut self.interior_envmap_texture
    }
    fn interior_envmap_exp(&self) -> &super::core::Vec4 {
        &self.interior_envmap_exp
    }
    fn interior_envmap_exp_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.interior_envmap_exp
    }
    fn interior_envmap_scale(&self) -> &super::core::Vec4 {
        &self.interior_envmap_scale
    }
    fn interior_envmap_scale_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.interior_envmap_scale
    }
    fn interior_envmap_bias(&self) -> &super::core::Vec4 {
        &self.interior_envmap_bias
    }
    fn interior_envmap_bias_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.interior_envmap_bias
    }
    fn interior_envmap_sky_visibility_fade_start(&self) -> &f32 {
        &self.interior_envmap_sky_visibility_fade_start
    }
    fn interior_envmap_sky_visibility_fade_start_mut(&mut self) -> &mut f32 {
        &mut self.interior_envmap_sky_visibility_fade_start
    }
    fn interior_envmap_sky_visibility_fade_length(&self) -> &f32 {
        &self.interior_envmap_sky_visibility_fade_length
    }
    fn interior_envmap_sky_visibility_fade_length_mut(&mut self) -> &mut f32 {
        &mut self.interior_envmap_sky_visibility_fade_length
    }
    fn earth_radius(&self) -> &f32 {
        &self.earth_radius
    }
    fn earth_radius_mut(&mut self) -> &mut f32 {
        &mut self.earth_radius
    }
    fn atmosphere_radius(&self) -> &f32 {
        &self.atmosphere_radius
    }
    fn atmosphere_radius_mut(&mut self) -> &mut f32 {
        &mut self.atmosphere_radius
    }
    fn mie_scattering_coefficient(&self) -> &f32 {
        &self.mie_scattering_coefficient
    }
    fn mie_scattering_coefficient_mut(&mut self) -> &mut f32 {
        &mut self.mie_scattering_coefficient
    }
    fn mie_g(&self) -> &f32 {
        &self.mie_g
    }
    fn mie_g_mut(&mut self) -> &mut f32 {
        &mut self.mie_g
    }
    fn mie_extinction_coefficient_relation(&self) -> &f32 {
        &self.mie_extinction_coefficient_relation
    }
    fn mie_extinction_coefficient_relation_mut(&mut self) -> &mut f32 {
        &mut self.mie_extinction_coefficient_relation
    }
    fn scale_height_mie(&self) -> &f32 {
        &self.scale_height_mie
    }
    fn scale_height_mie_mut(&mut self) -> &mut f32 {
        &mut self.scale_height_mie
    }
    fn rayleigh_scattering_coefficient(&self) -> &super::core::Vec3 {
        &self.rayleigh_scattering_coefficient
    }
    fn rayleigh_scattering_coefficient_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.rayleigh_scattering_coefficient
    }
    fn rayleigh_scattering_coefficient_scale(&self) -> &f32 {
        &self.rayleigh_scattering_coefficient_scale
    }
    fn rayleigh_scattering_coefficient_scale_mut(&mut self) -> &mut f32 {
        &mut self.rayleigh_scattering_coefficient_scale
    }
    fn rayleigh_extinction_coefficient_relation(&self) -> &f32 {
        &self.rayleigh_extinction_coefficient_relation
    }
    fn rayleigh_extinction_coefficient_relation_mut(&mut self) -> &mut f32 {
        &mut self.rayleigh_extinction_coefficient_relation
    }
    fn scale_height_rayleigh(&self) -> &f32 {
        &self.scale_height_rayleigh
    }
    fn scale_height_rayleigh_mut(&mut self) -> &mut f32 {
        &mut self.scale_height_rayleigh
    }
    fn use_ozone(&self) -> &bool {
        &self.use_ozone
    }
    fn use_ozone_mut(&mut self) -> &mut bool {
        &mut self.use_ozone
    }
    fn ozone_percentage(&self) -> &f32 {
        &self.ozone_percentage
    }
    fn ozone_percentage_mut(&mut self) -> &mut f32 {
        &mut self.ozone_percentage
    }
    fn use_aerial_perspective(&self) -> &bool {
        &self.use_aerial_perspective
    }
    fn use_aerial_perspective_mut(&mut self) -> &mut bool {
        &mut self.use_aerial_perspective
    }
    fn aerial_perspective_scale(&self) -> &f32 {
        &self.aerial_perspective_scale
    }
    fn aerial_perspective_scale_mut(&mut self) -> &mut f32 {
        &mut self.aerial_perspective_scale
    }
    fn aerial_perspective_intensity(&self) -> &f32 {
        &self.aerial_perspective_intensity
    }
    fn aerial_perspective_intensity_mut(&mut self) -> &mut f32 {
        &mut self.aerial_perspective_intensity
    }
    fn aerial_perspective_dithering(&self) -> &f32 {
        &self.aerial_perspective_dithering
    }
    fn aerial_perspective_dithering_mut(&mut self) -> &mut f32 {
        &mut self.aerial_perspective_dithering
    }
    fn light1_color(&self) -> &super::core::Vec3 {
        &self.light1_color
    }
    fn light1_color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.light1_color
    }
    fn light1_intensity(&self) -> &f32 {
        &self.light1_intensity
    }
    fn light1_intensity_mut(&mut self) -> &mut f32 {
        &mut self.light1_intensity
    }
    fn light1_follow_outdoor_light(&self) -> &bool {
        &self.light1_follow_outdoor_light
    }
    fn light1_follow_outdoor_light_mut(&mut self) -> &mut bool {
        &mut self.light1_follow_outdoor_light
    }
    fn light1_takes_color_from_outdoor_light(&self) -> &bool {
        &self.light1_takes_color_from_outdoor_light
    }
    fn light1_takes_color_from_outdoor_light_mut(&mut self) -> &mut bool {
        &mut self.light1_takes_color_from_outdoor_light
    }
    fn light1_rot_x(&self) -> &f32 {
        &self.light1_rot_x
    }
    fn light1_rot_x_mut(&mut self) -> &mut f32 {
        &mut self.light1_rot_x
    }
    fn light1_rot_y(&self) -> &f32 {
        &self.light1_rot_y
    }
    fn light1_rot_y_mut(&mut self) -> &mut f32 {
        &mut self.light1_rot_y
    }
    fn light2_color(&self) -> &super::core::Vec3 {
        &self.light2_color
    }
    fn light2_color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.light2_color
    }
    fn light2_intensity(&self) -> &f32 {
        &self.light2_intensity
    }
    fn light2_intensity_mut(&mut self) -> &mut f32 {
        &mut self.light2_intensity
    }
    fn use_light_source2(&self) -> &bool {
        &self.use_light_source2
    }
    fn use_light_source2_mut(&mut self) -> &mut bool {
        &mut self.use_light_source2
    }
    fn light2_rot_x(&self) -> &f32 {
        &self.light2_rot_x
    }
    fn light2_rot_x_mut(&mut self) -> &mut f32 {
        &mut self.light2_rot_x
    }
    fn light2_rot_y(&self) -> &f32 {
        &self.light2_rot_y
    }
    fn light2_rot_y_mut(&mut self) -> &mut f32 {
        &mut self.light2_rot_y
    }
    fn use_noise(&self) -> &bool {
        &self.use_noise
    }
    fn use_noise_mut(&mut self) -> &mut bool {
        &mut self.use_noise
    }
    fn fog_start_distance(&self) -> &f32 {
        &self.fog_start_distance
    }
    fn fog_start_distance_mut(&mut self) -> &mut f32 {
        &mut self.fog_start_distance
    }
    fn rayleigh_polarization(&self) -> &super::core::Vec3 {
        &self.rayleigh_polarization
    }
    fn rayleigh_polarization_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.rayleigh_polarization
    }
    fn mie_polarization(&self) -> &super::core::Vec3 {
        &self.mie_polarization
    }
    fn mie_polarization_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.mie_polarization
    }
    fn outdoor_light_scale(&self) -> &super::core::Vec3 {
        &self.outdoor_light_scale
    }
    fn outdoor_light_scale_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.outdoor_light_scale
    }
    fn draw_sun_disc(&self) -> &bool {
        &self.draw_sun_disc
    }
    fn draw_sun_disc_mut(&mut self) -> &mut bool {
        &mut self.draw_sun_disc
    }
    fn forward_scattering_depth_visibility(&self) -> &super::core::Vec4 {
        &self.forward_scattering_depth_visibility
    }
    fn forward_scattering_depth_visibility_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.forward_scattering_depth_visibility
    }
    fn forward_scattering_start_depth(&self) -> &f32 {
        &self.forward_scattering_start_depth
    }
    fn forward_scattering_start_depth_mut(&mut self) -> &mut f32 {
        &mut self.forward_scattering_start_depth
    }
    fn forward_scattering_end_depth(&self) -> &f32 {
        &self.forward_scattering_end_depth
    }
    fn forward_scattering_end_depth_mut(&mut self) -> &mut f32 {
        &mut self.forward_scattering_end_depth
    }
    fn forward_scattering_takes_color_from_outdoor_light(&self) -> &f32 {
        &self.forward_scattering_takes_color_from_outdoor_light
    }
    fn forward_scattering_takes_color_from_outdoor_light_mut(&mut self) -> &mut f32 {
        &mut self.forward_scattering_takes_color_from_outdoor_light
    }
    fn forward_scattering_outdoor_light_tint(&self) -> &super::core::Vec3 {
        &self.forward_scattering_outdoor_light_tint
    }
    fn forward_scattering_outdoor_light_tint_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.forward_scattering_outdoor_light_tint
    }
    fn height_fog_color_add(&self) -> &super::core::Vec3 {
        &self.height_fog_color_add
    }
    fn height_fog_color_add_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.height_fog_color_add
    }
    fn height_fog_color_mult(&self) -> &super::core::Vec3 {
        &self.height_fog_color_mult
    }
    fn height_fog_color_mult_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.height_fog_color_mult
    }
    fn min_height_fog_transmittance(&self) -> &f32 {
        &self.min_height_fog_transmittance
    }
    fn min_height_fog_transmittance_mut(&mut self) -> &mut f32 {
        &mut self.min_height_fog_transmittance
    }
    fn field_flag_override0(&self) -> &u32 {
        &self.field_flag_override0
    }
    fn field_flag_override0_mut(&mut self) -> &mut u32 {
        &mut self.field_flag_override0
    }
    fn field_flag_override1(&self) -> &u32 {
        &self.field_flag_override1
    }
    fn field_flag_override1_mut(&mut self) -> &mut u32 {
        &mut self.field_flag_override1
    }
    fn field_flag_override2(&self) -> &u32 {
        &self.field_flag_override2
    }
    fn field_flag_override2_mut(&mut self) -> &mut u32 {
        &mut self.field_flag_override2
    }
    fn field_flag_override3(&self) -> &u32 {
        &self.field_flag_override3
    }
    fn field_flag_override3_mut(&mut self) -> &mut u32 {
        &mut self.field_flag_override3
    }
}

impl VisualEnvironmentComponentDataTrait for SkyComponentData {
    fn property_overrides(&self) -> &Vec<String> {
        self._glacier_base.property_overrides()
    }
    fn property_overrides_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.property_overrides_mut()
    }
}

impl super::entity::ComponentDataTrait for SkyComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for SkyComponentData {
}

impl super::core::DataBusPeerTrait for SkyComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SkyComponentData {
}

impl super::core::DataContainerTrait for SkyComponentData {
}

pub static SKYCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SkyComponentData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VISUALENVIRONMENTCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SkyComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SkyComponentData, enable),
            },
            FieldInfoData {
                name: "DrawSkyGeo",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SkyComponentData, draw_sky_geo),
            },
            FieldInfoData {
                name: "SkyType",
                flags: MemberInfoFlags::new(0),
                field_type: "SkyType",
                rust_offset: offset_of!(SkyComponentData, sky_type),
            },
            FieldInfoData {
                name: "LuminanceScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, luminance_scale),
            },
            FieldInfoData {
                name: "SkyGradientTexture",
                flags: MemberInfoFlags::new(0),
                field_type: "TextureBaseAsset",
                rust_offset: offset_of!(SkyComponentData, sky_gradient_texture),
            },
            FieldInfoData {
                name: "AlphaOutput",
                flags: MemberInfoFlags::new(0),
                field_type: "AlphaOutputMode",
                rust_offset: offset_of!(SkyComponentData, alpha_output),
            },
            FieldInfoData {
                name: "UseSkyVisibilityAsAO",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SkyComponentData, use_sky_visibility_as_a_o),
            },
            FieldInfoData {
                name: "HdriRotation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, hdri_rotation),
            },
            FieldInfoData {
                name: "HdriTexture",
                flags: MemberInfoFlags::new(0),
                field_type: "TextureBaseAsset",
                rust_offset: offset_of!(SkyComponentData, hdri_texture),
            },
            FieldInfoData {
                name: "SunSize",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, sun_size),
            },
            FieldInfoData {
                name: "SunScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, sun_scale),
            },
            FieldInfoData {
                name: "PanoramicUVMinX",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, panoramic_u_v_min_x),
            },
            FieldInfoData {
                name: "PanoramicUVMaxX",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, panoramic_u_v_max_x),
            },
            FieldInfoData {
                name: "PanoramicUVMinY",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, panoramic_u_v_min_y),
            },
            FieldInfoData {
                name: "PanoramicUVMaxY",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, panoramic_u_v_max_y),
            },
            FieldInfoData {
                name: "PanoramicTileFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, panoramic_tile_factor),
            },
            FieldInfoData {
                name: "PanoramicRotation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, panoramic_rotation),
            },
            FieldInfoData {
                name: "PanoramicTexture",
                flags: MemberInfoFlags::new(0),
                field_type: "TextureBaseAsset",
                rust_offset: offset_of!(SkyComponentData, panoramic_texture),
            },
            FieldInfoData {
                name: "PanoramicAlphaTexture",
                flags: MemberInfoFlags::new(0),
                field_type: "TextureBaseAsset",
                rust_offset: offset_of!(SkyComponentData, panoramic_alpha_texture),
            },
            FieldInfoData {
                name: "SkyGradientFollowsPanoramicUVs",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SkyComponentData, sky_gradient_follows_panoramic_u_vs),
            },
            FieldInfoData {
                name: "FlowEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SkyComponentData, flow_enable),
            },
            FieldInfoData {
                name: "FlowPeriod",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, flow_period),
            },
            FieldInfoData {
                name: "FlowDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, flow_distance),
            },
            FieldInfoData {
                name: "FlowDirection",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, flow_direction),
            },
            FieldInfoData {
                name: "FlowHeightMaskScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, flow_height_mask_scale),
            },
            FieldInfoData {
                name: "FlowHeightMaskBias",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, flow_height_mask_bias),
            },
            FieldInfoData {
                name: "FlowMaskTexture",
                flags: MemberInfoFlags::new(0),
                field_type: "TextureBaseAsset",
                rust_offset: offset_of!(SkyComponentData, flow_mask_texture),
            },
            FieldInfoData {
                name: "CloudLayerSunColor",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SkyComponentData, cloud_layer_sun_color),
            },
            FieldInfoData {
                name: "CloudLayerMaskTexture",
                flags: MemberInfoFlags::new(0),
                field_type: "TextureBaseAsset",
                rust_offset: offset_of!(SkyComponentData, cloud_layer_mask_texture),
            },
            FieldInfoData {
                name: "CloudLayer1Altitude",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, cloud_layer1_altitude),
            },
            FieldInfoData {
                name: "CloudLayer1TileFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, cloud_layer1_tile_factor),
            },
            FieldInfoData {
                name: "CloudLayer1Rotation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, cloud_layer1_rotation),
            },
            FieldInfoData {
                name: "CloudLayer1Speed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, cloud_layer1_speed),
            },
            FieldInfoData {
                name: "CloudLayer1SunLightIntensity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, cloud_layer1_sun_light_intensity),
            },
            FieldInfoData {
                name: "CloudLayer1SunLightPower",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, cloud_layer1_sun_light_power),
            },
            FieldInfoData {
                name: "CloudLayer1AmbientLightIntensity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, cloud_layer1_ambient_light_intensity),
            },
            FieldInfoData {
                name: "CloudLayer1Color",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SkyComponentData, cloud_layer1_color),
            },
            FieldInfoData {
                name: "CloudLayer1AlphaMul",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, cloud_layer1_alpha_mul),
            },
            FieldInfoData {
                name: "CloudLayer1Texture",
                flags: MemberInfoFlags::new(0),
                field_type: "TextureBaseAsset",
                rust_offset: offset_of!(SkyComponentData, cloud_layer1_texture),
            },
            FieldInfoData {
                name: "CloudLayer1Absorption",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, cloud_layer1_absorption),
            },
            FieldInfoData {
                name: "CloudLayer1Scattering",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, cloud_layer1_scattering),
            },
            FieldInfoData {
                name: "CloudLayer1Phase",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, cloud_layer1_phase),
            },
            FieldInfoData {
                name: "CloudLayer1Thickness",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, cloud_layer1_thickness),
            },
            FieldInfoData {
                name: "CloudLayer2Altitude",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, cloud_layer2_altitude),
            },
            FieldInfoData {
                name: "CloudLayer2TileFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, cloud_layer2_tile_factor),
            },
            FieldInfoData {
                name: "CloudLayer2Rotation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, cloud_layer2_rotation),
            },
            FieldInfoData {
                name: "CloudLayer2Speed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, cloud_layer2_speed),
            },
            FieldInfoData {
                name: "CloudLayer2SunLightIntensity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, cloud_layer2_sun_light_intensity),
            },
            FieldInfoData {
                name: "CloudLayer2SunLightPower",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, cloud_layer2_sun_light_power),
            },
            FieldInfoData {
                name: "CloudLayer2AmbientLightIntensity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, cloud_layer2_ambient_light_intensity),
            },
            FieldInfoData {
                name: "CloudLayer2Color",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SkyComponentData, cloud_layer2_color),
            },
            FieldInfoData {
                name: "CloudLayer2AlphaMul",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, cloud_layer2_alpha_mul),
            },
            FieldInfoData {
                name: "CloudLayer2Texture",
                flags: MemberInfoFlags::new(0),
                field_type: "TextureBaseAsset",
                rust_offset: offset_of!(SkyComponentData, cloud_layer2_texture),
            },
            FieldInfoData {
                name: "CloudLayer2Absorption",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, cloud_layer2_absorption),
            },
            FieldInfoData {
                name: "CloudLayer2Scattering",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, cloud_layer2_scattering),
            },
            FieldInfoData {
                name: "CloudLayer2Phase",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, cloud_layer2_phase),
            },
            FieldInfoData {
                name: "CloudLayer2Thickness",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, cloud_layer2_thickness),
            },
            FieldInfoData {
                name: "StaticEnvmapTexture",
                flags: MemberInfoFlags::new(0),
                field_type: "TextureBaseAsset",
                rust_offset: offset_of!(SkyComponentData, static_envmap_texture),
            },
            FieldInfoData {
                name: "StaticEnvmapScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, static_envmap_scale),
            },
            FieldInfoData {
                name: "SkyEnvmap8BitTexScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, sky_envmap8_bit_tex_scale),
            },
            FieldInfoData {
                name: "CustomEnvmapTexture",
                flags: MemberInfoFlags::new(0),
                field_type: "TextureBaseAsset",
                rust_offset: offset_of!(SkyComponentData, custom_envmap_texture),
            },
            FieldInfoData {
                name: "CustomEnvmapScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, custom_envmap_scale),
            },
            FieldInfoData {
                name: "CustomEnvmapAmbient",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, custom_envmap_ambient),
            },
            FieldInfoData {
                name: "SkyVisibilityExponent",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, sky_visibility_exponent),
            },
            FieldInfoData {
                name: "InteriorEnvmapTexture",
                flags: MemberInfoFlags::new(0),
                field_type: "TextureBaseAsset",
                rust_offset: offset_of!(SkyComponentData, interior_envmap_texture),
            },
            FieldInfoData {
                name: "InteriorEnvmapExp",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(SkyComponentData, interior_envmap_exp),
            },
            FieldInfoData {
                name: "InteriorEnvmapScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(SkyComponentData, interior_envmap_scale),
            },
            FieldInfoData {
                name: "InteriorEnvmapBias",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(SkyComponentData, interior_envmap_bias),
            },
            FieldInfoData {
                name: "InteriorEnvmapSkyVisibilityFadeStart",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, interior_envmap_sky_visibility_fade_start),
            },
            FieldInfoData {
                name: "InteriorEnvmapSkyVisibilityFadeLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, interior_envmap_sky_visibility_fade_length),
            },
            FieldInfoData {
                name: "EarthRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, earth_radius),
            },
            FieldInfoData {
                name: "AtmosphereRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, atmosphere_radius),
            },
            FieldInfoData {
                name: "MieScatteringCoefficient",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, mie_scattering_coefficient),
            },
            FieldInfoData {
                name: "MieG",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, mie_g),
            },
            FieldInfoData {
                name: "MieExtinctionCoefficientRelation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, mie_extinction_coefficient_relation),
            },
            FieldInfoData {
                name: "ScaleHeightMie",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, scale_height_mie),
            },
            FieldInfoData {
                name: "RayleighScatteringCoefficient",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SkyComponentData, rayleigh_scattering_coefficient),
            },
            FieldInfoData {
                name: "RayleighScatteringCoefficientScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, rayleigh_scattering_coefficient_scale),
            },
            FieldInfoData {
                name: "RayleighExtinctionCoefficientRelation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, rayleigh_extinction_coefficient_relation),
            },
            FieldInfoData {
                name: "ScaleHeightRayleigh",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, scale_height_rayleigh),
            },
            FieldInfoData {
                name: "UseOzone",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SkyComponentData, use_ozone),
            },
            FieldInfoData {
                name: "OzonePercentage",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, ozone_percentage),
            },
            FieldInfoData {
                name: "UseAerialPerspective",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SkyComponentData, use_aerial_perspective),
            },
            FieldInfoData {
                name: "AerialPerspectiveScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, aerial_perspective_scale),
            },
            FieldInfoData {
                name: "AerialPerspectiveIntensity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, aerial_perspective_intensity),
            },
            FieldInfoData {
                name: "AerialPerspectiveDithering",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, aerial_perspective_dithering),
            },
            FieldInfoData {
                name: "Light1Color",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SkyComponentData, light1_color),
            },
            FieldInfoData {
                name: "Light1Intensity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, light1_intensity),
            },
            FieldInfoData {
                name: "Light1FollowOutdoorLight",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SkyComponentData, light1_follow_outdoor_light),
            },
            FieldInfoData {
                name: "Light1TakesColorFromOutdoorLight",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SkyComponentData, light1_takes_color_from_outdoor_light),
            },
            FieldInfoData {
                name: "Light1RotX",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, light1_rot_x),
            },
            FieldInfoData {
                name: "Light1RotY",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, light1_rot_y),
            },
            FieldInfoData {
                name: "Light2Color",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SkyComponentData, light2_color),
            },
            FieldInfoData {
                name: "Light2Intensity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, light2_intensity),
            },
            FieldInfoData {
                name: "UseLightSource2",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SkyComponentData, use_light_source2),
            },
            FieldInfoData {
                name: "Light2RotX",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, light2_rot_x),
            },
            FieldInfoData {
                name: "Light2RotY",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, light2_rot_y),
            },
            FieldInfoData {
                name: "UseNoise",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SkyComponentData, use_noise),
            },
            FieldInfoData {
                name: "FogStartDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, fog_start_distance),
            },
            FieldInfoData {
                name: "RayleighPolarization",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SkyComponentData, rayleigh_polarization),
            },
            FieldInfoData {
                name: "MiePolarization",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SkyComponentData, mie_polarization),
            },
            FieldInfoData {
                name: "OutdoorLightScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SkyComponentData, outdoor_light_scale),
            },
            FieldInfoData {
                name: "DrawSunDisc",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SkyComponentData, draw_sun_disc),
            },
            FieldInfoData {
                name: "ForwardScatteringDepthVisibility",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(SkyComponentData, forward_scattering_depth_visibility),
            },
            FieldInfoData {
                name: "ForwardScatteringStartDepth",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, forward_scattering_start_depth),
            },
            FieldInfoData {
                name: "ForwardScatteringEndDepth",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, forward_scattering_end_depth),
            },
            FieldInfoData {
                name: "ForwardScatteringTakesColorFromOutdoorLight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, forward_scattering_takes_color_from_outdoor_light),
            },
            FieldInfoData {
                name: "ForwardScatteringOutdoorLightTint",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SkyComponentData, forward_scattering_outdoor_light_tint),
            },
            FieldInfoData {
                name: "HeightFogColorAdd",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SkyComponentData, height_fog_color_add),
            },
            FieldInfoData {
                name: "HeightFogColorMult",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SkyComponentData, height_fog_color_mult),
            },
            FieldInfoData {
                name: "MinHeightFogTransmittance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkyComponentData, min_height_fog_transmittance),
            },
            FieldInfoData {
                name: "FieldFlagOverride0",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(SkyComponentData, field_flag_override0),
            },
            FieldInfoData {
                name: "FieldFlagOverride1",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(SkyComponentData, field_flag_override1),
            },
            FieldInfoData {
                name: "FieldFlagOverride2",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(SkyComponentData, field_flag_override2),
            },
            FieldInfoData {
                name: "FieldFlagOverride3",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(SkyComponentData, field_flag_override3),
            },
        ],
    }),
    array_type: Some(SKYCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SkyComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        SKYCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SKYCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SkyComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("SkyComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FogComponentData {
    pub _glacier_base: VisualEnvironmentComponentData,
    pub enable: bool,
    pub fog_distance_multiplier: f32,
    pub fog_gradient_enable: bool,
    pub start: f32,
    pub end: f32,
    pub curve: super::core::Vec4,
    pub fog_gradient_height_fade_enable: bool,
    pub fade_start: f32,
    pub fade_end: f32,
    pub fog_color_enable: bool,
    pub fog_color: super::core::Vec3,
    pub fog_color_start: f32,
    pub fog_color_end: f32,
    pub fog_color_curve: super::core::Vec4,
    pub transparency_fade_start: f32,
    pub transparency_fade_end: f32,
    pub transparency_fade_clamp: f32,
    pub transparency_fade_curve: super::core::Vec4,
    pub forward_light_scattering_enabled: bool,
    pub forward_light_scattering_use_sun_position: bool,
    pub forward_light_scattering_rotation_x: f32,
    pub forward_light_scattering_rotation_y: f32,
    pub forward_light_scattering_phase_g: f32,
    pub forward_light_scattering_strength: f32,
    pub forward_light_scattering_color: super::core::Vec3,
    pub forward_light_scattering_presence: f32,
    pub forward_light_scattering_max_blur_length: f32,
    pub forward_light_scattering_extinction: f32,
    pub forward_light_scattering_smoothness: f32,
    pub forward_light_scattering_attenuation_type: super::world_base::ForwardLightScatteringAttenuation,
    pub height_fog_enable: bool,
    pub height_fog_follow_camera: f32,
    pub height_fog_altitude: f32,
    pub height_fog_depth: f32,
    pub height_fog_visibility_range: f32,
    pub participating_media_enable: bool,
    pub depth_fog_participating_media: super::world_base::ParticipatingMedia,
    pub height_fog_participating_media: super::world_base::ParticipatingMedia,
    pub fog_volume_strength: f32,
    pub field_flag_override0: u32,
    pub field_flag_override1: u8,
}

pub trait FogComponentDataTrait: VisualEnvironmentComponentDataTrait {
    fn enable(&self) -> &bool;
    fn enable_mut(&mut self) -> &mut bool;
    fn fog_distance_multiplier(&self) -> &f32;
    fn fog_distance_multiplier_mut(&mut self) -> &mut f32;
    fn fog_gradient_enable(&self) -> &bool;
    fn fog_gradient_enable_mut(&mut self) -> &mut bool;
    fn start(&self) -> &f32;
    fn start_mut(&mut self) -> &mut f32;
    fn end(&self) -> &f32;
    fn end_mut(&mut self) -> &mut f32;
    fn curve(&self) -> &super::core::Vec4;
    fn curve_mut(&mut self) -> &mut super::core::Vec4;
    fn fog_gradient_height_fade_enable(&self) -> &bool;
    fn fog_gradient_height_fade_enable_mut(&mut self) -> &mut bool;
    fn fade_start(&self) -> &f32;
    fn fade_start_mut(&mut self) -> &mut f32;
    fn fade_end(&self) -> &f32;
    fn fade_end_mut(&mut self) -> &mut f32;
    fn fog_color_enable(&self) -> &bool;
    fn fog_color_enable_mut(&mut self) -> &mut bool;
    fn fog_color(&self) -> &super::core::Vec3;
    fn fog_color_mut(&mut self) -> &mut super::core::Vec3;
    fn fog_color_start(&self) -> &f32;
    fn fog_color_start_mut(&mut self) -> &mut f32;
    fn fog_color_end(&self) -> &f32;
    fn fog_color_end_mut(&mut self) -> &mut f32;
    fn fog_color_curve(&self) -> &super::core::Vec4;
    fn fog_color_curve_mut(&mut self) -> &mut super::core::Vec4;
    fn transparency_fade_start(&self) -> &f32;
    fn transparency_fade_start_mut(&mut self) -> &mut f32;
    fn transparency_fade_end(&self) -> &f32;
    fn transparency_fade_end_mut(&mut self) -> &mut f32;
    fn transparency_fade_clamp(&self) -> &f32;
    fn transparency_fade_clamp_mut(&mut self) -> &mut f32;
    fn transparency_fade_curve(&self) -> &super::core::Vec4;
    fn transparency_fade_curve_mut(&mut self) -> &mut super::core::Vec4;
    fn forward_light_scattering_enabled(&self) -> &bool;
    fn forward_light_scattering_enabled_mut(&mut self) -> &mut bool;
    fn forward_light_scattering_use_sun_position(&self) -> &bool;
    fn forward_light_scattering_use_sun_position_mut(&mut self) -> &mut bool;
    fn forward_light_scattering_rotation_x(&self) -> &f32;
    fn forward_light_scattering_rotation_x_mut(&mut self) -> &mut f32;
    fn forward_light_scattering_rotation_y(&self) -> &f32;
    fn forward_light_scattering_rotation_y_mut(&mut self) -> &mut f32;
    fn forward_light_scattering_phase_g(&self) -> &f32;
    fn forward_light_scattering_phase_g_mut(&mut self) -> &mut f32;
    fn forward_light_scattering_strength(&self) -> &f32;
    fn forward_light_scattering_strength_mut(&mut self) -> &mut f32;
    fn forward_light_scattering_color(&self) -> &super::core::Vec3;
    fn forward_light_scattering_color_mut(&mut self) -> &mut super::core::Vec3;
    fn forward_light_scattering_presence(&self) -> &f32;
    fn forward_light_scattering_presence_mut(&mut self) -> &mut f32;
    fn forward_light_scattering_max_blur_length(&self) -> &f32;
    fn forward_light_scattering_max_blur_length_mut(&mut self) -> &mut f32;
    fn forward_light_scattering_extinction(&self) -> &f32;
    fn forward_light_scattering_extinction_mut(&mut self) -> &mut f32;
    fn forward_light_scattering_smoothness(&self) -> &f32;
    fn forward_light_scattering_smoothness_mut(&mut self) -> &mut f32;
    fn forward_light_scattering_attenuation_type(&self) -> &super::world_base::ForwardLightScatteringAttenuation;
    fn forward_light_scattering_attenuation_type_mut(&mut self) -> &mut super::world_base::ForwardLightScatteringAttenuation;
    fn height_fog_enable(&self) -> &bool;
    fn height_fog_enable_mut(&mut self) -> &mut bool;
    fn height_fog_follow_camera(&self) -> &f32;
    fn height_fog_follow_camera_mut(&mut self) -> &mut f32;
    fn height_fog_altitude(&self) -> &f32;
    fn height_fog_altitude_mut(&mut self) -> &mut f32;
    fn height_fog_depth(&self) -> &f32;
    fn height_fog_depth_mut(&mut self) -> &mut f32;
    fn height_fog_visibility_range(&self) -> &f32;
    fn height_fog_visibility_range_mut(&mut self) -> &mut f32;
    fn participating_media_enable(&self) -> &bool;
    fn participating_media_enable_mut(&mut self) -> &mut bool;
    fn depth_fog_participating_media(&self) -> &super::world_base::ParticipatingMedia;
    fn depth_fog_participating_media_mut(&mut self) -> &mut super::world_base::ParticipatingMedia;
    fn height_fog_participating_media(&self) -> &super::world_base::ParticipatingMedia;
    fn height_fog_participating_media_mut(&mut self) -> &mut super::world_base::ParticipatingMedia;
    fn fog_volume_strength(&self) -> &f32;
    fn fog_volume_strength_mut(&mut self) -> &mut f32;
    fn field_flag_override0(&self) -> &u32;
    fn field_flag_override0_mut(&mut self) -> &mut u32;
    fn field_flag_override1(&self) -> &u8;
    fn field_flag_override1_mut(&mut self) -> &mut u8;
}

impl FogComponentDataTrait for FogComponentData {
    fn enable(&self) -> &bool {
        &self.enable
    }
    fn enable_mut(&mut self) -> &mut bool {
        &mut self.enable
    }
    fn fog_distance_multiplier(&self) -> &f32 {
        &self.fog_distance_multiplier
    }
    fn fog_distance_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.fog_distance_multiplier
    }
    fn fog_gradient_enable(&self) -> &bool {
        &self.fog_gradient_enable
    }
    fn fog_gradient_enable_mut(&mut self) -> &mut bool {
        &mut self.fog_gradient_enable
    }
    fn start(&self) -> &f32 {
        &self.start
    }
    fn start_mut(&mut self) -> &mut f32 {
        &mut self.start
    }
    fn end(&self) -> &f32 {
        &self.end
    }
    fn end_mut(&mut self) -> &mut f32 {
        &mut self.end
    }
    fn curve(&self) -> &super::core::Vec4 {
        &self.curve
    }
    fn curve_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.curve
    }
    fn fog_gradient_height_fade_enable(&self) -> &bool {
        &self.fog_gradient_height_fade_enable
    }
    fn fog_gradient_height_fade_enable_mut(&mut self) -> &mut bool {
        &mut self.fog_gradient_height_fade_enable
    }
    fn fade_start(&self) -> &f32 {
        &self.fade_start
    }
    fn fade_start_mut(&mut self) -> &mut f32 {
        &mut self.fade_start
    }
    fn fade_end(&self) -> &f32 {
        &self.fade_end
    }
    fn fade_end_mut(&mut self) -> &mut f32 {
        &mut self.fade_end
    }
    fn fog_color_enable(&self) -> &bool {
        &self.fog_color_enable
    }
    fn fog_color_enable_mut(&mut self) -> &mut bool {
        &mut self.fog_color_enable
    }
    fn fog_color(&self) -> &super::core::Vec3 {
        &self.fog_color
    }
    fn fog_color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.fog_color
    }
    fn fog_color_start(&self) -> &f32 {
        &self.fog_color_start
    }
    fn fog_color_start_mut(&mut self) -> &mut f32 {
        &mut self.fog_color_start
    }
    fn fog_color_end(&self) -> &f32 {
        &self.fog_color_end
    }
    fn fog_color_end_mut(&mut self) -> &mut f32 {
        &mut self.fog_color_end
    }
    fn fog_color_curve(&self) -> &super::core::Vec4 {
        &self.fog_color_curve
    }
    fn fog_color_curve_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.fog_color_curve
    }
    fn transparency_fade_start(&self) -> &f32 {
        &self.transparency_fade_start
    }
    fn transparency_fade_start_mut(&mut self) -> &mut f32 {
        &mut self.transparency_fade_start
    }
    fn transparency_fade_end(&self) -> &f32 {
        &self.transparency_fade_end
    }
    fn transparency_fade_end_mut(&mut self) -> &mut f32 {
        &mut self.transparency_fade_end
    }
    fn transparency_fade_clamp(&self) -> &f32 {
        &self.transparency_fade_clamp
    }
    fn transparency_fade_clamp_mut(&mut self) -> &mut f32 {
        &mut self.transparency_fade_clamp
    }
    fn transparency_fade_curve(&self) -> &super::core::Vec4 {
        &self.transparency_fade_curve
    }
    fn transparency_fade_curve_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.transparency_fade_curve
    }
    fn forward_light_scattering_enabled(&self) -> &bool {
        &self.forward_light_scattering_enabled
    }
    fn forward_light_scattering_enabled_mut(&mut self) -> &mut bool {
        &mut self.forward_light_scattering_enabled
    }
    fn forward_light_scattering_use_sun_position(&self) -> &bool {
        &self.forward_light_scattering_use_sun_position
    }
    fn forward_light_scattering_use_sun_position_mut(&mut self) -> &mut bool {
        &mut self.forward_light_scattering_use_sun_position
    }
    fn forward_light_scattering_rotation_x(&self) -> &f32 {
        &self.forward_light_scattering_rotation_x
    }
    fn forward_light_scattering_rotation_x_mut(&mut self) -> &mut f32 {
        &mut self.forward_light_scattering_rotation_x
    }
    fn forward_light_scattering_rotation_y(&self) -> &f32 {
        &self.forward_light_scattering_rotation_y
    }
    fn forward_light_scattering_rotation_y_mut(&mut self) -> &mut f32 {
        &mut self.forward_light_scattering_rotation_y
    }
    fn forward_light_scattering_phase_g(&self) -> &f32 {
        &self.forward_light_scattering_phase_g
    }
    fn forward_light_scattering_phase_g_mut(&mut self) -> &mut f32 {
        &mut self.forward_light_scattering_phase_g
    }
    fn forward_light_scattering_strength(&self) -> &f32 {
        &self.forward_light_scattering_strength
    }
    fn forward_light_scattering_strength_mut(&mut self) -> &mut f32 {
        &mut self.forward_light_scattering_strength
    }
    fn forward_light_scattering_color(&self) -> &super::core::Vec3 {
        &self.forward_light_scattering_color
    }
    fn forward_light_scattering_color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.forward_light_scattering_color
    }
    fn forward_light_scattering_presence(&self) -> &f32 {
        &self.forward_light_scattering_presence
    }
    fn forward_light_scattering_presence_mut(&mut self) -> &mut f32 {
        &mut self.forward_light_scattering_presence
    }
    fn forward_light_scattering_max_blur_length(&self) -> &f32 {
        &self.forward_light_scattering_max_blur_length
    }
    fn forward_light_scattering_max_blur_length_mut(&mut self) -> &mut f32 {
        &mut self.forward_light_scattering_max_blur_length
    }
    fn forward_light_scattering_extinction(&self) -> &f32 {
        &self.forward_light_scattering_extinction
    }
    fn forward_light_scattering_extinction_mut(&mut self) -> &mut f32 {
        &mut self.forward_light_scattering_extinction
    }
    fn forward_light_scattering_smoothness(&self) -> &f32 {
        &self.forward_light_scattering_smoothness
    }
    fn forward_light_scattering_smoothness_mut(&mut self) -> &mut f32 {
        &mut self.forward_light_scattering_smoothness
    }
    fn forward_light_scattering_attenuation_type(&self) -> &super::world_base::ForwardLightScatteringAttenuation {
        &self.forward_light_scattering_attenuation_type
    }
    fn forward_light_scattering_attenuation_type_mut(&mut self) -> &mut super::world_base::ForwardLightScatteringAttenuation {
        &mut self.forward_light_scattering_attenuation_type
    }
    fn height_fog_enable(&self) -> &bool {
        &self.height_fog_enable
    }
    fn height_fog_enable_mut(&mut self) -> &mut bool {
        &mut self.height_fog_enable
    }
    fn height_fog_follow_camera(&self) -> &f32 {
        &self.height_fog_follow_camera
    }
    fn height_fog_follow_camera_mut(&mut self) -> &mut f32 {
        &mut self.height_fog_follow_camera
    }
    fn height_fog_altitude(&self) -> &f32 {
        &self.height_fog_altitude
    }
    fn height_fog_altitude_mut(&mut self) -> &mut f32 {
        &mut self.height_fog_altitude
    }
    fn height_fog_depth(&self) -> &f32 {
        &self.height_fog_depth
    }
    fn height_fog_depth_mut(&mut self) -> &mut f32 {
        &mut self.height_fog_depth
    }
    fn height_fog_visibility_range(&self) -> &f32 {
        &self.height_fog_visibility_range
    }
    fn height_fog_visibility_range_mut(&mut self) -> &mut f32 {
        &mut self.height_fog_visibility_range
    }
    fn participating_media_enable(&self) -> &bool {
        &self.participating_media_enable
    }
    fn participating_media_enable_mut(&mut self) -> &mut bool {
        &mut self.participating_media_enable
    }
    fn depth_fog_participating_media(&self) -> &super::world_base::ParticipatingMedia {
        &self.depth_fog_participating_media
    }
    fn depth_fog_participating_media_mut(&mut self) -> &mut super::world_base::ParticipatingMedia {
        &mut self.depth_fog_participating_media
    }
    fn height_fog_participating_media(&self) -> &super::world_base::ParticipatingMedia {
        &self.height_fog_participating_media
    }
    fn height_fog_participating_media_mut(&mut self) -> &mut super::world_base::ParticipatingMedia {
        &mut self.height_fog_participating_media
    }
    fn fog_volume_strength(&self) -> &f32 {
        &self.fog_volume_strength
    }
    fn fog_volume_strength_mut(&mut self) -> &mut f32 {
        &mut self.fog_volume_strength
    }
    fn field_flag_override0(&self) -> &u32 {
        &self.field_flag_override0
    }
    fn field_flag_override0_mut(&mut self) -> &mut u32 {
        &mut self.field_flag_override0
    }
    fn field_flag_override1(&self) -> &u8 {
        &self.field_flag_override1
    }
    fn field_flag_override1_mut(&mut self) -> &mut u8 {
        &mut self.field_flag_override1
    }
}

impl VisualEnvironmentComponentDataTrait for FogComponentData {
    fn property_overrides(&self) -> &Vec<String> {
        self._glacier_base.property_overrides()
    }
    fn property_overrides_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.property_overrides_mut()
    }
}

impl super::entity::ComponentDataTrait for FogComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for FogComponentData {
}

impl super::core::DataBusPeerTrait for FogComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for FogComponentData {
}

impl super::core::DataContainerTrait for FogComponentData {
}

pub static FOGCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FogComponentData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VISUALENVIRONMENTCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FogComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FogComponentData, enable),
            },
            FieldInfoData {
                name: "FogDistanceMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FogComponentData, fog_distance_multiplier),
            },
            FieldInfoData {
                name: "FogGradientEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FogComponentData, fog_gradient_enable),
            },
            FieldInfoData {
                name: "Start",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FogComponentData, start),
            },
            FieldInfoData {
                name: "End",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FogComponentData, end),
            },
            FieldInfoData {
                name: "Curve",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(FogComponentData, curve),
            },
            FieldInfoData {
                name: "FogGradientHeightFadeEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FogComponentData, fog_gradient_height_fade_enable),
            },
            FieldInfoData {
                name: "FadeStart",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FogComponentData, fade_start),
            },
            FieldInfoData {
                name: "FadeEnd",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FogComponentData, fade_end),
            },
            FieldInfoData {
                name: "FogColorEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FogComponentData, fog_color_enable),
            },
            FieldInfoData {
                name: "FogColor",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(FogComponentData, fog_color),
            },
            FieldInfoData {
                name: "FogColorStart",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FogComponentData, fog_color_start),
            },
            FieldInfoData {
                name: "FogColorEnd",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FogComponentData, fog_color_end),
            },
            FieldInfoData {
                name: "FogColorCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(FogComponentData, fog_color_curve),
            },
            FieldInfoData {
                name: "TransparencyFadeStart",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FogComponentData, transparency_fade_start),
            },
            FieldInfoData {
                name: "TransparencyFadeEnd",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FogComponentData, transparency_fade_end),
            },
            FieldInfoData {
                name: "TransparencyFadeClamp",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FogComponentData, transparency_fade_clamp),
            },
            FieldInfoData {
                name: "TransparencyFadeCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(FogComponentData, transparency_fade_curve),
            },
            FieldInfoData {
                name: "ForwardLightScatteringEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FogComponentData, forward_light_scattering_enabled),
            },
            FieldInfoData {
                name: "ForwardLightScatteringUseSunPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FogComponentData, forward_light_scattering_use_sun_position),
            },
            FieldInfoData {
                name: "ForwardLightScatteringRotationX",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FogComponentData, forward_light_scattering_rotation_x),
            },
            FieldInfoData {
                name: "ForwardLightScatteringRotationY",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FogComponentData, forward_light_scattering_rotation_y),
            },
            FieldInfoData {
                name: "ForwardLightScatteringPhaseG",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FogComponentData, forward_light_scattering_phase_g),
            },
            FieldInfoData {
                name: "ForwardLightScatteringStrength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FogComponentData, forward_light_scattering_strength),
            },
            FieldInfoData {
                name: "ForwardLightScatteringColor",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(FogComponentData, forward_light_scattering_color),
            },
            FieldInfoData {
                name: "ForwardLightScatteringPresence",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FogComponentData, forward_light_scattering_presence),
            },
            FieldInfoData {
                name: "ForwardLightScatteringMaxBlurLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FogComponentData, forward_light_scattering_max_blur_length),
            },
            FieldInfoData {
                name: "ForwardLightScatteringExtinction",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FogComponentData, forward_light_scattering_extinction),
            },
            FieldInfoData {
                name: "ForwardLightScatteringSmoothness",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FogComponentData, forward_light_scattering_smoothness),
            },
            FieldInfoData {
                name: "ForwardLightScatteringAttenuationType",
                flags: MemberInfoFlags::new(0),
                field_type: "ForwardLightScatteringAttenuation",
                rust_offset: offset_of!(FogComponentData, forward_light_scattering_attenuation_type),
            },
            FieldInfoData {
                name: "HeightFogEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FogComponentData, height_fog_enable),
            },
            FieldInfoData {
                name: "HeightFogFollowCamera",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FogComponentData, height_fog_follow_camera),
            },
            FieldInfoData {
                name: "HeightFogAltitude",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FogComponentData, height_fog_altitude),
            },
            FieldInfoData {
                name: "HeightFogDepth",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FogComponentData, height_fog_depth),
            },
            FieldInfoData {
                name: "HeightFogVisibilityRange",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FogComponentData, height_fog_visibility_range),
            },
            FieldInfoData {
                name: "ParticipatingMediaEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FogComponentData, participating_media_enable),
            },
            FieldInfoData {
                name: "DepthFogParticipatingMedia",
                flags: MemberInfoFlags::new(0),
                field_type: "ParticipatingMedia",
                rust_offset: offset_of!(FogComponentData, depth_fog_participating_media),
            },
            FieldInfoData {
                name: "HeightFogParticipatingMedia",
                flags: MemberInfoFlags::new(0),
                field_type: "ParticipatingMedia",
                rust_offset: offset_of!(FogComponentData, height_fog_participating_media),
            },
            FieldInfoData {
                name: "FogVolumeStrength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FogComponentData, fog_volume_strength),
            },
            FieldInfoData {
                name: "FieldFlagOverride0",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(FogComponentData, field_flag_override0),
            },
            FieldInfoData {
                name: "FieldFlagOverride1",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(FogComponentData, field_flag_override1),
            },
        ],
    }),
    array_type: Some(FOGCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for FogComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        FOGCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FOGCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FogComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("FogComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct OutdoorLightComponentData {
    pub _glacier_base: VisualEnvironmentComponentData,
    pub enable: bool,
    pub sun_rotation_x: f32,
    pub sun_rotation_y: f32,
    pub shadow_sun_rotation_enable: bool,
    pub shadow_sun_rotation_x: f32,
    pub shadow_sun_rotation_y: f32,
    pub sun_color: super::core::Vec3,
    pub sun_intensity: f32,
    pub final_sun_luminance: super::core::Vec3,
    pub final_sun_illuminance: super::core::Vec3,
    pub outer_space_sun_luminance: super::core::Vec3,
    pub outer_space_sun_illuminance1: super::core::Vec3,
    pub outer_space_sun_illuminance2: super::core::Vec3,
    pub sun_angular_radius: f32,
    pub sky_color: super::core::Vec3,
    pub ground_color: super::core::Vec3,
    pub sky_light_angle_factor: f32,
    pub sun_specular_scale: f32,
    pub sky_envmap_shadow_scale: f32,
    pub cascade_shadow_enable: bool,
    pub sun_shadow_height_scale: f32,
    pub sun_shadow_filter_type: super::world_base::ShadowFilteringType,
    pub sun_shadow_forward_quality: super::render_base::ShaderShadowmapQuality,
    pub sun_pcss_filter_adaptive: bool,
    pub sun_pcss_initial_sample_count: i32,
    pub sun_pcss_maximum_sample_count: i32,
    pub sun_pcss_filter_error_threshold_pct: f32,
    pub sun_penumbra_size: f32,
    pub sun_pcss_shadow_filter_scale: f32,
    pub cloud_shadow_enable: bool,
    pub cloud_shadow_texture: Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>,
    pub cloud_shadow_speed: super::core::Vec2,
    pub cloud_shadow_size: f32,
    pub cloud_shadow_coverage: f32,
    pub cloud_shadow_exponent: f32,
    pub cloud_shadow_is_top_down: bool,
    pub cloud_shadow_start_fade: f32,
    pub cloud_shadows_fade_distance: f32,
    pub cloud_shadow_height_fade_enable: bool,
    pub cloud_shadow_start_height_fade: f32,
    pub cloud_shadows_height_fade_distance: f32,
    pub cloud_x_z_translation: super::core::Vec2,
    pub cloud_shadow_addressing_mode: super::render_base::TextureAddress,
    pub cloud_radiosity_enable: bool,
    pub secondary_cloud_shadow_texture: Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>,
    pub secondary_cloud_shadow_speed: super::core::Vec2,
    pub secondary_cloud_shadow_size: f32,
    pub secondary_cloud_shadow_coverage: f32,
    pub secondary_cloud_shadow_exponent: f32,
    pub secondary_cloud_shadow_is_top_down: bool,
    pub secondary_cloud_x_z_translation: super::core::Vec2,
    pub secondary_cloud_shadow_addressing_mode: super::render_base::TextureAddress,
    pub cast_terrain_shadows_enable: bool,
    pub translucency_ambient: f32,
    pub translucency_scale: f32,
    pub translucency_power: f32,
    pub translucency_distortion: f32,
    pub particle_sun_shadow_factor: f32,
    pub particle_sun_shadow_smoothing: f32,
    pub field_flag_override0: u32,
    pub field_flag_override1: u32,
}

pub trait OutdoorLightComponentDataTrait: VisualEnvironmentComponentDataTrait {
    fn enable(&self) -> &bool;
    fn enable_mut(&mut self) -> &mut bool;
    fn sun_rotation_x(&self) -> &f32;
    fn sun_rotation_x_mut(&mut self) -> &mut f32;
    fn sun_rotation_y(&self) -> &f32;
    fn sun_rotation_y_mut(&mut self) -> &mut f32;
    fn shadow_sun_rotation_enable(&self) -> &bool;
    fn shadow_sun_rotation_enable_mut(&mut self) -> &mut bool;
    fn shadow_sun_rotation_x(&self) -> &f32;
    fn shadow_sun_rotation_x_mut(&mut self) -> &mut f32;
    fn shadow_sun_rotation_y(&self) -> &f32;
    fn shadow_sun_rotation_y_mut(&mut self) -> &mut f32;
    fn sun_color(&self) -> &super::core::Vec3;
    fn sun_color_mut(&mut self) -> &mut super::core::Vec3;
    fn sun_intensity(&self) -> &f32;
    fn sun_intensity_mut(&mut self) -> &mut f32;
    fn final_sun_luminance(&self) -> &super::core::Vec3;
    fn final_sun_luminance_mut(&mut self) -> &mut super::core::Vec3;
    fn final_sun_illuminance(&self) -> &super::core::Vec3;
    fn final_sun_illuminance_mut(&mut self) -> &mut super::core::Vec3;
    fn outer_space_sun_luminance(&self) -> &super::core::Vec3;
    fn outer_space_sun_luminance_mut(&mut self) -> &mut super::core::Vec3;
    fn outer_space_sun_illuminance1(&self) -> &super::core::Vec3;
    fn outer_space_sun_illuminance1_mut(&mut self) -> &mut super::core::Vec3;
    fn outer_space_sun_illuminance2(&self) -> &super::core::Vec3;
    fn outer_space_sun_illuminance2_mut(&mut self) -> &mut super::core::Vec3;
    fn sun_angular_radius(&self) -> &f32;
    fn sun_angular_radius_mut(&mut self) -> &mut f32;
    fn sky_color(&self) -> &super::core::Vec3;
    fn sky_color_mut(&mut self) -> &mut super::core::Vec3;
    fn ground_color(&self) -> &super::core::Vec3;
    fn ground_color_mut(&mut self) -> &mut super::core::Vec3;
    fn sky_light_angle_factor(&self) -> &f32;
    fn sky_light_angle_factor_mut(&mut self) -> &mut f32;
    fn sun_specular_scale(&self) -> &f32;
    fn sun_specular_scale_mut(&mut self) -> &mut f32;
    fn sky_envmap_shadow_scale(&self) -> &f32;
    fn sky_envmap_shadow_scale_mut(&mut self) -> &mut f32;
    fn cascade_shadow_enable(&self) -> &bool;
    fn cascade_shadow_enable_mut(&mut self) -> &mut bool;
    fn sun_shadow_height_scale(&self) -> &f32;
    fn sun_shadow_height_scale_mut(&mut self) -> &mut f32;
    fn sun_shadow_filter_type(&self) -> &super::world_base::ShadowFilteringType;
    fn sun_shadow_filter_type_mut(&mut self) -> &mut super::world_base::ShadowFilteringType;
    fn sun_shadow_forward_quality(&self) -> &super::render_base::ShaderShadowmapQuality;
    fn sun_shadow_forward_quality_mut(&mut self) -> &mut super::render_base::ShaderShadowmapQuality;
    fn sun_pcss_filter_adaptive(&self) -> &bool;
    fn sun_pcss_filter_adaptive_mut(&mut self) -> &mut bool;
    fn sun_pcss_initial_sample_count(&self) -> &i32;
    fn sun_pcss_initial_sample_count_mut(&mut self) -> &mut i32;
    fn sun_pcss_maximum_sample_count(&self) -> &i32;
    fn sun_pcss_maximum_sample_count_mut(&mut self) -> &mut i32;
    fn sun_pcss_filter_error_threshold_pct(&self) -> &f32;
    fn sun_pcss_filter_error_threshold_pct_mut(&mut self) -> &mut f32;
    fn sun_penumbra_size(&self) -> &f32;
    fn sun_penumbra_size_mut(&mut self) -> &mut f32;
    fn sun_pcss_shadow_filter_scale(&self) -> &f32;
    fn sun_pcss_shadow_filter_scale_mut(&mut self) -> &mut f32;
    fn cloud_shadow_enable(&self) -> &bool;
    fn cloud_shadow_enable_mut(&mut self) -> &mut bool;
    fn cloud_shadow_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn cloud_shadow_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn cloud_shadow_speed(&self) -> &super::core::Vec2;
    fn cloud_shadow_speed_mut(&mut self) -> &mut super::core::Vec2;
    fn cloud_shadow_size(&self) -> &f32;
    fn cloud_shadow_size_mut(&mut self) -> &mut f32;
    fn cloud_shadow_coverage(&self) -> &f32;
    fn cloud_shadow_coverage_mut(&mut self) -> &mut f32;
    fn cloud_shadow_exponent(&self) -> &f32;
    fn cloud_shadow_exponent_mut(&mut self) -> &mut f32;
    fn cloud_shadow_is_top_down(&self) -> &bool;
    fn cloud_shadow_is_top_down_mut(&mut self) -> &mut bool;
    fn cloud_shadow_start_fade(&self) -> &f32;
    fn cloud_shadow_start_fade_mut(&mut self) -> &mut f32;
    fn cloud_shadows_fade_distance(&self) -> &f32;
    fn cloud_shadows_fade_distance_mut(&mut self) -> &mut f32;
    fn cloud_shadow_height_fade_enable(&self) -> &bool;
    fn cloud_shadow_height_fade_enable_mut(&mut self) -> &mut bool;
    fn cloud_shadow_start_height_fade(&self) -> &f32;
    fn cloud_shadow_start_height_fade_mut(&mut self) -> &mut f32;
    fn cloud_shadows_height_fade_distance(&self) -> &f32;
    fn cloud_shadows_height_fade_distance_mut(&mut self) -> &mut f32;
    fn cloud_x_z_translation(&self) -> &super::core::Vec2;
    fn cloud_x_z_translation_mut(&mut self) -> &mut super::core::Vec2;
    fn cloud_shadow_addressing_mode(&self) -> &super::render_base::TextureAddress;
    fn cloud_shadow_addressing_mode_mut(&mut self) -> &mut super::render_base::TextureAddress;
    fn cloud_radiosity_enable(&self) -> &bool;
    fn cloud_radiosity_enable_mut(&mut self) -> &mut bool;
    fn secondary_cloud_shadow_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn secondary_cloud_shadow_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn secondary_cloud_shadow_speed(&self) -> &super::core::Vec2;
    fn secondary_cloud_shadow_speed_mut(&mut self) -> &mut super::core::Vec2;
    fn secondary_cloud_shadow_size(&self) -> &f32;
    fn secondary_cloud_shadow_size_mut(&mut self) -> &mut f32;
    fn secondary_cloud_shadow_coverage(&self) -> &f32;
    fn secondary_cloud_shadow_coverage_mut(&mut self) -> &mut f32;
    fn secondary_cloud_shadow_exponent(&self) -> &f32;
    fn secondary_cloud_shadow_exponent_mut(&mut self) -> &mut f32;
    fn secondary_cloud_shadow_is_top_down(&self) -> &bool;
    fn secondary_cloud_shadow_is_top_down_mut(&mut self) -> &mut bool;
    fn secondary_cloud_x_z_translation(&self) -> &super::core::Vec2;
    fn secondary_cloud_x_z_translation_mut(&mut self) -> &mut super::core::Vec2;
    fn secondary_cloud_shadow_addressing_mode(&self) -> &super::render_base::TextureAddress;
    fn secondary_cloud_shadow_addressing_mode_mut(&mut self) -> &mut super::render_base::TextureAddress;
    fn cast_terrain_shadows_enable(&self) -> &bool;
    fn cast_terrain_shadows_enable_mut(&mut self) -> &mut bool;
    fn translucency_ambient(&self) -> &f32;
    fn translucency_ambient_mut(&mut self) -> &mut f32;
    fn translucency_scale(&self) -> &f32;
    fn translucency_scale_mut(&mut self) -> &mut f32;
    fn translucency_power(&self) -> &f32;
    fn translucency_power_mut(&mut self) -> &mut f32;
    fn translucency_distortion(&self) -> &f32;
    fn translucency_distortion_mut(&mut self) -> &mut f32;
    fn particle_sun_shadow_factor(&self) -> &f32;
    fn particle_sun_shadow_factor_mut(&mut self) -> &mut f32;
    fn particle_sun_shadow_smoothing(&self) -> &f32;
    fn particle_sun_shadow_smoothing_mut(&mut self) -> &mut f32;
    fn field_flag_override0(&self) -> &u32;
    fn field_flag_override0_mut(&mut self) -> &mut u32;
    fn field_flag_override1(&self) -> &u32;
    fn field_flag_override1_mut(&mut self) -> &mut u32;
}

impl OutdoorLightComponentDataTrait for OutdoorLightComponentData {
    fn enable(&self) -> &bool {
        &self.enable
    }
    fn enable_mut(&mut self) -> &mut bool {
        &mut self.enable
    }
    fn sun_rotation_x(&self) -> &f32 {
        &self.sun_rotation_x
    }
    fn sun_rotation_x_mut(&mut self) -> &mut f32 {
        &mut self.sun_rotation_x
    }
    fn sun_rotation_y(&self) -> &f32 {
        &self.sun_rotation_y
    }
    fn sun_rotation_y_mut(&mut self) -> &mut f32 {
        &mut self.sun_rotation_y
    }
    fn shadow_sun_rotation_enable(&self) -> &bool {
        &self.shadow_sun_rotation_enable
    }
    fn shadow_sun_rotation_enable_mut(&mut self) -> &mut bool {
        &mut self.shadow_sun_rotation_enable
    }
    fn shadow_sun_rotation_x(&self) -> &f32 {
        &self.shadow_sun_rotation_x
    }
    fn shadow_sun_rotation_x_mut(&mut self) -> &mut f32 {
        &mut self.shadow_sun_rotation_x
    }
    fn shadow_sun_rotation_y(&self) -> &f32 {
        &self.shadow_sun_rotation_y
    }
    fn shadow_sun_rotation_y_mut(&mut self) -> &mut f32 {
        &mut self.shadow_sun_rotation_y
    }
    fn sun_color(&self) -> &super::core::Vec3 {
        &self.sun_color
    }
    fn sun_color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.sun_color
    }
    fn sun_intensity(&self) -> &f32 {
        &self.sun_intensity
    }
    fn sun_intensity_mut(&mut self) -> &mut f32 {
        &mut self.sun_intensity
    }
    fn final_sun_luminance(&self) -> &super::core::Vec3 {
        &self.final_sun_luminance
    }
    fn final_sun_luminance_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.final_sun_luminance
    }
    fn final_sun_illuminance(&self) -> &super::core::Vec3 {
        &self.final_sun_illuminance
    }
    fn final_sun_illuminance_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.final_sun_illuminance
    }
    fn outer_space_sun_luminance(&self) -> &super::core::Vec3 {
        &self.outer_space_sun_luminance
    }
    fn outer_space_sun_luminance_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.outer_space_sun_luminance
    }
    fn outer_space_sun_illuminance1(&self) -> &super::core::Vec3 {
        &self.outer_space_sun_illuminance1
    }
    fn outer_space_sun_illuminance1_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.outer_space_sun_illuminance1
    }
    fn outer_space_sun_illuminance2(&self) -> &super::core::Vec3 {
        &self.outer_space_sun_illuminance2
    }
    fn outer_space_sun_illuminance2_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.outer_space_sun_illuminance2
    }
    fn sun_angular_radius(&self) -> &f32 {
        &self.sun_angular_radius
    }
    fn sun_angular_radius_mut(&mut self) -> &mut f32 {
        &mut self.sun_angular_radius
    }
    fn sky_color(&self) -> &super::core::Vec3 {
        &self.sky_color
    }
    fn sky_color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.sky_color
    }
    fn ground_color(&self) -> &super::core::Vec3 {
        &self.ground_color
    }
    fn ground_color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.ground_color
    }
    fn sky_light_angle_factor(&self) -> &f32 {
        &self.sky_light_angle_factor
    }
    fn sky_light_angle_factor_mut(&mut self) -> &mut f32 {
        &mut self.sky_light_angle_factor
    }
    fn sun_specular_scale(&self) -> &f32 {
        &self.sun_specular_scale
    }
    fn sun_specular_scale_mut(&mut self) -> &mut f32 {
        &mut self.sun_specular_scale
    }
    fn sky_envmap_shadow_scale(&self) -> &f32 {
        &self.sky_envmap_shadow_scale
    }
    fn sky_envmap_shadow_scale_mut(&mut self) -> &mut f32 {
        &mut self.sky_envmap_shadow_scale
    }
    fn cascade_shadow_enable(&self) -> &bool {
        &self.cascade_shadow_enable
    }
    fn cascade_shadow_enable_mut(&mut self) -> &mut bool {
        &mut self.cascade_shadow_enable
    }
    fn sun_shadow_height_scale(&self) -> &f32 {
        &self.sun_shadow_height_scale
    }
    fn sun_shadow_height_scale_mut(&mut self) -> &mut f32 {
        &mut self.sun_shadow_height_scale
    }
    fn sun_shadow_filter_type(&self) -> &super::world_base::ShadowFilteringType {
        &self.sun_shadow_filter_type
    }
    fn sun_shadow_filter_type_mut(&mut self) -> &mut super::world_base::ShadowFilteringType {
        &mut self.sun_shadow_filter_type
    }
    fn sun_shadow_forward_quality(&self) -> &super::render_base::ShaderShadowmapQuality {
        &self.sun_shadow_forward_quality
    }
    fn sun_shadow_forward_quality_mut(&mut self) -> &mut super::render_base::ShaderShadowmapQuality {
        &mut self.sun_shadow_forward_quality
    }
    fn sun_pcss_filter_adaptive(&self) -> &bool {
        &self.sun_pcss_filter_adaptive
    }
    fn sun_pcss_filter_adaptive_mut(&mut self) -> &mut bool {
        &mut self.sun_pcss_filter_adaptive
    }
    fn sun_pcss_initial_sample_count(&self) -> &i32 {
        &self.sun_pcss_initial_sample_count
    }
    fn sun_pcss_initial_sample_count_mut(&mut self) -> &mut i32 {
        &mut self.sun_pcss_initial_sample_count
    }
    fn sun_pcss_maximum_sample_count(&self) -> &i32 {
        &self.sun_pcss_maximum_sample_count
    }
    fn sun_pcss_maximum_sample_count_mut(&mut self) -> &mut i32 {
        &mut self.sun_pcss_maximum_sample_count
    }
    fn sun_pcss_filter_error_threshold_pct(&self) -> &f32 {
        &self.sun_pcss_filter_error_threshold_pct
    }
    fn sun_pcss_filter_error_threshold_pct_mut(&mut self) -> &mut f32 {
        &mut self.sun_pcss_filter_error_threshold_pct
    }
    fn sun_penumbra_size(&self) -> &f32 {
        &self.sun_penumbra_size
    }
    fn sun_penumbra_size_mut(&mut self) -> &mut f32 {
        &mut self.sun_penumbra_size
    }
    fn sun_pcss_shadow_filter_scale(&self) -> &f32 {
        &self.sun_pcss_shadow_filter_scale
    }
    fn sun_pcss_shadow_filter_scale_mut(&mut self) -> &mut f32 {
        &mut self.sun_pcss_shadow_filter_scale
    }
    fn cloud_shadow_enable(&self) -> &bool {
        &self.cloud_shadow_enable
    }
    fn cloud_shadow_enable_mut(&mut self) -> &mut bool {
        &mut self.cloud_shadow_enable
    }
    fn cloud_shadow_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &self.cloud_shadow_texture
    }
    fn cloud_shadow_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &mut self.cloud_shadow_texture
    }
    fn cloud_shadow_speed(&self) -> &super::core::Vec2 {
        &self.cloud_shadow_speed
    }
    fn cloud_shadow_speed_mut(&mut self) -> &mut super::core::Vec2 {
        &mut self.cloud_shadow_speed
    }
    fn cloud_shadow_size(&self) -> &f32 {
        &self.cloud_shadow_size
    }
    fn cloud_shadow_size_mut(&mut self) -> &mut f32 {
        &mut self.cloud_shadow_size
    }
    fn cloud_shadow_coverage(&self) -> &f32 {
        &self.cloud_shadow_coverage
    }
    fn cloud_shadow_coverage_mut(&mut self) -> &mut f32 {
        &mut self.cloud_shadow_coverage
    }
    fn cloud_shadow_exponent(&self) -> &f32 {
        &self.cloud_shadow_exponent
    }
    fn cloud_shadow_exponent_mut(&mut self) -> &mut f32 {
        &mut self.cloud_shadow_exponent
    }
    fn cloud_shadow_is_top_down(&self) -> &bool {
        &self.cloud_shadow_is_top_down
    }
    fn cloud_shadow_is_top_down_mut(&mut self) -> &mut bool {
        &mut self.cloud_shadow_is_top_down
    }
    fn cloud_shadow_start_fade(&self) -> &f32 {
        &self.cloud_shadow_start_fade
    }
    fn cloud_shadow_start_fade_mut(&mut self) -> &mut f32 {
        &mut self.cloud_shadow_start_fade
    }
    fn cloud_shadows_fade_distance(&self) -> &f32 {
        &self.cloud_shadows_fade_distance
    }
    fn cloud_shadows_fade_distance_mut(&mut self) -> &mut f32 {
        &mut self.cloud_shadows_fade_distance
    }
    fn cloud_shadow_height_fade_enable(&self) -> &bool {
        &self.cloud_shadow_height_fade_enable
    }
    fn cloud_shadow_height_fade_enable_mut(&mut self) -> &mut bool {
        &mut self.cloud_shadow_height_fade_enable
    }
    fn cloud_shadow_start_height_fade(&self) -> &f32 {
        &self.cloud_shadow_start_height_fade
    }
    fn cloud_shadow_start_height_fade_mut(&mut self) -> &mut f32 {
        &mut self.cloud_shadow_start_height_fade
    }
    fn cloud_shadows_height_fade_distance(&self) -> &f32 {
        &self.cloud_shadows_height_fade_distance
    }
    fn cloud_shadows_height_fade_distance_mut(&mut self) -> &mut f32 {
        &mut self.cloud_shadows_height_fade_distance
    }
    fn cloud_x_z_translation(&self) -> &super::core::Vec2 {
        &self.cloud_x_z_translation
    }
    fn cloud_x_z_translation_mut(&mut self) -> &mut super::core::Vec2 {
        &mut self.cloud_x_z_translation
    }
    fn cloud_shadow_addressing_mode(&self) -> &super::render_base::TextureAddress {
        &self.cloud_shadow_addressing_mode
    }
    fn cloud_shadow_addressing_mode_mut(&mut self) -> &mut super::render_base::TextureAddress {
        &mut self.cloud_shadow_addressing_mode
    }
    fn cloud_radiosity_enable(&self) -> &bool {
        &self.cloud_radiosity_enable
    }
    fn cloud_radiosity_enable_mut(&mut self) -> &mut bool {
        &mut self.cloud_radiosity_enable
    }
    fn secondary_cloud_shadow_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &self.secondary_cloud_shadow_texture
    }
    fn secondary_cloud_shadow_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &mut self.secondary_cloud_shadow_texture
    }
    fn secondary_cloud_shadow_speed(&self) -> &super::core::Vec2 {
        &self.secondary_cloud_shadow_speed
    }
    fn secondary_cloud_shadow_speed_mut(&mut self) -> &mut super::core::Vec2 {
        &mut self.secondary_cloud_shadow_speed
    }
    fn secondary_cloud_shadow_size(&self) -> &f32 {
        &self.secondary_cloud_shadow_size
    }
    fn secondary_cloud_shadow_size_mut(&mut self) -> &mut f32 {
        &mut self.secondary_cloud_shadow_size
    }
    fn secondary_cloud_shadow_coverage(&self) -> &f32 {
        &self.secondary_cloud_shadow_coverage
    }
    fn secondary_cloud_shadow_coverage_mut(&mut self) -> &mut f32 {
        &mut self.secondary_cloud_shadow_coverage
    }
    fn secondary_cloud_shadow_exponent(&self) -> &f32 {
        &self.secondary_cloud_shadow_exponent
    }
    fn secondary_cloud_shadow_exponent_mut(&mut self) -> &mut f32 {
        &mut self.secondary_cloud_shadow_exponent
    }
    fn secondary_cloud_shadow_is_top_down(&self) -> &bool {
        &self.secondary_cloud_shadow_is_top_down
    }
    fn secondary_cloud_shadow_is_top_down_mut(&mut self) -> &mut bool {
        &mut self.secondary_cloud_shadow_is_top_down
    }
    fn secondary_cloud_x_z_translation(&self) -> &super::core::Vec2 {
        &self.secondary_cloud_x_z_translation
    }
    fn secondary_cloud_x_z_translation_mut(&mut self) -> &mut super::core::Vec2 {
        &mut self.secondary_cloud_x_z_translation
    }
    fn secondary_cloud_shadow_addressing_mode(&self) -> &super::render_base::TextureAddress {
        &self.secondary_cloud_shadow_addressing_mode
    }
    fn secondary_cloud_shadow_addressing_mode_mut(&mut self) -> &mut super::render_base::TextureAddress {
        &mut self.secondary_cloud_shadow_addressing_mode
    }
    fn cast_terrain_shadows_enable(&self) -> &bool {
        &self.cast_terrain_shadows_enable
    }
    fn cast_terrain_shadows_enable_mut(&mut self) -> &mut bool {
        &mut self.cast_terrain_shadows_enable
    }
    fn translucency_ambient(&self) -> &f32 {
        &self.translucency_ambient
    }
    fn translucency_ambient_mut(&mut self) -> &mut f32 {
        &mut self.translucency_ambient
    }
    fn translucency_scale(&self) -> &f32 {
        &self.translucency_scale
    }
    fn translucency_scale_mut(&mut self) -> &mut f32 {
        &mut self.translucency_scale
    }
    fn translucency_power(&self) -> &f32 {
        &self.translucency_power
    }
    fn translucency_power_mut(&mut self) -> &mut f32 {
        &mut self.translucency_power
    }
    fn translucency_distortion(&self) -> &f32 {
        &self.translucency_distortion
    }
    fn translucency_distortion_mut(&mut self) -> &mut f32 {
        &mut self.translucency_distortion
    }
    fn particle_sun_shadow_factor(&self) -> &f32 {
        &self.particle_sun_shadow_factor
    }
    fn particle_sun_shadow_factor_mut(&mut self) -> &mut f32 {
        &mut self.particle_sun_shadow_factor
    }
    fn particle_sun_shadow_smoothing(&self) -> &f32 {
        &self.particle_sun_shadow_smoothing
    }
    fn particle_sun_shadow_smoothing_mut(&mut self) -> &mut f32 {
        &mut self.particle_sun_shadow_smoothing
    }
    fn field_flag_override0(&self) -> &u32 {
        &self.field_flag_override0
    }
    fn field_flag_override0_mut(&mut self) -> &mut u32 {
        &mut self.field_flag_override0
    }
    fn field_flag_override1(&self) -> &u32 {
        &self.field_flag_override1
    }
    fn field_flag_override1_mut(&mut self) -> &mut u32 {
        &mut self.field_flag_override1
    }
}

impl VisualEnvironmentComponentDataTrait for OutdoorLightComponentData {
    fn property_overrides(&self) -> &Vec<String> {
        self._glacier_base.property_overrides()
    }
    fn property_overrides_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.property_overrides_mut()
    }
}

impl super::entity::ComponentDataTrait for OutdoorLightComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for OutdoorLightComponentData {
}

impl super::core::DataBusPeerTrait for OutdoorLightComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for OutdoorLightComponentData {
}

impl super::core::DataContainerTrait for OutdoorLightComponentData {
}

pub static OUTDOORLIGHTCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OutdoorLightComponentData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VISUALENVIRONMENTCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<OutdoorLightComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(OutdoorLightComponentData, enable),
            },
            FieldInfoData {
                name: "SunRotationX",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(OutdoorLightComponentData, sun_rotation_x),
            },
            FieldInfoData {
                name: "SunRotationY",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(OutdoorLightComponentData, sun_rotation_y),
            },
            FieldInfoData {
                name: "ShadowSunRotationEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(OutdoorLightComponentData, shadow_sun_rotation_enable),
            },
            FieldInfoData {
                name: "ShadowSunRotationX",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(OutdoorLightComponentData, shadow_sun_rotation_x),
            },
            FieldInfoData {
                name: "ShadowSunRotationY",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(OutdoorLightComponentData, shadow_sun_rotation_y),
            },
            FieldInfoData {
                name: "SunColor",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(OutdoorLightComponentData, sun_color),
            },
            FieldInfoData {
                name: "SunIntensity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(OutdoorLightComponentData, sun_intensity),
            },
            FieldInfoData {
                name: "FinalSunLuminance",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(OutdoorLightComponentData, final_sun_luminance),
            },
            FieldInfoData {
                name: "FinalSunIlluminance",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(OutdoorLightComponentData, final_sun_illuminance),
            },
            FieldInfoData {
                name: "OuterSpaceSunLuminance",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(OutdoorLightComponentData, outer_space_sun_luminance),
            },
            FieldInfoData {
                name: "OuterSpaceSunIlluminance1",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(OutdoorLightComponentData, outer_space_sun_illuminance1),
            },
            FieldInfoData {
                name: "OuterSpaceSunIlluminance2",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(OutdoorLightComponentData, outer_space_sun_illuminance2),
            },
            FieldInfoData {
                name: "SunAngularRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(OutdoorLightComponentData, sun_angular_radius),
            },
            FieldInfoData {
                name: "SkyColor",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(OutdoorLightComponentData, sky_color),
            },
            FieldInfoData {
                name: "GroundColor",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(OutdoorLightComponentData, ground_color),
            },
            FieldInfoData {
                name: "SkyLightAngleFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(OutdoorLightComponentData, sky_light_angle_factor),
            },
            FieldInfoData {
                name: "SunSpecularScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(OutdoorLightComponentData, sun_specular_scale),
            },
            FieldInfoData {
                name: "SkyEnvmapShadowScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(OutdoorLightComponentData, sky_envmap_shadow_scale),
            },
            FieldInfoData {
                name: "CascadeShadowEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(OutdoorLightComponentData, cascade_shadow_enable),
            },
            FieldInfoData {
                name: "SunShadowHeightScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(OutdoorLightComponentData, sun_shadow_height_scale),
            },
            FieldInfoData {
                name: "SunShadowFilterType",
                flags: MemberInfoFlags::new(0),
                field_type: "ShadowFilteringType",
                rust_offset: offset_of!(OutdoorLightComponentData, sun_shadow_filter_type),
            },
            FieldInfoData {
                name: "SunShadowForwardQuality",
                flags: MemberInfoFlags::new(0),
                field_type: "ShaderShadowmapQuality",
                rust_offset: offset_of!(OutdoorLightComponentData, sun_shadow_forward_quality),
            },
            FieldInfoData {
                name: "SunPcssFilterAdaptive",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(OutdoorLightComponentData, sun_pcss_filter_adaptive),
            },
            FieldInfoData {
                name: "SunPcssInitialSampleCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(OutdoorLightComponentData, sun_pcss_initial_sample_count),
            },
            FieldInfoData {
                name: "SunPcssMaximumSampleCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(OutdoorLightComponentData, sun_pcss_maximum_sample_count),
            },
            FieldInfoData {
                name: "SunPcssFilterErrorThresholdPct",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(OutdoorLightComponentData, sun_pcss_filter_error_threshold_pct),
            },
            FieldInfoData {
                name: "SunPenumbraSize",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(OutdoorLightComponentData, sun_penumbra_size),
            },
            FieldInfoData {
                name: "SunPcssShadowFilterScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(OutdoorLightComponentData, sun_pcss_shadow_filter_scale),
            },
            FieldInfoData {
                name: "CloudShadowEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(OutdoorLightComponentData, cloud_shadow_enable),
            },
            FieldInfoData {
                name: "CloudShadowTexture",
                flags: MemberInfoFlags::new(0),
                field_type: "TextureBaseAsset",
                rust_offset: offset_of!(OutdoorLightComponentData, cloud_shadow_texture),
            },
            FieldInfoData {
                name: "CloudShadowSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(OutdoorLightComponentData, cloud_shadow_speed),
            },
            FieldInfoData {
                name: "CloudShadowSize",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(OutdoorLightComponentData, cloud_shadow_size),
            },
            FieldInfoData {
                name: "CloudShadowCoverage",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(OutdoorLightComponentData, cloud_shadow_coverage),
            },
            FieldInfoData {
                name: "CloudShadowExponent",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(OutdoorLightComponentData, cloud_shadow_exponent),
            },
            FieldInfoData {
                name: "CloudShadowIsTopDown",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(OutdoorLightComponentData, cloud_shadow_is_top_down),
            },
            FieldInfoData {
                name: "CloudShadowStartFade",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(OutdoorLightComponentData, cloud_shadow_start_fade),
            },
            FieldInfoData {
                name: "CloudShadowsFadeDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(OutdoorLightComponentData, cloud_shadows_fade_distance),
            },
            FieldInfoData {
                name: "CloudShadowHeightFadeEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(OutdoorLightComponentData, cloud_shadow_height_fade_enable),
            },
            FieldInfoData {
                name: "CloudShadowStartHeightFade",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(OutdoorLightComponentData, cloud_shadow_start_height_fade),
            },
            FieldInfoData {
                name: "CloudShadowsHeightFadeDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(OutdoorLightComponentData, cloud_shadows_height_fade_distance),
            },
            FieldInfoData {
                name: "CloudXZTranslation",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(OutdoorLightComponentData, cloud_x_z_translation),
            },
            FieldInfoData {
                name: "CloudShadowAddressingMode",
                flags: MemberInfoFlags::new(0),
                field_type: "TextureAddress",
                rust_offset: offset_of!(OutdoorLightComponentData, cloud_shadow_addressing_mode),
            },
            FieldInfoData {
                name: "CloudRadiosityEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(OutdoorLightComponentData, cloud_radiosity_enable),
            },
            FieldInfoData {
                name: "SecondaryCloudShadowTexture",
                flags: MemberInfoFlags::new(0),
                field_type: "TextureBaseAsset",
                rust_offset: offset_of!(OutdoorLightComponentData, secondary_cloud_shadow_texture),
            },
            FieldInfoData {
                name: "SecondaryCloudShadowSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(OutdoorLightComponentData, secondary_cloud_shadow_speed),
            },
            FieldInfoData {
                name: "SecondaryCloudShadowSize",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(OutdoorLightComponentData, secondary_cloud_shadow_size),
            },
            FieldInfoData {
                name: "SecondaryCloudShadowCoverage",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(OutdoorLightComponentData, secondary_cloud_shadow_coverage),
            },
            FieldInfoData {
                name: "SecondaryCloudShadowExponent",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(OutdoorLightComponentData, secondary_cloud_shadow_exponent),
            },
            FieldInfoData {
                name: "SecondaryCloudShadowIsTopDown",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(OutdoorLightComponentData, secondary_cloud_shadow_is_top_down),
            },
            FieldInfoData {
                name: "SecondaryCloudXZTranslation",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(OutdoorLightComponentData, secondary_cloud_x_z_translation),
            },
            FieldInfoData {
                name: "SecondaryCloudShadowAddressingMode",
                flags: MemberInfoFlags::new(0),
                field_type: "TextureAddress",
                rust_offset: offset_of!(OutdoorLightComponentData, secondary_cloud_shadow_addressing_mode),
            },
            FieldInfoData {
                name: "CastTerrainShadowsEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(OutdoorLightComponentData, cast_terrain_shadows_enable),
            },
            FieldInfoData {
                name: "TranslucencyAmbient",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(OutdoorLightComponentData, translucency_ambient),
            },
            FieldInfoData {
                name: "TranslucencyScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(OutdoorLightComponentData, translucency_scale),
            },
            FieldInfoData {
                name: "TranslucencyPower",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(OutdoorLightComponentData, translucency_power),
            },
            FieldInfoData {
                name: "TranslucencyDistortion",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(OutdoorLightComponentData, translucency_distortion),
            },
            FieldInfoData {
                name: "ParticleSunShadowFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(OutdoorLightComponentData, particle_sun_shadow_factor),
            },
            FieldInfoData {
                name: "ParticleSunShadowSmoothing",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(OutdoorLightComponentData, particle_sun_shadow_smoothing),
            },
            FieldInfoData {
                name: "FieldFlagOverride0",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(OutdoorLightComponentData, field_flag_override0),
            },
            FieldInfoData {
                name: "FieldFlagOverride1",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(OutdoorLightComponentData, field_flag_override1),
            },
        ],
    }),
    array_type: Some(OUTDOORLIGHTCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for OutdoorLightComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        OUTDOORLIGHTCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static OUTDOORLIGHTCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OutdoorLightComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("OutdoorLightComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct IndirectSpecularComponentData {
    pub _glacier_base: VisualEnvironmentComponentData,
    pub enabled: bool,
    pub intensity: f32,
    pub reflectance_scale: f32,
    pub probes_intensity: f32,
    pub probes_reflectance_scale: f32,
    pub field_flag_override0: u8,
}

pub trait IndirectSpecularComponentDataTrait: VisualEnvironmentComponentDataTrait {
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
    fn intensity(&self) -> &f32;
    fn intensity_mut(&mut self) -> &mut f32;
    fn reflectance_scale(&self) -> &f32;
    fn reflectance_scale_mut(&mut self) -> &mut f32;
    fn probes_intensity(&self) -> &f32;
    fn probes_intensity_mut(&mut self) -> &mut f32;
    fn probes_reflectance_scale(&self) -> &f32;
    fn probes_reflectance_scale_mut(&mut self) -> &mut f32;
    fn field_flag_override0(&self) -> &u8;
    fn field_flag_override0_mut(&mut self) -> &mut u8;
}

impl IndirectSpecularComponentDataTrait for IndirectSpecularComponentData {
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
    fn intensity(&self) -> &f32 {
        &self.intensity
    }
    fn intensity_mut(&mut self) -> &mut f32 {
        &mut self.intensity
    }
    fn reflectance_scale(&self) -> &f32 {
        &self.reflectance_scale
    }
    fn reflectance_scale_mut(&mut self) -> &mut f32 {
        &mut self.reflectance_scale
    }
    fn probes_intensity(&self) -> &f32 {
        &self.probes_intensity
    }
    fn probes_intensity_mut(&mut self) -> &mut f32 {
        &mut self.probes_intensity
    }
    fn probes_reflectance_scale(&self) -> &f32 {
        &self.probes_reflectance_scale
    }
    fn probes_reflectance_scale_mut(&mut self) -> &mut f32 {
        &mut self.probes_reflectance_scale
    }
    fn field_flag_override0(&self) -> &u8 {
        &self.field_flag_override0
    }
    fn field_flag_override0_mut(&mut self) -> &mut u8 {
        &mut self.field_flag_override0
    }
}

impl VisualEnvironmentComponentDataTrait for IndirectSpecularComponentData {
    fn property_overrides(&self) -> &Vec<String> {
        self._glacier_base.property_overrides()
    }
    fn property_overrides_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.property_overrides_mut()
    }
}

impl super::entity::ComponentDataTrait for IndirectSpecularComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for IndirectSpecularComponentData {
}

impl super::core::DataBusPeerTrait for IndirectSpecularComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for IndirectSpecularComponentData {
}

impl super::core::DataContainerTrait for IndirectSpecularComponentData {
}

pub static INDIRECTSPECULARCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IndirectSpecularComponentData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VISUALENVIRONMENTCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<IndirectSpecularComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(IndirectSpecularComponentData, enabled),
            },
            FieldInfoData {
                name: "Intensity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(IndirectSpecularComponentData, intensity),
            },
            FieldInfoData {
                name: "ReflectanceScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(IndirectSpecularComponentData, reflectance_scale),
            },
            FieldInfoData {
                name: "ProbesIntensity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(IndirectSpecularComponentData, probes_intensity),
            },
            FieldInfoData {
                name: "ProbesReflectanceScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(IndirectSpecularComponentData, probes_reflectance_scale),
            },
            FieldInfoData {
                name: "FieldFlagOverride0",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(IndirectSpecularComponentData, field_flag_override0),
            },
        ],
    }),
    array_type: Some(INDIRECTSPECULARCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for IndirectSpecularComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        INDIRECTSPECULARCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static INDIRECTSPECULARCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IndirectSpecularComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("IndirectSpecularComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VisualEnvironmentComponentData {
    pub _glacier_base: super::entity::ComponentData,
    pub property_overrides: Vec<String>,
}

pub trait VisualEnvironmentComponentDataTrait: super::entity::ComponentDataTrait {
    fn property_overrides(&self) -> &Vec<String>;
    fn property_overrides_mut(&mut self) -> &mut Vec<String>;
}

impl VisualEnvironmentComponentDataTrait for VisualEnvironmentComponentData {
    fn property_overrides(&self) -> &Vec<String> {
        &self.property_overrides
    }
    fn property_overrides_mut(&mut self) -> &mut Vec<String> {
        &mut self.property_overrides
    }
}

impl super::entity::ComponentDataTrait for VisualEnvironmentComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for VisualEnvironmentComponentData {
}

impl super::core::DataBusPeerTrait for VisualEnvironmentComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for VisualEnvironmentComponentData {
}

impl super::core::DataContainerTrait for VisualEnvironmentComponentData {
}

pub static VISUALENVIRONMENTCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VisualEnvironmentComponentData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::COMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VisualEnvironmentComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PropertyOverrides",
                flags: MemberInfoFlags::new(144),
                field_type: "CString-Array",
                rust_offset: offset_of!(VisualEnvironmentComponentData, property_overrides),
            },
        ],
    }),
    array_type: Some(VISUALENVIRONMENTCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for VisualEnvironmentComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        VISUALENVIRONMENTCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VISUALENVIRONMENTCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VisualEnvironmentComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("VisualEnvironmentComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CustomStringParam {
    pub param_name: String,
    pub param_value: String,
}

pub trait CustomStringParamTrait: TypeObject {
    fn param_name(&self) -> &String;
    fn param_name_mut(&mut self) -> &mut String;
    fn param_value(&self) -> &String;
    fn param_value_mut(&mut self) -> &mut String;
}

impl CustomStringParamTrait for CustomStringParam {
    fn param_name(&self) -> &String {
        &self.param_name
    }
    fn param_name_mut(&mut self) -> &mut String {
        &mut self.param_name
    }
    fn param_value(&self) -> &String {
        &self.param_value
    }
    fn param_value_mut(&mut self) -> &mut String {
        &mut self.param_value
    }
}

pub static CUSTOMSTRINGPARAM_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomStringParam",
    flags: MemberInfoFlags::new(73),
    module: "WorldSim",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CustomStringParam as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ParamName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(CustomStringParam, param_name),
            },
            FieldInfoData {
                name: "ParamValue",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(CustomStringParam, param_value),
            },
        ],
    }),
    array_type: Some(CUSTOMSTRINGPARAM_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CustomStringParam {
    fn type_info(&self) -> &'static TypeInfo {
        CUSTOMSTRINGPARAM_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CUSTOMSTRINGPARAM_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomStringParam-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("CustomStringParam"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum FileFrameNamingEnum {
    #[default]
    Sequential = 0,
    Absolute = 1,
}

pub static FILEFRAMENAMINGENUM_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FileFrameNamingEnum",
    flags: MemberInfoFlags::new(49429),
    module: "WorldSim",
    data: TypeInfoData::Enum,
    array_type: Some(FILEFRAMENAMINGENUM_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for FileFrameNamingEnum {
    fn type_info(&self) -> &'static TypeInfo {
        FILEFRAMENAMINGENUM_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static FILEFRAMENAMINGENUM_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FileFrameNamingEnum-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("FileFrameNamingEnum"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum LayerModeEnum {
    #[default]
    Single = 0,
    Common = 1,
    All = 2,
}

pub static LAYERMODEENUM_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LayerModeEnum",
    flags: MemberInfoFlags::new(49429),
    module: "WorldSim",
    data: TypeInfoData::Enum,
    array_type: Some(LAYERMODEENUM_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for LayerModeEnum {
    fn type_info(&self) -> &'static TypeInfo {
        LAYERMODEENUM_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static LAYERMODEENUM_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LayerModeEnum-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("LayerModeEnum"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum ImageTypeEnum {
    #[default]
    tga = 0,
    png = 1,
    png16 = 2,
    exr = 3,
}

pub static IMAGETYPEENUM_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ImageTypeEnum",
    flags: MemberInfoFlags::new(49429),
    module: "WorldSim",
    data: TypeInfoData::Enum,
    array_type: Some(IMAGETYPEENUM_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for ImageTypeEnum {
    fn type_info(&self) -> &'static TypeInfo {
        IMAGETYPEENUM_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static IMAGETYPEENUM_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ImageTypeEnum-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("ImageTypeEnum"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RenderFramesTrackData {
    pub _glacier_base: super::timeline::TimelineTrackData,
    pub keyframes: Vec<Option<Arc<Mutex<dyn RenderFramesKeyframeTrait>>>>,
    pub quick_render_name: String,
}

pub trait RenderFramesTrackDataTrait: super::timeline::TimelineTrackDataTrait {
    fn keyframes(&self) -> &Vec<Option<Arc<Mutex<dyn RenderFramesKeyframeTrait>>>>;
    fn keyframes_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn RenderFramesKeyframeTrait>>>>;
    fn quick_render_name(&self) -> &String;
    fn quick_render_name_mut(&mut self) -> &mut String;
}

impl RenderFramesTrackDataTrait for RenderFramesTrackData {
    fn keyframes(&self) -> &Vec<Option<Arc<Mutex<dyn RenderFramesKeyframeTrait>>>> {
        &self.keyframes
    }
    fn keyframes_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn RenderFramesKeyframeTrait>>>> {
        &mut self.keyframes
    }
    fn quick_render_name(&self) -> &String {
        &self.quick_render_name
    }
    fn quick_render_name_mut(&mut self) -> &mut String {
        &mut self.quick_render_name
    }
}

impl super::timeline::TimelineTrackDataTrait for RenderFramesTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for RenderFramesTrackData {
}

impl super::core::DataBusPeerTrait for RenderFramesTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for RenderFramesTrackData {
}

impl super::core::DataContainerTrait for RenderFramesTrackData {
}

pub static RENDERFRAMESTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RenderFramesTrackData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::TIMELINETRACKDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RenderFramesTrackData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Keyframes",
                flags: MemberInfoFlags::new(144),
                field_type: "RenderFramesKeyframe-Array",
                rust_offset: offset_of!(RenderFramesTrackData, keyframes),
            },
            FieldInfoData {
                name: "QuickRenderName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(RenderFramesTrackData, quick_render_name),
            },
        ],
    }),
    array_type: Some(RENDERFRAMESTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RenderFramesTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        RENDERFRAMESTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RENDERFRAMESTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RenderFramesTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("RenderFramesTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RenderFramesKeyframe {
    pub _glacier_base: super::core::DataContainer,
    pub time: f32,
    pub length: f32,
    pub render_file_name: String,
    pub render_folder_name: String,
}

pub trait RenderFramesKeyframeTrait: super::core::DataContainerTrait {
    fn time(&self) -> &f32;
    fn time_mut(&mut self) -> &mut f32;
    fn length(&self) -> &f32;
    fn length_mut(&mut self) -> &mut f32;
    fn render_file_name(&self) -> &String;
    fn render_file_name_mut(&mut self) -> &mut String;
    fn render_folder_name(&self) -> &String;
    fn render_folder_name_mut(&mut self) -> &mut String;
}

impl RenderFramesKeyframeTrait for RenderFramesKeyframe {
    fn time(&self) -> &f32 {
        &self.time
    }
    fn time_mut(&mut self) -> &mut f32 {
        &mut self.time
    }
    fn length(&self) -> &f32 {
        &self.length
    }
    fn length_mut(&mut self) -> &mut f32 {
        &mut self.length
    }
    fn render_file_name(&self) -> &String {
        &self.render_file_name
    }
    fn render_file_name_mut(&mut self) -> &mut String {
        &mut self.render_file_name
    }
    fn render_folder_name(&self) -> &String {
        &self.render_folder_name
    }
    fn render_folder_name_mut(&mut self) -> &mut String {
        &mut self.render_folder_name
    }
}

impl super::core::DataContainerTrait for RenderFramesKeyframe {
}

pub static RENDERFRAMESKEYFRAME_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RenderFramesKeyframe",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RenderFramesKeyframe as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Time",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RenderFramesKeyframe, time),
            },
            FieldInfoData {
                name: "Length",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RenderFramesKeyframe, length),
            },
            FieldInfoData {
                name: "RenderFileName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(RenderFramesKeyframe, render_file_name),
            },
            FieldInfoData {
                name: "RenderFolderName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(RenderFramesKeyframe, render_folder_name),
            },
        ],
    }),
    array_type: Some(RENDERFRAMESKEYFRAME_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RenderFramesKeyframe {
    fn type_info(&self) -> &'static TypeInfo {
        RENDERFRAMESKEYFRAME_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RENDERFRAMESKEYFRAME_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RenderFramesKeyframe-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("RenderFramesKeyframe"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SimpleVolumetricsEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub enabled: bool,
    pub fade_out_end_radius: f32,
    pub fade_out_start_radius: f32,
    pub far_fade_start_distance: f32,
    pub far_fade_end_distance: f32,
    pub use_clipping_plane: bool,
    pub clipping_plane_offset: f32,
    pub draw_pass: super::world_base::SimpleVolumetricsDrawPass,
    pub scale_to_exposure: bool,
    pub exponent: f32,
    pub emission: super::core::Vec3,
    pub emission_scale: f32,
}

pub trait SimpleVolumetricsEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
    fn fade_out_end_radius(&self) -> &f32;
    fn fade_out_end_radius_mut(&mut self) -> &mut f32;
    fn fade_out_start_radius(&self) -> &f32;
    fn fade_out_start_radius_mut(&mut self) -> &mut f32;
    fn far_fade_start_distance(&self) -> &f32;
    fn far_fade_start_distance_mut(&mut self) -> &mut f32;
    fn far_fade_end_distance(&self) -> &f32;
    fn far_fade_end_distance_mut(&mut self) -> &mut f32;
    fn use_clipping_plane(&self) -> &bool;
    fn use_clipping_plane_mut(&mut self) -> &mut bool;
    fn clipping_plane_offset(&self) -> &f32;
    fn clipping_plane_offset_mut(&mut self) -> &mut f32;
    fn draw_pass(&self) -> &super::world_base::SimpleVolumetricsDrawPass;
    fn draw_pass_mut(&mut self) -> &mut super::world_base::SimpleVolumetricsDrawPass;
    fn scale_to_exposure(&self) -> &bool;
    fn scale_to_exposure_mut(&mut self) -> &mut bool;
    fn exponent(&self) -> &f32;
    fn exponent_mut(&mut self) -> &mut f32;
    fn emission(&self) -> &super::core::Vec3;
    fn emission_mut(&mut self) -> &mut super::core::Vec3;
    fn emission_scale(&self) -> &f32;
    fn emission_scale_mut(&mut self) -> &mut f32;
}

impl SimpleVolumetricsEntityDataTrait for SimpleVolumetricsEntityData {
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
    fn fade_out_end_radius(&self) -> &f32 {
        &self.fade_out_end_radius
    }
    fn fade_out_end_radius_mut(&mut self) -> &mut f32 {
        &mut self.fade_out_end_radius
    }
    fn fade_out_start_radius(&self) -> &f32 {
        &self.fade_out_start_radius
    }
    fn fade_out_start_radius_mut(&mut self) -> &mut f32 {
        &mut self.fade_out_start_radius
    }
    fn far_fade_start_distance(&self) -> &f32 {
        &self.far_fade_start_distance
    }
    fn far_fade_start_distance_mut(&mut self) -> &mut f32 {
        &mut self.far_fade_start_distance
    }
    fn far_fade_end_distance(&self) -> &f32 {
        &self.far_fade_end_distance
    }
    fn far_fade_end_distance_mut(&mut self) -> &mut f32 {
        &mut self.far_fade_end_distance
    }
    fn use_clipping_plane(&self) -> &bool {
        &self.use_clipping_plane
    }
    fn use_clipping_plane_mut(&mut self) -> &mut bool {
        &mut self.use_clipping_plane
    }
    fn clipping_plane_offset(&self) -> &f32 {
        &self.clipping_plane_offset
    }
    fn clipping_plane_offset_mut(&mut self) -> &mut f32 {
        &mut self.clipping_plane_offset
    }
    fn draw_pass(&self) -> &super::world_base::SimpleVolumetricsDrawPass {
        &self.draw_pass
    }
    fn draw_pass_mut(&mut self) -> &mut super::world_base::SimpleVolumetricsDrawPass {
        &mut self.draw_pass
    }
    fn scale_to_exposure(&self) -> &bool {
        &self.scale_to_exposure
    }
    fn scale_to_exposure_mut(&mut self) -> &mut bool {
        &mut self.scale_to_exposure
    }
    fn exponent(&self) -> &f32 {
        &self.exponent
    }
    fn exponent_mut(&mut self) -> &mut f32 {
        &mut self.exponent
    }
    fn emission(&self) -> &super::core::Vec3 {
        &self.emission
    }
    fn emission_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.emission
    }
    fn emission_scale(&self) -> &f32 {
        &self.emission_scale
    }
    fn emission_scale_mut(&mut self) -> &mut f32 {
        &mut self.emission_scale
    }
}

impl super::entity::SpatialEntityDataTrait for SimpleVolumetricsEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for SimpleVolumetricsEntityData {
}

impl super::entity::GameObjectDataTrait for SimpleVolumetricsEntityData {
}

impl super::core::DataBusPeerTrait for SimpleVolumetricsEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SimpleVolumetricsEntityData {
}

impl super::core::DataContainerTrait for SimpleVolumetricsEntityData {
}

pub static SIMPLEVOLUMETRICSENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleVolumetricsEntityData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SimpleVolumetricsEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SimpleVolumetricsEntityData, enabled),
            },
            FieldInfoData {
                name: "FadeOutEndRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SimpleVolumetricsEntityData, fade_out_end_radius),
            },
            FieldInfoData {
                name: "FadeOutStartRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SimpleVolumetricsEntityData, fade_out_start_radius),
            },
            FieldInfoData {
                name: "FarFadeStartDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SimpleVolumetricsEntityData, far_fade_start_distance),
            },
            FieldInfoData {
                name: "FarFadeEndDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SimpleVolumetricsEntityData, far_fade_end_distance),
            },
            FieldInfoData {
                name: "UseClippingPlane",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SimpleVolumetricsEntityData, use_clipping_plane),
            },
            FieldInfoData {
                name: "ClippingPlaneOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SimpleVolumetricsEntityData, clipping_plane_offset),
            },
            FieldInfoData {
                name: "DrawPass",
                flags: MemberInfoFlags::new(0),
                field_type: "SimpleVolumetricsDrawPass",
                rust_offset: offset_of!(SimpleVolumetricsEntityData, draw_pass),
            },
            FieldInfoData {
                name: "ScaleToExposure",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SimpleVolumetricsEntityData, scale_to_exposure),
            },
            FieldInfoData {
                name: "Exponent",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SimpleVolumetricsEntityData, exponent),
            },
            FieldInfoData {
                name: "Emission",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SimpleVolumetricsEntityData, emission),
            },
            FieldInfoData {
                name: "EmissionScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SimpleVolumetricsEntityData, emission_scale),
            },
        ],
    }),
    array_type: Some(SIMPLEVOLUMETRICSENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SimpleVolumetricsEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SIMPLEVOLUMETRICSENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SIMPLEVOLUMETRICSENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleVolumetricsEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("SimpleVolumetricsEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ScreenshotCaptureEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub file_name: String,
    pub sub_folder: String,
    pub format: super::render_base::ScreenshotFormat,
    pub layer_mode: super::render_base::ScreenshotLayerMode,
    pub resolution_multiplier: i32,
    pub antialias_multiplier: i32,
    pub enable_alpha: bool,
    pub surround_capture: bool,
    pub force_auto_render: bool,
    pub use_native_file_system: bool,
    pub starting_x_pos: i32,
    pub starting_y_pos: i32,
    pub width: i32,
    pub height: i32,
    pub delay_frames: i32,
    pub upload_to_juice: bool,
    pub upload_to_ensemble_whiteboard: bool,
    pub overwrite: bool,
}

pub trait ScreenshotCaptureEntityDataTrait: super::entity::EntityDataTrait {
    fn file_name(&self) -> &String;
    fn file_name_mut(&mut self) -> &mut String;
    fn sub_folder(&self) -> &String;
    fn sub_folder_mut(&mut self) -> &mut String;
    fn format(&self) -> &super::render_base::ScreenshotFormat;
    fn format_mut(&mut self) -> &mut super::render_base::ScreenshotFormat;
    fn layer_mode(&self) -> &super::render_base::ScreenshotLayerMode;
    fn layer_mode_mut(&mut self) -> &mut super::render_base::ScreenshotLayerMode;
    fn resolution_multiplier(&self) -> &i32;
    fn resolution_multiplier_mut(&mut self) -> &mut i32;
    fn antialias_multiplier(&self) -> &i32;
    fn antialias_multiplier_mut(&mut self) -> &mut i32;
    fn enable_alpha(&self) -> &bool;
    fn enable_alpha_mut(&mut self) -> &mut bool;
    fn surround_capture(&self) -> &bool;
    fn surround_capture_mut(&mut self) -> &mut bool;
    fn force_auto_render(&self) -> &bool;
    fn force_auto_render_mut(&mut self) -> &mut bool;
    fn use_native_file_system(&self) -> &bool;
    fn use_native_file_system_mut(&mut self) -> &mut bool;
    fn starting_x_pos(&self) -> &i32;
    fn starting_x_pos_mut(&mut self) -> &mut i32;
    fn starting_y_pos(&self) -> &i32;
    fn starting_y_pos_mut(&mut self) -> &mut i32;
    fn width(&self) -> &i32;
    fn width_mut(&mut self) -> &mut i32;
    fn height(&self) -> &i32;
    fn height_mut(&mut self) -> &mut i32;
    fn delay_frames(&self) -> &i32;
    fn delay_frames_mut(&mut self) -> &mut i32;
    fn upload_to_juice(&self) -> &bool;
    fn upload_to_juice_mut(&mut self) -> &mut bool;
    fn upload_to_ensemble_whiteboard(&self) -> &bool;
    fn upload_to_ensemble_whiteboard_mut(&mut self) -> &mut bool;
    fn overwrite(&self) -> &bool;
    fn overwrite_mut(&mut self) -> &mut bool;
}

impl ScreenshotCaptureEntityDataTrait for ScreenshotCaptureEntityData {
    fn file_name(&self) -> &String {
        &self.file_name
    }
    fn file_name_mut(&mut self) -> &mut String {
        &mut self.file_name
    }
    fn sub_folder(&self) -> &String {
        &self.sub_folder
    }
    fn sub_folder_mut(&mut self) -> &mut String {
        &mut self.sub_folder
    }
    fn format(&self) -> &super::render_base::ScreenshotFormat {
        &self.format
    }
    fn format_mut(&mut self) -> &mut super::render_base::ScreenshotFormat {
        &mut self.format
    }
    fn layer_mode(&self) -> &super::render_base::ScreenshotLayerMode {
        &self.layer_mode
    }
    fn layer_mode_mut(&mut self) -> &mut super::render_base::ScreenshotLayerMode {
        &mut self.layer_mode
    }
    fn resolution_multiplier(&self) -> &i32 {
        &self.resolution_multiplier
    }
    fn resolution_multiplier_mut(&mut self) -> &mut i32 {
        &mut self.resolution_multiplier
    }
    fn antialias_multiplier(&self) -> &i32 {
        &self.antialias_multiplier
    }
    fn antialias_multiplier_mut(&mut self) -> &mut i32 {
        &mut self.antialias_multiplier
    }
    fn enable_alpha(&self) -> &bool {
        &self.enable_alpha
    }
    fn enable_alpha_mut(&mut self) -> &mut bool {
        &mut self.enable_alpha
    }
    fn surround_capture(&self) -> &bool {
        &self.surround_capture
    }
    fn surround_capture_mut(&mut self) -> &mut bool {
        &mut self.surround_capture
    }
    fn force_auto_render(&self) -> &bool {
        &self.force_auto_render
    }
    fn force_auto_render_mut(&mut self) -> &mut bool {
        &mut self.force_auto_render
    }
    fn use_native_file_system(&self) -> &bool {
        &self.use_native_file_system
    }
    fn use_native_file_system_mut(&mut self) -> &mut bool {
        &mut self.use_native_file_system
    }
    fn starting_x_pos(&self) -> &i32 {
        &self.starting_x_pos
    }
    fn starting_x_pos_mut(&mut self) -> &mut i32 {
        &mut self.starting_x_pos
    }
    fn starting_y_pos(&self) -> &i32 {
        &self.starting_y_pos
    }
    fn starting_y_pos_mut(&mut self) -> &mut i32 {
        &mut self.starting_y_pos
    }
    fn width(&self) -> &i32 {
        &self.width
    }
    fn width_mut(&mut self) -> &mut i32 {
        &mut self.width
    }
    fn height(&self) -> &i32 {
        &self.height
    }
    fn height_mut(&mut self) -> &mut i32 {
        &mut self.height
    }
    fn delay_frames(&self) -> &i32 {
        &self.delay_frames
    }
    fn delay_frames_mut(&mut self) -> &mut i32 {
        &mut self.delay_frames
    }
    fn upload_to_juice(&self) -> &bool {
        &self.upload_to_juice
    }
    fn upload_to_juice_mut(&mut self) -> &mut bool {
        &mut self.upload_to_juice
    }
    fn upload_to_ensemble_whiteboard(&self) -> &bool {
        &self.upload_to_ensemble_whiteboard
    }
    fn upload_to_ensemble_whiteboard_mut(&mut self) -> &mut bool {
        &mut self.upload_to_ensemble_whiteboard
    }
    fn overwrite(&self) -> &bool {
        &self.overwrite
    }
    fn overwrite_mut(&mut self) -> &mut bool {
        &mut self.overwrite
    }
}

impl super::entity::EntityDataTrait for ScreenshotCaptureEntityData {
}

impl super::entity::GameObjectDataTrait for ScreenshotCaptureEntityData {
}

impl super::core::DataBusPeerTrait for ScreenshotCaptureEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ScreenshotCaptureEntityData {
}

impl super::core::DataContainerTrait for ScreenshotCaptureEntityData {
}

pub static SCREENSHOTCAPTUREENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScreenshotCaptureEntityData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ScreenshotCaptureEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "FileName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ScreenshotCaptureEntityData, file_name),
            },
            FieldInfoData {
                name: "SubFolder",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ScreenshotCaptureEntityData, sub_folder),
            },
            FieldInfoData {
                name: "Format",
                flags: MemberInfoFlags::new(0),
                field_type: "ScreenshotFormat",
                rust_offset: offset_of!(ScreenshotCaptureEntityData, format),
            },
            FieldInfoData {
                name: "LayerMode",
                flags: MemberInfoFlags::new(0),
                field_type: "ScreenshotLayerMode",
                rust_offset: offset_of!(ScreenshotCaptureEntityData, layer_mode),
            },
            FieldInfoData {
                name: "ResolutionMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ScreenshotCaptureEntityData, resolution_multiplier),
            },
            FieldInfoData {
                name: "AntialiasMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ScreenshotCaptureEntityData, antialias_multiplier),
            },
            FieldInfoData {
                name: "EnableAlpha",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ScreenshotCaptureEntityData, enable_alpha),
            },
            FieldInfoData {
                name: "SurroundCapture",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ScreenshotCaptureEntityData, surround_capture),
            },
            FieldInfoData {
                name: "ForceAutoRender",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ScreenshotCaptureEntityData, force_auto_render),
            },
            FieldInfoData {
                name: "UseNativeFileSystem",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ScreenshotCaptureEntityData, use_native_file_system),
            },
            FieldInfoData {
                name: "StartingXPos",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ScreenshotCaptureEntityData, starting_x_pos),
            },
            FieldInfoData {
                name: "StartingYPos",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ScreenshotCaptureEntityData, starting_y_pos),
            },
            FieldInfoData {
                name: "Width",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ScreenshotCaptureEntityData, width),
            },
            FieldInfoData {
                name: "Height",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ScreenshotCaptureEntityData, height),
            },
            FieldInfoData {
                name: "DelayFrames",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ScreenshotCaptureEntityData, delay_frames),
            },
            FieldInfoData {
                name: "UploadToJuice",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ScreenshotCaptureEntityData, upload_to_juice),
            },
            FieldInfoData {
                name: "UploadToEnsembleWhiteboard",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ScreenshotCaptureEntityData, upload_to_ensemble_whiteboard),
            },
            FieldInfoData {
                name: "Overwrite",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ScreenshotCaptureEntityData, overwrite),
            },
        ],
    }),
    array_type: Some(SCREENSHOTCAPTUREENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ScreenshotCaptureEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SCREENSHOTCAPTUREENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SCREENSHOTCAPTUREENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScreenshotCaptureEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("ScreenshotCaptureEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct OccluderVolumeEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub occluder_high_priority: bool,
    pub occluder_is_conservative: bool,
    pub coverage_value: f32,
    pub visible: bool,
}

pub trait OccluderVolumeEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn occluder_high_priority(&self) -> &bool;
    fn occluder_high_priority_mut(&mut self) -> &mut bool;
    fn occluder_is_conservative(&self) -> &bool;
    fn occluder_is_conservative_mut(&mut self) -> &mut bool;
    fn coverage_value(&self) -> &f32;
    fn coverage_value_mut(&mut self) -> &mut f32;
    fn visible(&self) -> &bool;
    fn visible_mut(&mut self) -> &mut bool;
}

impl OccluderVolumeEntityDataTrait for OccluderVolumeEntityData {
    fn occluder_high_priority(&self) -> &bool {
        &self.occluder_high_priority
    }
    fn occluder_high_priority_mut(&mut self) -> &mut bool {
        &mut self.occluder_high_priority
    }
    fn occluder_is_conservative(&self) -> &bool {
        &self.occluder_is_conservative
    }
    fn occluder_is_conservative_mut(&mut self) -> &mut bool {
        &mut self.occluder_is_conservative
    }
    fn coverage_value(&self) -> &f32 {
        &self.coverage_value
    }
    fn coverage_value_mut(&mut self) -> &mut f32 {
        &mut self.coverage_value
    }
    fn visible(&self) -> &bool {
        &self.visible
    }
    fn visible_mut(&mut self) -> &mut bool {
        &mut self.visible
    }
}

impl super::entity::SpatialEntityDataTrait for OccluderVolumeEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for OccluderVolumeEntityData {
}

impl super::entity::GameObjectDataTrait for OccluderVolumeEntityData {
}

impl super::core::DataBusPeerTrait for OccluderVolumeEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for OccluderVolumeEntityData {
}

impl super::core::DataContainerTrait for OccluderVolumeEntityData {
}

pub static OCCLUDERVOLUMEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OccluderVolumeEntityData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<OccluderVolumeEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "OccluderHighPriority",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(OccluderVolumeEntityData, occluder_high_priority),
            },
            FieldInfoData {
                name: "OccluderIsConservative",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(OccluderVolumeEntityData, occluder_is_conservative),
            },
            FieldInfoData {
                name: "CoverageValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(OccluderVolumeEntityData, coverage_value),
            },
            FieldInfoData {
                name: "Visible",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(OccluderVolumeEntityData, visible),
            },
        ],
    }),
    array_type: Some(OCCLUDERVOLUMEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for OccluderVolumeEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        OCCLUDERVOLUMEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static OCCLUDERVOLUMEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OccluderVolumeEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("OccluderVolumeEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct OccluderPlaneEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub occluder_high_priority: bool,
    pub occluder_is_conservative: bool,
    pub doubled_sided: bool,
    pub coverage_value: f32,
    pub visible: bool,
}

pub trait OccluderPlaneEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn occluder_high_priority(&self) -> &bool;
    fn occluder_high_priority_mut(&mut self) -> &mut bool;
    fn occluder_is_conservative(&self) -> &bool;
    fn occluder_is_conservative_mut(&mut self) -> &mut bool;
    fn doubled_sided(&self) -> &bool;
    fn doubled_sided_mut(&mut self) -> &mut bool;
    fn coverage_value(&self) -> &f32;
    fn coverage_value_mut(&mut self) -> &mut f32;
    fn visible(&self) -> &bool;
    fn visible_mut(&mut self) -> &mut bool;
}

impl OccluderPlaneEntityDataTrait for OccluderPlaneEntityData {
    fn occluder_high_priority(&self) -> &bool {
        &self.occluder_high_priority
    }
    fn occluder_high_priority_mut(&mut self) -> &mut bool {
        &mut self.occluder_high_priority
    }
    fn occluder_is_conservative(&self) -> &bool {
        &self.occluder_is_conservative
    }
    fn occluder_is_conservative_mut(&mut self) -> &mut bool {
        &mut self.occluder_is_conservative
    }
    fn doubled_sided(&self) -> &bool {
        &self.doubled_sided
    }
    fn doubled_sided_mut(&mut self) -> &mut bool {
        &mut self.doubled_sided
    }
    fn coverage_value(&self) -> &f32 {
        &self.coverage_value
    }
    fn coverage_value_mut(&mut self) -> &mut f32 {
        &mut self.coverage_value
    }
    fn visible(&self) -> &bool {
        &self.visible
    }
    fn visible_mut(&mut self) -> &mut bool {
        &mut self.visible
    }
}

impl super::entity::SpatialEntityDataTrait for OccluderPlaneEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for OccluderPlaneEntityData {
}

impl super::entity::GameObjectDataTrait for OccluderPlaneEntityData {
}

impl super::core::DataBusPeerTrait for OccluderPlaneEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for OccluderPlaneEntityData {
}

impl super::core::DataContainerTrait for OccluderPlaneEntityData {
}

pub static OCCLUDERPLANEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OccluderPlaneEntityData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<OccluderPlaneEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "OccluderHighPriority",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(OccluderPlaneEntityData, occluder_high_priority),
            },
            FieldInfoData {
                name: "OccluderIsConservative",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(OccluderPlaneEntityData, occluder_is_conservative),
            },
            FieldInfoData {
                name: "DoubledSided",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(OccluderPlaneEntityData, doubled_sided),
            },
            FieldInfoData {
                name: "CoverageValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(OccluderPlaneEntityData, coverage_value),
            },
            FieldInfoData {
                name: "Visible",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(OccluderPlaneEntityData, visible),
            },
        ],
    }),
    array_type: Some(OCCLUDERPLANEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for OccluderPlaneEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        OCCLUDERPLANEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static OCCLUDERPLANEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OccluderPlaneEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("OccluderPlaneEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct OccluderMeshEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub mesh: Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>>,
    pub visible: bool,
}

pub trait OccluderMeshEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn mesh(&self) -> &Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>>;
    fn mesh_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>>;
    fn visible(&self) -> &bool;
    fn visible_mut(&mut self) -> &mut bool;
}

impl OccluderMeshEntityDataTrait for OccluderMeshEntityData {
    fn mesh(&self) -> &Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        &self.mesh
    }
    fn mesh_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        &mut self.mesh
    }
    fn visible(&self) -> &bool {
        &self.visible
    }
    fn visible_mut(&mut self) -> &mut bool {
        &mut self.visible
    }
}

impl super::entity::SpatialEntityDataTrait for OccluderMeshEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for OccluderMeshEntityData {
}

impl super::entity::GameObjectDataTrait for OccluderMeshEntityData {
}

impl super::core::DataBusPeerTrait for OccluderMeshEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for OccluderMeshEntityData {
}

impl super::core::DataContainerTrait for OccluderMeshEntityData {
}

pub static OCCLUDERMESHENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OccluderMeshEntityData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<OccluderMeshEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Mesh",
                flags: MemberInfoFlags::new(0),
                field_type: "MeshBaseAsset",
                rust_offset: offset_of!(OccluderMeshEntityData, mesh),
            },
            FieldInfoData {
                name: "Visible",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(OccluderMeshEntityData, visible),
            },
        ],
    }),
    array_type: Some(OCCLUDERMESHENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for OccluderMeshEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        OCCLUDERMESHENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static OCCLUDERMESHENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OccluderMeshEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("OccluderMeshEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VisibleAreaEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub realm: super::core::Realm,
    pub hide_treshold: u32,
    pub visual_cull_screen_area: f32,
}

pub trait VisibleAreaEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn hide_treshold(&self) -> &u32;
    fn hide_treshold_mut(&mut self) -> &mut u32;
    fn visual_cull_screen_area(&self) -> &f32;
    fn visual_cull_screen_area_mut(&mut self) -> &mut f32;
}

impl VisibleAreaEntityDataTrait for VisibleAreaEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn hide_treshold(&self) -> &u32 {
        &self.hide_treshold
    }
    fn hide_treshold_mut(&mut self) -> &mut u32 {
        &mut self.hide_treshold
    }
    fn visual_cull_screen_area(&self) -> &f32 {
        &self.visual_cull_screen_area
    }
    fn visual_cull_screen_area_mut(&mut self) -> &mut f32 {
        &mut self.visual_cull_screen_area
    }
}

impl super::entity::SpatialEntityDataTrait for VisibleAreaEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for VisibleAreaEntityData {
}

impl super::entity::GameObjectDataTrait for VisibleAreaEntityData {
}

impl super::core::DataBusPeerTrait for VisibleAreaEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for VisibleAreaEntityData {
}

impl super::core::DataContainerTrait for VisibleAreaEntityData {
}

pub static VISIBLEAREAENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VisibleAreaEntityData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VisibleAreaEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(VisibleAreaEntityData, realm),
            },
            FieldInfoData {
                name: "HideTreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(VisibleAreaEntityData, hide_treshold),
            },
            FieldInfoData {
                name: "VisualCullScreenArea",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VisibleAreaEntityData, visual_cull_screen_area),
            },
        ],
    }),
    array_type: Some(VISIBLEAREAENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VisibleAreaEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VISIBLEAREAENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VISIBLEAREAENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VisibleAreaEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("VisibleAreaEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlanarReflectionLocatorEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub enable: bool,
}

pub trait PlanarReflectionLocatorEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn enable(&self) -> &bool;
    fn enable_mut(&mut self) -> &mut bool;
}

impl PlanarReflectionLocatorEntityDataTrait for PlanarReflectionLocatorEntityData {
    fn enable(&self) -> &bool {
        &self.enable
    }
    fn enable_mut(&mut self) -> &mut bool {
        &mut self.enable
    }
}

impl super::entity::SpatialEntityDataTrait for PlanarReflectionLocatorEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for PlanarReflectionLocatorEntityData {
}

impl super::entity::GameObjectDataTrait for PlanarReflectionLocatorEntityData {
}

impl super::core::DataBusPeerTrait for PlanarReflectionLocatorEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PlanarReflectionLocatorEntityData {
}

impl super::core::DataContainerTrait for PlanarReflectionLocatorEntityData {
}

pub static PLANARREFLECTIONLOCATORENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlanarReflectionLocatorEntityData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlanarReflectionLocatorEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlanarReflectionLocatorEntityData, enable),
            },
        ],
    }),
    array_type: Some(PLANARREFLECTIONLOCATORENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PlanarReflectionLocatorEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PLANARREFLECTIONLOCATORENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PLANARREFLECTIONLOCATORENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlanarReflectionLocatorEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("PlanarReflectionLocatorEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LightProbeVolumeData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub xres: u32,
    pub yres: u32,
    pub zres: u32,
    pub blend_distance: f32,
    pub priority: u32,
    pub enable: bool,
}

pub trait LightProbeVolumeDataTrait: super::entity::SpatialEntityDataTrait {
    fn xres(&self) -> &u32;
    fn xres_mut(&mut self) -> &mut u32;
    fn yres(&self) -> &u32;
    fn yres_mut(&mut self) -> &mut u32;
    fn zres(&self) -> &u32;
    fn zres_mut(&mut self) -> &mut u32;
    fn blend_distance(&self) -> &f32;
    fn blend_distance_mut(&mut self) -> &mut f32;
    fn priority(&self) -> &u32;
    fn priority_mut(&mut self) -> &mut u32;
    fn enable(&self) -> &bool;
    fn enable_mut(&mut self) -> &mut bool;
}

impl LightProbeVolumeDataTrait for LightProbeVolumeData {
    fn xres(&self) -> &u32 {
        &self.xres
    }
    fn xres_mut(&mut self) -> &mut u32 {
        &mut self.xres
    }
    fn yres(&self) -> &u32 {
        &self.yres
    }
    fn yres_mut(&mut self) -> &mut u32 {
        &mut self.yres
    }
    fn zres(&self) -> &u32 {
        &self.zres
    }
    fn zres_mut(&mut self) -> &mut u32 {
        &mut self.zres
    }
    fn blend_distance(&self) -> &f32 {
        &self.blend_distance
    }
    fn blend_distance_mut(&mut self) -> &mut f32 {
        &mut self.blend_distance
    }
    fn priority(&self) -> &u32 {
        &self.priority
    }
    fn priority_mut(&mut self) -> &mut u32 {
        &mut self.priority
    }
    fn enable(&self) -> &bool {
        &self.enable
    }
    fn enable_mut(&mut self) -> &mut bool {
        &mut self.enable
    }
}

impl super::entity::SpatialEntityDataTrait for LightProbeVolumeData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for LightProbeVolumeData {
}

impl super::entity::GameObjectDataTrait for LightProbeVolumeData {
}

impl super::core::DataBusPeerTrait for LightProbeVolumeData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for LightProbeVolumeData {
}

impl super::core::DataContainerTrait for LightProbeVolumeData {
}

pub static LIGHTPROBEVOLUMEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LightProbeVolumeData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LightProbeVolumeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Xres",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(LightProbeVolumeData, xres),
            },
            FieldInfoData {
                name: "Yres",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(LightProbeVolumeData, yres),
            },
            FieldInfoData {
                name: "Zres",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(LightProbeVolumeData, zres),
            },
            FieldInfoData {
                name: "BlendDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LightProbeVolumeData, blend_distance),
            },
            FieldInfoData {
                name: "Priority",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(LightProbeVolumeData, priority),
            },
            FieldInfoData {
                name: "Enable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LightProbeVolumeData, enable),
            },
        ],
    }),
    array_type: Some(LIGHTPROBEVOLUMEDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for LightProbeVolumeData {
    fn type_info(&self) -> &'static TypeInfo {
        LIGHTPROBEVOLUMEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LIGHTPROBEVOLUMEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LightProbeVolumeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("LightProbeVolumeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct StaticEnlightenEntityData {
    pub _glacier_base: EnlightenEntityData,
    pub priority: i32,
    pub enlighten_data: Option<Arc<Mutex<dyn super::render_base::StaticEnlightenBaseAssetTrait>>>,
    pub dynamic_enlighten_data: Option<Arc<Mutex<dyn super::render_base::EnlightenBaseAssetTrait>>>,
    pub object_layers: u16,
    pub flux_auto_bake: bool,
    pub enable: bool,
    pub mixed: bool,
}

pub trait StaticEnlightenEntityDataTrait: EnlightenEntityDataTrait {
    fn priority(&self) -> &i32;
    fn priority_mut(&mut self) -> &mut i32;
    fn enlighten_data(&self) -> &Option<Arc<Mutex<dyn super::render_base::StaticEnlightenBaseAssetTrait>>>;
    fn enlighten_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::StaticEnlightenBaseAssetTrait>>>;
    fn dynamic_enlighten_data(&self) -> &Option<Arc<Mutex<dyn super::render_base::EnlightenBaseAssetTrait>>>;
    fn dynamic_enlighten_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::EnlightenBaseAssetTrait>>>;
    fn object_layers(&self) -> &u16;
    fn object_layers_mut(&mut self) -> &mut u16;
    fn flux_auto_bake(&self) -> &bool;
    fn flux_auto_bake_mut(&mut self) -> &mut bool;
    fn enable(&self) -> &bool;
    fn enable_mut(&mut self) -> &mut bool;
    fn mixed(&self) -> &bool;
    fn mixed_mut(&mut self) -> &mut bool;
}

impl StaticEnlightenEntityDataTrait for StaticEnlightenEntityData {
    fn priority(&self) -> &i32 {
        &self.priority
    }
    fn priority_mut(&mut self) -> &mut i32 {
        &mut self.priority
    }
    fn enlighten_data(&self) -> &Option<Arc<Mutex<dyn super::render_base::StaticEnlightenBaseAssetTrait>>> {
        &self.enlighten_data
    }
    fn enlighten_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::StaticEnlightenBaseAssetTrait>>> {
        &mut self.enlighten_data
    }
    fn dynamic_enlighten_data(&self) -> &Option<Arc<Mutex<dyn super::render_base::EnlightenBaseAssetTrait>>> {
        &self.dynamic_enlighten_data
    }
    fn dynamic_enlighten_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::EnlightenBaseAssetTrait>>> {
        &mut self.dynamic_enlighten_data
    }
    fn object_layers(&self) -> &u16 {
        &self.object_layers
    }
    fn object_layers_mut(&mut self) -> &mut u16 {
        &mut self.object_layers
    }
    fn flux_auto_bake(&self) -> &bool {
        &self.flux_auto_bake
    }
    fn flux_auto_bake_mut(&mut self) -> &mut bool {
        &mut self.flux_auto_bake
    }
    fn enable(&self) -> &bool {
        &self.enable
    }
    fn enable_mut(&mut self) -> &mut bool {
        &mut self.enable
    }
    fn mixed(&self) -> &bool {
        &self.mixed
    }
    fn mixed_mut(&mut self) -> &mut bool {
        &mut self.mixed
    }
}

impl EnlightenEntityDataTrait for StaticEnlightenEntityData {
}

impl super::entity::EntityDataTrait for StaticEnlightenEntityData {
}

impl super::entity::GameObjectDataTrait for StaticEnlightenEntityData {
}

impl super::core::DataBusPeerTrait for StaticEnlightenEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for StaticEnlightenEntityData {
}

impl super::core::DataContainerTrait for StaticEnlightenEntityData {
}

pub static STATICENLIGHTENENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StaticEnlightenEntityData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENLIGHTENENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StaticEnlightenEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Priority",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(StaticEnlightenEntityData, priority),
            },
            FieldInfoData {
                name: "EnlightenData",
                flags: MemberInfoFlags::new(0),
                field_type: "StaticEnlightenBaseAsset",
                rust_offset: offset_of!(StaticEnlightenEntityData, enlighten_data),
            },
            FieldInfoData {
                name: "DynamicEnlightenData",
                flags: MemberInfoFlags::new(0),
                field_type: "EnlightenBaseAsset",
                rust_offset: offset_of!(StaticEnlightenEntityData, dynamic_enlighten_data),
            },
            FieldInfoData {
                name: "ObjectLayers",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint16",
                rust_offset: offset_of!(StaticEnlightenEntityData, object_layers),
            },
            FieldInfoData {
                name: "FluxAutoBake",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(StaticEnlightenEntityData, flux_auto_bake),
            },
            FieldInfoData {
                name: "Enable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(StaticEnlightenEntityData, enable),
            },
            FieldInfoData {
                name: "Mixed",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(StaticEnlightenEntityData, mixed),
            },
        ],
    }),
    array_type: Some(STATICENLIGHTENENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for StaticEnlightenEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        STATICENLIGHTENENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static STATICENLIGHTENENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StaticEnlightenEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("StaticEnlightenEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DynamicEnlightenEntityData {
    pub _glacier_base: EnlightenEntityData,
    pub priority: i32,
    pub enlighten_data: Option<Arc<Mutex<dyn super::render_base::EnlightenBaseAssetTrait>>>,
    pub object_layers: u16,
    pub enable: bool,
    pub database_version: i32,
}

pub trait DynamicEnlightenEntityDataTrait: EnlightenEntityDataTrait {
    fn priority(&self) -> &i32;
    fn priority_mut(&mut self) -> &mut i32;
    fn enlighten_data(&self) -> &Option<Arc<Mutex<dyn super::render_base::EnlightenBaseAssetTrait>>>;
    fn enlighten_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::EnlightenBaseAssetTrait>>>;
    fn object_layers(&self) -> &u16;
    fn object_layers_mut(&mut self) -> &mut u16;
    fn enable(&self) -> &bool;
    fn enable_mut(&mut self) -> &mut bool;
    fn database_version(&self) -> &i32;
    fn database_version_mut(&mut self) -> &mut i32;
}

impl DynamicEnlightenEntityDataTrait for DynamicEnlightenEntityData {
    fn priority(&self) -> &i32 {
        &self.priority
    }
    fn priority_mut(&mut self) -> &mut i32 {
        &mut self.priority
    }
    fn enlighten_data(&self) -> &Option<Arc<Mutex<dyn super::render_base::EnlightenBaseAssetTrait>>> {
        &self.enlighten_data
    }
    fn enlighten_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::EnlightenBaseAssetTrait>>> {
        &mut self.enlighten_data
    }
    fn object_layers(&self) -> &u16 {
        &self.object_layers
    }
    fn object_layers_mut(&mut self) -> &mut u16 {
        &mut self.object_layers
    }
    fn enable(&self) -> &bool {
        &self.enable
    }
    fn enable_mut(&mut self) -> &mut bool {
        &mut self.enable
    }
    fn database_version(&self) -> &i32 {
        &self.database_version
    }
    fn database_version_mut(&mut self) -> &mut i32 {
        &mut self.database_version
    }
}

impl EnlightenEntityDataTrait for DynamicEnlightenEntityData {
}

impl super::entity::EntityDataTrait for DynamicEnlightenEntityData {
}

impl super::entity::GameObjectDataTrait for DynamicEnlightenEntityData {
}

impl super::core::DataBusPeerTrait for DynamicEnlightenEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for DynamicEnlightenEntityData {
}

impl super::core::DataContainerTrait for DynamicEnlightenEntityData {
}

pub static DYNAMICENLIGHTENENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicEnlightenEntityData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENLIGHTENENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DynamicEnlightenEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Priority",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(DynamicEnlightenEntityData, priority),
            },
            FieldInfoData {
                name: "EnlightenData",
                flags: MemberInfoFlags::new(0),
                field_type: "EnlightenBaseAsset",
                rust_offset: offset_of!(DynamicEnlightenEntityData, enlighten_data),
            },
            FieldInfoData {
                name: "ObjectLayers",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint16",
                rust_offset: offset_of!(DynamicEnlightenEntityData, object_layers),
            },
            FieldInfoData {
                name: "Enable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DynamicEnlightenEntityData, enable),
            },
            FieldInfoData {
                name: "DatabaseVersion",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(DynamicEnlightenEntityData, database_version),
            },
        ],
    }),
    array_type: Some(DYNAMICENLIGHTENENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DynamicEnlightenEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        DYNAMICENLIGHTENENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DYNAMICENLIGHTENENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicEnlightenEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("DynamicEnlightenEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EnlightenEntityData {
    pub _glacier_base: super::entity::EntityData,
}

pub trait EnlightenEntityDataTrait: super::entity::EntityDataTrait {
}

impl EnlightenEntityDataTrait for EnlightenEntityData {
}

impl super::entity::EntityDataTrait for EnlightenEntityData {
}

impl super::entity::GameObjectDataTrait for EnlightenEntityData {
}

impl super::core::DataBusPeerTrait for EnlightenEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for EnlightenEntityData {
}

impl super::core::DataContainerTrait for EnlightenEntityData {
}

pub static ENLIGHTENENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnlightenEntityData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EnlightenEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(ENLIGHTENENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EnlightenEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        ENLIGHTENENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ENLIGHTENENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnlightenEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("EnlightenEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RadiosityModifierEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub bounce_scale: f32,
    pub sun_scale: f32,
}

pub trait RadiosityModifierEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn bounce_scale(&self) -> &f32;
    fn bounce_scale_mut(&mut self) -> &mut f32;
    fn sun_scale(&self) -> &f32;
    fn sun_scale_mut(&mut self) -> &mut f32;
}

impl RadiosityModifierEntityDataTrait for RadiosityModifierEntityData {
    fn bounce_scale(&self) -> &f32 {
        &self.bounce_scale
    }
    fn bounce_scale_mut(&mut self) -> &mut f32 {
        &mut self.bounce_scale
    }
    fn sun_scale(&self) -> &f32 {
        &self.sun_scale
    }
    fn sun_scale_mut(&mut self) -> &mut f32 {
        &mut self.sun_scale
    }
}

impl super::entity::SpatialEntityDataTrait for RadiosityModifierEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for RadiosityModifierEntityData {
}

impl super::entity::GameObjectDataTrait for RadiosityModifierEntityData {
}

impl super::core::DataBusPeerTrait for RadiosityModifierEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for RadiosityModifierEntityData {
}

impl super::core::DataContainerTrait for RadiosityModifierEntityData {
}

pub static RADIOSITYMODIFIERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RadiosityModifierEntityData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RadiosityModifierEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "BounceScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RadiosityModifierEntityData, bounce_scale),
            },
            FieldInfoData {
                name: "SunScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RadiosityModifierEntityData, sun_scale),
            },
        ],
    }),
    array_type: Some(RADIOSITYMODIFIERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for RadiosityModifierEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        RADIOSITYMODIFIERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RADIOSITYMODIFIERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RadiosityModifierEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("RadiosityModifierEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RadiosityMaterialOpacityTriggerEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub material_src_color: super::core::Vec3,
    pub material_src_opacity: f32,
    pub opacity_on_transparency: f32,
    pub opacity_on_color_multiplier: f32,
    pub opacity_off_transparency: f32,
    pub opacity_off_color_multiplier: f32,
    pub material_guid: glacier_util::guid::Guid,
    pub opacity: f32,
    pub color: super::core::Vec3,
}

pub trait RadiosityMaterialOpacityTriggerEntityDataTrait: super::entity::EntityDataTrait {
    fn material_src_color(&self) -> &super::core::Vec3;
    fn material_src_color_mut(&mut self) -> &mut super::core::Vec3;
    fn material_src_opacity(&self) -> &f32;
    fn material_src_opacity_mut(&mut self) -> &mut f32;
    fn opacity_on_transparency(&self) -> &f32;
    fn opacity_on_transparency_mut(&mut self) -> &mut f32;
    fn opacity_on_color_multiplier(&self) -> &f32;
    fn opacity_on_color_multiplier_mut(&mut self) -> &mut f32;
    fn opacity_off_transparency(&self) -> &f32;
    fn opacity_off_transparency_mut(&mut self) -> &mut f32;
    fn opacity_off_color_multiplier(&self) -> &f32;
    fn opacity_off_color_multiplier_mut(&mut self) -> &mut f32;
    fn material_guid(&self) -> &glacier_util::guid::Guid;
    fn material_guid_mut(&mut self) -> &mut glacier_util::guid::Guid;
    fn opacity(&self) -> &f32;
    fn opacity_mut(&mut self) -> &mut f32;
    fn color(&self) -> &super::core::Vec3;
    fn color_mut(&mut self) -> &mut super::core::Vec3;
}

impl RadiosityMaterialOpacityTriggerEntityDataTrait for RadiosityMaterialOpacityTriggerEntityData {
    fn material_src_color(&self) -> &super::core::Vec3 {
        &self.material_src_color
    }
    fn material_src_color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.material_src_color
    }
    fn material_src_opacity(&self) -> &f32 {
        &self.material_src_opacity
    }
    fn material_src_opacity_mut(&mut self) -> &mut f32 {
        &mut self.material_src_opacity
    }
    fn opacity_on_transparency(&self) -> &f32 {
        &self.opacity_on_transparency
    }
    fn opacity_on_transparency_mut(&mut self) -> &mut f32 {
        &mut self.opacity_on_transparency
    }
    fn opacity_on_color_multiplier(&self) -> &f32 {
        &self.opacity_on_color_multiplier
    }
    fn opacity_on_color_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.opacity_on_color_multiplier
    }
    fn opacity_off_transparency(&self) -> &f32 {
        &self.opacity_off_transparency
    }
    fn opacity_off_transparency_mut(&mut self) -> &mut f32 {
        &mut self.opacity_off_transparency
    }
    fn opacity_off_color_multiplier(&self) -> &f32 {
        &self.opacity_off_color_multiplier
    }
    fn opacity_off_color_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.opacity_off_color_multiplier
    }
    fn material_guid(&self) -> &glacier_util::guid::Guid {
        &self.material_guid
    }
    fn material_guid_mut(&mut self) -> &mut glacier_util::guid::Guid {
        &mut self.material_guid
    }
    fn opacity(&self) -> &f32 {
        &self.opacity
    }
    fn opacity_mut(&mut self) -> &mut f32 {
        &mut self.opacity
    }
    fn color(&self) -> &super::core::Vec3 {
        &self.color
    }
    fn color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.color
    }
}

impl super::entity::EntityDataTrait for RadiosityMaterialOpacityTriggerEntityData {
}

impl super::entity::GameObjectDataTrait for RadiosityMaterialOpacityTriggerEntityData {
}

impl super::core::DataBusPeerTrait for RadiosityMaterialOpacityTriggerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for RadiosityMaterialOpacityTriggerEntityData {
}

impl super::core::DataContainerTrait for RadiosityMaterialOpacityTriggerEntityData {
}

pub static RADIOSITYMATERIALOPACITYTRIGGERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RadiosityMaterialOpacityTriggerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RadiosityMaterialOpacityTriggerEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MaterialSrcColor",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(RadiosityMaterialOpacityTriggerEntityData, material_src_color),
            },
            FieldInfoData {
                name: "MaterialSrcOpacity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RadiosityMaterialOpacityTriggerEntityData, material_src_opacity),
            },
            FieldInfoData {
                name: "OpacityOnTransparency",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RadiosityMaterialOpacityTriggerEntityData, opacity_on_transparency),
            },
            FieldInfoData {
                name: "OpacityOnColorMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RadiosityMaterialOpacityTriggerEntityData, opacity_on_color_multiplier),
            },
            FieldInfoData {
                name: "OpacityOffTransparency",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RadiosityMaterialOpacityTriggerEntityData, opacity_off_transparency),
            },
            FieldInfoData {
                name: "OpacityOffColorMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RadiosityMaterialOpacityTriggerEntityData, opacity_off_color_multiplier),
            },
            FieldInfoData {
                name: "MaterialGuid",
                flags: MemberInfoFlags::new(0),
                field_type: "Guid",
                rust_offset: offset_of!(RadiosityMaterialOpacityTriggerEntityData, material_guid),
            },
            FieldInfoData {
                name: "Opacity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RadiosityMaterialOpacityTriggerEntityData, opacity),
            },
            FieldInfoData {
                name: "Color",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(RadiosityMaterialOpacityTriggerEntityData, color),
            },
        ],
    }),
    array_type: Some(RADIOSITYMATERIALOPACITYTRIGGERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for RadiosityMaterialOpacityTriggerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        RADIOSITYMATERIALOPACITYTRIGGERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RADIOSITYMATERIALOPACITYTRIGGERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RadiosityMaterialOpacityTriggerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("RadiosityMaterialOpacityTriggerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RadiosityMaterialInstanceEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub material_guid: glacier_util::guid::Guid,
    pub material_update_mask: u8,
    pub color: super::core::Vec3,
    pub emissive_intensity: f32,
    pub opacity: f32,
    pub backface_type: super::render_base::RadiosityBackfaceType,
    pub field_flag_override0: u8,
}

pub trait RadiosityMaterialInstanceEntityDataTrait: super::entity::EntityDataTrait {
    fn material_guid(&self) -> &glacier_util::guid::Guid;
    fn material_guid_mut(&mut self) -> &mut glacier_util::guid::Guid;
    fn material_update_mask(&self) -> &u8;
    fn material_update_mask_mut(&mut self) -> &mut u8;
    fn color(&self) -> &super::core::Vec3;
    fn color_mut(&mut self) -> &mut super::core::Vec3;
    fn emissive_intensity(&self) -> &f32;
    fn emissive_intensity_mut(&mut self) -> &mut f32;
    fn opacity(&self) -> &f32;
    fn opacity_mut(&mut self) -> &mut f32;
    fn backface_type(&self) -> &super::render_base::RadiosityBackfaceType;
    fn backface_type_mut(&mut self) -> &mut super::render_base::RadiosityBackfaceType;
    fn field_flag_override0(&self) -> &u8;
    fn field_flag_override0_mut(&mut self) -> &mut u8;
}

impl RadiosityMaterialInstanceEntityDataTrait for RadiosityMaterialInstanceEntityData {
    fn material_guid(&self) -> &glacier_util::guid::Guid {
        &self.material_guid
    }
    fn material_guid_mut(&mut self) -> &mut glacier_util::guid::Guid {
        &mut self.material_guid
    }
    fn material_update_mask(&self) -> &u8 {
        &self.material_update_mask
    }
    fn material_update_mask_mut(&mut self) -> &mut u8 {
        &mut self.material_update_mask
    }
    fn color(&self) -> &super::core::Vec3 {
        &self.color
    }
    fn color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.color
    }
    fn emissive_intensity(&self) -> &f32 {
        &self.emissive_intensity
    }
    fn emissive_intensity_mut(&mut self) -> &mut f32 {
        &mut self.emissive_intensity
    }
    fn opacity(&self) -> &f32 {
        &self.opacity
    }
    fn opacity_mut(&mut self) -> &mut f32 {
        &mut self.opacity
    }
    fn backface_type(&self) -> &super::render_base::RadiosityBackfaceType {
        &self.backface_type
    }
    fn backface_type_mut(&mut self) -> &mut super::render_base::RadiosityBackfaceType {
        &mut self.backface_type
    }
    fn field_flag_override0(&self) -> &u8 {
        &self.field_flag_override0
    }
    fn field_flag_override0_mut(&mut self) -> &mut u8 {
        &mut self.field_flag_override0
    }
}

impl super::entity::EntityDataTrait for RadiosityMaterialInstanceEntityData {
}

impl super::entity::GameObjectDataTrait for RadiosityMaterialInstanceEntityData {
}

impl super::core::DataBusPeerTrait for RadiosityMaterialInstanceEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for RadiosityMaterialInstanceEntityData {
}

impl super::core::DataContainerTrait for RadiosityMaterialInstanceEntityData {
}

pub static RADIOSITYMATERIALINSTANCEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RadiosityMaterialInstanceEntityData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RadiosityMaterialInstanceEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MaterialGuid",
                flags: MemberInfoFlags::new(0),
                field_type: "Guid",
                rust_offset: offset_of!(RadiosityMaterialInstanceEntityData, material_guid),
            },
            FieldInfoData {
                name: "MaterialUpdateMask",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(RadiosityMaterialInstanceEntityData, material_update_mask),
            },
            FieldInfoData {
                name: "Color",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(RadiosityMaterialInstanceEntityData, color),
            },
            FieldInfoData {
                name: "EmissiveIntensity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RadiosityMaterialInstanceEntityData, emissive_intensity),
            },
            FieldInfoData {
                name: "Opacity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RadiosityMaterialInstanceEntityData, opacity),
            },
            FieldInfoData {
                name: "BackfaceType",
                flags: MemberInfoFlags::new(0),
                field_type: "RadiosityBackfaceType",
                rust_offset: offset_of!(RadiosityMaterialInstanceEntityData, backface_type),
            },
            FieldInfoData {
                name: "FieldFlagOverride0",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(RadiosityMaterialInstanceEntityData, field_flag_override0),
            },
        ],
    }),
    array_type: Some(RADIOSITYMATERIALINSTANCEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for RadiosityMaterialInstanceEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        RADIOSITYMATERIALINSTANCEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RADIOSITYMATERIALINSTANCEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RadiosityMaterialInstanceEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("RadiosityMaterialInstanceEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RadiosityMaterialEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub material_guid: glacier_util::guid::Guid,
    pub material_update_mask: u8,
    pub color: super::core::Vec3,
    pub emissive_intensity: f32,
    pub opacity: f32,
    pub backface_type: super::render_base::RadiosityBackfaceType,
    pub field_flag_override0: u8,
}

pub trait RadiosityMaterialEntityDataTrait: super::entity::EntityDataTrait {
    fn material_guid(&self) -> &glacier_util::guid::Guid;
    fn material_guid_mut(&mut self) -> &mut glacier_util::guid::Guid;
    fn material_update_mask(&self) -> &u8;
    fn material_update_mask_mut(&mut self) -> &mut u8;
    fn color(&self) -> &super::core::Vec3;
    fn color_mut(&mut self) -> &mut super::core::Vec3;
    fn emissive_intensity(&self) -> &f32;
    fn emissive_intensity_mut(&mut self) -> &mut f32;
    fn opacity(&self) -> &f32;
    fn opacity_mut(&mut self) -> &mut f32;
    fn backface_type(&self) -> &super::render_base::RadiosityBackfaceType;
    fn backface_type_mut(&mut self) -> &mut super::render_base::RadiosityBackfaceType;
    fn field_flag_override0(&self) -> &u8;
    fn field_flag_override0_mut(&mut self) -> &mut u8;
}

impl RadiosityMaterialEntityDataTrait for RadiosityMaterialEntityData {
    fn material_guid(&self) -> &glacier_util::guid::Guid {
        &self.material_guid
    }
    fn material_guid_mut(&mut self) -> &mut glacier_util::guid::Guid {
        &mut self.material_guid
    }
    fn material_update_mask(&self) -> &u8 {
        &self.material_update_mask
    }
    fn material_update_mask_mut(&mut self) -> &mut u8 {
        &mut self.material_update_mask
    }
    fn color(&self) -> &super::core::Vec3 {
        &self.color
    }
    fn color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.color
    }
    fn emissive_intensity(&self) -> &f32 {
        &self.emissive_intensity
    }
    fn emissive_intensity_mut(&mut self) -> &mut f32 {
        &mut self.emissive_intensity
    }
    fn opacity(&self) -> &f32 {
        &self.opacity
    }
    fn opacity_mut(&mut self) -> &mut f32 {
        &mut self.opacity
    }
    fn backface_type(&self) -> &super::render_base::RadiosityBackfaceType {
        &self.backface_type
    }
    fn backface_type_mut(&mut self) -> &mut super::render_base::RadiosityBackfaceType {
        &mut self.backface_type
    }
    fn field_flag_override0(&self) -> &u8 {
        &self.field_flag_override0
    }
    fn field_flag_override0_mut(&mut self) -> &mut u8 {
        &mut self.field_flag_override0
    }
}

impl super::entity::EntityDataTrait for RadiosityMaterialEntityData {
}

impl super::entity::GameObjectDataTrait for RadiosityMaterialEntityData {
}

impl super::core::DataBusPeerTrait for RadiosityMaterialEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for RadiosityMaterialEntityData {
}

impl super::core::DataContainerTrait for RadiosityMaterialEntityData {
}

pub static RADIOSITYMATERIALENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RadiosityMaterialEntityData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RadiosityMaterialEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MaterialGuid",
                flags: MemberInfoFlags::new(0),
                field_type: "Guid",
                rust_offset: offset_of!(RadiosityMaterialEntityData, material_guid),
            },
            FieldInfoData {
                name: "MaterialUpdateMask",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(RadiosityMaterialEntityData, material_update_mask),
            },
            FieldInfoData {
                name: "Color",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(RadiosityMaterialEntityData, color),
            },
            FieldInfoData {
                name: "EmissiveIntensity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RadiosityMaterialEntityData, emissive_intensity),
            },
            FieldInfoData {
                name: "Opacity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RadiosityMaterialEntityData, opacity),
            },
            FieldInfoData {
                name: "BackfaceType",
                flags: MemberInfoFlags::new(0),
                field_type: "RadiosityBackfaceType",
                rust_offset: offset_of!(RadiosityMaterialEntityData, backface_type),
            },
            FieldInfoData {
                name: "FieldFlagOverride0",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(RadiosityMaterialEntityData, field_flag_override0),
            },
        ],
    }),
    array_type: Some(RADIOSITYMATERIALENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for RadiosityMaterialEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        RADIOSITYMATERIALENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RADIOSITYMATERIALENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RadiosityMaterialEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("RadiosityMaterialEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GroundHeightEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub data: super::world_base::GroundHeightData,
}

pub trait GroundHeightEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn data(&self) -> &super::world_base::GroundHeightData;
    fn data_mut(&mut self) -> &mut super::world_base::GroundHeightData;
}

impl GroundHeightEntityDataTrait for GroundHeightEntityData {
    fn data(&self) -> &super::world_base::GroundHeightData {
        &self.data
    }
    fn data_mut(&mut self) -> &mut super::world_base::GroundHeightData {
        &mut self.data
    }
}

impl super::entity::SpatialEntityDataTrait for GroundHeightEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for GroundHeightEntityData {
}

impl super::entity::GameObjectDataTrait for GroundHeightEntityData {
}

impl super::core::DataBusPeerTrait for GroundHeightEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for GroundHeightEntityData {
}

impl super::core::DataContainerTrait for GroundHeightEntityData {
}

pub static GROUNDHEIGHTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GroundHeightEntityData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GroundHeightEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Data",
                flags: MemberInfoFlags::new(0),
                field_type: "GroundHeightData",
                rust_offset: offset_of!(GroundHeightEntityData, data),
            },
        ],
    }),
    array_type: Some(GROUNDHEIGHTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for GroundHeightEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        GROUNDHEIGHTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static GROUNDHEIGHTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GroundHeightEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("GroundHeightEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RenderVolumeEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub shader: super::render_base::SurfaceShaderInstanceDataStruct,
    pub user_masks: super::core::Vec4,
    pub transform_type: super::world_base::RenderVolumeTransformType,
    pub enabled: bool,
}

pub trait RenderVolumeEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn shader(&self) -> &super::render_base::SurfaceShaderInstanceDataStruct;
    fn shader_mut(&mut self) -> &mut super::render_base::SurfaceShaderInstanceDataStruct;
    fn user_masks(&self) -> &super::core::Vec4;
    fn user_masks_mut(&mut self) -> &mut super::core::Vec4;
    fn transform_type(&self) -> &super::world_base::RenderVolumeTransformType;
    fn transform_type_mut(&mut self) -> &mut super::world_base::RenderVolumeTransformType;
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
}

impl RenderVolumeEntityDataTrait for RenderVolumeEntityData {
    fn shader(&self) -> &super::render_base::SurfaceShaderInstanceDataStruct {
        &self.shader
    }
    fn shader_mut(&mut self) -> &mut super::render_base::SurfaceShaderInstanceDataStruct {
        &mut self.shader
    }
    fn user_masks(&self) -> &super::core::Vec4 {
        &self.user_masks
    }
    fn user_masks_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.user_masks
    }
    fn transform_type(&self) -> &super::world_base::RenderVolumeTransformType {
        &self.transform_type
    }
    fn transform_type_mut(&mut self) -> &mut super::world_base::RenderVolumeTransformType {
        &mut self.transform_type
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
}

impl super::entity::SpatialEntityDataTrait for RenderVolumeEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for RenderVolumeEntityData {
}

impl super::entity::GameObjectDataTrait for RenderVolumeEntityData {
}

impl super::core::DataBusPeerTrait for RenderVolumeEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for RenderVolumeEntityData {
}

impl super::core::DataContainerTrait for RenderVolumeEntityData {
}

pub static RENDERVOLUMEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RenderVolumeEntityData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RenderVolumeEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Shader",
                flags: MemberInfoFlags::new(0),
                field_type: "SurfaceShaderInstanceDataStruct",
                rust_offset: offset_of!(RenderVolumeEntityData, shader),
            },
            FieldInfoData {
                name: "UserMasks",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(RenderVolumeEntityData, user_masks),
            },
            FieldInfoData {
                name: "TransformType",
                flags: MemberInfoFlags::new(0),
                field_type: "RenderVolumeTransformType",
                rust_offset: offset_of!(RenderVolumeEntityData, transform_type),
            },
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RenderVolumeEntityData, enabled),
            },
        ],
    }),
    array_type: Some(RENDERVOLUMEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for RenderVolumeEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        RENDERVOLUMEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RENDERVOLUMEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RenderVolumeEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("RenderVolumeEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MeshProxyEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub mesh: Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>>,
    pub base_pose_transforms: super::core::SparseTransformArray,
    pub static_instances: super::entity::StaticInstancingData,
}

pub trait MeshProxyEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn mesh(&self) -> &Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>>;
    fn mesh_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>>;
    fn base_pose_transforms(&self) -> &super::core::SparseTransformArray;
    fn base_pose_transforms_mut(&mut self) -> &mut super::core::SparseTransformArray;
    fn static_instances(&self) -> &super::entity::StaticInstancingData;
    fn static_instances_mut(&mut self) -> &mut super::entity::StaticInstancingData;
}

impl MeshProxyEntityDataTrait for MeshProxyEntityData {
    fn mesh(&self) -> &Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        &self.mesh
    }
    fn mesh_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        &mut self.mesh
    }
    fn base_pose_transforms(&self) -> &super::core::SparseTransformArray {
        &self.base_pose_transforms
    }
    fn base_pose_transforms_mut(&mut self) -> &mut super::core::SparseTransformArray {
        &mut self.base_pose_transforms
    }
    fn static_instances(&self) -> &super::entity::StaticInstancingData {
        &self.static_instances
    }
    fn static_instances_mut(&mut self) -> &mut super::entity::StaticInstancingData {
        &mut self.static_instances
    }
}

impl super::entity::SpatialEntityDataTrait for MeshProxyEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for MeshProxyEntityData {
}

impl super::entity::GameObjectDataTrait for MeshProxyEntityData {
}

impl super::core::DataBusPeerTrait for MeshProxyEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for MeshProxyEntityData {
}

impl super::core::DataContainerTrait for MeshProxyEntityData {
}

pub static MESHPROXYENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MeshProxyEntityData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MeshProxyEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Mesh",
                flags: MemberInfoFlags::new(0),
                field_type: "MeshBaseAsset",
                rust_offset: offset_of!(MeshProxyEntityData, mesh),
            },
            FieldInfoData {
                name: "BasePoseTransforms",
                flags: MemberInfoFlags::new(0),
                field_type: "SparseTransformArray",
                rust_offset: offset_of!(MeshProxyEntityData, base_pose_transforms),
            },
            FieldInfoData {
                name: "StaticInstances",
                flags: MemberInfoFlags::new(0),
                field_type: "StaticInstancingData",
                rust_offset: offset_of!(MeshProxyEntityData, static_instances),
            },
        ],
    }),
    array_type: Some(MESHPROXYENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for MeshProxyEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        MESHPROXYENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MESHPROXYENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MeshProxyEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("MeshProxyEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ParticipatingMediaMaterialEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub specification_mode: super::world_base::ParticipatingMediaSpecificationMode,
    pub absorption: f32,
    pub scattering: super::core::Vec3,
    pub exctinction: f32,
    pub albedo: super::core::Vec3,
    pub emissive: super::core::Vec3,
    pub phase: f32,
}

pub trait ParticipatingMediaMaterialEntityDataTrait: super::entity::EntityDataTrait {
    fn specification_mode(&self) -> &super::world_base::ParticipatingMediaSpecificationMode;
    fn specification_mode_mut(&mut self) -> &mut super::world_base::ParticipatingMediaSpecificationMode;
    fn absorption(&self) -> &f32;
    fn absorption_mut(&mut self) -> &mut f32;
    fn scattering(&self) -> &super::core::Vec3;
    fn scattering_mut(&mut self) -> &mut super::core::Vec3;
    fn exctinction(&self) -> &f32;
    fn exctinction_mut(&mut self) -> &mut f32;
    fn albedo(&self) -> &super::core::Vec3;
    fn albedo_mut(&mut self) -> &mut super::core::Vec3;
    fn emissive(&self) -> &super::core::Vec3;
    fn emissive_mut(&mut self) -> &mut super::core::Vec3;
    fn phase(&self) -> &f32;
    fn phase_mut(&mut self) -> &mut f32;
}

impl ParticipatingMediaMaterialEntityDataTrait for ParticipatingMediaMaterialEntityData {
    fn specification_mode(&self) -> &super::world_base::ParticipatingMediaSpecificationMode {
        &self.specification_mode
    }
    fn specification_mode_mut(&mut self) -> &mut super::world_base::ParticipatingMediaSpecificationMode {
        &mut self.specification_mode
    }
    fn absorption(&self) -> &f32 {
        &self.absorption
    }
    fn absorption_mut(&mut self) -> &mut f32 {
        &mut self.absorption
    }
    fn scattering(&self) -> &super::core::Vec3 {
        &self.scattering
    }
    fn scattering_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.scattering
    }
    fn exctinction(&self) -> &f32 {
        &self.exctinction
    }
    fn exctinction_mut(&mut self) -> &mut f32 {
        &mut self.exctinction
    }
    fn albedo(&self) -> &super::core::Vec3 {
        &self.albedo
    }
    fn albedo_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.albedo
    }
    fn emissive(&self) -> &super::core::Vec3 {
        &self.emissive
    }
    fn emissive_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.emissive
    }
    fn phase(&self) -> &f32 {
        &self.phase
    }
    fn phase_mut(&mut self) -> &mut f32 {
        &mut self.phase
    }
}

impl super::entity::EntityDataTrait for ParticipatingMediaMaterialEntityData {
}

impl super::entity::GameObjectDataTrait for ParticipatingMediaMaterialEntityData {
}

impl super::core::DataBusPeerTrait for ParticipatingMediaMaterialEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ParticipatingMediaMaterialEntityData {
}

impl super::core::DataContainerTrait for ParticipatingMediaMaterialEntityData {
}

pub static PARTICIPATINGMEDIAMATERIALENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ParticipatingMediaMaterialEntityData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ParticipatingMediaMaterialEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SpecificationMode",
                flags: MemberInfoFlags::new(0),
                field_type: "ParticipatingMediaSpecificationMode",
                rust_offset: offset_of!(ParticipatingMediaMaterialEntityData, specification_mode),
            },
            FieldInfoData {
                name: "Absorption",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ParticipatingMediaMaterialEntityData, absorption),
            },
            FieldInfoData {
                name: "Scattering",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(ParticipatingMediaMaterialEntityData, scattering),
            },
            FieldInfoData {
                name: "Exctinction",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ParticipatingMediaMaterialEntityData, exctinction),
            },
            FieldInfoData {
                name: "Albedo",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(ParticipatingMediaMaterialEntityData, albedo),
            },
            FieldInfoData {
                name: "Emissive",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(ParticipatingMediaMaterialEntityData, emissive),
            },
            FieldInfoData {
                name: "Phase",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ParticipatingMediaMaterialEntityData, phase),
            },
        ],
    }),
    array_type: Some(PARTICIPATINGMEDIAMATERIALENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ParticipatingMediaMaterialEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PARTICIPATINGMEDIAMATERIALENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PARTICIPATINGMEDIAMATERIALENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ParticipatingMediaMaterialEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("ParticipatingMediaMaterialEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LocalFogVolumeEntityData {
    pub _glacier_base: LocalVolumetricEntityData,
    pub object_layers: u16,
    pub enabled: bool,
    pub participating_media: super::world_base::ParticipatingMedia,
    pub ambient_lighting_scale: f32,
    pub density_texture: Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>,
}

pub trait LocalFogVolumeEntityDataTrait: LocalVolumetricEntityDataTrait {
    fn object_layers(&self) -> &u16;
    fn object_layers_mut(&mut self) -> &mut u16;
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
    fn participating_media(&self) -> &super::world_base::ParticipatingMedia;
    fn participating_media_mut(&mut self) -> &mut super::world_base::ParticipatingMedia;
    fn ambient_lighting_scale(&self) -> &f32;
    fn ambient_lighting_scale_mut(&mut self) -> &mut f32;
    fn density_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn density_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
}

impl LocalFogVolumeEntityDataTrait for LocalFogVolumeEntityData {
    fn object_layers(&self) -> &u16 {
        &self.object_layers
    }
    fn object_layers_mut(&mut self) -> &mut u16 {
        &mut self.object_layers
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
    fn participating_media(&self) -> &super::world_base::ParticipatingMedia {
        &self.participating_media
    }
    fn participating_media_mut(&mut self) -> &mut super::world_base::ParticipatingMedia {
        &mut self.participating_media
    }
    fn ambient_lighting_scale(&self) -> &f32 {
        &self.ambient_lighting_scale
    }
    fn ambient_lighting_scale_mut(&mut self) -> &mut f32 {
        &mut self.ambient_lighting_scale
    }
    fn density_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &self.density_texture
    }
    fn density_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &mut self.density_texture
    }
}

impl LocalVolumetricEntityDataTrait for LocalFogVolumeEntityData {
}

impl super::entity::SpatialEntityDataTrait for LocalFogVolumeEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for LocalFogVolumeEntityData {
}

impl super::entity::GameObjectDataTrait for LocalFogVolumeEntityData {
}

impl super::core::DataBusPeerTrait for LocalFogVolumeEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for LocalFogVolumeEntityData {
}

impl super::core::DataContainerTrait for LocalFogVolumeEntityData {
}

pub static LOCALFOGVOLUMEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalFogVolumeEntityData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(LOCALVOLUMETRICENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LocalFogVolumeEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ObjectLayers",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint16",
                rust_offset: offset_of!(LocalFogVolumeEntityData, object_layers),
            },
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LocalFogVolumeEntityData, enabled),
            },
            FieldInfoData {
                name: "ParticipatingMedia",
                flags: MemberInfoFlags::new(0),
                field_type: "ParticipatingMedia",
                rust_offset: offset_of!(LocalFogVolumeEntityData, participating_media),
            },
            FieldInfoData {
                name: "AmbientLightingScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LocalFogVolumeEntityData, ambient_lighting_scale),
            },
            FieldInfoData {
                name: "DensityTexture",
                flags: MemberInfoFlags::new(0),
                field_type: "TextureBaseAsset",
                rust_offset: offset_of!(LocalFogVolumeEntityData, density_texture),
            },
        ],
    }),
    array_type: Some(LOCALFOGVOLUMEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for LocalFogVolumeEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        LOCALFOGVOLUMEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LOCALFOGVOLUMEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalFogVolumeEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("LocalFogVolumeEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LocalVolumetricEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
}

pub trait LocalVolumetricEntityDataTrait: super::entity::SpatialEntityDataTrait {
}

impl LocalVolumetricEntityDataTrait for LocalVolumetricEntityData {
}

impl super::entity::SpatialEntityDataTrait for LocalVolumetricEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for LocalVolumetricEntityData {
}

impl super::entity::GameObjectDataTrait for LocalVolumetricEntityData {
}

impl super::core::DataBusPeerTrait for LocalVolumetricEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for LocalVolumetricEntityData {
}

impl super::core::DataContainerTrait for LocalVolumetricEntityData {
}

pub static LOCALVOLUMETRICENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalVolumetricEntityData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LocalVolumetricEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(LOCALVOLUMETRICENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for LocalVolumetricEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        LOCALVOLUMETRICENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LOCALVOLUMETRICENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalVolumetricEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("LocalVolumetricEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ReflectionVolumeSynchronizerEntityData {
    pub _glacier_base: super::entity::EntityData,
}

pub trait ReflectionVolumeSynchronizerEntityDataTrait: super::entity::EntityDataTrait {
}

impl ReflectionVolumeSynchronizerEntityDataTrait for ReflectionVolumeSynchronizerEntityData {
}

impl super::entity::EntityDataTrait for ReflectionVolumeSynchronizerEntityData {
}

impl super::entity::GameObjectDataTrait for ReflectionVolumeSynchronizerEntityData {
}

impl super::core::DataBusPeerTrait for ReflectionVolumeSynchronizerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ReflectionVolumeSynchronizerEntityData {
}

impl super::core::DataContainerTrait for ReflectionVolumeSynchronizerEntityData {
}

pub static REFLECTIONVOLUMESYNCHRONIZERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReflectionVolumeSynchronizerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ReflectionVolumeSynchronizerEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(REFLECTIONVOLUMESYNCHRONIZERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ReflectionVolumeSynchronizerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        REFLECTIONVOLUMESYNCHRONIZERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static REFLECTIONVOLUMESYNCHRONIZERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReflectionVolumeSynchronizerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("ReflectionVolumeSynchronizerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LocalPlanarReflectionEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub far_plane: f32,
    pub clipping_offset: f32,
    pub clipping_enable: bool,
    pub distance_tolerance: f32,
    pub distance_falloff: f32,
    pub normal_tolerance: f32,
    pub normal_falloff: f32,
    pub enable: bool,
    pub terrain_reflections_enable: bool,
    pub sky_reflection_enable: bool,
}

pub trait LocalPlanarReflectionEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn far_plane(&self) -> &f32;
    fn far_plane_mut(&mut self) -> &mut f32;
    fn clipping_offset(&self) -> &f32;
    fn clipping_offset_mut(&mut self) -> &mut f32;
    fn clipping_enable(&self) -> &bool;
    fn clipping_enable_mut(&mut self) -> &mut bool;
    fn distance_tolerance(&self) -> &f32;
    fn distance_tolerance_mut(&mut self) -> &mut f32;
    fn distance_falloff(&self) -> &f32;
    fn distance_falloff_mut(&mut self) -> &mut f32;
    fn normal_tolerance(&self) -> &f32;
    fn normal_tolerance_mut(&mut self) -> &mut f32;
    fn normal_falloff(&self) -> &f32;
    fn normal_falloff_mut(&mut self) -> &mut f32;
    fn enable(&self) -> &bool;
    fn enable_mut(&mut self) -> &mut bool;
    fn terrain_reflections_enable(&self) -> &bool;
    fn terrain_reflections_enable_mut(&mut self) -> &mut bool;
    fn sky_reflection_enable(&self) -> &bool;
    fn sky_reflection_enable_mut(&mut self) -> &mut bool;
}

impl LocalPlanarReflectionEntityDataTrait for LocalPlanarReflectionEntityData {
    fn far_plane(&self) -> &f32 {
        &self.far_plane
    }
    fn far_plane_mut(&mut self) -> &mut f32 {
        &mut self.far_plane
    }
    fn clipping_offset(&self) -> &f32 {
        &self.clipping_offset
    }
    fn clipping_offset_mut(&mut self) -> &mut f32 {
        &mut self.clipping_offset
    }
    fn clipping_enable(&self) -> &bool {
        &self.clipping_enable
    }
    fn clipping_enable_mut(&mut self) -> &mut bool {
        &mut self.clipping_enable
    }
    fn distance_tolerance(&self) -> &f32 {
        &self.distance_tolerance
    }
    fn distance_tolerance_mut(&mut self) -> &mut f32 {
        &mut self.distance_tolerance
    }
    fn distance_falloff(&self) -> &f32 {
        &self.distance_falloff
    }
    fn distance_falloff_mut(&mut self) -> &mut f32 {
        &mut self.distance_falloff
    }
    fn normal_tolerance(&self) -> &f32 {
        &self.normal_tolerance
    }
    fn normal_tolerance_mut(&mut self) -> &mut f32 {
        &mut self.normal_tolerance
    }
    fn normal_falloff(&self) -> &f32 {
        &self.normal_falloff
    }
    fn normal_falloff_mut(&mut self) -> &mut f32 {
        &mut self.normal_falloff
    }
    fn enable(&self) -> &bool {
        &self.enable
    }
    fn enable_mut(&mut self) -> &mut bool {
        &mut self.enable
    }
    fn terrain_reflections_enable(&self) -> &bool {
        &self.terrain_reflections_enable
    }
    fn terrain_reflections_enable_mut(&mut self) -> &mut bool {
        &mut self.terrain_reflections_enable
    }
    fn sky_reflection_enable(&self) -> &bool {
        &self.sky_reflection_enable
    }
    fn sky_reflection_enable_mut(&mut self) -> &mut bool {
        &mut self.sky_reflection_enable
    }
}

impl super::entity::SpatialEntityDataTrait for LocalPlanarReflectionEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for LocalPlanarReflectionEntityData {
}

impl super::entity::GameObjectDataTrait for LocalPlanarReflectionEntityData {
}

impl super::core::DataBusPeerTrait for LocalPlanarReflectionEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for LocalPlanarReflectionEntityData {
}

impl super::core::DataContainerTrait for LocalPlanarReflectionEntityData {
}

pub static LOCALPLANARREFLECTIONENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalPlanarReflectionEntityData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LocalPlanarReflectionEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "FarPlane",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LocalPlanarReflectionEntityData, far_plane),
            },
            FieldInfoData {
                name: "ClippingOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LocalPlanarReflectionEntityData, clipping_offset),
            },
            FieldInfoData {
                name: "ClippingEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LocalPlanarReflectionEntityData, clipping_enable),
            },
            FieldInfoData {
                name: "DistanceTolerance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LocalPlanarReflectionEntityData, distance_tolerance),
            },
            FieldInfoData {
                name: "DistanceFalloff",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LocalPlanarReflectionEntityData, distance_falloff),
            },
            FieldInfoData {
                name: "NormalTolerance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LocalPlanarReflectionEntityData, normal_tolerance),
            },
            FieldInfoData {
                name: "NormalFalloff",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LocalPlanarReflectionEntityData, normal_falloff),
            },
            FieldInfoData {
                name: "Enable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LocalPlanarReflectionEntityData, enable),
            },
            FieldInfoData {
                name: "TerrainReflectionsEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LocalPlanarReflectionEntityData, terrain_reflections_enable),
            },
            FieldInfoData {
                name: "SkyReflectionEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LocalPlanarReflectionEntityData, sky_reflection_enable),
            },
        ],
    }),
    array_type: Some(LOCALPLANARREFLECTIONENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for LocalPlanarReflectionEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        LOCALPLANARREFLECTIONENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LOCALPLANARREFLECTIONENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalPlanarReflectionEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("LocalPlanarReflectionEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PbrDistantReflectionVolumeEntityData {
    pub _glacier_base: PbrGenericBoxReflectionVolumeEntityData,
    pub location_type: super::render_base::DistantIBLLocationType,
    pub local_offset: super::core::Vec3,
    pub mode: super::render_base::LocalIBLMode,
    pub capture_distance: f32,
    pub capture_fade_distance: f32,
    pub influence_expand_distance: f32,
    pub influence_fade_distance: f32,
    pub update_when_moving: bool,
    pub capture_sky: bool,
    pub capture_sky_mask: bool,
    pub use_sky_visibility_as_a_o: bool,
    pub use_sky_visibility_as_mask: bool,
    pub sharpen_sky_visibility: f32,
    pub bias_sky_visibility: f32,
    pub use_proxy_reprojection: bool,
    pub capture_fog: bool,
    pub object_layers: u16,
    pub do_not_update_baked_texture: bool,
    pub baked_texture: Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>,
    pub enabled: bool,
    pub is_visible: bool,
}

pub trait PbrDistantReflectionVolumeEntityDataTrait: PbrGenericBoxReflectionVolumeEntityDataTrait {
    fn location_type(&self) -> &super::render_base::DistantIBLLocationType;
    fn location_type_mut(&mut self) -> &mut super::render_base::DistantIBLLocationType;
    fn local_offset(&self) -> &super::core::Vec3;
    fn local_offset_mut(&mut self) -> &mut super::core::Vec3;
    fn mode(&self) -> &super::render_base::LocalIBLMode;
    fn mode_mut(&mut self) -> &mut super::render_base::LocalIBLMode;
    fn capture_distance(&self) -> &f32;
    fn capture_distance_mut(&mut self) -> &mut f32;
    fn capture_fade_distance(&self) -> &f32;
    fn capture_fade_distance_mut(&mut self) -> &mut f32;
    fn influence_expand_distance(&self) -> &f32;
    fn influence_expand_distance_mut(&mut self) -> &mut f32;
    fn influence_fade_distance(&self) -> &f32;
    fn influence_fade_distance_mut(&mut self) -> &mut f32;
    fn update_when_moving(&self) -> &bool;
    fn update_when_moving_mut(&mut self) -> &mut bool;
    fn capture_sky(&self) -> &bool;
    fn capture_sky_mut(&mut self) -> &mut bool;
    fn capture_sky_mask(&self) -> &bool;
    fn capture_sky_mask_mut(&mut self) -> &mut bool;
    fn use_sky_visibility_as_a_o(&self) -> &bool;
    fn use_sky_visibility_as_a_o_mut(&mut self) -> &mut bool;
    fn use_sky_visibility_as_mask(&self) -> &bool;
    fn use_sky_visibility_as_mask_mut(&mut self) -> &mut bool;
    fn sharpen_sky_visibility(&self) -> &f32;
    fn sharpen_sky_visibility_mut(&mut self) -> &mut f32;
    fn bias_sky_visibility(&self) -> &f32;
    fn bias_sky_visibility_mut(&mut self) -> &mut f32;
    fn use_proxy_reprojection(&self) -> &bool;
    fn use_proxy_reprojection_mut(&mut self) -> &mut bool;
    fn capture_fog(&self) -> &bool;
    fn capture_fog_mut(&mut self) -> &mut bool;
    fn object_layers(&self) -> &u16;
    fn object_layers_mut(&mut self) -> &mut u16;
    fn do_not_update_baked_texture(&self) -> &bool;
    fn do_not_update_baked_texture_mut(&mut self) -> &mut bool;
    fn baked_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn baked_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
    fn is_visible(&self) -> &bool;
    fn is_visible_mut(&mut self) -> &mut bool;
}

impl PbrDistantReflectionVolumeEntityDataTrait for PbrDistantReflectionVolumeEntityData {
    fn location_type(&self) -> &super::render_base::DistantIBLLocationType {
        &self.location_type
    }
    fn location_type_mut(&mut self) -> &mut super::render_base::DistantIBLLocationType {
        &mut self.location_type
    }
    fn local_offset(&self) -> &super::core::Vec3 {
        &self.local_offset
    }
    fn local_offset_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.local_offset
    }
    fn mode(&self) -> &super::render_base::LocalIBLMode {
        &self.mode
    }
    fn mode_mut(&mut self) -> &mut super::render_base::LocalIBLMode {
        &mut self.mode
    }
    fn capture_distance(&self) -> &f32 {
        &self.capture_distance
    }
    fn capture_distance_mut(&mut self) -> &mut f32 {
        &mut self.capture_distance
    }
    fn capture_fade_distance(&self) -> &f32 {
        &self.capture_fade_distance
    }
    fn capture_fade_distance_mut(&mut self) -> &mut f32 {
        &mut self.capture_fade_distance
    }
    fn influence_expand_distance(&self) -> &f32 {
        &self.influence_expand_distance
    }
    fn influence_expand_distance_mut(&mut self) -> &mut f32 {
        &mut self.influence_expand_distance
    }
    fn influence_fade_distance(&self) -> &f32 {
        &self.influence_fade_distance
    }
    fn influence_fade_distance_mut(&mut self) -> &mut f32 {
        &mut self.influence_fade_distance
    }
    fn update_when_moving(&self) -> &bool {
        &self.update_when_moving
    }
    fn update_when_moving_mut(&mut self) -> &mut bool {
        &mut self.update_when_moving
    }
    fn capture_sky(&self) -> &bool {
        &self.capture_sky
    }
    fn capture_sky_mut(&mut self) -> &mut bool {
        &mut self.capture_sky
    }
    fn capture_sky_mask(&self) -> &bool {
        &self.capture_sky_mask
    }
    fn capture_sky_mask_mut(&mut self) -> &mut bool {
        &mut self.capture_sky_mask
    }
    fn use_sky_visibility_as_a_o(&self) -> &bool {
        &self.use_sky_visibility_as_a_o
    }
    fn use_sky_visibility_as_a_o_mut(&mut self) -> &mut bool {
        &mut self.use_sky_visibility_as_a_o
    }
    fn use_sky_visibility_as_mask(&self) -> &bool {
        &self.use_sky_visibility_as_mask
    }
    fn use_sky_visibility_as_mask_mut(&mut self) -> &mut bool {
        &mut self.use_sky_visibility_as_mask
    }
    fn sharpen_sky_visibility(&self) -> &f32 {
        &self.sharpen_sky_visibility
    }
    fn sharpen_sky_visibility_mut(&mut self) -> &mut f32 {
        &mut self.sharpen_sky_visibility
    }
    fn bias_sky_visibility(&self) -> &f32 {
        &self.bias_sky_visibility
    }
    fn bias_sky_visibility_mut(&mut self) -> &mut f32 {
        &mut self.bias_sky_visibility
    }
    fn use_proxy_reprojection(&self) -> &bool {
        &self.use_proxy_reprojection
    }
    fn use_proxy_reprojection_mut(&mut self) -> &mut bool {
        &mut self.use_proxy_reprojection
    }
    fn capture_fog(&self) -> &bool {
        &self.capture_fog
    }
    fn capture_fog_mut(&mut self) -> &mut bool {
        &mut self.capture_fog
    }
    fn object_layers(&self) -> &u16 {
        &self.object_layers
    }
    fn object_layers_mut(&mut self) -> &mut u16 {
        &mut self.object_layers
    }
    fn do_not_update_baked_texture(&self) -> &bool {
        &self.do_not_update_baked_texture
    }
    fn do_not_update_baked_texture_mut(&mut self) -> &mut bool {
        &mut self.do_not_update_baked_texture
    }
    fn baked_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &self.baked_texture
    }
    fn baked_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &mut self.baked_texture
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
    fn is_visible(&self) -> &bool {
        &self.is_visible
    }
    fn is_visible_mut(&mut self) -> &mut bool {
        &mut self.is_visible
    }
}

impl PbrGenericBoxReflectionVolumeEntityDataTrait for PbrDistantReflectionVolumeEntityData {
}

impl PbrReflectionVolumeEntityDataTrait for PbrDistantReflectionVolumeEntityData {
}

impl BakeableTextureEntityDataTrait for PbrDistantReflectionVolumeEntityData {
}

impl super::entity::SpatialEntityDataTrait for PbrDistantReflectionVolumeEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for PbrDistantReflectionVolumeEntityData {
}

impl super::entity::GameObjectDataTrait for PbrDistantReflectionVolumeEntityData {
}

impl super::core::DataBusPeerTrait for PbrDistantReflectionVolumeEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PbrDistantReflectionVolumeEntityData {
}

impl super::core::DataContainerTrait for PbrDistantReflectionVolumeEntityData {
}

pub static PBRDISTANTREFLECTIONVOLUMEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PbrDistantReflectionVolumeEntityData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PBRGENERICBOXREFLECTIONVOLUMEENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PbrDistantReflectionVolumeEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "LocationType",
                flags: MemberInfoFlags::new(0),
                field_type: "DistantIBLLocationType",
                rust_offset: offset_of!(PbrDistantReflectionVolumeEntityData, location_type),
            },
            FieldInfoData {
                name: "LocalOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(PbrDistantReflectionVolumeEntityData, local_offset),
            },
            FieldInfoData {
                name: "Mode",
                flags: MemberInfoFlags::new(0),
                field_type: "LocalIBLMode",
                rust_offset: offset_of!(PbrDistantReflectionVolumeEntityData, mode),
            },
            FieldInfoData {
                name: "CaptureDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrDistantReflectionVolumeEntityData, capture_distance),
            },
            FieldInfoData {
                name: "CaptureFadeDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrDistantReflectionVolumeEntityData, capture_fade_distance),
            },
            FieldInfoData {
                name: "InfluenceExpandDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrDistantReflectionVolumeEntityData, influence_expand_distance),
            },
            FieldInfoData {
                name: "InfluenceFadeDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrDistantReflectionVolumeEntityData, influence_fade_distance),
            },
            FieldInfoData {
                name: "UpdateWhenMoving",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrDistantReflectionVolumeEntityData, update_when_moving),
            },
            FieldInfoData {
                name: "CaptureSky",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrDistantReflectionVolumeEntityData, capture_sky),
            },
            FieldInfoData {
                name: "CaptureSkyMask",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrDistantReflectionVolumeEntityData, capture_sky_mask),
            },
            FieldInfoData {
                name: "UseSkyVisibilityAsAO",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrDistantReflectionVolumeEntityData, use_sky_visibility_as_a_o),
            },
            FieldInfoData {
                name: "UseSkyVisibilityAsMask",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrDistantReflectionVolumeEntityData, use_sky_visibility_as_mask),
            },
            FieldInfoData {
                name: "SharpenSkyVisibility",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrDistantReflectionVolumeEntityData, sharpen_sky_visibility),
            },
            FieldInfoData {
                name: "BiasSkyVisibility",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrDistantReflectionVolumeEntityData, bias_sky_visibility),
            },
            FieldInfoData {
                name: "UseProxyReprojection",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrDistantReflectionVolumeEntityData, use_proxy_reprojection),
            },
            FieldInfoData {
                name: "CaptureFog",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrDistantReflectionVolumeEntityData, capture_fog),
            },
            FieldInfoData {
                name: "ObjectLayers",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint16",
                rust_offset: offset_of!(PbrDistantReflectionVolumeEntityData, object_layers),
            },
            FieldInfoData {
                name: "DoNotUpdateBakedTexture",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrDistantReflectionVolumeEntityData, do_not_update_baked_texture),
            },
            FieldInfoData {
                name: "BakedTexture",
                flags: MemberInfoFlags::new(0),
                field_type: "TextureBaseAsset",
                rust_offset: offset_of!(PbrDistantReflectionVolumeEntityData, baked_texture),
            },
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrDistantReflectionVolumeEntityData, enabled),
            },
            FieldInfoData {
                name: "IsVisible",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrDistantReflectionVolumeEntityData, is_visible),
            },
        ],
    }),
    array_type: Some(PBRDISTANTREFLECTIONVOLUMEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PbrDistantReflectionVolumeEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PBRDISTANTREFLECTIONVOLUMEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PBRDISTANTREFLECTIONVOLUMEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PbrDistantReflectionVolumeEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("PbrDistantReflectionVolumeEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PbrBoxReflectionVolumeEntityData {
    pub _glacier_base: PbrGenericBoxReflectionVolumeEntityData,
    pub influence_fade_normal: super::core::Vec3,
    pub side_fade_pos_x: f32,
    pub side_fade_neg_x: f32,
    pub side_fade_pos_y: f32,
    pub side_fade_neg_y: f32,
    pub side_fade_pos_z: f32,
    pub side_fade_neg_z: f32,
    pub local_offset: super::core::Vec3,
    pub mode: super::render_base::LocalIBLMode,
    pub capture_distance: f32,
    pub capture_fade_distance: f32,
    pub influence_expand_distance: f32,
    pub influence_fade_distance: f32,
    pub update_when_moving: bool,
    pub capture_sky: bool,
    pub capture_sky_mask: bool,
    pub use_sky_visibility_as_a_o: bool,
    pub use_sky_visibility_as_mask: bool,
    pub sharpen_sky_visibility: f32,
    pub bias_sky_visibility: f32,
    pub use_proxy_reprojection: bool,
    pub capture_fog: bool,
    pub object_layers: u16,
    pub do_not_update_baked_texture: bool,
    pub baked_texture: Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>,
    pub enabled: bool,
    pub is_visible: bool,
}

pub trait PbrBoxReflectionVolumeEntityDataTrait: PbrGenericBoxReflectionVolumeEntityDataTrait {
    fn influence_fade_normal(&self) -> &super::core::Vec3;
    fn influence_fade_normal_mut(&mut self) -> &mut super::core::Vec3;
    fn side_fade_pos_x(&self) -> &f32;
    fn side_fade_pos_x_mut(&mut self) -> &mut f32;
    fn side_fade_neg_x(&self) -> &f32;
    fn side_fade_neg_x_mut(&mut self) -> &mut f32;
    fn side_fade_pos_y(&self) -> &f32;
    fn side_fade_pos_y_mut(&mut self) -> &mut f32;
    fn side_fade_neg_y(&self) -> &f32;
    fn side_fade_neg_y_mut(&mut self) -> &mut f32;
    fn side_fade_pos_z(&self) -> &f32;
    fn side_fade_pos_z_mut(&mut self) -> &mut f32;
    fn side_fade_neg_z(&self) -> &f32;
    fn side_fade_neg_z_mut(&mut self) -> &mut f32;
    fn local_offset(&self) -> &super::core::Vec3;
    fn local_offset_mut(&mut self) -> &mut super::core::Vec3;
    fn mode(&self) -> &super::render_base::LocalIBLMode;
    fn mode_mut(&mut self) -> &mut super::render_base::LocalIBLMode;
    fn capture_distance(&self) -> &f32;
    fn capture_distance_mut(&mut self) -> &mut f32;
    fn capture_fade_distance(&self) -> &f32;
    fn capture_fade_distance_mut(&mut self) -> &mut f32;
    fn influence_expand_distance(&self) -> &f32;
    fn influence_expand_distance_mut(&mut self) -> &mut f32;
    fn influence_fade_distance(&self) -> &f32;
    fn influence_fade_distance_mut(&mut self) -> &mut f32;
    fn update_when_moving(&self) -> &bool;
    fn update_when_moving_mut(&mut self) -> &mut bool;
    fn capture_sky(&self) -> &bool;
    fn capture_sky_mut(&mut self) -> &mut bool;
    fn capture_sky_mask(&self) -> &bool;
    fn capture_sky_mask_mut(&mut self) -> &mut bool;
    fn use_sky_visibility_as_a_o(&self) -> &bool;
    fn use_sky_visibility_as_a_o_mut(&mut self) -> &mut bool;
    fn use_sky_visibility_as_mask(&self) -> &bool;
    fn use_sky_visibility_as_mask_mut(&mut self) -> &mut bool;
    fn sharpen_sky_visibility(&self) -> &f32;
    fn sharpen_sky_visibility_mut(&mut self) -> &mut f32;
    fn bias_sky_visibility(&self) -> &f32;
    fn bias_sky_visibility_mut(&mut self) -> &mut f32;
    fn use_proxy_reprojection(&self) -> &bool;
    fn use_proxy_reprojection_mut(&mut self) -> &mut bool;
    fn capture_fog(&self) -> &bool;
    fn capture_fog_mut(&mut self) -> &mut bool;
    fn object_layers(&self) -> &u16;
    fn object_layers_mut(&mut self) -> &mut u16;
    fn do_not_update_baked_texture(&self) -> &bool;
    fn do_not_update_baked_texture_mut(&mut self) -> &mut bool;
    fn baked_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn baked_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
    fn is_visible(&self) -> &bool;
    fn is_visible_mut(&mut self) -> &mut bool;
}

impl PbrBoxReflectionVolumeEntityDataTrait for PbrBoxReflectionVolumeEntityData {
    fn influence_fade_normal(&self) -> &super::core::Vec3 {
        &self.influence_fade_normal
    }
    fn influence_fade_normal_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.influence_fade_normal
    }
    fn side_fade_pos_x(&self) -> &f32 {
        &self.side_fade_pos_x
    }
    fn side_fade_pos_x_mut(&mut self) -> &mut f32 {
        &mut self.side_fade_pos_x
    }
    fn side_fade_neg_x(&self) -> &f32 {
        &self.side_fade_neg_x
    }
    fn side_fade_neg_x_mut(&mut self) -> &mut f32 {
        &mut self.side_fade_neg_x
    }
    fn side_fade_pos_y(&self) -> &f32 {
        &self.side_fade_pos_y
    }
    fn side_fade_pos_y_mut(&mut self) -> &mut f32 {
        &mut self.side_fade_pos_y
    }
    fn side_fade_neg_y(&self) -> &f32 {
        &self.side_fade_neg_y
    }
    fn side_fade_neg_y_mut(&mut self) -> &mut f32 {
        &mut self.side_fade_neg_y
    }
    fn side_fade_pos_z(&self) -> &f32 {
        &self.side_fade_pos_z
    }
    fn side_fade_pos_z_mut(&mut self) -> &mut f32 {
        &mut self.side_fade_pos_z
    }
    fn side_fade_neg_z(&self) -> &f32 {
        &self.side_fade_neg_z
    }
    fn side_fade_neg_z_mut(&mut self) -> &mut f32 {
        &mut self.side_fade_neg_z
    }
    fn local_offset(&self) -> &super::core::Vec3 {
        &self.local_offset
    }
    fn local_offset_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.local_offset
    }
    fn mode(&self) -> &super::render_base::LocalIBLMode {
        &self.mode
    }
    fn mode_mut(&mut self) -> &mut super::render_base::LocalIBLMode {
        &mut self.mode
    }
    fn capture_distance(&self) -> &f32 {
        &self.capture_distance
    }
    fn capture_distance_mut(&mut self) -> &mut f32 {
        &mut self.capture_distance
    }
    fn capture_fade_distance(&self) -> &f32 {
        &self.capture_fade_distance
    }
    fn capture_fade_distance_mut(&mut self) -> &mut f32 {
        &mut self.capture_fade_distance
    }
    fn influence_expand_distance(&self) -> &f32 {
        &self.influence_expand_distance
    }
    fn influence_expand_distance_mut(&mut self) -> &mut f32 {
        &mut self.influence_expand_distance
    }
    fn influence_fade_distance(&self) -> &f32 {
        &self.influence_fade_distance
    }
    fn influence_fade_distance_mut(&mut self) -> &mut f32 {
        &mut self.influence_fade_distance
    }
    fn update_when_moving(&self) -> &bool {
        &self.update_when_moving
    }
    fn update_when_moving_mut(&mut self) -> &mut bool {
        &mut self.update_when_moving
    }
    fn capture_sky(&self) -> &bool {
        &self.capture_sky
    }
    fn capture_sky_mut(&mut self) -> &mut bool {
        &mut self.capture_sky
    }
    fn capture_sky_mask(&self) -> &bool {
        &self.capture_sky_mask
    }
    fn capture_sky_mask_mut(&mut self) -> &mut bool {
        &mut self.capture_sky_mask
    }
    fn use_sky_visibility_as_a_o(&self) -> &bool {
        &self.use_sky_visibility_as_a_o
    }
    fn use_sky_visibility_as_a_o_mut(&mut self) -> &mut bool {
        &mut self.use_sky_visibility_as_a_o
    }
    fn use_sky_visibility_as_mask(&self) -> &bool {
        &self.use_sky_visibility_as_mask
    }
    fn use_sky_visibility_as_mask_mut(&mut self) -> &mut bool {
        &mut self.use_sky_visibility_as_mask
    }
    fn sharpen_sky_visibility(&self) -> &f32 {
        &self.sharpen_sky_visibility
    }
    fn sharpen_sky_visibility_mut(&mut self) -> &mut f32 {
        &mut self.sharpen_sky_visibility
    }
    fn bias_sky_visibility(&self) -> &f32 {
        &self.bias_sky_visibility
    }
    fn bias_sky_visibility_mut(&mut self) -> &mut f32 {
        &mut self.bias_sky_visibility
    }
    fn use_proxy_reprojection(&self) -> &bool {
        &self.use_proxy_reprojection
    }
    fn use_proxy_reprojection_mut(&mut self) -> &mut bool {
        &mut self.use_proxy_reprojection
    }
    fn capture_fog(&self) -> &bool {
        &self.capture_fog
    }
    fn capture_fog_mut(&mut self) -> &mut bool {
        &mut self.capture_fog
    }
    fn object_layers(&self) -> &u16 {
        &self.object_layers
    }
    fn object_layers_mut(&mut self) -> &mut u16 {
        &mut self.object_layers
    }
    fn do_not_update_baked_texture(&self) -> &bool {
        &self.do_not_update_baked_texture
    }
    fn do_not_update_baked_texture_mut(&mut self) -> &mut bool {
        &mut self.do_not_update_baked_texture
    }
    fn baked_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &self.baked_texture
    }
    fn baked_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &mut self.baked_texture
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
    fn is_visible(&self) -> &bool {
        &self.is_visible
    }
    fn is_visible_mut(&mut self) -> &mut bool {
        &mut self.is_visible
    }
}

impl PbrGenericBoxReflectionVolumeEntityDataTrait for PbrBoxReflectionVolumeEntityData {
}

impl PbrReflectionVolumeEntityDataTrait for PbrBoxReflectionVolumeEntityData {
}

impl BakeableTextureEntityDataTrait for PbrBoxReflectionVolumeEntityData {
}

impl super::entity::SpatialEntityDataTrait for PbrBoxReflectionVolumeEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for PbrBoxReflectionVolumeEntityData {
}

impl super::entity::GameObjectDataTrait for PbrBoxReflectionVolumeEntityData {
}

impl super::core::DataBusPeerTrait for PbrBoxReflectionVolumeEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PbrBoxReflectionVolumeEntityData {
}

impl super::core::DataContainerTrait for PbrBoxReflectionVolumeEntityData {
}

pub static PBRBOXREFLECTIONVOLUMEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PbrBoxReflectionVolumeEntityData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PBRGENERICBOXREFLECTIONVOLUMEENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PbrBoxReflectionVolumeEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "InfluenceFadeNormal",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(PbrBoxReflectionVolumeEntityData, influence_fade_normal),
            },
            FieldInfoData {
                name: "SideFadePosX",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrBoxReflectionVolumeEntityData, side_fade_pos_x),
            },
            FieldInfoData {
                name: "SideFadeNegX",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrBoxReflectionVolumeEntityData, side_fade_neg_x),
            },
            FieldInfoData {
                name: "SideFadePosY",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrBoxReflectionVolumeEntityData, side_fade_pos_y),
            },
            FieldInfoData {
                name: "SideFadeNegY",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrBoxReflectionVolumeEntityData, side_fade_neg_y),
            },
            FieldInfoData {
                name: "SideFadePosZ",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrBoxReflectionVolumeEntityData, side_fade_pos_z),
            },
            FieldInfoData {
                name: "SideFadeNegZ",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrBoxReflectionVolumeEntityData, side_fade_neg_z),
            },
            FieldInfoData {
                name: "LocalOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(PbrBoxReflectionVolumeEntityData, local_offset),
            },
            FieldInfoData {
                name: "Mode",
                flags: MemberInfoFlags::new(0),
                field_type: "LocalIBLMode",
                rust_offset: offset_of!(PbrBoxReflectionVolumeEntityData, mode),
            },
            FieldInfoData {
                name: "CaptureDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrBoxReflectionVolumeEntityData, capture_distance),
            },
            FieldInfoData {
                name: "CaptureFadeDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrBoxReflectionVolumeEntityData, capture_fade_distance),
            },
            FieldInfoData {
                name: "InfluenceExpandDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrBoxReflectionVolumeEntityData, influence_expand_distance),
            },
            FieldInfoData {
                name: "InfluenceFadeDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrBoxReflectionVolumeEntityData, influence_fade_distance),
            },
            FieldInfoData {
                name: "UpdateWhenMoving",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrBoxReflectionVolumeEntityData, update_when_moving),
            },
            FieldInfoData {
                name: "CaptureSky",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrBoxReflectionVolumeEntityData, capture_sky),
            },
            FieldInfoData {
                name: "CaptureSkyMask",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrBoxReflectionVolumeEntityData, capture_sky_mask),
            },
            FieldInfoData {
                name: "UseSkyVisibilityAsAO",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrBoxReflectionVolumeEntityData, use_sky_visibility_as_a_o),
            },
            FieldInfoData {
                name: "UseSkyVisibilityAsMask",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrBoxReflectionVolumeEntityData, use_sky_visibility_as_mask),
            },
            FieldInfoData {
                name: "SharpenSkyVisibility",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrBoxReflectionVolumeEntityData, sharpen_sky_visibility),
            },
            FieldInfoData {
                name: "BiasSkyVisibility",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrBoxReflectionVolumeEntityData, bias_sky_visibility),
            },
            FieldInfoData {
                name: "UseProxyReprojection",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrBoxReflectionVolumeEntityData, use_proxy_reprojection),
            },
            FieldInfoData {
                name: "CaptureFog",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrBoxReflectionVolumeEntityData, capture_fog),
            },
            FieldInfoData {
                name: "ObjectLayers",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint16",
                rust_offset: offset_of!(PbrBoxReflectionVolumeEntityData, object_layers),
            },
            FieldInfoData {
                name: "DoNotUpdateBakedTexture",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrBoxReflectionVolumeEntityData, do_not_update_baked_texture),
            },
            FieldInfoData {
                name: "BakedTexture",
                flags: MemberInfoFlags::new(0),
                field_type: "TextureBaseAsset",
                rust_offset: offset_of!(PbrBoxReflectionVolumeEntityData, baked_texture),
            },
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrBoxReflectionVolumeEntityData, enabled),
            },
            FieldInfoData {
                name: "IsVisible",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrBoxReflectionVolumeEntityData, is_visible),
            },
        ],
    }),
    array_type: Some(PBRBOXREFLECTIONVOLUMEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PbrBoxReflectionVolumeEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PBRBOXREFLECTIONVOLUMEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PBRBOXREFLECTIONVOLUMEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PbrBoxReflectionVolumeEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("PbrBoxReflectionVolumeEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PbrGenericBoxReflectionVolumeEntityData {
    pub _glacier_base: PbrReflectionVolumeEntityData,
}

pub trait PbrGenericBoxReflectionVolumeEntityDataTrait: PbrReflectionVolumeEntityDataTrait {
}

impl PbrGenericBoxReflectionVolumeEntityDataTrait for PbrGenericBoxReflectionVolumeEntityData {
}

impl PbrReflectionVolumeEntityDataTrait for PbrGenericBoxReflectionVolumeEntityData {
}

impl BakeableTextureEntityDataTrait for PbrGenericBoxReflectionVolumeEntityData {
}

impl super::entity::SpatialEntityDataTrait for PbrGenericBoxReflectionVolumeEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for PbrGenericBoxReflectionVolumeEntityData {
}

impl super::entity::GameObjectDataTrait for PbrGenericBoxReflectionVolumeEntityData {
}

impl super::core::DataBusPeerTrait for PbrGenericBoxReflectionVolumeEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PbrGenericBoxReflectionVolumeEntityData {
}

impl super::core::DataContainerTrait for PbrGenericBoxReflectionVolumeEntityData {
}

pub static PBRGENERICBOXREFLECTIONVOLUMEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PbrGenericBoxReflectionVolumeEntityData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PBRREFLECTIONVOLUMEENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PbrGenericBoxReflectionVolumeEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(PBRGENERICBOXREFLECTIONVOLUMEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PbrGenericBoxReflectionVolumeEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PBRGENERICBOXREFLECTIONVOLUMEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PBRGENERICBOXREFLECTIONVOLUMEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PbrGenericBoxReflectionVolumeEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("PbrGenericBoxReflectionVolumeEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PbrSphereReflectionVolumeEntityData {
    pub _glacier_base: PbrReflectionVolumeEntityData,
    pub influence_fade_normal: f32,
    pub mode: super::render_base::LocalIBLMode,
    pub capture_distance: f32,
    pub capture_fade_distance: f32,
    pub influence_expand_distance: f32,
    pub influence_fade_distance: f32,
    pub update_when_moving: bool,
    pub capture_sky: bool,
    pub capture_sky_mask: bool,
    pub use_sky_visibility_as_a_o: bool,
    pub use_sky_visibility_as_mask: bool,
    pub sharpen_sky_visibility: f32,
    pub bias_sky_visibility: f32,
    pub use_proxy_reprojection: bool,
    pub capture_fog: bool,
    pub object_layers: u16,
    pub do_not_update_baked_texture: bool,
    pub baked_texture: Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>,
    pub enabled: bool,
    pub is_visible: bool,
}

pub trait PbrSphereReflectionVolumeEntityDataTrait: PbrReflectionVolumeEntityDataTrait {
    fn influence_fade_normal(&self) -> &f32;
    fn influence_fade_normal_mut(&mut self) -> &mut f32;
    fn mode(&self) -> &super::render_base::LocalIBLMode;
    fn mode_mut(&mut self) -> &mut super::render_base::LocalIBLMode;
    fn capture_distance(&self) -> &f32;
    fn capture_distance_mut(&mut self) -> &mut f32;
    fn capture_fade_distance(&self) -> &f32;
    fn capture_fade_distance_mut(&mut self) -> &mut f32;
    fn influence_expand_distance(&self) -> &f32;
    fn influence_expand_distance_mut(&mut self) -> &mut f32;
    fn influence_fade_distance(&self) -> &f32;
    fn influence_fade_distance_mut(&mut self) -> &mut f32;
    fn update_when_moving(&self) -> &bool;
    fn update_when_moving_mut(&mut self) -> &mut bool;
    fn capture_sky(&self) -> &bool;
    fn capture_sky_mut(&mut self) -> &mut bool;
    fn capture_sky_mask(&self) -> &bool;
    fn capture_sky_mask_mut(&mut self) -> &mut bool;
    fn use_sky_visibility_as_a_o(&self) -> &bool;
    fn use_sky_visibility_as_a_o_mut(&mut self) -> &mut bool;
    fn use_sky_visibility_as_mask(&self) -> &bool;
    fn use_sky_visibility_as_mask_mut(&mut self) -> &mut bool;
    fn sharpen_sky_visibility(&self) -> &f32;
    fn sharpen_sky_visibility_mut(&mut self) -> &mut f32;
    fn bias_sky_visibility(&self) -> &f32;
    fn bias_sky_visibility_mut(&mut self) -> &mut f32;
    fn use_proxy_reprojection(&self) -> &bool;
    fn use_proxy_reprojection_mut(&mut self) -> &mut bool;
    fn capture_fog(&self) -> &bool;
    fn capture_fog_mut(&mut self) -> &mut bool;
    fn object_layers(&self) -> &u16;
    fn object_layers_mut(&mut self) -> &mut u16;
    fn do_not_update_baked_texture(&self) -> &bool;
    fn do_not_update_baked_texture_mut(&mut self) -> &mut bool;
    fn baked_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn baked_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
    fn is_visible(&self) -> &bool;
    fn is_visible_mut(&mut self) -> &mut bool;
}

impl PbrSphereReflectionVolumeEntityDataTrait for PbrSphereReflectionVolumeEntityData {
    fn influence_fade_normal(&self) -> &f32 {
        &self.influence_fade_normal
    }
    fn influence_fade_normal_mut(&mut self) -> &mut f32 {
        &mut self.influence_fade_normal
    }
    fn mode(&self) -> &super::render_base::LocalIBLMode {
        &self.mode
    }
    fn mode_mut(&mut self) -> &mut super::render_base::LocalIBLMode {
        &mut self.mode
    }
    fn capture_distance(&self) -> &f32 {
        &self.capture_distance
    }
    fn capture_distance_mut(&mut self) -> &mut f32 {
        &mut self.capture_distance
    }
    fn capture_fade_distance(&self) -> &f32 {
        &self.capture_fade_distance
    }
    fn capture_fade_distance_mut(&mut self) -> &mut f32 {
        &mut self.capture_fade_distance
    }
    fn influence_expand_distance(&self) -> &f32 {
        &self.influence_expand_distance
    }
    fn influence_expand_distance_mut(&mut self) -> &mut f32 {
        &mut self.influence_expand_distance
    }
    fn influence_fade_distance(&self) -> &f32 {
        &self.influence_fade_distance
    }
    fn influence_fade_distance_mut(&mut self) -> &mut f32 {
        &mut self.influence_fade_distance
    }
    fn update_when_moving(&self) -> &bool {
        &self.update_when_moving
    }
    fn update_when_moving_mut(&mut self) -> &mut bool {
        &mut self.update_when_moving
    }
    fn capture_sky(&self) -> &bool {
        &self.capture_sky
    }
    fn capture_sky_mut(&mut self) -> &mut bool {
        &mut self.capture_sky
    }
    fn capture_sky_mask(&self) -> &bool {
        &self.capture_sky_mask
    }
    fn capture_sky_mask_mut(&mut self) -> &mut bool {
        &mut self.capture_sky_mask
    }
    fn use_sky_visibility_as_a_o(&self) -> &bool {
        &self.use_sky_visibility_as_a_o
    }
    fn use_sky_visibility_as_a_o_mut(&mut self) -> &mut bool {
        &mut self.use_sky_visibility_as_a_o
    }
    fn use_sky_visibility_as_mask(&self) -> &bool {
        &self.use_sky_visibility_as_mask
    }
    fn use_sky_visibility_as_mask_mut(&mut self) -> &mut bool {
        &mut self.use_sky_visibility_as_mask
    }
    fn sharpen_sky_visibility(&self) -> &f32 {
        &self.sharpen_sky_visibility
    }
    fn sharpen_sky_visibility_mut(&mut self) -> &mut f32 {
        &mut self.sharpen_sky_visibility
    }
    fn bias_sky_visibility(&self) -> &f32 {
        &self.bias_sky_visibility
    }
    fn bias_sky_visibility_mut(&mut self) -> &mut f32 {
        &mut self.bias_sky_visibility
    }
    fn use_proxy_reprojection(&self) -> &bool {
        &self.use_proxy_reprojection
    }
    fn use_proxy_reprojection_mut(&mut self) -> &mut bool {
        &mut self.use_proxy_reprojection
    }
    fn capture_fog(&self) -> &bool {
        &self.capture_fog
    }
    fn capture_fog_mut(&mut self) -> &mut bool {
        &mut self.capture_fog
    }
    fn object_layers(&self) -> &u16 {
        &self.object_layers
    }
    fn object_layers_mut(&mut self) -> &mut u16 {
        &mut self.object_layers
    }
    fn do_not_update_baked_texture(&self) -> &bool {
        &self.do_not_update_baked_texture
    }
    fn do_not_update_baked_texture_mut(&mut self) -> &mut bool {
        &mut self.do_not_update_baked_texture
    }
    fn baked_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &self.baked_texture
    }
    fn baked_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &mut self.baked_texture
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
    fn is_visible(&self) -> &bool {
        &self.is_visible
    }
    fn is_visible_mut(&mut self) -> &mut bool {
        &mut self.is_visible
    }
}

impl PbrReflectionVolumeEntityDataTrait for PbrSphereReflectionVolumeEntityData {
}

impl BakeableTextureEntityDataTrait for PbrSphereReflectionVolumeEntityData {
}

impl super::entity::SpatialEntityDataTrait for PbrSphereReflectionVolumeEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for PbrSphereReflectionVolumeEntityData {
}

impl super::entity::GameObjectDataTrait for PbrSphereReflectionVolumeEntityData {
}

impl super::core::DataBusPeerTrait for PbrSphereReflectionVolumeEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PbrSphereReflectionVolumeEntityData {
}

impl super::core::DataContainerTrait for PbrSphereReflectionVolumeEntityData {
}

pub static PBRSPHEREREFLECTIONVOLUMEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PbrSphereReflectionVolumeEntityData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PBRREFLECTIONVOLUMEENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PbrSphereReflectionVolumeEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "InfluenceFadeNormal",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrSphereReflectionVolumeEntityData, influence_fade_normal),
            },
            FieldInfoData {
                name: "Mode",
                flags: MemberInfoFlags::new(0),
                field_type: "LocalIBLMode",
                rust_offset: offset_of!(PbrSphereReflectionVolumeEntityData, mode),
            },
            FieldInfoData {
                name: "CaptureDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrSphereReflectionVolumeEntityData, capture_distance),
            },
            FieldInfoData {
                name: "CaptureFadeDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrSphereReflectionVolumeEntityData, capture_fade_distance),
            },
            FieldInfoData {
                name: "InfluenceExpandDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrSphereReflectionVolumeEntityData, influence_expand_distance),
            },
            FieldInfoData {
                name: "InfluenceFadeDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrSphereReflectionVolumeEntityData, influence_fade_distance),
            },
            FieldInfoData {
                name: "UpdateWhenMoving",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrSphereReflectionVolumeEntityData, update_when_moving),
            },
            FieldInfoData {
                name: "CaptureSky",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrSphereReflectionVolumeEntityData, capture_sky),
            },
            FieldInfoData {
                name: "CaptureSkyMask",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrSphereReflectionVolumeEntityData, capture_sky_mask),
            },
            FieldInfoData {
                name: "UseSkyVisibilityAsAO",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrSphereReflectionVolumeEntityData, use_sky_visibility_as_a_o),
            },
            FieldInfoData {
                name: "UseSkyVisibilityAsMask",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrSphereReflectionVolumeEntityData, use_sky_visibility_as_mask),
            },
            FieldInfoData {
                name: "SharpenSkyVisibility",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrSphereReflectionVolumeEntityData, sharpen_sky_visibility),
            },
            FieldInfoData {
                name: "BiasSkyVisibility",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrSphereReflectionVolumeEntityData, bias_sky_visibility),
            },
            FieldInfoData {
                name: "UseProxyReprojection",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrSphereReflectionVolumeEntityData, use_proxy_reprojection),
            },
            FieldInfoData {
                name: "CaptureFog",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrSphereReflectionVolumeEntityData, capture_fog),
            },
            FieldInfoData {
                name: "ObjectLayers",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint16",
                rust_offset: offset_of!(PbrSphereReflectionVolumeEntityData, object_layers),
            },
            FieldInfoData {
                name: "DoNotUpdateBakedTexture",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrSphereReflectionVolumeEntityData, do_not_update_baked_texture),
            },
            FieldInfoData {
                name: "BakedTexture",
                flags: MemberInfoFlags::new(0),
                field_type: "TextureBaseAsset",
                rust_offset: offset_of!(PbrSphereReflectionVolumeEntityData, baked_texture),
            },
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrSphereReflectionVolumeEntityData, enabled),
            },
            FieldInfoData {
                name: "IsVisible",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrSphereReflectionVolumeEntityData, is_visible),
            },
        ],
    }),
    array_type: Some(PBRSPHEREREFLECTIONVOLUMEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PbrSphereReflectionVolumeEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PBRSPHEREREFLECTIONVOLUMEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PBRSPHEREREFLECTIONVOLUMEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PbrSphereReflectionVolumeEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("PbrSphereReflectionVolumeEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PbrReflectionVolumeEntityData {
    pub _glacier_base: BakeableTextureEntityData,
}

pub trait PbrReflectionVolumeEntityDataTrait: BakeableTextureEntityDataTrait {
}

impl PbrReflectionVolumeEntityDataTrait for PbrReflectionVolumeEntityData {
}

impl BakeableTextureEntityDataTrait for PbrReflectionVolumeEntityData {
}

impl super::entity::SpatialEntityDataTrait for PbrReflectionVolumeEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for PbrReflectionVolumeEntityData {
}

impl super::entity::GameObjectDataTrait for PbrReflectionVolumeEntityData {
}

impl super::core::DataBusPeerTrait for PbrReflectionVolumeEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PbrReflectionVolumeEntityData {
}

impl super::core::DataContainerTrait for PbrReflectionVolumeEntityData {
}

pub static PBRREFLECTIONVOLUMEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PbrReflectionVolumeEntityData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(BAKEABLETEXTUREENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PbrReflectionVolumeEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(PBRREFLECTIONVOLUMEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PbrReflectionVolumeEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PBRREFLECTIONVOLUMEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PBRREFLECTIONVOLUMEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PbrReflectionVolumeEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("PbrReflectionVolumeEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PbrRectangularLightEntityData {
    pub _glacier_base: PbrAnalyticLightEntityData,
    pub shape: super::render_base::RectangularLightShape,
    pub outer_angle: f32,
    pub aspect: f32,
    pub width: f32,
    pub height: f32,
    pub texture: Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>,
    pub shadow_max_angle: f32,
    pub shadow_fade_out_range: f32,
    pub color: super::core::Vec3,
    pub intensity: f32,
    pub exposure_compensation: f32,
    pub attenuation_radius: f32,
    pub emissive_shape_enable: bool,
    pub attenuation_offset: f32,
    pub light_unit: super::render_base::LightUnitType,
    pub affect_diffuse: bool,
    pub affect_specular: bool,
    pub particle_color_scale: super::core::Vec3,
    pub cast_shadows: super::core::QualityScalableEnabled,
    pub cast_volumetric: super::core::QualityScalableEnabled,
    pub cast_volumetric_shadows: super::core::QualityScalableEnabled,
    pub shadow_resolution: super::core::QualityLevel,
    pub shadow_near_radius: f32,
    pub shadow_far_radius: f32,
    pub shadow_dimmer: f32,
    pub cast_shadows_enable: bool,
    pub cast_volumetric_shadows_enable: bool,
    pub affect_radiosity: bool,
    pub radiosity_color_scale: super::core::Vec3,
    pub dimmer: f32,
    pub cull_screen_area: f32,
    pub fade_screen_area: f32,
    pub cull_distance: f32,
    pub fade_distance: f32,
    pub shadow_cull_screen_area: f32,
    pub shadow_fade_screen_area: f32,
    pub shadow_cull_distance: f32,
    pub shadow_fade_distance: f32,
    pub direct_lightmap_enable: bool,
    pub shadow_cache_enable: bool,
    pub shadow_cache_update_priority: f32,
    pub shadow_cache_update_counter: u32,
}

pub trait PbrRectangularLightEntityDataTrait: PbrAnalyticLightEntityDataTrait {
    fn shape(&self) -> &super::render_base::RectangularLightShape;
    fn shape_mut(&mut self) -> &mut super::render_base::RectangularLightShape;
    fn outer_angle(&self) -> &f32;
    fn outer_angle_mut(&mut self) -> &mut f32;
    fn aspect(&self) -> &f32;
    fn aspect_mut(&mut self) -> &mut f32;
    fn width(&self) -> &f32;
    fn width_mut(&mut self) -> &mut f32;
    fn height(&self) -> &f32;
    fn height_mut(&mut self) -> &mut f32;
    fn texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn shadow_max_angle(&self) -> &f32;
    fn shadow_max_angle_mut(&mut self) -> &mut f32;
    fn shadow_fade_out_range(&self) -> &f32;
    fn shadow_fade_out_range_mut(&mut self) -> &mut f32;
    fn color(&self) -> &super::core::Vec3;
    fn color_mut(&mut self) -> &mut super::core::Vec3;
    fn intensity(&self) -> &f32;
    fn intensity_mut(&mut self) -> &mut f32;
    fn exposure_compensation(&self) -> &f32;
    fn exposure_compensation_mut(&mut self) -> &mut f32;
    fn attenuation_radius(&self) -> &f32;
    fn attenuation_radius_mut(&mut self) -> &mut f32;
    fn emissive_shape_enable(&self) -> &bool;
    fn emissive_shape_enable_mut(&mut self) -> &mut bool;
    fn attenuation_offset(&self) -> &f32;
    fn attenuation_offset_mut(&mut self) -> &mut f32;
    fn light_unit(&self) -> &super::render_base::LightUnitType;
    fn light_unit_mut(&mut self) -> &mut super::render_base::LightUnitType;
    fn affect_diffuse(&self) -> &bool;
    fn affect_diffuse_mut(&mut self) -> &mut bool;
    fn affect_specular(&self) -> &bool;
    fn affect_specular_mut(&mut self) -> &mut bool;
    fn particle_color_scale(&self) -> &super::core::Vec3;
    fn particle_color_scale_mut(&mut self) -> &mut super::core::Vec3;
    fn cast_shadows(&self) -> &super::core::QualityScalableEnabled;
    fn cast_shadows_mut(&mut self) -> &mut super::core::QualityScalableEnabled;
    fn cast_volumetric(&self) -> &super::core::QualityScalableEnabled;
    fn cast_volumetric_mut(&mut self) -> &mut super::core::QualityScalableEnabled;
    fn cast_volumetric_shadows(&self) -> &super::core::QualityScalableEnabled;
    fn cast_volumetric_shadows_mut(&mut self) -> &mut super::core::QualityScalableEnabled;
    fn shadow_resolution(&self) -> &super::core::QualityLevel;
    fn shadow_resolution_mut(&mut self) -> &mut super::core::QualityLevel;
    fn shadow_near_radius(&self) -> &f32;
    fn shadow_near_radius_mut(&mut self) -> &mut f32;
    fn shadow_far_radius(&self) -> &f32;
    fn shadow_far_radius_mut(&mut self) -> &mut f32;
    fn shadow_dimmer(&self) -> &f32;
    fn shadow_dimmer_mut(&mut self) -> &mut f32;
    fn cast_shadows_enable(&self) -> &bool;
    fn cast_shadows_enable_mut(&mut self) -> &mut bool;
    fn cast_volumetric_shadows_enable(&self) -> &bool;
    fn cast_volumetric_shadows_enable_mut(&mut self) -> &mut bool;
    fn affect_radiosity(&self) -> &bool;
    fn affect_radiosity_mut(&mut self) -> &mut bool;
    fn radiosity_color_scale(&self) -> &super::core::Vec3;
    fn radiosity_color_scale_mut(&mut self) -> &mut super::core::Vec3;
    fn dimmer(&self) -> &f32;
    fn dimmer_mut(&mut self) -> &mut f32;
    fn cull_screen_area(&self) -> &f32;
    fn cull_screen_area_mut(&mut self) -> &mut f32;
    fn fade_screen_area(&self) -> &f32;
    fn fade_screen_area_mut(&mut self) -> &mut f32;
    fn cull_distance(&self) -> &f32;
    fn cull_distance_mut(&mut self) -> &mut f32;
    fn fade_distance(&self) -> &f32;
    fn fade_distance_mut(&mut self) -> &mut f32;
    fn shadow_cull_screen_area(&self) -> &f32;
    fn shadow_cull_screen_area_mut(&mut self) -> &mut f32;
    fn shadow_fade_screen_area(&self) -> &f32;
    fn shadow_fade_screen_area_mut(&mut self) -> &mut f32;
    fn shadow_cull_distance(&self) -> &f32;
    fn shadow_cull_distance_mut(&mut self) -> &mut f32;
    fn shadow_fade_distance(&self) -> &f32;
    fn shadow_fade_distance_mut(&mut self) -> &mut f32;
    fn direct_lightmap_enable(&self) -> &bool;
    fn direct_lightmap_enable_mut(&mut self) -> &mut bool;
    fn shadow_cache_enable(&self) -> &bool;
    fn shadow_cache_enable_mut(&mut self) -> &mut bool;
    fn shadow_cache_update_priority(&self) -> &f32;
    fn shadow_cache_update_priority_mut(&mut self) -> &mut f32;
    fn shadow_cache_update_counter(&self) -> &u32;
    fn shadow_cache_update_counter_mut(&mut self) -> &mut u32;
}

impl PbrRectangularLightEntityDataTrait for PbrRectangularLightEntityData {
    fn shape(&self) -> &super::render_base::RectangularLightShape {
        &self.shape
    }
    fn shape_mut(&mut self) -> &mut super::render_base::RectangularLightShape {
        &mut self.shape
    }
    fn outer_angle(&self) -> &f32 {
        &self.outer_angle
    }
    fn outer_angle_mut(&mut self) -> &mut f32 {
        &mut self.outer_angle
    }
    fn aspect(&self) -> &f32 {
        &self.aspect
    }
    fn aspect_mut(&mut self) -> &mut f32 {
        &mut self.aspect
    }
    fn width(&self) -> &f32 {
        &self.width
    }
    fn width_mut(&mut self) -> &mut f32 {
        &mut self.width
    }
    fn height(&self) -> &f32 {
        &self.height
    }
    fn height_mut(&mut self) -> &mut f32 {
        &mut self.height
    }
    fn texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &self.texture
    }
    fn texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &mut self.texture
    }
    fn shadow_max_angle(&self) -> &f32 {
        &self.shadow_max_angle
    }
    fn shadow_max_angle_mut(&mut self) -> &mut f32 {
        &mut self.shadow_max_angle
    }
    fn shadow_fade_out_range(&self) -> &f32 {
        &self.shadow_fade_out_range
    }
    fn shadow_fade_out_range_mut(&mut self) -> &mut f32 {
        &mut self.shadow_fade_out_range
    }
    fn color(&self) -> &super::core::Vec3 {
        &self.color
    }
    fn color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.color
    }
    fn intensity(&self) -> &f32 {
        &self.intensity
    }
    fn intensity_mut(&mut self) -> &mut f32 {
        &mut self.intensity
    }
    fn exposure_compensation(&self) -> &f32 {
        &self.exposure_compensation
    }
    fn exposure_compensation_mut(&mut self) -> &mut f32 {
        &mut self.exposure_compensation
    }
    fn attenuation_radius(&self) -> &f32 {
        &self.attenuation_radius
    }
    fn attenuation_radius_mut(&mut self) -> &mut f32 {
        &mut self.attenuation_radius
    }
    fn emissive_shape_enable(&self) -> &bool {
        &self.emissive_shape_enable
    }
    fn emissive_shape_enable_mut(&mut self) -> &mut bool {
        &mut self.emissive_shape_enable
    }
    fn attenuation_offset(&self) -> &f32 {
        &self.attenuation_offset
    }
    fn attenuation_offset_mut(&mut self) -> &mut f32 {
        &mut self.attenuation_offset
    }
    fn light_unit(&self) -> &super::render_base::LightUnitType {
        &self.light_unit
    }
    fn light_unit_mut(&mut self) -> &mut super::render_base::LightUnitType {
        &mut self.light_unit
    }
    fn affect_diffuse(&self) -> &bool {
        &self.affect_diffuse
    }
    fn affect_diffuse_mut(&mut self) -> &mut bool {
        &mut self.affect_diffuse
    }
    fn affect_specular(&self) -> &bool {
        &self.affect_specular
    }
    fn affect_specular_mut(&mut self) -> &mut bool {
        &mut self.affect_specular
    }
    fn particle_color_scale(&self) -> &super::core::Vec3 {
        &self.particle_color_scale
    }
    fn particle_color_scale_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.particle_color_scale
    }
    fn cast_shadows(&self) -> &super::core::QualityScalableEnabled {
        &self.cast_shadows
    }
    fn cast_shadows_mut(&mut self) -> &mut super::core::QualityScalableEnabled {
        &mut self.cast_shadows
    }
    fn cast_volumetric(&self) -> &super::core::QualityScalableEnabled {
        &self.cast_volumetric
    }
    fn cast_volumetric_mut(&mut self) -> &mut super::core::QualityScalableEnabled {
        &mut self.cast_volumetric
    }
    fn cast_volumetric_shadows(&self) -> &super::core::QualityScalableEnabled {
        &self.cast_volumetric_shadows
    }
    fn cast_volumetric_shadows_mut(&mut self) -> &mut super::core::QualityScalableEnabled {
        &mut self.cast_volumetric_shadows
    }
    fn shadow_resolution(&self) -> &super::core::QualityLevel {
        &self.shadow_resolution
    }
    fn shadow_resolution_mut(&mut self) -> &mut super::core::QualityLevel {
        &mut self.shadow_resolution
    }
    fn shadow_near_radius(&self) -> &f32 {
        &self.shadow_near_radius
    }
    fn shadow_near_radius_mut(&mut self) -> &mut f32 {
        &mut self.shadow_near_radius
    }
    fn shadow_far_radius(&self) -> &f32 {
        &self.shadow_far_radius
    }
    fn shadow_far_radius_mut(&mut self) -> &mut f32 {
        &mut self.shadow_far_radius
    }
    fn shadow_dimmer(&self) -> &f32 {
        &self.shadow_dimmer
    }
    fn shadow_dimmer_mut(&mut self) -> &mut f32 {
        &mut self.shadow_dimmer
    }
    fn cast_shadows_enable(&self) -> &bool {
        &self.cast_shadows_enable
    }
    fn cast_shadows_enable_mut(&mut self) -> &mut bool {
        &mut self.cast_shadows_enable
    }
    fn cast_volumetric_shadows_enable(&self) -> &bool {
        &self.cast_volumetric_shadows_enable
    }
    fn cast_volumetric_shadows_enable_mut(&mut self) -> &mut bool {
        &mut self.cast_volumetric_shadows_enable
    }
    fn affect_radiosity(&self) -> &bool {
        &self.affect_radiosity
    }
    fn affect_radiosity_mut(&mut self) -> &mut bool {
        &mut self.affect_radiosity
    }
    fn radiosity_color_scale(&self) -> &super::core::Vec3 {
        &self.radiosity_color_scale
    }
    fn radiosity_color_scale_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.radiosity_color_scale
    }
    fn dimmer(&self) -> &f32 {
        &self.dimmer
    }
    fn dimmer_mut(&mut self) -> &mut f32 {
        &mut self.dimmer
    }
    fn cull_screen_area(&self) -> &f32 {
        &self.cull_screen_area
    }
    fn cull_screen_area_mut(&mut self) -> &mut f32 {
        &mut self.cull_screen_area
    }
    fn fade_screen_area(&self) -> &f32 {
        &self.fade_screen_area
    }
    fn fade_screen_area_mut(&mut self) -> &mut f32 {
        &mut self.fade_screen_area
    }
    fn cull_distance(&self) -> &f32 {
        &self.cull_distance
    }
    fn cull_distance_mut(&mut self) -> &mut f32 {
        &mut self.cull_distance
    }
    fn fade_distance(&self) -> &f32 {
        &self.fade_distance
    }
    fn fade_distance_mut(&mut self) -> &mut f32 {
        &mut self.fade_distance
    }
    fn shadow_cull_screen_area(&self) -> &f32 {
        &self.shadow_cull_screen_area
    }
    fn shadow_cull_screen_area_mut(&mut self) -> &mut f32 {
        &mut self.shadow_cull_screen_area
    }
    fn shadow_fade_screen_area(&self) -> &f32 {
        &self.shadow_fade_screen_area
    }
    fn shadow_fade_screen_area_mut(&mut self) -> &mut f32 {
        &mut self.shadow_fade_screen_area
    }
    fn shadow_cull_distance(&self) -> &f32 {
        &self.shadow_cull_distance
    }
    fn shadow_cull_distance_mut(&mut self) -> &mut f32 {
        &mut self.shadow_cull_distance
    }
    fn shadow_fade_distance(&self) -> &f32 {
        &self.shadow_fade_distance
    }
    fn shadow_fade_distance_mut(&mut self) -> &mut f32 {
        &mut self.shadow_fade_distance
    }
    fn direct_lightmap_enable(&self) -> &bool {
        &self.direct_lightmap_enable
    }
    fn direct_lightmap_enable_mut(&mut self) -> &mut bool {
        &mut self.direct_lightmap_enable
    }
    fn shadow_cache_enable(&self) -> &bool {
        &self.shadow_cache_enable
    }
    fn shadow_cache_enable_mut(&mut self) -> &mut bool {
        &mut self.shadow_cache_enable
    }
    fn shadow_cache_update_priority(&self) -> &f32 {
        &self.shadow_cache_update_priority
    }
    fn shadow_cache_update_priority_mut(&mut self) -> &mut f32 {
        &mut self.shadow_cache_update_priority
    }
    fn shadow_cache_update_counter(&self) -> &u32 {
        &self.shadow_cache_update_counter
    }
    fn shadow_cache_update_counter_mut(&mut self) -> &mut u32 {
        &mut self.shadow_cache_update_counter
    }
}

impl PbrAnalyticLightEntityDataTrait for PbrRectangularLightEntityData {
}

impl LocalLightEntityDataTrait for PbrRectangularLightEntityData {
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for PbrRectangularLightEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for PbrRectangularLightEntityData {
}

impl super::entity::GameObjectDataTrait for PbrRectangularLightEntityData {
}

impl super::core::DataBusPeerTrait for PbrRectangularLightEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PbrRectangularLightEntityData {
}

impl super::core::DataContainerTrait for PbrRectangularLightEntityData {
}

pub static PBRRECTANGULARLIGHTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PbrRectangularLightEntityData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PBRANALYTICLIGHTENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PbrRectangularLightEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Shape",
                flags: MemberInfoFlags::new(0),
                field_type: "RectangularLightShape",
                rust_offset: offset_of!(PbrRectangularLightEntityData, shape),
            },
            FieldInfoData {
                name: "OuterAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrRectangularLightEntityData, outer_angle),
            },
            FieldInfoData {
                name: "Aspect",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrRectangularLightEntityData, aspect),
            },
            FieldInfoData {
                name: "Width",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrRectangularLightEntityData, width),
            },
            FieldInfoData {
                name: "Height",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrRectangularLightEntityData, height),
            },
            FieldInfoData {
                name: "Texture",
                flags: MemberInfoFlags::new(0),
                field_type: "TextureBaseAsset",
                rust_offset: offset_of!(PbrRectangularLightEntityData, texture),
            },
            FieldInfoData {
                name: "ShadowMaxAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrRectangularLightEntityData, shadow_max_angle),
            },
            FieldInfoData {
                name: "ShadowFadeOutRange",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrRectangularLightEntityData, shadow_fade_out_range),
            },
            FieldInfoData {
                name: "Color",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(PbrRectangularLightEntityData, color),
            },
            FieldInfoData {
                name: "Intensity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrRectangularLightEntityData, intensity),
            },
            FieldInfoData {
                name: "ExposureCompensation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrRectangularLightEntityData, exposure_compensation),
            },
            FieldInfoData {
                name: "AttenuationRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrRectangularLightEntityData, attenuation_radius),
            },
            FieldInfoData {
                name: "EmissiveShapeEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrRectangularLightEntityData, emissive_shape_enable),
            },
            FieldInfoData {
                name: "AttenuationOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrRectangularLightEntityData, attenuation_offset),
            },
            FieldInfoData {
                name: "LightUnit",
                flags: MemberInfoFlags::new(0),
                field_type: "LightUnitType",
                rust_offset: offset_of!(PbrRectangularLightEntityData, light_unit),
            },
            FieldInfoData {
                name: "AffectDiffuse",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrRectangularLightEntityData, affect_diffuse),
            },
            FieldInfoData {
                name: "AffectSpecular",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrRectangularLightEntityData, affect_specular),
            },
            FieldInfoData {
                name: "ParticleColorScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(PbrRectangularLightEntityData, particle_color_scale),
            },
            FieldInfoData {
                name: "CastShadows",
                flags: MemberInfoFlags::new(0),
                field_type: "QualityScalableEnabled",
                rust_offset: offset_of!(PbrRectangularLightEntityData, cast_shadows),
            },
            FieldInfoData {
                name: "CastVolumetric",
                flags: MemberInfoFlags::new(0),
                field_type: "QualityScalableEnabled",
                rust_offset: offset_of!(PbrRectangularLightEntityData, cast_volumetric),
            },
            FieldInfoData {
                name: "CastVolumetricShadows",
                flags: MemberInfoFlags::new(0),
                field_type: "QualityScalableEnabled",
                rust_offset: offset_of!(PbrRectangularLightEntityData, cast_volumetric_shadows),
            },
            FieldInfoData {
                name: "ShadowResolution",
                flags: MemberInfoFlags::new(0),
                field_type: "QualityLevel",
                rust_offset: offset_of!(PbrRectangularLightEntityData, shadow_resolution),
            },
            FieldInfoData {
                name: "ShadowNearRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrRectangularLightEntityData, shadow_near_radius),
            },
            FieldInfoData {
                name: "ShadowFarRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrRectangularLightEntityData, shadow_far_radius),
            },
            FieldInfoData {
                name: "ShadowDimmer",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrRectangularLightEntityData, shadow_dimmer),
            },
            FieldInfoData {
                name: "CastShadowsEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrRectangularLightEntityData, cast_shadows_enable),
            },
            FieldInfoData {
                name: "CastVolumetricShadowsEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrRectangularLightEntityData, cast_volumetric_shadows_enable),
            },
            FieldInfoData {
                name: "AffectRadiosity",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrRectangularLightEntityData, affect_radiosity),
            },
            FieldInfoData {
                name: "RadiosityColorScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(PbrRectangularLightEntityData, radiosity_color_scale),
            },
            FieldInfoData {
                name: "Dimmer",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrRectangularLightEntityData, dimmer),
            },
            FieldInfoData {
                name: "CullScreenArea",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrRectangularLightEntityData, cull_screen_area),
            },
            FieldInfoData {
                name: "FadeScreenArea",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrRectangularLightEntityData, fade_screen_area),
            },
            FieldInfoData {
                name: "CullDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrRectangularLightEntityData, cull_distance),
            },
            FieldInfoData {
                name: "FadeDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrRectangularLightEntityData, fade_distance),
            },
            FieldInfoData {
                name: "ShadowCullScreenArea",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrRectangularLightEntityData, shadow_cull_screen_area),
            },
            FieldInfoData {
                name: "ShadowFadeScreenArea",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrRectangularLightEntityData, shadow_fade_screen_area),
            },
            FieldInfoData {
                name: "ShadowCullDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrRectangularLightEntityData, shadow_cull_distance),
            },
            FieldInfoData {
                name: "ShadowFadeDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrRectangularLightEntityData, shadow_fade_distance),
            },
            FieldInfoData {
                name: "DirectLightmapEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrRectangularLightEntityData, direct_lightmap_enable),
            },
            FieldInfoData {
                name: "ShadowCacheEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrRectangularLightEntityData, shadow_cache_enable),
            },
            FieldInfoData {
                name: "ShadowCacheUpdatePriority",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrRectangularLightEntityData, shadow_cache_update_priority),
            },
            FieldInfoData {
                name: "ShadowCacheUpdateCounter",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(PbrRectangularLightEntityData, shadow_cache_update_counter),
            },
        ],
    }),
    array_type: Some(PBRRECTANGULARLIGHTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PbrRectangularLightEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PBRRECTANGULARLIGHTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PBRRECTANGULARLIGHTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PbrRectangularLightEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("PbrRectangularLightEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PbrTubeLightEntityData {
    pub _glacier_base: PbrAnalyticLightEntityData,
    pub tube_radius: f32,
    pub tube_width: f32,
    pub only_hempishere: bool,
    pub is_capsule: bool,
    pub color: super::core::Vec3,
    pub intensity: f32,
    pub exposure_compensation: f32,
    pub attenuation_radius: f32,
    pub emissive_shape_enable: bool,
    pub attenuation_offset: f32,
    pub light_unit: super::render_base::LightUnitType,
    pub affect_diffuse: bool,
    pub affect_specular: bool,
    pub particle_color_scale: super::core::Vec3,
    pub cast_shadows: super::core::QualityScalableEnabled,
    pub cast_volumetric: super::core::QualityScalableEnabled,
    pub cast_volumetric_shadows: super::core::QualityScalableEnabled,
    pub shadow_resolution: super::core::QualityLevel,
    pub shadow_near_radius: f32,
    pub shadow_far_radius: f32,
    pub shadow_dimmer: f32,
    pub cast_shadows_enable: bool,
    pub cast_volumetric_shadows_enable: bool,
    pub affect_radiosity: bool,
    pub radiosity_color_scale: super::core::Vec3,
    pub dimmer: f32,
    pub cull_screen_area: f32,
    pub fade_screen_area: f32,
    pub cull_distance: f32,
    pub fade_distance: f32,
    pub shadow_cull_screen_area: f32,
    pub shadow_fade_screen_area: f32,
    pub shadow_cull_distance: f32,
    pub shadow_fade_distance: f32,
    pub direct_lightmap_enable: bool,
    pub shadow_cache_enable: bool,
    pub shadow_cache_update_priority: f32,
    pub shadow_cache_update_counter: u32,
}

pub trait PbrTubeLightEntityDataTrait: PbrAnalyticLightEntityDataTrait {
    fn tube_radius(&self) -> &f32;
    fn tube_radius_mut(&mut self) -> &mut f32;
    fn tube_width(&self) -> &f32;
    fn tube_width_mut(&mut self) -> &mut f32;
    fn only_hempishere(&self) -> &bool;
    fn only_hempishere_mut(&mut self) -> &mut bool;
    fn is_capsule(&self) -> &bool;
    fn is_capsule_mut(&mut self) -> &mut bool;
    fn color(&self) -> &super::core::Vec3;
    fn color_mut(&mut self) -> &mut super::core::Vec3;
    fn intensity(&self) -> &f32;
    fn intensity_mut(&mut self) -> &mut f32;
    fn exposure_compensation(&self) -> &f32;
    fn exposure_compensation_mut(&mut self) -> &mut f32;
    fn attenuation_radius(&self) -> &f32;
    fn attenuation_radius_mut(&mut self) -> &mut f32;
    fn emissive_shape_enable(&self) -> &bool;
    fn emissive_shape_enable_mut(&mut self) -> &mut bool;
    fn attenuation_offset(&self) -> &f32;
    fn attenuation_offset_mut(&mut self) -> &mut f32;
    fn light_unit(&self) -> &super::render_base::LightUnitType;
    fn light_unit_mut(&mut self) -> &mut super::render_base::LightUnitType;
    fn affect_diffuse(&self) -> &bool;
    fn affect_diffuse_mut(&mut self) -> &mut bool;
    fn affect_specular(&self) -> &bool;
    fn affect_specular_mut(&mut self) -> &mut bool;
    fn particle_color_scale(&self) -> &super::core::Vec3;
    fn particle_color_scale_mut(&mut self) -> &mut super::core::Vec3;
    fn cast_shadows(&self) -> &super::core::QualityScalableEnabled;
    fn cast_shadows_mut(&mut self) -> &mut super::core::QualityScalableEnabled;
    fn cast_volumetric(&self) -> &super::core::QualityScalableEnabled;
    fn cast_volumetric_mut(&mut self) -> &mut super::core::QualityScalableEnabled;
    fn cast_volumetric_shadows(&self) -> &super::core::QualityScalableEnabled;
    fn cast_volumetric_shadows_mut(&mut self) -> &mut super::core::QualityScalableEnabled;
    fn shadow_resolution(&self) -> &super::core::QualityLevel;
    fn shadow_resolution_mut(&mut self) -> &mut super::core::QualityLevel;
    fn shadow_near_radius(&self) -> &f32;
    fn shadow_near_radius_mut(&mut self) -> &mut f32;
    fn shadow_far_radius(&self) -> &f32;
    fn shadow_far_radius_mut(&mut self) -> &mut f32;
    fn shadow_dimmer(&self) -> &f32;
    fn shadow_dimmer_mut(&mut self) -> &mut f32;
    fn cast_shadows_enable(&self) -> &bool;
    fn cast_shadows_enable_mut(&mut self) -> &mut bool;
    fn cast_volumetric_shadows_enable(&self) -> &bool;
    fn cast_volumetric_shadows_enable_mut(&mut self) -> &mut bool;
    fn affect_radiosity(&self) -> &bool;
    fn affect_radiosity_mut(&mut self) -> &mut bool;
    fn radiosity_color_scale(&self) -> &super::core::Vec3;
    fn radiosity_color_scale_mut(&mut self) -> &mut super::core::Vec3;
    fn dimmer(&self) -> &f32;
    fn dimmer_mut(&mut self) -> &mut f32;
    fn cull_screen_area(&self) -> &f32;
    fn cull_screen_area_mut(&mut self) -> &mut f32;
    fn fade_screen_area(&self) -> &f32;
    fn fade_screen_area_mut(&mut self) -> &mut f32;
    fn cull_distance(&self) -> &f32;
    fn cull_distance_mut(&mut self) -> &mut f32;
    fn fade_distance(&self) -> &f32;
    fn fade_distance_mut(&mut self) -> &mut f32;
    fn shadow_cull_screen_area(&self) -> &f32;
    fn shadow_cull_screen_area_mut(&mut self) -> &mut f32;
    fn shadow_fade_screen_area(&self) -> &f32;
    fn shadow_fade_screen_area_mut(&mut self) -> &mut f32;
    fn shadow_cull_distance(&self) -> &f32;
    fn shadow_cull_distance_mut(&mut self) -> &mut f32;
    fn shadow_fade_distance(&self) -> &f32;
    fn shadow_fade_distance_mut(&mut self) -> &mut f32;
    fn direct_lightmap_enable(&self) -> &bool;
    fn direct_lightmap_enable_mut(&mut self) -> &mut bool;
    fn shadow_cache_enable(&self) -> &bool;
    fn shadow_cache_enable_mut(&mut self) -> &mut bool;
    fn shadow_cache_update_priority(&self) -> &f32;
    fn shadow_cache_update_priority_mut(&mut self) -> &mut f32;
    fn shadow_cache_update_counter(&self) -> &u32;
    fn shadow_cache_update_counter_mut(&mut self) -> &mut u32;
}

impl PbrTubeLightEntityDataTrait for PbrTubeLightEntityData {
    fn tube_radius(&self) -> &f32 {
        &self.tube_radius
    }
    fn tube_radius_mut(&mut self) -> &mut f32 {
        &mut self.tube_radius
    }
    fn tube_width(&self) -> &f32 {
        &self.tube_width
    }
    fn tube_width_mut(&mut self) -> &mut f32 {
        &mut self.tube_width
    }
    fn only_hempishere(&self) -> &bool {
        &self.only_hempishere
    }
    fn only_hempishere_mut(&mut self) -> &mut bool {
        &mut self.only_hempishere
    }
    fn is_capsule(&self) -> &bool {
        &self.is_capsule
    }
    fn is_capsule_mut(&mut self) -> &mut bool {
        &mut self.is_capsule
    }
    fn color(&self) -> &super::core::Vec3 {
        &self.color
    }
    fn color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.color
    }
    fn intensity(&self) -> &f32 {
        &self.intensity
    }
    fn intensity_mut(&mut self) -> &mut f32 {
        &mut self.intensity
    }
    fn exposure_compensation(&self) -> &f32 {
        &self.exposure_compensation
    }
    fn exposure_compensation_mut(&mut self) -> &mut f32 {
        &mut self.exposure_compensation
    }
    fn attenuation_radius(&self) -> &f32 {
        &self.attenuation_radius
    }
    fn attenuation_radius_mut(&mut self) -> &mut f32 {
        &mut self.attenuation_radius
    }
    fn emissive_shape_enable(&self) -> &bool {
        &self.emissive_shape_enable
    }
    fn emissive_shape_enable_mut(&mut self) -> &mut bool {
        &mut self.emissive_shape_enable
    }
    fn attenuation_offset(&self) -> &f32 {
        &self.attenuation_offset
    }
    fn attenuation_offset_mut(&mut self) -> &mut f32 {
        &mut self.attenuation_offset
    }
    fn light_unit(&self) -> &super::render_base::LightUnitType {
        &self.light_unit
    }
    fn light_unit_mut(&mut self) -> &mut super::render_base::LightUnitType {
        &mut self.light_unit
    }
    fn affect_diffuse(&self) -> &bool {
        &self.affect_diffuse
    }
    fn affect_diffuse_mut(&mut self) -> &mut bool {
        &mut self.affect_diffuse
    }
    fn affect_specular(&self) -> &bool {
        &self.affect_specular
    }
    fn affect_specular_mut(&mut self) -> &mut bool {
        &mut self.affect_specular
    }
    fn particle_color_scale(&self) -> &super::core::Vec3 {
        &self.particle_color_scale
    }
    fn particle_color_scale_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.particle_color_scale
    }
    fn cast_shadows(&self) -> &super::core::QualityScalableEnabled {
        &self.cast_shadows
    }
    fn cast_shadows_mut(&mut self) -> &mut super::core::QualityScalableEnabled {
        &mut self.cast_shadows
    }
    fn cast_volumetric(&self) -> &super::core::QualityScalableEnabled {
        &self.cast_volumetric
    }
    fn cast_volumetric_mut(&mut self) -> &mut super::core::QualityScalableEnabled {
        &mut self.cast_volumetric
    }
    fn cast_volumetric_shadows(&self) -> &super::core::QualityScalableEnabled {
        &self.cast_volumetric_shadows
    }
    fn cast_volumetric_shadows_mut(&mut self) -> &mut super::core::QualityScalableEnabled {
        &mut self.cast_volumetric_shadows
    }
    fn shadow_resolution(&self) -> &super::core::QualityLevel {
        &self.shadow_resolution
    }
    fn shadow_resolution_mut(&mut self) -> &mut super::core::QualityLevel {
        &mut self.shadow_resolution
    }
    fn shadow_near_radius(&self) -> &f32 {
        &self.shadow_near_radius
    }
    fn shadow_near_radius_mut(&mut self) -> &mut f32 {
        &mut self.shadow_near_radius
    }
    fn shadow_far_radius(&self) -> &f32 {
        &self.shadow_far_radius
    }
    fn shadow_far_radius_mut(&mut self) -> &mut f32 {
        &mut self.shadow_far_radius
    }
    fn shadow_dimmer(&self) -> &f32 {
        &self.shadow_dimmer
    }
    fn shadow_dimmer_mut(&mut self) -> &mut f32 {
        &mut self.shadow_dimmer
    }
    fn cast_shadows_enable(&self) -> &bool {
        &self.cast_shadows_enable
    }
    fn cast_shadows_enable_mut(&mut self) -> &mut bool {
        &mut self.cast_shadows_enable
    }
    fn cast_volumetric_shadows_enable(&self) -> &bool {
        &self.cast_volumetric_shadows_enable
    }
    fn cast_volumetric_shadows_enable_mut(&mut self) -> &mut bool {
        &mut self.cast_volumetric_shadows_enable
    }
    fn affect_radiosity(&self) -> &bool {
        &self.affect_radiosity
    }
    fn affect_radiosity_mut(&mut self) -> &mut bool {
        &mut self.affect_radiosity
    }
    fn radiosity_color_scale(&self) -> &super::core::Vec3 {
        &self.radiosity_color_scale
    }
    fn radiosity_color_scale_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.radiosity_color_scale
    }
    fn dimmer(&self) -> &f32 {
        &self.dimmer
    }
    fn dimmer_mut(&mut self) -> &mut f32 {
        &mut self.dimmer
    }
    fn cull_screen_area(&self) -> &f32 {
        &self.cull_screen_area
    }
    fn cull_screen_area_mut(&mut self) -> &mut f32 {
        &mut self.cull_screen_area
    }
    fn fade_screen_area(&self) -> &f32 {
        &self.fade_screen_area
    }
    fn fade_screen_area_mut(&mut self) -> &mut f32 {
        &mut self.fade_screen_area
    }
    fn cull_distance(&self) -> &f32 {
        &self.cull_distance
    }
    fn cull_distance_mut(&mut self) -> &mut f32 {
        &mut self.cull_distance
    }
    fn fade_distance(&self) -> &f32 {
        &self.fade_distance
    }
    fn fade_distance_mut(&mut self) -> &mut f32 {
        &mut self.fade_distance
    }
    fn shadow_cull_screen_area(&self) -> &f32 {
        &self.shadow_cull_screen_area
    }
    fn shadow_cull_screen_area_mut(&mut self) -> &mut f32 {
        &mut self.shadow_cull_screen_area
    }
    fn shadow_fade_screen_area(&self) -> &f32 {
        &self.shadow_fade_screen_area
    }
    fn shadow_fade_screen_area_mut(&mut self) -> &mut f32 {
        &mut self.shadow_fade_screen_area
    }
    fn shadow_cull_distance(&self) -> &f32 {
        &self.shadow_cull_distance
    }
    fn shadow_cull_distance_mut(&mut self) -> &mut f32 {
        &mut self.shadow_cull_distance
    }
    fn shadow_fade_distance(&self) -> &f32 {
        &self.shadow_fade_distance
    }
    fn shadow_fade_distance_mut(&mut self) -> &mut f32 {
        &mut self.shadow_fade_distance
    }
    fn direct_lightmap_enable(&self) -> &bool {
        &self.direct_lightmap_enable
    }
    fn direct_lightmap_enable_mut(&mut self) -> &mut bool {
        &mut self.direct_lightmap_enable
    }
    fn shadow_cache_enable(&self) -> &bool {
        &self.shadow_cache_enable
    }
    fn shadow_cache_enable_mut(&mut self) -> &mut bool {
        &mut self.shadow_cache_enable
    }
    fn shadow_cache_update_priority(&self) -> &f32 {
        &self.shadow_cache_update_priority
    }
    fn shadow_cache_update_priority_mut(&mut self) -> &mut f32 {
        &mut self.shadow_cache_update_priority
    }
    fn shadow_cache_update_counter(&self) -> &u32 {
        &self.shadow_cache_update_counter
    }
    fn shadow_cache_update_counter_mut(&mut self) -> &mut u32 {
        &mut self.shadow_cache_update_counter
    }
}

impl PbrAnalyticLightEntityDataTrait for PbrTubeLightEntityData {
}

impl LocalLightEntityDataTrait for PbrTubeLightEntityData {
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for PbrTubeLightEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for PbrTubeLightEntityData {
}

impl super::entity::GameObjectDataTrait for PbrTubeLightEntityData {
}

impl super::core::DataBusPeerTrait for PbrTubeLightEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PbrTubeLightEntityData {
}

impl super::core::DataContainerTrait for PbrTubeLightEntityData {
}

pub static PBRTUBELIGHTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PbrTubeLightEntityData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PBRANALYTICLIGHTENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PbrTubeLightEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "TubeRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrTubeLightEntityData, tube_radius),
            },
            FieldInfoData {
                name: "TubeWidth",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrTubeLightEntityData, tube_width),
            },
            FieldInfoData {
                name: "OnlyHempishere",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrTubeLightEntityData, only_hempishere),
            },
            FieldInfoData {
                name: "IsCapsule",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrTubeLightEntityData, is_capsule),
            },
            FieldInfoData {
                name: "Color",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(PbrTubeLightEntityData, color),
            },
            FieldInfoData {
                name: "Intensity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrTubeLightEntityData, intensity),
            },
            FieldInfoData {
                name: "ExposureCompensation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrTubeLightEntityData, exposure_compensation),
            },
            FieldInfoData {
                name: "AttenuationRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrTubeLightEntityData, attenuation_radius),
            },
            FieldInfoData {
                name: "EmissiveShapeEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrTubeLightEntityData, emissive_shape_enable),
            },
            FieldInfoData {
                name: "AttenuationOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrTubeLightEntityData, attenuation_offset),
            },
            FieldInfoData {
                name: "LightUnit",
                flags: MemberInfoFlags::new(0),
                field_type: "LightUnitType",
                rust_offset: offset_of!(PbrTubeLightEntityData, light_unit),
            },
            FieldInfoData {
                name: "AffectDiffuse",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrTubeLightEntityData, affect_diffuse),
            },
            FieldInfoData {
                name: "AffectSpecular",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrTubeLightEntityData, affect_specular),
            },
            FieldInfoData {
                name: "ParticleColorScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(PbrTubeLightEntityData, particle_color_scale),
            },
            FieldInfoData {
                name: "CastShadows",
                flags: MemberInfoFlags::new(0),
                field_type: "QualityScalableEnabled",
                rust_offset: offset_of!(PbrTubeLightEntityData, cast_shadows),
            },
            FieldInfoData {
                name: "CastVolumetric",
                flags: MemberInfoFlags::new(0),
                field_type: "QualityScalableEnabled",
                rust_offset: offset_of!(PbrTubeLightEntityData, cast_volumetric),
            },
            FieldInfoData {
                name: "CastVolumetricShadows",
                flags: MemberInfoFlags::new(0),
                field_type: "QualityScalableEnabled",
                rust_offset: offset_of!(PbrTubeLightEntityData, cast_volumetric_shadows),
            },
            FieldInfoData {
                name: "ShadowResolution",
                flags: MemberInfoFlags::new(0),
                field_type: "QualityLevel",
                rust_offset: offset_of!(PbrTubeLightEntityData, shadow_resolution),
            },
            FieldInfoData {
                name: "ShadowNearRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrTubeLightEntityData, shadow_near_radius),
            },
            FieldInfoData {
                name: "ShadowFarRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrTubeLightEntityData, shadow_far_radius),
            },
            FieldInfoData {
                name: "ShadowDimmer",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrTubeLightEntityData, shadow_dimmer),
            },
            FieldInfoData {
                name: "CastShadowsEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrTubeLightEntityData, cast_shadows_enable),
            },
            FieldInfoData {
                name: "CastVolumetricShadowsEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrTubeLightEntityData, cast_volumetric_shadows_enable),
            },
            FieldInfoData {
                name: "AffectRadiosity",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrTubeLightEntityData, affect_radiosity),
            },
            FieldInfoData {
                name: "RadiosityColorScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(PbrTubeLightEntityData, radiosity_color_scale),
            },
            FieldInfoData {
                name: "Dimmer",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrTubeLightEntityData, dimmer),
            },
            FieldInfoData {
                name: "CullScreenArea",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrTubeLightEntityData, cull_screen_area),
            },
            FieldInfoData {
                name: "FadeScreenArea",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrTubeLightEntityData, fade_screen_area),
            },
            FieldInfoData {
                name: "CullDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrTubeLightEntityData, cull_distance),
            },
            FieldInfoData {
                name: "FadeDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrTubeLightEntityData, fade_distance),
            },
            FieldInfoData {
                name: "ShadowCullScreenArea",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrTubeLightEntityData, shadow_cull_screen_area),
            },
            FieldInfoData {
                name: "ShadowFadeScreenArea",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrTubeLightEntityData, shadow_fade_screen_area),
            },
            FieldInfoData {
                name: "ShadowCullDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrTubeLightEntityData, shadow_cull_distance),
            },
            FieldInfoData {
                name: "ShadowFadeDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrTubeLightEntityData, shadow_fade_distance),
            },
            FieldInfoData {
                name: "DirectLightmapEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrTubeLightEntityData, direct_lightmap_enable),
            },
            FieldInfoData {
                name: "ShadowCacheEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrTubeLightEntityData, shadow_cache_enable),
            },
            FieldInfoData {
                name: "ShadowCacheUpdatePriority",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrTubeLightEntityData, shadow_cache_update_priority),
            },
            FieldInfoData {
                name: "ShadowCacheUpdateCounter",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(PbrTubeLightEntityData, shadow_cache_update_counter),
            },
        ],
    }),
    array_type: Some(PBRTUBELIGHTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PbrTubeLightEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PBRTUBELIGHTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PBRTUBELIGHTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PbrTubeLightEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("PbrTubeLightEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PbrSpotLightEntityData {
    pub _glacier_base: PbrAnalyticLightEntityData,
    pub disc_radius: f32,
    pub inner_angle: f32,
    pub outer_angle: f32,
    pub i_e_s_profile: Option<Arc<Mutex<dyn super::world_base::IesProfileAssetTrait>>>,
    pub use_i_e_s_profile_as_mask: bool,
    pub i_e_s_multiplier: f32,
    pub shadow_max_angle: f32,
    pub shadow_fade_out_range: f32,
    pub color: super::core::Vec3,
    pub intensity: f32,
    pub exposure_compensation: f32,
    pub attenuation_radius: f32,
    pub emissive_shape_enable: bool,
    pub attenuation_offset: f32,
    pub light_unit: super::render_base::LightUnitType,
    pub affect_diffuse: bool,
    pub affect_specular: bool,
    pub particle_color_scale: super::core::Vec3,
    pub cast_shadows: super::core::QualityScalableEnabled,
    pub cast_volumetric: super::core::QualityScalableEnabled,
    pub cast_volumetric_shadows: super::core::QualityScalableEnabled,
    pub shadow_resolution: super::core::QualityLevel,
    pub shadow_near_radius: f32,
    pub shadow_far_radius: f32,
    pub shadow_dimmer: f32,
    pub cast_shadows_enable: bool,
    pub cast_volumetric_shadows_enable: bool,
    pub affect_radiosity: bool,
    pub radiosity_color_scale: super::core::Vec3,
    pub dimmer: f32,
    pub cull_screen_area: f32,
    pub fade_screen_area: f32,
    pub cull_distance: f32,
    pub fade_distance: f32,
    pub shadow_cull_screen_area: f32,
    pub shadow_fade_screen_area: f32,
    pub shadow_cull_distance: f32,
    pub shadow_fade_distance: f32,
    pub direct_lightmap_enable: bool,
    pub shadow_cache_enable: bool,
    pub shadow_cache_update_priority: f32,
    pub shadow_cache_update_counter: u32,
}

pub trait PbrSpotLightEntityDataTrait: PbrAnalyticLightEntityDataTrait {
    fn disc_radius(&self) -> &f32;
    fn disc_radius_mut(&mut self) -> &mut f32;
    fn inner_angle(&self) -> &f32;
    fn inner_angle_mut(&mut self) -> &mut f32;
    fn outer_angle(&self) -> &f32;
    fn outer_angle_mut(&mut self) -> &mut f32;
    fn i_e_s_profile(&self) -> &Option<Arc<Mutex<dyn super::world_base::IesProfileAssetTrait>>>;
    fn i_e_s_profile_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::world_base::IesProfileAssetTrait>>>;
    fn use_i_e_s_profile_as_mask(&self) -> &bool;
    fn use_i_e_s_profile_as_mask_mut(&mut self) -> &mut bool;
    fn i_e_s_multiplier(&self) -> &f32;
    fn i_e_s_multiplier_mut(&mut self) -> &mut f32;
    fn shadow_max_angle(&self) -> &f32;
    fn shadow_max_angle_mut(&mut self) -> &mut f32;
    fn shadow_fade_out_range(&self) -> &f32;
    fn shadow_fade_out_range_mut(&mut self) -> &mut f32;
    fn color(&self) -> &super::core::Vec3;
    fn color_mut(&mut self) -> &mut super::core::Vec3;
    fn intensity(&self) -> &f32;
    fn intensity_mut(&mut self) -> &mut f32;
    fn exposure_compensation(&self) -> &f32;
    fn exposure_compensation_mut(&mut self) -> &mut f32;
    fn attenuation_radius(&self) -> &f32;
    fn attenuation_radius_mut(&mut self) -> &mut f32;
    fn emissive_shape_enable(&self) -> &bool;
    fn emissive_shape_enable_mut(&mut self) -> &mut bool;
    fn attenuation_offset(&self) -> &f32;
    fn attenuation_offset_mut(&mut self) -> &mut f32;
    fn light_unit(&self) -> &super::render_base::LightUnitType;
    fn light_unit_mut(&mut self) -> &mut super::render_base::LightUnitType;
    fn affect_diffuse(&self) -> &bool;
    fn affect_diffuse_mut(&mut self) -> &mut bool;
    fn affect_specular(&self) -> &bool;
    fn affect_specular_mut(&mut self) -> &mut bool;
    fn particle_color_scale(&self) -> &super::core::Vec3;
    fn particle_color_scale_mut(&mut self) -> &mut super::core::Vec3;
    fn cast_shadows(&self) -> &super::core::QualityScalableEnabled;
    fn cast_shadows_mut(&mut self) -> &mut super::core::QualityScalableEnabled;
    fn cast_volumetric(&self) -> &super::core::QualityScalableEnabled;
    fn cast_volumetric_mut(&mut self) -> &mut super::core::QualityScalableEnabled;
    fn cast_volumetric_shadows(&self) -> &super::core::QualityScalableEnabled;
    fn cast_volumetric_shadows_mut(&mut self) -> &mut super::core::QualityScalableEnabled;
    fn shadow_resolution(&self) -> &super::core::QualityLevel;
    fn shadow_resolution_mut(&mut self) -> &mut super::core::QualityLevel;
    fn shadow_near_radius(&self) -> &f32;
    fn shadow_near_radius_mut(&mut self) -> &mut f32;
    fn shadow_far_radius(&self) -> &f32;
    fn shadow_far_radius_mut(&mut self) -> &mut f32;
    fn shadow_dimmer(&self) -> &f32;
    fn shadow_dimmer_mut(&mut self) -> &mut f32;
    fn cast_shadows_enable(&self) -> &bool;
    fn cast_shadows_enable_mut(&mut self) -> &mut bool;
    fn cast_volumetric_shadows_enable(&self) -> &bool;
    fn cast_volumetric_shadows_enable_mut(&mut self) -> &mut bool;
    fn affect_radiosity(&self) -> &bool;
    fn affect_radiosity_mut(&mut self) -> &mut bool;
    fn radiosity_color_scale(&self) -> &super::core::Vec3;
    fn radiosity_color_scale_mut(&mut self) -> &mut super::core::Vec3;
    fn dimmer(&self) -> &f32;
    fn dimmer_mut(&mut self) -> &mut f32;
    fn cull_screen_area(&self) -> &f32;
    fn cull_screen_area_mut(&mut self) -> &mut f32;
    fn fade_screen_area(&self) -> &f32;
    fn fade_screen_area_mut(&mut self) -> &mut f32;
    fn cull_distance(&self) -> &f32;
    fn cull_distance_mut(&mut self) -> &mut f32;
    fn fade_distance(&self) -> &f32;
    fn fade_distance_mut(&mut self) -> &mut f32;
    fn shadow_cull_screen_area(&self) -> &f32;
    fn shadow_cull_screen_area_mut(&mut self) -> &mut f32;
    fn shadow_fade_screen_area(&self) -> &f32;
    fn shadow_fade_screen_area_mut(&mut self) -> &mut f32;
    fn shadow_cull_distance(&self) -> &f32;
    fn shadow_cull_distance_mut(&mut self) -> &mut f32;
    fn shadow_fade_distance(&self) -> &f32;
    fn shadow_fade_distance_mut(&mut self) -> &mut f32;
    fn direct_lightmap_enable(&self) -> &bool;
    fn direct_lightmap_enable_mut(&mut self) -> &mut bool;
    fn shadow_cache_enable(&self) -> &bool;
    fn shadow_cache_enable_mut(&mut self) -> &mut bool;
    fn shadow_cache_update_priority(&self) -> &f32;
    fn shadow_cache_update_priority_mut(&mut self) -> &mut f32;
    fn shadow_cache_update_counter(&self) -> &u32;
    fn shadow_cache_update_counter_mut(&mut self) -> &mut u32;
}

impl PbrSpotLightEntityDataTrait for PbrSpotLightEntityData {
    fn disc_radius(&self) -> &f32 {
        &self.disc_radius
    }
    fn disc_radius_mut(&mut self) -> &mut f32 {
        &mut self.disc_radius
    }
    fn inner_angle(&self) -> &f32 {
        &self.inner_angle
    }
    fn inner_angle_mut(&mut self) -> &mut f32 {
        &mut self.inner_angle
    }
    fn outer_angle(&self) -> &f32 {
        &self.outer_angle
    }
    fn outer_angle_mut(&mut self) -> &mut f32 {
        &mut self.outer_angle
    }
    fn i_e_s_profile(&self) -> &Option<Arc<Mutex<dyn super::world_base::IesProfileAssetTrait>>> {
        &self.i_e_s_profile
    }
    fn i_e_s_profile_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::world_base::IesProfileAssetTrait>>> {
        &mut self.i_e_s_profile
    }
    fn use_i_e_s_profile_as_mask(&self) -> &bool {
        &self.use_i_e_s_profile_as_mask
    }
    fn use_i_e_s_profile_as_mask_mut(&mut self) -> &mut bool {
        &mut self.use_i_e_s_profile_as_mask
    }
    fn i_e_s_multiplier(&self) -> &f32 {
        &self.i_e_s_multiplier
    }
    fn i_e_s_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.i_e_s_multiplier
    }
    fn shadow_max_angle(&self) -> &f32 {
        &self.shadow_max_angle
    }
    fn shadow_max_angle_mut(&mut self) -> &mut f32 {
        &mut self.shadow_max_angle
    }
    fn shadow_fade_out_range(&self) -> &f32 {
        &self.shadow_fade_out_range
    }
    fn shadow_fade_out_range_mut(&mut self) -> &mut f32 {
        &mut self.shadow_fade_out_range
    }
    fn color(&self) -> &super::core::Vec3 {
        &self.color
    }
    fn color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.color
    }
    fn intensity(&self) -> &f32 {
        &self.intensity
    }
    fn intensity_mut(&mut self) -> &mut f32 {
        &mut self.intensity
    }
    fn exposure_compensation(&self) -> &f32 {
        &self.exposure_compensation
    }
    fn exposure_compensation_mut(&mut self) -> &mut f32 {
        &mut self.exposure_compensation
    }
    fn attenuation_radius(&self) -> &f32 {
        &self.attenuation_radius
    }
    fn attenuation_radius_mut(&mut self) -> &mut f32 {
        &mut self.attenuation_radius
    }
    fn emissive_shape_enable(&self) -> &bool {
        &self.emissive_shape_enable
    }
    fn emissive_shape_enable_mut(&mut self) -> &mut bool {
        &mut self.emissive_shape_enable
    }
    fn attenuation_offset(&self) -> &f32 {
        &self.attenuation_offset
    }
    fn attenuation_offset_mut(&mut self) -> &mut f32 {
        &mut self.attenuation_offset
    }
    fn light_unit(&self) -> &super::render_base::LightUnitType {
        &self.light_unit
    }
    fn light_unit_mut(&mut self) -> &mut super::render_base::LightUnitType {
        &mut self.light_unit
    }
    fn affect_diffuse(&self) -> &bool {
        &self.affect_diffuse
    }
    fn affect_diffuse_mut(&mut self) -> &mut bool {
        &mut self.affect_diffuse
    }
    fn affect_specular(&self) -> &bool {
        &self.affect_specular
    }
    fn affect_specular_mut(&mut self) -> &mut bool {
        &mut self.affect_specular
    }
    fn particle_color_scale(&self) -> &super::core::Vec3 {
        &self.particle_color_scale
    }
    fn particle_color_scale_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.particle_color_scale
    }
    fn cast_shadows(&self) -> &super::core::QualityScalableEnabled {
        &self.cast_shadows
    }
    fn cast_shadows_mut(&mut self) -> &mut super::core::QualityScalableEnabled {
        &mut self.cast_shadows
    }
    fn cast_volumetric(&self) -> &super::core::QualityScalableEnabled {
        &self.cast_volumetric
    }
    fn cast_volumetric_mut(&mut self) -> &mut super::core::QualityScalableEnabled {
        &mut self.cast_volumetric
    }
    fn cast_volumetric_shadows(&self) -> &super::core::QualityScalableEnabled {
        &self.cast_volumetric_shadows
    }
    fn cast_volumetric_shadows_mut(&mut self) -> &mut super::core::QualityScalableEnabled {
        &mut self.cast_volumetric_shadows
    }
    fn shadow_resolution(&self) -> &super::core::QualityLevel {
        &self.shadow_resolution
    }
    fn shadow_resolution_mut(&mut self) -> &mut super::core::QualityLevel {
        &mut self.shadow_resolution
    }
    fn shadow_near_radius(&self) -> &f32 {
        &self.shadow_near_radius
    }
    fn shadow_near_radius_mut(&mut self) -> &mut f32 {
        &mut self.shadow_near_radius
    }
    fn shadow_far_radius(&self) -> &f32 {
        &self.shadow_far_radius
    }
    fn shadow_far_radius_mut(&mut self) -> &mut f32 {
        &mut self.shadow_far_radius
    }
    fn shadow_dimmer(&self) -> &f32 {
        &self.shadow_dimmer
    }
    fn shadow_dimmer_mut(&mut self) -> &mut f32 {
        &mut self.shadow_dimmer
    }
    fn cast_shadows_enable(&self) -> &bool {
        &self.cast_shadows_enable
    }
    fn cast_shadows_enable_mut(&mut self) -> &mut bool {
        &mut self.cast_shadows_enable
    }
    fn cast_volumetric_shadows_enable(&self) -> &bool {
        &self.cast_volumetric_shadows_enable
    }
    fn cast_volumetric_shadows_enable_mut(&mut self) -> &mut bool {
        &mut self.cast_volumetric_shadows_enable
    }
    fn affect_radiosity(&self) -> &bool {
        &self.affect_radiosity
    }
    fn affect_radiosity_mut(&mut self) -> &mut bool {
        &mut self.affect_radiosity
    }
    fn radiosity_color_scale(&self) -> &super::core::Vec3 {
        &self.radiosity_color_scale
    }
    fn radiosity_color_scale_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.radiosity_color_scale
    }
    fn dimmer(&self) -> &f32 {
        &self.dimmer
    }
    fn dimmer_mut(&mut self) -> &mut f32 {
        &mut self.dimmer
    }
    fn cull_screen_area(&self) -> &f32 {
        &self.cull_screen_area
    }
    fn cull_screen_area_mut(&mut self) -> &mut f32 {
        &mut self.cull_screen_area
    }
    fn fade_screen_area(&self) -> &f32 {
        &self.fade_screen_area
    }
    fn fade_screen_area_mut(&mut self) -> &mut f32 {
        &mut self.fade_screen_area
    }
    fn cull_distance(&self) -> &f32 {
        &self.cull_distance
    }
    fn cull_distance_mut(&mut self) -> &mut f32 {
        &mut self.cull_distance
    }
    fn fade_distance(&self) -> &f32 {
        &self.fade_distance
    }
    fn fade_distance_mut(&mut self) -> &mut f32 {
        &mut self.fade_distance
    }
    fn shadow_cull_screen_area(&self) -> &f32 {
        &self.shadow_cull_screen_area
    }
    fn shadow_cull_screen_area_mut(&mut self) -> &mut f32 {
        &mut self.shadow_cull_screen_area
    }
    fn shadow_fade_screen_area(&self) -> &f32 {
        &self.shadow_fade_screen_area
    }
    fn shadow_fade_screen_area_mut(&mut self) -> &mut f32 {
        &mut self.shadow_fade_screen_area
    }
    fn shadow_cull_distance(&self) -> &f32 {
        &self.shadow_cull_distance
    }
    fn shadow_cull_distance_mut(&mut self) -> &mut f32 {
        &mut self.shadow_cull_distance
    }
    fn shadow_fade_distance(&self) -> &f32 {
        &self.shadow_fade_distance
    }
    fn shadow_fade_distance_mut(&mut self) -> &mut f32 {
        &mut self.shadow_fade_distance
    }
    fn direct_lightmap_enable(&self) -> &bool {
        &self.direct_lightmap_enable
    }
    fn direct_lightmap_enable_mut(&mut self) -> &mut bool {
        &mut self.direct_lightmap_enable
    }
    fn shadow_cache_enable(&self) -> &bool {
        &self.shadow_cache_enable
    }
    fn shadow_cache_enable_mut(&mut self) -> &mut bool {
        &mut self.shadow_cache_enable
    }
    fn shadow_cache_update_priority(&self) -> &f32 {
        &self.shadow_cache_update_priority
    }
    fn shadow_cache_update_priority_mut(&mut self) -> &mut f32 {
        &mut self.shadow_cache_update_priority
    }
    fn shadow_cache_update_counter(&self) -> &u32 {
        &self.shadow_cache_update_counter
    }
    fn shadow_cache_update_counter_mut(&mut self) -> &mut u32 {
        &mut self.shadow_cache_update_counter
    }
}

impl PbrAnalyticLightEntityDataTrait for PbrSpotLightEntityData {
}

impl LocalLightEntityDataTrait for PbrSpotLightEntityData {
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for PbrSpotLightEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for PbrSpotLightEntityData {
}

impl super::entity::GameObjectDataTrait for PbrSpotLightEntityData {
}

impl super::core::DataBusPeerTrait for PbrSpotLightEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PbrSpotLightEntityData {
}

impl super::core::DataContainerTrait for PbrSpotLightEntityData {
}

pub static PBRSPOTLIGHTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PbrSpotLightEntityData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PBRANALYTICLIGHTENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PbrSpotLightEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DiscRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrSpotLightEntityData, disc_radius),
            },
            FieldInfoData {
                name: "InnerAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrSpotLightEntityData, inner_angle),
            },
            FieldInfoData {
                name: "OuterAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrSpotLightEntityData, outer_angle),
            },
            FieldInfoData {
                name: "IESProfile",
                flags: MemberInfoFlags::new(0),
                field_type: "IesProfileAsset",
                rust_offset: offset_of!(PbrSpotLightEntityData, i_e_s_profile),
            },
            FieldInfoData {
                name: "UseIESProfileAsMask",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrSpotLightEntityData, use_i_e_s_profile_as_mask),
            },
            FieldInfoData {
                name: "IESMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrSpotLightEntityData, i_e_s_multiplier),
            },
            FieldInfoData {
                name: "ShadowMaxAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrSpotLightEntityData, shadow_max_angle),
            },
            FieldInfoData {
                name: "ShadowFadeOutRange",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrSpotLightEntityData, shadow_fade_out_range),
            },
            FieldInfoData {
                name: "Color",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(PbrSpotLightEntityData, color),
            },
            FieldInfoData {
                name: "Intensity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrSpotLightEntityData, intensity),
            },
            FieldInfoData {
                name: "ExposureCompensation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrSpotLightEntityData, exposure_compensation),
            },
            FieldInfoData {
                name: "AttenuationRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrSpotLightEntityData, attenuation_radius),
            },
            FieldInfoData {
                name: "EmissiveShapeEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrSpotLightEntityData, emissive_shape_enable),
            },
            FieldInfoData {
                name: "AttenuationOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrSpotLightEntityData, attenuation_offset),
            },
            FieldInfoData {
                name: "LightUnit",
                flags: MemberInfoFlags::new(0),
                field_type: "LightUnitType",
                rust_offset: offset_of!(PbrSpotLightEntityData, light_unit),
            },
            FieldInfoData {
                name: "AffectDiffuse",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrSpotLightEntityData, affect_diffuse),
            },
            FieldInfoData {
                name: "AffectSpecular",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrSpotLightEntityData, affect_specular),
            },
            FieldInfoData {
                name: "ParticleColorScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(PbrSpotLightEntityData, particle_color_scale),
            },
            FieldInfoData {
                name: "CastShadows",
                flags: MemberInfoFlags::new(0),
                field_type: "QualityScalableEnabled",
                rust_offset: offset_of!(PbrSpotLightEntityData, cast_shadows),
            },
            FieldInfoData {
                name: "CastVolumetric",
                flags: MemberInfoFlags::new(0),
                field_type: "QualityScalableEnabled",
                rust_offset: offset_of!(PbrSpotLightEntityData, cast_volumetric),
            },
            FieldInfoData {
                name: "CastVolumetricShadows",
                flags: MemberInfoFlags::new(0),
                field_type: "QualityScalableEnabled",
                rust_offset: offset_of!(PbrSpotLightEntityData, cast_volumetric_shadows),
            },
            FieldInfoData {
                name: "ShadowResolution",
                flags: MemberInfoFlags::new(0),
                field_type: "QualityLevel",
                rust_offset: offset_of!(PbrSpotLightEntityData, shadow_resolution),
            },
            FieldInfoData {
                name: "ShadowNearRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrSpotLightEntityData, shadow_near_radius),
            },
            FieldInfoData {
                name: "ShadowFarRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrSpotLightEntityData, shadow_far_radius),
            },
            FieldInfoData {
                name: "ShadowDimmer",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrSpotLightEntityData, shadow_dimmer),
            },
            FieldInfoData {
                name: "CastShadowsEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrSpotLightEntityData, cast_shadows_enable),
            },
            FieldInfoData {
                name: "CastVolumetricShadowsEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrSpotLightEntityData, cast_volumetric_shadows_enable),
            },
            FieldInfoData {
                name: "AffectRadiosity",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrSpotLightEntityData, affect_radiosity),
            },
            FieldInfoData {
                name: "RadiosityColorScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(PbrSpotLightEntityData, radiosity_color_scale),
            },
            FieldInfoData {
                name: "Dimmer",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrSpotLightEntityData, dimmer),
            },
            FieldInfoData {
                name: "CullScreenArea",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrSpotLightEntityData, cull_screen_area),
            },
            FieldInfoData {
                name: "FadeScreenArea",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrSpotLightEntityData, fade_screen_area),
            },
            FieldInfoData {
                name: "CullDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrSpotLightEntityData, cull_distance),
            },
            FieldInfoData {
                name: "FadeDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrSpotLightEntityData, fade_distance),
            },
            FieldInfoData {
                name: "ShadowCullScreenArea",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrSpotLightEntityData, shadow_cull_screen_area),
            },
            FieldInfoData {
                name: "ShadowFadeScreenArea",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrSpotLightEntityData, shadow_fade_screen_area),
            },
            FieldInfoData {
                name: "ShadowCullDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrSpotLightEntityData, shadow_cull_distance),
            },
            FieldInfoData {
                name: "ShadowFadeDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrSpotLightEntityData, shadow_fade_distance),
            },
            FieldInfoData {
                name: "DirectLightmapEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrSpotLightEntityData, direct_lightmap_enable),
            },
            FieldInfoData {
                name: "ShadowCacheEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrSpotLightEntityData, shadow_cache_enable),
            },
            FieldInfoData {
                name: "ShadowCacheUpdatePriority",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrSpotLightEntityData, shadow_cache_update_priority),
            },
            FieldInfoData {
                name: "ShadowCacheUpdateCounter",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(PbrSpotLightEntityData, shadow_cache_update_counter),
            },
        ],
    }),
    array_type: Some(PBRSPOTLIGHTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PbrSpotLightEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PBRSPOTLIGHTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PBRSPOTLIGHTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PbrSpotLightEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("PbrSpotLightEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PbrSphereLightEntityData {
    pub _glacier_base: PbrAnalyticLightEntityData,
    pub sphere_radius: f32,
    pub only_hempishere: bool,
    pub i_e_s_profile: Option<Arc<Mutex<dyn super::world_base::IesProfileAssetTrait>>>,
    pub use_i_e_s_profile_as_mask: bool,
    pub i_e_s_multiplier: f32,
    pub color: super::core::Vec3,
    pub intensity: f32,
    pub exposure_compensation: f32,
    pub attenuation_radius: f32,
    pub emissive_shape_enable: bool,
    pub attenuation_offset: f32,
    pub light_unit: super::render_base::LightUnitType,
    pub affect_diffuse: bool,
    pub affect_specular: bool,
    pub particle_color_scale: super::core::Vec3,
    pub cast_shadows: super::core::QualityScalableEnabled,
    pub cast_volumetric: super::core::QualityScalableEnabled,
    pub cast_volumetric_shadows: super::core::QualityScalableEnabled,
    pub shadow_resolution: super::core::QualityLevel,
    pub shadow_near_radius: f32,
    pub shadow_far_radius: f32,
    pub shadow_dimmer: f32,
    pub cast_shadows_enable: bool,
    pub cast_volumetric_shadows_enable: bool,
    pub affect_radiosity: bool,
    pub radiosity_color_scale: super::core::Vec3,
    pub dimmer: f32,
    pub cull_screen_area: f32,
    pub fade_screen_area: f32,
    pub cull_distance: f32,
    pub fade_distance: f32,
    pub shadow_cull_screen_area: f32,
    pub shadow_fade_screen_area: f32,
    pub shadow_cull_distance: f32,
    pub shadow_fade_distance: f32,
    pub direct_lightmap_enable: bool,
    pub shadow_cache_enable: bool,
    pub shadow_cache_update_priority: f32,
    pub shadow_cache_update_counter: u32,
}

pub trait PbrSphereLightEntityDataTrait: PbrAnalyticLightEntityDataTrait {
    fn sphere_radius(&self) -> &f32;
    fn sphere_radius_mut(&mut self) -> &mut f32;
    fn only_hempishere(&self) -> &bool;
    fn only_hempishere_mut(&mut self) -> &mut bool;
    fn i_e_s_profile(&self) -> &Option<Arc<Mutex<dyn super::world_base::IesProfileAssetTrait>>>;
    fn i_e_s_profile_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::world_base::IesProfileAssetTrait>>>;
    fn use_i_e_s_profile_as_mask(&self) -> &bool;
    fn use_i_e_s_profile_as_mask_mut(&mut self) -> &mut bool;
    fn i_e_s_multiplier(&self) -> &f32;
    fn i_e_s_multiplier_mut(&mut self) -> &mut f32;
    fn color(&self) -> &super::core::Vec3;
    fn color_mut(&mut self) -> &mut super::core::Vec3;
    fn intensity(&self) -> &f32;
    fn intensity_mut(&mut self) -> &mut f32;
    fn exposure_compensation(&self) -> &f32;
    fn exposure_compensation_mut(&mut self) -> &mut f32;
    fn attenuation_radius(&self) -> &f32;
    fn attenuation_radius_mut(&mut self) -> &mut f32;
    fn emissive_shape_enable(&self) -> &bool;
    fn emissive_shape_enable_mut(&mut self) -> &mut bool;
    fn attenuation_offset(&self) -> &f32;
    fn attenuation_offset_mut(&mut self) -> &mut f32;
    fn light_unit(&self) -> &super::render_base::LightUnitType;
    fn light_unit_mut(&mut self) -> &mut super::render_base::LightUnitType;
    fn affect_diffuse(&self) -> &bool;
    fn affect_diffuse_mut(&mut self) -> &mut bool;
    fn affect_specular(&self) -> &bool;
    fn affect_specular_mut(&mut self) -> &mut bool;
    fn particle_color_scale(&self) -> &super::core::Vec3;
    fn particle_color_scale_mut(&mut self) -> &mut super::core::Vec3;
    fn cast_shadows(&self) -> &super::core::QualityScalableEnabled;
    fn cast_shadows_mut(&mut self) -> &mut super::core::QualityScalableEnabled;
    fn cast_volumetric(&self) -> &super::core::QualityScalableEnabled;
    fn cast_volumetric_mut(&mut self) -> &mut super::core::QualityScalableEnabled;
    fn cast_volumetric_shadows(&self) -> &super::core::QualityScalableEnabled;
    fn cast_volumetric_shadows_mut(&mut self) -> &mut super::core::QualityScalableEnabled;
    fn shadow_resolution(&self) -> &super::core::QualityLevel;
    fn shadow_resolution_mut(&mut self) -> &mut super::core::QualityLevel;
    fn shadow_near_radius(&self) -> &f32;
    fn shadow_near_radius_mut(&mut self) -> &mut f32;
    fn shadow_far_radius(&self) -> &f32;
    fn shadow_far_radius_mut(&mut self) -> &mut f32;
    fn shadow_dimmer(&self) -> &f32;
    fn shadow_dimmer_mut(&mut self) -> &mut f32;
    fn cast_shadows_enable(&self) -> &bool;
    fn cast_shadows_enable_mut(&mut self) -> &mut bool;
    fn cast_volumetric_shadows_enable(&self) -> &bool;
    fn cast_volumetric_shadows_enable_mut(&mut self) -> &mut bool;
    fn affect_radiosity(&self) -> &bool;
    fn affect_radiosity_mut(&mut self) -> &mut bool;
    fn radiosity_color_scale(&self) -> &super::core::Vec3;
    fn radiosity_color_scale_mut(&mut self) -> &mut super::core::Vec3;
    fn dimmer(&self) -> &f32;
    fn dimmer_mut(&mut self) -> &mut f32;
    fn cull_screen_area(&self) -> &f32;
    fn cull_screen_area_mut(&mut self) -> &mut f32;
    fn fade_screen_area(&self) -> &f32;
    fn fade_screen_area_mut(&mut self) -> &mut f32;
    fn cull_distance(&self) -> &f32;
    fn cull_distance_mut(&mut self) -> &mut f32;
    fn fade_distance(&self) -> &f32;
    fn fade_distance_mut(&mut self) -> &mut f32;
    fn shadow_cull_screen_area(&self) -> &f32;
    fn shadow_cull_screen_area_mut(&mut self) -> &mut f32;
    fn shadow_fade_screen_area(&self) -> &f32;
    fn shadow_fade_screen_area_mut(&mut self) -> &mut f32;
    fn shadow_cull_distance(&self) -> &f32;
    fn shadow_cull_distance_mut(&mut self) -> &mut f32;
    fn shadow_fade_distance(&self) -> &f32;
    fn shadow_fade_distance_mut(&mut self) -> &mut f32;
    fn direct_lightmap_enable(&self) -> &bool;
    fn direct_lightmap_enable_mut(&mut self) -> &mut bool;
    fn shadow_cache_enable(&self) -> &bool;
    fn shadow_cache_enable_mut(&mut self) -> &mut bool;
    fn shadow_cache_update_priority(&self) -> &f32;
    fn shadow_cache_update_priority_mut(&mut self) -> &mut f32;
    fn shadow_cache_update_counter(&self) -> &u32;
    fn shadow_cache_update_counter_mut(&mut self) -> &mut u32;
}

impl PbrSphereLightEntityDataTrait for PbrSphereLightEntityData {
    fn sphere_radius(&self) -> &f32 {
        &self.sphere_radius
    }
    fn sphere_radius_mut(&mut self) -> &mut f32 {
        &mut self.sphere_radius
    }
    fn only_hempishere(&self) -> &bool {
        &self.only_hempishere
    }
    fn only_hempishere_mut(&mut self) -> &mut bool {
        &mut self.only_hempishere
    }
    fn i_e_s_profile(&self) -> &Option<Arc<Mutex<dyn super::world_base::IesProfileAssetTrait>>> {
        &self.i_e_s_profile
    }
    fn i_e_s_profile_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::world_base::IesProfileAssetTrait>>> {
        &mut self.i_e_s_profile
    }
    fn use_i_e_s_profile_as_mask(&self) -> &bool {
        &self.use_i_e_s_profile_as_mask
    }
    fn use_i_e_s_profile_as_mask_mut(&mut self) -> &mut bool {
        &mut self.use_i_e_s_profile_as_mask
    }
    fn i_e_s_multiplier(&self) -> &f32 {
        &self.i_e_s_multiplier
    }
    fn i_e_s_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.i_e_s_multiplier
    }
    fn color(&self) -> &super::core::Vec3 {
        &self.color
    }
    fn color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.color
    }
    fn intensity(&self) -> &f32 {
        &self.intensity
    }
    fn intensity_mut(&mut self) -> &mut f32 {
        &mut self.intensity
    }
    fn exposure_compensation(&self) -> &f32 {
        &self.exposure_compensation
    }
    fn exposure_compensation_mut(&mut self) -> &mut f32 {
        &mut self.exposure_compensation
    }
    fn attenuation_radius(&self) -> &f32 {
        &self.attenuation_radius
    }
    fn attenuation_radius_mut(&mut self) -> &mut f32 {
        &mut self.attenuation_radius
    }
    fn emissive_shape_enable(&self) -> &bool {
        &self.emissive_shape_enable
    }
    fn emissive_shape_enable_mut(&mut self) -> &mut bool {
        &mut self.emissive_shape_enable
    }
    fn attenuation_offset(&self) -> &f32 {
        &self.attenuation_offset
    }
    fn attenuation_offset_mut(&mut self) -> &mut f32 {
        &mut self.attenuation_offset
    }
    fn light_unit(&self) -> &super::render_base::LightUnitType {
        &self.light_unit
    }
    fn light_unit_mut(&mut self) -> &mut super::render_base::LightUnitType {
        &mut self.light_unit
    }
    fn affect_diffuse(&self) -> &bool {
        &self.affect_diffuse
    }
    fn affect_diffuse_mut(&mut self) -> &mut bool {
        &mut self.affect_diffuse
    }
    fn affect_specular(&self) -> &bool {
        &self.affect_specular
    }
    fn affect_specular_mut(&mut self) -> &mut bool {
        &mut self.affect_specular
    }
    fn particle_color_scale(&self) -> &super::core::Vec3 {
        &self.particle_color_scale
    }
    fn particle_color_scale_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.particle_color_scale
    }
    fn cast_shadows(&self) -> &super::core::QualityScalableEnabled {
        &self.cast_shadows
    }
    fn cast_shadows_mut(&mut self) -> &mut super::core::QualityScalableEnabled {
        &mut self.cast_shadows
    }
    fn cast_volumetric(&self) -> &super::core::QualityScalableEnabled {
        &self.cast_volumetric
    }
    fn cast_volumetric_mut(&mut self) -> &mut super::core::QualityScalableEnabled {
        &mut self.cast_volumetric
    }
    fn cast_volumetric_shadows(&self) -> &super::core::QualityScalableEnabled {
        &self.cast_volumetric_shadows
    }
    fn cast_volumetric_shadows_mut(&mut self) -> &mut super::core::QualityScalableEnabled {
        &mut self.cast_volumetric_shadows
    }
    fn shadow_resolution(&self) -> &super::core::QualityLevel {
        &self.shadow_resolution
    }
    fn shadow_resolution_mut(&mut self) -> &mut super::core::QualityLevel {
        &mut self.shadow_resolution
    }
    fn shadow_near_radius(&self) -> &f32 {
        &self.shadow_near_radius
    }
    fn shadow_near_radius_mut(&mut self) -> &mut f32 {
        &mut self.shadow_near_radius
    }
    fn shadow_far_radius(&self) -> &f32 {
        &self.shadow_far_radius
    }
    fn shadow_far_radius_mut(&mut self) -> &mut f32 {
        &mut self.shadow_far_radius
    }
    fn shadow_dimmer(&self) -> &f32 {
        &self.shadow_dimmer
    }
    fn shadow_dimmer_mut(&mut self) -> &mut f32 {
        &mut self.shadow_dimmer
    }
    fn cast_shadows_enable(&self) -> &bool {
        &self.cast_shadows_enable
    }
    fn cast_shadows_enable_mut(&mut self) -> &mut bool {
        &mut self.cast_shadows_enable
    }
    fn cast_volumetric_shadows_enable(&self) -> &bool {
        &self.cast_volumetric_shadows_enable
    }
    fn cast_volumetric_shadows_enable_mut(&mut self) -> &mut bool {
        &mut self.cast_volumetric_shadows_enable
    }
    fn affect_radiosity(&self) -> &bool {
        &self.affect_radiosity
    }
    fn affect_radiosity_mut(&mut self) -> &mut bool {
        &mut self.affect_radiosity
    }
    fn radiosity_color_scale(&self) -> &super::core::Vec3 {
        &self.radiosity_color_scale
    }
    fn radiosity_color_scale_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.radiosity_color_scale
    }
    fn dimmer(&self) -> &f32 {
        &self.dimmer
    }
    fn dimmer_mut(&mut self) -> &mut f32 {
        &mut self.dimmer
    }
    fn cull_screen_area(&self) -> &f32 {
        &self.cull_screen_area
    }
    fn cull_screen_area_mut(&mut self) -> &mut f32 {
        &mut self.cull_screen_area
    }
    fn fade_screen_area(&self) -> &f32 {
        &self.fade_screen_area
    }
    fn fade_screen_area_mut(&mut self) -> &mut f32 {
        &mut self.fade_screen_area
    }
    fn cull_distance(&self) -> &f32 {
        &self.cull_distance
    }
    fn cull_distance_mut(&mut self) -> &mut f32 {
        &mut self.cull_distance
    }
    fn fade_distance(&self) -> &f32 {
        &self.fade_distance
    }
    fn fade_distance_mut(&mut self) -> &mut f32 {
        &mut self.fade_distance
    }
    fn shadow_cull_screen_area(&self) -> &f32 {
        &self.shadow_cull_screen_area
    }
    fn shadow_cull_screen_area_mut(&mut self) -> &mut f32 {
        &mut self.shadow_cull_screen_area
    }
    fn shadow_fade_screen_area(&self) -> &f32 {
        &self.shadow_fade_screen_area
    }
    fn shadow_fade_screen_area_mut(&mut self) -> &mut f32 {
        &mut self.shadow_fade_screen_area
    }
    fn shadow_cull_distance(&self) -> &f32 {
        &self.shadow_cull_distance
    }
    fn shadow_cull_distance_mut(&mut self) -> &mut f32 {
        &mut self.shadow_cull_distance
    }
    fn shadow_fade_distance(&self) -> &f32 {
        &self.shadow_fade_distance
    }
    fn shadow_fade_distance_mut(&mut self) -> &mut f32 {
        &mut self.shadow_fade_distance
    }
    fn direct_lightmap_enable(&self) -> &bool {
        &self.direct_lightmap_enable
    }
    fn direct_lightmap_enable_mut(&mut self) -> &mut bool {
        &mut self.direct_lightmap_enable
    }
    fn shadow_cache_enable(&self) -> &bool {
        &self.shadow_cache_enable
    }
    fn shadow_cache_enable_mut(&mut self) -> &mut bool {
        &mut self.shadow_cache_enable
    }
    fn shadow_cache_update_priority(&self) -> &f32 {
        &self.shadow_cache_update_priority
    }
    fn shadow_cache_update_priority_mut(&mut self) -> &mut f32 {
        &mut self.shadow_cache_update_priority
    }
    fn shadow_cache_update_counter(&self) -> &u32 {
        &self.shadow_cache_update_counter
    }
    fn shadow_cache_update_counter_mut(&mut self) -> &mut u32 {
        &mut self.shadow_cache_update_counter
    }
}

impl PbrAnalyticLightEntityDataTrait for PbrSphereLightEntityData {
}

impl LocalLightEntityDataTrait for PbrSphereLightEntityData {
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for PbrSphereLightEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for PbrSphereLightEntityData {
}

impl super::entity::GameObjectDataTrait for PbrSphereLightEntityData {
}

impl super::core::DataBusPeerTrait for PbrSphereLightEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PbrSphereLightEntityData {
}

impl super::core::DataContainerTrait for PbrSphereLightEntityData {
}

pub static PBRSPHERELIGHTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PbrSphereLightEntityData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PBRANALYTICLIGHTENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PbrSphereLightEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SphereRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrSphereLightEntityData, sphere_radius),
            },
            FieldInfoData {
                name: "OnlyHempishere",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrSphereLightEntityData, only_hempishere),
            },
            FieldInfoData {
                name: "IESProfile",
                flags: MemberInfoFlags::new(0),
                field_type: "IesProfileAsset",
                rust_offset: offset_of!(PbrSphereLightEntityData, i_e_s_profile),
            },
            FieldInfoData {
                name: "UseIESProfileAsMask",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrSphereLightEntityData, use_i_e_s_profile_as_mask),
            },
            FieldInfoData {
                name: "IESMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrSphereLightEntityData, i_e_s_multiplier),
            },
            FieldInfoData {
                name: "Color",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(PbrSphereLightEntityData, color),
            },
            FieldInfoData {
                name: "Intensity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrSphereLightEntityData, intensity),
            },
            FieldInfoData {
                name: "ExposureCompensation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrSphereLightEntityData, exposure_compensation),
            },
            FieldInfoData {
                name: "AttenuationRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrSphereLightEntityData, attenuation_radius),
            },
            FieldInfoData {
                name: "EmissiveShapeEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrSphereLightEntityData, emissive_shape_enable),
            },
            FieldInfoData {
                name: "AttenuationOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrSphereLightEntityData, attenuation_offset),
            },
            FieldInfoData {
                name: "LightUnit",
                flags: MemberInfoFlags::new(0),
                field_type: "LightUnitType",
                rust_offset: offset_of!(PbrSphereLightEntityData, light_unit),
            },
            FieldInfoData {
                name: "AffectDiffuse",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrSphereLightEntityData, affect_diffuse),
            },
            FieldInfoData {
                name: "AffectSpecular",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrSphereLightEntityData, affect_specular),
            },
            FieldInfoData {
                name: "ParticleColorScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(PbrSphereLightEntityData, particle_color_scale),
            },
            FieldInfoData {
                name: "CastShadows",
                flags: MemberInfoFlags::new(0),
                field_type: "QualityScalableEnabled",
                rust_offset: offset_of!(PbrSphereLightEntityData, cast_shadows),
            },
            FieldInfoData {
                name: "CastVolumetric",
                flags: MemberInfoFlags::new(0),
                field_type: "QualityScalableEnabled",
                rust_offset: offset_of!(PbrSphereLightEntityData, cast_volumetric),
            },
            FieldInfoData {
                name: "CastVolumetricShadows",
                flags: MemberInfoFlags::new(0),
                field_type: "QualityScalableEnabled",
                rust_offset: offset_of!(PbrSphereLightEntityData, cast_volumetric_shadows),
            },
            FieldInfoData {
                name: "ShadowResolution",
                flags: MemberInfoFlags::new(0),
                field_type: "QualityLevel",
                rust_offset: offset_of!(PbrSphereLightEntityData, shadow_resolution),
            },
            FieldInfoData {
                name: "ShadowNearRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrSphereLightEntityData, shadow_near_radius),
            },
            FieldInfoData {
                name: "ShadowFarRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrSphereLightEntityData, shadow_far_radius),
            },
            FieldInfoData {
                name: "ShadowDimmer",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrSphereLightEntityData, shadow_dimmer),
            },
            FieldInfoData {
                name: "CastShadowsEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrSphereLightEntityData, cast_shadows_enable),
            },
            FieldInfoData {
                name: "CastVolumetricShadowsEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrSphereLightEntityData, cast_volumetric_shadows_enable),
            },
            FieldInfoData {
                name: "AffectRadiosity",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrSphereLightEntityData, affect_radiosity),
            },
            FieldInfoData {
                name: "RadiosityColorScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(PbrSphereLightEntityData, radiosity_color_scale),
            },
            FieldInfoData {
                name: "Dimmer",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrSphereLightEntityData, dimmer),
            },
            FieldInfoData {
                name: "CullScreenArea",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrSphereLightEntityData, cull_screen_area),
            },
            FieldInfoData {
                name: "FadeScreenArea",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrSphereLightEntityData, fade_screen_area),
            },
            FieldInfoData {
                name: "CullDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrSphereLightEntityData, cull_distance),
            },
            FieldInfoData {
                name: "FadeDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrSphereLightEntityData, fade_distance),
            },
            FieldInfoData {
                name: "ShadowCullScreenArea",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrSphereLightEntityData, shadow_cull_screen_area),
            },
            FieldInfoData {
                name: "ShadowFadeScreenArea",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrSphereLightEntityData, shadow_fade_screen_area),
            },
            FieldInfoData {
                name: "ShadowCullDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrSphereLightEntityData, shadow_cull_distance),
            },
            FieldInfoData {
                name: "ShadowFadeDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrSphereLightEntityData, shadow_fade_distance),
            },
            FieldInfoData {
                name: "DirectLightmapEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrSphereLightEntityData, direct_lightmap_enable),
            },
            FieldInfoData {
                name: "ShadowCacheEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PbrSphereLightEntityData, shadow_cache_enable),
            },
            FieldInfoData {
                name: "ShadowCacheUpdatePriority",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PbrSphereLightEntityData, shadow_cache_update_priority),
            },
            FieldInfoData {
                name: "ShadowCacheUpdateCounter",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(PbrSphereLightEntityData, shadow_cache_update_counter),
            },
        ],
    }),
    array_type: Some(PBRSPHERELIGHTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PbrSphereLightEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PBRSPHERELIGHTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PBRSPHERELIGHTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PbrSphereLightEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("PbrSphereLightEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PbrAnalyticLightEntityData {
    pub _glacier_base: LocalLightEntityData,
}

pub trait PbrAnalyticLightEntityDataTrait: LocalLightEntityDataTrait {
}

impl PbrAnalyticLightEntityDataTrait for PbrAnalyticLightEntityData {
}

impl LocalLightEntityDataTrait for PbrAnalyticLightEntityData {
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for PbrAnalyticLightEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for PbrAnalyticLightEntityData {
}

impl super::entity::GameObjectDataTrait for PbrAnalyticLightEntityData {
}

impl super::core::DataBusPeerTrait for PbrAnalyticLightEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PbrAnalyticLightEntityData {
}

impl super::core::DataContainerTrait for PbrAnalyticLightEntityData {
}

pub static PBRANALYTICLIGHTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PbrAnalyticLightEntityData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(LOCALLIGHTENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PbrAnalyticLightEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(PBRANALYTICLIGHTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PbrAnalyticLightEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PBRANALYTICLIGHTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PBRANALYTICLIGHTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PbrAnalyticLightEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("PbrAnalyticLightEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SpotLightEntityData {
    pub _glacier_base: LocalLightEntityData,
    pub shape: super::world_base::SpotLightShape,
    pub cone_inner_angle: f32,
    pub cone_outer_angle: f32,
    pub frustum_fov: f32,
    pub frustum_aspect: f32,
    pub ortho_width: f32,
    pub ortho_height: f32,
    pub near_plane: f32,
    pub texture: Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>,
    pub cast_shadows: super::core::QualityScalableEnabled,
    pub cast_volumetric_shadows: super::core::QualityScalableEnabled,
    pub shadow_resolution: super::core::QualityLevel,
    pub shadow_radius: f32,
    pub shadow_dimmer: f32,
    pub frustum_as_cone: super::core::QualityScalableEnabled,
    pub frustum_as_cone_angle: bool,
    pub frustum_as_cone_intensity_scale: f32,
    pub cast_shadows_enable: bool,
    pub cast_volumetric_shadows_enable: bool,
    pub cast_shadows_min_level: super::core::QualityLevel,
    pub direct_lightmap_enable: bool,
    pub color: super::core::Vec3,
    pub radius: f32,
    pub intensity: f32,
    pub attenuation_offset: f32,
    pub direct_light_enable: bool,
    pub specular_enable: bool,
    pub enlighten_color_mode: super::world_base::EnlightenColorMode,
    pub enlighten_enable: bool,
    pub enlighten_color_scale: super::core::Vec3,
    pub particle_color_scale: super::core::Vec3,
    pub exposure_compensation: f32,
    pub shadow_cache_enable: bool,
    pub shadow_cache_update_priority: f32,
    pub shadow_cache_update_counter: u32,
}

pub trait SpotLightEntityDataTrait: LocalLightEntityDataTrait {
    fn shape(&self) -> &super::world_base::SpotLightShape;
    fn shape_mut(&mut self) -> &mut super::world_base::SpotLightShape;
    fn cone_inner_angle(&self) -> &f32;
    fn cone_inner_angle_mut(&mut self) -> &mut f32;
    fn cone_outer_angle(&self) -> &f32;
    fn cone_outer_angle_mut(&mut self) -> &mut f32;
    fn frustum_fov(&self) -> &f32;
    fn frustum_fov_mut(&mut self) -> &mut f32;
    fn frustum_aspect(&self) -> &f32;
    fn frustum_aspect_mut(&mut self) -> &mut f32;
    fn ortho_width(&self) -> &f32;
    fn ortho_width_mut(&mut self) -> &mut f32;
    fn ortho_height(&self) -> &f32;
    fn ortho_height_mut(&mut self) -> &mut f32;
    fn near_plane(&self) -> &f32;
    fn near_plane_mut(&mut self) -> &mut f32;
    fn texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn cast_shadows(&self) -> &super::core::QualityScalableEnabled;
    fn cast_shadows_mut(&mut self) -> &mut super::core::QualityScalableEnabled;
    fn cast_volumetric_shadows(&self) -> &super::core::QualityScalableEnabled;
    fn cast_volumetric_shadows_mut(&mut self) -> &mut super::core::QualityScalableEnabled;
    fn shadow_resolution(&self) -> &super::core::QualityLevel;
    fn shadow_resolution_mut(&mut self) -> &mut super::core::QualityLevel;
    fn shadow_radius(&self) -> &f32;
    fn shadow_radius_mut(&mut self) -> &mut f32;
    fn shadow_dimmer(&self) -> &f32;
    fn shadow_dimmer_mut(&mut self) -> &mut f32;
    fn frustum_as_cone(&self) -> &super::core::QualityScalableEnabled;
    fn frustum_as_cone_mut(&mut self) -> &mut super::core::QualityScalableEnabled;
    fn frustum_as_cone_angle(&self) -> &bool;
    fn frustum_as_cone_angle_mut(&mut self) -> &mut bool;
    fn frustum_as_cone_intensity_scale(&self) -> &f32;
    fn frustum_as_cone_intensity_scale_mut(&mut self) -> &mut f32;
    fn cast_shadows_enable(&self) -> &bool;
    fn cast_shadows_enable_mut(&mut self) -> &mut bool;
    fn cast_volumetric_shadows_enable(&self) -> &bool;
    fn cast_volumetric_shadows_enable_mut(&mut self) -> &mut bool;
    fn cast_shadows_min_level(&self) -> &super::core::QualityLevel;
    fn cast_shadows_min_level_mut(&mut self) -> &mut super::core::QualityLevel;
    fn direct_lightmap_enable(&self) -> &bool;
    fn direct_lightmap_enable_mut(&mut self) -> &mut bool;
    fn color(&self) -> &super::core::Vec3;
    fn color_mut(&mut self) -> &mut super::core::Vec3;
    fn radius(&self) -> &f32;
    fn radius_mut(&mut self) -> &mut f32;
    fn intensity(&self) -> &f32;
    fn intensity_mut(&mut self) -> &mut f32;
    fn attenuation_offset(&self) -> &f32;
    fn attenuation_offset_mut(&mut self) -> &mut f32;
    fn direct_light_enable(&self) -> &bool;
    fn direct_light_enable_mut(&mut self) -> &mut bool;
    fn specular_enable(&self) -> &bool;
    fn specular_enable_mut(&mut self) -> &mut bool;
    fn enlighten_color_mode(&self) -> &super::world_base::EnlightenColorMode;
    fn enlighten_color_mode_mut(&mut self) -> &mut super::world_base::EnlightenColorMode;
    fn enlighten_enable(&self) -> &bool;
    fn enlighten_enable_mut(&mut self) -> &mut bool;
    fn enlighten_color_scale(&self) -> &super::core::Vec3;
    fn enlighten_color_scale_mut(&mut self) -> &mut super::core::Vec3;
    fn particle_color_scale(&self) -> &super::core::Vec3;
    fn particle_color_scale_mut(&mut self) -> &mut super::core::Vec3;
    fn exposure_compensation(&self) -> &f32;
    fn exposure_compensation_mut(&mut self) -> &mut f32;
    fn shadow_cache_enable(&self) -> &bool;
    fn shadow_cache_enable_mut(&mut self) -> &mut bool;
    fn shadow_cache_update_priority(&self) -> &f32;
    fn shadow_cache_update_priority_mut(&mut self) -> &mut f32;
    fn shadow_cache_update_counter(&self) -> &u32;
    fn shadow_cache_update_counter_mut(&mut self) -> &mut u32;
}

impl SpotLightEntityDataTrait for SpotLightEntityData {
    fn shape(&self) -> &super::world_base::SpotLightShape {
        &self.shape
    }
    fn shape_mut(&mut self) -> &mut super::world_base::SpotLightShape {
        &mut self.shape
    }
    fn cone_inner_angle(&self) -> &f32 {
        &self.cone_inner_angle
    }
    fn cone_inner_angle_mut(&mut self) -> &mut f32 {
        &mut self.cone_inner_angle
    }
    fn cone_outer_angle(&self) -> &f32 {
        &self.cone_outer_angle
    }
    fn cone_outer_angle_mut(&mut self) -> &mut f32 {
        &mut self.cone_outer_angle
    }
    fn frustum_fov(&self) -> &f32 {
        &self.frustum_fov
    }
    fn frustum_fov_mut(&mut self) -> &mut f32 {
        &mut self.frustum_fov
    }
    fn frustum_aspect(&self) -> &f32 {
        &self.frustum_aspect
    }
    fn frustum_aspect_mut(&mut self) -> &mut f32 {
        &mut self.frustum_aspect
    }
    fn ortho_width(&self) -> &f32 {
        &self.ortho_width
    }
    fn ortho_width_mut(&mut self) -> &mut f32 {
        &mut self.ortho_width
    }
    fn ortho_height(&self) -> &f32 {
        &self.ortho_height
    }
    fn ortho_height_mut(&mut self) -> &mut f32 {
        &mut self.ortho_height
    }
    fn near_plane(&self) -> &f32 {
        &self.near_plane
    }
    fn near_plane_mut(&mut self) -> &mut f32 {
        &mut self.near_plane
    }
    fn texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &self.texture
    }
    fn texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &mut self.texture
    }
    fn cast_shadows(&self) -> &super::core::QualityScalableEnabled {
        &self.cast_shadows
    }
    fn cast_shadows_mut(&mut self) -> &mut super::core::QualityScalableEnabled {
        &mut self.cast_shadows
    }
    fn cast_volumetric_shadows(&self) -> &super::core::QualityScalableEnabled {
        &self.cast_volumetric_shadows
    }
    fn cast_volumetric_shadows_mut(&mut self) -> &mut super::core::QualityScalableEnabled {
        &mut self.cast_volumetric_shadows
    }
    fn shadow_resolution(&self) -> &super::core::QualityLevel {
        &self.shadow_resolution
    }
    fn shadow_resolution_mut(&mut self) -> &mut super::core::QualityLevel {
        &mut self.shadow_resolution
    }
    fn shadow_radius(&self) -> &f32 {
        &self.shadow_radius
    }
    fn shadow_radius_mut(&mut self) -> &mut f32 {
        &mut self.shadow_radius
    }
    fn shadow_dimmer(&self) -> &f32 {
        &self.shadow_dimmer
    }
    fn shadow_dimmer_mut(&mut self) -> &mut f32 {
        &mut self.shadow_dimmer
    }
    fn frustum_as_cone(&self) -> &super::core::QualityScalableEnabled {
        &self.frustum_as_cone
    }
    fn frustum_as_cone_mut(&mut self) -> &mut super::core::QualityScalableEnabled {
        &mut self.frustum_as_cone
    }
    fn frustum_as_cone_angle(&self) -> &bool {
        &self.frustum_as_cone_angle
    }
    fn frustum_as_cone_angle_mut(&mut self) -> &mut bool {
        &mut self.frustum_as_cone_angle
    }
    fn frustum_as_cone_intensity_scale(&self) -> &f32 {
        &self.frustum_as_cone_intensity_scale
    }
    fn frustum_as_cone_intensity_scale_mut(&mut self) -> &mut f32 {
        &mut self.frustum_as_cone_intensity_scale
    }
    fn cast_shadows_enable(&self) -> &bool {
        &self.cast_shadows_enable
    }
    fn cast_shadows_enable_mut(&mut self) -> &mut bool {
        &mut self.cast_shadows_enable
    }
    fn cast_volumetric_shadows_enable(&self) -> &bool {
        &self.cast_volumetric_shadows_enable
    }
    fn cast_volumetric_shadows_enable_mut(&mut self) -> &mut bool {
        &mut self.cast_volumetric_shadows_enable
    }
    fn cast_shadows_min_level(&self) -> &super::core::QualityLevel {
        &self.cast_shadows_min_level
    }
    fn cast_shadows_min_level_mut(&mut self) -> &mut super::core::QualityLevel {
        &mut self.cast_shadows_min_level
    }
    fn direct_lightmap_enable(&self) -> &bool {
        &self.direct_lightmap_enable
    }
    fn direct_lightmap_enable_mut(&mut self) -> &mut bool {
        &mut self.direct_lightmap_enable
    }
    fn color(&self) -> &super::core::Vec3 {
        &self.color
    }
    fn color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.color
    }
    fn radius(&self) -> &f32 {
        &self.radius
    }
    fn radius_mut(&mut self) -> &mut f32 {
        &mut self.radius
    }
    fn intensity(&self) -> &f32 {
        &self.intensity
    }
    fn intensity_mut(&mut self) -> &mut f32 {
        &mut self.intensity
    }
    fn attenuation_offset(&self) -> &f32 {
        &self.attenuation_offset
    }
    fn attenuation_offset_mut(&mut self) -> &mut f32 {
        &mut self.attenuation_offset
    }
    fn direct_light_enable(&self) -> &bool {
        &self.direct_light_enable
    }
    fn direct_light_enable_mut(&mut self) -> &mut bool {
        &mut self.direct_light_enable
    }
    fn specular_enable(&self) -> &bool {
        &self.specular_enable
    }
    fn specular_enable_mut(&mut self) -> &mut bool {
        &mut self.specular_enable
    }
    fn enlighten_color_mode(&self) -> &super::world_base::EnlightenColorMode {
        &self.enlighten_color_mode
    }
    fn enlighten_color_mode_mut(&mut self) -> &mut super::world_base::EnlightenColorMode {
        &mut self.enlighten_color_mode
    }
    fn enlighten_enable(&self) -> &bool {
        &self.enlighten_enable
    }
    fn enlighten_enable_mut(&mut self) -> &mut bool {
        &mut self.enlighten_enable
    }
    fn enlighten_color_scale(&self) -> &super::core::Vec3 {
        &self.enlighten_color_scale
    }
    fn enlighten_color_scale_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.enlighten_color_scale
    }
    fn particle_color_scale(&self) -> &super::core::Vec3 {
        &self.particle_color_scale
    }
    fn particle_color_scale_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.particle_color_scale
    }
    fn exposure_compensation(&self) -> &f32 {
        &self.exposure_compensation
    }
    fn exposure_compensation_mut(&mut self) -> &mut f32 {
        &mut self.exposure_compensation
    }
    fn shadow_cache_enable(&self) -> &bool {
        &self.shadow_cache_enable
    }
    fn shadow_cache_enable_mut(&mut self) -> &mut bool {
        &mut self.shadow_cache_enable
    }
    fn shadow_cache_update_priority(&self) -> &f32 {
        &self.shadow_cache_update_priority
    }
    fn shadow_cache_update_priority_mut(&mut self) -> &mut f32 {
        &mut self.shadow_cache_update_priority
    }
    fn shadow_cache_update_counter(&self) -> &u32 {
        &self.shadow_cache_update_counter
    }
    fn shadow_cache_update_counter_mut(&mut self) -> &mut u32 {
        &mut self.shadow_cache_update_counter
    }
}

impl LocalLightEntityDataTrait for SpotLightEntityData {
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for SpotLightEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for SpotLightEntityData {
}

impl super::entity::GameObjectDataTrait for SpotLightEntityData {
}

impl super::core::DataBusPeerTrait for SpotLightEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SpotLightEntityData {
}

impl super::core::DataContainerTrait for SpotLightEntityData {
}

pub static SPOTLIGHTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpotLightEntityData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(LOCALLIGHTENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SpotLightEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Shape",
                flags: MemberInfoFlags::new(0),
                field_type: "SpotLightShape",
                rust_offset: offset_of!(SpotLightEntityData, shape),
            },
            FieldInfoData {
                name: "ConeInnerAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpotLightEntityData, cone_inner_angle),
            },
            FieldInfoData {
                name: "ConeOuterAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpotLightEntityData, cone_outer_angle),
            },
            FieldInfoData {
                name: "FrustumFov",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpotLightEntityData, frustum_fov),
            },
            FieldInfoData {
                name: "FrustumAspect",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpotLightEntityData, frustum_aspect),
            },
            FieldInfoData {
                name: "OrthoWidth",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpotLightEntityData, ortho_width),
            },
            FieldInfoData {
                name: "OrthoHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpotLightEntityData, ortho_height),
            },
            FieldInfoData {
                name: "NearPlane",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpotLightEntityData, near_plane),
            },
            FieldInfoData {
                name: "Texture",
                flags: MemberInfoFlags::new(0),
                field_type: "TextureBaseAsset",
                rust_offset: offset_of!(SpotLightEntityData, texture),
            },
            FieldInfoData {
                name: "CastShadows",
                flags: MemberInfoFlags::new(0),
                field_type: "QualityScalableEnabled",
                rust_offset: offset_of!(SpotLightEntityData, cast_shadows),
            },
            FieldInfoData {
                name: "CastVolumetricShadows",
                flags: MemberInfoFlags::new(0),
                field_type: "QualityScalableEnabled",
                rust_offset: offset_of!(SpotLightEntityData, cast_volumetric_shadows),
            },
            FieldInfoData {
                name: "ShadowResolution",
                flags: MemberInfoFlags::new(0),
                field_type: "QualityLevel",
                rust_offset: offset_of!(SpotLightEntityData, shadow_resolution),
            },
            FieldInfoData {
                name: "ShadowRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpotLightEntityData, shadow_radius),
            },
            FieldInfoData {
                name: "ShadowDimmer",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpotLightEntityData, shadow_dimmer),
            },
            FieldInfoData {
                name: "FrustumAsCone",
                flags: MemberInfoFlags::new(0),
                field_type: "QualityScalableEnabled",
                rust_offset: offset_of!(SpotLightEntityData, frustum_as_cone),
            },
            FieldInfoData {
                name: "FrustumAsConeAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SpotLightEntityData, frustum_as_cone_angle),
            },
            FieldInfoData {
                name: "FrustumAsConeIntensityScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpotLightEntityData, frustum_as_cone_intensity_scale),
            },
            FieldInfoData {
                name: "CastShadowsEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SpotLightEntityData, cast_shadows_enable),
            },
            FieldInfoData {
                name: "CastVolumetricShadowsEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SpotLightEntityData, cast_volumetric_shadows_enable),
            },
            FieldInfoData {
                name: "CastShadowsMinLevel",
                flags: MemberInfoFlags::new(0),
                field_type: "QualityLevel",
                rust_offset: offset_of!(SpotLightEntityData, cast_shadows_min_level),
            },
            FieldInfoData {
                name: "DirectLightmapEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SpotLightEntityData, direct_lightmap_enable),
            },
            FieldInfoData {
                name: "Color",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SpotLightEntityData, color),
            },
            FieldInfoData {
                name: "Radius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpotLightEntityData, radius),
            },
            FieldInfoData {
                name: "Intensity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpotLightEntityData, intensity),
            },
            FieldInfoData {
                name: "AttenuationOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpotLightEntityData, attenuation_offset),
            },
            FieldInfoData {
                name: "DirectLightEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SpotLightEntityData, direct_light_enable),
            },
            FieldInfoData {
                name: "SpecularEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SpotLightEntityData, specular_enable),
            },
            FieldInfoData {
                name: "EnlightenColorMode",
                flags: MemberInfoFlags::new(0),
                field_type: "EnlightenColorMode",
                rust_offset: offset_of!(SpotLightEntityData, enlighten_color_mode),
            },
            FieldInfoData {
                name: "EnlightenEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SpotLightEntityData, enlighten_enable),
            },
            FieldInfoData {
                name: "EnlightenColorScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SpotLightEntityData, enlighten_color_scale),
            },
            FieldInfoData {
                name: "ParticleColorScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SpotLightEntityData, particle_color_scale),
            },
            FieldInfoData {
                name: "ExposureCompensation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpotLightEntityData, exposure_compensation),
            },
            FieldInfoData {
                name: "ShadowCacheEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SpotLightEntityData, shadow_cache_enable),
            },
            FieldInfoData {
                name: "ShadowCacheUpdatePriority",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpotLightEntityData, shadow_cache_update_priority),
            },
            FieldInfoData {
                name: "ShadowCacheUpdateCounter",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(SpotLightEntityData, shadow_cache_update_counter),
            },
        ],
    }),
    array_type: Some(SPOTLIGHTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SpotLightEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SPOTLIGHTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SPOTLIGHTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpotLightEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("SpotLightEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PointLightEntityData {
    pub _glacier_base: LocalLightEntityData,
    pub width: f32,
    pub translucency_ambient: f32,
    pub translucency_scale: f32,
    pub translucency_power: f32,
    pub translucency_distortion: f32,
    pub direct_lightmap_enable: bool,
    pub color: super::core::Vec3,
    pub radius: f32,
    pub intensity: f32,
    pub attenuation_offset: f32,
    pub direct_light_enable: bool,
    pub specular_enable: bool,
    pub enlighten_color_mode: super::world_base::EnlightenColorMode,
    pub enlighten_enable: bool,
    pub enlighten_color_scale: super::core::Vec3,
    pub particle_color_scale: super::core::Vec3,
    pub exposure_compensation: f32,
    pub shadow_cache_enable: bool,
    pub shadow_cache_update_priority: f32,
    pub shadow_cache_update_counter: u32,
}

pub trait PointLightEntityDataTrait: LocalLightEntityDataTrait {
    fn width(&self) -> &f32;
    fn width_mut(&mut self) -> &mut f32;
    fn translucency_ambient(&self) -> &f32;
    fn translucency_ambient_mut(&mut self) -> &mut f32;
    fn translucency_scale(&self) -> &f32;
    fn translucency_scale_mut(&mut self) -> &mut f32;
    fn translucency_power(&self) -> &f32;
    fn translucency_power_mut(&mut self) -> &mut f32;
    fn translucency_distortion(&self) -> &f32;
    fn translucency_distortion_mut(&mut self) -> &mut f32;
    fn direct_lightmap_enable(&self) -> &bool;
    fn direct_lightmap_enable_mut(&mut self) -> &mut bool;
    fn color(&self) -> &super::core::Vec3;
    fn color_mut(&mut self) -> &mut super::core::Vec3;
    fn radius(&self) -> &f32;
    fn radius_mut(&mut self) -> &mut f32;
    fn intensity(&self) -> &f32;
    fn intensity_mut(&mut self) -> &mut f32;
    fn attenuation_offset(&self) -> &f32;
    fn attenuation_offset_mut(&mut self) -> &mut f32;
    fn direct_light_enable(&self) -> &bool;
    fn direct_light_enable_mut(&mut self) -> &mut bool;
    fn specular_enable(&self) -> &bool;
    fn specular_enable_mut(&mut self) -> &mut bool;
    fn enlighten_color_mode(&self) -> &super::world_base::EnlightenColorMode;
    fn enlighten_color_mode_mut(&mut self) -> &mut super::world_base::EnlightenColorMode;
    fn enlighten_enable(&self) -> &bool;
    fn enlighten_enable_mut(&mut self) -> &mut bool;
    fn enlighten_color_scale(&self) -> &super::core::Vec3;
    fn enlighten_color_scale_mut(&mut self) -> &mut super::core::Vec3;
    fn particle_color_scale(&self) -> &super::core::Vec3;
    fn particle_color_scale_mut(&mut self) -> &mut super::core::Vec3;
    fn exposure_compensation(&self) -> &f32;
    fn exposure_compensation_mut(&mut self) -> &mut f32;
    fn shadow_cache_enable(&self) -> &bool;
    fn shadow_cache_enable_mut(&mut self) -> &mut bool;
    fn shadow_cache_update_priority(&self) -> &f32;
    fn shadow_cache_update_priority_mut(&mut self) -> &mut f32;
    fn shadow_cache_update_counter(&self) -> &u32;
    fn shadow_cache_update_counter_mut(&mut self) -> &mut u32;
}

impl PointLightEntityDataTrait for PointLightEntityData {
    fn width(&self) -> &f32 {
        &self.width
    }
    fn width_mut(&mut self) -> &mut f32 {
        &mut self.width
    }
    fn translucency_ambient(&self) -> &f32 {
        &self.translucency_ambient
    }
    fn translucency_ambient_mut(&mut self) -> &mut f32 {
        &mut self.translucency_ambient
    }
    fn translucency_scale(&self) -> &f32 {
        &self.translucency_scale
    }
    fn translucency_scale_mut(&mut self) -> &mut f32 {
        &mut self.translucency_scale
    }
    fn translucency_power(&self) -> &f32 {
        &self.translucency_power
    }
    fn translucency_power_mut(&mut self) -> &mut f32 {
        &mut self.translucency_power
    }
    fn translucency_distortion(&self) -> &f32 {
        &self.translucency_distortion
    }
    fn translucency_distortion_mut(&mut self) -> &mut f32 {
        &mut self.translucency_distortion
    }
    fn direct_lightmap_enable(&self) -> &bool {
        &self.direct_lightmap_enable
    }
    fn direct_lightmap_enable_mut(&mut self) -> &mut bool {
        &mut self.direct_lightmap_enable
    }
    fn color(&self) -> &super::core::Vec3 {
        &self.color
    }
    fn color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.color
    }
    fn radius(&self) -> &f32 {
        &self.radius
    }
    fn radius_mut(&mut self) -> &mut f32 {
        &mut self.radius
    }
    fn intensity(&self) -> &f32 {
        &self.intensity
    }
    fn intensity_mut(&mut self) -> &mut f32 {
        &mut self.intensity
    }
    fn attenuation_offset(&self) -> &f32 {
        &self.attenuation_offset
    }
    fn attenuation_offset_mut(&mut self) -> &mut f32 {
        &mut self.attenuation_offset
    }
    fn direct_light_enable(&self) -> &bool {
        &self.direct_light_enable
    }
    fn direct_light_enable_mut(&mut self) -> &mut bool {
        &mut self.direct_light_enable
    }
    fn specular_enable(&self) -> &bool {
        &self.specular_enable
    }
    fn specular_enable_mut(&mut self) -> &mut bool {
        &mut self.specular_enable
    }
    fn enlighten_color_mode(&self) -> &super::world_base::EnlightenColorMode {
        &self.enlighten_color_mode
    }
    fn enlighten_color_mode_mut(&mut self) -> &mut super::world_base::EnlightenColorMode {
        &mut self.enlighten_color_mode
    }
    fn enlighten_enable(&self) -> &bool {
        &self.enlighten_enable
    }
    fn enlighten_enable_mut(&mut self) -> &mut bool {
        &mut self.enlighten_enable
    }
    fn enlighten_color_scale(&self) -> &super::core::Vec3 {
        &self.enlighten_color_scale
    }
    fn enlighten_color_scale_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.enlighten_color_scale
    }
    fn particle_color_scale(&self) -> &super::core::Vec3 {
        &self.particle_color_scale
    }
    fn particle_color_scale_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.particle_color_scale
    }
    fn exposure_compensation(&self) -> &f32 {
        &self.exposure_compensation
    }
    fn exposure_compensation_mut(&mut self) -> &mut f32 {
        &mut self.exposure_compensation
    }
    fn shadow_cache_enable(&self) -> &bool {
        &self.shadow_cache_enable
    }
    fn shadow_cache_enable_mut(&mut self) -> &mut bool {
        &mut self.shadow_cache_enable
    }
    fn shadow_cache_update_priority(&self) -> &f32 {
        &self.shadow_cache_update_priority
    }
    fn shadow_cache_update_priority_mut(&mut self) -> &mut f32 {
        &mut self.shadow_cache_update_priority
    }
    fn shadow_cache_update_counter(&self) -> &u32 {
        &self.shadow_cache_update_counter
    }
    fn shadow_cache_update_counter_mut(&mut self) -> &mut u32 {
        &mut self.shadow_cache_update_counter
    }
}

impl LocalLightEntityDataTrait for PointLightEntityData {
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for PointLightEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for PointLightEntityData {
}

impl super::entity::GameObjectDataTrait for PointLightEntityData {
}

impl super::core::DataBusPeerTrait for PointLightEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PointLightEntityData {
}

impl super::core::DataContainerTrait for PointLightEntityData {
}

pub static POINTLIGHTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PointLightEntityData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(LOCALLIGHTENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PointLightEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Width",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PointLightEntityData, width),
            },
            FieldInfoData {
                name: "TranslucencyAmbient",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PointLightEntityData, translucency_ambient),
            },
            FieldInfoData {
                name: "TranslucencyScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PointLightEntityData, translucency_scale),
            },
            FieldInfoData {
                name: "TranslucencyPower",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PointLightEntityData, translucency_power),
            },
            FieldInfoData {
                name: "TranslucencyDistortion",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PointLightEntityData, translucency_distortion),
            },
            FieldInfoData {
                name: "DirectLightmapEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PointLightEntityData, direct_lightmap_enable),
            },
            FieldInfoData {
                name: "Color",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(PointLightEntityData, color),
            },
            FieldInfoData {
                name: "Radius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PointLightEntityData, radius),
            },
            FieldInfoData {
                name: "Intensity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PointLightEntityData, intensity),
            },
            FieldInfoData {
                name: "AttenuationOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PointLightEntityData, attenuation_offset),
            },
            FieldInfoData {
                name: "DirectLightEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PointLightEntityData, direct_light_enable),
            },
            FieldInfoData {
                name: "SpecularEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PointLightEntityData, specular_enable),
            },
            FieldInfoData {
                name: "EnlightenColorMode",
                flags: MemberInfoFlags::new(0),
                field_type: "EnlightenColorMode",
                rust_offset: offset_of!(PointLightEntityData, enlighten_color_mode),
            },
            FieldInfoData {
                name: "EnlightenEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PointLightEntityData, enlighten_enable),
            },
            FieldInfoData {
                name: "EnlightenColorScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(PointLightEntityData, enlighten_color_scale),
            },
            FieldInfoData {
                name: "ParticleColorScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(PointLightEntityData, particle_color_scale),
            },
            FieldInfoData {
                name: "ExposureCompensation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PointLightEntityData, exposure_compensation),
            },
            FieldInfoData {
                name: "ShadowCacheEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PointLightEntityData, shadow_cache_enable),
            },
            FieldInfoData {
                name: "ShadowCacheUpdatePriority",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PointLightEntityData, shadow_cache_update_priority),
            },
            FieldInfoData {
                name: "ShadowCacheUpdateCounter",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(PointLightEntityData, shadow_cache_update_counter),
            },
        ],
    }),
    array_type: Some(POINTLIGHTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PointLightEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        POINTLIGHTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static POINTLIGHTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PointLightEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("PointLightEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LocalLightEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub enabled: bool,
}

pub trait LocalLightEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
}

impl LocalLightEntityDataTrait for LocalLightEntityData {
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
}

impl super::entity::SpatialEntityDataTrait for LocalLightEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for LocalLightEntityData {
}

impl super::entity::GameObjectDataTrait for LocalLightEntityData {
}

impl super::core::DataBusPeerTrait for LocalLightEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for LocalLightEntityData {
}

impl super::core::DataContainerTrait for LocalLightEntityData {
}

pub static LOCALLIGHTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalLightEntityData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LocalLightEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LocalLightEntityData, enabled),
            },
        ],
    }),
    array_type: Some(LOCALLIGHTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for LocalLightEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        LOCALLIGHTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LOCALLIGHTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalLightEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("LocalLightEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LensFlareReferenceObjectData {
    pub _glacier_base: super::entity::SpatialReferenceObjectData,
}

pub trait LensFlareReferenceObjectDataTrait: super::entity::SpatialReferenceObjectDataTrait {
}

impl LensFlareReferenceObjectDataTrait for LensFlareReferenceObjectData {
}

impl super::entity::SpatialReferenceObjectDataTrait for LensFlareReferenceObjectData {
    fn local_player_id(&self) -> &super::core::LocalPlayerId {
        self._glacier_base.local_player_id()
    }
    fn local_player_id_mut(&mut self) -> &mut super::core::LocalPlayerId {
        self._glacier_base.local_player_id_mut()
    }
}

impl super::entity::ReferenceObjectDataTrait for LensFlareReferenceObjectData {
    fn blueprint_transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.blueprint_transform()
    }
    fn blueprint_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.blueprint_transform_mut()
    }
    fn blueprint(&self) -> &Option<Arc<Mutex<dyn super::entity::BlueprintTrait>>> {
        self._glacier_base.blueprint()
    }
    fn blueprint_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::BlueprintTrait>>> {
        self._glacier_base.blueprint_mut()
    }
    fn object_variation(&self) -> &Option<Arc<Mutex<dyn super::entity::ObjectVariationTrait>>> {
        self._glacier_base.object_variation()
    }
    fn object_variation_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::ObjectVariationTrait>>> {
        self._glacier_base.object_variation_mut()
    }
    fn stream_realm(&self) -> &super::entity::StreamRealm {
        self._glacier_base.stream_realm()
    }
    fn stream_realm_mut(&mut self) -> &mut super::entity::StreamRealm {
        self._glacier_base.stream_realm_mut()
    }
    fn radiosity_type_override(&self) -> &super::core::RadiosityTypeOverride {
        self._glacier_base.radiosity_type_override()
    }
    fn radiosity_type_override_mut(&mut self) -> &mut super::core::RadiosityTypeOverride {
        self._glacier_base.radiosity_type_override_mut()
    }
    fn lightmap_resolution_scale(&self) -> &u32 {
        self._glacier_base.lightmap_resolution_scale()
    }
    fn lightmap_resolution_scale_mut(&mut self) -> &mut u32 {
        self._glacier_base.lightmap_resolution_scale_mut()
    }
    fn lightmap_scale_with_size(&self) -> &bool {
        self._glacier_base.lightmap_scale_with_size()
    }
    fn lightmap_scale_with_size_mut(&mut self) -> &mut bool {
        self._glacier_base.lightmap_scale_with_size_mut()
    }
    fn rendering_overrides(&self) -> &super::core::RenderingOverrides {
        self._glacier_base.rendering_overrides()
    }
    fn rendering_overrides_mut(&mut self) -> &mut super::core::RenderingOverrides {
        self._glacier_base.rendering_overrides_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
    fn create_indestructible_entity(&self) -> &bool {
        self._glacier_base.create_indestructible_entity()
    }
    fn create_indestructible_entity_mut(&mut self) -> &mut bool {
        self._glacier_base.create_indestructible_entity_mut()
    }
}

impl super::entity::GameObjectDataTrait for LensFlareReferenceObjectData {
}

impl super::core::DataBusPeerTrait for LensFlareReferenceObjectData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for LensFlareReferenceObjectData {
}

impl super::core::DataContainerTrait for LensFlareReferenceObjectData {
}

pub static LENSFLAREREFERENCEOBJECTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LensFlareReferenceObjectData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALREFERENCEOBJECTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LensFlareReferenceObjectData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(LENSFLAREREFERENCEOBJECTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for LensFlareReferenceObjectData {
    fn type_info(&self) -> &'static TypeInfo {
        LENSFLAREREFERENCEOBJECTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LENSFLAREREFERENCEOBJECTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LensFlareReferenceObjectData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("LensFlareReferenceObjectData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LensFlareBlueprint {
    pub _glacier_base: super::entity::ObjectBlueprint,
    pub time_delta_type: super::entity::TimeDeltaType,
}

pub trait LensFlareBlueprintTrait: super::entity::ObjectBlueprintTrait {
    fn time_delta_type(&self) -> &super::entity::TimeDeltaType;
    fn time_delta_type_mut(&mut self) -> &mut super::entity::TimeDeltaType;
}

impl LensFlareBlueprintTrait for LensFlareBlueprint {
    fn time_delta_type(&self) -> &super::entity::TimeDeltaType {
        &self.time_delta_type
    }
    fn time_delta_type_mut(&mut self) -> &mut super::entity::TimeDeltaType {
        &mut self.time_delta_type
    }
}

impl super::entity::ObjectBlueprintTrait for LensFlareBlueprint {
    fn object(&self) -> &Option<Arc<Mutex<dyn super::entity::EntityDataTrait>>> {
        self._glacier_base.object()
    }
    fn object_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::EntityDataTrait>>> {
        self._glacier_base.object_mut()
    }
}

impl super::entity::BlueprintTrait for LensFlareBlueprint {
    fn objects(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.objects()
    }
    fn objects_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.objects_mut()
    }
    fn schematics(&self) -> &Option<Arc<Mutex<dyn super::schematics::SchematicsBaseAssetTrait>>> {
        self._glacier_base.schematics()
    }
    fn schematics_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::schematics::SchematicsBaseAssetTrait>>> {
        self._glacier_base.schematics_mut()
    }
}

impl super::entity::EntityBusDataTrait for LensFlareBlueprint {
    fn event_connections(&self) -> &Vec<super::entity::EventConnection> {
        self._glacier_base.event_connections()
    }
    fn event_connections_mut(&mut self) -> &mut Vec<super::entity::EventConnection> {
        self._glacier_base.event_connections_mut()
    }
}

impl super::core::DataBusDataTrait for LensFlareBlueprint {
    fn flags(&self) -> &u16 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.flags_mut()
    }
    fn property_connections(&self) -> &Vec<super::core::PropertyConnection> {
        self._glacier_base.property_connections()
    }
    fn property_connections_mut(&mut self) -> &mut Vec<super::core::PropertyConnection> {
        self._glacier_base.property_connections_mut()
    }
    fn link_connections(&self) -> &Vec<super::core::LinkConnection> {
        self._glacier_base.link_connections()
    }
    fn link_connections_mut(&mut self) -> &mut Vec<super::core::LinkConnection> {
        self._glacier_base.link_connections_mut()
    }
    fn interface(&self) -> &Option<Arc<Mutex<dyn super::core::DynamicDataContainerTrait>>> {
        self._glacier_base.interface()
    }
    fn interface_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::DynamicDataContainerTrait>>> {
        self._glacier_base.interface_mut()
    }
}

impl super::core::AssetTrait for LensFlareBlueprint {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for LensFlareBlueprint {
}

pub static LENSFLAREBLUEPRINT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LensFlareBlueprint",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::OBJECTBLUEPRINT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LensFlareBlueprint as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "TimeDeltaType",
                flags: MemberInfoFlags::new(0),
                field_type: "TimeDeltaType",
                rust_offset: offset_of!(LensFlareBlueprint, time_delta_type),
            },
        ],
    }),
    array_type: Some(LENSFLAREBLUEPRINT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LensFlareBlueprint {
    fn type_info(&self) -> &'static TypeInfo {
        LENSFLAREBLUEPRINT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LENSFLAREBLUEPRINT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LensFlareBlueprint-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("LensFlareBlueprint"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LensFlareEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub debug_draw_occluder: bool,
    pub half_res: bool,
    pub occluder_size: f32,
    pub render_mode: super::world_base::LensFlareRenderMode,
    pub screen_clip: bool,
    pub depth_bias: f32,
    pub elements: Vec<super::world_base::LensFlareElement>,
    pub flare_direction_mode: super::world_base::FlareDirectionMode,
    pub visible: bool,
    pub dimmer: f32,
}

pub trait LensFlareEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn debug_draw_occluder(&self) -> &bool;
    fn debug_draw_occluder_mut(&mut self) -> &mut bool;
    fn half_res(&self) -> &bool;
    fn half_res_mut(&mut self) -> &mut bool;
    fn occluder_size(&self) -> &f32;
    fn occluder_size_mut(&mut self) -> &mut f32;
    fn render_mode(&self) -> &super::world_base::LensFlareRenderMode;
    fn render_mode_mut(&mut self) -> &mut super::world_base::LensFlareRenderMode;
    fn screen_clip(&self) -> &bool;
    fn screen_clip_mut(&mut self) -> &mut bool;
    fn depth_bias(&self) -> &f32;
    fn depth_bias_mut(&mut self) -> &mut f32;
    fn elements(&self) -> &Vec<super::world_base::LensFlareElement>;
    fn elements_mut(&mut self) -> &mut Vec<super::world_base::LensFlareElement>;
    fn flare_direction_mode(&self) -> &super::world_base::FlareDirectionMode;
    fn flare_direction_mode_mut(&mut self) -> &mut super::world_base::FlareDirectionMode;
    fn visible(&self) -> &bool;
    fn visible_mut(&mut self) -> &mut bool;
    fn dimmer(&self) -> &f32;
    fn dimmer_mut(&mut self) -> &mut f32;
}

impl LensFlareEntityDataTrait for LensFlareEntityData {
    fn debug_draw_occluder(&self) -> &bool {
        &self.debug_draw_occluder
    }
    fn debug_draw_occluder_mut(&mut self) -> &mut bool {
        &mut self.debug_draw_occluder
    }
    fn half_res(&self) -> &bool {
        &self.half_res
    }
    fn half_res_mut(&mut self) -> &mut bool {
        &mut self.half_res
    }
    fn occluder_size(&self) -> &f32 {
        &self.occluder_size
    }
    fn occluder_size_mut(&mut self) -> &mut f32 {
        &mut self.occluder_size
    }
    fn render_mode(&self) -> &super::world_base::LensFlareRenderMode {
        &self.render_mode
    }
    fn render_mode_mut(&mut self) -> &mut super::world_base::LensFlareRenderMode {
        &mut self.render_mode
    }
    fn screen_clip(&self) -> &bool {
        &self.screen_clip
    }
    fn screen_clip_mut(&mut self) -> &mut bool {
        &mut self.screen_clip
    }
    fn depth_bias(&self) -> &f32 {
        &self.depth_bias
    }
    fn depth_bias_mut(&mut self) -> &mut f32 {
        &mut self.depth_bias
    }
    fn elements(&self) -> &Vec<super::world_base::LensFlareElement> {
        &self.elements
    }
    fn elements_mut(&mut self) -> &mut Vec<super::world_base::LensFlareElement> {
        &mut self.elements
    }
    fn flare_direction_mode(&self) -> &super::world_base::FlareDirectionMode {
        &self.flare_direction_mode
    }
    fn flare_direction_mode_mut(&mut self) -> &mut super::world_base::FlareDirectionMode {
        &mut self.flare_direction_mode
    }
    fn visible(&self) -> &bool {
        &self.visible
    }
    fn visible_mut(&mut self) -> &mut bool {
        &mut self.visible
    }
    fn dimmer(&self) -> &f32 {
        &self.dimmer
    }
    fn dimmer_mut(&mut self) -> &mut f32 {
        &mut self.dimmer
    }
}

impl super::entity::SpatialEntityDataTrait for LensFlareEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for LensFlareEntityData {
}

impl super::entity::GameObjectDataTrait for LensFlareEntityData {
}

impl super::core::DataBusPeerTrait for LensFlareEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for LensFlareEntityData {
}

impl super::core::DataContainerTrait for LensFlareEntityData {
}

pub static LENSFLAREENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LensFlareEntityData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LensFlareEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DebugDrawOccluder",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LensFlareEntityData, debug_draw_occluder),
            },
            FieldInfoData {
                name: "HalfRes",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LensFlareEntityData, half_res),
            },
            FieldInfoData {
                name: "OccluderSize",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LensFlareEntityData, occluder_size),
            },
            FieldInfoData {
                name: "RenderMode",
                flags: MemberInfoFlags::new(0),
                field_type: "LensFlareRenderMode",
                rust_offset: offset_of!(LensFlareEntityData, render_mode),
            },
            FieldInfoData {
                name: "ScreenClip",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LensFlareEntityData, screen_clip),
            },
            FieldInfoData {
                name: "DepthBias",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LensFlareEntityData, depth_bias),
            },
            FieldInfoData {
                name: "Elements",
                flags: MemberInfoFlags::new(144),
                field_type: "LensFlareElement-Array",
                rust_offset: offset_of!(LensFlareEntityData, elements),
            },
            FieldInfoData {
                name: "FlareDirectionMode",
                flags: MemberInfoFlags::new(0),
                field_type: "FlareDirectionMode",
                rust_offset: offset_of!(LensFlareEntityData, flare_direction_mode),
            },
            FieldInfoData {
                name: "Visible",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LensFlareEntityData, visible),
            },
            FieldInfoData {
                name: "Dimmer",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LensFlareEntityData, dimmer),
            },
        ],
    }),
    array_type: Some(LENSFLAREENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for LensFlareEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        LENSFLAREENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LENSFLAREENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LensFlareEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("LensFlareEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FogExclusionVolumeEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub fog_exclusion_volume_shape: super::world_base::FogExclusionVolumeShape,
    pub fog_volume_strength: f32,
    pub fade_out_start: f32,
    pub fade_out_end: f32,
    pub enabled: bool,
}

pub trait FogExclusionVolumeEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn fog_exclusion_volume_shape(&self) -> &super::world_base::FogExclusionVolumeShape;
    fn fog_exclusion_volume_shape_mut(&mut self) -> &mut super::world_base::FogExclusionVolumeShape;
    fn fog_volume_strength(&self) -> &f32;
    fn fog_volume_strength_mut(&mut self) -> &mut f32;
    fn fade_out_start(&self) -> &f32;
    fn fade_out_start_mut(&mut self) -> &mut f32;
    fn fade_out_end(&self) -> &f32;
    fn fade_out_end_mut(&mut self) -> &mut f32;
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
}

impl FogExclusionVolumeEntityDataTrait for FogExclusionVolumeEntityData {
    fn fog_exclusion_volume_shape(&self) -> &super::world_base::FogExclusionVolumeShape {
        &self.fog_exclusion_volume_shape
    }
    fn fog_exclusion_volume_shape_mut(&mut self) -> &mut super::world_base::FogExclusionVolumeShape {
        &mut self.fog_exclusion_volume_shape
    }
    fn fog_volume_strength(&self) -> &f32 {
        &self.fog_volume_strength
    }
    fn fog_volume_strength_mut(&mut self) -> &mut f32 {
        &mut self.fog_volume_strength
    }
    fn fade_out_start(&self) -> &f32 {
        &self.fade_out_start
    }
    fn fade_out_start_mut(&mut self) -> &mut f32 {
        &mut self.fade_out_start
    }
    fn fade_out_end(&self) -> &f32 {
        &self.fade_out_end
    }
    fn fade_out_end_mut(&mut self) -> &mut f32 {
        &mut self.fade_out_end
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
}

impl super::entity::SpatialEntityDataTrait for FogExclusionVolumeEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for FogExclusionVolumeEntityData {
}

impl super::entity::GameObjectDataTrait for FogExclusionVolumeEntityData {
}

impl super::core::DataBusPeerTrait for FogExclusionVolumeEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for FogExclusionVolumeEntityData {
}

impl super::core::DataContainerTrait for FogExclusionVolumeEntityData {
}

pub static FOGEXCLUSIONVOLUMEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FogExclusionVolumeEntityData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FogExclusionVolumeEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "FogExclusionVolumeShape",
                flags: MemberInfoFlags::new(0),
                field_type: "FogExclusionVolumeShape",
                rust_offset: offset_of!(FogExclusionVolumeEntityData, fog_exclusion_volume_shape),
            },
            FieldInfoData {
                name: "FogVolumeStrength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FogExclusionVolumeEntityData, fog_volume_strength),
            },
            FieldInfoData {
                name: "FadeOutStart",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FogExclusionVolumeEntityData, fade_out_start),
            },
            FieldInfoData {
                name: "FadeOutEnd",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FogExclusionVolumeEntityData, fade_out_end),
            },
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FogExclusionVolumeEntityData, enabled),
            },
        ],
    }),
    array_type: Some(FOGEXCLUSIONVOLUMEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for FogExclusionVolumeEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        FOGEXCLUSIONVOLUMEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FOGEXCLUSIONVOLUMEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FogExclusionVolumeEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("FogExclusionVolumeEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DistantShadowCacheVolumeEntityData {
    pub _glacier_base: BakeableTextureEntityData,
    pub mode: super::render_base::ShadowCacheMode,
    pub resolution: u32,
    pub doublebuffer: bool,
    pub depth_bias: super::render_base::ShadowCacheDepthBias,
    pub dynamic_prod_priority: u32,
    pub tiles_per_side: u32,
    pub do_not_update_baked_texture: bool,
    pub baked_texture: Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>,
    pub enabled: bool,
}

pub trait DistantShadowCacheVolumeEntityDataTrait: BakeableTextureEntityDataTrait {
    fn mode(&self) -> &super::render_base::ShadowCacheMode;
    fn mode_mut(&mut self) -> &mut super::render_base::ShadowCacheMode;
    fn resolution(&self) -> &u32;
    fn resolution_mut(&mut self) -> &mut u32;
    fn doublebuffer(&self) -> &bool;
    fn doublebuffer_mut(&mut self) -> &mut bool;
    fn depth_bias(&self) -> &super::render_base::ShadowCacheDepthBias;
    fn depth_bias_mut(&mut self) -> &mut super::render_base::ShadowCacheDepthBias;
    fn dynamic_prod_priority(&self) -> &u32;
    fn dynamic_prod_priority_mut(&mut self) -> &mut u32;
    fn tiles_per_side(&self) -> &u32;
    fn tiles_per_side_mut(&mut self) -> &mut u32;
    fn do_not_update_baked_texture(&self) -> &bool;
    fn do_not_update_baked_texture_mut(&mut self) -> &mut bool;
    fn baked_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn baked_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
}

impl DistantShadowCacheVolumeEntityDataTrait for DistantShadowCacheVolumeEntityData {
    fn mode(&self) -> &super::render_base::ShadowCacheMode {
        &self.mode
    }
    fn mode_mut(&mut self) -> &mut super::render_base::ShadowCacheMode {
        &mut self.mode
    }
    fn resolution(&self) -> &u32 {
        &self.resolution
    }
    fn resolution_mut(&mut self) -> &mut u32 {
        &mut self.resolution
    }
    fn doublebuffer(&self) -> &bool {
        &self.doublebuffer
    }
    fn doublebuffer_mut(&mut self) -> &mut bool {
        &mut self.doublebuffer
    }
    fn depth_bias(&self) -> &super::render_base::ShadowCacheDepthBias {
        &self.depth_bias
    }
    fn depth_bias_mut(&mut self) -> &mut super::render_base::ShadowCacheDepthBias {
        &mut self.depth_bias
    }
    fn dynamic_prod_priority(&self) -> &u32 {
        &self.dynamic_prod_priority
    }
    fn dynamic_prod_priority_mut(&mut self) -> &mut u32 {
        &mut self.dynamic_prod_priority
    }
    fn tiles_per_side(&self) -> &u32 {
        &self.tiles_per_side
    }
    fn tiles_per_side_mut(&mut self) -> &mut u32 {
        &mut self.tiles_per_side
    }
    fn do_not_update_baked_texture(&self) -> &bool {
        &self.do_not_update_baked_texture
    }
    fn do_not_update_baked_texture_mut(&mut self) -> &mut bool {
        &mut self.do_not_update_baked_texture
    }
    fn baked_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &self.baked_texture
    }
    fn baked_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &mut self.baked_texture
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
}

impl BakeableTextureEntityDataTrait for DistantShadowCacheVolumeEntityData {
}

impl super::entity::SpatialEntityDataTrait for DistantShadowCacheVolumeEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for DistantShadowCacheVolumeEntityData {
}

impl super::entity::GameObjectDataTrait for DistantShadowCacheVolumeEntityData {
}

impl super::core::DataBusPeerTrait for DistantShadowCacheVolumeEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for DistantShadowCacheVolumeEntityData {
}

impl super::core::DataContainerTrait for DistantShadowCacheVolumeEntityData {
}

pub static DISTANTSHADOWCACHEVOLUMEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DistantShadowCacheVolumeEntityData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(BAKEABLETEXTUREENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DistantShadowCacheVolumeEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Mode",
                flags: MemberInfoFlags::new(0),
                field_type: "ShadowCacheMode",
                rust_offset: offset_of!(DistantShadowCacheVolumeEntityData, mode),
            },
            FieldInfoData {
                name: "Resolution",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(DistantShadowCacheVolumeEntityData, resolution),
            },
            FieldInfoData {
                name: "Doublebuffer",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DistantShadowCacheVolumeEntityData, doublebuffer),
            },
            FieldInfoData {
                name: "DepthBias",
                flags: MemberInfoFlags::new(0),
                field_type: "ShadowCacheDepthBias",
                rust_offset: offset_of!(DistantShadowCacheVolumeEntityData, depth_bias),
            },
            FieldInfoData {
                name: "DynamicProdPriority",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(DistantShadowCacheVolumeEntityData, dynamic_prod_priority),
            },
            FieldInfoData {
                name: "TilesPerSide",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(DistantShadowCacheVolumeEntityData, tiles_per_side),
            },
            FieldInfoData {
                name: "DoNotUpdateBakedTexture",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DistantShadowCacheVolumeEntityData, do_not_update_baked_texture),
            },
            FieldInfoData {
                name: "BakedTexture",
                flags: MemberInfoFlags::new(0),
                field_type: "TextureBaseAsset",
                rust_offset: offset_of!(DistantShadowCacheVolumeEntityData, baked_texture),
            },
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DistantShadowCacheVolumeEntityData, enabled),
            },
        ],
    }),
    array_type: Some(DISTANTSHADOWCACHEVOLUMEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for DistantShadowCacheVolumeEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        DISTANTSHADOWCACHEVOLUMEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DISTANTSHADOWCACHEVOLUMEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DistantShadowCacheVolumeEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("DistantShadowCacheVolumeEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SimpleVolumetricsEntity {
    pub _glacier_base: super::entity::Entity,
}

pub trait SimpleVolumetricsEntityTrait: super::entity::EntityTrait {
}

impl SimpleVolumetricsEntityTrait for SimpleVolumetricsEntity {
}

impl super::entity::EntityTrait for SimpleVolumetricsEntity {
}

impl super::entity::EntityBusPeerTrait for SimpleVolumetricsEntity {
}

pub static SIMPLEVOLUMETRICSENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleVolumetricsEntity",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SimpleVolumetricsEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SIMPLEVOLUMETRICSENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SimpleVolumetricsEntity {
    fn type_info(&self) -> &'static TypeInfo {
        SIMPLEVOLUMETRICSENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SIMPLEVOLUMETRICSENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleVolumetricsEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("SimpleVolumetricsEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ScreenshotCaptureEntity {
    pub _glacier_base: super::entity::Entity,
}

pub trait ScreenshotCaptureEntityTrait: super::entity::EntityTrait {
}

impl ScreenshotCaptureEntityTrait for ScreenshotCaptureEntity {
}

impl super::entity::EntityTrait for ScreenshotCaptureEntity {
}

impl super::entity::EntityBusPeerTrait for ScreenshotCaptureEntity {
}

pub static SCREENSHOTCAPTUREENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScreenshotCaptureEntity",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ScreenshotCaptureEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SCREENSHOTCAPTUREENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ScreenshotCaptureEntity {
    fn type_info(&self) -> &'static TypeInfo {
        SCREENSHOTCAPTUREENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SCREENSHOTCAPTUREENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScreenshotCaptureEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("ScreenshotCaptureEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RenderVolumeEntity {
    pub _glacier_base: super::entity::Entity,
}

pub trait RenderVolumeEntityTrait: super::entity::EntityTrait {
}

impl RenderVolumeEntityTrait for RenderVolumeEntity {
}

impl super::entity::EntityTrait for RenderVolumeEntity {
}

impl super::entity::EntityBusPeerTrait for RenderVolumeEntity {
}

pub static RENDERVOLUMEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RenderVolumeEntity",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RenderVolumeEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(RENDERVOLUMEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for RenderVolumeEntity {
    fn type_info(&self) -> &'static TypeInfo {
        RENDERVOLUMEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RENDERVOLUMEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RenderVolumeEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("RenderVolumeEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RadiosityModifierEntity {
    pub _glacier_base: super::entity::Entity,
}

pub trait RadiosityModifierEntityTrait: super::entity::EntityTrait {
}

impl RadiosityModifierEntityTrait for RadiosityModifierEntity {
}

impl super::entity::EntityTrait for RadiosityModifierEntity {
}

impl super::entity::EntityBusPeerTrait for RadiosityModifierEntity {
}

pub static RADIOSITYMODIFIERENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RadiosityModifierEntity",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RadiosityModifierEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(RADIOSITYMODIFIERENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for RadiosityModifierEntity {
    fn type_info(&self) -> &'static TypeInfo {
        RADIOSITYMODIFIERENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RADIOSITYMODIFIERENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RadiosityModifierEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("RadiosityModifierEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RadiosityMaterialOpacityTriggerEntity {
    pub _glacier_base: super::entity::Entity,
}

pub trait RadiosityMaterialOpacityTriggerEntityTrait: super::entity::EntityTrait {
}

impl RadiosityMaterialOpacityTriggerEntityTrait for RadiosityMaterialOpacityTriggerEntity {
}

impl super::entity::EntityTrait for RadiosityMaterialOpacityTriggerEntity {
}

impl super::entity::EntityBusPeerTrait for RadiosityMaterialOpacityTriggerEntity {
}

pub static RADIOSITYMATERIALOPACITYTRIGGERENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RadiosityMaterialOpacityTriggerEntity",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RadiosityMaterialOpacityTriggerEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(RADIOSITYMATERIALOPACITYTRIGGERENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for RadiosityMaterialOpacityTriggerEntity {
    fn type_info(&self) -> &'static TypeInfo {
        RADIOSITYMATERIALOPACITYTRIGGERENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RADIOSITYMATERIALOPACITYTRIGGERENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RadiosityMaterialOpacityTriggerEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("RadiosityMaterialOpacityTriggerEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RadiosityMaterialInstanceEntity {
    pub _glacier_base: super::entity::Entity,
}

pub trait RadiosityMaterialInstanceEntityTrait: super::entity::EntityTrait {
}

impl RadiosityMaterialInstanceEntityTrait for RadiosityMaterialInstanceEntity {
}

impl super::entity::EntityTrait for RadiosityMaterialInstanceEntity {
}

impl super::entity::EntityBusPeerTrait for RadiosityMaterialInstanceEntity {
}

pub static RADIOSITYMATERIALINSTANCEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RadiosityMaterialInstanceEntity",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RadiosityMaterialInstanceEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(RADIOSITYMATERIALINSTANCEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for RadiosityMaterialInstanceEntity {
    fn type_info(&self) -> &'static TypeInfo {
        RADIOSITYMATERIALINSTANCEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RADIOSITYMATERIALINSTANCEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RadiosityMaterialInstanceEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("RadiosityMaterialInstanceEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RadiosityMaterialEntity {
    pub _glacier_base: super::entity::Entity,
}

pub trait RadiosityMaterialEntityTrait: super::entity::EntityTrait {
}

impl RadiosityMaterialEntityTrait for RadiosityMaterialEntity {
}

impl super::entity::EntityTrait for RadiosityMaterialEntity {
}

impl super::entity::EntityBusPeerTrait for RadiosityMaterialEntity {
}

pub static RADIOSITYMATERIALENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RadiosityMaterialEntity",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RadiosityMaterialEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(RADIOSITYMATERIALENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for RadiosityMaterialEntity {
    fn type_info(&self) -> &'static TypeInfo {
        RADIOSITYMATERIALENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RADIOSITYMATERIALENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RadiosityMaterialEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("RadiosityMaterialEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlanarReflectionLocatorEntity {
    pub _glacier_base: super::entity::Entity,
}

pub trait PlanarReflectionLocatorEntityTrait: super::entity::EntityTrait {
}

impl PlanarReflectionLocatorEntityTrait for PlanarReflectionLocatorEntity {
}

impl super::entity::EntityTrait for PlanarReflectionLocatorEntity {
}

impl super::entity::EntityBusPeerTrait for PlanarReflectionLocatorEntity {
}

pub static PLANARREFLECTIONLOCATORENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlanarReflectionLocatorEntity",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlanarReflectionLocatorEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(PLANARREFLECTIONLOCATORENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for PlanarReflectionLocatorEntity {
    fn type_info(&self) -> &'static TypeInfo {
        PLANARREFLECTIONLOCATORENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PLANARREFLECTIONLOCATORENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlanarReflectionLocatorEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("PlanarReflectionLocatorEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct OccluderVolumeEntity {
    pub _glacier_base: super::entity::Entity,
}

pub trait OccluderVolumeEntityTrait: super::entity::EntityTrait {
}

impl OccluderVolumeEntityTrait for OccluderVolumeEntity {
}

impl super::entity::EntityTrait for OccluderVolumeEntity {
}

impl super::entity::EntityBusPeerTrait for OccluderVolumeEntity {
}

pub static OCCLUDERVOLUMEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OccluderVolumeEntity",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<OccluderVolumeEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(OCCLUDERVOLUMEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for OccluderVolumeEntity {
    fn type_info(&self) -> &'static TypeInfo {
        OCCLUDERVOLUMEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static OCCLUDERVOLUMEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OccluderVolumeEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("OccluderVolumeEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct OccluderPlaneEntity {
    pub _glacier_base: super::entity::Entity,
}

pub trait OccluderPlaneEntityTrait: super::entity::EntityTrait {
}

impl OccluderPlaneEntityTrait for OccluderPlaneEntity {
}

impl super::entity::EntityTrait for OccluderPlaneEntity {
}

impl super::entity::EntityBusPeerTrait for OccluderPlaneEntity {
}

pub static OCCLUDERPLANEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OccluderPlaneEntity",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<OccluderPlaneEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(OCCLUDERPLANEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for OccluderPlaneEntity {
    fn type_info(&self) -> &'static TypeInfo {
        OCCLUDERPLANEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static OCCLUDERPLANEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OccluderPlaneEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("OccluderPlaneEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct OccluderMeshEntity {
    pub _glacier_base: super::entity::Entity,
}

pub trait OccluderMeshEntityTrait: super::entity::EntityTrait {
}

impl OccluderMeshEntityTrait for OccluderMeshEntity {
}

impl super::entity::EntityTrait for OccluderMeshEntity {
}

impl super::entity::EntityBusPeerTrait for OccluderMeshEntity {
}

pub static OCCLUDERMESHENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OccluderMeshEntity",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<OccluderMeshEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(OCCLUDERMESHENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for OccluderMeshEntity {
    fn type_info(&self) -> &'static TypeInfo {
        OCCLUDERMESHENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static OCCLUDERMESHENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OccluderMeshEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("OccluderMeshEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MeshProxyEntity {
    pub _glacier_base: super::entity::SpatialEntity,
}

pub trait MeshProxyEntityTrait: super::entity::SpatialEntityTrait {
}

impl MeshProxyEntityTrait for MeshProxyEntity {
}

impl super::entity::SpatialEntityTrait for MeshProxyEntity {
}

impl super::entity::EntityTrait for MeshProxyEntity {
}

impl super::entity::EntityBusPeerTrait for MeshProxyEntity {
}

pub static MESHPROXYENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MeshProxyEntity",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MeshProxyEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(MESHPROXYENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for MeshProxyEntity {
    fn type_info(&self) -> &'static TypeInfo {
        MESHPROXYENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MESHPROXYENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MeshProxyEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("MeshProxyEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ParticipatingMediaMaterialEntity {
    pub _glacier_base: super::entity::Entity,
}

pub trait ParticipatingMediaMaterialEntityTrait: super::entity::EntityTrait {
}

impl ParticipatingMediaMaterialEntityTrait for ParticipatingMediaMaterialEntity {
}

impl super::entity::EntityTrait for ParticipatingMediaMaterialEntity {
}

impl super::entity::EntityBusPeerTrait for ParticipatingMediaMaterialEntity {
}

pub static PARTICIPATINGMEDIAMATERIALENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ParticipatingMediaMaterialEntity",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ParticipatingMediaMaterialEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(PARTICIPATINGMEDIAMATERIALENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ParticipatingMediaMaterialEntity {
    fn type_info(&self) -> &'static TypeInfo {
        PARTICIPATINGMEDIAMATERIALENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PARTICIPATINGMEDIAMATERIALENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ParticipatingMediaMaterialEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("ParticipatingMediaMaterialEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LocalFogVolumeEntity {
    pub _glacier_base: super::entity::Entity,
}

pub trait LocalFogVolumeEntityTrait: super::entity::EntityTrait {
}

impl LocalFogVolumeEntityTrait for LocalFogVolumeEntity {
}

impl super::entity::EntityTrait for LocalFogVolumeEntity {
}

impl super::entity::EntityBusPeerTrait for LocalFogVolumeEntity {
}

pub static LOCALFOGVOLUMEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalFogVolumeEntity",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LocalFogVolumeEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(LOCALFOGVOLUMEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for LocalFogVolumeEntity {
    fn type_info(&self) -> &'static TypeInfo {
        LOCALFOGVOLUMEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LOCALFOGVOLUMEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalFogVolumeEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("LocalFogVolumeEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LocalPlanarReflectionEntity {
    pub _glacier_base: super::entity::Entity,
}

pub trait LocalPlanarReflectionEntityTrait: super::entity::EntityTrait {
}

impl LocalPlanarReflectionEntityTrait for LocalPlanarReflectionEntity {
}

impl super::entity::EntityTrait for LocalPlanarReflectionEntity {
}

impl super::entity::EntityBusPeerTrait for LocalPlanarReflectionEntity {
}

pub static LOCALPLANARREFLECTIONENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalPlanarReflectionEntity",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LocalPlanarReflectionEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(LOCALPLANARREFLECTIONENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for LocalPlanarReflectionEntity {
    fn type_info(&self) -> &'static TypeInfo {
        LOCALPLANARREFLECTIONENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LOCALPLANARREFLECTIONENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalPlanarReflectionEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("LocalPlanarReflectionEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ReflectionVolumeSynchronizerEntity {
    pub _glacier_base: super::entity::Entity,
}

pub trait ReflectionVolumeSynchronizerEntityTrait: super::entity::EntityTrait {
}

impl ReflectionVolumeSynchronizerEntityTrait for ReflectionVolumeSynchronizerEntity {
}

impl super::entity::EntityTrait for ReflectionVolumeSynchronizerEntity {
}

impl super::entity::EntityBusPeerTrait for ReflectionVolumeSynchronizerEntity {
}

pub static REFLECTIONVOLUMESYNCHRONIZERENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReflectionVolumeSynchronizerEntity",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ReflectionVolumeSynchronizerEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(REFLECTIONVOLUMESYNCHRONIZERENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ReflectionVolumeSynchronizerEntity {
    fn type_info(&self) -> &'static TypeInfo {
        REFLECTIONVOLUMESYNCHRONIZERENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static REFLECTIONVOLUMESYNCHRONIZERENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReflectionVolumeSynchronizerEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("ReflectionVolumeSynchronizerEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DistantIBLEntity {
    pub _glacier_base: super::entity::Entity,
}

pub trait DistantIBLEntityTrait: super::entity::EntityTrait {
}

impl DistantIBLEntityTrait for DistantIBLEntity {
}

impl super::entity::EntityTrait for DistantIBLEntity {
}

impl super::entity::EntityBusPeerTrait for DistantIBLEntity {
}

pub static DISTANTIBLENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DistantIBLEntity",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DistantIBLEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(DISTANTIBLENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for DistantIBLEntity {
    fn type_info(&self) -> &'static TypeInfo {
        DISTANTIBLENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DISTANTIBLENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DistantIBLEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("DistantIBLEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LocalBoxIBLEntity {
    pub _glacier_base: super::entity::Entity,
}

pub trait LocalBoxIBLEntityTrait: super::entity::EntityTrait {
}

impl LocalBoxIBLEntityTrait for LocalBoxIBLEntity {
}

impl super::entity::EntityTrait for LocalBoxIBLEntity {
}

impl super::entity::EntityBusPeerTrait for LocalBoxIBLEntity {
}

pub static LOCALBOXIBLENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalBoxIBLEntity",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LocalBoxIBLEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(LOCALBOXIBLENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for LocalBoxIBLEntity {
    fn type_info(&self) -> &'static TypeInfo {
        LOCALBOXIBLENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LOCALBOXIBLENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalBoxIBLEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("LocalBoxIBLEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LocalSphereIBLEntity {
    pub _glacier_base: super::entity::Entity,
}

pub trait LocalSphereIBLEntityTrait: super::entity::EntityTrait {
}

impl LocalSphereIBLEntityTrait for LocalSphereIBLEntity {
}

impl super::entity::EntityTrait for LocalSphereIBLEntity {
}

impl super::entity::EntityBusPeerTrait for LocalSphereIBLEntity {
}

pub static LOCALSPHEREIBLENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalSphereIBLEntity",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LocalSphereIBLEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(LOCALSPHEREIBLENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for LocalSphereIBLEntity {
    fn type_info(&self) -> &'static TypeInfo {
        LOCALSPHEREIBLENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LOCALSPHEREIBLENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalSphereIBLEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("LocalSphereIBLEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PbrRectangularLightEntity {
    pub _glacier_base: LocalLightEntity,
}

pub trait PbrRectangularLightEntityTrait: LocalLightEntityTrait {
}

impl PbrRectangularLightEntityTrait for PbrRectangularLightEntity {
}

impl LocalLightEntityTrait for PbrRectangularLightEntity {
}

impl super::entity::EntityTrait for PbrRectangularLightEntity {
}

impl super::entity::EntityBusPeerTrait for PbrRectangularLightEntity {
}

pub static PBRRECTANGULARLIGHTENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PbrRectangularLightEntity",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(LOCALLIGHTENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PbrRectangularLightEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(PBRRECTANGULARLIGHTENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for PbrRectangularLightEntity {
    fn type_info(&self) -> &'static TypeInfo {
        PBRRECTANGULARLIGHTENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PBRRECTANGULARLIGHTENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PbrRectangularLightEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("PbrRectangularLightEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PbrTubeLightEntity {
    pub _glacier_base: LocalLightEntity,
}

pub trait PbrTubeLightEntityTrait: LocalLightEntityTrait {
}

impl PbrTubeLightEntityTrait for PbrTubeLightEntity {
}

impl LocalLightEntityTrait for PbrTubeLightEntity {
}

impl super::entity::EntityTrait for PbrTubeLightEntity {
}

impl super::entity::EntityBusPeerTrait for PbrTubeLightEntity {
}

pub static PBRTUBELIGHTENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PbrTubeLightEntity",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(LOCALLIGHTENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PbrTubeLightEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(PBRTUBELIGHTENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for PbrTubeLightEntity {
    fn type_info(&self) -> &'static TypeInfo {
        PBRTUBELIGHTENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PBRTUBELIGHTENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PbrTubeLightEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("PbrTubeLightEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PbrSpotLightEntity {
    pub _glacier_base: LocalLightEntity,
}

pub trait PbrSpotLightEntityTrait: LocalLightEntityTrait {
}

impl PbrSpotLightEntityTrait for PbrSpotLightEntity {
}

impl LocalLightEntityTrait for PbrSpotLightEntity {
}

impl super::entity::EntityTrait for PbrSpotLightEntity {
}

impl super::entity::EntityBusPeerTrait for PbrSpotLightEntity {
}

pub static PBRSPOTLIGHTENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PbrSpotLightEntity",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(LOCALLIGHTENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PbrSpotLightEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(PBRSPOTLIGHTENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for PbrSpotLightEntity {
    fn type_info(&self) -> &'static TypeInfo {
        PBRSPOTLIGHTENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PBRSPOTLIGHTENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PbrSpotLightEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("PbrSpotLightEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PbrSphereLightEntity {
    pub _glacier_base: LocalLightEntity,
}

pub trait PbrSphereLightEntityTrait: LocalLightEntityTrait {
}

impl PbrSphereLightEntityTrait for PbrSphereLightEntity {
}

impl LocalLightEntityTrait for PbrSphereLightEntity {
}

impl super::entity::EntityTrait for PbrSphereLightEntity {
}

impl super::entity::EntityBusPeerTrait for PbrSphereLightEntity {
}

pub static PBRSPHERELIGHTENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PbrSphereLightEntity",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(LOCALLIGHTENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PbrSphereLightEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(PBRSPHERELIGHTENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for PbrSphereLightEntity {
    fn type_info(&self) -> &'static TypeInfo {
        PBRSPHERELIGHTENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PBRSPHERELIGHTENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PbrSphereLightEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("PbrSphereLightEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct OldSpotLightEntity {
    pub _glacier_base: LocalLightEntity,
}

pub trait OldSpotLightEntityTrait: LocalLightEntityTrait {
}

impl OldSpotLightEntityTrait for OldSpotLightEntity {
}

impl LocalLightEntityTrait for OldSpotLightEntity {
}

impl super::entity::EntityTrait for OldSpotLightEntity {
}

impl super::entity::EntityBusPeerTrait for OldSpotLightEntity {
}

pub static OLDSPOTLIGHTENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OldSpotLightEntity",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(LOCALLIGHTENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<OldSpotLightEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(OLDSPOTLIGHTENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for OldSpotLightEntity {
    fn type_info(&self) -> &'static TypeInfo {
        OLDSPOTLIGHTENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static OLDSPOTLIGHTENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OldSpotLightEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("OldSpotLightEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct OldPointLightEntity {
    pub _glacier_base: LocalLightEntity,
}

pub trait OldPointLightEntityTrait: LocalLightEntityTrait {
}

impl OldPointLightEntityTrait for OldPointLightEntity {
}

impl LocalLightEntityTrait for OldPointLightEntity {
}

impl super::entity::EntityTrait for OldPointLightEntity {
}

impl super::entity::EntityBusPeerTrait for OldPointLightEntity {
}

pub static OLDPOINTLIGHTENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OldPointLightEntity",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(LOCALLIGHTENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<OldPointLightEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(OLDPOINTLIGHTENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for OldPointLightEntity {
    fn type_info(&self) -> &'static TypeInfo {
        OLDPOINTLIGHTENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static OLDPOINTLIGHTENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OldPointLightEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("OldPointLightEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LocalLightEntity {
    pub _glacier_base: super::entity::Entity,
}

pub trait LocalLightEntityTrait: super::entity::EntityTrait {
}

impl LocalLightEntityTrait for LocalLightEntity {
}

impl super::entity::EntityTrait for LocalLightEntity {
}

impl super::entity::EntityBusPeerTrait for LocalLightEntity {
}

pub static LOCALLIGHTENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalLightEntity",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LocalLightEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(LOCALLIGHTENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for LocalLightEntity {
    fn type_info(&self) -> &'static TypeInfo {
        LOCALLIGHTENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LOCALLIGHTENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalLightEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("LocalLightEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LensFlareEntity {
    pub _glacier_base: super::entity::Entity,
}

pub trait LensFlareEntityTrait: super::entity::EntityTrait {
}

impl LensFlareEntityTrait for LensFlareEntity {
}

impl super::entity::EntityTrait for LensFlareEntity {
}

impl super::entity::EntityBusPeerTrait for LensFlareEntity {
}

pub static LENSFLAREENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LensFlareEntity",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LensFlareEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(LENSFLAREENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for LensFlareEntity {
    fn type_info(&self) -> &'static TypeInfo {
        LENSFLAREENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LENSFLAREENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LensFlareEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("LensFlareEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GroundHeightEntity {
    pub _glacier_base: super::entity::Entity,
}

pub trait GroundHeightEntityTrait: super::entity::EntityTrait {
}

impl GroundHeightEntityTrait for GroundHeightEntity {
}

impl super::entity::EntityTrait for GroundHeightEntity {
}

impl super::entity::EntityBusPeerTrait for GroundHeightEntity {
}

pub static GROUNDHEIGHTENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GroundHeightEntity",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GroundHeightEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(GROUNDHEIGHTENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for GroundHeightEntity {
    fn type_info(&self) -> &'static TypeInfo {
        GROUNDHEIGHTENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static GROUNDHEIGHTENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GroundHeightEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("GroundHeightEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FogExclusionVolumeEntity {
    pub _glacier_base: super::entity::Entity,
}

pub trait FogExclusionVolumeEntityTrait: super::entity::EntityTrait {
}

impl FogExclusionVolumeEntityTrait for FogExclusionVolumeEntity {
}

impl super::entity::EntityTrait for FogExclusionVolumeEntity {
}

impl super::entity::EntityBusPeerTrait for FogExclusionVolumeEntity {
}

pub static FOGEXCLUSIONVOLUMEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FogExclusionVolumeEntity",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FogExclusionVolumeEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(FOGEXCLUSIONVOLUMEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for FogExclusionVolumeEntity {
    fn type_info(&self) -> &'static TypeInfo {
        FOGEXCLUSIONVOLUMEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FOGEXCLUSIONVOLUMEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FogExclusionVolumeEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("FogExclusionVolumeEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DynamicEnlightenEntity {
    pub _glacier_base: super::entity::Entity,
}

pub trait DynamicEnlightenEntityTrait: super::entity::EntityTrait {
}

impl DynamicEnlightenEntityTrait for DynamicEnlightenEntity {
}

impl super::entity::EntityTrait for DynamicEnlightenEntity {
}

impl super::entity::EntityBusPeerTrait for DynamicEnlightenEntity {
}

pub static DYNAMICENLIGHTENENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicEnlightenEntity",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DynamicEnlightenEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(DYNAMICENLIGHTENENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for DynamicEnlightenEntity {
    fn type_info(&self) -> &'static TypeInfo {
        DYNAMICENLIGHTENENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DYNAMICENLIGHTENENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicEnlightenEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("DynamicEnlightenEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DistantShadowCacheVolumeEntity {
    pub _glacier_base: super::entity::Entity,
}

pub trait DistantShadowCacheVolumeEntityTrait: super::entity::EntityTrait {
}

impl DistantShadowCacheVolumeEntityTrait for DistantShadowCacheVolumeEntity {
}

impl super::entity::EntityTrait for DistantShadowCacheVolumeEntity {
}

impl super::entity::EntityBusPeerTrait for DistantShadowCacheVolumeEntity {
}

pub static DISTANTSHADOWCACHEVOLUMEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DistantShadowCacheVolumeEntity",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DistantShadowCacheVolumeEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(DISTANTSHADOWCACHEVOLUMEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for DistantShadowCacheVolumeEntity {
    fn type_info(&self) -> &'static TypeInfo {
        DISTANTSHADOWCACHEVOLUMEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DISTANTSHADOWCACHEVOLUMEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DistantShadowCacheVolumeEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("DistantShadowCacheVolumeEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BakeableTextureEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
}

pub trait BakeableTextureEntityDataTrait: super::entity::SpatialEntityDataTrait {
}

impl BakeableTextureEntityDataTrait for BakeableTextureEntityData {
}

impl super::entity::SpatialEntityDataTrait for BakeableTextureEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for BakeableTextureEntityData {
}

impl super::entity::GameObjectDataTrait for BakeableTextureEntityData {
}

impl super::core::DataBusPeerTrait for BakeableTextureEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for BakeableTextureEntityData {
}

impl super::core::DataContainerTrait for BakeableTextureEntityData {
}

pub static BAKEABLETEXTUREENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BakeableTextureEntityData",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BakeableTextureEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(BAKEABLETEXTUREENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for BakeableTextureEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        BAKEABLETEXTUREENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BAKEABLETEXTUREENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BakeableTextureEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("BakeableTextureEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WindForceSphereEntity {
    pub _glacier_base: WindForceEntity,
}

pub trait WindForceSphereEntityTrait: WindForceEntityTrait {
}

impl WindForceSphereEntityTrait for WindForceSphereEntity {
}

impl WindForceEntityTrait for WindForceSphereEntity {
}

impl super::entity::SpatialEntityTrait for WindForceSphereEntity {
}

impl super::entity::EntityTrait for WindForceSphereEntity {
}

impl super::entity::EntityBusPeerTrait for WindForceSphereEntity {
}

pub static WINDFORCESPHEREENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WindForceSphereEntity",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(WINDFORCEENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WindForceSphereEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(WINDFORCESPHEREENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for WindForceSphereEntity {
    fn type_info(&self) -> &'static TypeInfo {
        WINDFORCESPHEREENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WINDFORCESPHEREENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WindForceSphereEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("WindForceSphereEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WindForceSphereComponent {
    pub _glacier_base: WindForceComponent,
}

pub trait WindForceSphereComponentTrait: WindForceComponentTrait {
}

impl WindForceSphereComponentTrait for WindForceSphereComponent {
}

impl WindForceComponentTrait for WindForceSphereComponent {
}

impl super::entity::ComponentTrait for WindForceSphereComponent {
}

impl super::entity::EntityBusPeerTrait for WindForceSphereComponent {
}

pub static WINDFORCESPHERECOMPONENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WindForceSphereComponent",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(WINDFORCECOMPONENT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WindForceSphereComponent as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(WINDFORCESPHERECOMPONENT_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for WindForceSphereComponent {
    fn type_info(&self) -> &'static TypeInfo {
        WINDFORCESPHERECOMPONENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WINDFORCESPHERECOMPONENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WindForceSphereComponent-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("WindForceSphereComponent"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WindForceSamplerEntity {
    pub _glacier_base: super::entity::SpatialEntity,
}

pub trait WindForceSamplerEntityTrait: super::entity::SpatialEntityTrait {
}

impl WindForceSamplerEntityTrait for WindForceSamplerEntity {
}

impl super::entity::SpatialEntityTrait for WindForceSamplerEntity {
}

impl super::entity::EntityTrait for WindForceSamplerEntity {
}

impl super::entity::EntityBusPeerTrait for WindForceSamplerEntity {
}

pub static WINDFORCESAMPLERENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WindForceSamplerEntity",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WindForceSamplerEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(WINDFORCESAMPLERENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for WindForceSamplerEntity {
    fn type_info(&self) -> &'static TypeInfo {
        WINDFORCESAMPLERENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WINDFORCESAMPLERENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WindForceSamplerEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("WindForceSamplerEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WindForceEntity {
    pub _glacier_base: super::entity::SpatialEntity,
}

pub trait WindForceEntityTrait: super::entity::SpatialEntityTrait {
}

impl WindForceEntityTrait for WindForceEntity {
}

impl super::entity::SpatialEntityTrait for WindForceEntity {
}

impl super::entity::EntityTrait for WindForceEntity {
}

impl super::entity::EntityBusPeerTrait for WindForceEntity {
}

pub static WINDFORCEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WindForceEntity",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WindForceEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(WINDFORCEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for WindForceEntity {
    fn type_info(&self) -> &'static TypeInfo {
        WINDFORCEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WINDFORCEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WindForceEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("WindForceEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WindForceConeEntity {
    pub _glacier_base: WindForceEntity,
}

pub trait WindForceConeEntityTrait: WindForceEntityTrait {
}

impl WindForceConeEntityTrait for WindForceConeEntity {
}

impl WindForceEntityTrait for WindForceConeEntity {
}

impl super::entity::SpatialEntityTrait for WindForceConeEntity {
}

impl super::entity::EntityTrait for WindForceConeEntity {
}

impl super::entity::EntityBusPeerTrait for WindForceConeEntity {
}

pub static WINDFORCECONEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WindForceConeEntity",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(WINDFORCEENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WindForceConeEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(WINDFORCECONEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for WindForceConeEntity {
    fn type_info(&self) -> &'static TypeInfo {
        WINDFORCECONEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WINDFORCECONEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WindForceConeEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("WindForceConeEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WindForceConeComponent {
    pub _glacier_base: WindForceComponent,
}

pub trait WindForceConeComponentTrait: WindForceComponentTrait {
}

impl WindForceConeComponentTrait for WindForceConeComponent {
}

impl WindForceComponentTrait for WindForceConeComponent {
}

impl super::entity::ComponentTrait for WindForceConeComponent {
}

impl super::entity::EntityBusPeerTrait for WindForceConeComponent {
}

pub static WINDFORCECONECOMPONENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WindForceConeComponent",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(WINDFORCECOMPONENT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WindForceConeComponent as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(WINDFORCECONECOMPONENT_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for WindForceConeComponent {
    fn type_info(&self) -> &'static TypeInfo {
        WINDFORCECONECOMPONENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WINDFORCECONECOMPONENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WindForceConeComponent-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("WindForceConeComponent"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WindForceComponent {
    pub _glacier_base: super::entity::Component,
}

pub trait WindForceComponentTrait: super::entity::ComponentTrait {
}

impl WindForceComponentTrait for WindForceComponent {
}

impl super::entity::ComponentTrait for WindForceComponent {
}

impl super::entity::EntityBusPeerTrait for WindForceComponent {
}

pub static WINDFORCECOMPONENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WindForceComponent",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::COMPONENT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WindForceComponent as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(WINDFORCECOMPONENT_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for WindForceComponent {
    fn type_info(&self) -> &'static TypeInfo {
        WINDFORCECOMPONENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WINDFORCECOMPONENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WindForceComponent-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("WindForceComponent"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WindForceBaked3DAs2x2DTexEntity {
    pub _glacier_base: WindForceEntity,
}

pub trait WindForceBaked3DAs2x2DTexEntityTrait: WindForceEntityTrait {
}

impl WindForceBaked3DAs2x2DTexEntityTrait for WindForceBaked3DAs2x2DTexEntity {
}

impl WindForceEntityTrait for WindForceBaked3DAs2x2DTexEntity {
}

impl super::entity::SpatialEntityTrait for WindForceBaked3DAs2x2DTexEntity {
}

impl super::entity::EntityTrait for WindForceBaked3DAs2x2DTexEntity {
}

impl super::entity::EntityBusPeerTrait for WindForceBaked3DAs2x2DTexEntity {
}

pub static WINDFORCEBAKED3DAS2X2DTEXENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WindForceBaked3DAs2x2DTexEntity",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(WINDFORCEENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WindForceBaked3DAs2x2DTexEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(WINDFORCEBAKED3DAS2X2DTEXENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for WindForceBaked3DAs2x2DTexEntity {
    fn type_info(&self) -> &'static TypeInfo {
        WINDFORCEBAKED3DAS2X2DTEXENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WINDFORCEBAKED3DAS2X2DTEXENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WindForceBaked3DAs2x2DTexEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("WindForceBaked3DAs2x2DTexEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WindForceBaked3DAs2x2DTexComponent {
    pub _glacier_base: WindForceComponent,
}

pub trait WindForceBaked3DAs2x2DTexComponentTrait: WindForceComponentTrait {
}

impl WindForceBaked3DAs2x2DTexComponentTrait for WindForceBaked3DAs2x2DTexComponent {
}

impl WindForceComponentTrait for WindForceBaked3DAs2x2DTexComponent {
}

impl super::entity::ComponentTrait for WindForceBaked3DAs2x2DTexComponent {
}

impl super::entity::EntityBusPeerTrait for WindForceBaked3DAs2x2DTexComponent {
}

pub static WINDFORCEBAKED3DAS2X2DTEXCOMPONENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WindForceBaked3DAs2x2DTexComponent",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(WINDFORCECOMPONENT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WindForceBaked3DAs2x2DTexComponent as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(WINDFORCEBAKED3DAS2X2DTEXCOMPONENT_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for WindForceBaked3DAs2x2DTexComponent {
    fn type_info(&self) -> &'static TypeInfo {
        WINDFORCEBAKED3DAS2X2DTEXCOMPONENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WINDFORCEBAKED3DAS2X2DTEXCOMPONENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WindForceBaked3DAs2x2DTexComponent-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("WindForceBaked3DAs2x2DTexComponent"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VisualEnvironmentEntity {
    pub _glacier_base: super::entity::ComponentEntity,
}

pub trait VisualEnvironmentEntityTrait: super::entity::ComponentEntityTrait {
}

impl VisualEnvironmentEntityTrait for VisualEnvironmentEntity {
}

impl super::entity::ComponentEntityTrait for VisualEnvironmentEntity {
}

impl super::entity::SpatialEntityTrait for VisualEnvironmentEntity {
}

impl super::entity::EntityTrait for VisualEnvironmentEntity {
}

impl super::entity::EntityBusPeerTrait for VisualEnvironmentEntity {
}

pub static VISUALENVIRONMENTENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VisualEnvironmentEntity",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::COMPONENTENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VisualEnvironmentEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(VISUALENVIRONMENTENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for VisualEnvironmentEntity {
    fn type_info(&self) -> &'static TypeInfo {
        VISUALENVIRONMENTENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VISUALENVIRONMENTENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VisualEnvironmentEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("VisualEnvironmentEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RaytraceReflectionComponent {
    pub _glacier_base: super::entity::Component,
}

pub trait RaytraceReflectionComponentTrait: super::entity::ComponentTrait {
}

impl RaytraceReflectionComponentTrait for RaytraceReflectionComponent {
}

impl super::entity::ComponentTrait for RaytraceReflectionComponent {
}

impl super::entity::EntityBusPeerTrait for RaytraceReflectionComponent {
}

pub static RAYTRACEREFLECTIONCOMPONENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RaytraceReflectionComponent",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::COMPONENT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RaytraceReflectionComponent as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(RAYTRACEREFLECTIONCOMPONENT_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for RaytraceReflectionComponent {
    fn type_info(&self) -> &'static TypeInfo {
        RAYTRACEREFLECTIONCOMPONENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RAYTRACEREFLECTIONCOMPONENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RaytraceReflectionComponent-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("RaytraceReflectionComponent"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SonarParamsComponent {
    pub _glacier_base: super::entity::Component,
}

pub trait SonarParamsComponentTrait: super::entity::ComponentTrait {
}

impl SonarParamsComponentTrait for SonarParamsComponent {
}

impl super::entity::ComponentTrait for SonarParamsComponent {
}

impl super::entity::EntityBusPeerTrait for SonarParamsComponent {
}

pub static SONARPARAMSCOMPONENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SonarParamsComponent",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::COMPONENT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SonarParamsComponent as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SONARPARAMSCOMPONENT_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SonarParamsComponent {
    fn type_info(&self) -> &'static TypeInfo {
        SONARPARAMSCOMPONENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SONARPARAMSCOMPONENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SonarParamsComponent-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("SonarParamsComponent"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct HologramParamsComponent {
    pub _glacier_base: super::entity::Component,
}

pub trait HologramParamsComponentTrait: super::entity::ComponentTrait {
}

impl HologramParamsComponentTrait for HologramParamsComponent {
}

impl super::entity::ComponentTrait for HologramParamsComponent {
}

impl super::entity::EntityBusPeerTrait for HologramParamsComponent {
}

pub static HOLOGRAMPARAMSCOMPONENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HologramParamsComponent",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::COMPONENT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<HologramParamsComponent as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(HOLOGRAMPARAMSCOMPONENT_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for HologramParamsComponent {
    fn type_info(&self) -> &'static TypeInfo {
        HOLOGRAMPARAMSCOMPONENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static HOLOGRAMPARAMSCOMPONENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HologramParamsComponent-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("HologramParamsComponent"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ThreatAlertHighlightParamsComponent {
    pub _glacier_base: super::entity::Component,
}

pub trait ThreatAlertHighlightParamsComponentTrait: super::entity::ComponentTrait {
}

impl ThreatAlertHighlightParamsComponentTrait for ThreatAlertHighlightParamsComponent {
}

impl super::entity::ComponentTrait for ThreatAlertHighlightParamsComponent {
}

impl super::entity::EntityBusPeerTrait for ThreatAlertHighlightParamsComponent {
}

pub static THREATALERTHIGHLIGHTPARAMSCOMPONENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ThreatAlertHighlightParamsComponent",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::COMPONENT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ThreatAlertHighlightParamsComponent as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(THREATALERTHIGHLIGHTPARAMSCOMPONENT_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ThreatAlertHighlightParamsComponent {
    fn type_info(&self) -> &'static TypeInfo {
        THREATALERTHIGHLIGHTPARAMSCOMPONENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static THREATALERTHIGHLIGHTPARAMSCOMPONENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ThreatAlertHighlightParamsComponent-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("ThreatAlertHighlightParamsComponent"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ObjectHighlightParamsComponent {
    pub _glacier_base: super::entity::Component,
}

pub trait ObjectHighlightParamsComponentTrait: super::entity::ComponentTrait {
}

impl ObjectHighlightParamsComponentTrait for ObjectHighlightParamsComponent {
}

impl super::entity::ComponentTrait for ObjectHighlightParamsComponent {
}

impl super::entity::EntityBusPeerTrait for ObjectHighlightParamsComponent {
}

pub static OBJECTHIGHLIGHTPARAMSCOMPONENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectHighlightParamsComponent",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::COMPONENT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ObjectHighlightParamsComponent as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(OBJECTHIGHLIGHTPARAMSCOMPONENT_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ObjectHighlightParamsComponent {
    fn type_info(&self) -> &'static TypeInfo {
        OBJECTHIGHLIGHTPARAMSCOMPONENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static OBJECTHIGHLIGHTPARAMSCOMPONENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectHighlightParamsComponent-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("ObjectHighlightParamsComponent"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AntiAliasComponent {
    pub _glacier_base: super::entity::Component,
}

pub trait AntiAliasComponentTrait: super::entity::ComponentTrait {
}

impl AntiAliasComponentTrait for AntiAliasComponent {
}

impl super::entity::ComponentTrait for AntiAliasComponent {
}

impl super::entity::EntityBusPeerTrait for AntiAliasComponent {
}

pub static ANTIALIASCOMPONENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntiAliasComponent",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::COMPONENT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AntiAliasComponent as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(ANTIALIASCOMPONENT_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for AntiAliasComponent {
    fn type_info(&self) -> &'static TypeInfo {
        ANTIALIASCOMPONENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANTIALIASCOMPONENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntiAliasComponent-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("AntiAliasComponent"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ScreenSpaceRaytraceComponent {
    pub _glacier_base: super::entity::Component,
}

pub trait ScreenSpaceRaytraceComponentTrait: super::entity::ComponentTrait {
}

impl ScreenSpaceRaytraceComponentTrait for ScreenSpaceRaytraceComponent {
}

impl super::entity::ComponentTrait for ScreenSpaceRaytraceComponent {
}

impl super::entity::EntityBusPeerTrait for ScreenSpaceRaytraceComponent {
}

pub static SCREENSPACERAYTRACECOMPONENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScreenSpaceRaytraceComponent",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::COMPONENT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ScreenSpaceRaytraceComponent as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SCREENSPACERAYTRACECOMPONENT_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ScreenSpaceRaytraceComponent {
    fn type_info(&self) -> &'static TypeInfo {
        SCREENSPACERAYTRACECOMPONENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SCREENSPACERAYTRACECOMPONENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScreenSpaceRaytraceComponent-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("ScreenSpaceRaytraceComponent"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DebugComponent {
    pub _glacier_base: super::entity::Component,
}

pub trait DebugComponentTrait: super::entity::ComponentTrait {
}

impl DebugComponentTrait for DebugComponent {
}

impl super::entity::ComponentTrait for DebugComponent {
}

impl super::entity::EntityBusPeerTrait for DebugComponent {
}

pub static DEBUGCOMPONENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DebugComponent",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::COMPONENT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DebugComponent as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(DEBUGCOMPONENT_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for DebugComponent {
    fn type_info(&self) -> &'static TypeInfo {
        DEBUGCOMPONENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DEBUGCOMPONENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DebugComponent-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("DebugComponent"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LensReflectionComponent {
    pub _glacier_base: super::entity::Component,
}

pub trait LensReflectionComponentTrait: super::entity::ComponentTrait {
}

impl LensReflectionComponentTrait for LensReflectionComponent {
}

impl super::entity::ComponentTrait for LensReflectionComponent {
}

impl super::entity::EntityBusPeerTrait for LensReflectionComponent {
}

pub static LENSREFLECTIONCOMPONENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LensReflectionComponent",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::COMPONENT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LensReflectionComponent as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(LENSREFLECTIONCOMPONENT_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for LensReflectionComponent {
    fn type_info(&self) -> &'static TypeInfo {
        LENSREFLECTIONCOMPONENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LENSREFLECTIONCOMPONENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LensReflectionComponent-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("LensReflectionComponent"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SkyCelestialRotationComponent {
    pub _glacier_base: super::entity::Component,
}

pub trait SkyCelestialRotationComponentTrait: super::entity::ComponentTrait {
}

impl SkyCelestialRotationComponentTrait for SkyCelestialRotationComponent {
}

impl super::entity::ComponentTrait for SkyCelestialRotationComponent {
}

impl super::entity::EntityBusPeerTrait for SkyCelestialRotationComponent {
}

pub static SKYCELESTIALROTATIONCOMPONENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SkyCelestialRotationComponent",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::COMPONENT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SkyCelestialRotationComponent as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SKYCELESTIALROTATIONCOMPONENT_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SkyCelestialRotationComponent {
    fn type_info(&self) -> &'static TypeInfo {
        SKYCELESTIALROTATIONCOMPONENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SKYCELESTIALROTATIONCOMPONENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SkyCelestialRotationComponent-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("SkyCelestialRotationComponent"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SkyCelestialMultiComponent {
    pub _glacier_base: super::entity::Component,
}

pub trait SkyCelestialMultiComponentTrait: super::entity::ComponentTrait {
}

impl SkyCelestialMultiComponentTrait for SkyCelestialMultiComponent {
}

impl super::entity::ComponentTrait for SkyCelestialMultiComponent {
}

impl super::entity::EntityBusPeerTrait for SkyCelestialMultiComponent {
}

pub static SKYCELESTIALMULTICOMPONENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SkyCelestialMultiComponent",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::COMPONENT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SkyCelestialMultiComponent as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SKYCELESTIALMULTICOMPONENT_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SkyCelestialMultiComponent {
    fn type_info(&self) -> &'static TypeInfo {
        SKYCELESTIALMULTICOMPONENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SKYCELESTIALMULTICOMPONENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SkyCelestialMultiComponent-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("SkyCelestialMultiComponent"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SkyCelestialSingleComponent {
    pub _glacier_base: super::entity::Component,
}

pub trait SkyCelestialSingleComponentTrait: super::entity::ComponentTrait {
}

impl SkyCelestialSingleComponentTrait for SkyCelestialSingleComponent {
}

impl super::entity::ComponentTrait for SkyCelestialSingleComponent {
}

impl super::entity::EntityBusPeerTrait for SkyCelestialSingleComponent {
}

pub static SKYCELESTIALSINGLECOMPONENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SkyCelestialSingleComponent",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::COMPONENT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SkyCelestialSingleComponent as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SKYCELESTIALSINGLECOMPONENT_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SkyCelestialSingleComponent {
    fn type_info(&self) -> &'static TypeInfo {
        SKYCELESTIALSINGLECOMPONENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SKYCELESTIALSINGLECOMPONENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SkyCelestialSingleComponent-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("SkyCelestialSingleComponent"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EmitterParamGlobalComponent {
    pub _glacier_base: super::entity::Component,
}

pub trait EmitterParamGlobalComponentTrait: super::entity::ComponentTrait {
}

impl EmitterParamGlobalComponentTrait for EmitterParamGlobalComponent {
}

impl super::entity::ComponentTrait for EmitterParamGlobalComponent {
}

impl super::entity::EntityBusPeerTrait for EmitterParamGlobalComponent {
}

pub static EMITTERPARAMGLOBALCOMPONENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EmitterParamGlobalComponent",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::COMPONENT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EmitterParamGlobalComponent as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(EMITTERPARAMGLOBALCOMPONENT_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for EmitterParamGlobalComponent {
    fn type_info(&self) -> &'static TypeInfo {
        EMITTERPARAMGLOBALCOMPONENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EMITTERPARAMGLOBALCOMPONENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EmitterParamGlobalComponent-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("EmitterParamGlobalComponent"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EmitterParamComponent {
    pub _glacier_base: super::entity::Component,
}

pub trait EmitterParamComponentTrait: super::entity::ComponentTrait {
}

impl EmitterParamComponentTrait for EmitterParamComponent {
}

impl super::entity::ComponentTrait for EmitterParamComponent {
}

impl super::entity::EntityBusPeerTrait for EmitterParamComponent {
}

pub static EMITTERPARAMCOMPONENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EmitterParamComponent",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::COMPONENT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EmitterParamComponent as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(EMITTERPARAMCOMPONENT_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for EmitterParamComponent {
    fn type_info(&self) -> &'static TypeInfo {
        EMITTERPARAMCOMPONENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EMITTERPARAMCOMPONENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EmitterParamComponent-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("EmitterParamComponent"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ShaderParamsComponent {
    pub _glacier_base: super::entity::Component,
}

pub trait ShaderParamsComponentTrait: super::entity::ComponentTrait {
}

impl ShaderParamsComponentTrait for ShaderParamsComponent {
}

impl super::entity::ComponentTrait for ShaderParamsComponent {
}

impl super::entity::EntityBusPeerTrait for ShaderParamsComponent {
}

pub static SHADERPARAMSCOMPONENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ShaderParamsComponent",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::COMPONENT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ShaderParamsComponent as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SHADERPARAMSCOMPONENT_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ShaderParamsComponent {
    fn type_info(&self) -> &'static TypeInfo {
        SHADERPARAMSCOMPONENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SHADERPARAMSCOMPONENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ShaderParamsComponent-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("ShaderParamsComponent"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MotionBlurComponent {
    pub _glacier_base: super::entity::Component,
}

pub trait MotionBlurComponentTrait: super::entity::ComponentTrait {
}

impl MotionBlurComponentTrait for MotionBlurComponent {
}

impl super::entity::ComponentTrait for MotionBlurComponent {
}

impl super::entity::EntityBusPeerTrait for MotionBlurComponent {
}

pub static MOTIONBLURCOMPONENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MotionBlurComponent",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::COMPONENT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MotionBlurComponent as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(MOTIONBLURCOMPONENT_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for MotionBlurComponent {
    fn type_info(&self) -> &'static TypeInfo {
        MOTIONBLURCOMPONENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MOTIONBLURCOMPONENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MotionBlurComponent-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("MotionBlurComponent"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SubSurfaceScatteringComponent {
    pub _glacier_base: super::entity::Component,
}

pub trait SubSurfaceScatteringComponentTrait: super::entity::ComponentTrait {
}

impl SubSurfaceScatteringComponentTrait for SubSurfaceScatteringComponent {
}

impl super::entity::ComponentTrait for SubSurfaceScatteringComponent {
}

impl super::entity::EntityBusPeerTrait for SubSurfaceScatteringComponent {
}

pub static SUBSURFACESCATTERINGCOMPONENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubSurfaceScatteringComponent",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::COMPONENT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SubSurfaceScatteringComponent as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SUBSURFACESCATTERINGCOMPONENT_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SubSurfaceScatteringComponent {
    fn type_info(&self) -> &'static TypeInfo {
        SUBSURFACESCATTERINGCOMPONENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SUBSURFACESCATTERINGCOMPONENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubSurfaceScatteringComponent-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("SubSurfaceScatteringComponent"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterLightingComponent {
    pub _glacier_base: super::entity::Component,
}

pub trait CharacterLightingComponentTrait: super::entity::ComponentTrait {
}

impl CharacterLightingComponentTrait for CharacterLightingComponent {
}

impl super::entity::ComponentTrait for CharacterLightingComponent {
}

impl super::entity::EntityBusPeerTrait for CharacterLightingComponent {
}

pub static CHARACTERLIGHTINGCOMPONENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterLightingComponent",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::COMPONENT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterLightingComponent as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(CHARACTERLIGHTINGCOMPONENT_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for CharacterLightingComponent {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERLIGHTINGCOMPONENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERLIGHTINGCOMPONENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterLightingComponent-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("CharacterLightingComponent"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DynamicEnvmapComponent {
    pub _glacier_base: super::entity::Component,
}

pub trait DynamicEnvmapComponentTrait: super::entity::ComponentTrait {
}

impl DynamicEnvmapComponentTrait for DynamicEnvmapComponent {
}

impl super::entity::ComponentTrait for DynamicEnvmapComponent {
}

impl super::entity::EntityBusPeerTrait for DynamicEnvmapComponent {
}

pub static DYNAMICENVMAPCOMPONENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicEnvmapComponent",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::COMPONENT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DynamicEnvmapComponent as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(DYNAMICENVMAPCOMPONENT_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for DynamicEnvmapComponent {
    fn type_info(&self) -> &'static TypeInfo {
        DYNAMICENVMAPCOMPONENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DYNAMICENVMAPCOMPONENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicEnvmapComponent-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("DynamicEnvmapComponent"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlanarReflectionComponent {
    pub _glacier_base: super::entity::Component,
}

pub trait PlanarReflectionComponentTrait: super::entity::ComponentTrait {
}

impl PlanarReflectionComponentTrait for PlanarReflectionComponent {
}

impl super::entity::ComponentTrait for PlanarReflectionComponent {
}

impl super::entity::EntityBusPeerTrait for PlanarReflectionComponent {
}

pub static PLANARREFLECTIONCOMPONENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlanarReflectionComponent",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::COMPONENT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlanarReflectionComponent as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(PLANARREFLECTIONCOMPONENT_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for PlanarReflectionComponent {
    fn type_info(&self) -> &'static TypeInfo {
        PLANARREFLECTIONCOMPONENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PLANARREFLECTIONCOMPONENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlanarReflectionComponent-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("PlanarReflectionComponent"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DamageEffectComponent {
    pub _glacier_base: super::entity::Component,
}

pub trait DamageEffectComponentTrait: super::entity::ComponentTrait {
}

impl DamageEffectComponentTrait for DamageEffectComponent {
}

impl super::entity::ComponentTrait for DamageEffectComponent {
}

impl super::entity::EntityBusPeerTrait for DamageEffectComponent {
}

pub static DAMAGEEFFECTCOMPONENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DamageEffectComponent",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::COMPONENT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DamageEffectComponent as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(DAMAGEEFFECTCOMPONENT_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for DamageEffectComponent {
    fn type_info(&self) -> &'static TypeInfo {
        DAMAGEEFFECTCOMPONENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DAMAGEEFFECTCOMPONENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DamageEffectComponent-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("DamageEffectComponent"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ScreenEffectComponent {
    pub _glacier_base: super::entity::Component,
}

pub trait ScreenEffectComponentTrait: super::entity::ComponentTrait {
}

impl ScreenEffectComponentTrait for ScreenEffectComponent {
}

impl super::entity::ComponentTrait for ScreenEffectComponent {
}

impl super::entity::EntityBusPeerTrait for ScreenEffectComponent {
}

pub static SCREENEFFECTCOMPONENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScreenEffectComponent",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::COMPONENT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ScreenEffectComponent as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SCREENEFFECTCOMPONENT_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ScreenEffectComponent {
    fn type_info(&self) -> &'static TypeInfo {
        SCREENEFFECTCOMPONENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SCREENEFFECTCOMPONENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScreenEffectComponent-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("ScreenEffectComponent"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ShadowsComponent {
    pub _glacier_base: super::entity::Component,
}

pub trait ShadowsComponentTrait: super::entity::ComponentTrait {
}

impl ShadowsComponentTrait for ShadowsComponent {
}

impl super::entity::ComponentTrait for ShadowsComponent {
}

impl super::entity::EntityBusPeerTrait for ShadowsComponent {
}

pub static SHADOWSCOMPONENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ShadowsComponent",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::COMPONENT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ShadowsComponent as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SHADOWSCOMPONENT_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ShadowsComponent {
    fn type_info(&self) -> &'static TypeInfo {
        SHADOWSCOMPONENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SHADOWSCOMPONENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ShadowsComponent-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("ShadowsComponent"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MeshSettingsComponent {
    pub _glacier_base: super::entity::Component,
}

pub trait MeshSettingsComponentTrait: super::entity::ComponentTrait {
}

impl MeshSettingsComponentTrait for MeshSettingsComponent {
}

impl super::entity::ComponentTrait for MeshSettingsComponent {
}

impl super::entity::EntityBusPeerTrait for MeshSettingsComponent {
}

pub static MESHSETTINGSCOMPONENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MeshSettingsComponent",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::COMPONENT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MeshSettingsComponent as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(MESHSETTINGSCOMPONENT_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for MeshSettingsComponent {
    fn type_info(&self) -> &'static TypeInfo {
        MESHSETTINGSCOMPONENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MESHSETTINGSCOMPONENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MeshSettingsComponent-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("MeshSettingsComponent"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CameraParamsComponent {
    pub _glacier_base: super::entity::Component,
}

pub trait CameraParamsComponentTrait: super::entity::ComponentTrait {
}

impl CameraParamsComponentTrait for CameraParamsComponent {
}

impl super::entity::ComponentTrait for CameraParamsComponent {
}

impl super::entity::EntityBusPeerTrait for CameraParamsComponent {
}

pub static CAMERAPARAMSCOMPONENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraParamsComponent",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::COMPONENT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraParamsComponent as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(CAMERAPARAMSCOMPONENT_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for CameraParamsComponent {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERAPARAMSCOMPONENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CAMERAPARAMSCOMPONENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraParamsComponent-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("CameraParamsComponent"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LensScopeComponent {
    pub _glacier_base: super::entity::Component,
}

pub trait LensScopeComponentTrait: super::entity::ComponentTrait {
}

impl LensScopeComponentTrait for LensScopeComponent {
}

impl super::entity::ComponentTrait for LensScopeComponent {
}

impl super::entity::EntityBusPeerTrait for LensScopeComponent {
}

pub static LENSSCOPECOMPONENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LensScopeComponent",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::COMPONENT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LensScopeComponent as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(LENSSCOPECOMPONENT_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for LensScopeComponent {
    fn type_info(&self) -> &'static TypeInfo {
        LENSSCOPECOMPONENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LENSSCOPECOMPONENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LensScopeComponent-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("LensScopeComponent"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FilmGrainComponent {
    pub _glacier_base: super::entity::Component,
}

pub trait FilmGrainComponentTrait: super::entity::ComponentTrait {
}

impl FilmGrainComponentTrait for FilmGrainComponent {
}

impl super::entity::ComponentTrait for FilmGrainComponent {
}

impl super::entity::EntityBusPeerTrait for FilmGrainComponent {
}

pub static FILMGRAINCOMPONENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FilmGrainComponent",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::COMPONENT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FilmGrainComponent as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(FILMGRAINCOMPONENT_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for FilmGrainComponent {
    fn type_info(&self) -> &'static TypeInfo {
        FILMGRAINCOMPONENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FILMGRAINCOMPONENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FilmGrainComponent-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("FilmGrainComponent"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VignetteComponent {
    pub _glacier_base: super::entity::Component,
}

pub trait VignetteComponentTrait: super::entity::ComponentTrait {
}

impl VignetteComponentTrait for VignetteComponent {
}

impl super::entity::ComponentTrait for VignetteComponent {
}

impl super::entity::EntityBusPeerTrait for VignetteComponent {
}

pub static VIGNETTECOMPONENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VignetteComponent",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::COMPONENT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VignetteComponent as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(VIGNETTECOMPONENT_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for VignetteComponent {
    fn type_info(&self) -> &'static TypeInfo {
        VIGNETTECOMPONENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VIGNETTECOMPONENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VignetteComponent-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("VignetteComponent"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DofComponent {
    pub _glacier_base: super::entity::Component,
}

pub trait DofComponentTrait: super::entity::ComponentTrait {
}

impl DofComponentTrait for DofComponent {
}

impl super::entity::ComponentTrait for DofComponent {
}

impl super::entity::EntityBusPeerTrait for DofComponent {
}

pub static DOFCOMPONENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DofComponent",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::COMPONENT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DofComponent as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(DOFCOMPONENT_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for DofComponent {
    fn type_info(&self) -> &'static TypeInfo {
        DOFCOMPONENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DOFCOMPONENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DofComponent-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("DofComponent"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FilmicEffectsComponent {
    pub _glacier_base: super::entity::Component,
}

pub trait FilmicEffectsComponentTrait: super::entity::ComponentTrait {
}

impl FilmicEffectsComponentTrait for FilmicEffectsComponent {
}

impl super::entity::ComponentTrait for FilmicEffectsComponent {
}

impl super::entity::EntityBusPeerTrait for FilmicEffectsComponent {
}

pub static FILMICEFFECTSCOMPONENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FilmicEffectsComponent",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::COMPONENT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FilmicEffectsComponent as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(FILMICEFFECTSCOMPONENT_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for FilmicEffectsComponent {
    fn type_info(&self) -> &'static TypeInfo {
        FILMICEFFECTSCOMPONENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FILMICEFFECTSCOMPONENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FilmicEffectsComponent-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("FilmicEffectsComponent"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DynamicAOComponent {
    pub _glacier_base: super::entity::Component,
}

pub trait DynamicAOComponentTrait: super::entity::ComponentTrait {
}

impl DynamicAOComponentTrait for DynamicAOComponent {
}

impl super::entity::ComponentTrait for DynamicAOComponent {
}

impl super::entity::EntityBusPeerTrait for DynamicAOComponent {
}

pub static DYNAMICAOCOMPONENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicAOComponent",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::COMPONENT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DynamicAOComponent as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(DYNAMICAOCOMPONENT_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for DynamicAOComponent {
    fn type_info(&self) -> &'static TypeInfo {
        DYNAMICAOCOMPONENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DYNAMICAOCOMPONENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicAOComponent-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("DynamicAOComponent"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SunFlareComponent {
    pub _glacier_base: super::entity::Component,
}

pub trait SunFlareComponentTrait: super::entity::ComponentTrait {
}

impl SunFlareComponentTrait for SunFlareComponent {
}

impl super::entity::ComponentTrait for SunFlareComponent {
}

impl super::entity::EntityBusPeerTrait for SunFlareComponent {
}

pub static SUNFLARECOMPONENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SunFlareComponent",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::COMPONENT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SunFlareComponent as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SUNFLARECOMPONENT_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SunFlareComponent {
    fn type_info(&self) -> &'static TypeInfo {
        SUNFLARECOMPONENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SUNFLARECOMPONENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SunFlareComponent-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("SunFlareComponent"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CloudComponent {
    pub _glacier_base: super::entity::Component,
}

pub trait CloudComponentTrait: super::entity::ComponentTrait {
}

impl CloudComponentTrait for CloudComponent {
}

impl super::entity::ComponentTrait for CloudComponent {
}

impl super::entity::EntityBusPeerTrait for CloudComponent {
}

pub static CLOUDCOMPONENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CloudComponent",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::COMPONENT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CloudComponent as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(CLOUDCOMPONENT_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for CloudComponent {
    fn type_info(&self) -> &'static TypeInfo {
        CLOUDCOMPONENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CLOUDCOMPONENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CloudComponent-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("CloudComponent"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WindComponent {
    pub _glacier_base: super::entity::Component,
}

pub trait WindComponentTrait: super::entity::ComponentTrait {
}

impl WindComponentTrait for WindComponent {
}

impl super::entity::ComponentTrait for WindComponent {
}

impl super::entity::EntityBusPeerTrait for WindComponent {
}

pub static WINDCOMPONENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WindComponent",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::COMPONENT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WindComponent as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(WINDCOMPONENT_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for WindComponent {
    fn type_info(&self) -> &'static TypeInfo {
        WINDCOMPONENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WINDCOMPONENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WindComponent-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("WindComponent"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FogComponent {
    pub _glacier_base: super::entity::Component,
}

pub trait FogComponentTrait: super::entity::ComponentTrait {
}

impl FogComponentTrait for FogComponent {
}

impl super::entity::ComponentTrait for FogComponent {
}

impl super::entity::EntityBusPeerTrait for FogComponent {
}

pub static FOGCOMPONENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FogComponent",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::COMPONENT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FogComponent as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(FOGCOMPONENT_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for FogComponent {
    fn type_info(&self) -> &'static TypeInfo {
        FOGCOMPONENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FOGCOMPONENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FogComponent-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("FogComponent"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ColorCorrectionComponent {
    pub _glacier_base: super::entity::Component,
}

pub trait ColorCorrectionComponentTrait: super::entity::ComponentTrait {
}

impl ColorCorrectionComponentTrait for ColorCorrectionComponent {
}

impl super::entity::ComponentTrait for ColorCorrectionComponent {
}

impl super::entity::EntityBusPeerTrait for ColorCorrectionComponent {
}

pub static COLORCORRECTIONCOMPONENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ColorCorrectionComponent",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::COMPONENT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ColorCorrectionComponent as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(COLORCORRECTIONCOMPONENT_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ColorCorrectionComponent {
    fn type_info(&self) -> &'static TypeInfo {
        COLORCORRECTIONCOMPONENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COLORCORRECTIONCOMPONENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ColorCorrectionComponent-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("ColorCorrectionComponent"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TonemapComponent {
    pub _glacier_base: super::entity::Component,
}

pub trait TonemapComponentTrait: super::entity::ComponentTrait {
}

impl TonemapComponentTrait for TonemapComponent {
}

impl super::entity::ComponentTrait for TonemapComponent {
}

impl super::entity::EntityBusPeerTrait for TonemapComponent {
}

pub static TONEMAPCOMPONENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TonemapComponent",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::COMPONENT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TonemapComponent as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(TONEMAPCOMPONENT_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for TonemapComponent {
    fn type_info(&self) -> &'static TypeInfo {
        TONEMAPCOMPONENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TONEMAPCOMPONENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TonemapComponent-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("TonemapComponent"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EnlightenComponent {
    pub _glacier_base: super::entity::Component,
}

pub trait EnlightenComponentTrait: super::entity::ComponentTrait {
}

impl EnlightenComponentTrait for EnlightenComponent {
}

impl super::entity::ComponentTrait for EnlightenComponent {
}

impl super::entity::EntityBusPeerTrait for EnlightenComponent {
}

pub static ENLIGHTENCOMPONENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnlightenComponent",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::COMPONENT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EnlightenComponent as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(ENLIGHTENCOMPONENT_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for EnlightenComponent {
    fn type_info(&self) -> &'static TypeInfo {
        ENLIGHTENCOMPONENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ENLIGHTENCOMPONENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnlightenComponent-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("EnlightenComponent"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct OutdoorLightComponent {
    pub _glacier_base: super::entity::Component,
}

pub trait OutdoorLightComponentTrait: super::entity::ComponentTrait {
}

impl OutdoorLightComponentTrait for OutdoorLightComponent {
}

impl super::entity::ComponentTrait for OutdoorLightComponent {
}

impl super::entity::EntityBusPeerTrait for OutdoorLightComponent {
}

pub static OUTDOORLIGHTCOMPONENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OutdoorLightComponent",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::COMPONENT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<OutdoorLightComponent as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(OUTDOORLIGHTCOMPONENT_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for OutdoorLightComponent {
    fn type_info(&self) -> &'static TypeInfo {
        OUTDOORLIGHTCOMPONENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static OUTDOORLIGHTCOMPONENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OutdoorLightComponent-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("OutdoorLightComponent"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct IndirectSpecularComponent {
    pub _glacier_base: super::entity::Component,
}

pub trait IndirectSpecularComponentTrait: super::entity::ComponentTrait {
}

impl IndirectSpecularComponentTrait for IndirectSpecularComponent {
}

impl super::entity::ComponentTrait for IndirectSpecularComponent {
}

impl super::entity::EntityBusPeerTrait for IndirectSpecularComponent {
}

pub static INDIRECTSPECULARCOMPONENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IndirectSpecularComponent",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::COMPONENT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<IndirectSpecularComponent as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(INDIRECTSPECULARCOMPONENT_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for IndirectSpecularComponent {
    fn type_info(&self) -> &'static TypeInfo {
        INDIRECTSPECULARCOMPONENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static INDIRECTSPECULARCOMPONENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IndirectSpecularComponent-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("IndirectSpecularComponent"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SkyComponent {
    pub _glacier_base: super::entity::Component,
}

pub trait SkyComponentTrait: super::entity::ComponentTrait {
}

impl SkyComponentTrait for SkyComponent {
}

impl super::entity::ComponentTrait for SkyComponent {
}

impl super::entity::EntityBusPeerTrait for SkyComponent {
}

pub static SKYCOMPONENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SkyComponent",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::COMPONENT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SkyComponent as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SKYCOMPONENT_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SkyComponent {
    fn type_info(&self) -> &'static TypeInfo {
        SKYCOMPONENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SKYCOMPONENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SkyComponent-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("SkyComponent"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RenderFramesTrack {
    pub _glacier_base: super::timeline::TimelineTrack,
}

pub trait RenderFramesTrackTrait: super::timeline::TimelineTrackTrait {
}

impl RenderFramesTrackTrait for RenderFramesTrack {
}

impl super::timeline::TimelineTrackTrait for RenderFramesTrack {
}

pub static RENDERFRAMESTRACK_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RenderFramesTrack",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::TIMELINETRACK_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RenderFramesTrack as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(RENDERFRAMESTRACK_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for RenderFramesTrack {
    fn type_info(&self) -> &'static TypeInfo {
        RENDERFRAMESTRACK_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RENDERFRAMESTRACK_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RenderFramesTrack-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("RenderFramesTrack"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ServerVisibleAreaEntity {
    pub _glacier_base: super::entity::Entity,
}

pub trait ServerVisibleAreaEntityTrait: super::entity::EntityTrait {
}

impl ServerVisibleAreaEntityTrait for ServerVisibleAreaEntity {
}

impl super::entity::EntityTrait for ServerVisibleAreaEntity {
}

impl super::entity::EntityBusPeerTrait for ServerVisibleAreaEntity {
}

pub static SERVERVISIBLEAREAENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ServerVisibleAreaEntity",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ServerVisibleAreaEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SERVERVISIBLEAREAENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ServerVisibleAreaEntity {
    fn type_info(&self) -> &'static TypeInfo {
        SERVERVISIBLEAREAENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SERVERVISIBLEAREAENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ServerVisibleAreaEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("ServerVisibleAreaEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ClientVisibleAreaEntity {
    pub _glacier_base: super::entity::Entity,
}

pub trait ClientVisibleAreaEntityTrait: super::entity::EntityTrait {
}

impl ClientVisibleAreaEntityTrait for ClientVisibleAreaEntity {
}

impl super::entity::EntityTrait for ClientVisibleAreaEntity {
}

impl super::entity::EntityBusPeerTrait for ClientVisibleAreaEntity {
}

pub static CLIENTVISIBLEAREAENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClientVisibleAreaEntity",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ClientVisibleAreaEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(CLIENTVISIBLEAREAENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ClientVisibleAreaEntity {
    fn type_info(&self) -> &'static TypeInfo {
        CLIENTVISIBLEAREAENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CLIENTVISIBLEAREAENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClientVisibleAreaEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("ClientVisibleAreaEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct StaticEnlightenEntity {
    pub _glacier_base: super::entity::Entity,
}

pub trait StaticEnlightenEntityTrait: super::entity::EntityTrait {
}

impl StaticEnlightenEntityTrait for StaticEnlightenEntity {
}

impl super::entity::EntityTrait for StaticEnlightenEntity {
}

impl super::entity::EntityBusPeerTrait for StaticEnlightenEntity {
}

pub static STATICENLIGHTENENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StaticEnlightenEntity",
    flags: MemberInfoFlags::new(101),
    module: "WorldSim",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StaticEnlightenEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(STATICENLIGHTENENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for StaticEnlightenEntity {
    fn type_info(&self) -> &'static TypeInfo {
        STATICENLIGHTENENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static STATICENLIGHTENENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StaticEnlightenEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "WorldSim",
    data: TypeInfoData::Array("StaticEnlightenEntity"),
    array_type: None,
    alignment: 8,
};


