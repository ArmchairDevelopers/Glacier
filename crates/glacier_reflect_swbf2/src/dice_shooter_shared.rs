use std::{mem::offset_of, any::Any, option::Option, sync::Arc};
use tokio::sync::Mutex;

use glacier_reflect::{
    member::MemberInfoFlags,
    type_info::{
        ClassInfoData, ValueTypeInfoData, FieldInfoData, TypeInfo, TypeInfoData, TypeObject, TypeFunctions,
    }, type_registry::TypeRegistry,
};

pub(crate) fn register_dice_shooter_shared_types(registry: &mut TypeRegistry) {
    registry.register_type(MULTIBODYPHYSICSCOMPONENTDATA_TYPE_INFO);
    registry.register_type(MULTIBODYPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(PHYSICSBODYWRAPPING_TYPE_INFO);
    registry.register_type(PHYSICSBODYWRAPPING_ARRAY_TYPE_INFO);
    registry.register_type(PHYSICSBONEMAPPING_TYPE_INFO);
    registry.register_type(PHYSICSBONEMAPPING_ARRAY_TYPE_INFO);
    registry.register_type(MOUNTHEALTHCOMPONENTDATA_TYPE_INFO);
    registry.register_type(MOUNTHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(ENTITYREPLICATIONNETSTATE_TYPE_INFO);
    registry.register_type(ENTITYREPLICATIONNETSTATE_ARRAY_TYPE_INFO);
    registry.register_type(ENTITYREPLICATIONEVENT_TYPE_INFO);
    registry.register_type(ENTITYREPLICATIONEVENT_ARRAY_TYPE_INFO);
    registry.register_type(ENTITYREPLICATIONINT_TYPE_INFO);
    registry.register_type(ENTITYREPLICATIONINT_ARRAY_TYPE_INFO);
    registry.register_type(ENTITYREPLICATIONFLOAT_TYPE_INFO);
    registry.register_type(ENTITYREPLICATIONFLOAT_ARRAY_TYPE_INFO);
    registry.register_type(ENTITYREPLICATIONBOOL_TYPE_INFO);
    registry.register_type(ENTITYREPLICATIONBOOL_ARRAY_TYPE_INFO);
    registry.register_type(ENTITYREPLICATIONINTERFACECOMPONENTDATA_TYPE_INFO);
    registry.register_type(ENTITYREPLICATIONINTERFACECOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOGICAWARENESSTARGETENTITYDATA_TYPE_INFO);
    registry.register_type(LOGICAWARENESSTARGETENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AWARENESSTARGETENTITYDATA_TYPE_INFO);
    registry.register_type(AWARENESSTARGETENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AWARENESSCOMPONENTDATA_TYPE_INFO);
    registry.register_type(AWARENESSCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(AWARENESSTARGETINFO_TYPE_INFO);
    registry.register_type(AWARENESSTARGETINFO_ARRAY_TYPE_INFO);
    registry.register_type(LOOKATTARGETTYPE_TYPE_INFO);
    registry.register_type(LOOKATTARGETTYPE_ARRAY_TYPE_INFO);
    registry.register_type(AWARENESSTARGETTYPE_TYPE_INFO);
    registry.register_type(AWARENESSTARGETTYPE_ARRAY_TYPE_INFO);
    registry.register_type(AWARENESSCOMPONENTBINDING_TYPE_INFO);
    registry.register_type(AWARENESSCOMPONENTBINDING_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEREQUESTNETSTATE_TYPE_INFO);
    registry.register_type(CHARACTERSTATEREQUESTNETSTATE_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEREQUESTNETSTATEFLAGS_TYPE_INFO);
    registry.register_type(CHARACTERSTATEREQUESTNETSTATEFLAGS_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEREQUESTENTITYDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEREQUESTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEREQUESTLISTDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEREQUESTLISTDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEREQUESTSETCONSTANTSDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEREQUESTSETCONSTANTSDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEREQUESTOBJECTINTERACTIONDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEREQUESTOBJECTINTERACTIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEREQUESTTRANSFORMINTERACTIONDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEREQUESTTRANSFORMINTERACTIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMCHANNELVARIATION_TYPE_INFO);
    registry.register_type(TRANSFORMCHANNELVARIATION_ARRAY_TYPE_INFO);
    registry.register_type(VEC3CHANNELVARIATION_TYPE_INFO);
    registry.register_type(VEC3CHANNELVARIATION_ARRAY_TYPE_INFO);
    registry.register_type(FLOATCHANNELVARIATION_TYPE_INFO);
    registry.register_type(FLOATCHANNELVARIATION_ARRAY_TYPE_INFO);
    registry.register_type(INTCHANNELVARIATION_TYPE_INFO);
    registry.register_type(INTCHANNELVARIATION_ARRAY_TYPE_INFO);
    registry.register_type(BOOLCHANNELVARIATION_TYPE_INFO);
    registry.register_type(BOOLCHANNELVARIATION_ARRAY_TYPE_INFO);
    registry.register_type(CHANNELVARIATIONLIST_TYPE_INFO);
    registry.register_type(CHANNELVARIATIONLIST_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEREQUESTDATABASE_TYPE_INFO);
    registry.register_type(CHARACTERSTATEREQUESTDATABASE_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEOWNERDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEOWNERDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEDYNAMICAVOIDANCEDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEDYNAMICAVOIDANCEDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATECONTROLLERGROUP_TYPE_INFO);
    registry.register_type(CHARACTERSTATECONTROLLERGROUP_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEROOTCONTROLLERDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEROOTCONTROLLERDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEINFO_TYPE_INFO);
    registry.register_type(CHARACTERSTATEINFO_ARRAY_TYPE_INFO);
    registry.register_type(CONTROLLEREVALCOMPONENTDATA_TYPE_INFO);
    registry.register_type(CONTROLLEREVALCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(OLDPHYSICSEMULATORDATA_TYPE_INFO);
    registry.register_type(OLDPHYSICSEMULATORDATA_ARRAY_TYPE_INFO);
    registry.register_type(INPUTTOFLOATGAMESTATE_TYPE_INFO);
    registry.register_type(INPUTTOFLOATGAMESTATE_ARRAY_TYPE_INFO);
    registry.register_type(INPUTTOINTGAMESTATE_TYPE_INFO);
    registry.register_type(INPUTTOINTGAMESTATE_ARRAY_TYPE_INFO);
    registry.register_type(INPUTTOGAMESTATE_TYPE_INFO);
    registry.register_type(INPUTTOGAMESTATE_ARRAY_TYPE_INFO);
    registry.register_type(INPUTTOGAMESTATECUTOFFTIMEMODE_TYPE_INFO);
    registry.register_type(INPUTTOGAMESTATECUTOFFTIMEMODE_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEEVALCOMPONENTCONSTANTS_TYPE_INFO);
    registry.register_type(CHARACTERSTATEEVALCOMPONENTCONSTANTS_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATECHANNELREADERENTITYDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATECHANNELREADERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEPUBLICORPRIVATECHANNELDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEPUBLICORPRIVATECHANNELDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEWARPANIMATIONTOINPUTCONTROLLERDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEWARPANIMATIONTOINPUTCONTROLLERDATA_ARRAY_TYPE_INFO);
    registry.register_type(WARPCLIPTARGETCONNECTFROMINPUTDATA_TYPE_INFO);
    registry.register_type(WARPCLIPTARGETCONNECTFROMINPUTDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATETIMECONTROLLERDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATETIMECONTROLLERDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATESTATEFLOWCONTROLLERDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATESTATEFLOWCONTROLLERDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATESTATEFLOWNODECONTROLLERDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATESTATEFLOWNODECONTROLLERDATA_ARRAY_TYPE_INFO);
    registry.register_type(TRANSITIONCONDITION_TYPE_INFO);
    registry.register_type(TRANSITIONCONDITION_ARRAY_TYPE_INFO);
    registry.register_type(TRANSITIONCONDITIONNUMERICCOMPAREMODE_TYPE_INFO);
    registry.register_type(TRANSITIONCONDITIONNUMERICCOMPAREMODE_ARRAY_TYPE_INFO);
    registry.register_type(TRANSITIONCONDITIONBOOLCOMPAREMODE_TYPE_INFO);
    registry.register_type(TRANSITIONCONDITIONBOOLCOMPAREMODE_ARRAY_TYPE_INFO);
    registry.register_type(TRANSITIONCONDITIONTYPE_TYPE_INFO);
    registry.register_type(TRANSITIONCONDITIONTYPE_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATETRANSITIONCONTROLLERDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATETRANSITIONCONTROLLERDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATETRANSITIONPHASEMODE_TYPE_INFO);
    registry.register_type(CHARACTERSTATETRANSITIONPHASEMODE_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEPOSEMATCHINGCONTROLLERDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEPOSEMATCHINGCONTROLLERDATA_ARRAY_TYPE_INFO);
    registry.register_type(EXTRACTEDCLIPINFO_TYPE_INFO);
    registry.register_type(EXTRACTEDCLIPINFO_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEPAIREDCLIPCONTROLLERDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEPAIREDCLIPCONTROLLERDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLEWEAPONPLAYERABILITYNETSTATE_TYPE_INFO);
    registry.register_type(VEHICLEWEAPONPLAYERABILITYNETSTATE_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERWEAPONPLAYERABILITYNETSTATE_TYPE_INFO);
    registry.register_type(SOLDIERWEAPONPLAYERABILITYNETSTATE_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEPLAYERABILITYNETSTATE_TYPE_INFO);
    registry.register_type(CHARACTERSTATEPLAYERABILITYNETSTATE_ARRAY_TYPE_INFO);
    registry.register_type(RECHARGEABLEPLAYERABILITYNETSTATE_TYPE_INFO);
    registry.register_type(RECHARGEABLEPLAYERABILITYNETSTATE_ARRAY_TYPE_INFO);
    registry.register_type(RETRIGGERABLEPLAYERABILITYNETSTATE_TYPE_INFO);
    registry.register_type(RETRIGGERABLEPLAYERABILITYNETSTATE_ARRAY_TYPE_INFO);
    registry.register_type(EMPTYPLAYERABILITYNETSTATE_TYPE_INFO);
    registry.register_type(EMPTYPLAYERABILITYNETSTATE_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERABILITYPROPERTYMODIFIER_TYPE_INFO);
    registry.register_type(PLAYERABILITYPROPERTYMODIFIER_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERABILITYPROPERTYMODIFIERTRIGGERCOSTVALUE_TYPE_INFO);
    registry.register_type(PLAYERABILITYPROPERTYMODIFIERTRIGGERCOSTVALUE_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERABILITYPROPERTYMODIFIERCHARGECOUNTVALUE_TYPE_INFO);
    registry.register_type(PLAYERABILITYPROPERTYMODIFIERCHARGECOUNTVALUE_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERABILITYPROPERTYMODIFIERACTIVATIONVALUE_TYPE_INFO);
    registry.register_type(PLAYERABILITYPROPERTYMODIFIERACTIVATIONVALUE_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERABILITYPROPERTYMODIFIERACTIVEVALUE_TYPE_INFO);
    registry.register_type(PLAYERABILITYPROPERTYMODIFIERACTIVEVALUE_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERABILITYPROPERTYMODIFIERRECHARGEVALUE_TYPE_INFO);
    registry.register_type(PLAYERABILITYPROPERTYMODIFIERRECHARGEVALUE_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERABILITYPROPERTYMODIFIERVALUE_TYPE_INFO);
    registry.register_type(PLAYERABILITYPROPERTYMODIFIERVALUE_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERABILITYMODIFIERUNLOCKMODIFIER_TYPE_INFO);
    registry.register_type(PLAYERABILITYMODIFIERUNLOCKMODIFIER_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERABILITYPROPERTYOUTPUTMODIFIER_TYPE_INFO);
    registry.register_type(PLAYERABILITYPROPERTYOUTPUTMODIFIER_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERABILITYMODIFIER_TYPE_INFO);
    registry.register_type(PLAYERABILITYMODIFIER_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERABILITYPROPERTYOUTPUTINTMODIFIERVALUE_TYPE_INFO);
    registry.register_type(PLAYERABILITYPROPERTYOUTPUTINTMODIFIERVALUE_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERABILITYPROPERTYOUTPUTFLOATMODIFIERVALUE_TYPE_INFO);
    registry.register_type(PLAYERABILITYPROPERTYOUTPUTFLOATMODIFIERVALUE_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERABILITYPROPERTYOUTPUTVEC3MODIFIERVALUE_TYPE_INFO);
    registry.register_type(PLAYERABILITYPROPERTYOUTPUTVEC3MODIFIERVALUE_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERABILITYPROPERTYOUTPUTBOOLMODIFIERVALUE_TYPE_INFO);
    registry.register_type(PLAYERABILITYPROPERTYOUTPUTBOOLMODIFIERVALUE_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERABILITYPROPERTYOUTPUTMODIFIERVALUE_TYPE_INFO);
    registry.register_type(PLAYERABILITYPROPERTYOUTPUTMODIFIERVALUE_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERABILITYUSEDMESSAGE_TYPE_INFO);
    registry.register_type(PLAYERABILITYACTIVATEDMESSAGE_TYPE_INFO);
    registry.register_type(PLAYERABILITYREPLACEDMESSAGE_TYPE_INFO);
    registry.register_type(PLAYERABILITYWEAPONUPGRADESUPDATEDMESSAGE_TYPE_INFO);
    registry.register_type(PLAYERABILITYENTRYINPUTCONTAINER_TYPE_INFO);
    registry.register_type(PLAYERABILITYENTRYINPUTCONTAINER_ARRAY_TYPE_INFO);
    registry.register_type(ABILITYCATEGORYINPUTMAPPING_TYPE_INFO);
    registry.register_type(ABILITYCATEGORYINPUTMAPPING_ARRAY_TYPE_INFO);
    registry.register_type(ABILITYACTION_TYPE_INFO);
    registry.register_type(ABILITYACTION_ARRAY_TYPE_INFO);
    registry.register_type(ABILITYINPUTCUTOFFTIMEMODE_TYPE_INFO);
    registry.register_type(ABILITYINPUTCUTOFFTIMEMODE_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERABILITYPICKUPENTITYTYPE_TYPE_INFO);
    registry.register_type(PLAYERABILITYPICKUPENTITYTYPE_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERABILITYINPUTCONSTANTS_TYPE_INFO);
    registry.register_type(PLAYERABILITYINPUTCONSTANTS_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERABILITYLEVEL_TYPE_INFO);
    registry.register_type(PLAYERABILITYLEVEL_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERABILITYSTATE_TYPE_INFO);
    registry.register_type(PLAYERABILITYSTATE_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERABILITYCONSTANTS_TYPE_INFO);
    registry.register_type(PLAYERABILITYCONSTANTS_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERABILITYCATEGORY_TYPE_INFO);
    registry.register_type(PLAYERABILITYCATEGORY_ARRAY_TYPE_INFO);
    registry.register_type(STATICPLAYERABILITYPICKUPENTITYDATA_TYPE_INFO);
    registry.register_type(STATICPLAYERABILITYPICKUPENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(DYNAMICPLAYERABILITYPICKUPENTITYDATA_TYPE_INFO);
    registry.register_type(DYNAMICPLAYERABILITYPICKUPENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERABILITYSPATIALPICKUPENTITYDATA_TYPE_INFO);
    registry.register_type(PLAYERABILITYSPATIALPICKUPENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERABILITYPICKUPENTITYDATA_TYPE_INFO);
    registry.register_type(PLAYERABILITYPICKUPENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CATEGORYTOPLAYERABILITYENTITYDATA_TYPE_INFO);
    registry.register_type(CATEGORYTOPLAYERABILITYENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(REMOTEPLAYERABILITYSTATEENTITYDATA_TYPE_INFO);
    registry.register_type(REMOTEPLAYERABILITYSTATEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERABILITYSTATETRACKMODE_TYPE_INFO);
    registry.register_type(PLAYERABILITYSTATETRACKMODE_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERABILITYSTATEENTITYDATA_TYPE_INFO);
    registry.register_type(PLAYERABILITYSTATEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERABILITYPROPERTYOUTPUTENTITYDATA_TYPE_INFO);
    registry.register_type(PLAYERABILITYPROPERTYOUTPUTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERABILITYENTITYDATA_TYPE_INFO);
    registry.register_type(PLAYERABILITYENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(RECHARGEABLEPLAYERABILITYASSET_TYPE_INFO);
    registry.register_type(RECHARGEABLEPLAYERABILITYASSET_ARRAY_TYPE_INFO);
    registry.register_type(RETRIGGERABLEPLAYERABILITYASSET_TYPE_INFO);
    registry.register_type(RETRIGGERABLEPLAYERABILITYASSET_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERWEAPONPLAYERABILITYASSET_TYPE_INFO);
    registry.register_type(SOLDIERWEAPONPLAYERABILITYASSET_ARRAY_TYPE_INFO);
    registry.register_type(PASSIVEPLAYERABILITYASSET_TYPE_INFO);
    registry.register_type(PASSIVEPLAYERABILITYASSET_ARRAY_TYPE_INFO);
    registry.register_type(BASICPLAYERABILITYASSET_TYPE_INFO);
    registry.register_type(BASICPLAYERABILITYASSET_ARRAY_TYPE_INFO);
    registry.register_type(CORRECTEDPLAYERABILITYASSET_TYPE_INFO);
    registry.register_type(CORRECTEDPLAYERABILITYASSET_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEVEC3CHANNELVALUEDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEVEC3CHANNELVALUEDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEFLOATCHANNELVALUEDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEFLOATCHANNELVALUEDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEINTCHANNELVALUEDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEINTCHANNELVALUEDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEBOOLCHANNELVALUEDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEBOOLCHANNELVALUEDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATECHANNELVALUEDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATECHANNELVALUEDATA_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERABILITYASSET_TYPE_INFO);
    registry.register_type(PLAYERABILITYASSET_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERABILITYASSETGROUP_TYPE_INFO);
    registry.register_type(PLAYERABILITYASSETGROUP_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERABILITYASSETBASE_TYPE_INFO);
    registry.register_type(PLAYERABILITYASSETBASE_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERABILITYSETCATEGORYMODIFIER_TYPE_INFO);
    registry.register_type(PLAYERABILITYSETCATEGORYMODIFIER_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERABILITYINPUTMODIFIER_TYPE_INFO);
    registry.register_type(PLAYERABILITYINPUTMODIFIER_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERABILITYINPUTMODIFIERTIME_TYPE_INFO);
    registry.register_type(PLAYERABILITYINPUTMODIFIERTIME_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERABILITYBLOCKINGRULE_TYPE_INFO);
    registry.register_type(PLAYERABILITYBLOCKINGRULE_ARRAY_TYPE_INFO);
    registry.register_type(NONCUSTOMIZABLEPLAYERABILITYSETCOMPONENTDATA_TYPE_INFO);
    registry.register_type(NONCUSTOMIZABLEPLAYERABILITYSETCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERABILITYSETCOMPONENTDATA_TYPE_INFO);
    registry.register_type(PLAYERABILITYSETCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(ABILITYSETDYNAMICMODIFIERDATA_TYPE_INFO);
    registry.register_type(ABILITYSETDYNAMICMODIFIERDATA_ARRAY_TYPE_INFO);
    registry.register_type(ABILITYDYNAMICFLOATMODIFIER_TYPE_INFO);
    registry.register_type(ABILITYDYNAMICFLOATMODIFIER_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERABILITYPICKUPENTITYBLUEPRINT_TYPE_INFO);
    registry.register_type(PLAYERABILITYPICKUPENTITYBLUEPRINT_ARRAY_TYPE_INFO);
    registry.register_type(LINKEDPLAYERABILITYREFERENCEENTITYDATA_TYPE_INFO);
    registry.register_type(LINKEDPLAYERABILITYREFERENCEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(LINKEDABILITYREFERENCEENTITYDATA_TYPE_INFO);
    registry.register_type(LINKEDABILITYREFERENCEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PROXYPLAYERSQUADENTITYDATA_TYPE_INFO);
    registry.register_type(PROXYPLAYERSQUADENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PROXYPLAYERSETTINGS_TYPE_INFO);
    registry.register_type(PROXYPLAYERSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(PROXYPLAYERMOVETOCOMMANDENTITYDATA_TYPE_INFO);
    registry.register_type(PROXYPLAYERMOVETOCOMMANDENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PROXYPLAYERFIRECOMMANDENTITYDATA_TYPE_INFO);
    registry.register_type(PROXYPLAYERFIRECOMMANDENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PROXYPLAYERCOMMANDENTITYDATA_TYPE_INFO);
    registry.register_type(PROXYPLAYERCOMMANDENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PROXYPLAYERAIMATCOMMANDENTITYDATA_TYPE_INFO);
    registry.register_type(PROXYPLAYERAIMATCOMMANDENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONMODIFIERSTATEENTITYDATA_TYPE_INFO);
    registry.register_type(WEAPONMODIFIERSTATEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VAULTMODIFIERVOLUMEENTITYDATA_TYPE_INFO);
    registry.register_type(VAULTMODIFIERVOLUMEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VAULTMODIFIERTYPE_TYPE_INFO);
    registry.register_type(VAULTMODIFIERTYPE_ARRAY_TYPE_INFO);
    registry.register_type(VAULTMODIFIERBOX_TYPE_INFO);
    registry.register_type(VAULTMODIFIERBOX_ARRAY_TYPE_INFO);
    registry.register_type(TRIGGEREXPLOSIVEENTITYDATA_TYPE_INFO);
    registry.register_type(TRIGGEREXPLOSIVEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TRIGGEREXPLOSIVEENTITYCONSTANTS_TYPE_INFO);
    registry.register_type(TRIGGEREXPLOSIVEENTITYCONSTANTS_ARRAY_TYPE_INFO);
    registry.register_type(INPUTTONETWORKEDBOOLENTITYDATA_TYPE_INFO);
    registry.register_type(INPUTTONETWORKEDBOOLENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(GRAVITYWELLSYNCSTRUCT_TYPE_INFO);
    registry.register_type(GRAVITYWELLSYNCSTRUCT_ARRAY_TYPE_INFO);
    registry.register_type(GRAVITYWELLTICKSYNCSTATE_TYPE_INFO);
    registry.register_type(GRAVITYWELLTICKSYNCSTATE_ARRAY_TYPE_INFO);
    registry.register_type(GRAVITYWELLSTATE_TYPE_INFO);
    registry.register_type(GRAVITYWELLSTATE_ARRAY_TYPE_INFO);
    registry.register_type(GRAVITYWELLCONTROLLERENTITYDATA_TYPE_INFO);
    registry.register_type(GRAVITYWELLCONTROLLERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(GRAVITYWELLCONFIGDATA_TYPE_INFO);
    registry.register_type(GRAVITYWELLCONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(FRAMEINTERPOLATEDTRANSFORMDATA_TYPE_INFO);
    registry.register_type(FRAMEINTERPOLATEDTRANSFORMDATA_ARRAY_TYPE_INFO);
    registry.register_type(MATERIALBASEDEFFECTENTITYDATA_TYPE_INFO);
    registry.register_type(MATERIALBASEDEFFECTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(WSNORMALALIGNMENT_TYPE_INFO);
    registry.register_type(WSNORMALALIGNMENT_ARRAY_TYPE_INFO);
    registry.register_type(WSSNAPTYPE_TYPE_INFO);
    registry.register_type(WSSNAPTYPE_ARRAY_TYPE_INFO);
    registry.register_type(DICEPLAYVFXENTITYDATA_TYPE_INFO);
    registry.register_type(DICEPLAYVFXENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(DICEVFXENTITYBASEDATA_TYPE_INFO);
    registry.register_type(DICEVFXENTITYBASEDATA_ARRAY_TYPE_INFO);
    registry.register_type(DICESHOOTERDEATHEXPERIENCEENTITYDATA_TYPE_INFO);
    registry.register_type(DICESHOOTERDEATHEXPERIENCEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(DEATHEXPERIENCESMOOTHING_TYPE_INFO);
    registry.register_type(DEATHEXPERIENCESMOOTHING_ARRAY_TYPE_INFO);
    registry.register_type(DEBUGPLAYERSPAWNERDATA_TYPE_INFO);
    registry.register_type(DEBUGPLAYERSPAWNERDATA_ARRAY_TYPE_INFO);
    registry.register_type(DAMAGEGIVERENTITYDATA_TYPE_INFO);
    registry.register_type(DAMAGEGIVERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CONTROLLABLEINPUTFILTERENTITYDATA_TYPE_INFO);
    registry.register_type(CONTROLLABLEINPUTFILTERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TOGGLESPRINTINPUTDATA_TYPE_INFO);
    registry.register_type(TOGGLESPRINTINPUTDATA_ARRAY_TYPE_INFO);
    registry.register_type(VERTICALAVOIDANCEDATA_TYPE_INFO);
    registry.register_type(VERTICALAVOIDANCEDATA_ARRAY_TYPE_INFO);
    registry.register_type(HINTBOXAVOIDANCEDATA_TYPE_INFO);
    registry.register_type(HINTBOXAVOIDANCEDATA_ARRAY_TYPE_INFO);
    registry.register_type(DEFAULTAVOIDANCEDATA_TYPE_INFO);
    registry.register_type(DEFAULTAVOIDANCEDATA_ARRAY_TYPE_INFO);
    registry.register_type(INPUTTOVELOCITYBENDPARAMS_TYPE_INFO);
    registry.register_type(INPUTTOVELOCITYBENDPARAMS_ARRAY_TYPE_INFO);
    registry.register_type(AVOIDANCEBEHAVIOURBASEDATA_TYPE_INFO);
    registry.register_type(AVOIDANCEBEHAVIOURBASEDATA_ARRAY_TYPE_INFO);
    registry.register_type(INPUTFILTERBASEDATA_TYPE_INFO);
    registry.register_type(INPUTFILTERBASEDATA_ARRAY_TYPE_INFO);
    registry.register_type(OBSTACLEMATERIAL_TYPE_INFO);
    registry.register_type(OBSTACLEMATERIAL_ARRAY_TYPE_INFO);
    registry.register_type(CLIENTVEC3TOSERVERDATA_TYPE_INFO);
    registry.register_type(CLIENTVEC3TOSERVERDATA_ARRAY_TYPE_INFO);
    registry.register_type(CLIENTGRAVITYWELLTRACKERENTITYDATA_TYPE_INFO);
    registry.register_type(CLIENTGRAVITYWELLTRACKERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PHYSICALCAMERATRANSFORMERENTITYDATA_TYPE_INFO);
    registry.register_type(PHYSICALCAMERATRANSFORMERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(HOVERCAMERATRANSFORMERENTITYDATA_TYPE_INFO);
    registry.register_type(HOVERCAMERATRANSFORMERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COCKPITCAMERATRANSFORMERENTITYDATA_TYPE_INFO);
    registry.register_type(COCKPITCAMERATRANSFORMERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(REARVIEWCAMERATRANSFORMERENTITYDATA_TYPE_INFO);
    registry.register_type(REARVIEWCAMERATRANSFORMERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(FOLLOWCAMERATRANSFORMERENTITYDATA_TYPE_INFO);
    registry.register_type(FOLLOWCAMERATRANSFORMERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CAMERASLERPTRANSFORMENTITYDATA_TYPE_INFO);
    registry.register_type(CAMERASLERPTRANSFORMENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SPEEDERCAMERATRANSFORMERENTITYDATA_TYPE_INFO);
    registry.register_type(SPEEDERCAMERATRANSFORMERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VELOCITYREDIRECTCAMERATRANSFORMERENTITYDATA_TYPE_INFO);
    registry.register_type(VELOCITYREDIRECTCAMERATRANSFORMERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(REDIRECTDATA_TYPE_INFO);
    registry.register_type(REDIRECTDATA_ARRAY_TYPE_INFO);
    registry.register_type(QUANTITYAXISPAIR_TYPE_INFO);
    registry.register_type(QUANTITYAXISPAIR_ARRAY_TYPE_INFO);
    registry.register_type(THIRDPERSONCAMERATRANSFORMERENTITYDATA_TYPE_INFO);
    registry.register_type(THIRDPERSONCAMERATRANSFORMERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(ARMCOLLISIONCAMERATRANSFORMERENTITYDATA_TYPE_INFO);
    registry.register_type(ARMCOLLISIONCAMERATRANSFORMERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(THIRDPERSONCAMINERTIAVALUES_TYPE_INFO);
    registry.register_type(THIRDPERSONCAMINERTIAVALUES_ARRAY_TYPE_INFO);
    registry.register_type(YAWONLYCAMERATRANSFORMERENTITYDATA_TYPE_INFO);
    registry.register_type(YAWONLYCAMERATRANSFORMERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(STARFIGHTERCAMERATRANSFORMERENTITYDATA_TYPE_INFO);
    registry.register_type(STARFIGHTERCAMERATRANSFORMERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CAMERAINERTIATRANSFORMENTITYDATA_TYPE_INFO);
    registry.register_type(CAMERAINERTIATRANSFORMENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CAMERATRANSFORMERENTITYDATA_TYPE_INFO);
    registry.register_type(CAMERATRANSFORMERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(HOVERCAMERACONFIGENTITYDATA_TYPE_INFO);
    registry.register_type(HOVERCAMERACONFIGENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COCKPITCAMERACONFIGENTITYDATA_TYPE_INFO);
    registry.register_type(COCKPITCAMERACONFIGENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(REARVIEWCAMERACONFIGENTITYDATA_TYPE_INFO);
    registry.register_type(REARVIEWCAMERACONFIGENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(FOLLOWCAMERACONFIGENTITYDATA_TYPE_INFO);
    registry.register_type(FOLLOWCAMERACONFIGENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CAMERATRANSFORMERUPDATEPASS_TYPE_INFO);
    registry.register_type(CAMERATRANSFORMERUPDATEPASS_ARRAY_TYPE_INFO);
    registry.register_type(BARRAGEENTITYDATA_TYPE_INFO);
    registry.register_type(BARRAGEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(QUERYRESULTPLAYERINSPECTORENTITYDATA_TYPE_INFO);
    registry.register_type(QUERYRESULTPLAYERINSPECTORENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERANIMATABLEMESHPROXYCOMPONENTDATA_TYPE_INFO);
    registry.register_type(CHARACTERANIMATABLEMESHPROXYCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(VAULTCOMPONENTDATA_TYPE_INFO);
    registry.register_type(VAULTCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(VAULT3PONLYBINDING_TYPE_INFO);
    registry.register_type(VAULT3PONLYBINDING_ARRAY_TYPE_INFO);
    registry.register_type(VAULT1PONLYBINDING_TYPE_INFO);
    registry.register_type(VAULT1PONLYBINDING_ARRAY_TYPE_INFO);
    registry.register_type(VAULTBINDING_TYPE_INFO);
    registry.register_type(VAULTBINDING_ARRAY_TYPE_INFO);
    registry.register_type(VAULTTYPE_TYPE_INFO);
    registry.register_type(VAULTTYPE_ARRAY_TYPE_INFO);
    registry.register_type(VAULTSTATE_TYPE_INFO);
    registry.register_type(VAULTSTATE_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERSUPPRESSIONCOMPONENTDATA_TYPE_INFO);
    registry.register_type(SOLDIERSUPPRESSIONCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(SUPPRESSIONTYPE_TYPE_INFO);
    registry.register_type(SUPPRESSIONTYPE_ARRAY_TYPE_INFO);
    registry.register_type(SUPPRESSIONREACTIONDATA_TYPE_INFO);
    registry.register_type(SUPPRESSIONREACTIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(SUPPRESSIONSETTINGS_TYPE_INFO);
    registry.register_type(SUPPRESSIONSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMAREAQUERYENTITYDATA_TYPE_INFO);
    registry.register_type(TRANSFORMAREAQUERYENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TRACKRESPAWNMANAGERENTITYDATA_TYPE_INFO);
    registry.register_type(TRACKRESPAWNMANAGERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COOPCATCHUPTYPE_TYPE_INFO);
    registry.register_type(COOPCATCHUPTYPE_ARRAY_TYPE_INFO);
    registry.register_type(TRACKRESPAWNTYPE_TYPE_INFO);
    registry.register_type(TRACKRESPAWNTYPE_ARRAY_TYPE_INFO);
    registry.register_type(TRACKRESPAWNNODEENTITYDATA_TYPE_INFO);
    registry.register_type(TRACKRESPAWNNODEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TARGETCYCLINGENTITYDATA_TYPE_INFO);
    registry.register_type(TARGETCYCLINGENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(STARFIGHTEROVERLAPENTITYDATA_TYPE_INFO);
    registry.register_type(STARFIGHTEROVERLAPENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(STARFIGHTEROVERLAPCONFIGENTITYDATA_TYPE_INFO);
    registry.register_type(STARFIGHTEROVERLAPCONFIGENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(STARFIGHTERAVOIDANCEZONEENTITYDATA_TYPE_INFO);
    registry.register_type(STARFIGHTERAVOIDANCEZONEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SKISPEEDERPHYSICSACTIONDATA_TYPE_INFO);
    registry.register_type(SKISPEEDERPHYSICSACTIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(SHIELDCONTROLLERENTITYDATA_TYPE_INFO);
    registry.register_type(SHIELDCONTROLLERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SHIELDEXPLOSIONTYPE_TYPE_INFO);
    registry.register_type(SHIELDEXPLOSIONTYPE_ARRAY_TYPE_INFO);
    registry.register_type(RECEIVEEVENTENTITYDATA_TYPE_INFO);
    registry.register_type(RECEIVEEVENTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SENDEVENTENTITYDATA_TYPE_INFO);
    registry.register_type(SENDEVENTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(REMOTEEVENTENTITYDATA_TYPE_INFO);
    registry.register_type(REMOTEEVENTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(REMOTEEVENTENTITYTYPEASSET_TYPE_INFO);
    registry.register_type(REMOTEEVENTENTITYTYPEASSET_ARRAY_TYPE_INFO);
    registry.register_type(REMOTEPROPERTYDEFINITION_TYPE_INFO);
    registry.register_type(REMOTEPROPERTYDEFINITION_ARRAY_TYPE_INFO);
    registry.register_type(REMOTEPROPERTYTYPE_TYPE_INFO);
    registry.register_type(REMOTEPROPERTYTYPE_ARRAY_TYPE_INFO);
    registry.register_type(REMOTEEVENTEVENTTRIGGEREDMESSAGE_TYPE_INFO);
    registry.register_type(REMOTEEVENTPROPERTY_TYPE_INFO);
    registry.register_type(REMOTEEVENTPROPERTY_ARRAY_TYPE_INFO);
    registry.register_type(PROPERTYTOINPUTENTITYDATA_TYPE_INFO);
    registry.register_type(PROPERTYTOINPUTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PLAYEREVENTTOQUERYRESULTENTITYDATA_TYPE_INFO);
    registry.register_type(PLAYEREVENTTOQUERYRESULTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PHYSICSLOCKHEIGHTVOLUMEENTITYDATA_TYPE_INFO);
    registry.register_type(PHYSICSLOCKHEIGHTVOLUMEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PHYSICSFILTERMETADATAENTITYDATA_TYPE_INFO);
    registry.register_type(PHYSICSFILTERMETADATAENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(STARFIGHTERCOLLISIONREPULSORPHYSICSACTIONDATA_TYPE_INFO);
    registry.register_type(STARFIGHTERCOLLISIONREPULSORPHYSICSACTIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(STARFIGHTERSPINOUTPHYSICSACTIONDATA_TYPE_INFO);
    registry.register_type(STARFIGHTERSPINOUTPHYSICSACTIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(HOVERTANKPHYSICSACTIONDATA_TYPE_INFO);
    registry.register_type(HOVERTANKPHYSICSACTIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(HOVERLIFTPHYSICSACTIONDATA_TYPE_INFO);
    registry.register_type(HOVERLIFTPHYSICSACTIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(HOVERLIFTVOLUMECONFIG_TYPE_INFO);
    registry.register_type(HOVERLIFTVOLUMECONFIG_ARRAY_TYPE_INFO);
    registry.register_type(MUTUALREPULSORPHYSICSACTIONDATA_TYPE_INFO);
    registry.register_type(MUTUALREPULSORPHYSICSACTIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(STARFIGHTERPHYSICSACTIONDATA_TYPE_INFO);
    registry.register_type(STARFIGHTERPHYSICSACTIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(STARFIGHTERCONFIGENTITYDATA_TYPE_INFO);
    registry.register_type(STARFIGHTERCONFIGENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SPEEDERBIKEPHYSICSACTIONDATA_TYPE_INFO);
    registry.register_type(SPEEDERBIKEPHYSICSACTIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(REPULSORLIFTPHYSICSACTIONDATA_TYPE_INFO);
    registry.register_type(REPULSORLIFTPHYSICSACTIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(GROUNDFOLLOWPHYSICSACTIONDATA_TYPE_INFO);
    registry.register_type(GROUNDFOLLOWPHYSICSACTIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(RAYPROCESSTYPE_TYPE_INFO);
    registry.register_type(RAYPROCESSTYPE_ARRAY_TYPE_INFO);
    registry.register_type(INPUTREADERACTIONDATA_TYPE_INFO);
    registry.register_type(INPUTREADERACTIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(FLOATSTATEACTIONDATA_TYPE_INFO);
    registry.register_type(FLOATSTATEACTIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(SCRIPTEDMOTIONPHYSICSACTIONDATA_TYPE_INFO);
    registry.register_type(SCRIPTEDMOTIONPHYSICSACTIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(SCRIPTEDMOTIONINPUT_TYPE_INFO);
    registry.register_type(SCRIPTEDMOTIONINPUT_ARRAY_TYPE_INFO);
    registry.register_type(SCRIPTEDMOTIONCOMPARE_TYPE_INFO);
    registry.register_type(SCRIPTEDMOTIONCOMPARE_ARRAY_TYPE_INFO);
    registry.register_type(SCRIPTEDMOTIONDATA_TYPE_INFO);
    registry.register_type(SCRIPTEDMOTIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(HOVERNOISEPHYSICSACTIONDATA_TYPE_INFO);
    registry.register_type(HOVERNOISEPHYSICSACTIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(HOVERNOISEDATA_TYPE_INFO);
    registry.register_type(HOVERNOISEDATA_ARRAY_TYPE_INFO);
    registry.register_type(HOVERNOISETYPE_TYPE_INFO);
    registry.register_type(HOVERNOISETYPE_ARRAY_TYPE_INFO);
    registry.register_type(MOTIONDAMPINGPHYSICSACTIONDATA_TYPE_INFO);
    registry.register_type(MOTIONDAMPINGPHYSICSACTIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(CAMERARELSTEERINGPHYSICSACTIONDATA_TYPE_INFO);
    registry.register_type(CAMERARELSTEERINGPHYSICSACTIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(PROPERTYREADERPHYSICSACTIONDATA_TYPE_INFO);
    registry.register_type(PROPERTYREADERPHYSICSACTIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(FORCEOVERTIMEPHYSICSACTIONDATA_TYPE_INFO);
    registry.register_type(FORCEOVERTIMEPHYSICSACTIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(SPRINGSETPHYSICSACTIONDATA_TYPE_INFO);
    registry.register_type(SPRINGSETPHYSICSACTIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(VELOCITYONINPUTPHYSICSACTIONDATA_TYPE_INFO);
    registry.register_type(VELOCITYONINPUTPHYSICSACTIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(WORLDRELSTEERINGPHYSICSACTIONDATA_TYPE_INFO);
    registry.register_type(WORLDRELSTEERINGPHYSICSACTIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(SIMPLEENGINEPHYSICSACTIONDATA_TYPE_INFO);
    registry.register_type(SIMPLEENGINEPHYSICSACTIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(ROLLONINPUTPHYSICSACTIONDATA_TYPE_INFO);
    registry.register_type(ROLLONINPUTPHYSICSACTIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(ROLLONINPUTDATA_TYPE_INFO);
    registry.register_type(ROLLONINPUTDATA_ARRAY_TYPE_INFO);
    registry.register_type(CONSTRAINTPHYSICSACTIONDATA_TYPE_INFO);
    registry.register_type(CONSTRAINTPHYSICSACTIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANTIGRAVITYPHYSICSACTIONDATA_TYPE_INFO);
    registry.register_type(ANTIGRAVITYPHYSICSACTIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(FORCEPHYSICSACTIONDATA_TYPE_INFO);
    registry.register_type(FORCEPHYSICSACTIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(PHYSICSACTIONBASEDATA_TYPE_INFO);
    registry.register_type(PHYSICSACTIONBASEDATA_ARRAY_TYPE_INFO);
    registry.register_type(PHYSICSACTIONCOLLECTIONCOMPONENTDATA_TYPE_INFO);
    registry.register_type(PHYSICSACTIONCOLLECTIONCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(PHYSICSACTIONSPRINGDATA_TYPE_INFO);
    registry.register_type(PHYSICSACTIONSPRINGDATA_ARRAY_TYPE_INFO);
    registry.register_type(PHYSICSSPACE_TYPE_INFO);
    registry.register_type(PHYSICSSPACE_ARRAY_TYPE_INFO);
    registry.register_type(PHYSICSQUANTITY_TYPE_INFO);
    registry.register_type(PHYSICSQUANTITY_ARRAY_TYPE_INFO);
    registry.register_type(PHYSICSACTIONAXIS_TYPE_INFO);
    registry.register_type(PHYSICSACTIONAXIS_ARRAY_TYPE_INFO);
    registry.register_type(OVERRIDEJOINTENTITYDATA_TYPE_INFO);
    registry.register_type(OVERRIDEJOINTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(OBSTACLEDETECTIONHINTDATA_TYPE_INFO);
    registry.register_type(OBSTACLEDETECTIONHINTDATA_ARRAY_TYPE_INFO);
    registry.register_type(HINTMODETYPE_TYPE_INFO);
    registry.register_type(HINTMODETYPE_ARRAY_TYPE_INFO);
    registry.register_type(OBSTACLEDETECTIONENTITYDATA_TYPE_INFO);
    registry.register_type(OBSTACLEDETECTIONENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOCALPLAYERLODENTITYDATA_TYPE_INFO);
    registry.register_type(LOCALPLAYERLODENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CAMERALODENTITYDATA_TYPE_INFO);
    registry.register_type(CAMERALODENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(LINEARREPULSORLIFTPHYSICSACTIONDATA_TYPE_INFO);
    registry.register_type(LINEARREPULSORLIFTPHYSICSACTIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(ISLOOKEDATTARGETOVERRIDEENTITYDATA_TYPE_INFO);
    registry.register_type(ISLOOKEDATTARGETOVERRIDEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(ISLOOKEDATENTITYDATA_TYPE_INFO);
    registry.register_type(ISLOOKEDATENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATECAMERARELATIVESTEERINGCONTROLLERDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATECAMERARELATIVESTEERINGCONTROLLERDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEROTATEWITHYAWCONTROLLERDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEROTATEWITHYAWCONTROLLERDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEADJUSTTOGROUNDCONTROLLERDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEADJUSTTOGROUNDCONTROLLERDATA_ARRAY_TYPE_INFO);
    registry.register_type(ADJUSTTOGROUNDMODEENUM_TYPE_INFO);
    registry.register_type(ADJUSTTOGROUNDMODEENUM_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEJETPACKCONTROLLERDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEJETPACKCONTROLLERDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEJUMPPACKCONTROLLERDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEJUMPPACKCONTROLLERDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIRCONTROLCAPABLECONTROLLERDATA_TYPE_INFO);
    registry.register_type(AIRCONTROLCAPABLECONTROLLERDATA_ARRAY_TYPE_INFO);
    registry.register_type(DSJETPACKMOVEMENTMODE_TYPE_INFO);
    registry.register_type(DSJETPACKMOVEMENTMODE_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATESLIDINGCONTROLLERDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATESLIDINGCONTROLLERDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEMOVETOTARGETCONTROLLERDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEMOVETOTARGETCONTROLLERDATA_ARRAY_TYPE_INFO);
    registry.register_type(MOVETOCONTROLLERTYPE_TYPE_INFO);
    registry.register_type(MOVETOCONTROLLERTYPE_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATECLIMBINGCONTROLLERDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATECLIMBINGCONTROLLERDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATECHECKSTARTVAULTCONTROLLERDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATECHECKSTARTVAULTCONTROLLERDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATECHECKSTARTCLIMBINGCONTROLLERDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATECHECKSTARTCLIMBINGCONTROLLERDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEPARACHUTECONTROLLERDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEPARACHUTECONTROLLERDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEAPPLYACCELERATIONFROMINPUTCONTROLLERDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEAPPLYACCELERATIONFROMINPUTCONTROLLERDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEAPPLYACCELERATIONFROMINPUTMODIFICATION_TYPE_INFO);
    registry.register_type(CHARACTERSTATEAPPLYACCELERATIONFROMINPUTMODIFICATION_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEMOVEMENTINPUTSCALING_TYPE_INFO);
    registry.register_type(CHARACTERSTATEMOVEMENTINPUTSCALING_ARRAY_TYPE_INFO);
    registry.register_type(HILLMODIFICATION_TYPE_INFO);
    registry.register_type(HILLMODIFICATION_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEIMPULSECONTROLLERDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEIMPULSECONTROLLERDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATECONSTANTVELOCITYCONTROLLERDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATECONSTANTVELOCITYCONTROLLERDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEAPPLYFRICTIONCONTROLLERDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEAPPLYFRICTIONCONTROLLERDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEFALLWITHGRAVITYCONTROLLERDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEFALLWITHGRAVITYCONTROLLERDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEFOLLOWGROUNDCONTROLLERDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEFOLLOWGROUNDCONTROLLERDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATECHECKSUPPORTCONTROLLERDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATECHECKSUPPORTCONTROLLERDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEPOSECONTROLLERDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEPOSECONTROLLERDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEAUTHORITATIVEMOTIONCONTROLLERDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEAUTHORITATIVEMOTIONCONTROLLERDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATENETWORKENDCONTROLLERDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATENETWORKENDCONTROLLERDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEMIRRORCONTROLLERDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEMIRRORCONTROLLERDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATELAYERCONTROLLERDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATELAYERCONTROLLERDATA_ARRAY_TYPE_INFO);
    registry.register_type(LAYERELEMENTINFO_TYPE_INFO);
    registry.register_type(LAYERELEMENTINFO_ARRAY_TYPE_INFO);
    registry.register_type(BLENDMODE_TYPE_INFO);
    registry.register_type(BLENDMODE_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEKEYFRAMEDVEC3CHANNELCONTROLLERDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEKEYFRAMEDVEC3CHANNELCONTROLLERDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEVEC3TRACKDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEVEC3TRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEVEC3TAGDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEVEC3TAGDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEC3KEYFRAMEDATA_TYPE_INFO);
    registry.register_type(VEC3KEYFRAMEDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEKEYFRAMEDTRANSFORMCHANNELCONTROLLERDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEKEYFRAMEDTRANSFORMCHANNELCONTROLLERDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATETRANSFORMTRACKDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATETRANSFORMTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMKEYFRAMEDATA_TYPE_INFO);
    registry.register_type(TRANSFORMKEYFRAMEDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEKEYFRAMEDFLOATCHANNELCONTROLLERDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEKEYFRAMEDFLOATCHANNELCONTROLLERDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEFLOATTRACKDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEFLOATTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEFLOATTAGDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEFLOATTAGDATA_ARRAY_TYPE_INFO);
    registry.register_type(FLOATKEYFRAMEDATA_TYPE_INFO);
    registry.register_type(FLOATKEYFRAMEDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEKEYFRAMEDCHANNELCONTROLLERDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEKEYFRAMEDCHANNELCONTROLLERDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANIMATIONONLYTAGCOLLECTION_TYPE_INFO);
    registry.register_type(ANIMATIONONLYTAGCOLLECTION_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEKEYFRAMEDINTCHANNELCONTROLLERDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEKEYFRAMEDINTCHANNELCONTROLLERDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEINTTRACKDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEINTTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(INTKEYFRAMEDATA_TYPE_INFO);
    registry.register_type(INTKEYFRAMEDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEKEYFRAMEDBOOLCHANNELCONTROLLERDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEKEYFRAMEDBOOLCHANNELCONTROLLERDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEBOOLTRACKDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEBOOLTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(BOOLKEYFRAMEDATA_TYPE_INFO);
    registry.register_type(BOOLKEYFRAMEDATA_ARRAY_TYPE_INFO);
    registry.register_type(TAGMODE_TYPE_INFO);
    registry.register_type(TAGMODE_ARRAY_TYPE_INFO);
    registry.register_type(TAGRESETMODE_TYPE_INFO);
    registry.register_type(TAGRESETMODE_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEINDEXCHOOSERCONTROLLERDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEINDEXCHOOSERCONTROLLERDATA_ARRAY_TYPE_INFO);
    registry.register_type(FLOATCHOOSERDATA_TYPE_INFO);
    registry.register_type(FLOATCHOOSERDATA_ARRAY_TYPE_INFO);
    registry.register_type(RANDOMCHOOSERDATA_TYPE_INFO);
    registry.register_type(RANDOMCHOOSERDATA_ARRAY_TYPE_INFO);
    registry.register_type(SIGNALCHOOSERDATA_TYPE_INFO);
    registry.register_type(SIGNALCHOOSERDATA_ARRAY_TYPE_INFO);
    registry.register_type(CONTEXTDATABASECHOOSERDATA_TYPE_INFO);
    registry.register_type(CONTEXTDATABASECHOOSERDATA_ARRAY_TYPE_INFO);
    registry.register_type(CONTEXTDATABASECHOOSERFLOATDATA_TYPE_INFO);
    registry.register_type(CONTEXTDATABASECHOOSERFLOATDATA_ARRAY_TYPE_INFO);
    registry.register_type(CONTEXTDATABASECHOOSERBITMAPDATA_TYPE_INFO);
    registry.register_type(CONTEXTDATABASECHOOSERBITMAPDATA_ARRAY_TYPE_INFO);
    registry.register_type(CONTEXTDATABASECHOOSERINTDATA_TYPE_INFO);
    registry.register_type(CONTEXTDATABASECHOOSERINTDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEIKCONTROLLERDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEIKCONTROLLERDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATECLIPFROMINPUTCONTROLLERDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATECLIPFROMINPUTCONTROLLERDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEWARPCLIPCONTROLLERDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEWARPCLIPCONTROLLERDATA_ARRAY_TYPE_INFO);
    registry.register_type(WARPCLIPTARGETDATA_TYPE_INFO);
    registry.register_type(WARPCLIPTARGETDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEPHASECONTROLLERDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEPHASECONTROLLERDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATECLIPCONTROLLERDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATECLIPCONTROLLERDATA_ARRAY_TYPE_INFO);
    registry.register_type(CLIPOVERRIDEMAPPING_TYPE_INFO);
    registry.register_type(CLIPOVERRIDEMAPPING_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATECLIPINFO_TYPE_INFO);
    registry.register_type(CHARACTERSTATECLIPINFO_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEHELPERCONTROLLERDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEHELPERCONTROLLERDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANGULARYAWSPEEDOUTPUT_TYPE_INFO);
    registry.register_type(ANGULARYAWSPEEDOUTPUT_ARRAY_TYPE_INFO);
    registry.register_type(POSITIONWITHINANGLE_TYPE_INFO);
    registry.register_type(POSITIONWITHINANGLE_ARRAY_TYPE_INFO);
    registry.register_type(POSITIONWITHINANGLEITEM_TYPE_INFO);
    registry.register_type(POSITIONWITHINANGLEITEM_ARRAY_TYPE_INFO);
    registry.register_type(WITHINANGLEARCITEM_TYPE_INFO);
    registry.register_type(WITHINANGLEARCITEM_ARRAY_TYPE_INFO);
    registry.register_type(VEC3CHANNELRANGEITEM_TYPE_INFO);
    registry.register_type(VEC3CHANNELRANGEITEM_ARRAY_TYPE_INFO);
    registry.register_type(VEC3CHANNELTHRESHOLDITEM_TYPE_INFO);
    registry.register_type(VEC3CHANNELTHRESHOLDITEM_ARRAY_TYPE_INFO);
    registry.register_type(FLOATCHANNELTHRESHOLDITEM_TYPE_INFO);
    registry.register_type(FLOATCHANNELTHRESHOLDITEM_ARRAY_TYPE_INFO);
    registry.register_type(VEC3CHANNELRANGEEXECUTIONMODE_TYPE_INFO);
    registry.register_type(VEC3CHANNELRANGEEXECUTIONMODE_ARRAY_TYPE_INFO);
    registry.register_type(VEC3ITEMMODE_TYPE_INFO);
    registry.register_type(VEC3ITEMMODE_ARRAY_TYPE_INFO);
    registry.register_type(VELOCITYRANGEITEM_TYPE_INFO);
    registry.register_type(VELOCITYRANGEITEM_ARRAY_TYPE_INFO);
    registry.register_type(VELOCITYTHRESHOLDITEM_TYPE_INFO);
    registry.register_type(VELOCITYTHRESHOLDITEM_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATECLIPONLYBLENDSPACECONTROLLERDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATECLIPONLYBLENDSPACECONTROLLERDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEBLENDSPACECONTROLLERDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEBLENDSPACECONTROLLERDATA_ARRAY_TYPE_INFO);
    registry.register_type(BLENDSPACECLIPMODE_TYPE_INFO);
    registry.register_type(BLENDSPACECLIPMODE_ARRAY_TYPE_INFO);
    registry.register_type(VORONOIDIAGRAM_TYPE_INFO);
    registry.register_type(VORONOIDIAGRAM_ARRAY_TYPE_INFO);
    registry.register_type(VORONOIEDGE_TYPE_INFO);
    registry.register_type(VORONOIEDGE_ARRAY_TYPE_INFO);
    registry.register_type(VORONOITRIANGLE_TYPE_INFO);
    registry.register_type(VORONOITRIANGLE_ARRAY_TYPE_INFO);
    registry.register_type(VORONOIGRIDITEM_TYPE_INFO);
    registry.register_type(VORONOIGRIDITEM_ARRAY_TYPE_INFO);
    registry.register_type(VORONOIITEM_TYPE_INFO);
    registry.register_type(VORONOIITEM_ARRAY_TYPE_INFO);
    registry.register_type(VORONOIGRIDMODE_TYPE_INFO);
    registry.register_type(VORONOIGRIDMODE_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEBASECONTROLLERDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEBASECONTROLLERDATA_ARRAY_TYPE_INFO);
    registry.register_type(WATERHITCOMPONENTDATA_TYPE_INFO);
    registry.register_type(WATERHITCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERINDOORSENTITYDATA_TYPE_INFO);
    registry.register_type(SOLDIERINDOORSENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOCALPLAYERNODEDATA_TYPE_INFO);
    registry.register_type(LOCALPLAYERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(DICESHOOTERSURFACEPROPERTYSOUNDDATA_TYPE_INFO);
    registry.register_type(DICESHOOTERSURFACEPROPERTYSOUNDDATA_ARRAY_TYPE_INFO);
    registry.register_type(WHEELSURFACEWAVEDATA_TYPE_INFO);
    registry.register_type(WHEELSURFACEWAVEDATA_ARRAY_TYPE_INFO);
    registry.register_type(DICESHOOTERMATERIALPROPERTYSOUNDDATA_TYPE_INFO);
    registry.register_type(DICESHOOTERMATERIALPROPERTYSOUNDDATA_ARRAY_TYPE_INFO);
    registry.register_type(CLIENTVOICEOVERQUERYEVENTENTITYDATA_TYPE_INFO);
    registry.register_type(CLIENTVOICEOVERQUERYEVENTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CONTROLINPUTENTITYDATA_TYPE_INFO);
    registry.register_type(CONTROLINPUTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(FRIENDZONEENTITYDATA_TYPE_INFO);
    registry.register_type(FRIENDZONEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(ROUNDOVERENTITYDATA_TYPE_INFO);
    registry.register_type(ROUNDOVERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CLIENTROUNDOVERMESSAGE_TYPE_INFO);
    registry.register_type(CLIENTROUNDSTARTEDMESSAGE_TYPE_INFO);
    registry.register_type(KILLCOUNTERENTITYDATA_TYPE_INFO);
    registry.register_type(KILLCOUNTERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(KILLWEIGHT_TYPE_INFO);
    registry.register_type(KILLWEIGHT_ARRAY_TYPE_INFO);
    registry.register_type(DICESHOOTERDAMAGEARBITRATIONSETTINGS_TYPE_INFO);
    registry.register_type(DICESHOOTERDAMAGEARBITRATIONSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(DICESHOOTERDCBPSTMESSAGE_TYPE_INFO);
    registry.register_type(DICESHOOTERDCBTMESSAGE_TYPE_INFO);
    registry.register_type(ENTITYCORRECTIONINTERFACECOMPONENTDATA_TYPE_INFO);
    registry.register_type(ENTITYCORRECTIONINTERFACECOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(REMOTEENTRYCOMPONENTDATA_TYPE_INFO);
    registry.register_type(REMOTEENTRYCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(DICESHOOTERVEHICLEENTRYCOMPONENTDATA_TYPE_INFO);
    registry.register_type(DICESHOOTERVEHICLEENTRYCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(SHIELDPHYSICSCOMPONENTDATA_TYPE_INFO);
    registry.register_type(SHIELDPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(SHIELDHEALTHCOMPONENTDATA_TYPE_INFO);
    registry.register_type(SHIELDHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(SHIELDCOMPONENTDATA_TYPE_INFO);
    registry.register_type(SHIELDCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(SHIELDCONTROLLERCOMPONENTDATA_TYPE_INFO);
    registry.register_type(SHIELDCONTROLLERCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(SHIELDSTATECOMPONENTDATA_TYPE_INFO);
    registry.register_type(SHIELDSTATECOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(SHIELDCONTROLLERCOMPONENTCONSTANTS_TYPE_INFO);
    registry.register_type(SHIELDCONTROLLERCOMPONENTCONSTANTS_ARRAY_TYPE_INFO);
    registry.register_type(SHIELDINTERCEPTEDTYPE_TYPE_INFO);
    registry.register_type(SHIELDINTERCEPTEDTYPE_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONATTACHWITHFOVSCALEDATA_TYPE_INFO);
    registry.register_type(WEAPONATTACHWITHFOVSCALEDATA_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONATTACHDATA_TYPE_INFO);
    registry.register_type(WEAPONATTACHDATA_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONTRANSFORMLINKDATA_TYPE_INFO);
    registry.register_type(WEAPONTRANSFORMLINKDATA_ARRAY_TYPE_INFO);
    registry.register_type(DICETELEMETRYSETTINGS_TYPE_INFO);
    registry.register_type(DICETELEMETRYSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(VIEWQUERYENTITYDATA_TYPE_INFO);
    registry.register_type(VIEWQUERYENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMQUERYENTITYDATA_TYPE_INFO);
    registry.register_type(TRANSFORMQUERYENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMQUERYTYPE_TYPE_INFO);
    registry.register_type(TRANSFORMQUERYTYPE_ARRAY_TYPE_INFO);
    registry.register_type(TERRAINRAYCASTENTITYDATA_TYPE_INFO);
    registry.register_type(TERRAINRAYCASTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SPHEREQUERYENTITYDATA_TYPE_INFO);
    registry.register_type(SPHEREQUERYENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SPHEREQUERYDEBUGDATA_TYPE_INFO);
    registry.register_type(SPHEREQUERYDEBUGDATA_ARRAY_TYPE_INFO);
    registry.register_type(REMOTESTATEQUERYFILTERENTITYDATA_TYPE_INFO);
    registry.register_type(REMOTESTATEQUERYFILTERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(REMOTESTATEWRITEENTITYDATA_TYPE_INFO);
    registry.register_type(REMOTESTATEWRITEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(REMOTESTATEREADENTITYDATA_TYPE_INFO);
    registry.register_type(REMOTESTATEREADENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(REMOTESTATEENTITYDATA_TYPE_INFO);
    registry.register_type(REMOTESTATEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SIMPLESTATEWRITEENTITYDATA_TYPE_INFO);
    registry.register_type(SIMPLESTATEWRITEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SIMPLESTATEREADENTITYDATA_TYPE_INFO);
    registry.register_type(SIMPLESTATEREADENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SIMPLESTATEENTITYDATA_TYPE_INFO);
    registry.register_type(SIMPLESTATEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SIMPLESTATEENTITYBASEDATA_TYPE_INFO);
    registry.register_type(SIMPLESTATEENTITYBASEDATA_ARRAY_TYPE_INFO);
    registry.register_type(WRITESIMPLEFLOATSTATEDATA_TYPE_INFO);
    registry.register_type(WRITESIMPLEFLOATSTATEDATA_ARRAY_TYPE_INFO);
    registry.register_type(WRITESIMPLEINTSTATEDATA_TYPE_INFO);
    registry.register_type(WRITESIMPLEINTSTATEDATA_ARRAY_TYPE_INFO);
    registry.register_type(WRITESIMPLETRANSFORMSTATEDATA_TYPE_INFO);
    registry.register_type(WRITESIMPLETRANSFORMSTATEDATA_ARRAY_TYPE_INFO);
    registry.register_type(WRITESIMPLEBOOLSTATEDATA_TYPE_INFO);
    registry.register_type(WRITESIMPLEBOOLSTATEDATA_ARRAY_TYPE_INFO);
    registry.register_type(WRITESIMPLESTATEDATA_TYPE_INFO);
    registry.register_type(WRITESIMPLESTATEDATA_ARRAY_TYPE_INFO);
    registry.register_type(SIMPLEEVENTSTATEDATA_TYPE_INFO);
    registry.register_type(SIMPLEEVENTSTATEDATA_ARRAY_TYPE_INFO);
    registry.register_type(SIMPLEVEC3STATEDATA_TYPE_INFO);
    registry.register_type(SIMPLEVEC3STATEDATA_ARRAY_TYPE_INFO);
    registry.register_type(SIMPLEFLOATSTATEDATA_TYPE_INFO);
    registry.register_type(SIMPLEFLOATSTATEDATA_ARRAY_TYPE_INFO);
    registry.register_type(SIMPLEINTSTATEDATA_TYPE_INFO);
    registry.register_type(SIMPLEINTSTATEDATA_ARRAY_TYPE_INFO);
    registry.register_type(SIMPLETRANSFORMSTATEDATA_TYPE_INFO);
    registry.register_type(SIMPLETRANSFORMSTATEDATA_ARRAY_TYPE_INFO);
    registry.register_type(SIMPLEBOOLSTATEDATA_TYPE_INFO);
    registry.register_type(SIMPLEBOOLSTATEDATA_ARRAY_TYPE_INFO);
    registry.register_type(SIMPLESTATEDATA_TYPE_INFO);
    registry.register_type(SIMPLESTATEDATA_ARRAY_TYPE_INFO);
    registry.register_type(SIMPLESTATEACCESSMODE_TYPE_INFO);
    registry.register_type(SIMPLESTATEACCESSMODE_ARRAY_TYPE_INFO);
    registry.register_type(SETTHEORYQUERYENTITYDATA_TYPE_INFO);
    registry.register_type(SETTHEORYQUERYENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SETTHEORYOPERATION_TYPE_INFO);
    registry.register_type(SETTHEORYOPERATION_ARRAY_TYPE_INFO);
    registry.register_type(RAYCASTENTITYDATA_TYPE_INFO);
    registry.register_type(RAYCASTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(RAYCASTENTITYRESULT_TYPE_INFO);
    registry.register_type(RAYCASTENTITYRESULT_ARRAY_TYPE_INFO);
    registry.register_type(QUERYSPLITTERENTITYDATA_TYPE_INFO);
    registry.register_type(QUERYSPLITTERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(QUERYRESULTBUFFERENTITYDATA_TYPE_INFO);
    registry.register_type(QUERYRESULTBUFFERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(QUERYENTITYFILTER_TYPE_INFO);
    registry.register_type(QUERYENTITYFILTER_ARRAY_TYPE_INFO);
    registry.register_type(QUERYENTITYRESULT_TYPE_INFO);
    registry.register_type(QUERYENTITYRESULT_ARRAY_TYPE_INFO);
    registry.register_type(DYNAMICQUERYFILTERENTITYDATA_TYPE_INFO);
    registry.register_type(DYNAMICQUERYFILTERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(LATERALDISTANCEQUERYFILTER_TYPE_INFO);
    registry.register_type(LATERALDISTANCEQUERYFILTER_ARRAY_TYPE_INFO);
    registry.register_type(HEIGHTDIFFERENCEQUERYFILTER_TYPE_INFO);
    registry.register_type(HEIGHTDIFFERENCEQUERYFILTER_ARRAY_TYPE_INFO);
    registry.register_type(MAXRESULTSQUERYFILTER_TYPE_INFO);
    registry.register_type(MAXRESULTSQUERYFILTER_ARRAY_TYPE_INFO);
    registry.register_type(ANGLEMULTIPLIERQUERYFILTER_TYPE_INFO);
    registry.register_type(ANGLEMULTIPLIERQUERYFILTER_ARRAY_TYPE_INFO);
    registry.register_type(DISTANCEMULTIPLIERQUERYFILTER_TYPE_INFO);
    registry.register_type(DISTANCEMULTIPLIERQUERYFILTER_ARRAY_TYPE_INFO);
    registry.register_type(ANGLEQUERYFILTER_TYPE_INFO);
    registry.register_type(ANGLEQUERYFILTER_ARRAY_TYPE_INFO);
    registry.register_type(DISTANCEQUERYFILTER_TYPE_INFO);
    registry.register_type(DISTANCEQUERYFILTER_ARRAY_TYPE_INFO);
    registry.register_type(FACINGQUERYFILTER_TYPE_INFO);
    registry.register_type(FACINGQUERYFILTER_ARRAY_TYPE_INFO);
    registry.register_type(BASICQUERYFILTER_TYPE_INFO);
    registry.register_type(BASICQUERYFILTER_ARRAY_TYPE_INFO);
    registry.register_type(LOSQUERYFILTER_TYPE_INFO);
    registry.register_type(LOSQUERYFILTER_ARRAY_TYPE_INFO);
    registry.register_type(QUERYFILTER_TYPE_INFO);
    registry.register_type(QUERYFILTER_ARRAY_TYPE_INFO);
    registry.register_type(QUERYFILTERENTITYDATA_TYPE_INFO);
    registry.register_type(QUERYFILTERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(QUERYFILTERENTITYINPUTDATA_TYPE_INFO);
    registry.register_type(QUERYFILTERENTITYINPUTDATA_ARRAY_TYPE_INFO);
    registry.register_type(SORTOUTPUTMODETYPE_TYPE_INFO);
    registry.register_type(SORTOUTPUTMODETYPE_ARRAY_TYPE_INFO);
    registry.register_type(FILTEROUTDISTANCETYPE_TYPE_INFO);
    registry.register_type(FILTEROUTDISTANCETYPE_ARRAY_TYPE_INFO);
    registry.register_type(QUERYENTITYFILTERTYPEDATA_TYPE_INFO);
    registry.register_type(QUERYENTITYFILTERTYPEDATA_ARRAY_TYPE_INFO);
    registry.register_type(QUERYCACHEENTITYDATA_TYPE_INFO);
    registry.register_type(QUERYCACHEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(QUERYCACHEENTITYINPUTDATA_TYPE_INFO);
    registry.register_type(QUERYCACHEENTITYINPUTDATA_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERSQUERYENTITYDATA_TYPE_INFO);
    registry.register_type(PLAYERSQUERYENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERSQUERYENTITYINPUTDATA_TYPE_INFO);
    registry.register_type(PLAYERSQUERYENTITYINPUTDATA_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERSINSIDEENTITYDATA_TYPE_INFO);
    registry.register_type(PLAYERSINSIDEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERSINSIDEENTITY_TEAMINFO_TYPE_INFO);
    registry.register_type(PLAYERSINSIDEENTITY_TEAMINFO_ARRAY_TYPE_INFO);
    registry.register_type(PHANTOMENTITYDATA_TYPE_INFO);
    registry.register_type(PHANTOMENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(MATERIALOFFSET_TYPE_INFO);
    registry.register_type(MATERIALOFFSET_ARRAY_TYPE_INFO);
    registry.register_type(OWNERTOQUERYRESULTENTITYDATA_TYPE_INFO);
    registry.register_type(OWNERTOQUERYRESULTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(JOINTTRANSFORMQUERYENTITYDATA_TYPE_INFO);
    registry.register_type(JOINTTRANSFORMQUERYENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(INPUTQUERYENTITYDATA_TYPE_INFO);
    registry.register_type(INPUTQUERYENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(GAMEPLAYQUERYBASEENTITYDATA_TYPE_INFO);
    registry.register_type(GAMEPLAYQUERYBASEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(FIREPROJECTILEENTITYDATA_TYPE_INFO);
    registry.register_type(FIREPROJECTILEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(FIREPROJECTILEENTITYOVERRIDEDATA_TYPE_INFO);
    registry.register_type(FIREPROJECTILEENTITYOVERRIDEDATA_ARRAY_TYPE_INFO);
    registry.register_type(FIREPROJECTILEENTITYPARAMETERS_TYPE_INFO);
    registry.register_type(FIREPROJECTILEENTITYPARAMETERS_ARRAY_TYPE_INFO);
    registry.register_type(DEALDAMAGEENTITYDATA_TYPE_INFO);
    registry.register_type(DEALDAMAGEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(DEALDAMAGEENTITYPARAMETERS_TYPE_INFO);
    registry.register_type(DEALDAMAGEENTITYPARAMETERS_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERABILITYWEAPONUPGRADESLOTMODIFIER_TYPE_INFO);
    registry.register_type(PLAYERABILITYWEAPONUPGRADESLOTMODIFIER_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERWEAPONUPGRADESLOTMODIFIERVALUE_TYPE_INFO);
    registry.register_type(SOLDIERWEAPONUPGRADESLOTMODIFIERVALUE_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERABILITYREFERENCEDATA_TYPE_INFO);
    registry.register_type(PLAYERABILITYREFERENCEDATA_ARRAY_TYPE_INFO);
    registry.register_type(CLIENTAUDIOVEHICLEENGINEPARAMETERSENTITYDATA_TYPE_INFO);
    registry.register_type(CLIENTAUDIOVEHICLEENGINEPARAMETERSENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AUDIOWHEELLOGICENTITYDATA_TYPE_INFO);
    registry.register_type(AUDIOWHEELLOGICENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AUDIORAYCASTINFOENTITYDATA_TYPE_INFO);
    registry.register_type(AUDIORAYCASTINFOENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AUDIORAYCASTCALCULATIONENTITYDATA_TYPE_INFO);
    registry.register_type(AUDIORAYCASTCALCULATIONENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(RAYHITMATERIALS_TYPE_INFO);
    registry.register_type(RAYHITMATERIALS_ARRAY_TYPE_INFO);
    registry.register_type(RAYCALCULATIONPROPERTIES_TYPE_INFO);
    registry.register_type(RAYCALCULATIONPROPERTIES_ARRAY_TYPE_INFO);
    registry.register_type(INFORMANIMATIONOFPHYSICSSTATEENTITYDATA_TYPE_INFO);
    registry.register_type(INFORMANIMATIONOFPHYSICSSTATEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(INFORMANIMATIONOFPHYSICSCOMMONBINDING_TYPE_INFO);
    registry.register_type(INFORMANIMATIONOFPHYSICSCOMMONBINDING_ARRAY_TYPE_INFO);
    registry.register_type(INFORMANIMATIONOFPHYSICSPERANIMATABLEBINDING_TYPE_INFO);
    registry.register_type(INFORMANIMATIONOFPHYSICSPERANIMATABLEBINDING_ARRAY_TYPE_INFO);
    registry.register_type(AIMINGCONSTRAINTENTITYDATA_TYPE_INFO);
    registry.register_type(AIMINGCONSTRAINTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AFFECTORVARIABLE_TYPE_INFO);
    registry.register_type(AFFECTORVARIABLE_ARRAY_TYPE_INFO);
    registry.register_type(AFFECTORSTREAMENTITYDATA_TYPE_INFO);
    registry.register_type(AFFECTORSTREAMENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AFFECTORRECEIVEENTITYDATA_TYPE_INFO);
    registry.register_type(AFFECTORRECEIVEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AFFECTORRECEIVETYPE_TYPE_INFO);
    registry.register_type(AFFECTORRECEIVETYPE_ARRAY_TYPE_INFO);
    registry.register_type(AFFECTORQUERYFILTERENTITYDATA_TYPE_INFO);
    registry.register_type(AFFECTORQUERYFILTERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AFFECTORLIMITS_TYPE_INFO);
    registry.register_type(AFFECTORLIMITS_ARRAY_TYPE_INFO);
    registry.register_type(AFFECTORAPPLIEDMESSAGE_TYPE_INFO);
    registry.register_type(ABILITYINPUTMAPPINGAFFECTORASSET_TYPE_INFO);
    registry.register_type(ABILITYINPUTMAPPINGAFFECTORASSET_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEAFFECTORASSET_TYPE_INFO);
    registry.register_type(CHARACTERSTATEAFFECTORASSET_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSTATEAFFECTORDATA_TYPE_INFO);
    registry.register_type(CHARACTERSTATEAFFECTORDATA_ARRAY_TYPE_INFO);
    registry.register_type(AFFECTORIMMUNITYAFFECTORASSET_TYPE_INFO);
    registry.register_type(AFFECTORIMMUNITYAFFECTORASSET_ARRAY_TYPE_INFO);
    registry.register_type(AFFECTORIMMUNITYAFFECTORDATA_TYPE_INFO);
    registry.register_type(AFFECTORIMMUNITYAFFECTORDATA_ARRAY_TYPE_INFO);
    registry.register_type(REMOVEAFFECTORASSET_TYPE_INFO);
    registry.register_type(REMOVEAFFECTORASSET_ARRAY_TYPE_INFO);
    registry.register_type(REMOVEAFFECTORDATA_TYPE_INFO);
    registry.register_type(REMOVEAFFECTORDATA_ARRAY_TYPE_INFO);
    registry.register_type(BASICAFFECTORASSET_TYPE_INFO);
    registry.register_type(BASICAFFECTORASSET_ARRAY_TYPE_INFO);
    registry.register_type(VARIABLEAFFECTORASSET_TYPE_INFO);
    registry.register_type(VARIABLEAFFECTORASSET_ARRAY_TYPE_INFO);
    registry.register_type(AFFECTORASSET_TYPE_INFO);
    registry.register_type(AFFECTORASSET_ARRAY_TYPE_INFO);
    registry.register_type(AFFECTORSTACKINGPOLICY_TYPE_INFO);
    registry.register_type(AFFECTORSTACKINGPOLICY_ARRAY_TYPE_INFO);
    registry.register_type(AFFECTORCONSTANTS_TYPE_INFO);
    registry.register_type(AFFECTORCONSTANTS_ARRAY_TYPE_INFO);
    registry.register_type(AFFECTORCOMPONENTDATA_TYPE_INFO);
    registry.register_type(AFFECTORCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(AFFECTORAPPLYENTITYDATA_TYPE_INFO);
    registry.register_type(AFFECTORAPPLYENTITYDATA_ARRAY_TYPE_INFO);
}

#[derive(Clone, Debug, Default)]
pub struct MultiBodyPhysicsComponentData {
    pub _glacier_base: super::game_shared::VehiclePhysicsComponentData,
    pub bind_pose: Vec<super::core::LinearTransform>,
    pub inverse_bind_pose: Vec<super::core::LinearTransform>,
    pub input_transform_field_hashes: Vec<i32>,
    pub exclude_from_loco_raycast_body_index: Vec<i32>,
    pub exclude_from_shoot_raycast_body_index: Vec<i32>,
}

pub trait MultiBodyPhysicsComponentDataTrait: super::game_shared::VehiclePhysicsComponentDataTrait {
    fn bind_pose(&self) -> &Vec<super::core::LinearTransform>;
    fn inverse_bind_pose(&self) -> &Vec<super::core::LinearTransform>;
    fn input_transform_field_hashes(&self) -> &Vec<i32>;
    fn exclude_from_loco_raycast_body_index(&self) -> &Vec<i32>;
    fn exclude_from_shoot_raycast_body_index(&self) -> &Vec<i32>;
}

impl MultiBodyPhysicsComponentDataTrait for MultiBodyPhysicsComponentData {
    fn bind_pose(&self) -> &Vec<super::core::LinearTransform> {
        &self.bind_pose
    }
    fn inverse_bind_pose(&self) -> &Vec<super::core::LinearTransform> {
        &self.inverse_bind_pose
    }
    fn input_transform_field_hashes(&self) -> &Vec<i32> {
        &self.input_transform_field_hashes
    }
    fn exclude_from_loco_raycast_body_index(&self) -> &Vec<i32> {
        &self.exclude_from_loco_raycast_body_index
    }
    fn exclude_from_shoot_raycast_body_index(&self) -> &Vec<i32> {
        &self.exclude_from_shoot_raycast_body_index
    }
}

impl super::game_shared::VehiclePhysicsComponentDataTrait for MultiBodyPhysicsComponentData {
    fn vehicle_physics_action(&self) -> &Option<Arc<Mutex<dyn super::physics::VehiclePhysicsActionDataTrait>>> {
        self._glacier_base.vehicle_physics_action()
    }
    fn proximity_tracker_data(&self) -> &Option<Arc<Mutex<dyn super::physics::ProximityTrackerDataTrait>>> {
        self._glacier_base.proximity_tracker_data()
    }
}

impl super::gameplay_sim::ControllablePhysicsComponentDataTrait for MultiBodyPhysicsComponentData {
}

impl super::gameplay_sim::GamePhysicsComponentDataTrait for MultiBodyPhysicsComponentData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn effect_parameters(&self) -> &Vec<Option<Arc<Mutex<dyn super::effect_base::EffectParameterTrait>>>> {
        self._glacier_base.effect_parameters()
    }
}

impl super::physics::PhysicsComponentDataTrait for MultiBodyPhysicsComponentData {
    fn physics_bodies(&self) -> &Vec<Option<Arc<Mutex<dyn super::physics::PhysicsBodyDataTrait>>>> {
        self._glacier_base.physics_bodies()
    }
    fn physics_constraints(&self) -> &Vec<Option<Arc<Mutex<dyn super::physics::PhysicsConstraintDataTrait>>>> {
        self._glacier_base.physics_constraints()
    }
    fn parts(&self) -> &Vec<super::physics::PhysicsPartData> {
        self._glacier_base.parts()
    }
    fn movable_parts(&self) -> &bool {
        self._glacier_base.movable_parts()
    }
    fn internal_collision_disabling(&self) -> &super::physics::InternalCollisionDisablingBehavior {
        self._glacier_base.internal_collision_disabling()
    }
    fn enable_collision_events(&self) -> &bool {
        self._glacier_base.enable_collision_events()
    }
}

impl super::entity::ComponentDataTrait for MultiBodyPhysicsComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
}

impl super::entity::GameObjectDataTrait for MultiBodyPhysicsComponentData {
}

impl super::core::DataBusPeerTrait for MultiBodyPhysicsComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for MultiBodyPhysicsComponentData {
}

impl super::core::DataContainerTrait for MultiBodyPhysicsComponentData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static MULTIBODYPHYSICSCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultiBodyPhysicsComponentData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::game_shared::VEHICLEPHYSICSCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MultiBodyPhysicsComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "BindPose",
                flags: MemberInfoFlags::new(144),
                field_type: "LinearTransform-Array",
                rust_offset: offset_of!(MultiBodyPhysicsComponentData, bind_pose),
            },
            FieldInfoData {
                name: "InverseBindPose",
                flags: MemberInfoFlags::new(144),
                field_type: "LinearTransform-Array",
                rust_offset: offset_of!(MultiBodyPhysicsComponentData, inverse_bind_pose),
            },
            FieldInfoData {
                name: "InputTransformFieldHashes",
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(MultiBodyPhysicsComponentData, input_transform_field_hashes),
            },
            FieldInfoData {
                name: "ExcludeFromLocoRaycastBodyIndex",
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(MultiBodyPhysicsComponentData, exclude_from_loco_raycast_body_index),
            },
            FieldInfoData {
                name: "ExcludeFromShootRaycastBodyIndex",
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(MultiBodyPhysicsComponentData, exclude_from_shoot_raycast_body_index),
            },
        ],
    }),
    array_type: Some(MULTIBODYPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for MultiBodyPhysicsComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        MULTIBODYPHYSICSCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static MULTIBODYPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultiBodyPhysicsComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("MultiBodyPhysicsComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PhysicsBodyWrapping {
    pub physics_body: String,
}

pub trait PhysicsBodyWrappingTrait: TypeObject {
    fn physics_body(&self) -> &String;
}

impl PhysicsBodyWrappingTrait for PhysicsBodyWrapping {
    fn physics_body(&self) -> &String {
        &self.physics_body
    }
}

pub static PHYSICSBODYWRAPPING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsBodyWrapping",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PhysicsBodyWrapping as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PhysicsBody",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(PhysicsBodyWrapping, physics_body),
            },
        ],
    }),
    array_type: Some(PHYSICSBODYWRAPPING_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PhysicsBodyWrapping {
    fn type_info(&self) -> &'static TypeInfo {
        PHYSICSBODYWRAPPING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PHYSICSBODYWRAPPING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsBodyWrapping-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PhysicsBodyWrapping"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PhysicsBoneMapping {
    pub physics_body: String,
    pub skeleton_joint: String,
}

pub trait PhysicsBoneMappingTrait: TypeObject {
    fn physics_body(&self) -> &String;
    fn skeleton_joint(&self) -> &String;
}

impl PhysicsBoneMappingTrait for PhysicsBoneMapping {
    fn physics_body(&self) -> &String {
        &self.physics_body
    }
    fn skeleton_joint(&self) -> &String {
        &self.skeleton_joint
    }
}

pub static PHYSICSBONEMAPPING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsBoneMapping",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PhysicsBoneMapping as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PhysicsBody",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(PhysicsBoneMapping, physics_body),
            },
            FieldInfoData {
                name: "SkeletonJoint",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(PhysicsBoneMapping, skeleton_joint),
            },
        ],
    }),
    array_type: Some(PHYSICSBONEMAPPING_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PhysicsBoneMapping {
    fn type_info(&self) -> &'static TypeInfo {
        PHYSICSBONEMAPPING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PHYSICSBONEMAPPING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsBoneMapping-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PhysicsBoneMapping"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MountHealthComponentData {
    pub _glacier_base: super::gameplay_sim::ControllableHealthComponentData,
    pub max_health: f32,
    pub damage_multiplier: f32,
    pub max_health_multiplier: f32,
    pub mount_material: super::entity::MaterialDecl,
    pub fall_damage_threshold: f32,
    pub fall_damage_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
    pub horizontal_damage_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
}

pub trait MountHealthComponentDataTrait: super::gameplay_sim::ControllableHealthComponentDataTrait {
    fn max_health(&self) -> &f32;
    fn damage_multiplier(&self) -> &f32;
    fn max_health_multiplier(&self) -> &f32;
    fn mount_material(&self) -> &super::entity::MaterialDecl;
    fn fall_damage_threshold(&self) -> &f32;
    fn fall_damage_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn horizontal_damage_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
}

impl MountHealthComponentDataTrait for MountHealthComponentData {
    fn max_health(&self) -> &f32 {
        &self.max_health
    }
    fn damage_multiplier(&self) -> &f32 {
        &self.damage_multiplier
    }
    fn max_health_multiplier(&self) -> &f32 {
        &self.max_health_multiplier
    }
    fn mount_material(&self) -> &super::entity::MaterialDecl {
        &self.mount_material
    }
    fn fall_damage_threshold(&self) -> &f32 {
        &self.fall_damage_threshold
    }
    fn fall_damage_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.fall_damage_curve
    }
    fn horizontal_damage_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.horizontal_damage_curve
    }
}

impl super::gameplay_sim::ControllableHealthComponentDataTrait for MountHealthComponentData {
}

impl super::gameplay_sim::GameHealthComponentDataTrait for MountHealthComponentData {
}

impl super::gameplay_sim::HealthComponentDataTrait for MountHealthComponentData {
}

impl super::entity::ComponentDataTrait for MountHealthComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
}

impl super::entity::GameObjectDataTrait for MountHealthComponentData {
}

impl super::core::DataBusPeerTrait for MountHealthComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for MountHealthComponentData {
}

impl super::core::DataContainerTrait for MountHealthComponentData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static MOUNTHEALTHCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MountHealthComponentData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::CONTROLLABLEHEALTHCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MountHealthComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MaxHealth",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MountHealthComponentData, max_health),
            },
            FieldInfoData {
                name: "DamageMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MountHealthComponentData, damage_multiplier),
            },
            FieldInfoData {
                name: "MaxHealthMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MountHealthComponentData, max_health_multiplier),
            },
            FieldInfoData {
                name: "MountMaterial",
                flags: MemberInfoFlags::new(0),
                field_type: "MaterialDecl",
                rust_offset: offset_of!(MountHealthComponentData, mount_material),
            },
            FieldInfoData {
                name: "FallDamageThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MountHealthComponentData, fall_damage_threshold),
            },
            FieldInfoData {
                name: "FallDamageCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(MountHealthComponentData, fall_damage_curve),
            },
            FieldInfoData {
                name: "HorizontalDamageCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(MountHealthComponentData, horizontal_damage_curve),
            },
        ],
    }),
    array_type: Some(MOUNTHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for MountHealthComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        MOUNTHEALTHCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static MOUNTHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MountHealthComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("MountHealthComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EntityReplicationNetState {
    pub identifier: glacier_util::guid::Guid,
}

pub trait EntityReplicationNetStateTrait: TypeObject {
    fn identifier(&self) -> &glacier_util::guid::Guid;
}

impl EntityReplicationNetStateTrait for EntityReplicationNetState {
    fn identifier(&self) -> &glacier_util::guid::Guid {
        &self.identifier
    }
}

pub static ENTITYREPLICATIONNETSTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityReplicationNetState",
    flags: MemberInfoFlags::new(36937),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EntityReplicationNetState as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Identifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Guid",
                rust_offset: offset_of!(EntityReplicationNetState, identifier),
            },
        ],
    }),
    array_type: Some(ENTITYREPLICATIONNETSTATE_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for EntityReplicationNetState {
    fn type_info(&self) -> &'static TypeInfo {
        ENTITYREPLICATIONNETSTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ENTITYREPLICATIONNETSTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityReplicationNetState-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("EntityReplicationNetState"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EntityReplicationEvent {
    pub value: u8,
}

pub trait EntityReplicationEventTrait: TypeObject {
    fn value(&self) -> &u8;
}

impl EntityReplicationEventTrait for EntityReplicationEvent {
    fn value(&self) -> &u8 {
        &self.value
    }
}

pub static ENTITYREPLICATIONEVENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityReplicationEvent",
    flags: MemberInfoFlags::new(36937),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EntityReplicationEvent as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(EntityReplicationEvent, value),
            },
        ],
    }),
    array_type: Some(ENTITYREPLICATIONEVENT_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for EntityReplicationEvent {
    fn type_info(&self) -> &'static TypeInfo {
        ENTITYREPLICATIONEVENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ENTITYREPLICATIONEVENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityReplicationEvent-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("EntityReplicationEvent"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EntityReplicationInt {
    pub value: i32,
}

pub trait EntityReplicationIntTrait: TypeObject {
    fn value(&self) -> &i32;
}

impl EntityReplicationIntTrait for EntityReplicationInt {
    fn value(&self) -> &i32 {
        &self.value
    }
}

pub static ENTITYREPLICATIONINT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityReplicationInt",
    flags: MemberInfoFlags::new(36937),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EntityReplicationInt as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(EntityReplicationInt, value),
            },
        ],
    }),
    array_type: Some(ENTITYREPLICATIONINT_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for EntityReplicationInt {
    fn type_info(&self) -> &'static TypeInfo {
        ENTITYREPLICATIONINT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ENTITYREPLICATIONINT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityReplicationInt-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("EntityReplicationInt"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EntityReplicationFloat {
    pub value: f32,
}

pub trait EntityReplicationFloatTrait: TypeObject {
    fn value(&self) -> &f32;
}

impl EntityReplicationFloatTrait for EntityReplicationFloat {
    fn value(&self) -> &f32 {
        &self.value
    }
}

pub static ENTITYREPLICATIONFLOAT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityReplicationFloat",
    flags: MemberInfoFlags::new(36937),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EntityReplicationFloat as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EntityReplicationFloat, value),
            },
        ],
    }),
    array_type: Some(ENTITYREPLICATIONFLOAT_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for EntityReplicationFloat {
    fn type_info(&self) -> &'static TypeInfo {
        ENTITYREPLICATIONFLOAT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ENTITYREPLICATIONFLOAT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityReplicationFloat-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("EntityReplicationFloat"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EntityReplicationBool {
    pub value: bool,
}

pub trait EntityReplicationBoolTrait: TypeObject {
    fn value(&self) -> &bool;
}

impl EntityReplicationBoolTrait for EntityReplicationBool {
    fn value(&self) -> &bool {
        &self.value
    }
}

pub static ENTITYREPLICATIONBOOL_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityReplicationBool",
    flags: MemberInfoFlags::new(36937),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EntityReplicationBool as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EntityReplicationBool, value),
            },
        ],
    }),
    array_type: Some(ENTITYREPLICATIONBOOL_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for EntityReplicationBool {
    fn type_info(&self) -> &'static TypeInfo {
        ENTITYREPLICATIONBOOL_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ENTITYREPLICATIONBOOL_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityReplicationBool-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("EntityReplicationBool"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EntityReplicationInterfaceComponentData {
    pub _glacier_base: super::entity::GameComponentData,
}

pub trait EntityReplicationInterfaceComponentDataTrait: super::entity::GameComponentDataTrait {
}

impl EntityReplicationInterfaceComponentDataTrait for EntityReplicationInterfaceComponentData {
}

impl super::entity::GameComponentDataTrait for EntityReplicationInterfaceComponentData {
}

impl super::entity::ComponentDataTrait for EntityReplicationInterfaceComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
}

impl super::entity::GameObjectDataTrait for EntityReplicationInterfaceComponentData {
}

impl super::core::DataBusPeerTrait for EntityReplicationInterfaceComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for EntityReplicationInterfaceComponentData {
}

impl super::core::DataContainerTrait for EntityReplicationInterfaceComponentData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static ENTITYREPLICATIONINTERFACECOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityReplicationInterfaceComponentData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EntityReplicationInterfaceComponentData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(ENTITYREPLICATIONINTERFACECOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for EntityReplicationInterfaceComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        ENTITYREPLICATIONINTERFACECOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ENTITYREPLICATIONINTERFACECOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityReplicationInterfaceComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("EntityReplicationInterfaceComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LogicAwarenessTargetEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub target_info: AwarenessTargetInfo,
    pub activate_target: bool,
    pub local_offset: super::core::Vec3,
}

pub trait LogicAwarenessTargetEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn target_info(&self) -> &AwarenessTargetInfo;
    fn activate_target(&self) -> &bool;
    fn local_offset(&self) -> &super::core::Vec3;
}

impl LogicAwarenessTargetEntityDataTrait for LogicAwarenessTargetEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn target_info(&self) -> &AwarenessTargetInfo {
        &self.target_info
    }
    fn activate_target(&self) -> &bool {
        &self.activate_target
    }
    fn local_offset(&self) -> &super::core::Vec3 {
        &self.local_offset
    }
}

impl super::entity::EntityDataTrait for LogicAwarenessTargetEntityData {
}

impl super::entity::GameObjectDataTrait for LogicAwarenessTargetEntityData {
}

impl super::core::DataBusPeerTrait for LogicAwarenessTargetEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for LogicAwarenessTargetEntityData {
}

impl super::core::DataContainerTrait for LogicAwarenessTargetEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static LOGICAWARENESSTARGETENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LogicAwarenessTargetEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LogicAwarenessTargetEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(LogicAwarenessTargetEntityData, realm),
            },
            FieldInfoData {
                name: "TargetInfo",
                flags: MemberInfoFlags::new(0),
                field_type: "AwarenessTargetInfo",
                rust_offset: offset_of!(LogicAwarenessTargetEntityData, target_info),
            },
            FieldInfoData {
                name: "ActivateTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LogicAwarenessTargetEntityData, activate_target),
            },
            FieldInfoData {
                name: "LocalOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(LogicAwarenessTargetEntityData, local_offset),
            },
        ],
    }),
    array_type: Some(LOGICAWARENESSTARGETENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for LogicAwarenessTargetEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        LOGICAWARENESSTARGETENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static LOGICAWARENESSTARGETENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LogicAwarenessTargetEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("LogicAwarenessTargetEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AwarenessTargetEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub realm: super::core::Realm,
    pub target_info: AwarenessTargetInfo,
    pub activate_target: bool,
}

pub trait AwarenessTargetEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn target_info(&self) -> &AwarenessTargetInfo;
    fn activate_target(&self) -> &bool;
}

impl AwarenessTargetEntityDataTrait for AwarenessTargetEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn target_info(&self) -> &AwarenessTargetInfo {
        &self.target_info
    }
    fn activate_target(&self) -> &bool {
        &self.activate_target
    }
}

impl super::entity::SpatialEntityDataTrait for AwarenessTargetEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
}

impl super::entity::EntityDataTrait for AwarenessTargetEntityData {
}

impl super::entity::GameObjectDataTrait for AwarenessTargetEntityData {
}

impl super::core::DataBusPeerTrait for AwarenessTargetEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for AwarenessTargetEntityData {
}

impl super::core::DataContainerTrait for AwarenessTargetEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static AWARENESSTARGETENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AwarenessTargetEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AwarenessTargetEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(AwarenessTargetEntityData, realm),
            },
            FieldInfoData {
                name: "TargetInfo",
                flags: MemberInfoFlags::new(0),
                field_type: "AwarenessTargetInfo",
                rust_offset: offset_of!(AwarenessTargetEntityData, target_info),
            },
            FieldInfoData {
                name: "ActivateTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AwarenessTargetEntityData, activate_target),
            },
        ],
    }),
    array_type: Some(AWARENESSTARGETENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AwarenessTargetEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AWARENESSTARGETENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static AWARENESSTARGETENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AwarenessTargetEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("AwarenessTargetEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AwarenessComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub realm: super::core::Realm,
    pub binding: AwarenessComponentBinding,
    pub reference_joint: super::entity::GameplayBones,
    pub has_own_target: bool,
    pub own_target_bone: super::entity::GameplayBones,
    pub own_target_range: f32,
    pub damage_inflictor_target_duration: f32,
    pub damage_inflictor_target_bone: super::entity::GameplayBones,
    pub min_lookat_soldier_duration: f32,
    pub max_lookat_soldier_duration: f32,
    pub min_ignore_soldier_duration: f32,
    pub max_ignore_soldier_duration: f32,
    pub look_at_slerp_speed: f32,
    pub output_raw_look_at_angles: bool,
    pub vehicle_react_radius: f32,
    pub vehicle_speed_threshold: f32,
    pub vehicle_direction_cone_angle: f32,
    pub vehicle_reaction_duration: f32,
    pub vehicle_update_rate: f32,
}

pub trait AwarenessComponentDataTrait: super::entity::GameComponentDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn binding(&self) -> &AwarenessComponentBinding;
    fn reference_joint(&self) -> &super::entity::GameplayBones;
    fn has_own_target(&self) -> &bool;
    fn own_target_bone(&self) -> &super::entity::GameplayBones;
    fn own_target_range(&self) -> &f32;
    fn damage_inflictor_target_duration(&self) -> &f32;
    fn damage_inflictor_target_bone(&self) -> &super::entity::GameplayBones;
    fn min_lookat_soldier_duration(&self) -> &f32;
    fn max_lookat_soldier_duration(&self) -> &f32;
    fn min_ignore_soldier_duration(&self) -> &f32;
    fn max_ignore_soldier_duration(&self) -> &f32;
    fn look_at_slerp_speed(&self) -> &f32;
    fn output_raw_look_at_angles(&self) -> &bool;
    fn vehicle_react_radius(&self) -> &f32;
    fn vehicle_speed_threshold(&self) -> &f32;
    fn vehicle_direction_cone_angle(&self) -> &f32;
    fn vehicle_reaction_duration(&self) -> &f32;
    fn vehicle_update_rate(&self) -> &f32;
}

impl AwarenessComponentDataTrait for AwarenessComponentData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn binding(&self) -> &AwarenessComponentBinding {
        &self.binding
    }
    fn reference_joint(&self) -> &super::entity::GameplayBones {
        &self.reference_joint
    }
    fn has_own_target(&self) -> &bool {
        &self.has_own_target
    }
    fn own_target_bone(&self) -> &super::entity::GameplayBones {
        &self.own_target_bone
    }
    fn own_target_range(&self) -> &f32 {
        &self.own_target_range
    }
    fn damage_inflictor_target_duration(&self) -> &f32 {
        &self.damage_inflictor_target_duration
    }
    fn damage_inflictor_target_bone(&self) -> &super::entity::GameplayBones {
        &self.damage_inflictor_target_bone
    }
    fn min_lookat_soldier_duration(&self) -> &f32 {
        &self.min_lookat_soldier_duration
    }
    fn max_lookat_soldier_duration(&self) -> &f32 {
        &self.max_lookat_soldier_duration
    }
    fn min_ignore_soldier_duration(&self) -> &f32 {
        &self.min_ignore_soldier_duration
    }
    fn max_ignore_soldier_duration(&self) -> &f32 {
        &self.max_ignore_soldier_duration
    }
    fn look_at_slerp_speed(&self) -> &f32 {
        &self.look_at_slerp_speed
    }
    fn output_raw_look_at_angles(&self) -> &bool {
        &self.output_raw_look_at_angles
    }
    fn vehicle_react_radius(&self) -> &f32 {
        &self.vehicle_react_radius
    }
    fn vehicle_speed_threshold(&self) -> &f32 {
        &self.vehicle_speed_threshold
    }
    fn vehicle_direction_cone_angle(&self) -> &f32 {
        &self.vehicle_direction_cone_angle
    }
    fn vehicle_reaction_duration(&self) -> &f32 {
        &self.vehicle_reaction_duration
    }
    fn vehicle_update_rate(&self) -> &f32 {
        &self.vehicle_update_rate
    }
}

impl super::entity::GameComponentDataTrait for AwarenessComponentData {
}

impl super::entity::ComponentDataTrait for AwarenessComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
}

impl super::entity::GameObjectDataTrait for AwarenessComponentData {
}

impl super::core::DataBusPeerTrait for AwarenessComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for AwarenessComponentData {
}

impl super::core::DataContainerTrait for AwarenessComponentData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static AWARENESSCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AwarenessComponentData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AwarenessComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(AwarenessComponentData, realm),
            },
            FieldInfoData {
                name: "Binding",
                flags: MemberInfoFlags::new(0),
                field_type: "AwarenessComponentBinding",
                rust_offset: offset_of!(AwarenessComponentData, binding),
            },
            FieldInfoData {
                name: "ReferenceJoint",
                flags: MemberInfoFlags::new(0),
                field_type: "GameplayBones",
                rust_offset: offset_of!(AwarenessComponentData, reference_joint),
            },
            FieldInfoData {
                name: "HasOwnTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AwarenessComponentData, has_own_target),
            },
            FieldInfoData {
                name: "OwnTargetBone",
                flags: MemberInfoFlags::new(0),
                field_type: "GameplayBones",
                rust_offset: offset_of!(AwarenessComponentData, own_target_bone),
            },
            FieldInfoData {
                name: "OwnTargetRange",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AwarenessComponentData, own_target_range),
            },
            FieldInfoData {
                name: "DamageInflictorTargetDuration",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AwarenessComponentData, damage_inflictor_target_duration),
            },
            FieldInfoData {
                name: "DamageInflictorTargetBone",
                flags: MemberInfoFlags::new(0),
                field_type: "GameplayBones",
                rust_offset: offset_of!(AwarenessComponentData, damage_inflictor_target_bone),
            },
            FieldInfoData {
                name: "MinLookatSoldierDuration",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AwarenessComponentData, min_lookat_soldier_duration),
            },
            FieldInfoData {
                name: "MaxLookatSoldierDuration",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AwarenessComponentData, max_lookat_soldier_duration),
            },
            FieldInfoData {
                name: "MinIgnoreSoldierDuration",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AwarenessComponentData, min_ignore_soldier_duration),
            },
            FieldInfoData {
                name: "MaxIgnoreSoldierDuration",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AwarenessComponentData, max_ignore_soldier_duration),
            },
            FieldInfoData {
                name: "LookAtSlerpSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AwarenessComponentData, look_at_slerp_speed),
            },
            FieldInfoData {
                name: "OutputRawLookAtAngles",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AwarenessComponentData, output_raw_look_at_angles),
            },
            FieldInfoData {
                name: "VehicleReactRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AwarenessComponentData, vehicle_react_radius),
            },
            FieldInfoData {
                name: "VehicleSpeedThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AwarenessComponentData, vehicle_speed_threshold),
            },
            FieldInfoData {
                name: "VehicleDirectionConeAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AwarenessComponentData, vehicle_direction_cone_angle),
            },
            FieldInfoData {
                name: "VehicleReactionDuration",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AwarenessComponentData, vehicle_reaction_duration),
            },
            FieldInfoData {
                name: "VehicleUpdateRate",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AwarenessComponentData, vehicle_update_rate),
            },
        ],
    }),
    array_type: Some(AWARENESSCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AwarenessComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        AWARENESSCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static AWARENESSCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AwarenessComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("AwarenessComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AwarenessTargetInfo {
    pub priority: f32,
    pub target_type: AwarenessTargetType,
    pub target_range: f32,
    pub must_be_inside_frustum: bool,
}

pub trait AwarenessTargetInfoTrait: TypeObject {
    fn priority(&self) -> &f32;
    fn target_type(&self) -> &AwarenessTargetType;
    fn target_range(&self) -> &f32;
    fn must_be_inside_frustum(&self) -> &bool;
}

impl AwarenessTargetInfoTrait for AwarenessTargetInfo {
    fn priority(&self) -> &f32 {
        &self.priority
    }
    fn target_type(&self) -> &AwarenessTargetType {
        &self.target_type
    }
    fn target_range(&self) -> &f32 {
        &self.target_range
    }
    fn must_be_inside_frustum(&self) -> &bool {
        &self.must_be_inside_frustum
    }
}

pub static AWARENESSTARGETINFO_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AwarenessTargetInfo",
    flags: MemberInfoFlags::new(36937),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AwarenessTargetInfo as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Priority",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AwarenessTargetInfo, priority),
            },
            FieldInfoData {
                name: "TargetType",
                flags: MemberInfoFlags::new(0),
                field_type: "AwarenessTargetType",
                rust_offset: offset_of!(AwarenessTargetInfo, target_type),
            },
            FieldInfoData {
                name: "TargetRange",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AwarenessTargetInfo, target_range),
            },
            FieldInfoData {
                name: "MustBeInsideFrustum",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AwarenessTargetInfo, must_be_inside_frustum),
            },
        ],
    }),
    array_type: Some(AWARENESSTARGETINFO_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AwarenessTargetInfo {
    fn type_info(&self) -> &'static TypeInfo {
        AWARENESSTARGETINFO_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static AWARENESSTARGETINFO_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AwarenessTargetInfo-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("AwarenessTargetInfo"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum LookAtTargetType {
    #[default]
    LookAtTargetType_PointOfInterest = 0,
    LookAtTargetType_Explosion = 1,
    LookAtTargetType_Soldier = 2,
    LookAtTargetType_EnemyFire = 3,
}

pub static LOOKATTARGETTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LookAtTargetType",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(LOOKATTARGETTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for LookAtTargetType {
    fn type_info(&self) -> &'static TypeInfo {
        LOOKATTARGETTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static LOOKATTARGETTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LookAtTargetType-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("LookAtTargetType"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum AwarenessTargetType {
    #[default]
    AwarenessTargetType_LookAt = 0,
    AwarenessTargetType_AmbientThreat = 1,
    AwarenessTargetType_Count = 2,
}

pub static AWARENESSTARGETTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AwarenessTargetType",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(AWARENESSTARGETTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AwarenessTargetType {
    fn type_info(&self) -> &'static TypeInfo {
        AWARENESSTARGETTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static AWARENESSTARGETTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AwarenessTargetType-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("AwarenessTargetType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AwarenessComponentBinding {
    pub relative_look_at_pitch: super::ant::AntRef,
    pub relative_look_at_yaw: super::ant::AntRef,
    pub has_awareness_target: super::ant::AntRef,
    pub explosion_nearby: super::ant::AntRef,
    pub explosion_direction: super::ant::AntRef,
    pub nearby_threat: super::ant::AntRef,
    pub nearby_threat_direction: super::ant::AntRef,
    pub ambient_threat: super::ant::AntRef,
    pub is_friendly: super::ant::AntRef,
    pub is_in_same_squad: super::ant::AntRef,
    pub look_at_target_type: super::ant::AntRef,
}

pub trait AwarenessComponentBindingTrait: TypeObject {
    fn relative_look_at_pitch(&self) -> &super::ant::AntRef;
    fn relative_look_at_yaw(&self) -> &super::ant::AntRef;
    fn has_awareness_target(&self) -> &super::ant::AntRef;
    fn explosion_nearby(&self) -> &super::ant::AntRef;
    fn explosion_direction(&self) -> &super::ant::AntRef;
    fn nearby_threat(&self) -> &super::ant::AntRef;
    fn nearby_threat_direction(&self) -> &super::ant::AntRef;
    fn ambient_threat(&self) -> &super::ant::AntRef;
    fn is_friendly(&self) -> &super::ant::AntRef;
    fn is_in_same_squad(&self) -> &super::ant::AntRef;
    fn look_at_target_type(&self) -> &super::ant::AntRef;
}

impl AwarenessComponentBindingTrait for AwarenessComponentBinding {
    fn relative_look_at_pitch(&self) -> &super::ant::AntRef {
        &self.relative_look_at_pitch
    }
    fn relative_look_at_yaw(&self) -> &super::ant::AntRef {
        &self.relative_look_at_yaw
    }
    fn has_awareness_target(&self) -> &super::ant::AntRef {
        &self.has_awareness_target
    }
    fn explosion_nearby(&self) -> &super::ant::AntRef {
        &self.explosion_nearby
    }
    fn explosion_direction(&self) -> &super::ant::AntRef {
        &self.explosion_direction
    }
    fn nearby_threat(&self) -> &super::ant::AntRef {
        &self.nearby_threat
    }
    fn nearby_threat_direction(&self) -> &super::ant::AntRef {
        &self.nearby_threat_direction
    }
    fn ambient_threat(&self) -> &super::ant::AntRef {
        &self.ambient_threat
    }
    fn is_friendly(&self) -> &super::ant::AntRef {
        &self.is_friendly
    }
    fn is_in_same_squad(&self) -> &super::ant::AntRef {
        &self.is_in_same_squad
    }
    fn look_at_target_type(&self) -> &super::ant::AntRef {
        &self.look_at_target_type
    }
}

pub static AWARENESSCOMPONENTBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AwarenessComponentBinding",
    flags: MemberInfoFlags::new(32841),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AwarenessComponentBinding as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "RelativeLookAtPitch",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AwarenessComponentBinding, relative_look_at_pitch),
            },
            FieldInfoData {
                name: "RelativeLookAtYaw",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AwarenessComponentBinding, relative_look_at_yaw),
            },
            FieldInfoData {
                name: "HasAwarenessTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AwarenessComponentBinding, has_awareness_target),
            },
            FieldInfoData {
                name: "ExplosionNearby",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AwarenessComponentBinding, explosion_nearby),
            },
            FieldInfoData {
                name: "ExplosionDirection",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AwarenessComponentBinding, explosion_direction),
            },
            FieldInfoData {
                name: "NearbyThreat",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AwarenessComponentBinding, nearby_threat),
            },
            FieldInfoData {
                name: "NearbyThreatDirection",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AwarenessComponentBinding, nearby_threat_direction),
            },
            FieldInfoData {
                name: "AmbientThreat",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AwarenessComponentBinding, ambient_threat),
            },
            FieldInfoData {
                name: "IsFriendly",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AwarenessComponentBinding, is_friendly),
            },
            FieldInfoData {
                name: "IsInSameSquad",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AwarenessComponentBinding, is_in_same_squad),
            },
            FieldInfoData {
                name: "LookAtTargetType",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AwarenessComponentBinding, look_at_target_type),
            },
        ],
    }),
    array_type: Some(AWARENESSCOMPONENTBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AwarenessComponentBinding {
    fn type_info(&self) -> &'static TypeInfo {
        AWARENESSCOMPONENTBINDING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static AWARENESSCOMPONENTBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AwarenessComponentBinding-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("AwarenessComponentBinding"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateRequestNetState {
    pub trans: super::core::Vec3,
    pub q: super::core::Quat,
    pub interact_request_type: u32,
    pub flags: u8,
}

pub trait CharacterStateRequestNetStateTrait: TypeObject {
    fn trans(&self) -> &super::core::Vec3;
    fn q(&self) -> &super::core::Quat;
    fn interact_request_type(&self) -> &u32;
    fn flags(&self) -> &u8;
}

impl CharacterStateRequestNetStateTrait for CharacterStateRequestNetState {
    fn trans(&self) -> &super::core::Vec3 {
        &self.trans
    }
    fn q(&self) -> &super::core::Quat {
        &self.q
    }
    fn interact_request_type(&self) -> &u32 {
        &self.interact_request_type
    }
    fn flags(&self) -> &u8 {
        &self.flags
    }
}

pub static CHARACTERSTATEREQUESTNETSTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateRequestNetState",
    flags: MemberInfoFlags::new(36937),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateRequestNetState as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Trans",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(CharacterStateRequestNetState, trans),
            },
            FieldInfoData {
                name: "Q",
                flags: MemberInfoFlags::new(0),
                field_type: "Quat",
                rust_offset: offset_of!(CharacterStateRequestNetState, q),
            },
            FieldInfoData {
                name: "InteractRequestType",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(CharacterStateRequestNetState, interact_request_type),
            },
            FieldInfoData {
                name: "Flags",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(CharacterStateRequestNetState, flags),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEREQUESTNETSTATE_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CharacterStateRequestNetState {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEREQUESTNETSTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEREQUESTNETSTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateRequestNetState-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateRequestNetState"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CharacterStateRequestNetStateFlags {
    #[default]
    CharacterStateRequestNetStateFlags_HaveTarget = 0,
    CharacterStateRequestNetStateFlags_Trigger = 1,
    CharacterStateRequestNetStateFlags_RequestValid = 2,
}

pub static CHARACTERSTATEREQUESTNETSTATEFLAGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateRequestNetStateFlags",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(CHARACTERSTATEREQUESTNETSTATEFLAGS_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CharacterStateRequestNetStateFlags {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEREQUESTNETSTATEFLAGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEREQUESTNETSTATEFLAGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateRequestNetStateFlags-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateRequestNetStateFlags"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateRequestEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub request: Option<Arc<Mutex<dyn CharacterStateRequestDataBaseTrait>>>,
    pub input_hash: i32,
    pub dummy: bool,
}

pub trait CharacterStateRequestEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn request(&self) -> &Option<Arc<Mutex<dyn CharacterStateRequestDataBaseTrait>>>;
    fn input_hash(&self) -> &i32;
    fn dummy(&self) -> &bool;
}

impl CharacterStateRequestEntityDataTrait for CharacterStateRequestEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn request(&self) -> &Option<Arc<Mutex<dyn CharacterStateRequestDataBaseTrait>>> {
        &self.request
    }
    fn input_hash(&self) -> &i32 {
        &self.input_hash
    }
    fn dummy(&self) -> &bool {
        &self.dummy
    }
}

impl super::entity::EntityDataTrait for CharacterStateRequestEntityData {
}

impl super::entity::GameObjectDataTrait for CharacterStateRequestEntityData {
}

impl super::core::DataBusPeerTrait for CharacterStateRequestEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for CharacterStateRequestEntityData {
}

impl super::core::DataContainerTrait for CharacterStateRequestEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATEREQUESTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateRequestEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateRequestEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(CharacterStateRequestEntityData, realm),
            },
            FieldInfoData {
                name: "Request",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterStateRequestDataBase",
                rust_offset: offset_of!(CharacterStateRequestEntityData, request),
            },
            FieldInfoData {
                name: "InputHash",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CharacterStateRequestEntityData, input_hash),
            },
            FieldInfoData {
                name: "Dummy",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateRequestEntityData, dummy),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEREQUESTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateRequestEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEREQUESTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEREQUESTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateRequestEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateRequestEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateRequestListData {
    pub _glacier_base: super::core::DataContainerPolicyAsset,
    pub requests: Vec<Option<Arc<Mutex<dyn CharacterStateRequestDataBaseTrait>>>>,
}

pub trait CharacterStateRequestListDataTrait: super::core::DataContainerPolicyAssetTrait {
    fn requests(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateRequestDataBaseTrait>>>>;
}

impl CharacterStateRequestListDataTrait for CharacterStateRequestListData {
    fn requests(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateRequestDataBaseTrait>>>> {
        &self.requests
    }
}

impl super::core::DataContainerPolicyAssetTrait for CharacterStateRequestListData {
}

impl super::core::AssetTrait for CharacterStateRequestListData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for CharacterStateRequestListData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATEREQUESTLISTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateRequestListData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINERPOLICYASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateRequestListData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Requests",
                flags: MemberInfoFlags::new(144),
                field_type: "CharacterStateRequestDataBase-Array",
                rust_offset: offset_of!(CharacterStateRequestListData, requests),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEREQUESTLISTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateRequestListData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEREQUESTLISTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEREQUESTLISTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateRequestListData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateRequestListData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateRequestSetConstantsData {
    pub _glacier_base: CharacterStateRequestDataBase,
    pub variation_list: ChannelVariationList,
}

pub trait CharacterStateRequestSetConstantsDataTrait: CharacterStateRequestDataBaseTrait {
    fn variation_list(&self) -> &ChannelVariationList;
}

impl CharacterStateRequestSetConstantsDataTrait for CharacterStateRequestSetConstantsData {
    fn variation_list(&self) -> &ChannelVariationList {
        &self.variation_list
    }
}

impl CharacterStateRequestDataBaseTrait for CharacterStateRequestSetConstantsData {
    fn hash(&self) -> &u32 {
        self._glacier_base.hash()
    }
    fn static_delay(&self) -> &f32 {
        self._glacier_base.static_delay()
    }
    fn max_duration(&self) -> &f32 {
        self._glacier_base.max_duration()
    }
}

impl super::core::DataContainerTrait for CharacterStateRequestSetConstantsData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATEREQUESTSETCONSTANTSDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateRequestSetConstantsData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEREQUESTDATABASE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateRequestSetConstantsData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "VariationList",
                flags: MemberInfoFlags::new(0),
                field_type: "ChannelVariationList",
                rust_offset: offset_of!(CharacterStateRequestSetConstantsData, variation_list),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEREQUESTSETCONSTANTSDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateRequestSetConstantsData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEREQUESTSETCONSTANTSDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEREQUESTSETCONSTANTSDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateRequestSetConstantsData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateRequestSetConstantsData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateRequestObjectInteractionData {
    pub _glacier_base: CharacterStateRequestDataBase,
    pub have_target_channel: Option<Arc<Mutex<dyn super::soldier_shared::CharacterStatePublicBoolChannelDataTrait>>>,
    pub transform_channel_to_set: Option<Arc<Mutex<dyn super::soldier_shared::CharacterStatePublicTransformChannelDataTrait>>>,
    pub trigger_to_set: Option<Arc<Mutex<dyn super::soldier_shared::CharacterStatePublicBoolChannelDataTrait>>>,
    pub variation_list: ChannelVariationList,
}

pub trait CharacterStateRequestObjectInteractionDataTrait: CharacterStateRequestDataBaseTrait {
    fn have_target_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::CharacterStatePublicBoolChannelDataTrait>>>;
    fn transform_channel_to_set(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::CharacterStatePublicTransformChannelDataTrait>>>;
    fn trigger_to_set(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::CharacterStatePublicBoolChannelDataTrait>>>;
    fn variation_list(&self) -> &ChannelVariationList;
}

impl CharacterStateRequestObjectInteractionDataTrait for CharacterStateRequestObjectInteractionData {
    fn have_target_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::CharacterStatePublicBoolChannelDataTrait>>> {
        &self.have_target_channel
    }
    fn transform_channel_to_set(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::CharacterStatePublicTransformChannelDataTrait>>> {
        &self.transform_channel_to_set
    }
    fn trigger_to_set(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::CharacterStatePublicBoolChannelDataTrait>>> {
        &self.trigger_to_set
    }
    fn variation_list(&self) -> &ChannelVariationList {
        &self.variation_list
    }
}

impl CharacterStateRequestDataBaseTrait for CharacterStateRequestObjectInteractionData {
    fn hash(&self) -> &u32 {
        self._glacier_base.hash()
    }
    fn static_delay(&self) -> &f32 {
        self._glacier_base.static_delay()
    }
    fn max_duration(&self) -> &f32 {
        self._glacier_base.max_duration()
    }
}

impl super::core::DataContainerTrait for CharacterStateRequestObjectInteractionData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATEREQUESTOBJECTINTERACTIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateRequestObjectInteractionData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEREQUESTDATABASE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateRequestObjectInteractionData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "HaveTargetChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterStatePublicBoolChannelData",
                rust_offset: offset_of!(CharacterStateRequestObjectInteractionData, have_target_channel),
            },
            FieldInfoData {
                name: "TransformChannelToSet",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterStatePublicTransformChannelData",
                rust_offset: offset_of!(CharacterStateRequestObjectInteractionData, transform_channel_to_set),
            },
            FieldInfoData {
                name: "TriggerToSet",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterStatePublicBoolChannelData",
                rust_offset: offset_of!(CharacterStateRequestObjectInteractionData, trigger_to_set),
            },
            FieldInfoData {
                name: "VariationList",
                flags: MemberInfoFlags::new(0),
                field_type: "ChannelVariationList",
                rust_offset: offset_of!(CharacterStateRequestObjectInteractionData, variation_list),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEREQUESTOBJECTINTERACTIONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateRequestObjectInteractionData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEREQUESTOBJECTINTERACTIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEREQUESTOBJECTINTERACTIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateRequestObjectInteractionData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateRequestObjectInteractionData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateRequestTransformInteractionData {
    pub _glacier_base: CharacterStateRequestDataBase,
    pub have_target_channel: Option<Arc<Mutex<dyn super::soldier_shared::CharacterStatePublicBoolChannelDataTrait>>>,
    pub transform_channel_to_set: Option<Arc<Mutex<dyn super::soldier_shared::CharacterStatePublicTransformChannelDataTrait>>>,
    pub trigger_to_set: Option<Arc<Mutex<dyn super::soldier_shared::CharacterStatePublicBoolChannelDataTrait>>>,
    pub variation_list: ChannelVariationList,
}

pub trait CharacterStateRequestTransformInteractionDataTrait: CharacterStateRequestDataBaseTrait {
    fn have_target_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::CharacterStatePublicBoolChannelDataTrait>>>;
    fn transform_channel_to_set(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::CharacterStatePublicTransformChannelDataTrait>>>;
    fn trigger_to_set(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::CharacterStatePublicBoolChannelDataTrait>>>;
    fn variation_list(&self) -> &ChannelVariationList;
}

impl CharacterStateRequestTransformInteractionDataTrait for CharacterStateRequestTransformInteractionData {
    fn have_target_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::CharacterStatePublicBoolChannelDataTrait>>> {
        &self.have_target_channel
    }
    fn transform_channel_to_set(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::CharacterStatePublicTransformChannelDataTrait>>> {
        &self.transform_channel_to_set
    }
    fn trigger_to_set(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::CharacterStatePublicBoolChannelDataTrait>>> {
        &self.trigger_to_set
    }
    fn variation_list(&self) -> &ChannelVariationList {
        &self.variation_list
    }
}

impl CharacterStateRequestDataBaseTrait for CharacterStateRequestTransformInteractionData {
    fn hash(&self) -> &u32 {
        self._glacier_base.hash()
    }
    fn static_delay(&self) -> &f32 {
        self._glacier_base.static_delay()
    }
    fn max_duration(&self) -> &f32 {
        self._glacier_base.max_duration()
    }
}

impl super::core::DataContainerTrait for CharacterStateRequestTransformInteractionData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATEREQUESTTRANSFORMINTERACTIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateRequestTransformInteractionData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEREQUESTDATABASE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateRequestTransformInteractionData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "HaveTargetChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterStatePublicBoolChannelData",
                rust_offset: offset_of!(CharacterStateRequestTransformInteractionData, have_target_channel),
            },
            FieldInfoData {
                name: "TransformChannelToSet",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterStatePublicTransformChannelData",
                rust_offset: offset_of!(CharacterStateRequestTransformInteractionData, transform_channel_to_set),
            },
            FieldInfoData {
                name: "TriggerToSet",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterStatePublicBoolChannelData",
                rust_offset: offset_of!(CharacterStateRequestTransformInteractionData, trigger_to_set),
            },
            FieldInfoData {
                name: "VariationList",
                flags: MemberInfoFlags::new(0),
                field_type: "ChannelVariationList",
                rust_offset: offset_of!(CharacterStateRequestTransformInteractionData, variation_list),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEREQUESTTRANSFORMINTERACTIONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateRequestTransformInteractionData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEREQUESTTRANSFORMINTERACTIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEREQUESTTRANSFORMINTERACTIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateRequestTransformInteractionData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateRequestTransformInteractionData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TransformChannelVariation {
    pub _glacier_base: super::core::DataContainer,
    pub variation_channel: Option<Arc<Mutex<dyn super::soldier_shared::CharacterStatePublicTransformChannelDataTrait>>>,
    pub variation_value: super::core::LinearTransform,
}

pub trait TransformChannelVariationTrait: super::core::DataContainerTrait {
    fn variation_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::CharacterStatePublicTransformChannelDataTrait>>>;
    fn variation_value(&self) -> &super::core::LinearTransform;
}

impl TransformChannelVariationTrait for TransformChannelVariation {
    fn variation_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::CharacterStatePublicTransformChannelDataTrait>>> {
        &self.variation_channel
    }
    fn variation_value(&self) -> &super::core::LinearTransform {
        &self.variation_value
    }
}

impl super::core::DataContainerTrait for TransformChannelVariation {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static TRANSFORMCHANNELVARIATION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformChannelVariation",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformChannelVariation as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "VariationChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterStatePublicTransformChannelData",
                rust_offset: offset_of!(TransformChannelVariation, variation_channel),
            },
            FieldInfoData {
                name: "VariationValue",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(TransformChannelVariation, variation_value),
            },
        ],
    }),
    array_type: Some(TRANSFORMCHANNELVARIATION_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for TransformChannelVariation {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMCHANNELVARIATION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static TRANSFORMCHANNELVARIATION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformChannelVariation-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("TransformChannelVariation"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Vec3ChannelVariation {
    pub _glacier_base: super::core::DataContainer,
    pub variation_channel: Option<Arc<Mutex<dyn super::soldier_shared::CharacterStatePublicVec3ChannelDataTrait>>>,
    pub variation_value: super::core::Vec3,
}

pub trait Vec3ChannelVariationTrait: super::core::DataContainerTrait {
    fn variation_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::CharacterStatePublicVec3ChannelDataTrait>>>;
    fn variation_value(&self) -> &super::core::Vec3;
}

impl Vec3ChannelVariationTrait for Vec3ChannelVariation {
    fn variation_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::CharacterStatePublicVec3ChannelDataTrait>>> {
        &self.variation_channel
    }
    fn variation_value(&self) -> &super::core::Vec3 {
        &self.variation_value
    }
}

impl super::core::DataContainerTrait for Vec3ChannelVariation {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static VEC3CHANNELVARIATION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3ChannelVariation",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec3ChannelVariation as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "VariationChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterStatePublicVec3ChannelData",
                rust_offset: offset_of!(Vec3ChannelVariation, variation_channel),
            },
            FieldInfoData {
                name: "VariationValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(Vec3ChannelVariation, variation_value),
            },
        ],
    }),
    array_type: Some(VEC3CHANNELVARIATION_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for Vec3ChannelVariation {
    fn type_info(&self) -> &'static TypeInfo {
        VEC3CHANNELVARIATION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VEC3CHANNELVARIATION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3ChannelVariation-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("Vec3ChannelVariation"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FloatChannelVariation {
    pub _glacier_base: super::core::DataContainer,
    pub variation_channel: Option<Arc<Mutex<dyn super::soldier_shared::CharacterStatePublicFloatChannelDataTrait>>>,
    pub variation_value: f32,
}

pub trait FloatChannelVariationTrait: super::core::DataContainerTrait {
    fn variation_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::CharacterStatePublicFloatChannelDataTrait>>>;
    fn variation_value(&self) -> &f32;
}

impl FloatChannelVariationTrait for FloatChannelVariation {
    fn variation_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::CharacterStatePublicFloatChannelDataTrait>>> {
        &self.variation_channel
    }
    fn variation_value(&self) -> &f32 {
        &self.variation_value
    }
}

impl super::core::DataContainerTrait for FloatChannelVariation {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static FLOATCHANNELVARIATION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatChannelVariation",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FloatChannelVariation as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "VariationChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterStatePublicFloatChannelData",
                rust_offset: offset_of!(FloatChannelVariation, variation_channel),
            },
            FieldInfoData {
                name: "VariationValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FloatChannelVariation, variation_value),
            },
        ],
    }),
    array_type: Some(FLOATCHANNELVARIATION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FloatChannelVariation {
    fn type_info(&self) -> &'static TypeInfo {
        FLOATCHANNELVARIATION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static FLOATCHANNELVARIATION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatChannelVariation-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("FloatChannelVariation"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct IntChannelVariation {
    pub _glacier_base: super::core::DataContainer,
    pub variation_channel: Option<Arc<Mutex<dyn super::soldier_shared::CharacterStatePublicIntChannelDataTrait>>>,
    pub variation_value: i32,
}

pub trait IntChannelVariationTrait: super::core::DataContainerTrait {
    fn variation_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::CharacterStatePublicIntChannelDataTrait>>>;
    fn variation_value(&self) -> &i32;
}

impl IntChannelVariationTrait for IntChannelVariation {
    fn variation_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::CharacterStatePublicIntChannelDataTrait>>> {
        &self.variation_channel
    }
    fn variation_value(&self) -> &i32 {
        &self.variation_value
    }
}

impl super::core::DataContainerTrait for IntChannelVariation {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static INTCHANNELVARIATION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntChannelVariation",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<IntChannelVariation as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "VariationChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterStatePublicIntChannelData",
                rust_offset: offset_of!(IntChannelVariation, variation_channel),
            },
            FieldInfoData {
                name: "VariationValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(IntChannelVariation, variation_value),
            },
        ],
    }),
    array_type: Some(INTCHANNELVARIATION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for IntChannelVariation {
    fn type_info(&self) -> &'static TypeInfo {
        INTCHANNELVARIATION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static INTCHANNELVARIATION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntChannelVariation-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("IntChannelVariation"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BoolChannelVariation {
    pub _glacier_base: super::core::DataContainer,
    pub variation_channel: Option<Arc<Mutex<dyn super::soldier_shared::CharacterStatePublicBoolChannelDataTrait>>>,
    pub variation_value: bool,
}

pub trait BoolChannelVariationTrait: super::core::DataContainerTrait {
    fn variation_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::CharacterStatePublicBoolChannelDataTrait>>>;
    fn variation_value(&self) -> &bool;
}

impl BoolChannelVariationTrait for BoolChannelVariation {
    fn variation_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::CharacterStatePublicBoolChannelDataTrait>>> {
        &self.variation_channel
    }
    fn variation_value(&self) -> &bool {
        &self.variation_value
    }
}

impl super::core::DataContainerTrait for BoolChannelVariation {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static BOOLCHANNELVARIATION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolChannelVariation",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BoolChannelVariation as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "VariationChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterStatePublicBoolChannelData",
                rust_offset: offset_of!(BoolChannelVariation, variation_channel),
            },
            FieldInfoData {
                name: "VariationValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BoolChannelVariation, variation_value),
            },
        ],
    }),
    array_type: Some(BOOLCHANNELVARIATION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BoolChannelVariation {
    fn type_info(&self) -> &'static TypeInfo {
        BOOLCHANNELVARIATION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static BOOLCHANNELVARIATION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolChannelVariation-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("BoolChannelVariation"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ChannelVariationList {
    pub int_variations: Vec<Option<Arc<Mutex<dyn IntChannelVariationTrait>>>>,
    pub bool_variations: Vec<Option<Arc<Mutex<dyn BoolChannelVariationTrait>>>>,
    pub float_variations: Vec<Option<Arc<Mutex<dyn FloatChannelVariationTrait>>>>,
    pub vec3_variations: Vec<Option<Arc<Mutex<dyn Vec3ChannelVariationTrait>>>>,
    pub transform_variations: Vec<Option<Arc<Mutex<dyn TransformChannelVariationTrait>>>>,
}

pub trait ChannelVariationListTrait: TypeObject {
    fn int_variations(&self) -> &Vec<Option<Arc<Mutex<dyn IntChannelVariationTrait>>>>;
    fn bool_variations(&self) -> &Vec<Option<Arc<Mutex<dyn BoolChannelVariationTrait>>>>;
    fn float_variations(&self) -> &Vec<Option<Arc<Mutex<dyn FloatChannelVariationTrait>>>>;
    fn vec3_variations(&self) -> &Vec<Option<Arc<Mutex<dyn Vec3ChannelVariationTrait>>>>;
    fn transform_variations(&self) -> &Vec<Option<Arc<Mutex<dyn TransformChannelVariationTrait>>>>;
}

impl ChannelVariationListTrait for ChannelVariationList {
    fn int_variations(&self) -> &Vec<Option<Arc<Mutex<dyn IntChannelVariationTrait>>>> {
        &self.int_variations
    }
    fn bool_variations(&self) -> &Vec<Option<Arc<Mutex<dyn BoolChannelVariationTrait>>>> {
        &self.bool_variations
    }
    fn float_variations(&self) -> &Vec<Option<Arc<Mutex<dyn FloatChannelVariationTrait>>>> {
        &self.float_variations
    }
    fn vec3_variations(&self) -> &Vec<Option<Arc<Mutex<dyn Vec3ChannelVariationTrait>>>> {
        &self.vec3_variations
    }
    fn transform_variations(&self) -> &Vec<Option<Arc<Mutex<dyn TransformChannelVariationTrait>>>> {
        &self.transform_variations
    }
}

pub static CHANNELVARIATIONLIST_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ChannelVariationList",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ChannelVariationList as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "IntVariations",
                flags: MemberInfoFlags::new(144),
                field_type: "IntChannelVariation-Array",
                rust_offset: offset_of!(ChannelVariationList, int_variations),
            },
            FieldInfoData {
                name: "BoolVariations",
                flags: MemberInfoFlags::new(144),
                field_type: "BoolChannelVariation-Array",
                rust_offset: offset_of!(ChannelVariationList, bool_variations),
            },
            FieldInfoData {
                name: "FloatVariations",
                flags: MemberInfoFlags::new(144),
                field_type: "FloatChannelVariation-Array",
                rust_offset: offset_of!(ChannelVariationList, float_variations),
            },
            FieldInfoData {
                name: "Vec3Variations",
                flags: MemberInfoFlags::new(144),
                field_type: "Vec3ChannelVariation-Array",
                rust_offset: offset_of!(ChannelVariationList, vec3_variations),
            },
            FieldInfoData {
                name: "TransformVariations",
                flags: MemberInfoFlags::new(144),
                field_type: "TransformChannelVariation-Array",
                rust_offset: offset_of!(ChannelVariationList, transform_variations),
            },
        ],
    }),
    array_type: Some(CHANNELVARIATIONLIST_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ChannelVariationList {
    fn type_info(&self) -> &'static TypeInfo {
        CHANNELVARIATIONLIST_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHANNELVARIATIONLIST_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ChannelVariationList-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("ChannelVariationList"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateRequestDataBase {
    pub _glacier_base: super::core::DataContainer,
    pub hash: u32,
    pub static_delay: f32,
    pub max_duration: f32,
}

pub trait CharacterStateRequestDataBaseTrait: super::core::DataContainerTrait {
    fn hash(&self) -> &u32;
    fn static_delay(&self) -> &f32;
    fn max_duration(&self) -> &f32;
}

impl CharacterStateRequestDataBaseTrait for CharacterStateRequestDataBase {
    fn hash(&self) -> &u32 {
        &self.hash
    }
    fn static_delay(&self) -> &f32 {
        &self.static_delay
    }
    fn max_duration(&self) -> &f32 {
        &self.max_duration
    }
}

impl super::core::DataContainerTrait for CharacterStateRequestDataBase {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATEREQUESTDATABASE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateRequestDataBase",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateRequestDataBase as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Hash",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(CharacterStateRequestDataBase, hash),
            },
            FieldInfoData {
                name: "StaticDelay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateRequestDataBase, static_delay),
            },
            FieldInfoData {
                name: "MaxDuration",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateRequestDataBase, max_duration),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEREQUESTDATABASE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateRequestDataBase {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEREQUESTDATABASE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEREQUESTDATABASE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateRequestDataBase-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateRequestDataBase"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateOwnerData {
    pub _glacier_base: super::core::DataContainerPolicyAsset,
    pub root_controller: Option<Arc<Mutex<dyn CharacterStateRootControllerDataTrait>>>,
    pub included_channels: Option<Arc<Mutex<dyn super::soldier_shared::ChannelSetDataTrait>>>,
    pub all_controller_datas: Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>>,
    pub controller_groups: Vec<CharacterStateControllerGroup>,
    pub public_channel_mapping: super::soldier_shared::CharacterStatePublicChannelMappingTable,
    pub dynamic_avoidance: Option<Arc<Mutex<dyn CharacterStateDynamicAvoidanceDataTrait>>>,
    pub proxy_data_pointer: super::ant::AntRef,
    pub attached_proxy_data_pointer: super::ant::AntRef,
    pub animatable: super::ant::AntRef,
    pub scene_op_matrix: super::ant::AntRef,
    pub controller_soft_limit_size: i32,
}

pub trait CharacterStateOwnerDataTrait: super::core::DataContainerPolicyAssetTrait {
    fn root_controller(&self) -> &Option<Arc<Mutex<dyn CharacterStateRootControllerDataTrait>>>;
    fn included_channels(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::ChannelSetDataTrait>>>;
    fn all_controller_datas(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>>;
    fn controller_groups(&self) -> &Vec<CharacterStateControllerGroup>;
    fn public_channel_mapping(&self) -> &super::soldier_shared::CharacterStatePublicChannelMappingTable;
    fn dynamic_avoidance(&self) -> &Option<Arc<Mutex<dyn CharacterStateDynamicAvoidanceDataTrait>>>;
    fn proxy_data_pointer(&self) -> &super::ant::AntRef;
    fn attached_proxy_data_pointer(&self) -> &super::ant::AntRef;
    fn animatable(&self) -> &super::ant::AntRef;
    fn scene_op_matrix(&self) -> &super::ant::AntRef;
    fn controller_soft_limit_size(&self) -> &i32;
}

impl CharacterStateOwnerDataTrait for CharacterStateOwnerData {
    fn root_controller(&self) -> &Option<Arc<Mutex<dyn CharacterStateRootControllerDataTrait>>> {
        &self.root_controller
    }
    fn included_channels(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::ChannelSetDataTrait>>> {
        &self.included_channels
    }
    fn all_controller_datas(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>> {
        &self.all_controller_datas
    }
    fn controller_groups(&self) -> &Vec<CharacterStateControllerGroup> {
        &self.controller_groups
    }
    fn public_channel_mapping(&self) -> &super::soldier_shared::CharacterStatePublicChannelMappingTable {
        &self.public_channel_mapping
    }
    fn dynamic_avoidance(&self) -> &Option<Arc<Mutex<dyn CharacterStateDynamicAvoidanceDataTrait>>> {
        &self.dynamic_avoidance
    }
    fn proxy_data_pointer(&self) -> &super::ant::AntRef {
        &self.proxy_data_pointer
    }
    fn attached_proxy_data_pointer(&self) -> &super::ant::AntRef {
        &self.attached_proxy_data_pointer
    }
    fn animatable(&self) -> &super::ant::AntRef {
        &self.animatable
    }
    fn scene_op_matrix(&self) -> &super::ant::AntRef {
        &self.scene_op_matrix
    }
    fn controller_soft_limit_size(&self) -> &i32 {
        &self.controller_soft_limit_size
    }
}

impl super::core::DataContainerPolicyAssetTrait for CharacterStateOwnerData {
}

impl super::core::AssetTrait for CharacterStateOwnerData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for CharacterStateOwnerData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATEOWNERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateOwnerData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINERPOLICYASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateOwnerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "RootController",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterStateRootControllerData",
                rust_offset: offset_of!(CharacterStateOwnerData, root_controller),
            },
            FieldInfoData {
                name: "IncludedChannels",
                flags: MemberInfoFlags::new(0),
                field_type: "ChannelSetData",
                rust_offset: offset_of!(CharacterStateOwnerData, included_channels),
            },
            FieldInfoData {
                name: "AllControllerDatas",
                flags: MemberInfoFlags::new(144),
                field_type: "CharacterStateBaseControllerData-Array",
                rust_offset: offset_of!(CharacterStateOwnerData, all_controller_datas),
            },
            FieldInfoData {
                name: "ControllerGroups",
                flags: MemberInfoFlags::new(144),
                field_type: "CharacterStateControllerGroup-Array",
                rust_offset: offset_of!(CharacterStateOwnerData, controller_groups),
            },
            FieldInfoData {
                name: "PublicChannelMapping",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterStatePublicChannelMappingTable",
                rust_offset: offset_of!(CharacterStateOwnerData, public_channel_mapping),
            },
            FieldInfoData {
                name: "DynamicAvoidance",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterStateDynamicAvoidanceData",
                rust_offset: offset_of!(CharacterStateOwnerData, dynamic_avoidance),
            },
            FieldInfoData {
                name: "ProxyDataPointer",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CharacterStateOwnerData, proxy_data_pointer),
            },
            FieldInfoData {
                name: "AttachedProxyDataPointer",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CharacterStateOwnerData, attached_proxy_data_pointer),
            },
            FieldInfoData {
                name: "Animatable",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CharacterStateOwnerData, animatable),
            },
            FieldInfoData {
                name: "SceneOpMatrix",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CharacterStateOwnerData, scene_op_matrix),
            },
            FieldInfoData {
                name: "ControllerSoftLimitSize",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CharacterStateOwnerData, controller_soft_limit_size),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEOWNERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateOwnerData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEOWNERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEOWNERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateOwnerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateOwnerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateDynamicAvoidanceData {
    pub _glacier_base: super::core::DataContainer,
    pub enable_dynamic_avoidance_channel: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub reject_hard_collisions_with_non_a_i_characters_channel: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub position_channel: Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>,
    pub velocity_channel: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub acceleration_channel: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub throttle_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub strafe_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub separation_velocity_still: f32,
    pub separation_distance_still: f32,
    pub separation_velocity_moving: f32,
    pub separation_distance_moving: f32,
    pub relative_velocity_limit_for_moving_separation: f32,
    pub resolve_clipping_while_moving: bool,
    pub adjust_sideways_to_limit_clipping: bool,
}

pub trait CharacterStateDynamicAvoidanceDataTrait: super::core::DataContainerTrait {
    fn enable_dynamic_avoidance_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn reject_hard_collisions_with_non_a_i_characters_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn position_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>;
    fn velocity_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn acceleration_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn throttle_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn strafe_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn separation_velocity_still(&self) -> &f32;
    fn separation_distance_still(&self) -> &f32;
    fn separation_velocity_moving(&self) -> &f32;
    fn separation_distance_moving(&self) -> &f32;
    fn relative_velocity_limit_for_moving_separation(&self) -> &f32;
    fn resolve_clipping_while_moving(&self) -> &bool;
    fn adjust_sideways_to_limit_clipping(&self) -> &bool;
}

impl CharacterStateDynamicAvoidanceDataTrait for CharacterStateDynamicAvoidanceData {
    fn enable_dynamic_avoidance_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.enable_dynamic_avoidance_channel
    }
    fn reject_hard_collisions_with_non_a_i_characters_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.reject_hard_collisions_with_non_a_i_characters_channel
    }
    fn position_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>> {
        &self.position_channel
    }
    fn velocity_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.velocity_channel
    }
    fn acceleration_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.acceleration_channel
    }
    fn throttle_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.throttle_channel
    }
    fn strafe_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.strafe_channel
    }
    fn separation_velocity_still(&self) -> &f32 {
        &self.separation_velocity_still
    }
    fn separation_distance_still(&self) -> &f32 {
        &self.separation_distance_still
    }
    fn separation_velocity_moving(&self) -> &f32 {
        &self.separation_velocity_moving
    }
    fn separation_distance_moving(&self) -> &f32 {
        &self.separation_distance_moving
    }
    fn relative_velocity_limit_for_moving_separation(&self) -> &f32 {
        &self.relative_velocity_limit_for_moving_separation
    }
    fn resolve_clipping_while_moving(&self) -> &bool {
        &self.resolve_clipping_while_moving
    }
    fn adjust_sideways_to_limit_clipping(&self) -> &bool {
        &self.adjust_sideways_to_limit_clipping
    }
}

impl super::core::DataContainerTrait for CharacterStateDynamicAvoidanceData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATEDYNAMICAVOIDANCEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateDynamicAvoidanceData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateDynamicAvoidanceData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "EnableDynamicAvoidanceChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(CharacterStateDynamicAvoidanceData, enable_dynamic_avoidance_channel),
            },
            FieldInfoData {
                name: "RejectHardCollisionsWithNonAICharactersChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(CharacterStateDynamicAvoidanceData, reject_hard_collisions_with_non_a_i_characters_channel),
            },
            FieldInfoData {
                name: "PositionChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(CharacterStateDynamicAvoidanceData, position_channel),
            },
            FieldInfoData {
                name: "VelocityChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateDynamicAvoidanceData, velocity_channel),
            },
            FieldInfoData {
                name: "AccelerationChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateDynamicAvoidanceData, acceleration_channel),
            },
            FieldInfoData {
                name: "ThrottleChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateDynamicAvoidanceData, throttle_channel),
            },
            FieldInfoData {
                name: "StrafeChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateDynamicAvoidanceData, strafe_channel),
            },
            FieldInfoData {
                name: "SeparationVelocityStill",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateDynamicAvoidanceData, separation_velocity_still),
            },
            FieldInfoData {
                name: "SeparationDistanceStill",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateDynamicAvoidanceData, separation_distance_still),
            },
            FieldInfoData {
                name: "SeparationVelocityMoving",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateDynamicAvoidanceData, separation_velocity_moving),
            },
            FieldInfoData {
                name: "SeparationDistanceMoving",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateDynamicAvoidanceData, separation_distance_moving),
            },
            FieldInfoData {
                name: "RelativeVelocityLimitForMovingSeparation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateDynamicAvoidanceData, relative_velocity_limit_for_moving_separation),
            },
            FieldInfoData {
                name: "ResolveClippingWhileMoving",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateDynamicAvoidanceData, resolve_clipping_while_moving),
            },
            FieldInfoData {
                name: "AdjustSidewaysToLimitClipping",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateDynamicAvoidanceData, adjust_sideways_to_limit_clipping),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEDYNAMICAVOIDANCEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateDynamicAvoidanceData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEDYNAMICAVOIDANCEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEDYNAMICAVOIDANCEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateDynamicAvoidanceData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateDynamicAvoidanceData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateControllerGroup {
    pub name: String,
    pub controllers_in_group: Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>>,
}

pub trait CharacterStateControllerGroupTrait: TypeObject {
    fn name(&self) -> &String;
    fn controllers_in_group(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>>;
}

impl CharacterStateControllerGroupTrait for CharacterStateControllerGroup {
    fn name(&self) -> &String {
        &self.name
    }
    fn controllers_in_group(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>> {
        &self.controllers_in_group
    }
}

pub static CHARACTERSTATECONTROLLERGROUP_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateControllerGroup",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateControllerGroup as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(CharacterStateControllerGroup, name),
            },
            FieldInfoData {
                name: "ControllersInGroup",
                flags: MemberInfoFlags::new(144),
                field_type: "CharacterStateBaseControllerData-Array",
                rust_offset: offset_of!(CharacterStateControllerGroup, controllers_in_group),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATECONTROLLERGROUP_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateControllerGroup {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATECONTROLLERGROUP_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATECONTROLLERGROUP_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateControllerGroup-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateControllerGroup"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateRootControllerData {
    pub _glacier_base: CharacterStateBaseControllerData,
    pub channels: super::soldier_shared::ChannelTableData,
    pub root_ant_controller: super::ant::AntRef,
    pub post_physics_root_ant_controller: super::ant::AntRef,
}

pub trait CharacterStateRootControllerDataTrait: CharacterStateBaseControllerDataTrait {
    fn channels(&self) -> &super::soldier_shared::ChannelTableData;
    fn root_ant_controller(&self) -> &super::ant::AntRef;
    fn post_physics_root_ant_controller(&self) -> &super::ant::AntRef;
}

impl CharacterStateRootControllerDataTrait for CharacterStateRootControllerData {
    fn channels(&self) -> &super::soldier_shared::ChannelTableData {
        &self.channels
    }
    fn root_ant_controller(&self) -> &super::ant::AntRef {
        &self.root_ant_controller
    }
    fn post_physics_root_ant_controller(&self) -> &super::ant::AntRef {
        &self.post_physics_root_ant_controller
    }
}

impl CharacterStateBaseControllerDataTrait for CharacterStateRootControllerData {
    fn asset_index(&self) -> &i32 {
        self._glacier_base.asset_index()
    }
    fn subjects(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>> {
        self._glacier_base.subjects()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for CharacterStateRootControllerData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATEROOTCONTROLLERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateRootControllerData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEBASECONTROLLERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateRootControllerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Channels",
                flags: MemberInfoFlags::new(0),
                field_type: "ChannelTableData",
                rust_offset: offset_of!(CharacterStateRootControllerData, channels),
            },
            FieldInfoData {
                name: "RootAntController",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CharacterStateRootControllerData, root_ant_controller),
            },
            FieldInfoData {
                name: "PostPhysicsRootAntController",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CharacterStateRootControllerData, post_physics_root_ant_controller),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEROOTCONTROLLERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateRootControllerData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEROOTCONTROLLERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEROOTCONTROLLERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateRootControllerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateRootControllerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CharacterStateInfo {
    #[default]
    CharacterStateInfo_NetworkedBoolBucketCount = 24,
    CharacterStateInfo_NetworkedFloatCount = 16,
    CharacterStateInfo_NetworkedVec3Count = 8,
    CharacterStateInfo_NetworkedTransformCount = 4,
    CharacterStateInfo_NetworkedFloatActiveBucketCount = 2,
    CharacterStateInfo_NetworkedVec3ActiveBucketCount = 1,
    CharacterStateInfo_NonNetworkedIntCount = 64,
    CharacterStateInfo_NonNetworkedTransformCount = 32,
    CharacterStateInfo_IndexBitCount = 6,
    CharacterStateInfo_InvalidAsset = 65535,
    CharacterStateInfo_MaxStateCount = 40,
    CharacterStateInfo_InvalidIndex = 41,
    CharacterStateInfo_InvalidBlendSpaceClipIndex = 63,
}

pub static CHARACTERSTATEINFO_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateInfo",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(CHARACTERSTATEINFO_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CharacterStateInfo {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEINFO_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEINFO_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateInfo-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateInfo"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ControllerEvalComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub realm: super::core::Realm,
    pub use_game_defined_state_machine: bool,
    pub loco_animatable: Option<Arc<Mutex<dyn CharacterStateOwnerDataTrait>>>,
    pub simple_input: Vec<InputToGameState>,
    pub int_channel_input: Vec<InputToIntGameState>,
    pub analog_input: Vec<InputToFloatGameState>,
    pub velocity: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub angular_velocity: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub aim_yaw: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub aim_pitch: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub position: Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>,
    pub accelerations: Vec<Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>>,
    pub weapon_move_speed_multiplier: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub authoritative_velocity: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub use_authoritative_motion: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub desired_pose_channel: Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>,
    pub changing_to_pose_channel: Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>,
    pub weapon_type_channel: Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>,
    pub character_request_list: Option<Arc<Mutex<dyn CharacterStateRequestListDataTrait>>>,
    pub replicated_update_disabled: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub old_physics_emulator: OldPhysicsEmulatorData,
}

pub trait ControllerEvalComponentDataTrait: super::entity::GameComponentDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn use_game_defined_state_machine(&self) -> &bool;
    fn loco_animatable(&self) -> &Option<Arc<Mutex<dyn CharacterStateOwnerDataTrait>>>;
    fn simple_input(&self) -> &Vec<InputToGameState>;
    fn int_channel_input(&self) -> &Vec<InputToIntGameState>;
    fn analog_input(&self) -> &Vec<InputToFloatGameState>;
    fn velocity(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn angular_velocity(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn aim_yaw(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn aim_pitch(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn position(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>;
    fn accelerations(&self) -> &Vec<Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>>;
    fn weapon_move_speed_multiplier(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn authoritative_velocity(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn use_authoritative_motion(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn desired_pose_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>;
    fn changing_to_pose_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>;
    fn weapon_type_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>;
    fn character_request_list(&self) -> &Option<Arc<Mutex<dyn CharacterStateRequestListDataTrait>>>;
    fn replicated_update_disabled(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn old_physics_emulator(&self) -> &OldPhysicsEmulatorData;
}

impl ControllerEvalComponentDataTrait for ControllerEvalComponentData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn use_game_defined_state_machine(&self) -> &bool {
        &self.use_game_defined_state_machine
    }
    fn loco_animatable(&self) -> &Option<Arc<Mutex<dyn CharacterStateOwnerDataTrait>>> {
        &self.loco_animatable
    }
    fn simple_input(&self) -> &Vec<InputToGameState> {
        &self.simple_input
    }
    fn int_channel_input(&self) -> &Vec<InputToIntGameState> {
        &self.int_channel_input
    }
    fn analog_input(&self) -> &Vec<InputToFloatGameState> {
        &self.analog_input
    }
    fn velocity(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.velocity
    }
    fn angular_velocity(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.angular_velocity
    }
    fn aim_yaw(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.aim_yaw
    }
    fn aim_pitch(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.aim_pitch
    }
    fn position(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>> {
        &self.position
    }
    fn accelerations(&self) -> &Vec<Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>> {
        &self.accelerations
    }
    fn weapon_move_speed_multiplier(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.weapon_move_speed_multiplier
    }
    fn authoritative_velocity(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.authoritative_velocity
    }
    fn use_authoritative_motion(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.use_authoritative_motion
    }
    fn desired_pose_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>> {
        &self.desired_pose_channel
    }
    fn changing_to_pose_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>> {
        &self.changing_to_pose_channel
    }
    fn weapon_type_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>> {
        &self.weapon_type_channel
    }
    fn character_request_list(&self) -> &Option<Arc<Mutex<dyn CharacterStateRequestListDataTrait>>> {
        &self.character_request_list
    }
    fn replicated_update_disabled(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.replicated_update_disabled
    }
    fn old_physics_emulator(&self) -> &OldPhysicsEmulatorData {
        &self.old_physics_emulator
    }
}

impl super::entity::GameComponentDataTrait for ControllerEvalComponentData {
}

impl super::entity::ComponentDataTrait for ControllerEvalComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
}

impl super::entity::GameObjectDataTrait for ControllerEvalComponentData {
}

impl super::core::DataBusPeerTrait for ControllerEvalComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for ControllerEvalComponentData {
}

impl super::core::DataContainerTrait for ControllerEvalComponentData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CONTROLLEREVALCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ControllerEvalComponentData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ControllerEvalComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(ControllerEvalComponentData, realm),
            },
            FieldInfoData {
                name: "UseGameDefinedStateMachine",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ControllerEvalComponentData, use_game_defined_state_machine),
            },
            FieldInfoData {
                name: "LocoAnimatable",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterStateOwnerData",
                rust_offset: offset_of!(ControllerEvalComponentData, loco_animatable),
            },
            FieldInfoData {
                name: "SimpleInput",
                flags: MemberInfoFlags::new(144),
                field_type: "InputToGameState-Array",
                rust_offset: offset_of!(ControllerEvalComponentData, simple_input),
            },
            FieldInfoData {
                name: "IntChannelInput",
                flags: MemberInfoFlags::new(144),
                field_type: "InputToIntGameState-Array",
                rust_offset: offset_of!(ControllerEvalComponentData, int_channel_input),
            },
            FieldInfoData {
                name: "AnalogInput",
                flags: MemberInfoFlags::new(144),
                field_type: "InputToFloatGameState-Array",
                rust_offset: offset_of!(ControllerEvalComponentData, analog_input),
            },
            FieldInfoData {
                name: "Velocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(ControllerEvalComponentData, velocity),
            },
            FieldInfoData {
                name: "AngularVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(ControllerEvalComponentData, angular_velocity),
            },
            FieldInfoData {
                name: "AimYaw",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(ControllerEvalComponentData, aim_yaw),
            },
            FieldInfoData {
                name: "AimPitch",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(ControllerEvalComponentData, aim_pitch),
            },
            FieldInfoData {
                name: "Position",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(ControllerEvalComponentData, position),
            },
            FieldInfoData {
                name: "Accelerations",
                flags: MemberInfoFlags::new(144),
                field_type: "Vec3ChannelData-Array",
                rust_offset: offset_of!(ControllerEvalComponentData, accelerations),
            },
            FieldInfoData {
                name: "WeaponMoveSpeedMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(ControllerEvalComponentData, weapon_move_speed_multiplier),
            },
            FieldInfoData {
                name: "AuthoritativeVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(ControllerEvalComponentData, authoritative_velocity),
            },
            FieldInfoData {
                name: "UseAuthoritativeMotion",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(ControllerEvalComponentData, use_authoritative_motion),
            },
            FieldInfoData {
                name: "DesiredPoseChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "IntChannelData",
                rust_offset: offset_of!(ControllerEvalComponentData, desired_pose_channel),
            },
            FieldInfoData {
                name: "ChangingToPoseChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "IntChannelData",
                rust_offset: offset_of!(ControllerEvalComponentData, changing_to_pose_channel),
            },
            FieldInfoData {
                name: "WeaponTypeChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "IntChannelData",
                rust_offset: offset_of!(ControllerEvalComponentData, weapon_type_channel),
            },
            FieldInfoData {
                name: "CharacterRequestList",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterStateRequestListData",
                rust_offset: offset_of!(ControllerEvalComponentData, character_request_list),
            },
            FieldInfoData {
                name: "ReplicatedUpdateDisabled",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(ControllerEvalComponentData, replicated_update_disabled),
            },
            FieldInfoData {
                name: "OldPhysicsEmulator",
                flags: MemberInfoFlags::new(0),
                field_type: "OldPhysicsEmulatorData",
                rust_offset: offset_of!(ControllerEvalComponentData, old_physics_emulator),
            },
        ],
    }),
    array_type: Some(CONTROLLEREVALCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ControllerEvalComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        CONTROLLEREVALCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CONTROLLEREVALCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ControllerEvalComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("ControllerEvalComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct OldPhysicsEmulatorData {
    pub action_state_channel: Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>,
    pub supported_channel: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub distance_to_ground_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub max_speed_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub is_sprinting_channel: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub current_pose_channel: Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>,
    pub changing_to_pose_channel: Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>,
    pub ground_normal_channel: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub ground_material_channel: Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>,
    pub eye_position_channel: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
}

pub trait OldPhysicsEmulatorDataTrait: TypeObject {
    fn action_state_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>;
    fn supported_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn distance_to_ground_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn max_speed_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn is_sprinting_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn current_pose_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>;
    fn changing_to_pose_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>;
    fn ground_normal_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn ground_material_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>;
    fn eye_position_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
}

impl OldPhysicsEmulatorDataTrait for OldPhysicsEmulatorData {
    fn action_state_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>> {
        &self.action_state_channel
    }
    fn supported_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.supported_channel
    }
    fn distance_to_ground_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.distance_to_ground_channel
    }
    fn max_speed_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.max_speed_channel
    }
    fn is_sprinting_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.is_sprinting_channel
    }
    fn current_pose_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>> {
        &self.current_pose_channel
    }
    fn changing_to_pose_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>> {
        &self.changing_to_pose_channel
    }
    fn ground_normal_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.ground_normal_channel
    }
    fn ground_material_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>> {
        &self.ground_material_channel
    }
    fn eye_position_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.eye_position_channel
    }
}

pub static OLDPHYSICSEMULATORDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OldPhysicsEmulatorData",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<OldPhysicsEmulatorData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ActionStateChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "IntChannelData",
                rust_offset: offset_of!(OldPhysicsEmulatorData, action_state_channel),
            },
            FieldInfoData {
                name: "SupportedChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(OldPhysicsEmulatorData, supported_channel),
            },
            FieldInfoData {
                name: "DistanceToGroundChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(OldPhysicsEmulatorData, distance_to_ground_channel),
            },
            FieldInfoData {
                name: "MaxSpeedChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(OldPhysicsEmulatorData, max_speed_channel),
            },
            FieldInfoData {
                name: "IsSprintingChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(OldPhysicsEmulatorData, is_sprinting_channel),
            },
            FieldInfoData {
                name: "CurrentPoseChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "IntChannelData",
                rust_offset: offset_of!(OldPhysicsEmulatorData, current_pose_channel),
            },
            FieldInfoData {
                name: "ChangingToPoseChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "IntChannelData",
                rust_offset: offset_of!(OldPhysicsEmulatorData, changing_to_pose_channel),
            },
            FieldInfoData {
                name: "GroundNormalChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(OldPhysicsEmulatorData, ground_normal_channel),
            },
            FieldInfoData {
                name: "GroundMaterialChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "IntChannelData",
                rust_offset: offset_of!(OldPhysicsEmulatorData, ground_material_channel),
            },
            FieldInfoData {
                name: "EyePositionChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(OldPhysicsEmulatorData, eye_position_channel),
            },
        ],
    }),
    array_type: Some(OLDPHYSICSEMULATORDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for OldPhysicsEmulatorData {
    fn type_info(&self) -> &'static TypeInfo {
        OLDPHYSICSEMULATORDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static OLDPHYSICSEMULATORDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OldPhysicsEmulatorData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("OldPhysicsEmulatorData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct InputToFloatGameState {
    pub action: i32,
    pub channel_data: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
}

pub trait InputToFloatGameStateTrait: TypeObject {
    fn action(&self) -> &i32;
    fn channel_data(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
}

impl InputToFloatGameStateTrait for InputToFloatGameState {
    fn action(&self) -> &i32 {
        &self.action
    }
    fn channel_data(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.channel_data
    }
}

pub static INPUTTOFLOATGAMESTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InputToFloatGameState",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<InputToFloatGameState as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Action",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(InputToFloatGameState, action),
            },
            FieldInfoData {
                name: "ChannelData",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(InputToFloatGameState, channel_data),
            },
        ],
    }),
    array_type: Some(INPUTTOFLOATGAMESTATE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for InputToFloatGameState {
    fn type_info(&self) -> &'static TypeInfo {
        INPUTTOFLOATGAMESTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static INPUTTOFLOATGAMESTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InputToFloatGameState-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("InputToFloatGameState"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct InputToIntGameState {
    pub actions: Vec<i32>,
    pub channel_data: Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>,
    pub value: i32,
}

pub trait InputToIntGameStateTrait: TypeObject {
    fn actions(&self) -> &Vec<i32>;
    fn channel_data(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>;
    fn value(&self) -> &i32;
}

impl InputToIntGameStateTrait for InputToIntGameState {
    fn actions(&self) -> &Vec<i32> {
        &self.actions
    }
    fn channel_data(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>> {
        &self.channel_data
    }
    fn value(&self) -> &i32 {
        &self.value
    }
}

pub static INPUTTOINTGAMESTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InputToIntGameState",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<InputToIntGameState as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Actions",
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(InputToIntGameState, actions),
            },
            FieldInfoData {
                name: "ChannelData",
                flags: MemberInfoFlags::new(0),
                field_type: "IntChannelData",
                rust_offset: offset_of!(InputToIntGameState, channel_data),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(InputToIntGameState, value),
            },
        ],
    }),
    array_type: Some(INPUTTOINTGAMESTATE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for InputToIntGameState {
    fn type_info(&self) -> &'static TypeInfo {
        INPUTTOINTGAMESTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static INPUTTOINTGAMESTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InputToIntGameState-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("InputToIntGameState"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct InputToGameState {
    pub action: i32,
    pub actions: Vec<i32>,
    pub channel_data: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub edge_detect: bool,
    pub cutoff_time: f32,
    pub cutoff_time_mode: InputToGameStateCutoffTimeMode,
}

pub trait InputToGameStateTrait: TypeObject {
    fn action(&self) -> &i32;
    fn actions(&self) -> &Vec<i32>;
    fn channel_data(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn edge_detect(&self) -> &bool;
    fn cutoff_time(&self) -> &f32;
    fn cutoff_time_mode(&self) -> &InputToGameStateCutoffTimeMode;
}

impl InputToGameStateTrait for InputToGameState {
    fn action(&self) -> &i32 {
        &self.action
    }
    fn actions(&self) -> &Vec<i32> {
        &self.actions
    }
    fn channel_data(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.channel_data
    }
    fn edge_detect(&self) -> &bool {
        &self.edge_detect
    }
    fn cutoff_time(&self) -> &f32 {
        &self.cutoff_time
    }
    fn cutoff_time_mode(&self) -> &InputToGameStateCutoffTimeMode {
        &self.cutoff_time_mode
    }
}

pub static INPUTTOGAMESTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InputToGameState",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<InputToGameState as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Action",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(InputToGameState, action),
            },
            FieldInfoData {
                name: "Actions",
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(InputToGameState, actions),
            },
            FieldInfoData {
                name: "ChannelData",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(InputToGameState, channel_data),
            },
            FieldInfoData {
                name: "EdgeDetect",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(InputToGameState, edge_detect),
            },
            FieldInfoData {
                name: "CutoffTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(InputToGameState, cutoff_time),
            },
            FieldInfoData {
                name: "CutoffTimeMode",
                flags: MemberInfoFlags::new(0),
                field_type: "InputToGameStateCutoffTimeMode",
                rust_offset: offset_of!(InputToGameState, cutoff_time_mode),
            },
        ],
    }),
    array_type: Some(INPUTTOGAMESTATE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for InputToGameState {
    fn type_info(&self) -> &'static TypeInfo {
        INPUTTOGAMESTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static INPUTTOGAMESTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InputToGameState-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("InputToGameState"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum InputToGameStateCutoffTimeMode {
    #[default]
    InputToGameStateCutoffTimeMode_ReleaseAfterTime = 0,
    InputToGameStateCutoffTimeMode_ReleaseBeforeTime = 1,
    InputToGameStateCutoffTimeMode_KeepPressedUntilTime = 2,
}

pub static INPUTTOGAMESTATECUTOFFTIMEMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InputToGameStateCutoffTimeMode",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(INPUTTOGAMESTATECUTOFFTIMEMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for InputToGameStateCutoffTimeMode {
    fn type_info(&self) -> &'static TypeInfo {
        INPUTTOGAMESTATECUTOFFTIMEMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static INPUTTOGAMESTATECUTOFFTIMEMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InputToGameStateCutoffTimeMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("InputToGameStateCutoffTimeMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CharacterStateEvalComponentConstants {
    #[default]
    CharacterStateEvalComponentConstants_ChannelChangesInMessage = 6,
    CharacterStateEvalComponentConstants_BufferedChannelChanges = 20,
}

pub static CHARACTERSTATEEVALCOMPONENTCONSTANTS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateEvalComponentConstants",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(CHARACTERSTATEEVALCOMPONENTCONSTANTS_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CharacterStateEvalComponentConstants {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEEVALCOMPONENTCONSTANTS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEEVALCOMPONENTCONSTANTS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateEvalComponentConstants-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateEvalComponentConstants"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateChannelReaderEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub channels: Vec<CharacterStatePublicOrPrivateChannelData>,
    pub always_enabled: bool,
}

pub trait CharacterStateChannelReaderEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn channels(&self) -> &Vec<CharacterStatePublicOrPrivateChannelData>;
    fn always_enabled(&self) -> &bool;
}

impl CharacterStateChannelReaderEntityDataTrait for CharacterStateChannelReaderEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn channels(&self) -> &Vec<CharacterStatePublicOrPrivateChannelData> {
        &self.channels
    }
    fn always_enabled(&self) -> &bool {
        &self.always_enabled
    }
}

impl super::entity::EntityDataTrait for CharacterStateChannelReaderEntityData {
}

impl super::entity::GameObjectDataTrait for CharacterStateChannelReaderEntityData {
}

impl super::core::DataBusPeerTrait for CharacterStateChannelReaderEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for CharacterStateChannelReaderEntityData {
}

impl super::core::DataContainerTrait for CharacterStateChannelReaderEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATECHANNELREADERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateChannelReaderEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateChannelReaderEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(CharacterStateChannelReaderEntityData, realm),
            },
            FieldInfoData {
                name: "Channels",
                flags: MemberInfoFlags::new(144),
                field_type: "CharacterStatePublicOrPrivateChannelData-Array",
                rust_offset: offset_of!(CharacterStateChannelReaderEntityData, channels),
            },
            FieldInfoData {
                name: "AlwaysEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateChannelReaderEntityData, always_enabled),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATECHANNELREADERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateChannelReaderEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATECHANNELREADERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATECHANNELREADERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateChannelReaderEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateChannelReaderEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStatePublicOrPrivateChannelData {
    pub public_channel: Option<Arc<Mutex<dyn super::soldier_shared::CharacterStatePublicChannelDataTrait>>>,
    pub private_channel: Option<Arc<Mutex<dyn super::soldier_shared::ChannelDataTrait>>>,
}

pub trait CharacterStatePublicOrPrivateChannelDataTrait: TypeObject {
    fn public_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::CharacterStatePublicChannelDataTrait>>>;
    fn private_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::ChannelDataTrait>>>;
}

impl CharacterStatePublicOrPrivateChannelDataTrait for CharacterStatePublicOrPrivateChannelData {
    fn public_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::CharacterStatePublicChannelDataTrait>>> {
        &self.public_channel
    }
    fn private_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::ChannelDataTrait>>> {
        &self.private_channel
    }
}

pub static CHARACTERSTATEPUBLICORPRIVATECHANNELDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStatePublicOrPrivateChannelData",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStatePublicOrPrivateChannelData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PublicChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterStatePublicChannelData",
                rust_offset: offset_of!(CharacterStatePublicOrPrivateChannelData, public_channel),
            },
            FieldInfoData {
                name: "PrivateChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "ChannelData",
                rust_offset: offset_of!(CharacterStatePublicOrPrivateChannelData, private_channel),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEPUBLICORPRIVATECHANNELDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStatePublicOrPrivateChannelData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEPUBLICORPRIVATECHANNELDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEPUBLICORPRIVATECHANNELDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStatePublicOrPrivateChannelData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStatePublicOrPrivateChannelData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateWarpAnimationToInputControllerData {
    pub _glacier_base: CharacterStateBaseControllerData,
    pub ant_controller: super::ant::AntRef,
    pub extended_clip: Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>,
    pub position_channel: Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>,
    pub velocity_channel: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub angular_velocity_channel: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub acceleration_channel: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub root_motion_channel: Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>,
    pub connect_channel: Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>,
    pub have_external_target_channel: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub external_target_channel: Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>,
    pub dynamic_blend_weight_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub dynamic_blend_weight_translation_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub limit_to_x_z_rotation: bool,
    pub warp_translation_for_input: bool,
    pub warp_translation_for_external_target: bool,
    pub use_look_at_for_external_rotation: bool,
    pub allow_adjust_translation_opposite_to_authored_velocity: bool,
    pub static_blend_weight: f32,
    pub static_blend_weight_translation: f32,
    pub weights_channel: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub weights: super::core::Vec3,
    pub transform_from_input: WarpClipTargetConnectFromInputData,
    pub local_offset_to_target_transform: super::core::LinearTransform,
    pub store_external_align_transform_on_init: bool,
}

pub trait CharacterStateWarpAnimationToInputControllerDataTrait: CharacterStateBaseControllerDataTrait {
    fn ant_controller(&self) -> &super::ant::AntRef;
    fn extended_clip(&self) -> &Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>;
    fn position_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>;
    fn velocity_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn angular_velocity_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn acceleration_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn root_motion_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>;
    fn connect_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>;
    fn have_external_target_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn external_target_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>;
    fn dynamic_blend_weight_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn dynamic_blend_weight_translation_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn limit_to_x_z_rotation(&self) -> &bool;
    fn warp_translation_for_input(&self) -> &bool;
    fn warp_translation_for_external_target(&self) -> &bool;
    fn use_look_at_for_external_rotation(&self) -> &bool;
    fn allow_adjust_translation_opposite_to_authored_velocity(&self) -> &bool;
    fn static_blend_weight(&self) -> &f32;
    fn static_blend_weight_translation(&self) -> &f32;
    fn weights_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn weights(&self) -> &super::core::Vec3;
    fn transform_from_input(&self) -> &WarpClipTargetConnectFromInputData;
    fn local_offset_to_target_transform(&self) -> &super::core::LinearTransform;
    fn store_external_align_transform_on_init(&self) -> &bool;
}

impl CharacterStateWarpAnimationToInputControllerDataTrait for CharacterStateWarpAnimationToInputControllerData {
    fn ant_controller(&self) -> &super::ant::AntRef {
        &self.ant_controller
    }
    fn extended_clip(&self) -> &Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>> {
        &self.extended_clip
    }
    fn position_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>> {
        &self.position_channel
    }
    fn velocity_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.velocity_channel
    }
    fn angular_velocity_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.angular_velocity_channel
    }
    fn acceleration_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.acceleration_channel
    }
    fn root_motion_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>> {
        &self.root_motion_channel
    }
    fn connect_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>> {
        &self.connect_channel
    }
    fn have_external_target_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.have_external_target_channel
    }
    fn external_target_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>> {
        &self.external_target_channel
    }
    fn dynamic_blend_weight_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.dynamic_blend_weight_channel
    }
    fn dynamic_blend_weight_translation_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.dynamic_blend_weight_translation_channel
    }
    fn limit_to_x_z_rotation(&self) -> &bool {
        &self.limit_to_x_z_rotation
    }
    fn warp_translation_for_input(&self) -> &bool {
        &self.warp_translation_for_input
    }
    fn warp_translation_for_external_target(&self) -> &bool {
        &self.warp_translation_for_external_target
    }
    fn use_look_at_for_external_rotation(&self) -> &bool {
        &self.use_look_at_for_external_rotation
    }
    fn allow_adjust_translation_opposite_to_authored_velocity(&self) -> &bool {
        &self.allow_adjust_translation_opposite_to_authored_velocity
    }
    fn static_blend_weight(&self) -> &f32 {
        &self.static_blend_weight
    }
    fn static_blend_weight_translation(&self) -> &f32 {
        &self.static_blend_weight_translation
    }
    fn weights_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.weights_channel
    }
    fn weights(&self) -> &super::core::Vec3 {
        &self.weights
    }
    fn transform_from_input(&self) -> &WarpClipTargetConnectFromInputData {
        &self.transform_from_input
    }
    fn local_offset_to_target_transform(&self) -> &super::core::LinearTransform {
        &self.local_offset_to_target_transform
    }
    fn store_external_align_transform_on_init(&self) -> &bool {
        &self.store_external_align_transform_on_init
    }
}

impl CharacterStateBaseControllerDataTrait for CharacterStateWarpAnimationToInputControllerData {
    fn asset_index(&self) -> &i32 {
        self._glacier_base.asset_index()
    }
    fn subjects(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>> {
        self._glacier_base.subjects()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for CharacterStateWarpAnimationToInputControllerData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATEWARPANIMATIONTOINPUTCONTROLLERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateWarpAnimationToInputControllerData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEBASECONTROLLERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateWarpAnimationToInputControllerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AntController",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CharacterStateWarpAnimationToInputControllerData, ant_controller),
            },
            FieldInfoData {
                name: "ExtendedClip",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterStateBaseControllerData",
                rust_offset: offset_of!(CharacterStateWarpAnimationToInputControllerData, extended_clip),
            },
            FieldInfoData {
                name: "PositionChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(CharacterStateWarpAnimationToInputControllerData, position_channel),
            },
            FieldInfoData {
                name: "VelocityChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateWarpAnimationToInputControllerData, velocity_channel),
            },
            FieldInfoData {
                name: "AngularVelocityChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateWarpAnimationToInputControllerData, angular_velocity_channel),
            },
            FieldInfoData {
                name: "AccelerationChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateWarpAnimationToInputControllerData, acceleration_channel),
            },
            FieldInfoData {
                name: "RootMotionChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(CharacterStateWarpAnimationToInputControllerData, root_motion_channel),
            },
            FieldInfoData {
                name: "ConnectChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(CharacterStateWarpAnimationToInputControllerData, connect_channel),
            },
            FieldInfoData {
                name: "HaveExternalTargetChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(CharacterStateWarpAnimationToInputControllerData, have_external_target_channel),
            },
            FieldInfoData {
                name: "ExternalTargetChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(CharacterStateWarpAnimationToInputControllerData, external_target_channel),
            },
            FieldInfoData {
                name: "DynamicBlendWeightChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateWarpAnimationToInputControllerData, dynamic_blend_weight_channel),
            },
            FieldInfoData {
                name: "DynamicBlendWeightTranslationChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateWarpAnimationToInputControllerData, dynamic_blend_weight_translation_channel),
            },
            FieldInfoData {
                name: "LimitToXZRotation",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateWarpAnimationToInputControllerData, limit_to_x_z_rotation),
            },
            FieldInfoData {
                name: "WarpTranslationForInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateWarpAnimationToInputControllerData, warp_translation_for_input),
            },
            FieldInfoData {
                name: "WarpTranslationForExternalTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateWarpAnimationToInputControllerData, warp_translation_for_external_target),
            },
            FieldInfoData {
                name: "UseLookAtForExternalRotation",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateWarpAnimationToInputControllerData, use_look_at_for_external_rotation),
            },
            FieldInfoData {
                name: "AllowAdjustTranslationOppositeToAuthoredVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateWarpAnimationToInputControllerData, allow_adjust_translation_opposite_to_authored_velocity),
            },
            FieldInfoData {
                name: "StaticBlendWeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateWarpAnimationToInputControllerData, static_blend_weight),
            },
            FieldInfoData {
                name: "StaticBlendWeightTranslation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateWarpAnimationToInputControllerData, static_blend_weight_translation),
            },
            FieldInfoData {
                name: "WeightsChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateWarpAnimationToInputControllerData, weights_channel),
            },
            FieldInfoData {
                name: "Weights",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(CharacterStateWarpAnimationToInputControllerData, weights),
            },
            FieldInfoData {
                name: "TransformFromInput",
                flags: MemberInfoFlags::new(0),
                field_type: "WarpClipTargetConnectFromInputData",
                rust_offset: offset_of!(CharacterStateWarpAnimationToInputControllerData, transform_from_input),
            },
            FieldInfoData {
                name: "LocalOffsetToTargetTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(CharacterStateWarpAnimationToInputControllerData, local_offset_to_target_transform),
            },
            FieldInfoData {
                name: "StoreExternalAlignTransformOnInit",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateWarpAnimationToInputControllerData, store_external_align_transform_on_init),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEWARPANIMATIONTOINPUTCONTROLLERDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CharacterStateWarpAnimationToInputControllerData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEWARPANIMATIONTOINPUTCONTROLLERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEWARPANIMATIONTOINPUTCONTROLLERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateWarpAnimationToInputControllerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateWarpAnimationToInputControllerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WarpClipTargetConnectFromInputData {
    pub throttle_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub strafe_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub offset: f32,
    pub movement_yaw_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub require_input_for_using_movement_yaw: bool,
    pub throttle_constant_addition: f32,
    pub strafe_constant_addition: f32,
}

pub trait WarpClipTargetConnectFromInputDataTrait: TypeObject {
    fn throttle_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn strafe_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn offset(&self) -> &f32;
    fn movement_yaw_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn require_input_for_using_movement_yaw(&self) -> &bool;
    fn throttle_constant_addition(&self) -> &f32;
    fn strafe_constant_addition(&self) -> &f32;
}

impl WarpClipTargetConnectFromInputDataTrait for WarpClipTargetConnectFromInputData {
    fn throttle_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.throttle_channel
    }
    fn strafe_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.strafe_channel
    }
    fn offset(&self) -> &f32 {
        &self.offset
    }
    fn movement_yaw_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.movement_yaw_channel
    }
    fn require_input_for_using_movement_yaw(&self) -> &bool {
        &self.require_input_for_using_movement_yaw
    }
    fn throttle_constant_addition(&self) -> &f32 {
        &self.throttle_constant_addition
    }
    fn strafe_constant_addition(&self) -> &f32 {
        &self.strafe_constant_addition
    }
}

pub static WARPCLIPTARGETCONNECTFROMINPUTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WarpClipTargetConnectFromInputData",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WarpClipTargetConnectFromInputData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ThrottleChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(WarpClipTargetConnectFromInputData, throttle_channel),
            },
            FieldInfoData {
                name: "StrafeChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(WarpClipTargetConnectFromInputData, strafe_channel),
            },
            FieldInfoData {
                name: "Offset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WarpClipTargetConnectFromInputData, offset),
            },
            FieldInfoData {
                name: "MovementYawChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(WarpClipTargetConnectFromInputData, movement_yaw_channel),
            },
            FieldInfoData {
                name: "RequireInputForUsingMovementYaw",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WarpClipTargetConnectFromInputData, require_input_for_using_movement_yaw),
            },
            FieldInfoData {
                name: "ThrottleConstantAddition",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WarpClipTargetConnectFromInputData, throttle_constant_addition),
            },
            FieldInfoData {
                name: "StrafeConstantAddition",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WarpClipTargetConnectFromInputData, strafe_constant_addition),
            },
        ],
    }),
    array_type: Some(WARPCLIPTARGETCONNECTFROMINPUTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WarpClipTargetConnectFromInputData {
    fn type_info(&self) -> &'static TypeInfo {
        WARPCLIPTARGETCONNECTFROMINPUTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static WARPCLIPTARGETCONNECTFROMINPUTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WarpClipTargetConnectFromInputData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("WarpClipTargetConnectFromInputData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateTimeControllerData {
    pub _glacier_base: CharacterStateBaseControllerData,
    pub static_time_scale: f32,
    pub dynamic_time_scale: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
}

pub trait CharacterStateTimeControllerDataTrait: CharacterStateBaseControllerDataTrait {
    fn static_time_scale(&self) -> &f32;
    fn dynamic_time_scale(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
}

impl CharacterStateTimeControllerDataTrait for CharacterStateTimeControllerData {
    fn static_time_scale(&self) -> &f32 {
        &self.static_time_scale
    }
    fn dynamic_time_scale(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.dynamic_time_scale
    }
}

impl CharacterStateBaseControllerDataTrait for CharacterStateTimeControllerData {
    fn asset_index(&self) -> &i32 {
        self._glacier_base.asset_index()
    }
    fn subjects(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>> {
        self._glacier_base.subjects()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for CharacterStateTimeControllerData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATETIMECONTROLLERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateTimeControllerData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEBASECONTROLLERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateTimeControllerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "StaticTimeScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateTimeControllerData, static_time_scale),
            },
            FieldInfoData {
                name: "DynamicTimeScale",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateTimeControllerData, dynamic_time_scale),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATETIMECONTROLLERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateTimeControllerData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATETIMECONTROLLERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATETIMECONTROLLERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateTimeControllerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateTimeControllerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateStateFlowControllerData {
    pub _glacier_base: CharacterStateBaseControllerData,
    pub ant_state_flow_controller: super::ant::AntRef,
}

pub trait CharacterStateStateFlowControllerDataTrait: CharacterStateBaseControllerDataTrait {
    fn ant_state_flow_controller(&self) -> &super::ant::AntRef;
}

impl CharacterStateStateFlowControllerDataTrait for CharacterStateStateFlowControllerData {
    fn ant_state_flow_controller(&self) -> &super::ant::AntRef {
        &self.ant_state_flow_controller
    }
}

impl CharacterStateBaseControllerDataTrait for CharacterStateStateFlowControllerData {
    fn asset_index(&self) -> &i32 {
        self._glacier_base.asset_index()
    }
    fn subjects(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>> {
        self._glacier_base.subjects()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for CharacterStateStateFlowControllerData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATESTATEFLOWCONTROLLERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateStateFlowControllerData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEBASECONTROLLERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateStateFlowControllerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AntStateFlowController",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CharacterStateStateFlowControllerData, ant_state_flow_controller),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATESTATEFLOWCONTROLLERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateStateFlowControllerData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATESTATEFLOWCONTROLLERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATESTATEFLOWCONTROLLERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateStateFlowControllerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateStateFlowControllerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateStateFlowNodeControllerData {
    pub _glacier_base: CharacterStateBaseControllerData,
    pub transitions: Vec<TransitionCondition>,
    pub channel_controllers: Vec<Option<Arc<Mutex<dyn CharacterStateKeyframedChannelControllerDataTrait>>>>,
}

pub trait CharacterStateStateFlowNodeControllerDataTrait: CharacterStateBaseControllerDataTrait {
    fn transitions(&self) -> &Vec<TransitionCondition>;
    fn channel_controllers(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateKeyframedChannelControllerDataTrait>>>>;
}

impl CharacterStateStateFlowNodeControllerDataTrait for CharacterStateStateFlowNodeControllerData {
    fn transitions(&self) -> &Vec<TransitionCondition> {
        &self.transitions
    }
    fn channel_controllers(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateKeyframedChannelControllerDataTrait>>>> {
        &self.channel_controllers
    }
}

impl CharacterStateBaseControllerDataTrait for CharacterStateStateFlowNodeControllerData {
    fn asset_index(&self) -> &i32 {
        self._glacier_base.asset_index()
    }
    fn subjects(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>> {
        self._glacier_base.subjects()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for CharacterStateStateFlowNodeControllerData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATESTATEFLOWNODECONTROLLERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateStateFlowNodeControllerData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEBASECONTROLLERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateStateFlowNodeControllerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Transitions",
                flags: MemberInfoFlags::new(144),
                field_type: "TransitionCondition-Array",
                rust_offset: offset_of!(CharacterStateStateFlowNodeControllerData, transitions),
            },
            FieldInfoData {
                name: "ChannelControllers",
                flags: MemberInfoFlags::new(144),
                field_type: "CharacterStateKeyframedChannelControllerData-Array",
                rust_offset: offset_of!(CharacterStateStateFlowNodeControllerData, channel_controllers),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATESTATEFLOWNODECONTROLLERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateStateFlowNodeControllerData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATESTATEFLOWNODECONTROLLERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATESTATEFLOWNODECONTROLLERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateStateFlowNodeControllerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateStateFlowNodeControllerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TransitionCondition {
    pub child_conditions: Vec<TransitionCondition>,
    pub target: Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>,
    pub blend: Option<Arc<Mutex<dyn CharacterStateTransitionControllerDataTrait>>>,
    pub always_active: bool,
    pub start_tick: u32,
    pub length: u32,
    pub condition_type: TransitionConditionType,
    pub bool_channel1: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub bool_channel2: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub bool_compare_mode: TransitionConditionBoolCompareMode,
    pub int_channel: Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>,
    pub int_value: i32,
    pub float_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub float_value: f32,
    pub invert: bool,
    pub numeric_compare_mode: TransitionConditionNumericCompareMode,
}

pub trait TransitionConditionTrait: TypeObject {
    fn child_conditions(&self) -> &Vec<TransitionCondition>;
    fn target(&self) -> &Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>;
    fn blend(&self) -> &Option<Arc<Mutex<dyn CharacterStateTransitionControllerDataTrait>>>;
    fn always_active(&self) -> &bool;
    fn start_tick(&self) -> &u32;
    fn length(&self) -> &u32;
    fn condition_type(&self) -> &TransitionConditionType;
    fn bool_channel1(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn bool_channel2(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn bool_compare_mode(&self) -> &TransitionConditionBoolCompareMode;
    fn int_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>;
    fn int_value(&self) -> &i32;
    fn float_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn float_value(&self) -> &f32;
    fn invert(&self) -> &bool;
    fn numeric_compare_mode(&self) -> &TransitionConditionNumericCompareMode;
}

impl TransitionConditionTrait for TransitionCondition {
    fn child_conditions(&self) -> &Vec<TransitionCondition> {
        &self.child_conditions
    }
    fn target(&self) -> &Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>> {
        &self.target
    }
    fn blend(&self) -> &Option<Arc<Mutex<dyn CharacterStateTransitionControllerDataTrait>>> {
        &self.blend
    }
    fn always_active(&self) -> &bool {
        &self.always_active
    }
    fn start_tick(&self) -> &u32 {
        &self.start_tick
    }
    fn length(&self) -> &u32 {
        &self.length
    }
    fn condition_type(&self) -> &TransitionConditionType {
        &self.condition_type
    }
    fn bool_channel1(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.bool_channel1
    }
    fn bool_channel2(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.bool_channel2
    }
    fn bool_compare_mode(&self) -> &TransitionConditionBoolCompareMode {
        &self.bool_compare_mode
    }
    fn int_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>> {
        &self.int_channel
    }
    fn int_value(&self) -> &i32 {
        &self.int_value
    }
    fn float_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.float_channel
    }
    fn float_value(&self) -> &f32 {
        &self.float_value
    }
    fn invert(&self) -> &bool {
        &self.invert
    }
    fn numeric_compare_mode(&self) -> &TransitionConditionNumericCompareMode {
        &self.numeric_compare_mode
    }
}

pub static TRANSITIONCONDITION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransitionCondition",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransitionCondition as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ChildConditions",
                flags: MemberInfoFlags::new(144),
                field_type: "TransitionCondition-Array",
                rust_offset: offset_of!(TransitionCondition, child_conditions),
            },
            FieldInfoData {
                name: "Target",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterStateBaseControllerData",
                rust_offset: offset_of!(TransitionCondition, target),
            },
            FieldInfoData {
                name: "Blend",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterStateTransitionControllerData",
                rust_offset: offset_of!(TransitionCondition, blend),
            },
            FieldInfoData {
                name: "AlwaysActive",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TransitionCondition, always_active),
            },
            FieldInfoData {
                name: "StartTick",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(TransitionCondition, start_tick),
            },
            FieldInfoData {
                name: "Length",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(TransitionCondition, length),
            },
            FieldInfoData {
                name: "ConditionType",
                flags: MemberInfoFlags::new(0),
                field_type: "TransitionConditionType",
                rust_offset: offset_of!(TransitionCondition, condition_type),
            },
            FieldInfoData {
                name: "BoolChannel1",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(TransitionCondition, bool_channel1),
            },
            FieldInfoData {
                name: "BoolChannel2",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(TransitionCondition, bool_channel2),
            },
            FieldInfoData {
                name: "BoolCompareMode",
                flags: MemberInfoFlags::new(0),
                field_type: "TransitionConditionBoolCompareMode",
                rust_offset: offset_of!(TransitionCondition, bool_compare_mode),
            },
            FieldInfoData {
                name: "IntChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "IntChannelData",
                rust_offset: offset_of!(TransitionCondition, int_channel),
            },
            FieldInfoData {
                name: "IntValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(TransitionCondition, int_value),
            },
            FieldInfoData {
                name: "FloatChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(TransitionCondition, float_channel),
            },
            FieldInfoData {
                name: "FloatValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TransitionCondition, float_value),
            },
            FieldInfoData {
                name: "Invert",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TransitionCondition, invert),
            },
            FieldInfoData {
                name: "NumericCompareMode",
                flags: MemberInfoFlags::new(0),
                field_type: "TransitionConditionNumericCompareMode",
                rust_offset: offset_of!(TransitionCondition, numeric_compare_mode),
            },
        ],
    }),
    array_type: Some(TRANSITIONCONDITION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TransitionCondition {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSITIONCONDITION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static TRANSITIONCONDITION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransitionCondition-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("TransitionCondition"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum TransitionConditionNumericCompareMode {
    #[default]
    TransitionConditionNumericCompareMode_Equals = 0,
    TransitionConditionNumericCompareMode_NotEquals = 1,
    TransitionConditionNumericCompareMode_LessThan = 2,
    TransitionConditionNumericCompareMode_GreaterThan = 3,
}

pub static TRANSITIONCONDITIONNUMERICCOMPAREMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransitionConditionNumericCompareMode",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(TRANSITIONCONDITIONNUMERICCOMPAREMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for TransitionConditionNumericCompareMode {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSITIONCONDITIONNUMERICCOMPAREMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static TRANSITIONCONDITIONNUMERICCOMPAREMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransitionConditionNumericCompareMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("TransitionConditionNumericCompareMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum TransitionConditionBoolCompareMode {
    #[default]
    TransitionConditionBoolCompareMode_Equals = 0,
    TransitionConditionBoolCompareMode_NotEquals = 1,
    TransitionConditionBoolCompareMode_And = 2,
    TransitionConditionBoolCompareMode_Or = 3,
    TransitionConditionBoolCompareMode_Inverse = 4,
}

pub static TRANSITIONCONDITIONBOOLCOMPAREMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransitionConditionBoolCompareMode",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(TRANSITIONCONDITIONBOOLCOMPAREMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for TransitionConditionBoolCompareMode {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSITIONCONDITIONBOOLCOMPAREMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static TRANSITIONCONDITIONBOOLCOMPAREMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransitionConditionBoolCompareMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("TransitionConditionBoolCompareMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum TransitionConditionType {
    #[default]
    TransitionConditionType_None = 0,
    TransitionConditionType_Bool = 1,
    TransitionConditionType_Int = 2,
    TransitionConditionType_Float = 3,
}

pub static TRANSITIONCONDITIONTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransitionConditionType",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(TRANSITIONCONDITIONTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for TransitionConditionType {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSITIONCONDITIONTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static TRANSITIONCONDITIONTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransitionConditionType-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("TransitionConditionType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateTransitionControllerData {
    pub _glacier_base: CharacterStateBaseControllerData,
    pub blend_time: u32,
    pub physics_blend_time: u32,
    pub phase_mode: CharacterStateTransitionPhaseMode,
    pub to_phase: f32,
    pub to_phase_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub channel_controllers: Vec<Option<Arc<Mutex<dyn CharacterStateKeyframedChannelControllerDataTrait>>>>,
    pub controller: super::ant::AntRef,
}

pub trait CharacterStateTransitionControllerDataTrait: CharacterStateBaseControllerDataTrait {
    fn blend_time(&self) -> &u32;
    fn physics_blend_time(&self) -> &u32;
    fn phase_mode(&self) -> &CharacterStateTransitionPhaseMode;
    fn to_phase(&self) -> &f32;
    fn to_phase_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn channel_controllers(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateKeyframedChannelControllerDataTrait>>>>;
    fn controller(&self) -> &super::ant::AntRef;
}

impl CharacterStateTransitionControllerDataTrait for CharacterStateTransitionControllerData {
    fn blend_time(&self) -> &u32 {
        &self.blend_time
    }
    fn physics_blend_time(&self) -> &u32 {
        &self.physics_blend_time
    }
    fn phase_mode(&self) -> &CharacterStateTransitionPhaseMode {
        &self.phase_mode
    }
    fn to_phase(&self) -> &f32 {
        &self.to_phase
    }
    fn to_phase_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.to_phase_channel
    }
    fn channel_controllers(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateKeyframedChannelControllerDataTrait>>>> {
        &self.channel_controllers
    }
    fn controller(&self) -> &super::ant::AntRef {
        &self.controller
    }
}

impl CharacterStateBaseControllerDataTrait for CharacterStateTransitionControllerData {
    fn asset_index(&self) -> &i32 {
        self._glacier_base.asset_index()
    }
    fn subjects(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>> {
        self._glacier_base.subjects()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for CharacterStateTransitionControllerData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATETRANSITIONCONTROLLERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateTransitionControllerData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEBASECONTROLLERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateTransitionControllerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "BlendTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(CharacterStateTransitionControllerData, blend_time),
            },
            FieldInfoData {
                name: "PhysicsBlendTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(CharacterStateTransitionControllerData, physics_blend_time),
            },
            FieldInfoData {
                name: "PhaseMode",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterStateTransitionPhaseMode",
                rust_offset: offset_of!(CharacterStateTransitionControllerData, phase_mode),
            },
            FieldInfoData {
                name: "ToPhase",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateTransitionControllerData, to_phase),
            },
            FieldInfoData {
                name: "ToPhaseChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateTransitionControllerData, to_phase_channel),
            },
            FieldInfoData {
                name: "ChannelControllers",
                flags: MemberInfoFlags::new(144),
                field_type: "CharacterStateKeyframedChannelControllerData-Array",
                rust_offset: offset_of!(CharacterStateTransitionControllerData, channel_controllers),
            },
            FieldInfoData {
                name: "Controller",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CharacterStateTransitionControllerData, controller),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATETRANSITIONCONTROLLERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateTransitionControllerData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATETRANSITIONCONTROLLERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATETRANSITIONCONTROLLERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateTransitionControllerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateTransitionControllerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CharacterStateTransitionPhaseMode {
    #[default]
    CharacterStateTransitionPhaseMode_FromStart = 0,
    CharacterStateTransitionPhaseMode_InPhase = 1,
    CharacterStateTransitionPhaseMode_ToPhase = 2,
}

pub static CHARACTERSTATETRANSITIONPHASEMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateTransitionPhaseMode",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(CHARACTERSTATETRANSITIONPHASEMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CharacterStateTransitionPhaseMode {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATETRANSITIONPHASEMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATETRANSITIONPHASEMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateTransitionPhaseMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateTransitionPhaseMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStatePoseMatchingControllerData {
    pub _glacier_base: CharacterStateBaseControllerData,
    pub included_channels: Option<Arc<Mutex<dyn super::soldier_shared::ChannelSetDataTrait>>>,
    pub connect_transform_channel: Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>,
    pub target_connect_transform_channel: Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>,
    pub pos_and_rot_channel: Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>,
    pub extra_channels: Vec<Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>>,
    pub child_controller_extracted_info: Vec<ExtractedClipInfo>,
    pub match_position_weight: super::core::Vec3,
    pub match_rotation_weight: super::core::Vec3,
    pub ant_controller: super::ant::AntRef,
}

pub trait CharacterStatePoseMatchingControllerDataTrait: CharacterStateBaseControllerDataTrait {
    fn included_channels(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::ChannelSetDataTrait>>>;
    fn connect_transform_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>;
    fn target_connect_transform_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>;
    fn pos_and_rot_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>;
    fn extra_channels(&self) -> &Vec<Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>>;
    fn child_controller_extracted_info(&self) -> &Vec<ExtractedClipInfo>;
    fn match_position_weight(&self) -> &super::core::Vec3;
    fn match_rotation_weight(&self) -> &super::core::Vec3;
    fn ant_controller(&self) -> &super::ant::AntRef;
}

impl CharacterStatePoseMatchingControllerDataTrait for CharacterStatePoseMatchingControllerData {
    fn included_channels(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::ChannelSetDataTrait>>> {
        &self.included_channels
    }
    fn connect_transform_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>> {
        &self.connect_transform_channel
    }
    fn target_connect_transform_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>> {
        &self.target_connect_transform_channel
    }
    fn pos_and_rot_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>> {
        &self.pos_and_rot_channel
    }
    fn extra_channels(&self) -> &Vec<Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>> {
        &self.extra_channels
    }
    fn child_controller_extracted_info(&self) -> &Vec<ExtractedClipInfo> {
        &self.child_controller_extracted_info
    }
    fn match_position_weight(&self) -> &super::core::Vec3 {
        &self.match_position_weight
    }
    fn match_rotation_weight(&self) -> &super::core::Vec3 {
        &self.match_rotation_weight
    }
    fn ant_controller(&self) -> &super::ant::AntRef {
        &self.ant_controller
    }
}

impl CharacterStateBaseControllerDataTrait for CharacterStatePoseMatchingControllerData {
    fn asset_index(&self) -> &i32 {
        self._glacier_base.asset_index()
    }
    fn subjects(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>> {
        self._glacier_base.subjects()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for CharacterStatePoseMatchingControllerData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATEPOSEMATCHINGCONTROLLERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStatePoseMatchingControllerData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEBASECONTROLLERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStatePoseMatchingControllerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "IncludedChannels",
                flags: MemberInfoFlags::new(0),
                field_type: "ChannelSetData",
                rust_offset: offset_of!(CharacterStatePoseMatchingControllerData, included_channels),
            },
            FieldInfoData {
                name: "ConnectTransformChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(CharacterStatePoseMatchingControllerData, connect_transform_channel),
            },
            FieldInfoData {
                name: "TargetConnectTransformChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(CharacterStatePoseMatchingControllerData, target_connect_transform_channel),
            },
            FieldInfoData {
                name: "PosAndRotChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(CharacterStatePoseMatchingControllerData, pos_and_rot_channel),
            },
            FieldInfoData {
                name: "ExtraChannels",
                flags: MemberInfoFlags::new(144),
                field_type: "TransformChannelData-Array",
                rust_offset: offset_of!(CharacterStatePoseMatchingControllerData, extra_channels),
            },
            FieldInfoData {
                name: "ChildControllerExtractedInfo",
                flags: MemberInfoFlags::new(144),
                field_type: "ExtractedClipInfo-Array",
                rust_offset: offset_of!(CharacterStatePoseMatchingControllerData, child_controller_extracted_info),
            },
            FieldInfoData {
                name: "MatchPositionWeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(CharacterStatePoseMatchingControllerData, match_position_weight),
            },
            FieldInfoData {
                name: "MatchRotationWeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(CharacterStatePoseMatchingControllerData, match_rotation_weight),
            },
            FieldInfoData {
                name: "AntController",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CharacterStatePoseMatchingControllerData, ant_controller),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEPOSEMATCHINGCONTROLLERDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CharacterStatePoseMatchingControllerData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEPOSEMATCHINGCONTROLLERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEPOSEMATCHINGCONTROLLERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStatePoseMatchingControllerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStatePoseMatchingControllerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ExtractedClipInfo {
    pub channel_controller: Option<Arc<Mutex<dyn CharacterStateKeyframedTransformChannelControllerDataTrait>>>,
    pub keyframes: Vec<i32>,
}

pub trait ExtractedClipInfoTrait: TypeObject {
    fn channel_controller(&self) -> &Option<Arc<Mutex<dyn CharacterStateKeyframedTransformChannelControllerDataTrait>>>;
    fn keyframes(&self) -> &Vec<i32>;
}

impl ExtractedClipInfoTrait for ExtractedClipInfo {
    fn channel_controller(&self) -> &Option<Arc<Mutex<dyn CharacterStateKeyframedTransformChannelControllerDataTrait>>> {
        &self.channel_controller
    }
    fn keyframes(&self) -> &Vec<i32> {
        &self.keyframes
    }
}

pub static EXTRACTEDCLIPINFO_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExtractedClipInfo",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ExtractedClipInfo as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ChannelController",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterStateKeyframedTransformChannelControllerData",
                rust_offset: offset_of!(ExtractedClipInfo, channel_controller),
            },
            FieldInfoData {
                name: "Keyframes",
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(ExtractedClipInfo, keyframes),
            },
        ],
    }),
    array_type: Some(EXTRACTEDCLIPINFO_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ExtractedClipInfo {
    fn type_info(&self) -> &'static TypeInfo {
        EXTRACTEDCLIPINFO_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static EXTRACTEDCLIPINFO_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExtractedClipInfo-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("ExtractedClipInfo"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStatePairedClipControllerData {
    pub _glacier_base: CharacterStateBaseControllerData,
    pub ant_controller: super::ant::AntRef,
    pub acceleration_channel: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub velocity_channel: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub angular_velocity_channel: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub position_channel: Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>,
    pub connect_channel: Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>,
    pub target_connect_channel: Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>,
    pub blend_weight_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
}

pub trait CharacterStatePairedClipControllerDataTrait: CharacterStateBaseControllerDataTrait {
    fn ant_controller(&self) -> &super::ant::AntRef;
    fn acceleration_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn velocity_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn angular_velocity_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn position_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>;
    fn connect_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>;
    fn target_connect_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>;
    fn blend_weight_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
}

impl CharacterStatePairedClipControllerDataTrait for CharacterStatePairedClipControllerData {
    fn ant_controller(&self) -> &super::ant::AntRef {
        &self.ant_controller
    }
    fn acceleration_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.acceleration_channel
    }
    fn velocity_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.velocity_channel
    }
    fn angular_velocity_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.angular_velocity_channel
    }
    fn position_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>> {
        &self.position_channel
    }
    fn connect_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>> {
        &self.connect_channel
    }
    fn target_connect_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>> {
        &self.target_connect_channel
    }
    fn blend_weight_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.blend_weight_channel
    }
}

impl CharacterStateBaseControllerDataTrait for CharacterStatePairedClipControllerData {
    fn asset_index(&self) -> &i32 {
        self._glacier_base.asset_index()
    }
    fn subjects(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>> {
        self._glacier_base.subjects()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for CharacterStatePairedClipControllerData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATEPAIREDCLIPCONTROLLERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStatePairedClipControllerData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEBASECONTROLLERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStatePairedClipControllerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AntController",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CharacterStatePairedClipControllerData, ant_controller),
            },
            FieldInfoData {
                name: "AccelerationChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStatePairedClipControllerData, acceleration_channel),
            },
            FieldInfoData {
                name: "VelocityChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStatePairedClipControllerData, velocity_channel),
            },
            FieldInfoData {
                name: "AngularVelocityChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStatePairedClipControllerData, angular_velocity_channel),
            },
            FieldInfoData {
                name: "PositionChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(CharacterStatePairedClipControllerData, position_channel),
            },
            FieldInfoData {
                name: "ConnectChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(CharacterStatePairedClipControllerData, connect_channel),
            },
            FieldInfoData {
                name: "TargetConnectChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(CharacterStatePairedClipControllerData, target_connect_channel),
            },
            FieldInfoData {
                name: "BlendWeightChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStatePairedClipControllerData, blend_weight_channel),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEPAIREDCLIPCONTROLLERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStatePairedClipControllerData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEPAIREDCLIPCONTROLLERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEPAIREDCLIPCONTROLLERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStatePairedClipControllerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStatePairedClipControllerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VehicleWeaponPlayerAbilityNetState {
    pub dumb_fire_cooldown: f32,
    pub next_shot_cooldown: f32,
    pub num_shots_fired: i32,
    pub num_targets: i32,
    pub is_firing: bool,
}

pub trait VehicleWeaponPlayerAbilityNetStateTrait: TypeObject {
    fn dumb_fire_cooldown(&self) -> &f32;
    fn next_shot_cooldown(&self) -> &f32;
    fn num_shots_fired(&self) -> &i32;
    fn num_targets(&self) -> &i32;
    fn is_firing(&self) -> &bool;
}

impl VehicleWeaponPlayerAbilityNetStateTrait for VehicleWeaponPlayerAbilityNetState {
    fn dumb_fire_cooldown(&self) -> &f32 {
        &self.dumb_fire_cooldown
    }
    fn next_shot_cooldown(&self) -> &f32 {
        &self.next_shot_cooldown
    }
    fn num_shots_fired(&self) -> &i32 {
        &self.num_shots_fired
    }
    fn num_targets(&self) -> &i32 {
        &self.num_targets
    }
    fn is_firing(&self) -> &bool {
        &self.is_firing
    }
}

pub static VEHICLEWEAPONPLAYERABILITYNETSTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleWeaponPlayerAbilityNetState",
    flags: MemberInfoFlags::new(36937),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleWeaponPlayerAbilityNetState as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DumbFireCooldown",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleWeaponPlayerAbilityNetState, dumb_fire_cooldown),
            },
            FieldInfoData {
                name: "NextShotCooldown",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleWeaponPlayerAbilityNetState, next_shot_cooldown),
            },
            FieldInfoData {
                name: "NumShotsFired",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(VehicleWeaponPlayerAbilityNetState, num_shots_fired),
            },
            FieldInfoData {
                name: "NumTargets",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(VehicleWeaponPlayerAbilityNetState, num_targets),
            },
            FieldInfoData {
                name: "IsFiring",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleWeaponPlayerAbilityNetState, is_firing),
            },
        ],
    }),
    array_type: Some(VEHICLEWEAPONPLAYERABILITYNETSTATE_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for VehicleWeaponPlayerAbilityNetState {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLEWEAPONPLAYERABILITYNETSTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VEHICLEWEAPONPLAYERABILITYNETSTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleWeaponPlayerAbilityNetState-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("VehicleWeaponPlayerAbilityNetState"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoldierWeaponPlayerAbilityNetState {
    pub is_active: bool,
    pub freeze_active_time: bool,
}

pub trait SoldierWeaponPlayerAbilityNetStateTrait: TypeObject {
    fn is_active(&self) -> &bool;
    fn freeze_active_time(&self) -> &bool;
}

impl SoldierWeaponPlayerAbilityNetStateTrait for SoldierWeaponPlayerAbilityNetState {
    fn is_active(&self) -> &bool {
        &self.is_active
    }
    fn freeze_active_time(&self) -> &bool {
        &self.freeze_active_time
    }
}

pub static SOLDIERWEAPONPLAYERABILITYNETSTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierWeaponPlayerAbilityNetState",
    flags: MemberInfoFlags::new(36937),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierWeaponPlayerAbilityNetState as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "IsActive",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierWeaponPlayerAbilityNetState, is_active),
            },
            FieldInfoData {
                name: "FreezeActiveTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierWeaponPlayerAbilityNetState, freeze_active_time),
            },
        ],
    }),
    array_type: Some(SOLDIERWEAPONPLAYERABILITYNETSTATE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SoldierWeaponPlayerAbilityNetState {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERWEAPONPLAYERABILITYNETSTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SOLDIERWEAPONPLAYERABILITYNETSTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierWeaponPlayerAbilityNetState-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("SoldierWeaponPlayerAbilityNetState"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStatePlayerAbilityNetState {
    pub state_change_timeout: f32,
    pub charge: f32,
    pub is_running: bool,
    pub retriggers: u32,
    pub is_stop_trigger: bool,
}

pub trait CharacterStatePlayerAbilityNetStateTrait: TypeObject {
    fn state_change_timeout(&self) -> &f32;
    fn charge(&self) -> &f32;
    fn is_running(&self) -> &bool;
    fn retriggers(&self) -> &u32;
    fn is_stop_trigger(&self) -> &bool;
}

impl CharacterStatePlayerAbilityNetStateTrait for CharacterStatePlayerAbilityNetState {
    fn state_change_timeout(&self) -> &f32 {
        &self.state_change_timeout
    }
    fn charge(&self) -> &f32 {
        &self.charge
    }
    fn is_running(&self) -> &bool {
        &self.is_running
    }
    fn retriggers(&self) -> &u32 {
        &self.retriggers
    }
    fn is_stop_trigger(&self) -> &bool {
        &self.is_stop_trigger
    }
}

pub static CHARACTERSTATEPLAYERABILITYNETSTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStatePlayerAbilityNetState",
    flags: MemberInfoFlags::new(36937),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStatePlayerAbilityNetState as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "StateChangeTimeout",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStatePlayerAbilityNetState, state_change_timeout),
            },
            FieldInfoData {
                name: "Charge",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStatePlayerAbilityNetState, charge),
            },
            FieldInfoData {
                name: "IsRunning",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStatePlayerAbilityNetState, is_running),
            },
            FieldInfoData {
                name: "Retriggers",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(CharacterStatePlayerAbilityNetState, retriggers),
            },
            FieldInfoData {
                name: "IsStopTrigger",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStatePlayerAbilityNetState, is_stop_trigger),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEPLAYERABILITYNETSTATE_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for CharacterStatePlayerAbilityNetState {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEPLAYERABILITYNETSTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEPLAYERABILITYNETSTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStatePlayerAbilityNetState-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStatePlayerAbilityNetState"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RechargeablePlayerAbilityNetState {
    pub recharge_time: f32,
}

pub trait RechargeablePlayerAbilityNetStateTrait: TypeObject {
    fn recharge_time(&self) -> &f32;
}

impl RechargeablePlayerAbilityNetStateTrait for RechargeablePlayerAbilityNetState {
    fn recharge_time(&self) -> &f32 {
        &self.recharge_time
    }
}

pub static RECHARGEABLEPLAYERABILITYNETSTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RechargeablePlayerAbilityNetState",
    flags: MemberInfoFlags::new(36937),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RechargeablePlayerAbilityNetState as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "RechargeTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RechargeablePlayerAbilityNetState, recharge_time),
            },
        ],
    }),
    array_type: Some(RECHARGEABLEPLAYERABILITYNETSTATE_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for RechargeablePlayerAbilityNetState {
    fn type_info(&self) -> &'static TypeInfo {
        RECHARGEABLEPLAYERABILITYNETSTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static RECHARGEABLEPLAYERABILITYNETSTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RechargeablePlayerAbilityNetState-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("RechargeablePlayerAbilityNetState"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RetriggerablePlayerAbilityNetState {
    pub retriggerable_count: u32,
    pub trigger_event: u32,
    pub retrigger_cooldown: f32,
    pub retrigger_hold_time: f32,
    pub retriggerable: bool,
}

pub trait RetriggerablePlayerAbilityNetStateTrait: TypeObject {
    fn retriggerable_count(&self) -> &u32;
    fn trigger_event(&self) -> &u32;
    fn retrigger_cooldown(&self) -> &f32;
    fn retrigger_hold_time(&self) -> &f32;
    fn retriggerable(&self) -> &bool;
}

impl RetriggerablePlayerAbilityNetStateTrait for RetriggerablePlayerAbilityNetState {
    fn retriggerable_count(&self) -> &u32 {
        &self.retriggerable_count
    }
    fn trigger_event(&self) -> &u32 {
        &self.trigger_event
    }
    fn retrigger_cooldown(&self) -> &f32 {
        &self.retrigger_cooldown
    }
    fn retrigger_hold_time(&self) -> &f32 {
        &self.retrigger_hold_time
    }
    fn retriggerable(&self) -> &bool {
        &self.retriggerable
    }
}

pub static RETRIGGERABLEPLAYERABILITYNETSTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RetriggerablePlayerAbilityNetState",
    flags: MemberInfoFlags::new(36937),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RetriggerablePlayerAbilityNetState as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "RetriggerableCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(RetriggerablePlayerAbilityNetState, retriggerable_count),
            },
            FieldInfoData {
                name: "TriggerEvent",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(RetriggerablePlayerAbilityNetState, trigger_event),
            },
            FieldInfoData {
                name: "RetriggerCooldown",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RetriggerablePlayerAbilityNetState, retrigger_cooldown),
            },
            FieldInfoData {
                name: "RetriggerHoldTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RetriggerablePlayerAbilityNetState, retrigger_hold_time),
            },
            FieldInfoData {
                name: "Retriggerable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RetriggerablePlayerAbilityNetState, retriggerable),
            },
        ],
    }),
    array_type: Some(RETRIGGERABLEPLAYERABILITYNETSTATE_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for RetriggerablePlayerAbilityNetState {
    fn type_info(&self) -> &'static TypeInfo {
        RETRIGGERABLEPLAYERABILITYNETSTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static RETRIGGERABLEPLAYERABILITYNETSTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RetriggerablePlayerAbilityNetState-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("RetriggerablePlayerAbilityNetState"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EmptyPlayerAbilityNetState {
    pub dummy: bool,
}

pub trait EmptyPlayerAbilityNetStateTrait: TypeObject {
    fn dummy(&self) -> &bool;
}

impl EmptyPlayerAbilityNetStateTrait for EmptyPlayerAbilityNetState {
    fn dummy(&self) -> &bool {
        &self.dummy
    }
}

pub static EMPTYPLAYERABILITYNETSTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EmptyPlayerAbilityNetState",
    flags: MemberInfoFlags::new(36937),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EmptyPlayerAbilityNetState as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Dummy",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EmptyPlayerAbilityNetState, dummy),
            },
        ],
    }),
    array_type: Some(EMPTYPLAYERABILITYNETSTATE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for EmptyPlayerAbilityNetState {
    fn type_info(&self) -> &'static TypeInfo {
        EMPTYPLAYERABILITYNETSTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static EMPTYPLAYERABILITYNETSTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EmptyPlayerAbilityNetState-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("EmptyPlayerAbilityNetState"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlayerAbilityPropertyModifier {
    pub _glacier_base: PlayerAbilityModifier,
    pub values: Vec<Option<Arc<Mutex<dyn PlayerAbilityPropertyModifierValueTrait>>>>,
}

pub trait PlayerAbilityPropertyModifierTrait: PlayerAbilityModifierTrait {
    fn values(&self) -> &Vec<Option<Arc<Mutex<dyn PlayerAbilityPropertyModifierValueTrait>>>>;
}

impl PlayerAbilityPropertyModifierTrait for PlayerAbilityPropertyModifier {
    fn values(&self) -> &Vec<Option<Arc<Mutex<dyn PlayerAbilityPropertyModifierValueTrait>>>> {
        &self.values
    }
}

impl PlayerAbilityModifierTrait for PlayerAbilityPropertyModifier {
    fn required_unlock_id(&self) -> &u32 {
        self._glacier_base.required_unlock_id()
    }
}

impl super::core::DataContainerTrait for PlayerAbilityPropertyModifier {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PLAYERABILITYPROPERTYMODIFIER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityPropertyModifier",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PLAYERABILITYMODIFIER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayerAbilityPropertyModifier as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Values",
                flags: MemberInfoFlags::new(144),
                field_type: "PlayerAbilityPropertyModifierValue-Array",
                rust_offset: offset_of!(PlayerAbilityPropertyModifier, values),
            },
        ],
    }),
    array_type: Some(PLAYERABILITYPROPERTYMODIFIER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PlayerAbilityPropertyModifier {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERABILITYPROPERTYMODIFIER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PLAYERABILITYPROPERTYMODIFIER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityPropertyModifier-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PlayerAbilityPropertyModifier"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlayerAbilityPropertyModifierTriggerCostValue {
    pub _glacier_base: PlayerAbilityPropertyModifierValue,
    pub trigger_cost: f32,
}

pub trait PlayerAbilityPropertyModifierTriggerCostValueTrait: PlayerAbilityPropertyModifierValueTrait {
    fn trigger_cost(&self) -> &f32;
}

impl PlayerAbilityPropertyModifierTriggerCostValueTrait for PlayerAbilityPropertyModifierTriggerCostValue {
    fn trigger_cost(&self) -> &f32 {
        &self.trigger_cost
    }
}

impl PlayerAbilityPropertyModifierValueTrait for PlayerAbilityPropertyModifierTriggerCostValue {
}

impl super::core::DataContainerTrait for PlayerAbilityPropertyModifierTriggerCostValue {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PLAYERABILITYPROPERTYMODIFIERTRIGGERCOSTVALUE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityPropertyModifierTriggerCostValue",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PLAYERABILITYPROPERTYMODIFIERVALUE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayerAbilityPropertyModifierTriggerCostValue as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "TriggerCost",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PlayerAbilityPropertyModifierTriggerCostValue, trigger_cost),
            },
        ],
    }),
    array_type: Some(PLAYERABILITYPROPERTYMODIFIERTRIGGERCOSTVALUE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PlayerAbilityPropertyModifierTriggerCostValue {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERABILITYPROPERTYMODIFIERTRIGGERCOSTVALUE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PLAYERABILITYPROPERTYMODIFIERTRIGGERCOSTVALUE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityPropertyModifierTriggerCostValue-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PlayerAbilityPropertyModifierTriggerCostValue"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlayerAbilityPropertyModifierChargeCountValue {
    pub _glacier_base: PlayerAbilityPropertyModifierValue,
    pub charge_count: i32,
    pub start_charge_count: i32,
}

pub trait PlayerAbilityPropertyModifierChargeCountValueTrait: PlayerAbilityPropertyModifierValueTrait {
    fn charge_count(&self) -> &i32;
    fn start_charge_count(&self) -> &i32;
}

impl PlayerAbilityPropertyModifierChargeCountValueTrait for PlayerAbilityPropertyModifierChargeCountValue {
    fn charge_count(&self) -> &i32 {
        &self.charge_count
    }
    fn start_charge_count(&self) -> &i32 {
        &self.start_charge_count
    }
}

impl PlayerAbilityPropertyModifierValueTrait for PlayerAbilityPropertyModifierChargeCountValue {
}

impl super::core::DataContainerTrait for PlayerAbilityPropertyModifierChargeCountValue {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PLAYERABILITYPROPERTYMODIFIERCHARGECOUNTVALUE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityPropertyModifierChargeCountValue",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PLAYERABILITYPROPERTYMODIFIERVALUE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayerAbilityPropertyModifierChargeCountValue as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ChargeCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(PlayerAbilityPropertyModifierChargeCountValue, charge_count),
            },
            FieldInfoData {
                name: "StartChargeCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(PlayerAbilityPropertyModifierChargeCountValue, start_charge_count),
            },
        ],
    }),
    array_type: Some(PLAYERABILITYPROPERTYMODIFIERCHARGECOUNTVALUE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PlayerAbilityPropertyModifierChargeCountValue {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERABILITYPROPERTYMODIFIERCHARGECOUNTVALUE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PLAYERABILITYPROPERTYMODIFIERCHARGECOUNTVALUE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityPropertyModifierChargeCountValue-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PlayerAbilityPropertyModifierChargeCountValue"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlayerAbilityPropertyModifierActivationValue {
    pub _glacier_base: PlayerAbilityPropertyModifierValue,
    pub activation_time: f32,
}

pub trait PlayerAbilityPropertyModifierActivationValueTrait: PlayerAbilityPropertyModifierValueTrait {
    fn activation_time(&self) -> &f32;
}

impl PlayerAbilityPropertyModifierActivationValueTrait for PlayerAbilityPropertyModifierActivationValue {
    fn activation_time(&self) -> &f32 {
        &self.activation_time
    }
}

impl PlayerAbilityPropertyModifierValueTrait for PlayerAbilityPropertyModifierActivationValue {
}

impl super::core::DataContainerTrait for PlayerAbilityPropertyModifierActivationValue {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PLAYERABILITYPROPERTYMODIFIERACTIVATIONVALUE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityPropertyModifierActivationValue",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PLAYERABILITYPROPERTYMODIFIERVALUE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayerAbilityPropertyModifierActivationValue as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ActivationTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PlayerAbilityPropertyModifierActivationValue, activation_time),
            },
        ],
    }),
    array_type: Some(PLAYERABILITYPROPERTYMODIFIERACTIVATIONVALUE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PlayerAbilityPropertyModifierActivationValue {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERABILITYPROPERTYMODIFIERACTIVATIONVALUE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PLAYERABILITYPROPERTYMODIFIERACTIVATIONVALUE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityPropertyModifierActivationValue-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PlayerAbilityPropertyModifierActivationValue"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlayerAbilityPropertyModifierActiveValue {
    pub _glacier_base: PlayerAbilityPropertyModifierValue,
    pub active_time: f32,
}

pub trait PlayerAbilityPropertyModifierActiveValueTrait: PlayerAbilityPropertyModifierValueTrait {
    fn active_time(&self) -> &f32;
}

impl PlayerAbilityPropertyModifierActiveValueTrait for PlayerAbilityPropertyModifierActiveValue {
    fn active_time(&self) -> &f32 {
        &self.active_time
    }
}

impl PlayerAbilityPropertyModifierValueTrait for PlayerAbilityPropertyModifierActiveValue {
}

impl super::core::DataContainerTrait for PlayerAbilityPropertyModifierActiveValue {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PLAYERABILITYPROPERTYMODIFIERACTIVEVALUE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityPropertyModifierActiveValue",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PLAYERABILITYPROPERTYMODIFIERVALUE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayerAbilityPropertyModifierActiveValue as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ActiveTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PlayerAbilityPropertyModifierActiveValue, active_time),
            },
        ],
    }),
    array_type: Some(PLAYERABILITYPROPERTYMODIFIERACTIVEVALUE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PlayerAbilityPropertyModifierActiveValue {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERABILITYPROPERTYMODIFIERACTIVEVALUE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PLAYERABILITYPROPERTYMODIFIERACTIVEVALUE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityPropertyModifierActiveValue-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PlayerAbilityPropertyModifierActiveValue"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlayerAbilityPropertyModifierRechargeValue {
    pub _glacier_base: PlayerAbilityPropertyModifierValue,
    pub recharge_time: f32,
}

pub trait PlayerAbilityPropertyModifierRechargeValueTrait: PlayerAbilityPropertyModifierValueTrait {
    fn recharge_time(&self) -> &f32;
}

impl PlayerAbilityPropertyModifierRechargeValueTrait for PlayerAbilityPropertyModifierRechargeValue {
    fn recharge_time(&self) -> &f32 {
        &self.recharge_time
    }
}

impl PlayerAbilityPropertyModifierValueTrait for PlayerAbilityPropertyModifierRechargeValue {
}

impl super::core::DataContainerTrait for PlayerAbilityPropertyModifierRechargeValue {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PLAYERABILITYPROPERTYMODIFIERRECHARGEVALUE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityPropertyModifierRechargeValue",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PLAYERABILITYPROPERTYMODIFIERVALUE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayerAbilityPropertyModifierRechargeValue as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "RechargeTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PlayerAbilityPropertyModifierRechargeValue, recharge_time),
            },
        ],
    }),
    array_type: Some(PLAYERABILITYPROPERTYMODIFIERRECHARGEVALUE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PlayerAbilityPropertyModifierRechargeValue {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERABILITYPROPERTYMODIFIERRECHARGEVALUE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PLAYERABILITYPROPERTYMODIFIERRECHARGEVALUE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityPropertyModifierRechargeValue-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PlayerAbilityPropertyModifierRechargeValue"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlayerAbilityPropertyModifierValue {
    pub _glacier_base: super::core::DataContainer,
}

pub trait PlayerAbilityPropertyModifierValueTrait: super::core::DataContainerTrait {
}

impl PlayerAbilityPropertyModifierValueTrait for PlayerAbilityPropertyModifierValue {
}

impl super::core::DataContainerTrait for PlayerAbilityPropertyModifierValue {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PLAYERABILITYPROPERTYMODIFIERVALUE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityPropertyModifierValue",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayerAbilityPropertyModifierValue as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(PLAYERABILITYPROPERTYMODIFIERVALUE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PlayerAbilityPropertyModifierValue {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERABILITYPROPERTYMODIFIERVALUE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PLAYERABILITYPROPERTYMODIFIERVALUE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityPropertyModifierValue-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PlayerAbilityPropertyModifierValue"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlayerAbilityModifierUnlockModifier {
    pub _glacier_base: PlayerAbilityModifier,
    pub unlock_id: u32,
    pub min_ability_level: PlayerAbilityLevel,
    pub max_ability_level: PlayerAbilityLevel,
}

pub trait PlayerAbilityModifierUnlockModifierTrait: PlayerAbilityModifierTrait {
    fn unlock_id(&self) -> &u32;
    fn min_ability_level(&self) -> &PlayerAbilityLevel;
    fn max_ability_level(&self) -> &PlayerAbilityLevel;
}

impl PlayerAbilityModifierUnlockModifierTrait for PlayerAbilityModifierUnlockModifier {
    fn unlock_id(&self) -> &u32 {
        &self.unlock_id
    }
    fn min_ability_level(&self) -> &PlayerAbilityLevel {
        &self.min_ability_level
    }
    fn max_ability_level(&self) -> &PlayerAbilityLevel {
        &self.max_ability_level
    }
}

impl PlayerAbilityModifierTrait for PlayerAbilityModifierUnlockModifier {
    fn required_unlock_id(&self) -> &u32 {
        self._glacier_base.required_unlock_id()
    }
}

impl super::core::DataContainerTrait for PlayerAbilityModifierUnlockModifier {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PLAYERABILITYMODIFIERUNLOCKMODIFIER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityModifierUnlockModifier",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PLAYERABILITYMODIFIER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayerAbilityModifierUnlockModifier as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "UnlockId",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(PlayerAbilityModifierUnlockModifier, unlock_id),
            },
            FieldInfoData {
                name: "MinAbilityLevel",
                flags: MemberInfoFlags::new(0),
                field_type: "PlayerAbilityLevel",
                rust_offset: offset_of!(PlayerAbilityModifierUnlockModifier, min_ability_level),
            },
            FieldInfoData {
                name: "MaxAbilityLevel",
                flags: MemberInfoFlags::new(0),
                field_type: "PlayerAbilityLevel",
                rust_offset: offset_of!(PlayerAbilityModifierUnlockModifier, max_ability_level),
            },
        ],
    }),
    array_type: Some(PLAYERABILITYMODIFIERUNLOCKMODIFIER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PlayerAbilityModifierUnlockModifier {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERABILITYMODIFIERUNLOCKMODIFIER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PLAYERABILITYMODIFIERUNLOCKMODIFIER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityModifierUnlockModifier-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PlayerAbilityModifierUnlockModifier"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlayerAbilityPropertyOutputModifier {
    pub _glacier_base: PlayerAbilityModifier,
    pub output_hash: u32,
    pub values: Vec<Option<Arc<Mutex<dyn PlayerAbilityPropertyOutputModifierValueTrait>>>>,
}

pub trait PlayerAbilityPropertyOutputModifierTrait: PlayerAbilityModifierTrait {
    fn output_hash(&self) -> &u32;
    fn values(&self) -> &Vec<Option<Arc<Mutex<dyn PlayerAbilityPropertyOutputModifierValueTrait>>>>;
}

impl PlayerAbilityPropertyOutputModifierTrait for PlayerAbilityPropertyOutputModifier {
    fn output_hash(&self) -> &u32 {
        &self.output_hash
    }
    fn values(&self) -> &Vec<Option<Arc<Mutex<dyn PlayerAbilityPropertyOutputModifierValueTrait>>>> {
        &self.values
    }
}

impl PlayerAbilityModifierTrait for PlayerAbilityPropertyOutputModifier {
    fn required_unlock_id(&self) -> &u32 {
        self._glacier_base.required_unlock_id()
    }
}

impl super::core::DataContainerTrait for PlayerAbilityPropertyOutputModifier {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PLAYERABILITYPROPERTYOUTPUTMODIFIER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityPropertyOutputModifier",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PLAYERABILITYMODIFIER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayerAbilityPropertyOutputModifier as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "OutputHash",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(PlayerAbilityPropertyOutputModifier, output_hash),
            },
            FieldInfoData {
                name: "Values",
                flags: MemberInfoFlags::new(144),
                field_type: "PlayerAbilityPropertyOutputModifierValue-Array",
                rust_offset: offset_of!(PlayerAbilityPropertyOutputModifier, values),
            },
        ],
    }),
    array_type: Some(PLAYERABILITYPROPERTYOUTPUTMODIFIER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PlayerAbilityPropertyOutputModifier {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERABILITYPROPERTYOUTPUTMODIFIER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PLAYERABILITYPROPERTYOUTPUTMODIFIER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityPropertyOutputModifier-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PlayerAbilityPropertyOutputModifier"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlayerAbilityModifier {
    pub _glacier_base: super::core::DataContainer,
    pub required_unlock_id: u32,
}

pub trait PlayerAbilityModifierTrait: super::core::DataContainerTrait {
    fn required_unlock_id(&self) -> &u32;
}

impl PlayerAbilityModifierTrait for PlayerAbilityModifier {
    fn required_unlock_id(&self) -> &u32 {
        &self.required_unlock_id
    }
}

impl super::core::DataContainerTrait for PlayerAbilityModifier {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PLAYERABILITYMODIFIER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityModifier",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayerAbilityModifier as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "RequiredUnlockId",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(PlayerAbilityModifier, required_unlock_id),
            },
        ],
    }),
    array_type: Some(PLAYERABILITYMODIFIER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PlayerAbilityModifier {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERABILITYMODIFIER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PLAYERABILITYMODIFIER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityModifier-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PlayerAbilityModifier"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlayerAbilityPropertyOutputIntModifierValue {
    pub _glacier_base: PlayerAbilityPropertyOutputModifierValue,
    pub value: i32,
}

pub trait PlayerAbilityPropertyOutputIntModifierValueTrait: PlayerAbilityPropertyOutputModifierValueTrait {
    fn value(&self) -> &i32;
}

impl PlayerAbilityPropertyOutputIntModifierValueTrait for PlayerAbilityPropertyOutputIntModifierValue {
    fn value(&self) -> &i32 {
        &self.value
    }
}

impl PlayerAbilityPropertyOutputModifierValueTrait for PlayerAbilityPropertyOutputIntModifierValue {
    fn min_ability_level(&self) -> &PlayerAbilityLevel {
        self._glacier_base.min_ability_level()
    }
    fn max_ability_level(&self) -> &PlayerAbilityLevel {
        self._glacier_base.max_ability_level()
    }
}

impl super::core::DataContainerTrait for PlayerAbilityPropertyOutputIntModifierValue {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PLAYERABILITYPROPERTYOUTPUTINTMODIFIERVALUE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityPropertyOutputIntModifierValue",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PLAYERABILITYPROPERTYOUTPUTMODIFIERVALUE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayerAbilityPropertyOutputIntModifierValue as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(PlayerAbilityPropertyOutputIntModifierValue, value),
            },
        ],
    }),
    array_type: Some(PLAYERABILITYPROPERTYOUTPUTINTMODIFIERVALUE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PlayerAbilityPropertyOutputIntModifierValue {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERABILITYPROPERTYOUTPUTINTMODIFIERVALUE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PLAYERABILITYPROPERTYOUTPUTINTMODIFIERVALUE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityPropertyOutputIntModifierValue-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PlayerAbilityPropertyOutputIntModifierValue"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlayerAbilityPropertyOutputFloatModifierValue {
    pub _glacier_base: PlayerAbilityPropertyOutputModifierValue,
    pub value: f32,
}

pub trait PlayerAbilityPropertyOutputFloatModifierValueTrait: PlayerAbilityPropertyOutputModifierValueTrait {
    fn value(&self) -> &f32;
}

impl PlayerAbilityPropertyOutputFloatModifierValueTrait for PlayerAbilityPropertyOutputFloatModifierValue {
    fn value(&self) -> &f32 {
        &self.value
    }
}

impl PlayerAbilityPropertyOutputModifierValueTrait for PlayerAbilityPropertyOutputFloatModifierValue {
    fn min_ability_level(&self) -> &PlayerAbilityLevel {
        self._glacier_base.min_ability_level()
    }
    fn max_ability_level(&self) -> &PlayerAbilityLevel {
        self._glacier_base.max_ability_level()
    }
}

impl super::core::DataContainerTrait for PlayerAbilityPropertyOutputFloatModifierValue {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PLAYERABILITYPROPERTYOUTPUTFLOATMODIFIERVALUE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityPropertyOutputFloatModifierValue",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PLAYERABILITYPROPERTYOUTPUTMODIFIERVALUE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayerAbilityPropertyOutputFloatModifierValue as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PlayerAbilityPropertyOutputFloatModifierValue, value),
            },
        ],
    }),
    array_type: Some(PLAYERABILITYPROPERTYOUTPUTFLOATMODIFIERVALUE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PlayerAbilityPropertyOutputFloatModifierValue {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERABILITYPROPERTYOUTPUTFLOATMODIFIERVALUE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PLAYERABILITYPROPERTYOUTPUTFLOATMODIFIERVALUE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityPropertyOutputFloatModifierValue-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PlayerAbilityPropertyOutputFloatModifierValue"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlayerAbilityPropertyOutputVec3ModifierValue {
    pub _glacier_base: PlayerAbilityPropertyOutputModifierValue,
    pub value: super::core::Vec3,
}

pub trait PlayerAbilityPropertyOutputVec3ModifierValueTrait: PlayerAbilityPropertyOutputModifierValueTrait {
    fn value(&self) -> &super::core::Vec3;
}

impl PlayerAbilityPropertyOutputVec3ModifierValueTrait for PlayerAbilityPropertyOutputVec3ModifierValue {
    fn value(&self) -> &super::core::Vec3 {
        &self.value
    }
}

impl PlayerAbilityPropertyOutputModifierValueTrait for PlayerAbilityPropertyOutputVec3ModifierValue {
    fn min_ability_level(&self) -> &PlayerAbilityLevel {
        self._glacier_base.min_ability_level()
    }
    fn max_ability_level(&self) -> &PlayerAbilityLevel {
        self._glacier_base.max_ability_level()
    }
}

impl super::core::DataContainerTrait for PlayerAbilityPropertyOutputVec3ModifierValue {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PLAYERABILITYPROPERTYOUTPUTVEC3MODIFIERVALUE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityPropertyOutputVec3ModifierValue",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PLAYERABILITYPROPERTYOUTPUTMODIFIERVALUE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayerAbilityPropertyOutputVec3ModifierValue as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(PlayerAbilityPropertyOutputVec3ModifierValue, value),
            },
        ],
    }),
    array_type: Some(PLAYERABILITYPROPERTYOUTPUTVEC3MODIFIERVALUE_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PlayerAbilityPropertyOutputVec3ModifierValue {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERABILITYPROPERTYOUTPUTVEC3MODIFIERVALUE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PLAYERABILITYPROPERTYOUTPUTVEC3MODIFIERVALUE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityPropertyOutputVec3ModifierValue-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PlayerAbilityPropertyOutputVec3ModifierValue"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlayerAbilityPropertyOutputBoolModifierValue {
    pub _glacier_base: PlayerAbilityPropertyOutputModifierValue,
    pub value: bool,
}

pub trait PlayerAbilityPropertyOutputBoolModifierValueTrait: PlayerAbilityPropertyOutputModifierValueTrait {
    fn value(&self) -> &bool;
}

impl PlayerAbilityPropertyOutputBoolModifierValueTrait for PlayerAbilityPropertyOutputBoolModifierValue {
    fn value(&self) -> &bool {
        &self.value
    }
}

impl PlayerAbilityPropertyOutputModifierValueTrait for PlayerAbilityPropertyOutputBoolModifierValue {
    fn min_ability_level(&self) -> &PlayerAbilityLevel {
        self._glacier_base.min_ability_level()
    }
    fn max_ability_level(&self) -> &PlayerAbilityLevel {
        self._glacier_base.max_ability_level()
    }
}

impl super::core::DataContainerTrait for PlayerAbilityPropertyOutputBoolModifierValue {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PLAYERABILITYPROPERTYOUTPUTBOOLMODIFIERVALUE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityPropertyOutputBoolModifierValue",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PLAYERABILITYPROPERTYOUTPUTMODIFIERVALUE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayerAbilityPropertyOutputBoolModifierValue as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayerAbilityPropertyOutputBoolModifierValue, value),
            },
        ],
    }),
    array_type: Some(PLAYERABILITYPROPERTYOUTPUTBOOLMODIFIERVALUE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PlayerAbilityPropertyOutputBoolModifierValue {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERABILITYPROPERTYOUTPUTBOOLMODIFIERVALUE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PLAYERABILITYPROPERTYOUTPUTBOOLMODIFIERVALUE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityPropertyOutputBoolModifierValue-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PlayerAbilityPropertyOutputBoolModifierValue"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlayerAbilityPropertyOutputModifierValue {
    pub _glacier_base: super::core::DataContainer,
    pub min_ability_level: PlayerAbilityLevel,
    pub max_ability_level: PlayerAbilityLevel,
}

pub trait PlayerAbilityPropertyOutputModifierValueTrait: super::core::DataContainerTrait {
    fn min_ability_level(&self) -> &PlayerAbilityLevel;
    fn max_ability_level(&self) -> &PlayerAbilityLevel;
}

impl PlayerAbilityPropertyOutputModifierValueTrait for PlayerAbilityPropertyOutputModifierValue {
    fn min_ability_level(&self) -> &PlayerAbilityLevel {
        &self.min_ability_level
    }
    fn max_ability_level(&self) -> &PlayerAbilityLevel {
        &self.max_ability_level
    }
}

impl super::core::DataContainerTrait for PlayerAbilityPropertyOutputModifierValue {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PLAYERABILITYPROPERTYOUTPUTMODIFIERVALUE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityPropertyOutputModifierValue",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayerAbilityPropertyOutputModifierValue as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MinAbilityLevel",
                flags: MemberInfoFlags::new(0),
                field_type: "PlayerAbilityLevel",
                rust_offset: offset_of!(PlayerAbilityPropertyOutputModifierValue, min_ability_level),
            },
            FieldInfoData {
                name: "MaxAbilityLevel",
                flags: MemberInfoFlags::new(0),
                field_type: "PlayerAbilityLevel",
                rust_offset: offset_of!(PlayerAbilityPropertyOutputModifierValue, max_ability_level),
            },
        ],
    }),
    array_type: Some(PLAYERABILITYPROPERTYOUTPUTMODIFIERVALUE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PlayerAbilityPropertyOutputModifierValue {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERABILITYPROPERTYOUTPUTMODIFIERVALUE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PLAYERABILITYPROPERTYOUTPUTMODIFIERVALUE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityPropertyOutputModifierValue-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PlayerAbilityPropertyOutputModifierValue"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlayerAbilityUsedMessage {
}

pub trait PlayerAbilityUsedMessageTrait: TypeObject {
}

impl PlayerAbilityUsedMessageTrait for PlayerAbilityUsedMessage {
}

pub static PLAYERABILITYUSEDMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityUsedMessage",
    flags: MemberInfoFlags::new(36937),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayerAbilityUsedMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for PlayerAbilityUsedMessage {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERABILITYUSEDMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}

#[derive(Clone, Debug, Default)]
pub struct PlayerAbilityActivatedMessage {
}

pub trait PlayerAbilityActivatedMessageTrait: TypeObject {
}

impl PlayerAbilityActivatedMessageTrait for PlayerAbilityActivatedMessage {
}

pub static PLAYERABILITYACTIVATEDMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityActivatedMessage",
    flags: MemberInfoFlags::new(36937),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayerAbilityActivatedMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for PlayerAbilityActivatedMessage {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERABILITYACTIVATEDMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}

#[derive(Clone, Debug, Default)]
pub struct PlayerAbilityReplacedMessage {
}

pub trait PlayerAbilityReplacedMessageTrait: TypeObject {
}

impl PlayerAbilityReplacedMessageTrait for PlayerAbilityReplacedMessage {
}

pub static PLAYERABILITYREPLACEDMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityReplacedMessage",
    flags: MemberInfoFlags::new(36937),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayerAbilityReplacedMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for PlayerAbilityReplacedMessage {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERABILITYREPLACEDMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}

#[derive(Clone, Debug, Default)]
pub struct PlayerAbilityWeaponUpgradesUpdatedMessage {
}

pub trait PlayerAbilityWeaponUpgradesUpdatedMessageTrait: TypeObject {
}

impl PlayerAbilityWeaponUpgradesUpdatedMessageTrait for PlayerAbilityWeaponUpgradesUpdatedMessage {
}

pub static PLAYERABILITYWEAPONUPGRADESUPDATEDMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityWeaponUpgradesUpdatedMessage",
    flags: MemberInfoFlags::new(36937),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayerAbilityWeaponUpgradesUpdatedMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for PlayerAbilityWeaponUpgradesUpdatedMessage {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERABILITYWEAPONUPGRADESUPDATEDMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}

#[derive(Clone, Debug, Default)]
pub struct PlayerAbilityEntryInputContainer {
    pub actions: Vec<AbilityAction>,
}

pub trait PlayerAbilityEntryInputContainerTrait: TypeObject {
    fn actions(&self) -> &Vec<AbilityAction>;
}

impl PlayerAbilityEntryInputContainerTrait for PlayerAbilityEntryInputContainer {
    fn actions(&self) -> &Vec<AbilityAction> {
        &self.actions
    }
}

pub static PLAYERABILITYENTRYINPUTCONTAINER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityEntryInputContainer",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayerAbilityEntryInputContainer as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Actions",
                flags: MemberInfoFlags::new(144),
                field_type: "AbilityAction-Array",
                rust_offset: offset_of!(PlayerAbilityEntryInputContainer, actions),
            },
        ],
    }),
    array_type: Some(PLAYERABILITYENTRYINPUTCONTAINER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PlayerAbilityEntryInputContainer {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERABILITYENTRYINPUTCONTAINER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PLAYERABILITYENTRYINPUTCONTAINER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityEntryInputContainer-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PlayerAbilityEntryInputContainer"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AbilityCategoryInputMapping {
    pub category: PlayerAbilityCategory,
    pub action: i32,
    pub cutoff_time: f32,
    pub cutoff_time_mode: AbilityInputCutoffTimeMode,
}

pub trait AbilityCategoryInputMappingTrait: TypeObject {
    fn category(&self) -> &PlayerAbilityCategory;
    fn action(&self) -> &i32;
    fn cutoff_time(&self) -> &f32;
    fn cutoff_time_mode(&self) -> &AbilityInputCutoffTimeMode;
}

impl AbilityCategoryInputMappingTrait for AbilityCategoryInputMapping {
    fn category(&self) -> &PlayerAbilityCategory {
        &self.category
    }
    fn action(&self) -> &i32 {
        &self.action
    }
    fn cutoff_time(&self) -> &f32 {
        &self.cutoff_time
    }
    fn cutoff_time_mode(&self) -> &AbilityInputCutoffTimeMode {
        &self.cutoff_time_mode
    }
}

pub static ABILITYCATEGORYINPUTMAPPING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AbilityCategoryInputMapping",
    flags: MemberInfoFlags::new(36937),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AbilityCategoryInputMapping as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Category",
                flags: MemberInfoFlags::new(0),
                field_type: "PlayerAbilityCategory",
                rust_offset: offset_of!(AbilityCategoryInputMapping, category),
            },
            FieldInfoData {
                name: "Action",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AbilityCategoryInputMapping, action),
            },
            FieldInfoData {
                name: "CutoffTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AbilityCategoryInputMapping, cutoff_time),
            },
            FieldInfoData {
                name: "CutoffTimeMode",
                flags: MemberInfoFlags::new(0),
                field_type: "AbilityInputCutoffTimeMode",
                rust_offset: offset_of!(AbilityCategoryInputMapping, cutoff_time_mode),
            },
        ],
    }),
    array_type: Some(ABILITYCATEGORYINPUTMAPPING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AbilityCategoryInputMapping {
    fn type_info(&self) -> &'static TypeInfo {
        ABILITYCATEGORYINPUTMAPPING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ABILITYCATEGORYINPUTMAPPING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AbilityCategoryInputMapping-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("AbilityCategoryInputMapping"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AbilityAction {
    pub action: i32,
    pub cutoff_time: f32,
    pub cutoff_time_mode: AbilityInputCutoffTimeMode,
}

pub trait AbilityActionTrait: TypeObject {
    fn action(&self) -> &i32;
    fn cutoff_time(&self) -> &f32;
    fn cutoff_time_mode(&self) -> &AbilityInputCutoffTimeMode;
}

impl AbilityActionTrait for AbilityAction {
    fn action(&self) -> &i32 {
        &self.action
    }
    fn cutoff_time(&self) -> &f32 {
        &self.cutoff_time
    }
    fn cutoff_time_mode(&self) -> &AbilityInputCutoffTimeMode {
        &self.cutoff_time_mode
    }
}

pub static ABILITYACTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AbilityAction",
    flags: MemberInfoFlags::new(36937),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AbilityAction as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Action",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AbilityAction, action),
            },
            FieldInfoData {
                name: "CutoffTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AbilityAction, cutoff_time),
            },
            FieldInfoData {
                name: "CutoffTimeMode",
                flags: MemberInfoFlags::new(0),
                field_type: "AbilityInputCutoffTimeMode",
                rust_offset: offset_of!(AbilityAction, cutoff_time_mode),
            },
        ],
    }),
    array_type: Some(ABILITYACTION_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AbilityAction {
    fn type_info(&self) -> &'static TypeInfo {
        ABILITYACTION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ABILITYACTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AbilityAction-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("AbilityAction"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum AbilityInputCutoffTimeMode {
    #[default]
    AbilityInputCutoffTimeMode_KeepPressedUntilTime = 0,
    AbilityInputCutoffTimeMode_ReleaseAfterTime = 1,
    AbilityInputCutoffTimeMode_ReleaseBeforeTime = 2,
}

pub static ABILITYINPUTCUTOFFTIMEMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AbilityInputCutoffTimeMode",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(ABILITYINPUTCUTOFFTIMEMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AbilityInputCutoffTimeMode {
    fn type_info(&self) -> &'static TypeInfo {
        ABILITYINPUTCUTOFFTIMEMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ABILITYINPUTCUTOFFTIMEMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AbilityInputCutoffTimeMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("AbilityInputCutoffTimeMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum PlayerAbilityPickupEntityType {
    #[default]
    PlayerAbilityPickupEntityType_Dynamic = 0,
    PlayerAbilityPickupEntityType_Static = 1,
    PlayerAbilityPickupEntityType_Count = 2,
    PlayerAbilityPickupEntityType_Invalid = 3,
}

pub static PLAYERABILITYPICKUPENTITYTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityPickupEntityType",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(PLAYERABILITYPICKUPENTITYTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for PlayerAbilityPickupEntityType {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERABILITYPICKUPENTITYTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PLAYERABILITYPICKUPENTITYTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityPickupEntityType-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PlayerAbilityPickupEntityType"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum PlayerAbilityInputConstants {
    #[default]
    MaxSupportedMappingsPerAbility = 4,
}

pub static PLAYERABILITYINPUTCONSTANTS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityInputConstants",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(PLAYERABILITYINPUTCONSTANTS_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for PlayerAbilityInputConstants {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERABILITYINPUTCONSTANTS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PLAYERABILITYINPUTCONSTANTS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityInputConstants-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PlayerAbilityInputConstants"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum PlayerAbilityLevel {
    #[default]
    PlayerAbilityLevel_1 = 0,
    PlayerAbilityLevel_2 = 1,
    PlayerAbilityLevel_3 = 2,
    PlayerAbilityLevel_4 = 3,
    PlayerAbilityLevel_5 = 4,
    PlayerAbilityLevel_Count = 5,
    PlayerAbilityLevel_Invalid = 6,
}

pub static PLAYERABILITYLEVEL_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityLevel",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(PLAYERABILITYLEVEL_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for PlayerAbilityLevel {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERABILITYLEVEL_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PLAYERABILITYLEVEL_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityLevel-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PlayerAbilityLevel"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum PlayerAbilityState {
    #[default]
    PlayerAbilityState_Disabled = 0,
    PlayerAbilityState_Recharge = 1,
    PlayerAbilityState_Blocked = 2,
    PlayerAbilityState_Ready = 3,
    PlayerAbilityState_Activating = 4,
    PlayerAbilityState_Active = 5,
    PlayerAbilityState_Count = 6,
    PlayerAbilityState_Invalid = 7,
}

pub static PLAYERABILITYSTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityState",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(PLAYERABILITYSTATE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for PlayerAbilityState {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERABILITYSTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PLAYERABILITYSTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityState-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PlayerAbilityState"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum PlayerAbilityConstants {
    #[default]
    PlayerAbilityNumSlots = 18,
    PlayerAbilityWeaponSlotsCount = 10,
    PlayerAbilityInputQueueMaxSize = 5,
    PlayerAbilityMaxWeaponUpgrades = 3,
}

pub static PLAYERABILITYCONSTANTS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityConstants",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(PLAYERABILITYCONSTANTS_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for PlayerAbilityConstants {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERABILITYCONSTANTS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PLAYERABILITYCONSTANTS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityConstants-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PlayerAbilityConstants"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum PlayerAbilityCategory {
    #[default]
    PlayerAbilityCategory_Primary = 0,
    PlayerAbilityCategory_Middle = 1,
    PlayerAbilityCategory_Left = 2,
    PlayerAbilityCategory_Right = 3,
    PlayerAbilityCategory_AltFire1 = 4,
    PlayerAbilityCategory_AltFire2 = 5,
    PlayerAbilityCategory_AltFire3 = 6,
    PlayerAbilityCategory_Up = 7,
    PlayerAbilityCategory_Down = 8,
    PlayerAbilityCategory_Passive = 9,
    PlayerAbilityCategory_Evade = 10,
    PlayerAbilityCategory_HeroMenu = 11,
    PlayerAbilityCategory_Legendary = 12,
    PlayerAbilityCategory_Pickup = 13,
    PlayerAbilityCategory_Extra1 = 14,
    PlayerAbilityCategory_Extra2 = 15,
    PlayerAbilityCategory_Extra3 = 16,
    PlayerAbilityCategory_Extra4 = 17,
    PlayerAbilityCategory_LLeft = 18,
    PlayerAbilityCategory_LRight = 19,
    PlayerAbilityCategory_LUp = 20,
    PlayerAbilityCategory_LDown = 21,
    PlayerAbilityCategory_Emote = 22,
    PlayerAbilityCategory_Emote1 = 23,
    PlayerAbilityCategory_Emote2 = 24,
    PlayerAbilityCategory_Emote3 = 25,
    PlayerAbilityCategory_VictoryPose = 26,
    PlayerAbilityCategory_Bottom = 27,
    PlayerAbilityCategory_CommoRose = 28,
    PlayerAbilityCategory_VOWheel = 29,
    PlayerAbilityCategory_Count = 30,
    PlayerAbilityCategory_Invalid = 31,
}

pub static PLAYERABILITYCATEGORY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityCategory",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(PLAYERABILITYCATEGORY_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for PlayerAbilityCategory {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERABILITYCATEGORY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PLAYERABILITYCATEGORY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityCategory-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PlayerAbilityCategory"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct StaticPlayerAbilityPickupEntityData {
    pub _glacier_base: PlayerAbilitySpatialPickupEntityData,
}

pub trait StaticPlayerAbilityPickupEntityDataTrait: PlayerAbilitySpatialPickupEntityDataTrait {
}

impl StaticPlayerAbilityPickupEntityDataTrait for StaticPlayerAbilityPickupEntityData {
}

impl PlayerAbilitySpatialPickupEntityDataTrait for StaticPlayerAbilityPickupEntityData {
    fn mesh(&self) -> &Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        self._glacier_base.mesh()
    }
    fn allow_pickup_switching(&self) -> &bool {
        self._glacier_base.allow_pickup_switching()
    }
    fn store_state(&self) -> &bool {
        self._glacier_base.store_state()
    }
    fn reset_stored_state_on_pickup(&self) -> &bool {
        self._glacier_base.reset_stored_state_on_pickup()
    }
    fn store_weapon_state(&self) -> &bool {
        self._glacier_base.store_weapon_state()
    }
    fn attached_player_ability_identifier(&self) -> &u32 {
        self._glacier_base.attached_player_ability_identifier()
    }
}

impl super::entity::GameComponentEntityDataTrait for StaticPlayerAbilityPickupEntityData {
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
}

impl super::entity::ComponentEntityDataTrait for StaticPlayerAbilityPickupEntityData {
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn part_bounding_boxes(&self) -> &Vec<super::core::AxisAlignedBox> {
        self._glacier_base.part_bounding_boxes()
    }
    fn client_runtime_component_count(&self) -> &u8 {
        self._glacier_base.client_runtime_component_count()
    }
    fn server_runtime_component_count(&self) -> &u8 {
        self._glacier_base.server_runtime_component_count()
    }
    fn client_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.client_runtime_transformation_count()
    }
    fn server_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.server_runtime_transformation_count()
    }
}

impl super::entity::SpatialEntityDataTrait for StaticPlayerAbilityPickupEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
}

impl super::entity::EntityDataTrait for StaticPlayerAbilityPickupEntityData {
}

impl super::entity::GameObjectDataTrait for StaticPlayerAbilityPickupEntityData {
}

impl super::core::DataBusPeerTrait for StaticPlayerAbilityPickupEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for StaticPlayerAbilityPickupEntityData {
}

impl super::core::DataContainerTrait for StaticPlayerAbilityPickupEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static STATICPLAYERABILITYPICKUPENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StaticPlayerAbilityPickupEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PLAYERABILITYSPATIALPICKUPENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StaticPlayerAbilityPickupEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(STATICPLAYERABILITYPICKUPENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for StaticPlayerAbilityPickupEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        STATICPLAYERABILITYPICKUPENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static STATICPLAYERABILITYPICKUPENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StaticPlayerAbilityPickupEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("StaticPlayerAbilityPickupEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DynamicPlayerAbilityPickupEntityData {
    pub _glacier_base: PlayerAbilitySpatialPickupEntityData,
    pub destroy_on_picked_up: bool,
}

pub trait DynamicPlayerAbilityPickupEntityDataTrait: PlayerAbilitySpatialPickupEntityDataTrait {
    fn destroy_on_picked_up(&self) -> &bool;
}

impl DynamicPlayerAbilityPickupEntityDataTrait for DynamicPlayerAbilityPickupEntityData {
    fn destroy_on_picked_up(&self) -> &bool {
        &self.destroy_on_picked_up
    }
}

impl PlayerAbilitySpatialPickupEntityDataTrait for DynamicPlayerAbilityPickupEntityData {
    fn mesh(&self) -> &Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        self._glacier_base.mesh()
    }
    fn allow_pickup_switching(&self) -> &bool {
        self._glacier_base.allow_pickup_switching()
    }
    fn store_state(&self) -> &bool {
        self._glacier_base.store_state()
    }
    fn reset_stored_state_on_pickup(&self) -> &bool {
        self._glacier_base.reset_stored_state_on_pickup()
    }
    fn store_weapon_state(&self) -> &bool {
        self._glacier_base.store_weapon_state()
    }
    fn attached_player_ability_identifier(&self) -> &u32 {
        self._glacier_base.attached_player_ability_identifier()
    }
}

impl super::entity::GameComponentEntityDataTrait for DynamicPlayerAbilityPickupEntityData {
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
}

impl super::entity::ComponentEntityDataTrait for DynamicPlayerAbilityPickupEntityData {
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn part_bounding_boxes(&self) -> &Vec<super::core::AxisAlignedBox> {
        self._glacier_base.part_bounding_boxes()
    }
    fn client_runtime_component_count(&self) -> &u8 {
        self._glacier_base.client_runtime_component_count()
    }
    fn server_runtime_component_count(&self) -> &u8 {
        self._glacier_base.server_runtime_component_count()
    }
    fn client_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.client_runtime_transformation_count()
    }
    fn server_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.server_runtime_transformation_count()
    }
}

impl super::entity::SpatialEntityDataTrait for DynamicPlayerAbilityPickupEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
}

impl super::entity::EntityDataTrait for DynamicPlayerAbilityPickupEntityData {
}

impl super::entity::GameObjectDataTrait for DynamicPlayerAbilityPickupEntityData {
}

impl super::core::DataBusPeerTrait for DynamicPlayerAbilityPickupEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for DynamicPlayerAbilityPickupEntityData {
}

impl super::core::DataContainerTrait for DynamicPlayerAbilityPickupEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static DYNAMICPLAYERABILITYPICKUPENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicPlayerAbilityPickupEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PLAYERABILITYSPATIALPICKUPENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DynamicPlayerAbilityPickupEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DestroyOnPickedUp",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DynamicPlayerAbilityPickupEntityData, destroy_on_picked_up),
            },
        ],
    }),
    array_type: Some(DYNAMICPLAYERABILITYPICKUPENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for DynamicPlayerAbilityPickupEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        DYNAMICPLAYERABILITYPICKUPENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static DYNAMICPLAYERABILITYPICKUPENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicPlayerAbilityPickupEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("DynamicPlayerAbilityPickupEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlayerAbilitySpatialPickupEntityData {
    pub _glacier_base: super::entity::GameComponentEntityData,
    pub mesh: Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>>,
    pub allow_pickup_switching: bool,
    pub store_state: bool,
    pub reset_stored_state_on_pickup: bool,
    pub store_weapon_state: bool,
    pub attached_player_ability_identifier: u32,
}

pub trait PlayerAbilitySpatialPickupEntityDataTrait: super::entity::GameComponentEntityDataTrait {
    fn mesh(&self) -> &Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>>;
    fn allow_pickup_switching(&self) -> &bool;
    fn store_state(&self) -> &bool;
    fn reset_stored_state_on_pickup(&self) -> &bool;
    fn store_weapon_state(&self) -> &bool;
    fn attached_player_ability_identifier(&self) -> &u32;
}

impl PlayerAbilitySpatialPickupEntityDataTrait for PlayerAbilitySpatialPickupEntityData {
    fn mesh(&self) -> &Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        &self.mesh
    }
    fn allow_pickup_switching(&self) -> &bool {
        &self.allow_pickup_switching
    }
    fn store_state(&self) -> &bool {
        &self.store_state
    }
    fn reset_stored_state_on_pickup(&self) -> &bool {
        &self.reset_stored_state_on_pickup
    }
    fn store_weapon_state(&self) -> &bool {
        &self.store_weapon_state
    }
    fn attached_player_ability_identifier(&self) -> &u32 {
        &self.attached_player_ability_identifier
    }
}

impl super::entity::GameComponentEntityDataTrait for PlayerAbilitySpatialPickupEntityData {
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
}

impl super::entity::ComponentEntityDataTrait for PlayerAbilitySpatialPickupEntityData {
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn part_bounding_boxes(&self) -> &Vec<super::core::AxisAlignedBox> {
        self._glacier_base.part_bounding_boxes()
    }
    fn client_runtime_component_count(&self) -> &u8 {
        self._glacier_base.client_runtime_component_count()
    }
    fn server_runtime_component_count(&self) -> &u8 {
        self._glacier_base.server_runtime_component_count()
    }
    fn client_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.client_runtime_transformation_count()
    }
    fn server_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.server_runtime_transformation_count()
    }
}

impl super::entity::SpatialEntityDataTrait for PlayerAbilitySpatialPickupEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
}

impl super::entity::EntityDataTrait for PlayerAbilitySpatialPickupEntityData {
}

impl super::entity::GameObjectDataTrait for PlayerAbilitySpatialPickupEntityData {
}

impl super::core::DataBusPeerTrait for PlayerAbilitySpatialPickupEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for PlayerAbilitySpatialPickupEntityData {
}

impl super::core::DataContainerTrait for PlayerAbilitySpatialPickupEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PLAYERABILITYSPATIALPICKUPENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilitySpatialPickupEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayerAbilitySpatialPickupEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Mesh",
                flags: MemberInfoFlags::new(0),
                field_type: "MeshBaseAsset",
                rust_offset: offset_of!(PlayerAbilitySpatialPickupEntityData, mesh),
            },
            FieldInfoData {
                name: "AllowPickupSwitching",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayerAbilitySpatialPickupEntityData, allow_pickup_switching),
            },
            FieldInfoData {
                name: "StoreState",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayerAbilitySpatialPickupEntityData, store_state),
            },
            FieldInfoData {
                name: "ResetStoredStateOnPickup",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayerAbilitySpatialPickupEntityData, reset_stored_state_on_pickup),
            },
            FieldInfoData {
                name: "StoreWeaponState",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayerAbilitySpatialPickupEntityData, store_weapon_state),
            },
            FieldInfoData {
                name: "AttachedPlayerAbilityIdentifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(PlayerAbilitySpatialPickupEntityData, attached_player_ability_identifier),
            },
        ],
    }),
    array_type: Some(PLAYERABILITYSPATIALPICKUPENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PlayerAbilitySpatialPickupEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERABILITYSPATIALPICKUPENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PLAYERABILITYSPATIALPICKUPENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilitySpatialPickupEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PlayerAbilitySpatialPickupEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlayerAbilityPickupEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub player_ability_identifier: u32,
}

pub trait PlayerAbilityPickupEntityDataTrait: super::entity::EntityDataTrait {
    fn player_ability_identifier(&self) -> &u32;
}

impl PlayerAbilityPickupEntityDataTrait for PlayerAbilityPickupEntityData {
    fn player_ability_identifier(&self) -> &u32 {
        &self.player_ability_identifier
    }
}

impl super::entity::EntityDataTrait for PlayerAbilityPickupEntityData {
}

impl super::entity::GameObjectDataTrait for PlayerAbilityPickupEntityData {
}

impl super::core::DataBusPeerTrait for PlayerAbilityPickupEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for PlayerAbilityPickupEntityData {
}

impl super::core::DataContainerTrait for PlayerAbilityPickupEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PLAYERABILITYPICKUPENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityPickupEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayerAbilityPickupEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PlayerAbilityIdentifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(PlayerAbilityPickupEntityData, player_ability_identifier),
            },
        ],
    }),
    array_type: Some(PLAYERABILITYPICKUPENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PlayerAbilityPickupEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERABILITYPICKUPENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PLAYERABILITYPICKUPENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityPickupEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PlayerAbilityPickupEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CategoryToPlayerAbilityEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub clear_controllable_on_exit: bool,
    pub read_query_from_end: bool,
    pub category: PlayerAbilityCategory,
}

pub trait CategoryToPlayerAbilityEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn clear_controllable_on_exit(&self) -> &bool;
    fn read_query_from_end(&self) -> &bool;
    fn category(&self) -> &PlayerAbilityCategory;
}

impl CategoryToPlayerAbilityEntityDataTrait for CategoryToPlayerAbilityEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn clear_controllable_on_exit(&self) -> &bool {
        &self.clear_controllable_on_exit
    }
    fn read_query_from_end(&self) -> &bool {
        &self.read_query_from_end
    }
    fn category(&self) -> &PlayerAbilityCategory {
        &self.category
    }
}

impl super::entity::EntityDataTrait for CategoryToPlayerAbilityEntityData {
}

impl super::entity::GameObjectDataTrait for CategoryToPlayerAbilityEntityData {
}

impl super::core::DataBusPeerTrait for CategoryToPlayerAbilityEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for CategoryToPlayerAbilityEntityData {
}

impl super::core::DataContainerTrait for CategoryToPlayerAbilityEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CATEGORYTOPLAYERABILITYENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CategoryToPlayerAbilityEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CategoryToPlayerAbilityEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(CategoryToPlayerAbilityEntityData, realm),
            },
            FieldInfoData {
                name: "ClearControllableOnExit",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CategoryToPlayerAbilityEntityData, clear_controllable_on_exit),
            },
            FieldInfoData {
                name: "ReadQueryFromEnd",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CategoryToPlayerAbilityEntityData, read_query_from_end),
            },
            FieldInfoData {
                name: "Category",
                flags: MemberInfoFlags::new(0),
                field_type: "PlayerAbilityCategory",
                rust_offset: offset_of!(CategoryToPlayerAbilityEntityData, category),
            },
        ],
    }),
    array_type: Some(CATEGORYTOPLAYERABILITYENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CategoryToPlayerAbilityEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CATEGORYTOPLAYERABILITYENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CATEGORYTOPLAYERABILITYENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CategoryToPlayerAbilityEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CategoryToPlayerAbilityEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RemotePlayerAbilityStateEntityData {
    pub _glacier_base: PlayerAbilityStateEntityData,
    pub clear_controllable_on_exit: bool,
    pub track_mode: PlayerAbilityStateTrackMode,
}

pub trait RemotePlayerAbilityStateEntityDataTrait: PlayerAbilityStateEntityDataTrait {
    fn clear_controllable_on_exit(&self) -> &bool;
    fn track_mode(&self) -> &PlayerAbilityStateTrackMode;
}

impl RemotePlayerAbilityStateEntityDataTrait for RemotePlayerAbilityStateEntityData {
    fn clear_controllable_on_exit(&self) -> &bool {
        &self.clear_controllable_on_exit
    }
    fn track_mode(&self) -> &PlayerAbilityStateTrackMode {
        &self.track_mode
    }
}

impl PlayerAbilityStateEntityDataTrait for RemotePlayerAbilityStateEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn track_owners_player(&self) -> &bool {
        self._glacier_base.track_owners_player()
    }
    fn player_ability_identifier(&self) -> &u32 {
        self._glacier_base.player_ability_identifier()
    }
}

impl super::entity::EntityDataTrait for RemotePlayerAbilityStateEntityData {
}

impl super::entity::GameObjectDataTrait for RemotePlayerAbilityStateEntityData {
}

impl super::core::DataBusPeerTrait for RemotePlayerAbilityStateEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for RemotePlayerAbilityStateEntityData {
}

impl super::core::DataContainerTrait for RemotePlayerAbilityStateEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static REMOTEPLAYERABILITYSTATEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RemotePlayerAbilityStateEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PLAYERABILITYSTATEENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RemotePlayerAbilityStateEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ClearControllableOnExit",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RemotePlayerAbilityStateEntityData, clear_controllable_on_exit),
            },
            FieldInfoData {
                name: "TrackMode",
                flags: MemberInfoFlags::new(0),
                field_type: "PlayerAbilityStateTrackMode",
                rust_offset: offset_of!(RemotePlayerAbilityStateEntityData, track_mode),
            },
        ],
    }),
    array_type: Some(REMOTEPLAYERABILITYSTATEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RemotePlayerAbilityStateEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        REMOTEPLAYERABILITYSTATEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static REMOTEPLAYERABILITYSTATEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RemotePlayerAbilityStateEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("RemotePlayerAbilityStateEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum PlayerAbilityStateTrackMode {
    #[default]
    PlayerAbilityStateTrackMode_Controllable = 0,
    PlayerAbilityStateTrackMode_Player = 1,
}

pub static PLAYERABILITYSTATETRACKMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityStateTrackMode",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(PLAYERABILITYSTATETRACKMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for PlayerAbilityStateTrackMode {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERABILITYSTATETRACKMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PLAYERABILITYSTATETRACKMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityStateTrackMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PlayerAbilityStateTrackMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlayerAbilityStateEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub track_owners_player: bool,
    pub player_ability_identifier: u32,
}

pub trait PlayerAbilityStateEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn track_owners_player(&self) -> &bool;
    fn player_ability_identifier(&self) -> &u32;
}

impl PlayerAbilityStateEntityDataTrait for PlayerAbilityStateEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn track_owners_player(&self) -> &bool {
        &self.track_owners_player
    }
    fn player_ability_identifier(&self) -> &u32 {
        &self.player_ability_identifier
    }
}

impl super::entity::EntityDataTrait for PlayerAbilityStateEntityData {
}

impl super::entity::GameObjectDataTrait for PlayerAbilityStateEntityData {
}

impl super::core::DataBusPeerTrait for PlayerAbilityStateEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for PlayerAbilityStateEntityData {
}

impl super::core::DataContainerTrait for PlayerAbilityStateEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PLAYERABILITYSTATEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityStateEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayerAbilityStateEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(PlayerAbilityStateEntityData, realm),
            },
            FieldInfoData {
                name: "TrackOwnersPlayer",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayerAbilityStateEntityData, track_owners_player),
            },
            FieldInfoData {
                name: "PlayerAbilityIdentifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(PlayerAbilityStateEntityData, player_ability_identifier),
            },
        ],
    }),
    array_type: Some(PLAYERABILITYSTATEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PlayerAbilityStateEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERABILITYSTATEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PLAYERABILITYSTATEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityStateEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PlayerAbilityStateEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlayerAbilityPropertyOutputEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub player_ability_identifier: u32,
}

pub trait PlayerAbilityPropertyOutputEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn player_ability_identifier(&self) -> &u32;
}

impl PlayerAbilityPropertyOutputEntityDataTrait for PlayerAbilityPropertyOutputEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn player_ability_identifier(&self) -> &u32 {
        &self.player_ability_identifier
    }
}

impl super::entity::EntityDataTrait for PlayerAbilityPropertyOutputEntityData {
}

impl super::entity::GameObjectDataTrait for PlayerAbilityPropertyOutputEntityData {
}

impl super::core::DataBusPeerTrait for PlayerAbilityPropertyOutputEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for PlayerAbilityPropertyOutputEntityData {
}

impl super::core::DataContainerTrait for PlayerAbilityPropertyOutputEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PLAYERABILITYPROPERTYOUTPUTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityPropertyOutputEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayerAbilityPropertyOutputEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(PlayerAbilityPropertyOutputEntityData, realm),
            },
            FieldInfoData {
                name: "PlayerAbilityIdentifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(PlayerAbilityPropertyOutputEntityData, player_ability_identifier),
            },
        ],
    }),
    array_type: Some(PLAYERABILITYPROPERTYOUTPUTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PlayerAbilityPropertyOutputEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERABILITYPROPERTYOUTPUTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PLAYERABILITYPROPERTYOUTPUTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityPropertyOutputEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PlayerAbilityPropertyOutputEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlayerAbilityEntityData {
    pub _glacier_base: super::entity::EntityData,
}

pub trait PlayerAbilityEntityDataTrait: super::entity::EntityDataTrait {
}

impl PlayerAbilityEntityDataTrait for PlayerAbilityEntityData {
}

impl super::entity::EntityDataTrait for PlayerAbilityEntityData {
}

impl super::entity::GameObjectDataTrait for PlayerAbilityEntityData {
}

impl super::core::DataBusPeerTrait for PlayerAbilityEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for PlayerAbilityEntityData {
}

impl super::core::DataContainerTrait for PlayerAbilityEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PLAYERABILITYENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayerAbilityEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(PLAYERABILITYENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PlayerAbilityEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERABILITYENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PLAYERABILITYENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PlayerAbilityEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RechargeablePlayerAbilityAsset {
    pub _glacier_base: BasicPlayerAbilityAsset,
    pub charge_count: i32,
    pub start_charge_count: i32,
}

pub trait RechargeablePlayerAbilityAssetTrait: BasicPlayerAbilityAssetTrait {
    fn charge_count(&self) -> &i32;
    fn start_charge_count(&self) -> &i32;
}

impl RechargeablePlayerAbilityAssetTrait for RechargeablePlayerAbilityAsset {
    fn charge_count(&self) -> &i32 {
        &self.charge_count
    }
    fn start_charge_count(&self) -> &i32 {
        &self.start_charge_count
    }
}

impl BasicPlayerAbilityAssetTrait for RechargeablePlayerAbilityAsset {
    fn infinite_active_time(&self) -> &bool {
        self._glacier_base.infinite_active_time()
    }
    fn active_time(&self) -> &f32 {
        self._glacier_base.active_time()
    }
    fn require_hold_during_active_time(&self) -> &bool {
        self._glacier_base.require_hold_during_active_time()
    }
    fn infinite_activation_time(&self) -> &bool {
        self._glacier_base.infinite_activation_time()
    }
    fn activation_time(&self) -> &f32 {
        self._glacier_base.activation_time()
    }
    fn require_hold_during_activation_time(&self) -> &bool {
        self._glacier_base.require_hold_during_activation_time()
    }
    fn infinite_recharge_time(&self) -> &bool {
        self._glacier_base.infinite_recharge_time()
    }
    fn recharge_time(&self) -> &f32 {
        self._glacier_base.recharge_time()
    }
    fn disable_on_recharge(&self) -> &bool {
        self._glacier_base.disable_on_recharge()
    }
    fn disable_on_player_exit(&self) -> &bool {
        self._glacier_base.disable_on_player_exit()
    }
    fn disable_on_controllable_death(&self) -> &bool {
        self._glacier_base.disable_on_controllable_death()
    }
    fn remove_on_disable(&self) -> &bool {
        self._glacier_base.remove_on_disable()
    }
    fn supports_input_queue(&self) -> &bool {
        self._glacier_base.supports_input_queue()
    }
    fn input_queue_apply_order(&self) -> &i32 {
        self._glacier_base.input_queue_apply_order()
    }
    fn blocking_channels(&self) -> &Vec<Option<Arc<Mutex<dyn super::soldier_shared::CharacterStateRequiredChannelValueDataTrait>>>> {
        self._glacier_base.blocking_channels()
    }
    fn set_channels_when_activating(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateChannelValueDataTrait>>>> {
        self._glacier_base.set_channels_when_activating()
    }
    fn set_channels_when_active(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateChannelValueDataTrait>>>> {
        self._glacier_base.set_channels_when_active()
    }
    fn activate_when_button_is_down(&self) -> &bool {
        self._glacier_base.activate_when_button_is_down()
    }
}

impl CorrectedPlayerAbilityAssetTrait for RechargeablePlayerAbilityAsset {
}

impl PlayerAbilityAssetTrait for RechargeablePlayerAbilityAsset {
    fn is_supported_on_a_i_players(&self) -> &bool {
        self._glacier_base.is_supported_on_a_i_players()
    }
    fn is_supported_on_human_players(&self) -> &bool {
        self._glacier_base.is_supported_on_human_players()
    }
    fn has_bonus_levels(&self) -> &bool {
        self._glacier_base.has_bonus_levels()
    }
    fn unlock(&self) -> &Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>> {
        self._glacier_base.unlock()
    }
    fn category(&self) -> &PlayerAbilityCategory {
        self._glacier_base.category()
    }
    fn blueprint(&self) -> &Option<Arc<Mutex<dyn super::entity::BlueprintTrait>>> {
        self._glacier_base.blueprint()
    }
    fn ignore_networking_errors(&self) -> &bool {
        self._glacier_base.ignore_networking_errors()
    }
    fn reset_on_spawn(&self) -> &bool {
        self._glacier_base.reset_on_spawn()
    }
    fn descriptor_ids(&self) -> &Vec<u32> {
        self._glacier_base.descriptor_ids()
    }
    fn input_modifiers(&self) -> &Vec<PlayerAbilityInputModifier> {
        self._glacier_base.input_modifiers()
    }
    fn block_player_abilities_rules(&self) -> &Vec<PlayerAbilityBlockingRule> {
        self._glacier_base.block_player_abilities_rules()
    }
    fn apply_block_player_abilities_during_active(&self) -> &bool {
        self._glacier_base.apply_block_player_abilities_during_active()
    }
    fn apply_block_player_abilities_during_activation(&self) -> &bool {
        self._glacier_base.apply_block_player_abilities_during_activation()
    }
    fn blocked_player_ability_ids(&self) -> &Vec<u32> {
        self._glacier_base.blocked_player_ability_ids()
    }
    fn unblocked_by_ability_id(&self) -> &u32 {
        self._glacier_base.unblocked_by_ability_id()
    }
    fn identifier(&self) -> &u32 {
        self._glacier_base.identifier()
    }
    fn is_hidden(&self) -> &bool {
        self._glacier_base.is_hidden()
    }
    fn ability_modifiers(&self) -> &Vec<Option<Arc<Mutex<dyn PlayerAbilityModifierTrait>>>> {
        self._glacier_base.ability_modifiers()
    }
    fn is_default_unlocked(&self) -> &bool {
        self._glacier_base.is_default_unlocked()
    }
    fn drop_as_pickup_on_death(&self) -> &bool {
        self._glacier_base.drop_as_pickup_on_death()
    }
    fn pickup_blueprint(&self) -> &Option<Arc<Mutex<dyn PlayerAbilityPickupEntityBlueprintTrait>>> {
        self._glacier_base.pickup_blueprint()
    }
    fn non_streamed_pickup_mesh(&self) -> &Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        self._glacier_base.non_streamed_pickup_mesh()
    }
}

impl PlayerAbilityAssetBaseTrait for RechargeablePlayerAbilityAsset {
}

impl super::core::DataContainerPolicyAssetTrait for RechargeablePlayerAbilityAsset {
}

impl super::core::AssetTrait for RechargeablePlayerAbilityAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for RechargeablePlayerAbilityAsset {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static RECHARGEABLEPLAYERABILITYASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RechargeablePlayerAbilityAsset",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(BASICPLAYERABILITYASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RechargeablePlayerAbilityAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ChargeCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(RechargeablePlayerAbilityAsset, charge_count),
            },
            FieldInfoData {
                name: "StartChargeCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(RechargeablePlayerAbilityAsset, start_charge_count),
            },
        ],
    }),
    array_type: Some(RECHARGEABLEPLAYERABILITYASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RechargeablePlayerAbilityAsset {
    fn type_info(&self) -> &'static TypeInfo {
        RECHARGEABLEPLAYERABILITYASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static RECHARGEABLEPLAYERABILITYASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RechargeablePlayerAbilityAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("RechargeablePlayerAbilityAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RetriggerablePlayerAbilityAsset {
    pub _glacier_base: BasicPlayerAbilityAsset,
    pub require_hold_during_retrigger: bool,
    pub require_hold_during_retrigger_time: f32,
    pub retriggerable_count: i32,
    pub retrigger_cooldown: f32,
    pub recharge_on_retrigger_count_zero: bool,
}

pub trait RetriggerablePlayerAbilityAssetTrait: BasicPlayerAbilityAssetTrait {
    fn require_hold_during_retrigger(&self) -> &bool;
    fn require_hold_during_retrigger_time(&self) -> &f32;
    fn retriggerable_count(&self) -> &i32;
    fn retrigger_cooldown(&self) -> &f32;
    fn recharge_on_retrigger_count_zero(&self) -> &bool;
}

impl RetriggerablePlayerAbilityAssetTrait for RetriggerablePlayerAbilityAsset {
    fn require_hold_during_retrigger(&self) -> &bool {
        &self.require_hold_during_retrigger
    }
    fn require_hold_during_retrigger_time(&self) -> &f32 {
        &self.require_hold_during_retrigger_time
    }
    fn retriggerable_count(&self) -> &i32 {
        &self.retriggerable_count
    }
    fn retrigger_cooldown(&self) -> &f32 {
        &self.retrigger_cooldown
    }
    fn recharge_on_retrigger_count_zero(&self) -> &bool {
        &self.recharge_on_retrigger_count_zero
    }
}

impl BasicPlayerAbilityAssetTrait for RetriggerablePlayerAbilityAsset {
    fn infinite_active_time(&self) -> &bool {
        self._glacier_base.infinite_active_time()
    }
    fn active_time(&self) -> &f32 {
        self._glacier_base.active_time()
    }
    fn require_hold_during_active_time(&self) -> &bool {
        self._glacier_base.require_hold_during_active_time()
    }
    fn infinite_activation_time(&self) -> &bool {
        self._glacier_base.infinite_activation_time()
    }
    fn activation_time(&self) -> &f32 {
        self._glacier_base.activation_time()
    }
    fn require_hold_during_activation_time(&self) -> &bool {
        self._glacier_base.require_hold_during_activation_time()
    }
    fn infinite_recharge_time(&self) -> &bool {
        self._glacier_base.infinite_recharge_time()
    }
    fn recharge_time(&self) -> &f32 {
        self._glacier_base.recharge_time()
    }
    fn disable_on_recharge(&self) -> &bool {
        self._glacier_base.disable_on_recharge()
    }
    fn disable_on_player_exit(&self) -> &bool {
        self._glacier_base.disable_on_player_exit()
    }
    fn disable_on_controllable_death(&self) -> &bool {
        self._glacier_base.disable_on_controllable_death()
    }
    fn remove_on_disable(&self) -> &bool {
        self._glacier_base.remove_on_disable()
    }
    fn supports_input_queue(&self) -> &bool {
        self._glacier_base.supports_input_queue()
    }
    fn input_queue_apply_order(&self) -> &i32 {
        self._glacier_base.input_queue_apply_order()
    }
    fn blocking_channels(&self) -> &Vec<Option<Arc<Mutex<dyn super::soldier_shared::CharacterStateRequiredChannelValueDataTrait>>>> {
        self._glacier_base.blocking_channels()
    }
    fn set_channels_when_activating(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateChannelValueDataTrait>>>> {
        self._glacier_base.set_channels_when_activating()
    }
    fn set_channels_when_active(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateChannelValueDataTrait>>>> {
        self._glacier_base.set_channels_when_active()
    }
    fn activate_when_button_is_down(&self) -> &bool {
        self._glacier_base.activate_when_button_is_down()
    }
}

impl CorrectedPlayerAbilityAssetTrait for RetriggerablePlayerAbilityAsset {
}

impl PlayerAbilityAssetTrait for RetriggerablePlayerAbilityAsset {
    fn is_supported_on_a_i_players(&self) -> &bool {
        self._glacier_base.is_supported_on_a_i_players()
    }
    fn is_supported_on_human_players(&self) -> &bool {
        self._glacier_base.is_supported_on_human_players()
    }
    fn has_bonus_levels(&self) -> &bool {
        self._glacier_base.has_bonus_levels()
    }
    fn unlock(&self) -> &Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>> {
        self._glacier_base.unlock()
    }
    fn category(&self) -> &PlayerAbilityCategory {
        self._glacier_base.category()
    }
    fn blueprint(&self) -> &Option<Arc<Mutex<dyn super::entity::BlueprintTrait>>> {
        self._glacier_base.blueprint()
    }
    fn ignore_networking_errors(&self) -> &bool {
        self._glacier_base.ignore_networking_errors()
    }
    fn reset_on_spawn(&self) -> &bool {
        self._glacier_base.reset_on_spawn()
    }
    fn descriptor_ids(&self) -> &Vec<u32> {
        self._glacier_base.descriptor_ids()
    }
    fn input_modifiers(&self) -> &Vec<PlayerAbilityInputModifier> {
        self._glacier_base.input_modifiers()
    }
    fn block_player_abilities_rules(&self) -> &Vec<PlayerAbilityBlockingRule> {
        self._glacier_base.block_player_abilities_rules()
    }
    fn apply_block_player_abilities_during_active(&self) -> &bool {
        self._glacier_base.apply_block_player_abilities_during_active()
    }
    fn apply_block_player_abilities_during_activation(&self) -> &bool {
        self._glacier_base.apply_block_player_abilities_during_activation()
    }
    fn blocked_player_ability_ids(&self) -> &Vec<u32> {
        self._glacier_base.blocked_player_ability_ids()
    }
    fn unblocked_by_ability_id(&self) -> &u32 {
        self._glacier_base.unblocked_by_ability_id()
    }
    fn identifier(&self) -> &u32 {
        self._glacier_base.identifier()
    }
    fn is_hidden(&self) -> &bool {
        self._glacier_base.is_hidden()
    }
    fn ability_modifiers(&self) -> &Vec<Option<Arc<Mutex<dyn PlayerAbilityModifierTrait>>>> {
        self._glacier_base.ability_modifiers()
    }
    fn is_default_unlocked(&self) -> &bool {
        self._glacier_base.is_default_unlocked()
    }
    fn drop_as_pickup_on_death(&self) -> &bool {
        self._glacier_base.drop_as_pickup_on_death()
    }
    fn pickup_blueprint(&self) -> &Option<Arc<Mutex<dyn PlayerAbilityPickupEntityBlueprintTrait>>> {
        self._glacier_base.pickup_blueprint()
    }
    fn non_streamed_pickup_mesh(&self) -> &Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        self._glacier_base.non_streamed_pickup_mesh()
    }
}

impl PlayerAbilityAssetBaseTrait for RetriggerablePlayerAbilityAsset {
}

impl super::core::DataContainerPolicyAssetTrait for RetriggerablePlayerAbilityAsset {
}

impl super::core::AssetTrait for RetriggerablePlayerAbilityAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for RetriggerablePlayerAbilityAsset {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static RETRIGGERABLEPLAYERABILITYASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RetriggerablePlayerAbilityAsset",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(BASICPLAYERABILITYASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RetriggerablePlayerAbilityAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "RequireHoldDuringRetrigger",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RetriggerablePlayerAbilityAsset, require_hold_during_retrigger),
            },
            FieldInfoData {
                name: "RequireHoldDuringRetriggerTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RetriggerablePlayerAbilityAsset, require_hold_during_retrigger_time),
            },
            FieldInfoData {
                name: "RetriggerableCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(RetriggerablePlayerAbilityAsset, retriggerable_count),
            },
            FieldInfoData {
                name: "RetriggerCooldown",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RetriggerablePlayerAbilityAsset, retrigger_cooldown),
            },
            FieldInfoData {
                name: "RechargeOnRetriggerCountZero",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RetriggerablePlayerAbilityAsset, recharge_on_retrigger_count_zero),
            },
        ],
    }),
    array_type: Some(RETRIGGERABLEPLAYERABILITYASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RetriggerablePlayerAbilityAsset {
    fn type_info(&self) -> &'static TypeInfo {
        RETRIGGERABLEPLAYERABILITYASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static RETRIGGERABLEPLAYERABILITYASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RetriggerablePlayerAbilityAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("RetriggerablePlayerAbilityAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoldierWeaponPlayerAbilityAsset {
    pub _glacier_base: BasicPlayerAbilityAsset,
    pub start_deploying_on_activation: bool,
    pub stay_in_activating_during_deploy: bool,
    pub automatically_switch_back_on_out_of_ammo: bool,
    pub automatically_recharge_on_out_of_ammo: bool,
    pub refill_magazine_on_ready: bool,
    pub automatically_equip: bool,
    pub automatically_fire: bool,
    pub secondary_fire_abilities: Vec<u32>,
}

pub trait SoldierWeaponPlayerAbilityAssetTrait: BasicPlayerAbilityAssetTrait {
    fn start_deploying_on_activation(&self) -> &bool;
    fn stay_in_activating_during_deploy(&self) -> &bool;
    fn automatically_switch_back_on_out_of_ammo(&self) -> &bool;
    fn automatically_recharge_on_out_of_ammo(&self) -> &bool;
    fn refill_magazine_on_ready(&self) -> &bool;
    fn automatically_equip(&self) -> &bool;
    fn automatically_fire(&self) -> &bool;
    fn secondary_fire_abilities(&self) -> &Vec<u32>;
}

impl SoldierWeaponPlayerAbilityAssetTrait for SoldierWeaponPlayerAbilityAsset {
    fn start_deploying_on_activation(&self) -> &bool {
        &self.start_deploying_on_activation
    }
    fn stay_in_activating_during_deploy(&self) -> &bool {
        &self.stay_in_activating_during_deploy
    }
    fn automatically_switch_back_on_out_of_ammo(&self) -> &bool {
        &self.automatically_switch_back_on_out_of_ammo
    }
    fn automatically_recharge_on_out_of_ammo(&self) -> &bool {
        &self.automatically_recharge_on_out_of_ammo
    }
    fn refill_magazine_on_ready(&self) -> &bool {
        &self.refill_magazine_on_ready
    }
    fn automatically_equip(&self) -> &bool {
        &self.automatically_equip
    }
    fn automatically_fire(&self) -> &bool {
        &self.automatically_fire
    }
    fn secondary_fire_abilities(&self) -> &Vec<u32> {
        &self.secondary_fire_abilities
    }
}

impl BasicPlayerAbilityAssetTrait for SoldierWeaponPlayerAbilityAsset {
    fn infinite_active_time(&self) -> &bool {
        self._glacier_base.infinite_active_time()
    }
    fn active_time(&self) -> &f32 {
        self._glacier_base.active_time()
    }
    fn require_hold_during_active_time(&self) -> &bool {
        self._glacier_base.require_hold_during_active_time()
    }
    fn infinite_activation_time(&self) -> &bool {
        self._glacier_base.infinite_activation_time()
    }
    fn activation_time(&self) -> &f32 {
        self._glacier_base.activation_time()
    }
    fn require_hold_during_activation_time(&self) -> &bool {
        self._glacier_base.require_hold_during_activation_time()
    }
    fn infinite_recharge_time(&self) -> &bool {
        self._glacier_base.infinite_recharge_time()
    }
    fn recharge_time(&self) -> &f32 {
        self._glacier_base.recharge_time()
    }
    fn disable_on_recharge(&self) -> &bool {
        self._glacier_base.disable_on_recharge()
    }
    fn disable_on_player_exit(&self) -> &bool {
        self._glacier_base.disable_on_player_exit()
    }
    fn disable_on_controllable_death(&self) -> &bool {
        self._glacier_base.disable_on_controllable_death()
    }
    fn remove_on_disable(&self) -> &bool {
        self._glacier_base.remove_on_disable()
    }
    fn supports_input_queue(&self) -> &bool {
        self._glacier_base.supports_input_queue()
    }
    fn input_queue_apply_order(&self) -> &i32 {
        self._glacier_base.input_queue_apply_order()
    }
    fn blocking_channels(&self) -> &Vec<Option<Arc<Mutex<dyn super::soldier_shared::CharacterStateRequiredChannelValueDataTrait>>>> {
        self._glacier_base.blocking_channels()
    }
    fn set_channels_when_activating(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateChannelValueDataTrait>>>> {
        self._glacier_base.set_channels_when_activating()
    }
    fn set_channels_when_active(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateChannelValueDataTrait>>>> {
        self._glacier_base.set_channels_when_active()
    }
    fn activate_when_button_is_down(&self) -> &bool {
        self._glacier_base.activate_when_button_is_down()
    }
}

impl CorrectedPlayerAbilityAssetTrait for SoldierWeaponPlayerAbilityAsset {
}

impl PlayerAbilityAssetTrait for SoldierWeaponPlayerAbilityAsset {
    fn is_supported_on_a_i_players(&self) -> &bool {
        self._glacier_base.is_supported_on_a_i_players()
    }
    fn is_supported_on_human_players(&self) -> &bool {
        self._glacier_base.is_supported_on_human_players()
    }
    fn has_bonus_levels(&self) -> &bool {
        self._glacier_base.has_bonus_levels()
    }
    fn unlock(&self) -> &Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>> {
        self._glacier_base.unlock()
    }
    fn category(&self) -> &PlayerAbilityCategory {
        self._glacier_base.category()
    }
    fn blueprint(&self) -> &Option<Arc<Mutex<dyn super::entity::BlueprintTrait>>> {
        self._glacier_base.blueprint()
    }
    fn ignore_networking_errors(&self) -> &bool {
        self._glacier_base.ignore_networking_errors()
    }
    fn reset_on_spawn(&self) -> &bool {
        self._glacier_base.reset_on_spawn()
    }
    fn descriptor_ids(&self) -> &Vec<u32> {
        self._glacier_base.descriptor_ids()
    }
    fn input_modifiers(&self) -> &Vec<PlayerAbilityInputModifier> {
        self._glacier_base.input_modifiers()
    }
    fn block_player_abilities_rules(&self) -> &Vec<PlayerAbilityBlockingRule> {
        self._glacier_base.block_player_abilities_rules()
    }
    fn apply_block_player_abilities_during_active(&self) -> &bool {
        self._glacier_base.apply_block_player_abilities_during_active()
    }
    fn apply_block_player_abilities_during_activation(&self) -> &bool {
        self._glacier_base.apply_block_player_abilities_during_activation()
    }
    fn blocked_player_ability_ids(&self) -> &Vec<u32> {
        self._glacier_base.blocked_player_ability_ids()
    }
    fn unblocked_by_ability_id(&self) -> &u32 {
        self._glacier_base.unblocked_by_ability_id()
    }
    fn identifier(&self) -> &u32 {
        self._glacier_base.identifier()
    }
    fn is_hidden(&self) -> &bool {
        self._glacier_base.is_hidden()
    }
    fn ability_modifiers(&self) -> &Vec<Option<Arc<Mutex<dyn PlayerAbilityModifierTrait>>>> {
        self._glacier_base.ability_modifiers()
    }
    fn is_default_unlocked(&self) -> &bool {
        self._glacier_base.is_default_unlocked()
    }
    fn drop_as_pickup_on_death(&self) -> &bool {
        self._glacier_base.drop_as_pickup_on_death()
    }
    fn pickup_blueprint(&self) -> &Option<Arc<Mutex<dyn PlayerAbilityPickupEntityBlueprintTrait>>> {
        self._glacier_base.pickup_blueprint()
    }
    fn non_streamed_pickup_mesh(&self) -> &Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        self._glacier_base.non_streamed_pickup_mesh()
    }
}

impl PlayerAbilityAssetBaseTrait for SoldierWeaponPlayerAbilityAsset {
}

impl super::core::DataContainerPolicyAssetTrait for SoldierWeaponPlayerAbilityAsset {
}

impl super::core::AssetTrait for SoldierWeaponPlayerAbilityAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for SoldierWeaponPlayerAbilityAsset {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SOLDIERWEAPONPLAYERABILITYASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierWeaponPlayerAbilityAsset",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(BASICPLAYERABILITYASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierWeaponPlayerAbilityAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "StartDeployingOnActivation",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierWeaponPlayerAbilityAsset, start_deploying_on_activation),
            },
            FieldInfoData {
                name: "StayInActivatingDuringDeploy",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierWeaponPlayerAbilityAsset, stay_in_activating_during_deploy),
            },
            FieldInfoData {
                name: "AutomaticallySwitchBackOnOutOfAmmo",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierWeaponPlayerAbilityAsset, automatically_switch_back_on_out_of_ammo),
            },
            FieldInfoData {
                name: "AutomaticallyRechargeOnOutOfAmmo",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierWeaponPlayerAbilityAsset, automatically_recharge_on_out_of_ammo),
            },
            FieldInfoData {
                name: "RefillMagazineOnReady",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierWeaponPlayerAbilityAsset, refill_magazine_on_ready),
            },
            FieldInfoData {
                name: "AutomaticallyEquip",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierWeaponPlayerAbilityAsset, automatically_equip),
            },
            FieldInfoData {
                name: "AutomaticallyFire",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierWeaponPlayerAbilityAsset, automatically_fire),
            },
            FieldInfoData {
                name: "SecondaryFireAbilities",
                flags: MemberInfoFlags::new(144),
                field_type: "Uint32-Array",
                rust_offset: offset_of!(SoldierWeaponPlayerAbilityAsset, secondary_fire_abilities),
            },
        ],
    }),
    array_type: Some(SOLDIERWEAPONPLAYERABILITYASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoldierWeaponPlayerAbilityAsset {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERWEAPONPLAYERABILITYASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SOLDIERWEAPONPLAYERABILITYASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierWeaponPlayerAbilityAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("SoldierWeaponPlayerAbilityAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PassivePlayerAbilityAsset {
    pub _glacier_base: PlayerAbilityAsset,
}

pub trait PassivePlayerAbilityAssetTrait: PlayerAbilityAssetTrait {
}

impl PassivePlayerAbilityAssetTrait for PassivePlayerAbilityAsset {
}

impl PlayerAbilityAssetTrait for PassivePlayerAbilityAsset {
    fn is_supported_on_a_i_players(&self) -> &bool {
        self._glacier_base.is_supported_on_a_i_players()
    }
    fn is_supported_on_human_players(&self) -> &bool {
        self._glacier_base.is_supported_on_human_players()
    }
    fn has_bonus_levels(&self) -> &bool {
        self._glacier_base.has_bonus_levels()
    }
    fn unlock(&self) -> &Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>> {
        self._glacier_base.unlock()
    }
    fn category(&self) -> &PlayerAbilityCategory {
        self._glacier_base.category()
    }
    fn blueprint(&self) -> &Option<Arc<Mutex<dyn super::entity::BlueprintTrait>>> {
        self._glacier_base.blueprint()
    }
    fn ignore_networking_errors(&self) -> &bool {
        self._glacier_base.ignore_networking_errors()
    }
    fn reset_on_spawn(&self) -> &bool {
        self._glacier_base.reset_on_spawn()
    }
    fn descriptor_ids(&self) -> &Vec<u32> {
        self._glacier_base.descriptor_ids()
    }
    fn input_modifiers(&self) -> &Vec<PlayerAbilityInputModifier> {
        self._glacier_base.input_modifiers()
    }
    fn block_player_abilities_rules(&self) -> &Vec<PlayerAbilityBlockingRule> {
        self._glacier_base.block_player_abilities_rules()
    }
    fn apply_block_player_abilities_during_active(&self) -> &bool {
        self._glacier_base.apply_block_player_abilities_during_active()
    }
    fn apply_block_player_abilities_during_activation(&self) -> &bool {
        self._glacier_base.apply_block_player_abilities_during_activation()
    }
    fn blocked_player_ability_ids(&self) -> &Vec<u32> {
        self._glacier_base.blocked_player_ability_ids()
    }
    fn unblocked_by_ability_id(&self) -> &u32 {
        self._glacier_base.unblocked_by_ability_id()
    }
    fn identifier(&self) -> &u32 {
        self._glacier_base.identifier()
    }
    fn is_hidden(&self) -> &bool {
        self._glacier_base.is_hidden()
    }
    fn ability_modifiers(&self) -> &Vec<Option<Arc<Mutex<dyn PlayerAbilityModifierTrait>>>> {
        self._glacier_base.ability_modifiers()
    }
    fn is_default_unlocked(&self) -> &bool {
        self._glacier_base.is_default_unlocked()
    }
    fn drop_as_pickup_on_death(&self) -> &bool {
        self._glacier_base.drop_as_pickup_on_death()
    }
    fn pickup_blueprint(&self) -> &Option<Arc<Mutex<dyn PlayerAbilityPickupEntityBlueprintTrait>>> {
        self._glacier_base.pickup_blueprint()
    }
    fn non_streamed_pickup_mesh(&self) -> &Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        self._glacier_base.non_streamed_pickup_mesh()
    }
}

impl PlayerAbilityAssetBaseTrait for PassivePlayerAbilityAsset {
}

impl super::core::DataContainerPolicyAssetTrait for PassivePlayerAbilityAsset {
}

impl super::core::AssetTrait for PassivePlayerAbilityAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for PassivePlayerAbilityAsset {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PASSIVEPLAYERABILITYASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PassivePlayerAbilityAsset",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PLAYERABILITYASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PassivePlayerAbilityAsset as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(PASSIVEPLAYERABILITYASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PassivePlayerAbilityAsset {
    fn type_info(&self) -> &'static TypeInfo {
        PASSIVEPLAYERABILITYASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PASSIVEPLAYERABILITYASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PassivePlayerAbilityAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PassivePlayerAbilityAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BasicPlayerAbilityAsset {
    pub _glacier_base: CorrectedPlayerAbilityAsset,
    pub infinite_active_time: bool,
    pub active_time: f32,
    pub require_hold_during_active_time: bool,
    pub infinite_activation_time: bool,
    pub activation_time: f32,
    pub require_hold_during_activation_time: bool,
    pub infinite_recharge_time: bool,
    pub recharge_time: f32,
    pub disable_on_recharge: bool,
    pub disable_on_player_exit: bool,
    pub disable_on_controllable_death: bool,
    pub remove_on_disable: bool,
    pub supports_input_queue: bool,
    pub input_queue_apply_order: i32,
    pub blocking_channels: Vec<Option<Arc<Mutex<dyn super::soldier_shared::CharacterStateRequiredChannelValueDataTrait>>>>,
    pub set_channels_when_activating: Vec<Option<Arc<Mutex<dyn CharacterStateChannelValueDataTrait>>>>,
    pub set_channels_when_active: Vec<Option<Arc<Mutex<dyn CharacterStateChannelValueDataTrait>>>>,
    pub activate_when_button_is_down: bool,
}

pub trait BasicPlayerAbilityAssetTrait: CorrectedPlayerAbilityAssetTrait {
    fn infinite_active_time(&self) -> &bool;
    fn active_time(&self) -> &f32;
    fn require_hold_during_active_time(&self) -> &bool;
    fn infinite_activation_time(&self) -> &bool;
    fn activation_time(&self) -> &f32;
    fn require_hold_during_activation_time(&self) -> &bool;
    fn infinite_recharge_time(&self) -> &bool;
    fn recharge_time(&self) -> &f32;
    fn disable_on_recharge(&self) -> &bool;
    fn disable_on_player_exit(&self) -> &bool;
    fn disable_on_controllable_death(&self) -> &bool;
    fn remove_on_disable(&self) -> &bool;
    fn supports_input_queue(&self) -> &bool;
    fn input_queue_apply_order(&self) -> &i32;
    fn blocking_channels(&self) -> &Vec<Option<Arc<Mutex<dyn super::soldier_shared::CharacterStateRequiredChannelValueDataTrait>>>>;
    fn set_channels_when_activating(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateChannelValueDataTrait>>>>;
    fn set_channels_when_active(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateChannelValueDataTrait>>>>;
    fn activate_when_button_is_down(&self) -> &bool;
}

impl BasicPlayerAbilityAssetTrait for BasicPlayerAbilityAsset {
    fn infinite_active_time(&self) -> &bool {
        &self.infinite_active_time
    }
    fn active_time(&self) -> &f32 {
        &self.active_time
    }
    fn require_hold_during_active_time(&self) -> &bool {
        &self.require_hold_during_active_time
    }
    fn infinite_activation_time(&self) -> &bool {
        &self.infinite_activation_time
    }
    fn activation_time(&self) -> &f32 {
        &self.activation_time
    }
    fn require_hold_during_activation_time(&self) -> &bool {
        &self.require_hold_during_activation_time
    }
    fn infinite_recharge_time(&self) -> &bool {
        &self.infinite_recharge_time
    }
    fn recharge_time(&self) -> &f32 {
        &self.recharge_time
    }
    fn disable_on_recharge(&self) -> &bool {
        &self.disable_on_recharge
    }
    fn disable_on_player_exit(&self) -> &bool {
        &self.disable_on_player_exit
    }
    fn disable_on_controllable_death(&self) -> &bool {
        &self.disable_on_controllable_death
    }
    fn remove_on_disable(&self) -> &bool {
        &self.remove_on_disable
    }
    fn supports_input_queue(&self) -> &bool {
        &self.supports_input_queue
    }
    fn input_queue_apply_order(&self) -> &i32 {
        &self.input_queue_apply_order
    }
    fn blocking_channels(&self) -> &Vec<Option<Arc<Mutex<dyn super::soldier_shared::CharacterStateRequiredChannelValueDataTrait>>>> {
        &self.blocking_channels
    }
    fn set_channels_when_activating(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateChannelValueDataTrait>>>> {
        &self.set_channels_when_activating
    }
    fn set_channels_when_active(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateChannelValueDataTrait>>>> {
        &self.set_channels_when_active
    }
    fn activate_when_button_is_down(&self) -> &bool {
        &self.activate_when_button_is_down
    }
}

impl CorrectedPlayerAbilityAssetTrait for BasicPlayerAbilityAsset {
}

impl PlayerAbilityAssetTrait for BasicPlayerAbilityAsset {
    fn is_supported_on_a_i_players(&self) -> &bool {
        self._glacier_base.is_supported_on_a_i_players()
    }
    fn is_supported_on_human_players(&self) -> &bool {
        self._glacier_base.is_supported_on_human_players()
    }
    fn has_bonus_levels(&self) -> &bool {
        self._glacier_base.has_bonus_levels()
    }
    fn unlock(&self) -> &Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>> {
        self._glacier_base.unlock()
    }
    fn category(&self) -> &PlayerAbilityCategory {
        self._glacier_base.category()
    }
    fn blueprint(&self) -> &Option<Arc<Mutex<dyn super::entity::BlueprintTrait>>> {
        self._glacier_base.blueprint()
    }
    fn ignore_networking_errors(&self) -> &bool {
        self._glacier_base.ignore_networking_errors()
    }
    fn reset_on_spawn(&self) -> &bool {
        self._glacier_base.reset_on_spawn()
    }
    fn descriptor_ids(&self) -> &Vec<u32> {
        self._glacier_base.descriptor_ids()
    }
    fn input_modifiers(&self) -> &Vec<PlayerAbilityInputModifier> {
        self._glacier_base.input_modifiers()
    }
    fn block_player_abilities_rules(&self) -> &Vec<PlayerAbilityBlockingRule> {
        self._glacier_base.block_player_abilities_rules()
    }
    fn apply_block_player_abilities_during_active(&self) -> &bool {
        self._glacier_base.apply_block_player_abilities_during_active()
    }
    fn apply_block_player_abilities_during_activation(&self) -> &bool {
        self._glacier_base.apply_block_player_abilities_during_activation()
    }
    fn blocked_player_ability_ids(&self) -> &Vec<u32> {
        self._glacier_base.blocked_player_ability_ids()
    }
    fn unblocked_by_ability_id(&self) -> &u32 {
        self._glacier_base.unblocked_by_ability_id()
    }
    fn identifier(&self) -> &u32 {
        self._glacier_base.identifier()
    }
    fn is_hidden(&self) -> &bool {
        self._glacier_base.is_hidden()
    }
    fn ability_modifiers(&self) -> &Vec<Option<Arc<Mutex<dyn PlayerAbilityModifierTrait>>>> {
        self._glacier_base.ability_modifiers()
    }
    fn is_default_unlocked(&self) -> &bool {
        self._glacier_base.is_default_unlocked()
    }
    fn drop_as_pickup_on_death(&self) -> &bool {
        self._glacier_base.drop_as_pickup_on_death()
    }
    fn pickup_blueprint(&self) -> &Option<Arc<Mutex<dyn PlayerAbilityPickupEntityBlueprintTrait>>> {
        self._glacier_base.pickup_blueprint()
    }
    fn non_streamed_pickup_mesh(&self) -> &Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        self._glacier_base.non_streamed_pickup_mesh()
    }
}

impl PlayerAbilityAssetBaseTrait for BasicPlayerAbilityAsset {
}

impl super::core::DataContainerPolicyAssetTrait for BasicPlayerAbilityAsset {
}

impl super::core::AssetTrait for BasicPlayerAbilityAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for BasicPlayerAbilityAsset {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static BASICPLAYERABILITYASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BasicPlayerAbilityAsset",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CORRECTEDPLAYERABILITYASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BasicPlayerAbilityAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "InfiniteActiveTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BasicPlayerAbilityAsset, infinite_active_time),
            },
            FieldInfoData {
                name: "ActiveTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BasicPlayerAbilityAsset, active_time),
            },
            FieldInfoData {
                name: "RequireHoldDuringActiveTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BasicPlayerAbilityAsset, require_hold_during_active_time),
            },
            FieldInfoData {
                name: "InfiniteActivationTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BasicPlayerAbilityAsset, infinite_activation_time),
            },
            FieldInfoData {
                name: "ActivationTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BasicPlayerAbilityAsset, activation_time),
            },
            FieldInfoData {
                name: "RequireHoldDuringActivationTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BasicPlayerAbilityAsset, require_hold_during_activation_time),
            },
            FieldInfoData {
                name: "InfiniteRechargeTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BasicPlayerAbilityAsset, infinite_recharge_time),
            },
            FieldInfoData {
                name: "RechargeTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BasicPlayerAbilityAsset, recharge_time),
            },
            FieldInfoData {
                name: "DisableOnRecharge",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BasicPlayerAbilityAsset, disable_on_recharge),
            },
            FieldInfoData {
                name: "DisableOnPlayerExit",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BasicPlayerAbilityAsset, disable_on_player_exit),
            },
            FieldInfoData {
                name: "DisableOnControllableDeath",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BasicPlayerAbilityAsset, disable_on_controllable_death),
            },
            FieldInfoData {
                name: "RemoveOnDisable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BasicPlayerAbilityAsset, remove_on_disable),
            },
            FieldInfoData {
                name: "SupportsInputQueue",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BasicPlayerAbilityAsset, supports_input_queue),
            },
            FieldInfoData {
                name: "InputQueueApplyOrder",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(BasicPlayerAbilityAsset, input_queue_apply_order),
            },
            FieldInfoData {
                name: "BlockingChannels",
                flags: MemberInfoFlags::new(144),
                field_type: "CharacterStateRequiredChannelValueData-Array",
                rust_offset: offset_of!(BasicPlayerAbilityAsset, blocking_channels),
            },
            FieldInfoData {
                name: "SetChannelsWhenActivating",
                flags: MemberInfoFlags::new(144),
                field_type: "CharacterStateChannelValueData-Array",
                rust_offset: offset_of!(BasicPlayerAbilityAsset, set_channels_when_activating),
            },
            FieldInfoData {
                name: "SetChannelsWhenActive",
                flags: MemberInfoFlags::new(144),
                field_type: "CharacterStateChannelValueData-Array",
                rust_offset: offset_of!(BasicPlayerAbilityAsset, set_channels_when_active),
            },
            FieldInfoData {
                name: "ActivateWhenButtonIsDown",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BasicPlayerAbilityAsset, activate_when_button_is_down),
            },
        ],
    }),
    array_type: Some(BASICPLAYERABILITYASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BasicPlayerAbilityAsset {
    fn type_info(&self) -> &'static TypeInfo {
        BASICPLAYERABILITYASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static BASICPLAYERABILITYASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BasicPlayerAbilityAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("BasicPlayerAbilityAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CorrectedPlayerAbilityAsset {
    pub _glacier_base: PlayerAbilityAsset,
}

pub trait CorrectedPlayerAbilityAssetTrait: PlayerAbilityAssetTrait {
}

impl CorrectedPlayerAbilityAssetTrait for CorrectedPlayerAbilityAsset {
}

impl PlayerAbilityAssetTrait for CorrectedPlayerAbilityAsset {
    fn is_supported_on_a_i_players(&self) -> &bool {
        self._glacier_base.is_supported_on_a_i_players()
    }
    fn is_supported_on_human_players(&self) -> &bool {
        self._glacier_base.is_supported_on_human_players()
    }
    fn has_bonus_levels(&self) -> &bool {
        self._glacier_base.has_bonus_levels()
    }
    fn unlock(&self) -> &Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>> {
        self._glacier_base.unlock()
    }
    fn category(&self) -> &PlayerAbilityCategory {
        self._glacier_base.category()
    }
    fn blueprint(&self) -> &Option<Arc<Mutex<dyn super::entity::BlueprintTrait>>> {
        self._glacier_base.blueprint()
    }
    fn ignore_networking_errors(&self) -> &bool {
        self._glacier_base.ignore_networking_errors()
    }
    fn reset_on_spawn(&self) -> &bool {
        self._glacier_base.reset_on_spawn()
    }
    fn descriptor_ids(&self) -> &Vec<u32> {
        self._glacier_base.descriptor_ids()
    }
    fn input_modifiers(&self) -> &Vec<PlayerAbilityInputModifier> {
        self._glacier_base.input_modifiers()
    }
    fn block_player_abilities_rules(&self) -> &Vec<PlayerAbilityBlockingRule> {
        self._glacier_base.block_player_abilities_rules()
    }
    fn apply_block_player_abilities_during_active(&self) -> &bool {
        self._glacier_base.apply_block_player_abilities_during_active()
    }
    fn apply_block_player_abilities_during_activation(&self) -> &bool {
        self._glacier_base.apply_block_player_abilities_during_activation()
    }
    fn blocked_player_ability_ids(&self) -> &Vec<u32> {
        self._glacier_base.blocked_player_ability_ids()
    }
    fn unblocked_by_ability_id(&self) -> &u32 {
        self._glacier_base.unblocked_by_ability_id()
    }
    fn identifier(&self) -> &u32 {
        self._glacier_base.identifier()
    }
    fn is_hidden(&self) -> &bool {
        self._glacier_base.is_hidden()
    }
    fn ability_modifiers(&self) -> &Vec<Option<Arc<Mutex<dyn PlayerAbilityModifierTrait>>>> {
        self._glacier_base.ability_modifiers()
    }
    fn is_default_unlocked(&self) -> &bool {
        self._glacier_base.is_default_unlocked()
    }
    fn drop_as_pickup_on_death(&self) -> &bool {
        self._glacier_base.drop_as_pickup_on_death()
    }
    fn pickup_blueprint(&self) -> &Option<Arc<Mutex<dyn PlayerAbilityPickupEntityBlueprintTrait>>> {
        self._glacier_base.pickup_blueprint()
    }
    fn non_streamed_pickup_mesh(&self) -> &Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        self._glacier_base.non_streamed_pickup_mesh()
    }
}

impl PlayerAbilityAssetBaseTrait for CorrectedPlayerAbilityAsset {
}

impl super::core::DataContainerPolicyAssetTrait for CorrectedPlayerAbilityAsset {
}

impl super::core::AssetTrait for CorrectedPlayerAbilityAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for CorrectedPlayerAbilityAsset {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CORRECTEDPLAYERABILITYASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CorrectedPlayerAbilityAsset",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PLAYERABILITYASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CorrectedPlayerAbilityAsset as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(CORRECTEDPLAYERABILITYASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CorrectedPlayerAbilityAsset {
    fn type_info(&self) -> &'static TypeInfo {
        CORRECTEDPLAYERABILITYASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CORRECTEDPLAYERABILITYASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CorrectedPlayerAbilityAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CorrectedPlayerAbilityAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateVec3ChannelValueData {
    pub _glacier_base: CharacterStateChannelValueData,
    pub channel: Option<Arc<Mutex<dyn super::soldier_shared::CharacterStatePublicVec3ChannelDataTrait>>>,
    pub value: super::core::Vec3,
    pub reset_value: super::core::Vec3,
}

pub trait CharacterStateVec3ChannelValueDataTrait: CharacterStateChannelValueDataTrait {
    fn channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::CharacterStatePublicVec3ChannelDataTrait>>>;
    fn value(&self) -> &super::core::Vec3;
    fn reset_value(&self) -> &super::core::Vec3;
}

impl CharacterStateVec3ChannelValueDataTrait for CharacterStateVec3ChannelValueData {
    fn channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::CharacterStatePublicVec3ChannelDataTrait>>> {
        &self.channel
    }
    fn value(&self) -> &super::core::Vec3 {
        &self.value
    }
    fn reset_value(&self) -> &super::core::Vec3 {
        &self.reset_value
    }
}

impl CharacterStateChannelValueDataTrait for CharacterStateVec3ChannelValueData {
    fn set_value_on_try_activate(&self) -> &bool {
        self._glacier_base.set_value_on_try_activate()
    }
    fn reset_value_on_fail_activate(&self) -> &bool {
        self._glacier_base.reset_value_on_fail_activate()
    }
}

impl super::core::DataContainerTrait for CharacterStateVec3ChannelValueData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATEVEC3CHANNELVALUEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateVec3ChannelValueData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATECHANNELVALUEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateVec3ChannelValueData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Channel",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterStatePublicVec3ChannelData",
                rust_offset: offset_of!(CharacterStateVec3ChannelValueData, channel),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(CharacterStateVec3ChannelValueData, value),
            },
            FieldInfoData {
                name: "ResetValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(CharacterStateVec3ChannelValueData, reset_value),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEVEC3CHANNELVALUEDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CharacterStateVec3ChannelValueData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEVEC3CHANNELVALUEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEVEC3CHANNELVALUEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateVec3ChannelValueData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateVec3ChannelValueData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateFloatChannelValueData {
    pub _glacier_base: CharacterStateChannelValueData,
    pub channel: Option<Arc<Mutex<dyn super::soldier_shared::CharacterStatePublicFloatChannelDataTrait>>>,
    pub value: f32,
    pub reset_value: f32,
}

pub trait CharacterStateFloatChannelValueDataTrait: CharacterStateChannelValueDataTrait {
    fn channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::CharacterStatePublicFloatChannelDataTrait>>>;
    fn value(&self) -> &f32;
    fn reset_value(&self) -> &f32;
}

impl CharacterStateFloatChannelValueDataTrait for CharacterStateFloatChannelValueData {
    fn channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::CharacterStatePublicFloatChannelDataTrait>>> {
        &self.channel
    }
    fn value(&self) -> &f32 {
        &self.value
    }
    fn reset_value(&self) -> &f32 {
        &self.reset_value
    }
}

impl CharacterStateChannelValueDataTrait for CharacterStateFloatChannelValueData {
    fn set_value_on_try_activate(&self) -> &bool {
        self._glacier_base.set_value_on_try_activate()
    }
    fn reset_value_on_fail_activate(&self) -> &bool {
        self._glacier_base.reset_value_on_fail_activate()
    }
}

impl super::core::DataContainerTrait for CharacterStateFloatChannelValueData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATEFLOATCHANNELVALUEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateFloatChannelValueData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATECHANNELVALUEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateFloatChannelValueData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Channel",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterStatePublicFloatChannelData",
                rust_offset: offset_of!(CharacterStateFloatChannelValueData, channel),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateFloatChannelValueData, value),
            },
            FieldInfoData {
                name: "ResetValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateFloatChannelValueData, reset_value),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEFLOATCHANNELVALUEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateFloatChannelValueData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEFLOATCHANNELVALUEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEFLOATCHANNELVALUEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateFloatChannelValueData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateFloatChannelValueData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateIntChannelValueData {
    pub _glacier_base: CharacterStateChannelValueData,
    pub channel: Option<Arc<Mutex<dyn super::soldier_shared::CharacterStatePublicIntChannelDataTrait>>>,
    pub value: i32,
    pub reset_value: i32,
}

pub trait CharacterStateIntChannelValueDataTrait: CharacterStateChannelValueDataTrait {
    fn channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::CharacterStatePublicIntChannelDataTrait>>>;
    fn value(&self) -> &i32;
    fn reset_value(&self) -> &i32;
}

impl CharacterStateIntChannelValueDataTrait for CharacterStateIntChannelValueData {
    fn channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::CharacterStatePublicIntChannelDataTrait>>> {
        &self.channel
    }
    fn value(&self) -> &i32 {
        &self.value
    }
    fn reset_value(&self) -> &i32 {
        &self.reset_value
    }
}

impl CharacterStateChannelValueDataTrait for CharacterStateIntChannelValueData {
    fn set_value_on_try_activate(&self) -> &bool {
        self._glacier_base.set_value_on_try_activate()
    }
    fn reset_value_on_fail_activate(&self) -> &bool {
        self._glacier_base.reset_value_on_fail_activate()
    }
}

impl super::core::DataContainerTrait for CharacterStateIntChannelValueData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATEINTCHANNELVALUEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateIntChannelValueData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATECHANNELVALUEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateIntChannelValueData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Channel",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterStatePublicIntChannelData",
                rust_offset: offset_of!(CharacterStateIntChannelValueData, channel),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CharacterStateIntChannelValueData, value),
            },
            FieldInfoData {
                name: "ResetValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CharacterStateIntChannelValueData, reset_value),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEINTCHANNELVALUEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateIntChannelValueData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEINTCHANNELVALUEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEINTCHANNELVALUEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateIntChannelValueData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateIntChannelValueData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateBoolChannelValueData {
    pub _glacier_base: CharacterStateChannelValueData,
    pub channel: Option<Arc<Mutex<dyn super::soldier_shared::CharacterStatePublicBoolChannelDataTrait>>>,
    pub value: bool,
    pub reset_value: bool,
}

pub trait CharacterStateBoolChannelValueDataTrait: CharacterStateChannelValueDataTrait {
    fn channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::CharacterStatePublicBoolChannelDataTrait>>>;
    fn value(&self) -> &bool;
    fn reset_value(&self) -> &bool;
}

impl CharacterStateBoolChannelValueDataTrait for CharacterStateBoolChannelValueData {
    fn channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::CharacterStatePublicBoolChannelDataTrait>>> {
        &self.channel
    }
    fn value(&self) -> &bool {
        &self.value
    }
    fn reset_value(&self) -> &bool {
        &self.reset_value
    }
}

impl CharacterStateChannelValueDataTrait for CharacterStateBoolChannelValueData {
    fn set_value_on_try_activate(&self) -> &bool {
        self._glacier_base.set_value_on_try_activate()
    }
    fn reset_value_on_fail_activate(&self) -> &bool {
        self._glacier_base.reset_value_on_fail_activate()
    }
}

impl super::core::DataContainerTrait for CharacterStateBoolChannelValueData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATEBOOLCHANNELVALUEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateBoolChannelValueData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATECHANNELVALUEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateBoolChannelValueData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Channel",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterStatePublicBoolChannelData",
                rust_offset: offset_of!(CharacterStateBoolChannelValueData, channel),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateBoolChannelValueData, value),
            },
            FieldInfoData {
                name: "ResetValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateBoolChannelValueData, reset_value),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEBOOLCHANNELVALUEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateBoolChannelValueData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEBOOLCHANNELVALUEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEBOOLCHANNELVALUEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateBoolChannelValueData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateBoolChannelValueData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateChannelValueData {
    pub _glacier_base: super::core::DataContainer,
    pub set_value_on_try_activate: bool,
    pub reset_value_on_fail_activate: bool,
}

pub trait CharacterStateChannelValueDataTrait: super::core::DataContainerTrait {
    fn set_value_on_try_activate(&self) -> &bool;
    fn reset_value_on_fail_activate(&self) -> &bool;
}

impl CharacterStateChannelValueDataTrait for CharacterStateChannelValueData {
    fn set_value_on_try_activate(&self) -> &bool {
        &self.set_value_on_try_activate
    }
    fn reset_value_on_fail_activate(&self) -> &bool {
        &self.reset_value_on_fail_activate
    }
}

impl super::core::DataContainerTrait for CharacterStateChannelValueData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATECHANNELVALUEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateChannelValueData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateChannelValueData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SetValueOnTryActivate",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateChannelValueData, set_value_on_try_activate),
            },
            FieldInfoData {
                name: "ResetValueOnFailActivate",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateChannelValueData, reset_value_on_fail_activate),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATECHANNELVALUEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateChannelValueData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATECHANNELVALUEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATECHANNELVALUEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateChannelValueData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateChannelValueData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlayerAbilityAsset {
    pub _glacier_base: PlayerAbilityAssetBase,
    pub is_supported_on_a_i_players: bool,
    pub is_supported_on_human_players: bool,
    pub has_bonus_levels: bool,
    pub unlock: Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>>,
    pub category: PlayerAbilityCategory,
    pub blueprint: Option<Arc<Mutex<dyn super::entity::BlueprintTrait>>>,
    pub ignore_networking_errors: bool,
    pub reset_on_spawn: bool,
    pub descriptor_ids: Vec<u32>,
    pub input_modifiers: Vec<PlayerAbilityInputModifier>,
    pub block_player_abilities_rules: Vec<PlayerAbilityBlockingRule>,
    pub apply_block_player_abilities_during_active: bool,
    pub apply_block_player_abilities_during_activation: bool,
    pub blocked_player_ability_ids: Vec<u32>,
    pub unblocked_by_ability_id: u32,
    pub identifier: u32,
    pub is_hidden: bool,
    pub ability_modifiers: Vec<Option<Arc<Mutex<dyn PlayerAbilityModifierTrait>>>>,
    pub is_default_unlocked: bool,
    pub drop_as_pickup_on_death: bool,
    pub pickup_blueprint: Option<Arc<Mutex<dyn PlayerAbilityPickupEntityBlueprintTrait>>>,
    pub non_streamed_pickup_mesh: Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>>,
}

pub trait PlayerAbilityAssetTrait: PlayerAbilityAssetBaseTrait {
    fn is_supported_on_a_i_players(&self) -> &bool;
    fn is_supported_on_human_players(&self) -> &bool;
    fn has_bonus_levels(&self) -> &bool;
    fn unlock(&self) -> &Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>>;
    fn category(&self) -> &PlayerAbilityCategory;
    fn blueprint(&self) -> &Option<Arc<Mutex<dyn super::entity::BlueprintTrait>>>;
    fn ignore_networking_errors(&self) -> &bool;
    fn reset_on_spawn(&self) -> &bool;
    fn descriptor_ids(&self) -> &Vec<u32>;
    fn input_modifiers(&self) -> &Vec<PlayerAbilityInputModifier>;
    fn block_player_abilities_rules(&self) -> &Vec<PlayerAbilityBlockingRule>;
    fn apply_block_player_abilities_during_active(&self) -> &bool;
    fn apply_block_player_abilities_during_activation(&self) -> &bool;
    fn blocked_player_ability_ids(&self) -> &Vec<u32>;
    fn unblocked_by_ability_id(&self) -> &u32;
    fn identifier(&self) -> &u32;
    fn is_hidden(&self) -> &bool;
    fn ability_modifiers(&self) -> &Vec<Option<Arc<Mutex<dyn PlayerAbilityModifierTrait>>>>;
    fn is_default_unlocked(&self) -> &bool;
    fn drop_as_pickup_on_death(&self) -> &bool;
    fn pickup_blueprint(&self) -> &Option<Arc<Mutex<dyn PlayerAbilityPickupEntityBlueprintTrait>>>;
    fn non_streamed_pickup_mesh(&self) -> &Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>>;
}

impl PlayerAbilityAssetTrait for PlayerAbilityAsset {
    fn is_supported_on_a_i_players(&self) -> &bool {
        &self.is_supported_on_a_i_players
    }
    fn is_supported_on_human_players(&self) -> &bool {
        &self.is_supported_on_human_players
    }
    fn has_bonus_levels(&self) -> &bool {
        &self.has_bonus_levels
    }
    fn unlock(&self) -> &Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>> {
        &self.unlock
    }
    fn category(&self) -> &PlayerAbilityCategory {
        &self.category
    }
    fn blueprint(&self) -> &Option<Arc<Mutex<dyn super::entity::BlueprintTrait>>> {
        &self.blueprint
    }
    fn ignore_networking_errors(&self) -> &bool {
        &self.ignore_networking_errors
    }
    fn reset_on_spawn(&self) -> &bool {
        &self.reset_on_spawn
    }
    fn descriptor_ids(&self) -> &Vec<u32> {
        &self.descriptor_ids
    }
    fn input_modifiers(&self) -> &Vec<PlayerAbilityInputModifier> {
        &self.input_modifiers
    }
    fn block_player_abilities_rules(&self) -> &Vec<PlayerAbilityBlockingRule> {
        &self.block_player_abilities_rules
    }
    fn apply_block_player_abilities_during_active(&self) -> &bool {
        &self.apply_block_player_abilities_during_active
    }
    fn apply_block_player_abilities_during_activation(&self) -> &bool {
        &self.apply_block_player_abilities_during_activation
    }
    fn blocked_player_ability_ids(&self) -> &Vec<u32> {
        &self.blocked_player_ability_ids
    }
    fn unblocked_by_ability_id(&self) -> &u32 {
        &self.unblocked_by_ability_id
    }
    fn identifier(&self) -> &u32 {
        &self.identifier
    }
    fn is_hidden(&self) -> &bool {
        &self.is_hidden
    }
    fn ability_modifiers(&self) -> &Vec<Option<Arc<Mutex<dyn PlayerAbilityModifierTrait>>>> {
        &self.ability_modifiers
    }
    fn is_default_unlocked(&self) -> &bool {
        &self.is_default_unlocked
    }
    fn drop_as_pickup_on_death(&self) -> &bool {
        &self.drop_as_pickup_on_death
    }
    fn pickup_blueprint(&self) -> &Option<Arc<Mutex<dyn PlayerAbilityPickupEntityBlueprintTrait>>> {
        &self.pickup_blueprint
    }
    fn non_streamed_pickup_mesh(&self) -> &Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        &self.non_streamed_pickup_mesh
    }
}

impl PlayerAbilityAssetBaseTrait for PlayerAbilityAsset {
}

impl super::core::DataContainerPolicyAssetTrait for PlayerAbilityAsset {
}

impl super::core::AssetTrait for PlayerAbilityAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for PlayerAbilityAsset {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PLAYERABILITYASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityAsset",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PLAYERABILITYASSETBASE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayerAbilityAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "IsSupportedOnAIPlayers",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayerAbilityAsset, is_supported_on_a_i_players),
            },
            FieldInfoData {
                name: "IsSupportedOnHumanPlayers",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayerAbilityAsset, is_supported_on_human_players),
            },
            FieldInfoData {
                name: "HasBonusLevels",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayerAbilityAsset, has_bonus_levels),
            },
            FieldInfoData {
                name: "Unlock",
                flags: MemberInfoFlags::new(0),
                field_type: "UnlockAssetBase",
                rust_offset: offset_of!(PlayerAbilityAsset, unlock),
            },
            FieldInfoData {
                name: "Category",
                flags: MemberInfoFlags::new(0),
                field_type: "PlayerAbilityCategory",
                rust_offset: offset_of!(PlayerAbilityAsset, category),
            },
            FieldInfoData {
                name: "Blueprint",
                flags: MemberInfoFlags::new(0),
                field_type: "Blueprint",
                rust_offset: offset_of!(PlayerAbilityAsset, blueprint),
            },
            FieldInfoData {
                name: "IgnoreNetworkingErrors",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayerAbilityAsset, ignore_networking_errors),
            },
            FieldInfoData {
                name: "ResetOnSpawn",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayerAbilityAsset, reset_on_spawn),
            },
            FieldInfoData {
                name: "DescriptorIds",
                flags: MemberInfoFlags::new(144),
                field_type: "Uint32-Array",
                rust_offset: offset_of!(PlayerAbilityAsset, descriptor_ids),
            },
            FieldInfoData {
                name: "InputModifiers",
                flags: MemberInfoFlags::new(144),
                field_type: "PlayerAbilityInputModifier-Array",
                rust_offset: offset_of!(PlayerAbilityAsset, input_modifiers),
            },
            FieldInfoData {
                name: "BlockPlayerAbilitiesRules",
                flags: MemberInfoFlags::new(144),
                field_type: "PlayerAbilityBlockingRule-Array",
                rust_offset: offset_of!(PlayerAbilityAsset, block_player_abilities_rules),
            },
            FieldInfoData {
                name: "ApplyBlockPlayerAbilitiesDuringActive",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayerAbilityAsset, apply_block_player_abilities_during_active),
            },
            FieldInfoData {
                name: "ApplyBlockPlayerAbilitiesDuringActivation",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayerAbilityAsset, apply_block_player_abilities_during_activation),
            },
            FieldInfoData {
                name: "BlockedPlayerAbilityIds",
                flags: MemberInfoFlags::new(144),
                field_type: "Uint32-Array",
                rust_offset: offset_of!(PlayerAbilityAsset, blocked_player_ability_ids),
            },
            FieldInfoData {
                name: "UnblockedByAbilityId",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(PlayerAbilityAsset, unblocked_by_ability_id),
            },
            FieldInfoData {
                name: "Identifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(PlayerAbilityAsset, identifier),
            },
            FieldInfoData {
                name: "IsHidden",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayerAbilityAsset, is_hidden),
            },
            FieldInfoData {
                name: "AbilityModifiers",
                flags: MemberInfoFlags::new(144),
                field_type: "PlayerAbilityModifier-Array",
                rust_offset: offset_of!(PlayerAbilityAsset, ability_modifiers),
            },
            FieldInfoData {
                name: "IsDefaultUnlocked",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayerAbilityAsset, is_default_unlocked),
            },
            FieldInfoData {
                name: "DropAsPickupOnDeath",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayerAbilityAsset, drop_as_pickup_on_death),
            },
            FieldInfoData {
                name: "PickupBlueprint",
                flags: MemberInfoFlags::new(0),
                field_type: "PlayerAbilityPickupEntityBlueprint",
                rust_offset: offset_of!(PlayerAbilityAsset, pickup_blueprint),
            },
            FieldInfoData {
                name: "NonStreamedPickupMesh",
                flags: MemberInfoFlags::new(0),
                field_type: "MeshBaseAsset",
                rust_offset: offset_of!(PlayerAbilityAsset, non_streamed_pickup_mesh),
            },
        ],
    }),
    array_type: Some(PLAYERABILITYASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PlayerAbilityAsset {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERABILITYASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PLAYERABILITYASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PlayerAbilityAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlayerAbilityAssetGroup {
    pub _glacier_base: PlayerAbilityAssetBase,
    pub abilities: Vec<Option<Arc<Mutex<dyn PlayerAbilityAssetBaseTrait>>>>,
}

pub trait PlayerAbilityAssetGroupTrait: PlayerAbilityAssetBaseTrait {
    fn abilities(&self) -> &Vec<Option<Arc<Mutex<dyn PlayerAbilityAssetBaseTrait>>>>;
}

impl PlayerAbilityAssetGroupTrait for PlayerAbilityAssetGroup {
    fn abilities(&self) -> &Vec<Option<Arc<Mutex<dyn PlayerAbilityAssetBaseTrait>>>> {
        &self.abilities
    }
}

impl PlayerAbilityAssetBaseTrait for PlayerAbilityAssetGroup {
}

impl super::core::DataContainerPolicyAssetTrait for PlayerAbilityAssetGroup {
}

impl super::core::AssetTrait for PlayerAbilityAssetGroup {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for PlayerAbilityAssetGroup {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PLAYERABILITYASSETGROUP_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityAssetGroup",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PLAYERABILITYASSETBASE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayerAbilityAssetGroup as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Abilities",
                flags: MemberInfoFlags::new(144),
                field_type: "PlayerAbilityAssetBase-Array",
                rust_offset: offset_of!(PlayerAbilityAssetGroup, abilities),
            },
        ],
    }),
    array_type: Some(PLAYERABILITYASSETGROUP_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PlayerAbilityAssetGroup {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERABILITYASSETGROUP_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PLAYERABILITYASSETGROUP_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityAssetGroup-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PlayerAbilityAssetGroup"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlayerAbilityAssetBase {
    pub _glacier_base: super::core::DataContainerPolicyAsset,
}

pub trait PlayerAbilityAssetBaseTrait: super::core::DataContainerPolicyAssetTrait {
}

impl PlayerAbilityAssetBaseTrait for PlayerAbilityAssetBase {
}

impl super::core::DataContainerPolicyAssetTrait for PlayerAbilityAssetBase {
}

impl super::core::AssetTrait for PlayerAbilityAssetBase {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for PlayerAbilityAssetBase {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PLAYERABILITYASSETBASE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityAssetBase",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINERPOLICYASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayerAbilityAssetBase as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(PLAYERABILITYASSETBASE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PlayerAbilityAssetBase {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERABILITYASSETBASE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PLAYERABILITYASSETBASE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityAssetBase-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PlayerAbilityAssetBase"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlayerAbilitySetCategoryModifier {
    pub blocking_categories: Vec<PlayerAbilityCategory>,
    pub input_modifiers: Vec<PlayerAbilityInputModifier>,
}

pub trait PlayerAbilitySetCategoryModifierTrait: TypeObject {
    fn blocking_categories(&self) -> &Vec<PlayerAbilityCategory>;
    fn input_modifiers(&self) -> &Vec<PlayerAbilityInputModifier>;
}

impl PlayerAbilitySetCategoryModifierTrait for PlayerAbilitySetCategoryModifier {
    fn blocking_categories(&self) -> &Vec<PlayerAbilityCategory> {
        &self.blocking_categories
    }
    fn input_modifiers(&self) -> &Vec<PlayerAbilityInputModifier> {
        &self.input_modifiers
    }
}

pub static PLAYERABILITYSETCATEGORYMODIFIER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilitySetCategoryModifier",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayerAbilitySetCategoryModifier as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "BlockingCategories",
                flags: MemberInfoFlags::new(144),
                field_type: "PlayerAbilityCategory-Array",
                rust_offset: offset_of!(PlayerAbilitySetCategoryModifier, blocking_categories),
            },
            FieldInfoData {
                name: "InputModifiers",
                flags: MemberInfoFlags::new(144),
                field_type: "PlayerAbilityInputModifier-Array",
                rust_offset: offset_of!(PlayerAbilitySetCategoryModifier, input_modifiers),
            },
        ],
    }),
    array_type: Some(PLAYERABILITYSETCATEGORYMODIFIER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PlayerAbilitySetCategoryModifier {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERABILITYSETCATEGORYMODIFIER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PLAYERABILITYSETCATEGORYMODIFIER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilitySetCategoryModifier-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PlayerAbilitySetCategoryModifier"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlayerAbilityInputModifier {
    pub action: i32,
    pub offset: f32,
    pub scale: f32,
    pub apply_input_modifiers_during_active: bool,
    pub apply_input_modifiers_during_activation: bool,
    pub apply_input_modifiers_during_recharging: bool,
    pub apply_input_modifiers_during_ready: bool,
    pub cutoff_time: PlayerAbilityInputModifierTime,
}

pub trait PlayerAbilityInputModifierTrait: TypeObject {
    fn action(&self) -> &i32;
    fn offset(&self) -> &f32;
    fn scale(&self) -> &f32;
    fn apply_input_modifiers_during_active(&self) -> &bool;
    fn apply_input_modifiers_during_activation(&self) -> &bool;
    fn apply_input_modifiers_during_recharging(&self) -> &bool;
    fn apply_input_modifiers_during_ready(&self) -> &bool;
    fn cutoff_time(&self) -> &PlayerAbilityInputModifierTime;
}

impl PlayerAbilityInputModifierTrait for PlayerAbilityInputModifier {
    fn action(&self) -> &i32 {
        &self.action
    }
    fn offset(&self) -> &f32 {
        &self.offset
    }
    fn scale(&self) -> &f32 {
        &self.scale
    }
    fn apply_input_modifiers_during_active(&self) -> &bool {
        &self.apply_input_modifiers_during_active
    }
    fn apply_input_modifiers_during_activation(&self) -> &bool {
        &self.apply_input_modifiers_during_activation
    }
    fn apply_input_modifiers_during_recharging(&self) -> &bool {
        &self.apply_input_modifiers_during_recharging
    }
    fn apply_input_modifiers_during_ready(&self) -> &bool {
        &self.apply_input_modifiers_during_ready
    }
    fn cutoff_time(&self) -> &PlayerAbilityInputModifierTime {
        &self.cutoff_time
    }
}

pub static PLAYERABILITYINPUTMODIFIER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityInputModifier",
    flags: MemberInfoFlags::new(36937),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayerAbilityInputModifier as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Action",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(PlayerAbilityInputModifier, action),
            },
            FieldInfoData {
                name: "Offset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PlayerAbilityInputModifier, offset),
            },
            FieldInfoData {
                name: "Scale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PlayerAbilityInputModifier, scale),
            },
            FieldInfoData {
                name: "ApplyInputModifiersDuringActive",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayerAbilityInputModifier, apply_input_modifiers_during_active),
            },
            FieldInfoData {
                name: "ApplyInputModifiersDuringActivation",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayerAbilityInputModifier, apply_input_modifiers_during_activation),
            },
            FieldInfoData {
                name: "ApplyInputModifiersDuringRecharging",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayerAbilityInputModifier, apply_input_modifiers_during_recharging),
            },
            FieldInfoData {
                name: "ApplyInputModifiersDuringReady",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayerAbilityInputModifier, apply_input_modifiers_during_ready),
            },
            FieldInfoData {
                name: "CutoffTime",
                flags: MemberInfoFlags::new(0),
                field_type: "PlayerAbilityInputModifierTime",
                rust_offset: offset_of!(PlayerAbilityInputModifier, cutoff_time),
            },
        ],
    }),
    array_type: Some(PLAYERABILITYINPUTMODIFIER_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for PlayerAbilityInputModifier {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERABILITYINPUTMODIFIER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PLAYERABILITYINPUTMODIFIER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityInputModifier-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PlayerAbilityInputModifier"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlayerAbilityInputModifierTime {
    pub min: f32,
    pub max: f32,
}

pub trait PlayerAbilityInputModifierTimeTrait: TypeObject {
    fn min(&self) -> &f32;
    fn max(&self) -> &f32;
}

impl PlayerAbilityInputModifierTimeTrait for PlayerAbilityInputModifierTime {
    fn min(&self) -> &f32 {
        &self.min
    }
    fn max(&self) -> &f32 {
        &self.max
    }
}

pub static PLAYERABILITYINPUTMODIFIERTIME_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityInputModifierTime",
    flags: MemberInfoFlags::new(36937),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayerAbilityInputModifierTime as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Min",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PlayerAbilityInputModifierTime, min),
            },
            FieldInfoData {
                name: "Max",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PlayerAbilityInputModifierTime, max),
            },
        ],
    }),
    array_type: Some(PLAYERABILITYINPUTMODIFIERTIME_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for PlayerAbilityInputModifierTime {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERABILITYINPUTMODIFIERTIME_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PLAYERABILITYINPUTMODIFIERTIME_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityInputModifierTime-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PlayerAbilityInputModifierTime"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlayerAbilityBlockingRule {
    pub ability_ids: Vec<u32>,
    pub block_during_active: bool,
    pub block_during_activation: bool,
    pub block_during_recharging: bool,
    pub block_during_ready: bool,
}

pub trait PlayerAbilityBlockingRuleTrait: TypeObject {
    fn ability_ids(&self) -> &Vec<u32>;
    fn block_during_active(&self) -> &bool;
    fn block_during_activation(&self) -> &bool;
    fn block_during_recharging(&self) -> &bool;
    fn block_during_ready(&self) -> &bool;
}

impl PlayerAbilityBlockingRuleTrait for PlayerAbilityBlockingRule {
    fn ability_ids(&self) -> &Vec<u32> {
        &self.ability_ids
    }
    fn block_during_active(&self) -> &bool {
        &self.block_during_active
    }
    fn block_during_activation(&self) -> &bool {
        &self.block_during_activation
    }
    fn block_during_recharging(&self) -> &bool {
        &self.block_during_recharging
    }
    fn block_during_ready(&self) -> &bool {
        &self.block_during_ready
    }
}

pub static PLAYERABILITYBLOCKINGRULE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityBlockingRule",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayerAbilityBlockingRule as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AbilityIds",
                flags: MemberInfoFlags::new(144),
                field_type: "Uint32-Array",
                rust_offset: offset_of!(PlayerAbilityBlockingRule, ability_ids),
            },
            FieldInfoData {
                name: "BlockDuringActive",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayerAbilityBlockingRule, block_during_active),
            },
            FieldInfoData {
                name: "BlockDuringActivation",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayerAbilityBlockingRule, block_during_activation),
            },
            FieldInfoData {
                name: "BlockDuringRecharging",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayerAbilityBlockingRule, block_during_recharging),
            },
            FieldInfoData {
                name: "BlockDuringReady",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayerAbilityBlockingRule, block_during_ready),
            },
        ],
    }),
    array_type: Some(PLAYERABILITYBLOCKINGRULE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PlayerAbilityBlockingRule {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERABILITYBLOCKINGRULE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PLAYERABILITYBLOCKINGRULE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityBlockingRule-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PlayerAbilityBlockingRule"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct NonCustomizablePlayerAbilitySetComponentData {
    pub _glacier_base: PlayerAbilitySetComponentData,
    pub abilities: Vec<Option<Arc<Mutex<dyn PlayerAbilityAssetTrait>>>>,
}

pub trait NonCustomizablePlayerAbilitySetComponentDataTrait: PlayerAbilitySetComponentDataTrait {
    fn abilities(&self) -> &Vec<Option<Arc<Mutex<dyn PlayerAbilityAssetTrait>>>>;
}

impl NonCustomizablePlayerAbilitySetComponentDataTrait for NonCustomizablePlayerAbilitySetComponentData {
    fn abilities(&self) -> &Vec<Option<Arc<Mutex<dyn PlayerAbilityAssetTrait>>>> {
        &self.abilities
    }
}

impl PlayerAbilitySetComponentDataTrait for NonCustomizablePlayerAbilitySetComponentData {
    fn entry_input_action_map(&self) -> &Vec<PlayerAbilityEntryInputContainer> {
        self._glacier_base.entry_input_action_map()
    }
    fn modifiers(&self) -> &Vec<PlayerAbilitySetCategoryModifier> {
        self._glacier_base.modifiers()
    }
    fn input_queue_size(&self) -> &i32 {
        self._glacier_base.input_queue_size()
    }
    fn input_queue_timeout(&self) -> &f32 {
        self._glacier_base.input_queue_timeout()
    }
    fn ability_set_data(&self) -> &AbilitySetDynamicModifierData {
        self._glacier_base.ability_set_data()
    }
    fn detach_player_on_death(&self) -> &bool {
        self._glacier_base.detach_player_on_death()
    }
}

impl super::entity::GameComponentDataTrait for NonCustomizablePlayerAbilitySetComponentData {
}

impl super::entity::ComponentDataTrait for NonCustomizablePlayerAbilitySetComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
}

impl super::entity::GameObjectDataTrait for NonCustomizablePlayerAbilitySetComponentData {
}

impl super::core::DataBusPeerTrait for NonCustomizablePlayerAbilitySetComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for NonCustomizablePlayerAbilitySetComponentData {
}

impl super::core::DataContainerTrait for NonCustomizablePlayerAbilitySetComponentData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static NONCUSTOMIZABLEPLAYERABILITYSETCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NonCustomizablePlayerAbilitySetComponentData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PLAYERABILITYSETCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<NonCustomizablePlayerAbilitySetComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Abilities",
                flags: MemberInfoFlags::new(144),
                field_type: "PlayerAbilityAsset-Array",
                rust_offset: offset_of!(NonCustomizablePlayerAbilitySetComponentData, abilities),
            },
        ],
    }),
    array_type: Some(NONCUSTOMIZABLEPLAYERABILITYSETCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for NonCustomizablePlayerAbilitySetComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        NONCUSTOMIZABLEPLAYERABILITYSETCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static NONCUSTOMIZABLEPLAYERABILITYSETCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NonCustomizablePlayerAbilitySetComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("NonCustomizablePlayerAbilitySetComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlayerAbilitySetComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub entry_input_action_map: Vec<PlayerAbilityEntryInputContainer>,
    pub modifiers: Vec<PlayerAbilitySetCategoryModifier>,
    pub input_queue_size: i32,
    pub input_queue_timeout: f32,
    pub ability_set_data: AbilitySetDynamicModifierData,
    pub detach_player_on_death: bool,
}

pub trait PlayerAbilitySetComponentDataTrait: super::entity::GameComponentDataTrait {
    fn entry_input_action_map(&self) -> &Vec<PlayerAbilityEntryInputContainer>;
    fn modifiers(&self) -> &Vec<PlayerAbilitySetCategoryModifier>;
    fn input_queue_size(&self) -> &i32;
    fn input_queue_timeout(&self) -> &f32;
    fn ability_set_data(&self) -> &AbilitySetDynamicModifierData;
    fn detach_player_on_death(&self) -> &bool;
}

impl PlayerAbilitySetComponentDataTrait for PlayerAbilitySetComponentData {
    fn entry_input_action_map(&self) -> &Vec<PlayerAbilityEntryInputContainer> {
        &self.entry_input_action_map
    }
    fn modifiers(&self) -> &Vec<PlayerAbilitySetCategoryModifier> {
        &self.modifiers
    }
    fn input_queue_size(&self) -> &i32 {
        &self.input_queue_size
    }
    fn input_queue_timeout(&self) -> &f32 {
        &self.input_queue_timeout
    }
    fn ability_set_data(&self) -> &AbilitySetDynamicModifierData {
        &self.ability_set_data
    }
    fn detach_player_on_death(&self) -> &bool {
        &self.detach_player_on_death
    }
}

impl super::entity::GameComponentDataTrait for PlayerAbilitySetComponentData {
}

impl super::entity::ComponentDataTrait for PlayerAbilitySetComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
}

impl super::entity::GameObjectDataTrait for PlayerAbilitySetComponentData {
}

impl super::core::DataBusPeerTrait for PlayerAbilitySetComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for PlayerAbilitySetComponentData {
}

impl super::core::DataContainerTrait for PlayerAbilitySetComponentData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PLAYERABILITYSETCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilitySetComponentData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayerAbilitySetComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "EntryInputActionMap",
                flags: MemberInfoFlags::new(144),
                field_type: "PlayerAbilityEntryInputContainer-Array",
                rust_offset: offset_of!(PlayerAbilitySetComponentData, entry_input_action_map),
            },
            FieldInfoData {
                name: "Modifiers",
                flags: MemberInfoFlags::new(144),
                field_type: "PlayerAbilitySetCategoryModifier-Array",
                rust_offset: offset_of!(PlayerAbilitySetComponentData, modifiers),
            },
            FieldInfoData {
                name: "InputQueueSize",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(PlayerAbilitySetComponentData, input_queue_size),
            },
            FieldInfoData {
                name: "InputQueueTimeout",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PlayerAbilitySetComponentData, input_queue_timeout),
            },
            FieldInfoData {
                name: "AbilitySetData",
                flags: MemberInfoFlags::new(0),
                field_type: "AbilitySetDynamicModifierData",
                rust_offset: offset_of!(PlayerAbilitySetComponentData, ability_set_data),
            },
            FieldInfoData {
                name: "DetachPlayerOnDeath",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayerAbilitySetComponentData, detach_player_on_death),
            },
        ],
    }),
    array_type: Some(PLAYERABILITYSETCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PlayerAbilitySetComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERABILITYSETCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PLAYERABILITYSETCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilitySetComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PlayerAbilitySetComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AbilitySetDynamicModifierData {
    pub recharge_modifiers: Vec<AbilityDynamicFloatModifier>,
}

pub trait AbilitySetDynamicModifierDataTrait: TypeObject {
    fn recharge_modifiers(&self) -> &Vec<AbilityDynamicFloatModifier>;
}

impl AbilitySetDynamicModifierDataTrait for AbilitySetDynamicModifierData {
    fn recharge_modifiers(&self) -> &Vec<AbilityDynamicFloatModifier> {
        &self.recharge_modifiers
    }
}

pub static ABILITYSETDYNAMICMODIFIERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AbilitySetDynamicModifierData",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AbilitySetDynamicModifierData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "RechargeModifiers",
                flags: MemberInfoFlags::new(144),
                field_type: "AbilityDynamicFloatModifier-Array",
                rust_offset: offset_of!(AbilitySetDynamicModifierData, recharge_modifiers),
            },
        ],
    }),
    array_type: Some(ABILITYSETDYNAMICMODIFIERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AbilitySetDynamicModifierData {
    fn type_info(&self) -> &'static TypeInfo {
        ABILITYSETDYNAMICMODIFIERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ABILITYSETDYNAMICMODIFIERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AbilitySetDynamicModifierData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("AbilitySetDynamicModifierData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AbilityDynamicFloatModifier {
    pub channels: Vec<Option<Arc<Mutex<dyn super::soldier_shared::CharacterStatePublicFloatChannelDataTrait>>>>,
    pub descriptor_id: u32,
}

pub trait AbilityDynamicFloatModifierTrait: TypeObject {
    fn channels(&self) -> &Vec<Option<Arc<Mutex<dyn super::soldier_shared::CharacterStatePublicFloatChannelDataTrait>>>>;
    fn descriptor_id(&self) -> &u32;
}

impl AbilityDynamicFloatModifierTrait for AbilityDynamicFloatModifier {
    fn channels(&self) -> &Vec<Option<Arc<Mutex<dyn super::soldier_shared::CharacterStatePublicFloatChannelDataTrait>>>> {
        &self.channels
    }
    fn descriptor_id(&self) -> &u32 {
        &self.descriptor_id
    }
}

pub static ABILITYDYNAMICFLOATMODIFIER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AbilityDynamicFloatModifier",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AbilityDynamicFloatModifier as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Channels",
                flags: MemberInfoFlags::new(144),
                field_type: "CharacterStatePublicFloatChannelData-Array",
                rust_offset: offset_of!(AbilityDynamicFloatModifier, channels),
            },
            FieldInfoData {
                name: "DescriptorId",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(AbilityDynamicFloatModifier, descriptor_id),
            },
        ],
    }),
    array_type: Some(ABILITYDYNAMICFLOATMODIFIER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AbilityDynamicFloatModifier {
    fn type_info(&self) -> &'static TypeInfo {
        ABILITYDYNAMICFLOATMODIFIER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ABILITYDYNAMICFLOATMODIFIER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AbilityDynamicFloatModifier-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("AbilityDynamicFloatModifier"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlayerAbilityPickupEntityBlueprint {
    pub _glacier_base: super::entity::ObjectBlueprint,
}

pub trait PlayerAbilityPickupEntityBlueprintTrait: super::entity::ObjectBlueprintTrait {
}

impl PlayerAbilityPickupEntityBlueprintTrait for PlayerAbilityPickupEntityBlueprint {
}

impl super::entity::ObjectBlueprintTrait for PlayerAbilityPickupEntityBlueprint {
    fn object(&self) -> &Option<Arc<Mutex<dyn super::entity::EntityDataTrait>>> {
        self._glacier_base.object()
    }
}

impl super::entity::BlueprintTrait for PlayerAbilityPickupEntityBlueprint {
    fn objects(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.objects()
    }
    fn schematics(&self) -> &Option<Arc<Mutex<dyn super::schematics::SchematicsBaseAssetTrait>>> {
        self._glacier_base.schematics()
    }
}

impl super::entity::EntityBusDataTrait for PlayerAbilityPickupEntityBlueprint {
    fn event_connections(&self) -> &Vec<super::entity::EventConnection> {
        self._glacier_base.event_connections()
    }
}

impl super::core::DataBusDataTrait for PlayerAbilityPickupEntityBlueprint {
    fn flags(&self) -> &u16 {
        self._glacier_base.flags()
    }
    fn property_connections(&self) -> &Vec<super::core::PropertyConnection> {
        self._glacier_base.property_connections()
    }
    fn link_connections(&self) -> &Vec<super::core::LinkConnection> {
        self._glacier_base.link_connections()
    }
    fn interface(&self) -> &Option<Arc<Mutex<dyn super::core::DynamicDataContainerTrait>>> {
        self._glacier_base.interface()
    }
}

impl super::core::AssetTrait for PlayerAbilityPickupEntityBlueprint {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for PlayerAbilityPickupEntityBlueprint {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PLAYERABILITYPICKUPENTITYBLUEPRINT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityPickupEntityBlueprint",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::OBJECTBLUEPRINT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayerAbilityPickupEntityBlueprint as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(PLAYERABILITYPICKUPENTITYBLUEPRINT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PlayerAbilityPickupEntityBlueprint {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERABILITYPICKUPENTITYBLUEPRINT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PLAYERABILITYPICKUPENTITYBLUEPRINT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityPickupEntityBlueprint-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PlayerAbilityPickupEntityBlueprint"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LinkedPlayerAbilityReferenceEntityData {
    pub _glacier_base: PlayerAbilityReferenceData,
    pub linked_ability_i_ds: Vec<u32>,
}

pub trait LinkedPlayerAbilityReferenceEntityDataTrait: PlayerAbilityReferenceDataTrait {
    fn linked_ability_i_ds(&self) -> &Vec<u32>;
}

impl LinkedPlayerAbilityReferenceEntityDataTrait for LinkedPlayerAbilityReferenceEntityData {
    fn linked_ability_i_ds(&self) -> &Vec<u32> {
        &self.linked_ability_i_ds
    }
}

impl PlayerAbilityReferenceDataTrait for LinkedPlayerAbilityReferenceEntityData {
    fn auto_create_abilities(&self) -> &bool {
        self._glacier_base.auto_create_abilities()
    }
    fn auto_create_player_abilities(&self) -> &Vec<Option<Arc<Mutex<dyn PlayerAbilityAssetTrait>>>> {
        self._glacier_base.auto_create_player_abilities()
    }
}

impl super::entity::LogicReferenceObjectDataTrait for LinkedPlayerAbilityReferenceEntityData {
    fn local_player_id(&self) -> &super::core::LocalPlayerId {
        self._glacier_base.local_player_id()
    }
    fn sub_realm(&self) -> &super::entity::SubRealm {
        self._glacier_base.sub_realm()
    }
}

impl super::entity::ReferenceObjectDataTrait for LinkedPlayerAbilityReferenceEntityData {
    fn blueprint_transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.blueprint_transform()
    }
    fn blueprint(&self) -> &Option<Arc<Mutex<dyn super::entity::BlueprintTrait>>> {
        self._glacier_base.blueprint()
    }
    fn object_variation(&self) -> &Option<Arc<Mutex<dyn super::entity::ObjectVariationTrait>>> {
        self._glacier_base.object_variation()
    }
    fn stream_realm(&self) -> &super::entity::StreamRealm {
        self._glacier_base.stream_realm()
    }
    fn radiosity_type_override(&self) -> &super::core::RadiosityTypeOverride {
        self._glacier_base.radiosity_type_override()
    }
    fn lightmap_resolution_scale(&self) -> &u32 {
        self._glacier_base.lightmap_resolution_scale()
    }
    fn lightmap_scale_with_size(&self) -> &bool {
        self._glacier_base.lightmap_scale_with_size()
    }
    fn rendering_overrides(&self) -> &super::core::RenderingOverrides {
        self._glacier_base.rendering_overrides()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn create_indestructible_entity(&self) -> &bool {
        self._glacier_base.create_indestructible_entity()
    }
}

impl super::entity::GameObjectDataTrait for LinkedPlayerAbilityReferenceEntityData {
}

impl super::core::DataBusPeerTrait for LinkedPlayerAbilityReferenceEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for LinkedPlayerAbilityReferenceEntityData {
}

impl super::core::DataContainerTrait for LinkedPlayerAbilityReferenceEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static LINKEDPLAYERABILITYREFERENCEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkedPlayerAbilityReferenceEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PLAYERABILITYREFERENCEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LinkedPlayerAbilityReferenceEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "LinkedAbilityIDs",
                flags: MemberInfoFlags::new(144),
                field_type: "Uint32-Array",
                rust_offset: offset_of!(LinkedPlayerAbilityReferenceEntityData, linked_ability_i_ds),
            },
        ],
    }),
    array_type: Some(LINKEDPLAYERABILITYREFERENCEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for LinkedPlayerAbilityReferenceEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        LINKEDPLAYERABILITYREFERENCEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static LINKEDPLAYERABILITYREFERENCEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkedPlayerAbilityReferenceEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("LinkedPlayerAbilityReferenceEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LinkedAbilityReferenceEntityData {
    pub _glacier_base: super::entity::LogicReferenceObjectData,
    pub player_ability_identifier: u32,
    pub auto_create_ability: bool,
}

pub trait LinkedAbilityReferenceEntityDataTrait: super::entity::LogicReferenceObjectDataTrait {
    fn player_ability_identifier(&self) -> &u32;
    fn auto_create_ability(&self) -> &bool;
}

impl LinkedAbilityReferenceEntityDataTrait for LinkedAbilityReferenceEntityData {
    fn player_ability_identifier(&self) -> &u32 {
        &self.player_ability_identifier
    }
    fn auto_create_ability(&self) -> &bool {
        &self.auto_create_ability
    }
}

impl super::entity::LogicReferenceObjectDataTrait for LinkedAbilityReferenceEntityData {
    fn local_player_id(&self) -> &super::core::LocalPlayerId {
        self._glacier_base.local_player_id()
    }
    fn sub_realm(&self) -> &super::entity::SubRealm {
        self._glacier_base.sub_realm()
    }
}

impl super::entity::ReferenceObjectDataTrait for LinkedAbilityReferenceEntityData {
    fn blueprint_transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.blueprint_transform()
    }
    fn blueprint(&self) -> &Option<Arc<Mutex<dyn super::entity::BlueprintTrait>>> {
        self._glacier_base.blueprint()
    }
    fn object_variation(&self) -> &Option<Arc<Mutex<dyn super::entity::ObjectVariationTrait>>> {
        self._glacier_base.object_variation()
    }
    fn stream_realm(&self) -> &super::entity::StreamRealm {
        self._glacier_base.stream_realm()
    }
    fn radiosity_type_override(&self) -> &super::core::RadiosityTypeOverride {
        self._glacier_base.radiosity_type_override()
    }
    fn lightmap_resolution_scale(&self) -> &u32 {
        self._glacier_base.lightmap_resolution_scale()
    }
    fn lightmap_scale_with_size(&self) -> &bool {
        self._glacier_base.lightmap_scale_with_size()
    }
    fn rendering_overrides(&self) -> &super::core::RenderingOverrides {
        self._glacier_base.rendering_overrides()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn create_indestructible_entity(&self) -> &bool {
        self._glacier_base.create_indestructible_entity()
    }
}

impl super::entity::GameObjectDataTrait for LinkedAbilityReferenceEntityData {
}

impl super::core::DataBusPeerTrait for LinkedAbilityReferenceEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for LinkedAbilityReferenceEntityData {
}

impl super::core::DataContainerTrait for LinkedAbilityReferenceEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static LINKEDABILITYREFERENCEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkedAbilityReferenceEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::LOGICREFERENCEOBJECTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LinkedAbilityReferenceEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PlayerAbilityIdentifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(LinkedAbilityReferenceEntityData, player_ability_identifier),
            },
            FieldInfoData {
                name: "AutoCreateAbility",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LinkedAbilityReferenceEntityData, auto_create_ability),
            },
        ],
    }),
    array_type: Some(LINKEDABILITYREFERENCEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for LinkedAbilityReferenceEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        LINKEDABILITYREFERENCEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static LINKEDABILITYREFERENCEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkedAbilityReferenceEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("LinkedAbilityReferenceEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ProxyPlayerSquadEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub team: super::gameplay_sim::TeamId,
    pub size: u32,
}

pub trait ProxyPlayerSquadEntityDataTrait: super::entity::EntityDataTrait {
    fn team(&self) -> &super::gameplay_sim::TeamId;
    fn size(&self) -> &u32;
}

impl ProxyPlayerSquadEntityDataTrait for ProxyPlayerSquadEntityData {
    fn team(&self) -> &super::gameplay_sim::TeamId {
        &self.team
    }
    fn size(&self) -> &u32 {
        &self.size
    }
}

impl super::entity::EntityDataTrait for ProxyPlayerSquadEntityData {
}

impl super::entity::GameObjectDataTrait for ProxyPlayerSquadEntityData {
}

impl super::core::DataBusPeerTrait for ProxyPlayerSquadEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for ProxyPlayerSquadEntityData {
}

impl super::core::DataContainerTrait for ProxyPlayerSquadEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PROXYPLAYERSQUADENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ProxyPlayerSquadEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ProxyPlayerSquadEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Team",
                flags: MemberInfoFlags::new(0),
                field_type: "TeamId",
                rust_offset: offset_of!(ProxyPlayerSquadEntityData, team),
            },
            FieldInfoData {
                name: "Size",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(ProxyPlayerSquadEntityData, size),
            },
        ],
    }),
    array_type: Some(PROXYPLAYERSQUADENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ProxyPlayerSquadEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PROXYPLAYERSQUADENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PROXYPLAYERSQUADENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ProxyPlayerSquadEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("ProxyPlayerSquadEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ProxyPlayerSettings {
    pub _glacier_base: super::core::SystemSettings,
    pub client_proxy_player_enabled: bool,
    pub server_proxy_player_enabled: bool,
    pub debug_render_enabled: bool,
}

pub trait ProxyPlayerSettingsTrait: super::core::SystemSettingsTrait {
    fn client_proxy_player_enabled(&self) -> &bool;
    fn server_proxy_player_enabled(&self) -> &bool;
    fn debug_render_enabled(&self) -> &bool;
}

impl ProxyPlayerSettingsTrait for ProxyPlayerSettings {
    fn client_proxy_player_enabled(&self) -> &bool {
        &self.client_proxy_player_enabled
    }
    fn server_proxy_player_enabled(&self) -> &bool {
        &self.server_proxy_player_enabled
    }
    fn debug_render_enabled(&self) -> &bool {
        &self.debug_render_enabled
    }
}

impl super::core::SystemSettingsTrait for ProxyPlayerSettings {
    fn platform(&self) -> &super::core::GamePlatform {
        self._glacier_base.platform()
    }
}

impl super::core::DataContainerTrait for ProxyPlayerSettings {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PROXYPLAYERSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ProxyPlayerSettings",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::SYSTEMSETTINGS_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ProxyPlayerSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ClientProxyPlayerEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ProxyPlayerSettings, client_proxy_player_enabled),
            },
            FieldInfoData {
                name: "ServerProxyPlayerEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ProxyPlayerSettings, server_proxy_player_enabled),
            },
            FieldInfoData {
                name: "DebugRenderEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ProxyPlayerSettings, debug_render_enabled),
            },
        ],
    }),
    array_type: Some(PROXYPLAYERSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ProxyPlayerSettings {
    fn type_info(&self) -> &'static TypeInfo {
        PROXYPLAYERSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PROXYPLAYERSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ProxyPlayerSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("ProxyPlayerSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ProxyPlayerMoveToCommandEntityData {
    pub _glacier_base: ProxyPlayerCommandEntityData,
    pub target: super::core::Vec3,
    pub radius: f32,
    pub speed: f32,
}

pub trait ProxyPlayerMoveToCommandEntityDataTrait: ProxyPlayerCommandEntityDataTrait {
    fn target(&self) -> &super::core::Vec3;
    fn radius(&self) -> &f32;
    fn speed(&self) -> &f32;
}

impl ProxyPlayerMoveToCommandEntityDataTrait for ProxyPlayerMoveToCommandEntityData {
    fn target(&self) -> &super::core::Vec3 {
        &self.target
    }
    fn radius(&self) -> &f32 {
        &self.radius
    }
    fn speed(&self) -> &f32 {
        &self.speed
    }
}

impl ProxyPlayerCommandEntityDataTrait for ProxyPlayerMoveToCommandEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn activated_on_create(&self) -> &bool {
        self._glacier_base.activated_on_create()
    }
}

impl super::entity::EntityDataTrait for ProxyPlayerMoveToCommandEntityData {
}

impl super::entity::GameObjectDataTrait for ProxyPlayerMoveToCommandEntityData {
}

impl super::core::DataBusPeerTrait for ProxyPlayerMoveToCommandEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for ProxyPlayerMoveToCommandEntityData {
}

impl super::core::DataContainerTrait for ProxyPlayerMoveToCommandEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PROXYPLAYERMOVETOCOMMANDENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ProxyPlayerMoveToCommandEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PROXYPLAYERCOMMANDENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ProxyPlayerMoveToCommandEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Target",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(ProxyPlayerMoveToCommandEntityData, target),
            },
            FieldInfoData {
                name: "Radius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ProxyPlayerMoveToCommandEntityData, radius),
            },
            FieldInfoData {
                name: "Speed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ProxyPlayerMoveToCommandEntityData, speed),
            },
        ],
    }),
    array_type: Some(PROXYPLAYERMOVETOCOMMANDENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ProxyPlayerMoveToCommandEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PROXYPLAYERMOVETOCOMMANDENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PROXYPLAYERMOVETOCOMMANDENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ProxyPlayerMoveToCommandEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("ProxyPlayerMoveToCommandEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ProxyPlayerFireCommandEntityData {
    pub _glacier_base: ProxyPlayerCommandEntityData,
    pub firing_patern: u64,
    pub delay: u8,
}

pub trait ProxyPlayerFireCommandEntityDataTrait: ProxyPlayerCommandEntityDataTrait {
    fn firing_patern(&self) -> &u64;
    fn delay(&self) -> &u8;
}

impl ProxyPlayerFireCommandEntityDataTrait for ProxyPlayerFireCommandEntityData {
    fn firing_patern(&self) -> &u64 {
        &self.firing_patern
    }
    fn delay(&self) -> &u8 {
        &self.delay
    }
}

impl ProxyPlayerCommandEntityDataTrait for ProxyPlayerFireCommandEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn activated_on_create(&self) -> &bool {
        self._glacier_base.activated_on_create()
    }
}

impl super::entity::EntityDataTrait for ProxyPlayerFireCommandEntityData {
}

impl super::entity::GameObjectDataTrait for ProxyPlayerFireCommandEntityData {
}

impl super::core::DataBusPeerTrait for ProxyPlayerFireCommandEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for ProxyPlayerFireCommandEntityData {
}

impl super::core::DataContainerTrait for ProxyPlayerFireCommandEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PROXYPLAYERFIRECOMMANDENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ProxyPlayerFireCommandEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PROXYPLAYERCOMMANDENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ProxyPlayerFireCommandEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "FiringPatern",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint64",
                rust_offset: offset_of!(ProxyPlayerFireCommandEntityData, firing_patern),
            },
            FieldInfoData {
                name: "Delay",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(ProxyPlayerFireCommandEntityData, delay),
            },
        ],
    }),
    array_type: Some(PROXYPLAYERFIRECOMMANDENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ProxyPlayerFireCommandEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PROXYPLAYERFIRECOMMANDENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PROXYPLAYERFIRECOMMANDENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ProxyPlayerFireCommandEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("ProxyPlayerFireCommandEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ProxyPlayerCommandEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub activated_on_create: bool,
}

pub trait ProxyPlayerCommandEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn activated_on_create(&self) -> &bool;
}

impl ProxyPlayerCommandEntityDataTrait for ProxyPlayerCommandEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn activated_on_create(&self) -> &bool {
        &self.activated_on_create
    }
}

impl super::entity::EntityDataTrait for ProxyPlayerCommandEntityData {
}

impl super::entity::GameObjectDataTrait for ProxyPlayerCommandEntityData {
}

impl super::core::DataBusPeerTrait for ProxyPlayerCommandEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for ProxyPlayerCommandEntityData {
}

impl super::core::DataContainerTrait for ProxyPlayerCommandEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PROXYPLAYERCOMMANDENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ProxyPlayerCommandEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ProxyPlayerCommandEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(ProxyPlayerCommandEntityData, realm),
            },
            FieldInfoData {
                name: "ActivatedOnCreate",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ProxyPlayerCommandEntityData, activated_on_create),
            },
        ],
    }),
    array_type: Some(PROXYPLAYERCOMMANDENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ProxyPlayerCommandEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PROXYPLAYERCOMMANDENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PROXYPLAYERCOMMANDENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ProxyPlayerCommandEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("ProxyPlayerCommandEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ProxyPlayerAimAtCommandEntityData {
    pub _glacier_base: ProxyPlayerCommandEntityData,
    pub target: super::core::Vec3,
    pub tolerance: super::core::Vec2,
    pub speed_multiplier: super::core::Vec2,
    pub aim_axes: i32,
}

pub trait ProxyPlayerAimAtCommandEntityDataTrait: ProxyPlayerCommandEntityDataTrait {
    fn target(&self) -> &super::core::Vec3;
    fn tolerance(&self) -> &super::core::Vec2;
    fn speed_multiplier(&self) -> &super::core::Vec2;
    fn aim_axes(&self) -> &i32;
}

impl ProxyPlayerAimAtCommandEntityDataTrait for ProxyPlayerAimAtCommandEntityData {
    fn target(&self) -> &super::core::Vec3 {
        &self.target
    }
    fn tolerance(&self) -> &super::core::Vec2 {
        &self.tolerance
    }
    fn speed_multiplier(&self) -> &super::core::Vec2 {
        &self.speed_multiplier
    }
    fn aim_axes(&self) -> &i32 {
        &self.aim_axes
    }
}

impl ProxyPlayerCommandEntityDataTrait for ProxyPlayerAimAtCommandEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn activated_on_create(&self) -> &bool {
        self._glacier_base.activated_on_create()
    }
}

impl super::entity::EntityDataTrait for ProxyPlayerAimAtCommandEntityData {
}

impl super::entity::GameObjectDataTrait for ProxyPlayerAimAtCommandEntityData {
}

impl super::core::DataBusPeerTrait for ProxyPlayerAimAtCommandEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for ProxyPlayerAimAtCommandEntityData {
}

impl super::core::DataContainerTrait for ProxyPlayerAimAtCommandEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PROXYPLAYERAIMATCOMMANDENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ProxyPlayerAimAtCommandEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PROXYPLAYERCOMMANDENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ProxyPlayerAimAtCommandEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Target",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(ProxyPlayerAimAtCommandEntityData, target),
            },
            FieldInfoData {
                name: "Tolerance",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(ProxyPlayerAimAtCommandEntityData, tolerance),
            },
            FieldInfoData {
                name: "SpeedMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(ProxyPlayerAimAtCommandEntityData, speed_multiplier),
            },
            FieldInfoData {
                name: "AimAxes",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ProxyPlayerAimAtCommandEntityData, aim_axes),
            },
        ],
    }),
    array_type: Some(PROXYPLAYERAIMATCOMMANDENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ProxyPlayerAimAtCommandEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PROXYPLAYERAIMATCOMMANDENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PROXYPLAYERAIMATCOMMANDENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ProxyPlayerAimAtCommandEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("ProxyPlayerAimAtCommandEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WeaponModifierStateEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub modifier: Option<Arc<Mutex<dyn super::weapon_shared::WeaponModifierBaseTrait>>>,
}

pub trait WeaponModifierStateEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn modifier(&self) -> &Option<Arc<Mutex<dyn super::weapon_shared::WeaponModifierBaseTrait>>>;
}

impl WeaponModifierStateEntityDataTrait for WeaponModifierStateEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn modifier(&self) -> &Option<Arc<Mutex<dyn super::weapon_shared::WeaponModifierBaseTrait>>> {
        &self.modifier
    }
}

impl super::entity::EntityDataTrait for WeaponModifierStateEntityData {
}

impl super::entity::GameObjectDataTrait for WeaponModifierStateEntityData {
}

impl super::core::DataBusPeerTrait for WeaponModifierStateEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for WeaponModifierStateEntityData {
}

impl super::core::DataContainerTrait for WeaponModifierStateEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static WEAPONMODIFIERSTATEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponModifierStateEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WeaponModifierStateEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(WeaponModifierStateEntityData, realm),
            },
            FieldInfoData {
                name: "Modifier",
                flags: MemberInfoFlags::new(0),
                field_type: "WeaponModifierBase",
                rust_offset: offset_of!(WeaponModifierStateEntityData, modifier),
            },
        ],
    }),
    array_type: Some(WEAPONMODIFIERSTATEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WeaponModifierStateEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        WEAPONMODIFIERSTATEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static WEAPONMODIFIERSTATEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponModifierStateEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("WeaponModifierStateEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VaultModifierVolumeEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub enabled: bool,
    pub modifier_type: VaultModifierType,
    pub start_offset: f32,
    pub end_offset: f32,
    pub max_approach_angle: f32,
    pub dimensions: super::core::Vec3,
    pub vault_modifier_box_datas: Vec<VaultModifierBox>,
}

pub trait VaultModifierVolumeEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn enabled(&self) -> &bool;
    fn modifier_type(&self) -> &VaultModifierType;
    fn start_offset(&self) -> &f32;
    fn end_offset(&self) -> &f32;
    fn max_approach_angle(&self) -> &f32;
    fn dimensions(&self) -> &super::core::Vec3;
    fn vault_modifier_box_datas(&self) -> &Vec<VaultModifierBox>;
}

impl VaultModifierVolumeEntityDataTrait for VaultModifierVolumeEntityData {
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn modifier_type(&self) -> &VaultModifierType {
        &self.modifier_type
    }
    fn start_offset(&self) -> &f32 {
        &self.start_offset
    }
    fn end_offset(&self) -> &f32 {
        &self.end_offset
    }
    fn max_approach_angle(&self) -> &f32 {
        &self.max_approach_angle
    }
    fn dimensions(&self) -> &super::core::Vec3 {
        &self.dimensions
    }
    fn vault_modifier_box_datas(&self) -> &Vec<VaultModifierBox> {
        &self.vault_modifier_box_datas
    }
}

impl super::entity::SpatialEntityDataTrait for VaultModifierVolumeEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
}

impl super::entity::EntityDataTrait for VaultModifierVolumeEntityData {
}

impl super::entity::GameObjectDataTrait for VaultModifierVolumeEntityData {
}

impl super::core::DataBusPeerTrait for VaultModifierVolumeEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for VaultModifierVolumeEntityData {
}

impl super::core::DataContainerTrait for VaultModifierVolumeEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static VAULTMODIFIERVOLUMEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VaultModifierVolumeEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VaultModifierVolumeEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VaultModifierVolumeEntityData, enabled),
            },
            FieldInfoData {
                name: "ModifierType",
                flags: MemberInfoFlags::new(0),
                field_type: "VaultModifierType",
                rust_offset: offset_of!(VaultModifierVolumeEntityData, modifier_type),
            },
            FieldInfoData {
                name: "StartOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VaultModifierVolumeEntityData, start_offset),
            },
            FieldInfoData {
                name: "EndOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VaultModifierVolumeEntityData, end_offset),
            },
            FieldInfoData {
                name: "MaxApproachAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VaultModifierVolumeEntityData, max_approach_angle),
            },
            FieldInfoData {
                name: "Dimensions",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(VaultModifierVolumeEntityData, dimensions),
            },
            FieldInfoData {
                name: "VaultModifierBoxDatas",
                flags: MemberInfoFlags::new(144),
                field_type: "VaultModifierBox-Array",
                rust_offset: offset_of!(VaultModifierVolumeEntityData, vault_modifier_box_datas),
            },
        ],
    }),
    array_type: Some(VAULTMODIFIERVOLUMEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VaultModifierVolumeEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VAULTMODIFIERVOLUMEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VAULTMODIFIERVOLUMEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VaultModifierVolumeEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("VaultModifierVolumeEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum VaultModifierType {
    #[default]
    VaultDisable = 0,
    VaultWindow = 1,
}

pub static VAULTMODIFIERTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VaultModifierType",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(VAULTMODIFIERTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for VaultModifierType {
    fn type_info(&self) -> &'static TypeInfo {
        VAULTMODIFIERTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VAULTMODIFIERTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VaultModifierType-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("VaultModifierType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VaultModifierBox {
    pub transform: super::core::LinearTransform,
    pub half_extents: super::core::Vec3,
}

pub trait VaultModifierBoxTrait: TypeObject {
    fn transform(&self) -> &super::core::LinearTransform;
    fn half_extents(&self) -> &super::core::Vec3;
}

impl VaultModifierBoxTrait for VaultModifierBox {
    fn transform(&self) -> &super::core::LinearTransform {
        &self.transform
    }
    fn half_extents(&self) -> &super::core::Vec3 {
        &self.half_extents
    }
}

pub static VAULTMODIFIERBOX_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VaultModifierBox",
    flags: MemberInfoFlags::new(36937),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VaultModifierBox as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Transform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(VaultModifierBox, transform),
            },
            FieldInfoData {
                name: "HalfExtents",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(VaultModifierBox, half_extents),
            },
        ],
    }),
    array_type: Some(VAULTMODIFIERBOX_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VaultModifierBox {
    fn type_info(&self) -> &'static TypeInfo {
        VAULTMODIFIERBOX_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VAULTMODIFIERBOX_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VaultModifierBox-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("VaultModifierBox"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TriggerExplosiveEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub position: super::core::Vec3,
    pub transform: super::core::LinearTransform,
    pub damage_giver: QueryEntityResult,
    pub damage_multiplier: f32,
    pub inner_blast_radius_multiplier: f32,
    pub blast_radius_multiplier: f32,
    pub shockwave_radius_multiplier: f32,
    pub explosion_data: Option<Arc<Mutex<dyn super::game_shared::ExplosionEntityDataTrait>>>,
    pub unlock: Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>>,
}

pub trait TriggerExplosiveEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn position(&self) -> &super::core::Vec3;
    fn transform(&self) -> &super::core::LinearTransform;
    fn damage_giver(&self) -> &QueryEntityResult;
    fn damage_multiplier(&self) -> &f32;
    fn inner_blast_radius_multiplier(&self) -> &f32;
    fn blast_radius_multiplier(&self) -> &f32;
    fn shockwave_radius_multiplier(&self) -> &f32;
    fn explosion_data(&self) -> &Option<Arc<Mutex<dyn super::game_shared::ExplosionEntityDataTrait>>>;
    fn unlock(&self) -> &Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>>;
}

impl TriggerExplosiveEntityDataTrait for TriggerExplosiveEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn position(&self) -> &super::core::Vec3 {
        &self.position
    }
    fn transform(&self) -> &super::core::LinearTransform {
        &self.transform
    }
    fn damage_giver(&self) -> &QueryEntityResult {
        &self.damage_giver
    }
    fn damage_multiplier(&self) -> &f32 {
        &self.damage_multiplier
    }
    fn inner_blast_radius_multiplier(&self) -> &f32 {
        &self.inner_blast_radius_multiplier
    }
    fn blast_radius_multiplier(&self) -> &f32 {
        &self.blast_radius_multiplier
    }
    fn shockwave_radius_multiplier(&self) -> &f32 {
        &self.shockwave_radius_multiplier
    }
    fn explosion_data(&self) -> &Option<Arc<Mutex<dyn super::game_shared::ExplosionEntityDataTrait>>> {
        &self.explosion_data
    }
    fn unlock(&self) -> &Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>> {
        &self.unlock
    }
}

impl super::entity::EntityDataTrait for TriggerExplosiveEntityData {
}

impl super::entity::GameObjectDataTrait for TriggerExplosiveEntityData {
}

impl super::core::DataBusPeerTrait for TriggerExplosiveEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for TriggerExplosiveEntityData {
}

impl super::core::DataContainerTrait for TriggerExplosiveEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static TRIGGEREXPLOSIVEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TriggerExplosiveEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TriggerExplosiveEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(TriggerExplosiveEntityData, realm),
            },
            FieldInfoData {
                name: "Position",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(TriggerExplosiveEntityData, position),
            },
            FieldInfoData {
                name: "Transform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(TriggerExplosiveEntityData, transform),
            },
            FieldInfoData {
                name: "DamageGiver",
                flags: MemberInfoFlags::new(0),
                field_type: "QueryEntityResult",
                rust_offset: offset_of!(TriggerExplosiveEntityData, damage_giver),
            },
            FieldInfoData {
                name: "DamageMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TriggerExplosiveEntityData, damage_multiplier),
            },
            FieldInfoData {
                name: "InnerBlastRadiusMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TriggerExplosiveEntityData, inner_blast_radius_multiplier),
            },
            FieldInfoData {
                name: "BlastRadiusMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TriggerExplosiveEntityData, blast_radius_multiplier),
            },
            FieldInfoData {
                name: "ShockwaveRadiusMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TriggerExplosiveEntityData, shockwave_radius_multiplier),
            },
            FieldInfoData {
                name: "ExplosionData",
                flags: MemberInfoFlags::new(0),
                field_type: "ExplosionEntityData",
                rust_offset: offset_of!(TriggerExplosiveEntityData, explosion_data),
            },
            FieldInfoData {
                name: "Unlock",
                flags: MemberInfoFlags::new(0),
                field_type: "UnlockAssetBase",
                rust_offset: offset_of!(TriggerExplosiveEntityData, unlock),
            },
        ],
    }),
    array_type: Some(TRIGGEREXPLOSIVEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for TriggerExplosiveEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TRIGGEREXPLOSIVEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static TRIGGEREXPLOSIVEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TriggerExplosiveEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("TriggerExplosiveEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum TriggerExplosiveEntityConstants {
    #[default]
    MaxReplicatedDetonations = 3,
}

pub static TRIGGEREXPLOSIVEENTITYCONSTANTS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TriggerExplosiveEntityConstants",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(TRIGGEREXPLOSIVEENTITYCONSTANTS_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for TriggerExplosiveEntityConstants {
    fn type_info(&self) -> &'static TypeInfo {
        TRIGGEREXPLOSIVEENTITYCONSTANTS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static TRIGGEREXPLOSIVEENTITYCONSTANTS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TriggerExplosiveEntityConstants-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("TriggerExplosiveEntityConstants"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct InputToNetworkedBoolEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub input_action: i32,
}

pub trait InputToNetworkedBoolEntityDataTrait: super::entity::EntityDataTrait {
    fn input_action(&self) -> &i32;
}

impl InputToNetworkedBoolEntityDataTrait for InputToNetworkedBoolEntityData {
    fn input_action(&self) -> &i32 {
        &self.input_action
    }
}

impl super::entity::EntityDataTrait for InputToNetworkedBoolEntityData {
}

impl super::entity::GameObjectDataTrait for InputToNetworkedBoolEntityData {
}

impl super::core::DataBusPeerTrait for InputToNetworkedBoolEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for InputToNetworkedBoolEntityData {
}

impl super::core::DataContainerTrait for InputToNetworkedBoolEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static INPUTTONETWORKEDBOOLENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InputToNetworkedBoolEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<InputToNetworkedBoolEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "InputAction",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(InputToNetworkedBoolEntityData, input_action),
            },
        ],
    }),
    array_type: Some(INPUTTONETWORKEDBOOLENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for InputToNetworkedBoolEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        INPUTTONETWORKEDBOOLENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static INPUTTONETWORKEDBOOLENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InputToNetworkedBoolEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("InputToNetworkedBoolEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GravityWellSyncStruct {
    pub synced_tick_for_state: u32,
    pub last_state_change_sym_tick: u32,
    pub current_state: GravityWellTickSyncState,
    pub radius_at_last_event: f32,
}

pub trait GravityWellSyncStructTrait: TypeObject {
    fn synced_tick_for_state(&self) -> &u32;
    fn last_state_change_sym_tick(&self) -> &u32;
    fn current_state(&self) -> &GravityWellTickSyncState;
    fn radius_at_last_event(&self) -> &f32;
}

impl GravityWellSyncStructTrait for GravityWellSyncStruct {
    fn synced_tick_for_state(&self) -> &u32 {
        &self.synced_tick_for_state
    }
    fn last_state_change_sym_tick(&self) -> &u32 {
        &self.last_state_change_sym_tick
    }
    fn current_state(&self) -> &GravityWellTickSyncState {
        &self.current_state
    }
    fn radius_at_last_event(&self) -> &f32 {
        &self.radius_at_last_event
    }
}

pub static GRAVITYWELLSYNCSTRUCT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GravityWellSyncStruct",
    flags: MemberInfoFlags::new(36937),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GravityWellSyncStruct as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SyncedTickForState",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(GravityWellSyncStruct, synced_tick_for_state),
            },
            FieldInfoData {
                name: "LastStateChangeSymTick",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(GravityWellSyncStruct, last_state_change_sym_tick),
            },
            FieldInfoData {
                name: "CurrentState",
                flags: MemberInfoFlags::new(0),
                field_type: "GravityWellTickSyncState",
                rust_offset: offset_of!(GravityWellSyncStruct, current_state),
            },
            FieldInfoData {
                name: "RadiusAtLastEvent",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GravityWellSyncStruct, radius_at_last_event),
            },
        ],
    }),
    array_type: Some(GRAVITYWELLSYNCSTRUCT_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for GravityWellSyncStruct {
    fn type_info(&self) -> &'static TypeInfo {
        GRAVITYWELLSYNCSTRUCT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static GRAVITYWELLSYNCSTRUCT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GravityWellSyncStruct-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("GravityWellSyncStruct"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum GravityWellTickSyncState {
    #[default]
    GravityWellTickSyncState_Inactive = 0,
    GravityWellTickSyncState_Active = 1,
    GravityWellTickSyncState_Destroyed = 2,
    GravityWellTickSyncState_Finalised = 3,
}

pub static GRAVITYWELLTICKSYNCSTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GravityWellTickSyncState",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(GRAVITYWELLTICKSYNCSTATE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for GravityWellTickSyncState {
    fn type_info(&self) -> &'static TypeInfo {
        GRAVITYWELLTICKSYNCSTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static GRAVITYWELLTICKSYNCSTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GravityWellTickSyncState-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("GravityWellTickSyncState"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum GravityWellState {
    #[default]
    GravityWellState_Inactive = 0,
    GravityWellState_Dormant = 1,
    GravityWellState_Expanding = 2,
    GravityWellState_Expanded = 3,
    GravityWellState_Contracting = 4,
    GravityWellState_PrepareDestruction = 5,
    GravityWellState_BeingDestroyed = 6,
    GravityWellState_TerminateDestruction = 7,
    GravityWellState_Destroyed = 8,
}

pub static GRAVITYWELLSTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GravityWellState",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(GRAVITYWELLSTATE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for GravityWellState {
    fn type_info(&self) -> &'static TypeInfo {
        GRAVITYWELLSTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static GRAVITYWELLSTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GravityWellState-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("GravityWellState"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GravityWellControllerEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub well_transform0: super::core::LinearTransform,
    pub well_transform1: super::core::LinearTransform,
    pub well_transform2: super::core::LinearTransform,
    pub well_transform3: super::core::LinearTransform,
    pub well_transform4: super::core::LinearTransform,
    pub gravity_well: Vec<GravityWellConfigData>,
}

pub trait GravityWellControllerEntityDataTrait: super::entity::EntityDataTrait {
    fn well_transform0(&self) -> &super::core::LinearTransform;
    fn well_transform1(&self) -> &super::core::LinearTransform;
    fn well_transform2(&self) -> &super::core::LinearTransform;
    fn well_transform3(&self) -> &super::core::LinearTransform;
    fn well_transform4(&self) -> &super::core::LinearTransform;
    fn gravity_well(&self) -> &Vec<GravityWellConfigData>;
}

impl GravityWellControllerEntityDataTrait for GravityWellControllerEntityData {
    fn well_transform0(&self) -> &super::core::LinearTransform {
        &self.well_transform0
    }
    fn well_transform1(&self) -> &super::core::LinearTransform {
        &self.well_transform1
    }
    fn well_transform2(&self) -> &super::core::LinearTransform {
        &self.well_transform2
    }
    fn well_transform3(&self) -> &super::core::LinearTransform {
        &self.well_transform3
    }
    fn well_transform4(&self) -> &super::core::LinearTransform {
        &self.well_transform4
    }
    fn gravity_well(&self) -> &Vec<GravityWellConfigData> {
        &self.gravity_well
    }
}

impl super::entity::EntityDataTrait for GravityWellControllerEntityData {
}

impl super::entity::GameObjectDataTrait for GravityWellControllerEntityData {
}

impl super::core::DataBusPeerTrait for GravityWellControllerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for GravityWellControllerEntityData {
}

impl super::core::DataContainerTrait for GravityWellControllerEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static GRAVITYWELLCONTROLLERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GravityWellControllerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GravityWellControllerEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "WellTransform0",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(GravityWellControllerEntityData, well_transform0),
            },
            FieldInfoData {
                name: "WellTransform1",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(GravityWellControllerEntityData, well_transform1),
            },
            FieldInfoData {
                name: "WellTransform2",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(GravityWellControllerEntityData, well_transform2),
            },
            FieldInfoData {
                name: "WellTransform3",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(GravityWellControllerEntityData, well_transform3),
            },
            FieldInfoData {
                name: "WellTransform4",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(GravityWellControllerEntityData, well_transform4),
            },
            FieldInfoData {
                name: "GravityWell",
                flags: MemberInfoFlags::new(144),
                field_type: "GravityWellConfigData-Array",
                rust_offset: offset_of!(GravityWellControllerEntityData, gravity_well),
            },
        ],
    }),
    array_type: Some(GRAVITYWELLCONTROLLERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for GravityWellControllerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        GRAVITYWELLCONTROLLERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static GRAVITYWELLCONTROLLERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GravityWellControllerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("GravityWellControllerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GravityWellConfigData {
    pub max_radius: f32,
    pub dormant_time: f32,
    pub expanding_time: f32,
    pub expanded_time: f32,
    pub contracting_time: f32,
    pub prepare_destruction_time: f32,
    pub being_destroyed_loop_time: f32,
    pub terminate_destruction_time: f32,
    pub expansion_profile_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
    pub expanded_profile_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
    pub contraction_profile_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
    pub prepare_destruction_profile_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
    pub being_destroyed_loop_cycle_profile_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
    pub terminate_destruction_profile_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
    pub expansion_physics_push_force_size: f32,
    pub expansion_physics_push_force_direction_falloff: f32,
    pub pulse_physics_cadence_time: f32,
    pub pulse_physics_prepare_time: f32,
    pub pulse_physics_effect_time: f32,
    pub pulse_physics_push_force_size: f32,
    pub pulse_physics_push_force_direction_falloff: f32,
    pub contraction_physics_push_force_size: f32,
    pub contraction_physics_push_force_direction_falloff: f32,
    pub speed_ratio: f32,
}

pub trait GravityWellConfigDataTrait: TypeObject {
    fn max_radius(&self) -> &f32;
    fn dormant_time(&self) -> &f32;
    fn expanding_time(&self) -> &f32;
    fn expanded_time(&self) -> &f32;
    fn contracting_time(&self) -> &f32;
    fn prepare_destruction_time(&self) -> &f32;
    fn being_destroyed_loop_time(&self) -> &f32;
    fn terminate_destruction_time(&self) -> &f32;
    fn expansion_profile_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn expanded_profile_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn contraction_profile_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn prepare_destruction_profile_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn being_destroyed_loop_cycle_profile_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn terminate_destruction_profile_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn expansion_physics_push_force_size(&self) -> &f32;
    fn expansion_physics_push_force_direction_falloff(&self) -> &f32;
    fn pulse_physics_cadence_time(&self) -> &f32;
    fn pulse_physics_prepare_time(&self) -> &f32;
    fn pulse_physics_effect_time(&self) -> &f32;
    fn pulse_physics_push_force_size(&self) -> &f32;
    fn pulse_physics_push_force_direction_falloff(&self) -> &f32;
    fn contraction_physics_push_force_size(&self) -> &f32;
    fn contraction_physics_push_force_direction_falloff(&self) -> &f32;
    fn speed_ratio(&self) -> &f32;
}

impl GravityWellConfigDataTrait for GravityWellConfigData {
    fn max_radius(&self) -> &f32 {
        &self.max_radius
    }
    fn dormant_time(&self) -> &f32 {
        &self.dormant_time
    }
    fn expanding_time(&self) -> &f32 {
        &self.expanding_time
    }
    fn expanded_time(&self) -> &f32 {
        &self.expanded_time
    }
    fn contracting_time(&self) -> &f32 {
        &self.contracting_time
    }
    fn prepare_destruction_time(&self) -> &f32 {
        &self.prepare_destruction_time
    }
    fn being_destroyed_loop_time(&self) -> &f32 {
        &self.being_destroyed_loop_time
    }
    fn terminate_destruction_time(&self) -> &f32 {
        &self.terminate_destruction_time
    }
    fn expansion_profile_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.expansion_profile_curve
    }
    fn expanded_profile_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.expanded_profile_curve
    }
    fn contraction_profile_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.contraction_profile_curve
    }
    fn prepare_destruction_profile_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.prepare_destruction_profile_curve
    }
    fn being_destroyed_loop_cycle_profile_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.being_destroyed_loop_cycle_profile_curve
    }
    fn terminate_destruction_profile_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.terminate_destruction_profile_curve
    }
    fn expansion_physics_push_force_size(&self) -> &f32 {
        &self.expansion_physics_push_force_size
    }
    fn expansion_physics_push_force_direction_falloff(&self) -> &f32 {
        &self.expansion_physics_push_force_direction_falloff
    }
    fn pulse_physics_cadence_time(&self) -> &f32 {
        &self.pulse_physics_cadence_time
    }
    fn pulse_physics_prepare_time(&self) -> &f32 {
        &self.pulse_physics_prepare_time
    }
    fn pulse_physics_effect_time(&self) -> &f32 {
        &self.pulse_physics_effect_time
    }
    fn pulse_physics_push_force_size(&self) -> &f32 {
        &self.pulse_physics_push_force_size
    }
    fn pulse_physics_push_force_direction_falloff(&self) -> &f32 {
        &self.pulse_physics_push_force_direction_falloff
    }
    fn contraction_physics_push_force_size(&self) -> &f32 {
        &self.contraction_physics_push_force_size
    }
    fn contraction_physics_push_force_direction_falloff(&self) -> &f32 {
        &self.contraction_physics_push_force_direction_falloff
    }
    fn speed_ratio(&self) -> &f32 {
        &self.speed_ratio
    }
}

pub static GRAVITYWELLCONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GravityWellConfigData",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GravityWellConfigData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MaxRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GravityWellConfigData, max_radius),
            },
            FieldInfoData {
                name: "DormantTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GravityWellConfigData, dormant_time),
            },
            FieldInfoData {
                name: "ExpandingTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GravityWellConfigData, expanding_time),
            },
            FieldInfoData {
                name: "ExpandedTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GravityWellConfigData, expanded_time),
            },
            FieldInfoData {
                name: "ContractingTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GravityWellConfigData, contracting_time),
            },
            FieldInfoData {
                name: "PrepareDestructionTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GravityWellConfigData, prepare_destruction_time),
            },
            FieldInfoData {
                name: "BeingDestroyedLoopTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GravityWellConfigData, being_destroyed_loop_time),
            },
            FieldInfoData {
                name: "TerminateDestructionTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GravityWellConfigData, terminate_destruction_time),
            },
            FieldInfoData {
                name: "ExpansionProfileCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(GravityWellConfigData, expansion_profile_curve),
            },
            FieldInfoData {
                name: "ExpandedProfileCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(GravityWellConfigData, expanded_profile_curve),
            },
            FieldInfoData {
                name: "ContractionProfileCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(GravityWellConfigData, contraction_profile_curve),
            },
            FieldInfoData {
                name: "PrepareDestructionProfileCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(GravityWellConfigData, prepare_destruction_profile_curve),
            },
            FieldInfoData {
                name: "BeingDestroyedLoopCycleProfileCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(GravityWellConfigData, being_destroyed_loop_cycle_profile_curve),
            },
            FieldInfoData {
                name: "TerminateDestructionProfileCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(GravityWellConfigData, terminate_destruction_profile_curve),
            },
            FieldInfoData {
                name: "ExpansionPhysicsPushForceSize",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GravityWellConfigData, expansion_physics_push_force_size),
            },
            FieldInfoData {
                name: "ExpansionPhysicsPushForceDirectionFalloff",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GravityWellConfigData, expansion_physics_push_force_direction_falloff),
            },
            FieldInfoData {
                name: "PulsePhysicsCadenceTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GravityWellConfigData, pulse_physics_cadence_time),
            },
            FieldInfoData {
                name: "PulsePhysicsPrepareTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GravityWellConfigData, pulse_physics_prepare_time),
            },
            FieldInfoData {
                name: "PulsePhysicsEffectTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GravityWellConfigData, pulse_physics_effect_time),
            },
            FieldInfoData {
                name: "PulsePhysicsPushForceSize",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GravityWellConfigData, pulse_physics_push_force_size),
            },
            FieldInfoData {
                name: "PulsePhysicsPushForceDirectionFalloff",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GravityWellConfigData, pulse_physics_push_force_direction_falloff),
            },
            FieldInfoData {
                name: "ContractionPhysicsPushForceSize",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GravityWellConfigData, contraction_physics_push_force_size),
            },
            FieldInfoData {
                name: "ContractionPhysicsPushForceDirectionFalloff",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GravityWellConfigData, contraction_physics_push_force_direction_falloff),
            },
            FieldInfoData {
                name: "SpeedRatio",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GravityWellConfigData, speed_ratio),
            },
        ],
    }),
    array_type: Some(GRAVITYWELLCONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for GravityWellConfigData {
    fn type_info(&self) -> &'static TypeInfo {
        GRAVITYWELLCONFIGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static GRAVITYWELLCONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GravityWellConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("GravityWellConfigData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FrameInterpolatedTransformData {
    pub _glacier_base: super::entity::EntityData,
    pub r#in: super::core::LinearTransform,
}

pub trait FrameInterpolatedTransformDataTrait: super::entity::EntityDataTrait {
    fn r#in(&self) -> &super::core::LinearTransform;
}

impl FrameInterpolatedTransformDataTrait for FrameInterpolatedTransformData {
    fn r#in(&self) -> &super::core::LinearTransform {
        &self.r#in
    }
}

impl super::entity::EntityDataTrait for FrameInterpolatedTransformData {
}

impl super::entity::GameObjectDataTrait for FrameInterpolatedTransformData {
}

impl super::core::DataBusPeerTrait for FrameInterpolatedTransformData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for FrameInterpolatedTransformData {
}

impl super::core::DataContainerTrait for FrameInterpolatedTransformData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static FRAMEINTERPOLATEDTRANSFORMDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FrameInterpolatedTransformData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FrameInterpolatedTransformData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(FrameInterpolatedTransformData, r#in),
            },
        ],
    }),
    array_type: Some(FRAMEINTERPOLATEDTRANSFORMDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for FrameInterpolatedTransformData {
    fn type_info(&self) -> &'static TypeInfo {
        FRAMEINTERPOLATEDTRANSFORMDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static FRAMEINTERPOLATEDTRANSFORMDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FrameInterpolatedTransformData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("FrameInterpolatedTransformData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MaterialBasedEffectEntityData {
    pub _glacier_base: DiceVFXEntityBaseData,
    pub material: super::entity::MaterialDecl,
    pub snapping: WSSnapType,
    pub snapping_height_offset: f32,
    pub spawn_effect_on_lookup_location: bool,
    pub resampling_distance: f32,
    pub use_ray_cast: bool,
    pub ray_direction: super::core::Vec3,
    pub ray_distance: f32,
    pub see_through: bool,
    pub penetrable: bool,
    pub include_terrain: bool,
    pub normal_alignment: WSNormalAlignment,
    pub inherit_effect: bool,
    pub linked_offset: super::core::LinearTransform,
    pub raycast_result: RaycastEntityResult,
}

pub trait MaterialBasedEffectEntityDataTrait: DiceVFXEntityBaseDataTrait {
    fn material(&self) -> &super::entity::MaterialDecl;
    fn snapping(&self) -> &WSSnapType;
    fn snapping_height_offset(&self) -> &f32;
    fn spawn_effect_on_lookup_location(&self) -> &bool;
    fn resampling_distance(&self) -> &f32;
    fn use_ray_cast(&self) -> &bool;
    fn ray_direction(&self) -> &super::core::Vec3;
    fn ray_distance(&self) -> &f32;
    fn see_through(&self) -> &bool;
    fn penetrable(&self) -> &bool;
    fn include_terrain(&self) -> &bool;
    fn normal_alignment(&self) -> &WSNormalAlignment;
    fn inherit_effect(&self) -> &bool;
    fn linked_offset(&self) -> &super::core::LinearTransform;
    fn raycast_result(&self) -> &RaycastEntityResult;
}

impl MaterialBasedEffectEntityDataTrait for MaterialBasedEffectEntityData {
    fn material(&self) -> &super::entity::MaterialDecl {
        &self.material
    }
    fn snapping(&self) -> &WSSnapType {
        &self.snapping
    }
    fn snapping_height_offset(&self) -> &f32 {
        &self.snapping_height_offset
    }
    fn spawn_effect_on_lookup_location(&self) -> &bool {
        &self.spawn_effect_on_lookup_location
    }
    fn resampling_distance(&self) -> &f32 {
        &self.resampling_distance
    }
    fn use_ray_cast(&self) -> &bool {
        &self.use_ray_cast
    }
    fn ray_direction(&self) -> &super::core::Vec3 {
        &self.ray_direction
    }
    fn ray_distance(&self) -> &f32 {
        &self.ray_distance
    }
    fn see_through(&self) -> &bool {
        &self.see_through
    }
    fn penetrable(&self) -> &bool {
        &self.penetrable
    }
    fn include_terrain(&self) -> &bool {
        &self.include_terrain
    }
    fn normal_alignment(&self) -> &WSNormalAlignment {
        &self.normal_alignment
    }
    fn inherit_effect(&self) -> &bool {
        &self.inherit_effect
    }
    fn linked_offset(&self) -> &super::core::LinearTransform {
        &self.linked_offset
    }
    fn raycast_result(&self) -> &RaycastEntityResult {
        &self.raycast_result
    }
}

impl DiceVFXEntityBaseDataTrait for MaterialBasedEffectEntityData {
    fn raw_transform_effect_location(&self) -> &super::core::LinearTransform {
        self._glacier_base.raw_transform_effect_location()
    }
    fn stay_attached(&self) -> &bool {
        self._glacier_base.stay_attached()
    }
    fn attach(&self) -> &Option<Arc<Mutex<dyn super::dice_commons_shared::EntityAttachDataTrait>>> {
        self._glacier_base.attach()
    }
    fn effect_parameters(&self) -> &Vec<Option<Arc<Mutex<dyn super::effect_base::EffectParameterTrait>>>> {
        self._glacier_base.effect_parameters()
    }
    fn max_instances(&self) -> &i32 {
        self._glacier_base.max_instances()
    }
}

impl super::entity::EntityDataTrait for MaterialBasedEffectEntityData {
}

impl super::entity::GameObjectDataTrait for MaterialBasedEffectEntityData {
}

impl super::core::DataBusPeerTrait for MaterialBasedEffectEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for MaterialBasedEffectEntityData {
}

impl super::core::DataContainerTrait for MaterialBasedEffectEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static MATERIALBASEDEFFECTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MaterialBasedEffectEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DICEVFXENTITYBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MaterialBasedEffectEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Material",
                flags: MemberInfoFlags::new(0),
                field_type: "MaterialDecl",
                rust_offset: offset_of!(MaterialBasedEffectEntityData, material),
            },
            FieldInfoData {
                name: "Snapping",
                flags: MemberInfoFlags::new(0),
                field_type: "WSSnapType",
                rust_offset: offset_of!(MaterialBasedEffectEntityData, snapping),
            },
            FieldInfoData {
                name: "SnappingHeightOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MaterialBasedEffectEntityData, snapping_height_offset),
            },
            FieldInfoData {
                name: "SpawnEffectOnLookupLocation",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MaterialBasedEffectEntityData, spawn_effect_on_lookup_location),
            },
            FieldInfoData {
                name: "ResamplingDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MaterialBasedEffectEntityData, resampling_distance),
            },
            FieldInfoData {
                name: "UseRayCast",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MaterialBasedEffectEntityData, use_ray_cast),
            },
            FieldInfoData {
                name: "RayDirection",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(MaterialBasedEffectEntityData, ray_direction),
            },
            FieldInfoData {
                name: "RayDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MaterialBasedEffectEntityData, ray_distance),
            },
            FieldInfoData {
                name: "SeeThrough",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MaterialBasedEffectEntityData, see_through),
            },
            FieldInfoData {
                name: "Penetrable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MaterialBasedEffectEntityData, penetrable),
            },
            FieldInfoData {
                name: "IncludeTerrain",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MaterialBasedEffectEntityData, include_terrain),
            },
            FieldInfoData {
                name: "NormalAlignment",
                flags: MemberInfoFlags::new(0),
                field_type: "WSNormalAlignment",
                rust_offset: offset_of!(MaterialBasedEffectEntityData, normal_alignment),
            },
            FieldInfoData {
                name: "InheritEffect",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MaterialBasedEffectEntityData, inherit_effect),
            },
            FieldInfoData {
                name: "LinkedOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(MaterialBasedEffectEntityData, linked_offset),
            },
            FieldInfoData {
                name: "RaycastResult",
                flags: MemberInfoFlags::new(0),
                field_type: "RaycastEntityResult",
                rust_offset: offset_of!(MaterialBasedEffectEntityData, raycast_result),
            },
        ],
    }),
    array_type: Some(MATERIALBASEDEFFECTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for MaterialBasedEffectEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        MATERIALBASEDEFFECTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static MATERIALBASEDEFFECTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MaterialBasedEffectEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("MaterialBasedEffectEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum WSNormalAlignment {
    #[default]
    WSNormalAlignment_Unchanged = 0,
    WSNormalAlignment_FromTransform = 1,
    WSNormalAlignment_FromRay = 2,
}

pub static WSNORMALALIGNMENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WSNormalAlignment",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(WSNORMALALIGNMENT_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for WSNormalAlignment {
    fn type_info(&self) -> &'static TypeInfo {
        WSNORMALALIGNMENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static WSNORMALALIGNMENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WSNormalAlignment-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("WSNormalAlignment"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum WSSnapType {
    #[default]
    WSSnapType_NoSnap = 0,
    WSSnapType_SnapToTerrain = 1,
    WSSnapType_SnapToWater = 2,
    WSSnapType_SnapToClosest = 3,
}

pub static WSSNAPTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WSSnapType",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(WSSNAPTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for WSSnapType {
    fn type_info(&self) -> &'static TypeInfo {
        WSSNAPTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static WSSNAPTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WSSnapType-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("WSSnapType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DicePlayVFXEntityData {
    pub _glacier_base: DiceVFXEntityBaseData,
    pub effect: Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>>,
    pub is_full_screen: bool,
}

pub trait DicePlayVFXEntityDataTrait: DiceVFXEntityBaseDataTrait {
    fn effect(&self) -> &Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>>;
    fn is_full_screen(&self) -> &bool;
}

impl DicePlayVFXEntityDataTrait for DicePlayVFXEntityData {
    fn effect(&self) -> &Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>> {
        &self.effect
    }
    fn is_full_screen(&self) -> &bool {
        &self.is_full_screen
    }
}

impl DiceVFXEntityBaseDataTrait for DicePlayVFXEntityData {
    fn raw_transform_effect_location(&self) -> &super::core::LinearTransform {
        self._glacier_base.raw_transform_effect_location()
    }
    fn stay_attached(&self) -> &bool {
        self._glacier_base.stay_attached()
    }
    fn attach(&self) -> &Option<Arc<Mutex<dyn super::dice_commons_shared::EntityAttachDataTrait>>> {
        self._glacier_base.attach()
    }
    fn effect_parameters(&self) -> &Vec<Option<Arc<Mutex<dyn super::effect_base::EffectParameterTrait>>>> {
        self._glacier_base.effect_parameters()
    }
    fn max_instances(&self) -> &i32 {
        self._glacier_base.max_instances()
    }
}

impl super::entity::EntityDataTrait for DicePlayVFXEntityData {
}

impl super::entity::GameObjectDataTrait for DicePlayVFXEntityData {
}

impl super::core::DataBusPeerTrait for DicePlayVFXEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for DicePlayVFXEntityData {
}

impl super::core::DataContainerTrait for DicePlayVFXEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static DICEPLAYVFXENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DicePlayVFXEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DICEVFXENTITYBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DicePlayVFXEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Effect",
                flags: MemberInfoFlags::new(0),
                field_type: "EffectBlueprint",
                rust_offset: offset_of!(DicePlayVFXEntityData, effect),
            },
            FieldInfoData {
                name: "IsFullScreen",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DicePlayVFXEntityData, is_full_screen),
            },
        ],
    }),
    array_type: Some(DICEPLAYVFXENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for DicePlayVFXEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        DICEPLAYVFXENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static DICEPLAYVFXENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DicePlayVFXEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("DicePlayVFXEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DiceVFXEntityBaseData {
    pub _glacier_base: super::entity::EntityData,
    pub raw_transform_effect_location: super::core::LinearTransform,
    pub stay_attached: bool,
    pub attach: Option<Arc<Mutex<dyn super::dice_commons_shared::EntityAttachDataTrait>>>,
    pub effect_parameters: Vec<Option<Arc<Mutex<dyn super::effect_base::EffectParameterTrait>>>>,
    pub max_instances: i32,
}

pub trait DiceVFXEntityBaseDataTrait: super::entity::EntityDataTrait {
    fn raw_transform_effect_location(&self) -> &super::core::LinearTransform;
    fn stay_attached(&self) -> &bool;
    fn attach(&self) -> &Option<Arc<Mutex<dyn super::dice_commons_shared::EntityAttachDataTrait>>>;
    fn effect_parameters(&self) -> &Vec<Option<Arc<Mutex<dyn super::effect_base::EffectParameterTrait>>>>;
    fn max_instances(&self) -> &i32;
}

impl DiceVFXEntityBaseDataTrait for DiceVFXEntityBaseData {
    fn raw_transform_effect_location(&self) -> &super::core::LinearTransform {
        &self.raw_transform_effect_location
    }
    fn stay_attached(&self) -> &bool {
        &self.stay_attached
    }
    fn attach(&self) -> &Option<Arc<Mutex<dyn super::dice_commons_shared::EntityAttachDataTrait>>> {
        &self.attach
    }
    fn effect_parameters(&self) -> &Vec<Option<Arc<Mutex<dyn super::effect_base::EffectParameterTrait>>>> {
        &self.effect_parameters
    }
    fn max_instances(&self) -> &i32 {
        &self.max_instances
    }
}

impl super::entity::EntityDataTrait for DiceVFXEntityBaseData {
}

impl super::entity::GameObjectDataTrait for DiceVFXEntityBaseData {
}

impl super::core::DataBusPeerTrait for DiceVFXEntityBaseData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for DiceVFXEntityBaseData {
}

impl super::core::DataContainerTrait for DiceVFXEntityBaseData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static DICEVFXENTITYBASEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DiceVFXEntityBaseData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DiceVFXEntityBaseData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "RawTransformEffectLocation",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(DiceVFXEntityBaseData, raw_transform_effect_location),
            },
            FieldInfoData {
                name: "StayAttached",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DiceVFXEntityBaseData, stay_attached),
            },
            FieldInfoData {
                name: "Attach",
                flags: MemberInfoFlags::new(0),
                field_type: "EntityAttachData",
                rust_offset: offset_of!(DiceVFXEntityBaseData, attach),
            },
            FieldInfoData {
                name: "EffectParameters",
                flags: MemberInfoFlags::new(144),
                field_type: "EffectParameter-Array",
                rust_offset: offset_of!(DiceVFXEntityBaseData, effect_parameters),
            },
            FieldInfoData {
                name: "MaxInstances",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(DiceVFXEntityBaseData, max_instances),
            },
        ],
    }),
    array_type: Some(DICEVFXENTITYBASEDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for DiceVFXEntityBaseData {
    fn type_info(&self) -> &'static TypeInfo {
        DICEVFXENTITYBASEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static DICEVFXENTITYBASEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DiceVFXEntityBaseData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("DiceVFXEntityBaseData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DiceShooterDeathExperienceEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub activation_delay: f32,
    pub sphere_radius: f32,
    pub collision_offset_y: f32,
    pub victim_bone: super::entity::GameplayBones,
    pub victim_offset: super::core::Vec3,
    pub victim_offset_no_killer: super::core::Vec3,
    pub victim_offset_vehicle: super::core::Vec3,
    pub vehicle_radius_for_offset_scaling: f32,
    pub killer_look_at_offset_y: f32,
    pub killer_tracking_smoothness: f32,
    pub offset_blend_factor: f32,
    pub viewport_height_for_soldier: f32,
    pub viewport_height_scale_for_vehicle: f32,
    pub absolute_min_f_o_v: f32,
    pub viewport_height_blend_factor: f32,
    pub max_end_fov_to_zoom: f32,
    pub time_to_stop_camera_on_revive: f32,
    pub fov_blend_factor: f32,
    pub rotation_blend_factor: f32,
    pub camera_speed_scale: f32,
    pub update_rate: i32,
}

pub trait DiceShooterDeathExperienceEntityDataTrait: super::entity::EntityDataTrait {
    fn activation_delay(&self) -> &f32;
    fn sphere_radius(&self) -> &f32;
    fn collision_offset_y(&self) -> &f32;
    fn victim_bone(&self) -> &super::entity::GameplayBones;
    fn victim_offset(&self) -> &super::core::Vec3;
    fn victim_offset_no_killer(&self) -> &super::core::Vec3;
    fn victim_offset_vehicle(&self) -> &super::core::Vec3;
    fn vehicle_radius_for_offset_scaling(&self) -> &f32;
    fn killer_look_at_offset_y(&self) -> &f32;
    fn killer_tracking_smoothness(&self) -> &f32;
    fn offset_blend_factor(&self) -> &f32;
    fn viewport_height_for_soldier(&self) -> &f32;
    fn viewport_height_scale_for_vehicle(&self) -> &f32;
    fn absolute_min_f_o_v(&self) -> &f32;
    fn viewport_height_blend_factor(&self) -> &f32;
    fn max_end_fov_to_zoom(&self) -> &f32;
    fn time_to_stop_camera_on_revive(&self) -> &f32;
    fn fov_blend_factor(&self) -> &f32;
    fn rotation_blend_factor(&self) -> &f32;
    fn camera_speed_scale(&self) -> &f32;
    fn update_rate(&self) -> &i32;
}

impl DiceShooterDeathExperienceEntityDataTrait for DiceShooterDeathExperienceEntityData {
    fn activation_delay(&self) -> &f32 {
        &self.activation_delay
    }
    fn sphere_radius(&self) -> &f32 {
        &self.sphere_radius
    }
    fn collision_offset_y(&self) -> &f32 {
        &self.collision_offset_y
    }
    fn victim_bone(&self) -> &super::entity::GameplayBones {
        &self.victim_bone
    }
    fn victim_offset(&self) -> &super::core::Vec3 {
        &self.victim_offset
    }
    fn victim_offset_no_killer(&self) -> &super::core::Vec3 {
        &self.victim_offset_no_killer
    }
    fn victim_offset_vehicle(&self) -> &super::core::Vec3 {
        &self.victim_offset_vehicle
    }
    fn vehicle_radius_for_offset_scaling(&self) -> &f32 {
        &self.vehicle_radius_for_offset_scaling
    }
    fn killer_look_at_offset_y(&self) -> &f32 {
        &self.killer_look_at_offset_y
    }
    fn killer_tracking_smoothness(&self) -> &f32 {
        &self.killer_tracking_smoothness
    }
    fn offset_blend_factor(&self) -> &f32 {
        &self.offset_blend_factor
    }
    fn viewport_height_for_soldier(&self) -> &f32 {
        &self.viewport_height_for_soldier
    }
    fn viewport_height_scale_for_vehicle(&self) -> &f32 {
        &self.viewport_height_scale_for_vehicle
    }
    fn absolute_min_f_o_v(&self) -> &f32 {
        &self.absolute_min_f_o_v
    }
    fn viewport_height_blend_factor(&self) -> &f32 {
        &self.viewport_height_blend_factor
    }
    fn max_end_fov_to_zoom(&self) -> &f32 {
        &self.max_end_fov_to_zoom
    }
    fn time_to_stop_camera_on_revive(&self) -> &f32 {
        &self.time_to_stop_camera_on_revive
    }
    fn fov_blend_factor(&self) -> &f32 {
        &self.fov_blend_factor
    }
    fn rotation_blend_factor(&self) -> &f32 {
        &self.rotation_blend_factor
    }
    fn camera_speed_scale(&self) -> &f32 {
        &self.camera_speed_scale
    }
    fn update_rate(&self) -> &i32 {
        &self.update_rate
    }
}

impl super::entity::EntityDataTrait for DiceShooterDeathExperienceEntityData {
}

impl super::entity::GameObjectDataTrait for DiceShooterDeathExperienceEntityData {
}

impl super::core::DataBusPeerTrait for DiceShooterDeathExperienceEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for DiceShooterDeathExperienceEntityData {
}

impl super::core::DataContainerTrait for DiceShooterDeathExperienceEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static DICESHOOTERDEATHEXPERIENCEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DiceShooterDeathExperienceEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DiceShooterDeathExperienceEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ActivationDelay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DiceShooterDeathExperienceEntityData, activation_delay),
            },
            FieldInfoData {
                name: "SphereRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DiceShooterDeathExperienceEntityData, sphere_radius),
            },
            FieldInfoData {
                name: "CollisionOffsetY",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DiceShooterDeathExperienceEntityData, collision_offset_y),
            },
            FieldInfoData {
                name: "VictimBone",
                flags: MemberInfoFlags::new(0),
                field_type: "GameplayBones",
                rust_offset: offset_of!(DiceShooterDeathExperienceEntityData, victim_bone),
            },
            FieldInfoData {
                name: "VictimOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(DiceShooterDeathExperienceEntityData, victim_offset),
            },
            FieldInfoData {
                name: "VictimOffsetNoKiller",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(DiceShooterDeathExperienceEntityData, victim_offset_no_killer),
            },
            FieldInfoData {
                name: "VictimOffsetVehicle",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(DiceShooterDeathExperienceEntityData, victim_offset_vehicle),
            },
            FieldInfoData {
                name: "VehicleRadiusForOffsetScaling",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DiceShooterDeathExperienceEntityData, vehicle_radius_for_offset_scaling),
            },
            FieldInfoData {
                name: "KillerLookAtOffsetY",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DiceShooterDeathExperienceEntityData, killer_look_at_offset_y),
            },
            FieldInfoData {
                name: "KillerTrackingSmoothness",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DiceShooterDeathExperienceEntityData, killer_tracking_smoothness),
            },
            FieldInfoData {
                name: "OffsetBlendFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DiceShooterDeathExperienceEntityData, offset_blend_factor),
            },
            FieldInfoData {
                name: "ViewportHeightForSoldier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DiceShooterDeathExperienceEntityData, viewport_height_for_soldier),
            },
            FieldInfoData {
                name: "ViewportHeightScaleForVehicle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DiceShooterDeathExperienceEntityData, viewport_height_scale_for_vehicle),
            },
            FieldInfoData {
                name: "AbsoluteMinFOV",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DiceShooterDeathExperienceEntityData, absolute_min_f_o_v),
            },
            FieldInfoData {
                name: "ViewportHeightBlendFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DiceShooterDeathExperienceEntityData, viewport_height_blend_factor),
            },
            FieldInfoData {
                name: "MaxEndFovToZoom",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DiceShooterDeathExperienceEntityData, max_end_fov_to_zoom),
            },
            FieldInfoData {
                name: "TimeToStopCameraOnRevive",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DiceShooterDeathExperienceEntityData, time_to_stop_camera_on_revive),
            },
            FieldInfoData {
                name: "FovBlendFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DiceShooterDeathExperienceEntityData, fov_blend_factor),
            },
            FieldInfoData {
                name: "RotationBlendFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DiceShooterDeathExperienceEntityData, rotation_blend_factor),
            },
            FieldInfoData {
                name: "CameraSpeedScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DiceShooterDeathExperienceEntityData, camera_speed_scale),
            },
            FieldInfoData {
                name: "UpdateRate",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(DiceShooterDeathExperienceEntityData, update_rate),
            },
        ],
    }),
    array_type: Some(DICESHOOTERDEATHEXPERIENCEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for DiceShooterDeathExperienceEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        DICESHOOTERDEATHEXPERIENCEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static DICESHOOTERDEATHEXPERIENCEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DiceShooterDeathExperienceEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("DiceShooterDeathExperienceEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum DeathExperienceSmoothing {
    #[default]
    DeathExperienceSmoothing_EaseInAndOut = 0,
    DeathExperienceSmoothing_EaseIn = 1,
    DeathExperienceSmoothing_EaseOut = 2,
    DeathExperienceSmoothing_Linear = 3,
    DeathExperienceSmoothing_Size = 4,
}

pub static DEATHEXPERIENCESMOOTHING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DeathExperienceSmoothing",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(DEATHEXPERIENCESMOOTHING_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for DeathExperienceSmoothing {
    fn type_info(&self) -> &'static TypeInfo {
        DEATHEXPERIENCESMOOTHING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static DEATHEXPERIENCESMOOTHING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DeathExperienceSmoothing-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("DeathExperienceSmoothing"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DebugPlayerSpawnerData {
    pub _glacier_base: super::entity::EntityData,
    pub player_name: String,
    pub throttle: f32,
    pub yaw: f32,
}

pub trait DebugPlayerSpawnerDataTrait: super::entity::EntityDataTrait {
    fn player_name(&self) -> &String;
    fn throttle(&self) -> &f32;
    fn yaw(&self) -> &f32;
}

impl DebugPlayerSpawnerDataTrait for DebugPlayerSpawnerData {
    fn player_name(&self) -> &String {
        &self.player_name
    }
    fn throttle(&self) -> &f32 {
        &self.throttle
    }
    fn yaw(&self) -> &f32 {
        &self.yaw
    }
}

impl super::entity::EntityDataTrait for DebugPlayerSpawnerData {
}

impl super::entity::GameObjectDataTrait for DebugPlayerSpawnerData {
}

impl super::core::DataBusPeerTrait for DebugPlayerSpawnerData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for DebugPlayerSpawnerData {
}

impl super::core::DataContainerTrait for DebugPlayerSpawnerData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static DEBUGPLAYERSPAWNERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DebugPlayerSpawnerData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DebugPlayerSpawnerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PlayerName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(DebugPlayerSpawnerData, player_name),
            },
            FieldInfoData {
                name: "Throttle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DebugPlayerSpawnerData, throttle),
            },
            FieldInfoData {
                name: "Yaw",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DebugPlayerSpawnerData, yaw),
            },
        ],
    }),
    array_type: Some(DEBUGPLAYERSPAWNERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DebugPlayerSpawnerData {
    fn type_info(&self) -> &'static TypeInfo {
        DEBUGPLAYERSPAWNERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static DEBUGPLAYERSPAWNERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DebugPlayerSpawnerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("DebugPlayerSpawnerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DamageGiverEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub team: super::gameplay_sim::TeamId,
    pub damage_giver_name: String,
    pub is_a_i_damage: bool,
}

pub trait DamageGiverEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn team(&self) -> &super::gameplay_sim::TeamId;
    fn damage_giver_name(&self) -> &String;
    fn is_a_i_damage(&self) -> &bool;
}

impl DamageGiverEntityDataTrait for DamageGiverEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn team(&self) -> &super::gameplay_sim::TeamId {
        &self.team
    }
    fn damage_giver_name(&self) -> &String {
        &self.damage_giver_name
    }
    fn is_a_i_damage(&self) -> &bool {
        &self.is_a_i_damage
    }
}

impl super::entity::EntityDataTrait for DamageGiverEntityData {
}

impl super::entity::GameObjectDataTrait for DamageGiverEntityData {
}

impl super::core::DataBusPeerTrait for DamageGiverEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for DamageGiverEntityData {
}

impl super::core::DataContainerTrait for DamageGiverEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static DAMAGEGIVERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DamageGiverEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DamageGiverEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(DamageGiverEntityData, realm),
            },
            FieldInfoData {
                name: "Team",
                flags: MemberInfoFlags::new(0),
                field_type: "TeamId",
                rust_offset: offset_of!(DamageGiverEntityData, team),
            },
            FieldInfoData {
                name: "DamageGiverName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(DamageGiverEntityData, damage_giver_name),
            },
            FieldInfoData {
                name: "IsAIDamage",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DamageGiverEntityData, is_a_i_damage),
            },
        ],
    }),
    array_type: Some(DAMAGEGIVERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DamageGiverEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        DAMAGEGIVERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static DAMAGEGIVERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DamageGiverEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("DamageGiverEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ControllableInputFilterEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub input_filters: Vec<Option<Arc<Mutex<dyn InputFilterBaseDataTrait>>>>,
    pub obstacle_angle: f32,
    pub check_blocked_by_obastacle_distance: f32,
}

pub trait ControllableInputFilterEntityDataTrait: super::entity::EntityDataTrait {
    fn input_filters(&self) -> &Vec<Option<Arc<Mutex<dyn InputFilterBaseDataTrait>>>>;
    fn obstacle_angle(&self) -> &f32;
    fn check_blocked_by_obastacle_distance(&self) -> &f32;
}

impl ControllableInputFilterEntityDataTrait for ControllableInputFilterEntityData {
    fn input_filters(&self) -> &Vec<Option<Arc<Mutex<dyn InputFilterBaseDataTrait>>>> {
        &self.input_filters
    }
    fn obstacle_angle(&self) -> &f32 {
        &self.obstacle_angle
    }
    fn check_blocked_by_obastacle_distance(&self) -> &f32 {
        &self.check_blocked_by_obastacle_distance
    }
}

impl super::entity::EntityDataTrait for ControllableInputFilterEntityData {
}

impl super::entity::GameObjectDataTrait for ControllableInputFilterEntityData {
}

impl super::core::DataBusPeerTrait for ControllableInputFilterEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for ControllableInputFilterEntityData {
}

impl super::core::DataContainerTrait for ControllableInputFilterEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CONTROLLABLEINPUTFILTERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ControllableInputFilterEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ControllableInputFilterEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "InputFilters",
                flags: MemberInfoFlags::new(144),
                field_type: "InputFilterBaseData-Array",
                rust_offset: offset_of!(ControllableInputFilterEntityData, input_filters),
            },
            FieldInfoData {
                name: "ObstacleAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ControllableInputFilterEntityData, obstacle_angle),
            },
            FieldInfoData {
                name: "CheckBlockedByObastacleDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ControllableInputFilterEntityData, check_blocked_by_obastacle_distance),
            },
        ],
    }),
    array_type: Some(CONTROLLABLEINPUTFILTERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ControllableInputFilterEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CONTROLLABLEINPUTFILTERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CONTROLLABLEINPUTFILTERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ControllableInputFilterEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("ControllableInputFilterEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ToggleSprintInputData {
    pub _glacier_base: InputFilterBaseData,
}

pub trait ToggleSprintInputDataTrait: InputFilterBaseDataTrait {
}

impl ToggleSprintInputDataTrait for ToggleSprintInputData {
}

impl InputFilterBaseDataTrait for ToggleSprintInputData {
}

impl super::core::DataContainerTrait for ToggleSprintInputData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static TOGGLESPRINTINPUTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ToggleSprintInputData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(INPUTFILTERBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ToggleSprintInputData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(TOGGLESPRINTINPUTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ToggleSprintInputData {
    fn type_info(&self) -> &'static TypeInfo {
        TOGGLESPRINTINPUTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static TOGGLESPRINTINPUTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ToggleSprintInputData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("ToggleSprintInputData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VerticalAvoidanceData {
    pub _glacier_base: AvoidanceBehaviourBaseData,
    pub test_for_hit: bool,
    pub test_on_reverse: bool,
    pub detection_distance: f32,
    pub detection_distance_reverse: f32,
    pub speed_scale: f32,
    pub height_offset: f32,
    pub lateral_offset: f32,
    pub length: f32,
    pub allow_breaking_speed_limit: f32,
    pub stopping_input_strength: f32,
    pub stopping_absolute_distance: f32,
    pub forward_direction_override_velocity_at_speed: f32,
    pub input_to_velocity_blend_params: Option<Arc<Mutex<dyn InputToVelocityBendParamsTrait>>>,
    pub follow_ground_slope_multiplier: f32,
    pub follow_ground_max_upwards_angle: f32,
    pub follow_ground_max_downwards_angle: f32,
}

pub trait VerticalAvoidanceDataTrait: AvoidanceBehaviourBaseDataTrait {
    fn test_for_hit(&self) -> &bool;
    fn test_on_reverse(&self) -> &bool;
    fn detection_distance(&self) -> &f32;
    fn detection_distance_reverse(&self) -> &f32;
    fn speed_scale(&self) -> &f32;
    fn height_offset(&self) -> &f32;
    fn lateral_offset(&self) -> &f32;
    fn length(&self) -> &f32;
    fn allow_breaking_speed_limit(&self) -> &f32;
    fn stopping_input_strength(&self) -> &f32;
    fn stopping_absolute_distance(&self) -> &f32;
    fn forward_direction_override_velocity_at_speed(&self) -> &f32;
    fn input_to_velocity_blend_params(&self) -> &Option<Arc<Mutex<dyn InputToVelocityBendParamsTrait>>>;
    fn follow_ground_slope_multiplier(&self) -> &f32;
    fn follow_ground_max_upwards_angle(&self) -> &f32;
    fn follow_ground_max_downwards_angle(&self) -> &f32;
}

impl VerticalAvoidanceDataTrait for VerticalAvoidanceData {
    fn test_for_hit(&self) -> &bool {
        &self.test_for_hit
    }
    fn test_on_reverse(&self) -> &bool {
        &self.test_on_reverse
    }
    fn detection_distance(&self) -> &f32 {
        &self.detection_distance
    }
    fn detection_distance_reverse(&self) -> &f32 {
        &self.detection_distance_reverse
    }
    fn speed_scale(&self) -> &f32 {
        &self.speed_scale
    }
    fn height_offset(&self) -> &f32 {
        &self.height_offset
    }
    fn lateral_offset(&self) -> &f32 {
        &self.lateral_offset
    }
    fn length(&self) -> &f32 {
        &self.length
    }
    fn allow_breaking_speed_limit(&self) -> &f32 {
        &self.allow_breaking_speed_limit
    }
    fn stopping_input_strength(&self) -> &f32 {
        &self.stopping_input_strength
    }
    fn stopping_absolute_distance(&self) -> &f32 {
        &self.stopping_absolute_distance
    }
    fn forward_direction_override_velocity_at_speed(&self) -> &f32 {
        &self.forward_direction_override_velocity_at_speed
    }
    fn input_to_velocity_blend_params(&self) -> &Option<Arc<Mutex<dyn InputToVelocityBendParamsTrait>>> {
        &self.input_to_velocity_blend_params
    }
    fn follow_ground_slope_multiplier(&self) -> &f32 {
        &self.follow_ground_slope_multiplier
    }
    fn follow_ground_max_upwards_angle(&self) -> &f32 {
        &self.follow_ground_max_upwards_angle
    }
    fn follow_ground_max_downwards_angle(&self) -> &f32 {
        &self.follow_ground_max_downwards_angle
    }
}

impl AvoidanceBehaviourBaseDataTrait for VerticalAvoidanceData {
    fn obstacle_materials(&self) -> &Vec<ObstacleMaterial> {
        self._glacier_base.obstacle_materials()
    }
}

impl InputFilterBaseDataTrait for VerticalAvoidanceData {
}

impl super::core::DataContainerTrait for VerticalAvoidanceData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static VERTICALAVOIDANCEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VerticalAvoidanceData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AVOIDANCEBEHAVIOURBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VerticalAvoidanceData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "TestForHit",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VerticalAvoidanceData, test_for_hit),
            },
            FieldInfoData {
                name: "TestOnReverse",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VerticalAvoidanceData, test_on_reverse),
            },
            FieldInfoData {
                name: "DetectionDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VerticalAvoidanceData, detection_distance),
            },
            FieldInfoData {
                name: "DetectionDistanceReverse",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VerticalAvoidanceData, detection_distance_reverse),
            },
            FieldInfoData {
                name: "SpeedScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VerticalAvoidanceData, speed_scale),
            },
            FieldInfoData {
                name: "HeightOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VerticalAvoidanceData, height_offset),
            },
            FieldInfoData {
                name: "LateralOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VerticalAvoidanceData, lateral_offset),
            },
            FieldInfoData {
                name: "Length",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VerticalAvoidanceData, length),
            },
            FieldInfoData {
                name: "AllowBreakingSpeedLimit",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VerticalAvoidanceData, allow_breaking_speed_limit),
            },
            FieldInfoData {
                name: "StoppingInputStrength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VerticalAvoidanceData, stopping_input_strength),
            },
            FieldInfoData {
                name: "StoppingAbsoluteDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VerticalAvoidanceData, stopping_absolute_distance),
            },
            FieldInfoData {
                name: "ForwardDirectionOverrideVelocityAtSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VerticalAvoidanceData, forward_direction_override_velocity_at_speed),
            },
            FieldInfoData {
                name: "InputToVelocityBlendParams",
                flags: MemberInfoFlags::new(0),
                field_type: "InputToVelocityBendParams",
                rust_offset: offset_of!(VerticalAvoidanceData, input_to_velocity_blend_params),
            },
            FieldInfoData {
                name: "FollowGroundSlopeMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VerticalAvoidanceData, follow_ground_slope_multiplier),
            },
            FieldInfoData {
                name: "FollowGroundMaxUpwardsAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VerticalAvoidanceData, follow_ground_max_upwards_angle),
            },
            FieldInfoData {
                name: "FollowGroundMaxDownwardsAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VerticalAvoidanceData, follow_ground_max_downwards_angle),
            },
        ],
    }),
    array_type: Some(VERTICALAVOIDANCEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VerticalAvoidanceData {
    fn type_info(&self) -> &'static TypeInfo {
        VERTICALAVOIDANCEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VERTICALAVOIDANCEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VerticalAvoidanceData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("VerticalAvoidanceData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct HintBoxAvoidanceData {
    pub _glacier_base: AvoidanceBehaviourBaseData,
    pub detection_distance: f32,
    pub strength: f32,
}

pub trait HintBoxAvoidanceDataTrait: AvoidanceBehaviourBaseDataTrait {
    fn detection_distance(&self) -> &f32;
    fn strength(&self) -> &f32;
}

impl HintBoxAvoidanceDataTrait for HintBoxAvoidanceData {
    fn detection_distance(&self) -> &f32 {
        &self.detection_distance
    }
    fn strength(&self) -> &f32 {
        &self.strength
    }
}

impl AvoidanceBehaviourBaseDataTrait for HintBoxAvoidanceData {
    fn obstacle_materials(&self) -> &Vec<ObstacleMaterial> {
        self._glacier_base.obstacle_materials()
    }
}

impl InputFilterBaseDataTrait for HintBoxAvoidanceData {
}

impl super::core::DataContainerTrait for HintBoxAvoidanceData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static HINTBOXAVOIDANCEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HintBoxAvoidanceData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AVOIDANCEBEHAVIOURBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<HintBoxAvoidanceData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DetectionDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HintBoxAvoidanceData, detection_distance),
            },
            FieldInfoData {
                name: "Strength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HintBoxAvoidanceData, strength),
            },
        ],
    }),
    array_type: Some(HINTBOXAVOIDANCEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for HintBoxAvoidanceData {
    fn type_info(&self) -> &'static TypeInfo {
        HINTBOXAVOIDANCEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static HINTBOXAVOIDANCEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HintBoxAvoidanceData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("HintBoxAvoidanceData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DefaultAvoidanceData {
    pub _glacier_base: AvoidanceBehaviourBaseData,
    pub ray_forward_length: f32,
    pub ray_side_length: f32,
    pub speed_scale: f32,
    pub extended_hit_lambda: f32,
    pub allow_breaking_speed_limit: f32,
    pub stopping_input_strength: f32,
    pub stopping_absolute_distance: f32,
    pub allow_strafe_speed_limit: f32,
    pub steer_input_proportional_strength: f32,
    pub steer_input_derivative_strength: f32,
    pub scale_down_yaw_strength: f32,
    pub scale_down_yaw_speed_limit: f32,
    pub forward_direction_override_velocity_at_speed: f32,
    pub input_to_velocity_blend_params: Option<Arc<Mutex<dyn InputToVelocityBendParamsTrait>>>,
    pub height_offset: f32,
    pub width_offset: f32,
    pub side_angle: f32,
    pub follow_ground_slope_multiplier: f32,
    pub follow_ground_max_upwards_angle: f32,
    pub follow_ground_max_downwards_angle: f32,
}

pub trait DefaultAvoidanceDataTrait: AvoidanceBehaviourBaseDataTrait {
    fn ray_forward_length(&self) -> &f32;
    fn ray_side_length(&self) -> &f32;
    fn speed_scale(&self) -> &f32;
    fn extended_hit_lambda(&self) -> &f32;
    fn allow_breaking_speed_limit(&self) -> &f32;
    fn stopping_input_strength(&self) -> &f32;
    fn stopping_absolute_distance(&self) -> &f32;
    fn allow_strafe_speed_limit(&self) -> &f32;
    fn steer_input_proportional_strength(&self) -> &f32;
    fn steer_input_derivative_strength(&self) -> &f32;
    fn scale_down_yaw_strength(&self) -> &f32;
    fn scale_down_yaw_speed_limit(&self) -> &f32;
    fn forward_direction_override_velocity_at_speed(&self) -> &f32;
    fn input_to_velocity_blend_params(&self) -> &Option<Arc<Mutex<dyn InputToVelocityBendParamsTrait>>>;
    fn height_offset(&self) -> &f32;
    fn width_offset(&self) -> &f32;
    fn side_angle(&self) -> &f32;
    fn follow_ground_slope_multiplier(&self) -> &f32;
    fn follow_ground_max_upwards_angle(&self) -> &f32;
    fn follow_ground_max_downwards_angle(&self) -> &f32;
}

impl DefaultAvoidanceDataTrait for DefaultAvoidanceData {
    fn ray_forward_length(&self) -> &f32 {
        &self.ray_forward_length
    }
    fn ray_side_length(&self) -> &f32 {
        &self.ray_side_length
    }
    fn speed_scale(&self) -> &f32 {
        &self.speed_scale
    }
    fn extended_hit_lambda(&self) -> &f32 {
        &self.extended_hit_lambda
    }
    fn allow_breaking_speed_limit(&self) -> &f32 {
        &self.allow_breaking_speed_limit
    }
    fn stopping_input_strength(&self) -> &f32 {
        &self.stopping_input_strength
    }
    fn stopping_absolute_distance(&self) -> &f32 {
        &self.stopping_absolute_distance
    }
    fn allow_strafe_speed_limit(&self) -> &f32 {
        &self.allow_strafe_speed_limit
    }
    fn steer_input_proportional_strength(&self) -> &f32 {
        &self.steer_input_proportional_strength
    }
    fn steer_input_derivative_strength(&self) -> &f32 {
        &self.steer_input_derivative_strength
    }
    fn scale_down_yaw_strength(&self) -> &f32 {
        &self.scale_down_yaw_strength
    }
    fn scale_down_yaw_speed_limit(&self) -> &f32 {
        &self.scale_down_yaw_speed_limit
    }
    fn forward_direction_override_velocity_at_speed(&self) -> &f32 {
        &self.forward_direction_override_velocity_at_speed
    }
    fn input_to_velocity_blend_params(&self) -> &Option<Arc<Mutex<dyn InputToVelocityBendParamsTrait>>> {
        &self.input_to_velocity_blend_params
    }
    fn height_offset(&self) -> &f32 {
        &self.height_offset
    }
    fn width_offset(&self) -> &f32 {
        &self.width_offset
    }
    fn side_angle(&self) -> &f32 {
        &self.side_angle
    }
    fn follow_ground_slope_multiplier(&self) -> &f32 {
        &self.follow_ground_slope_multiplier
    }
    fn follow_ground_max_upwards_angle(&self) -> &f32 {
        &self.follow_ground_max_upwards_angle
    }
    fn follow_ground_max_downwards_angle(&self) -> &f32 {
        &self.follow_ground_max_downwards_angle
    }
}

impl AvoidanceBehaviourBaseDataTrait for DefaultAvoidanceData {
    fn obstacle_materials(&self) -> &Vec<ObstacleMaterial> {
        self._glacier_base.obstacle_materials()
    }
}

impl InputFilterBaseDataTrait for DefaultAvoidanceData {
}

impl super::core::DataContainerTrait for DefaultAvoidanceData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static DEFAULTAVOIDANCEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DefaultAvoidanceData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AVOIDANCEBEHAVIOURBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DefaultAvoidanceData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "RayForwardLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DefaultAvoidanceData, ray_forward_length),
            },
            FieldInfoData {
                name: "RaySideLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DefaultAvoidanceData, ray_side_length),
            },
            FieldInfoData {
                name: "SpeedScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DefaultAvoidanceData, speed_scale),
            },
            FieldInfoData {
                name: "ExtendedHitLambda",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DefaultAvoidanceData, extended_hit_lambda),
            },
            FieldInfoData {
                name: "AllowBreakingSpeedLimit",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DefaultAvoidanceData, allow_breaking_speed_limit),
            },
            FieldInfoData {
                name: "StoppingInputStrength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DefaultAvoidanceData, stopping_input_strength),
            },
            FieldInfoData {
                name: "StoppingAbsoluteDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DefaultAvoidanceData, stopping_absolute_distance),
            },
            FieldInfoData {
                name: "AllowStrafeSpeedLimit",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DefaultAvoidanceData, allow_strafe_speed_limit),
            },
            FieldInfoData {
                name: "SteerInputProportionalStrength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DefaultAvoidanceData, steer_input_proportional_strength),
            },
            FieldInfoData {
                name: "SteerInputDerivativeStrength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DefaultAvoidanceData, steer_input_derivative_strength),
            },
            FieldInfoData {
                name: "ScaleDownYawStrength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DefaultAvoidanceData, scale_down_yaw_strength),
            },
            FieldInfoData {
                name: "ScaleDownYawSpeedLimit",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DefaultAvoidanceData, scale_down_yaw_speed_limit),
            },
            FieldInfoData {
                name: "ForwardDirectionOverrideVelocityAtSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DefaultAvoidanceData, forward_direction_override_velocity_at_speed),
            },
            FieldInfoData {
                name: "InputToVelocityBlendParams",
                flags: MemberInfoFlags::new(0),
                field_type: "InputToVelocityBendParams",
                rust_offset: offset_of!(DefaultAvoidanceData, input_to_velocity_blend_params),
            },
            FieldInfoData {
                name: "HeightOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DefaultAvoidanceData, height_offset),
            },
            FieldInfoData {
                name: "WidthOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DefaultAvoidanceData, width_offset),
            },
            FieldInfoData {
                name: "SideAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DefaultAvoidanceData, side_angle),
            },
            FieldInfoData {
                name: "FollowGroundSlopeMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DefaultAvoidanceData, follow_ground_slope_multiplier),
            },
            FieldInfoData {
                name: "FollowGroundMaxUpwardsAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DefaultAvoidanceData, follow_ground_max_upwards_angle),
            },
            FieldInfoData {
                name: "FollowGroundMaxDownwardsAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DefaultAvoidanceData, follow_ground_max_downwards_angle),
            },
        ],
    }),
    array_type: Some(DEFAULTAVOIDANCEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DefaultAvoidanceData {
    fn type_info(&self) -> &'static TypeInfo {
        DEFAULTAVOIDANCEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static DEFAULTAVOIDANCEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DefaultAvoidanceData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("DefaultAvoidanceData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct InputToVelocityBendParams {
    pub _glacier_base: super::core::DataContainer,
    pub input_to_velocity_blend_min: f32,
    pub velocity_at_min: f32,
    pub input_to_velocity_blend_max: f32,
    pub velocity_at_max: f32,
}

pub trait InputToVelocityBendParamsTrait: super::core::DataContainerTrait {
    fn input_to_velocity_blend_min(&self) -> &f32;
    fn velocity_at_min(&self) -> &f32;
    fn input_to_velocity_blend_max(&self) -> &f32;
    fn velocity_at_max(&self) -> &f32;
}

impl InputToVelocityBendParamsTrait for InputToVelocityBendParams {
    fn input_to_velocity_blend_min(&self) -> &f32 {
        &self.input_to_velocity_blend_min
    }
    fn velocity_at_min(&self) -> &f32 {
        &self.velocity_at_min
    }
    fn input_to_velocity_blend_max(&self) -> &f32 {
        &self.input_to_velocity_blend_max
    }
    fn velocity_at_max(&self) -> &f32 {
        &self.velocity_at_max
    }
}

impl super::core::DataContainerTrait for InputToVelocityBendParams {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static INPUTTOVELOCITYBENDPARAMS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InputToVelocityBendParams",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<InputToVelocityBendParams as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "InputToVelocityBlendMin",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(InputToVelocityBendParams, input_to_velocity_blend_min),
            },
            FieldInfoData {
                name: "VelocityAtMin",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(InputToVelocityBendParams, velocity_at_min),
            },
            FieldInfoData {
                name: "InputToVelocityBlendMax",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(InputToVelocityBendParams, input_to_velocity_blend_max),
            },
            FieldInfoData {
                name: "VelocityAtMax",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(InputToVelocityBendParams, velocity_at_max),
            },
        ],
    }),
    array_type: Some(INPUTTOVELOCITYBENDPARAMS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for InputToVelocityBendParams {
    fn type_info(&self) -> &'static TypeInfo {
        INPUTTOVELOCITYBENDPARAMS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static INPUTTOVELOCITYBENDPARAMS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InputToVelocityBendParams-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("InputToVelocityBendParams"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AvoidanceBehaviourBaseData {
    pub _glacier_base: InputFilterBaseData,
    pub obstacle_materials: Vec<ObstacleMaterial>,
}

pub trait AvoidanceBehaviourBaseDataTrait: InputFilterBaseDataTrait {
    fn obstacle_materials(&self) -> &Vec<ObstacleMaterial>;
}

impl AvoidanceBehaviourBaseDataTrait for AvoidanceBehaviourBaseData {
    fn obstacle_materials(&self) -> &Vec<ObstacleMaterial> {
        &self.obstacle_materials
    }
}

impl InputFilterBaseDataTrait for AvoidanceBehaviourBaseData {
}

impl super::core::DataContainerTrait for AvoidanceBehaviourBaseData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static AVOIDANCEBEHAVIOURBASEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AvoidanceBehaviourBaseData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(INPUTFILTERBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AvoidanceBehaviourBaseData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ObstacleMaterials",
                flags: MemberInfoFlags::new(144),
                field_type: "ObstacleMaterial-Array",
                rust_offset: offset_of!(AvoidanceBehaviourBaseData, obstacle_materials),
            },
        ],
    }),
    array_type: Some(AVOIDANCEBEHAVIOURBASEDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for AvoidanceBehaviourBaseData {
    fn type_info(&self) -> &'static TypeInfo {
        AVOIDANCEBEHAVIOURBASEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static AVOIDANCEBEHAVIOURBASEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AvoidanceBehaviourBaseData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("AvoidanceBehaviourBaseData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct InputFilterBaseData {
    pub _glacier_base: super::core::DataContainer,
}

pub trait InputFilterBaseDataTrait: super::core::DataContainerTrait {
}

impl InputFilterBaseDataTrait for InputFilterBaseData {
}

impl super::core::DataContainerTrait for InputFilterBaseData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static INPUTFILTERBASEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InputFilterBaseData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<InputFilterBaseData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(INPUTFILTERBASEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for InputFilterBaseData {
    fn type_info(&self) -> &'static TypeInfo {
        INPUTFILTERBASEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static INPUTFILTERBASEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InputFilterBaseData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("InputFilterBaseData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ObstacleMaterial {
    pub material: super::entity::MaterialDecl,
}

pub trait ObstacleMaterialTrait: TypeObject {
    fn material(&self) -> &super::entity::MaterialDecl;
}

impl ObstacleMaterialTrait for ObstacleMaterial {
    fn material(&self) -> &super::entity::MaterialDecl {
        &self.material
    }
}

pub static OBSTACLEMATERIAL_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObstacleMaterial",
    flags: MemberInfoFlags::new(32841),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ObstacleMaterial as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Material",
                flags: MemberInfoFlags::new(0),
                field_type: "MaterialDecl",
                rust_offset: offset_of!(ObstacleMaterial, material),
            },
        ],
    }),
    array_type: Some(OBSTACLEMATERIAL_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for ObstacleMaterial {
    fn type_info(&self) -> &'static TypeInfo {
        OBSTACLEMATERIAL_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static OBSTACLEMATERIAL_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObstacleMaterial-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("ObstacleMaterial"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ClientVec3ToServerData {
    pub _glacier_base: super::entity::EntityData,
    pub frustum_check_enable: bool,
    pub frustum_fov: f32,
    pub frustum_offset: super::core::LinearTransform,
}

pub trait ClientVec3ToServerDataTrait: super::entity::EntityDataTrait {
    fn frustum_check_enable(&self) -> &bool;
    fn frustum_fov(&self) -> &f32;
    fn frustum_offset(&self) -> &super::core::LinearTransform;
}

impl ClientVec3ToServerDataTrait for ClientVec3ToServerData {
    fn frustum_check_enable(&self) -> &bool {
        &self.frustum_check_enable
    }
    fn frustum_fov(&self) -> &f32 {
        &self.frustum_fov
    }
    fn frustum_offset(&self) -> &super::core::LinearTransform {
        &self.frustum_offset
    }
}

impl super::entity::EntityDataTrait for ClientVec3ToServerData {
}

impl super::entity::GameObjectDataTrait for ClientVec3ToServerData {
}

impl super::core::DataBusPeerTrait for ClientVec3ToServerData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for ClientVec3ToServerData {
}

impl super::core::DataContainerTrait for ClientVec3ToServerData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CLIENTVEC3TOSERVERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClientVec3ToServerData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ClientVec3ToServerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "FrustumCheckEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ClientVec3ToServerData, frustum_check_enable),
            },
            FieldInfoData {
                name: "FrustumFov",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ClientVec3ToServerData, frustum_fov),
            },
            FieldInfoData {
                name: "FrustumOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(ClientVec3ToServerData, frustum_offset),
            },
        ],
    }),
    array_type: Some(CLIENTVEC3TOSERVERDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ClientVec3ToServerData {
    fn type_info(&self) -> &'static TypeInfo {
        CLIENTVEC3TOSERVERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CLIENTVEC3TOSERVERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClientVec3ToServerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("ClientVec3ToServerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ClientGravityWellTrackerEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub this_starfighter_transform: super::core::LinearTransform,
    pub target_starfighter_transform: super::core::LinearTransform,
}

pub trait ClientGravityWellTrackerEntityDataTrait: super::entity::EntityDataTrait {
    fn this_starfighter_transform(&self) -> &super::core::LinearTransform;
    fn target_starfighter_transform(&self) -> &super::core::LinearTransform;
}

impl ClientGravityWellTrackerEntityDataTrait for ClientGravityWellTrackerEntityData {
    fn this_starfighter_transform(&self) -> &super::core::LinearTransform {
        &self.this_starfighter_transform
    }
    fn target_starfighter_transform(&self) -> &super::core::LinearTransform {
        &self.target_starfighter_transform
    }
}

impl super::entity::EntityDataTrait for ClientGravityWellTrackerEntityData {
}

impl super::entity::GameObjectDataTrait for ClientGravityWellTrackerEntityData {
}

impl super::core::DataBusPeerTrait for ClientGravityWellTrackerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for ClientGravityWellTrackerEntityData {
}

impl super::core::DataContainerTrait for ClientGravityWellTrackerEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CLIENTGRAVITYWELLTRACKERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClientGravityWellTrackerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ClientGravityWellTrackerEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ThisStarfighterTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(ClientGravityWellTrackerEntityData, this_starfighter_transform),
            },
            FieldInfoData {
                name: "TargetStarfighterTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(ClientGravityWellTrackerEntityData, target_starfighter_transform),
            },
        ],
    }),
    array_type: Some(CLIENTGRAVITYWELLTRACKERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ClientGravityWellTrackerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CLIENTGRAVITYWELLTRACKERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CLIENTGRAVITYWELLTRACKERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClientGravityWellTrackerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("ClientGravityWellTrackerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PhysicalCameraTransformerEntityData {
    pub _glacier_base: CameraTransformerEntityData,
    pub look_around_pivot_transform: super::core::LinearTransform,
    pub follow_target_transform: super::core::LinearTransform,
    pub look_at_target_transform: super::core::LinearTransform,
    pub follow_distance: f32,
    pub follow_distance_max: f32,
    pub follow_distance_change_speed: f32,
    pub follow_height: f32,
    pub speed_control: bool,
    pub ref_max_speed: f32,
    pub follow_distance_curve: super::core::AudioCurve,
    pub follow_distance_max_curve: super::core::AudioCurve,
    pub follow_distance_change_speed_curve: super::core::AudioCurve,
    pub follow_height_curve: super::core::AudioCurve,
    pub convergence_speeds: super::core::Vec3,
    pub momentum_per_axis: super::core::Vec3,
    pub damping_per_axis: super::core::Vec3,
    pub reference_up_blend_body: f32,
    pub reference_up_blend_world: f32,
    pub reference_up_blend_camera: f32,
    pub follow_distance_min: f32,
    pub start_reversing_speed_threshold: f32,
    pub enable_in_air_landing_logic: bool,
    pub max_landing_intensity_threshold: f32,
    pub min_landing_intensity_threshold: f32,
    pub landing_params_duration: f32,
    pub impact_force_to_height_multiplier_curve: super::core::AudioCurve,
    pub landing_convergence_speeds: super::core::Vec3,
    pub landing_momentum_per_axis: super::core::Vec3,
    pub landing_damping_per_axis: super::core::Vec3,
    pub params_override: bool,
    pub in_air_look_c_o_m_weight: f32,
    pub velocity_based_look_at_min_speed: f32,
    pub velocity_based_look_at_max_speed: f32,
    pub look_at_blend_between_direction_and_velocity: f32,
    pub look_target_offset: super::core::Vec3,
    pub look_c_o_m_weight: f32,
    pub move_target_flattening: f32,
    pub look_lerp: f32,
    pub angle_to_look_c_o_m_weight_curve: super::core::AudioCurve,
    pub use_angle_to_look_c_o_m_weight_curve: bool,
    pub pill_minimum_collision_radius: f32,
    pub pill_maximum_collision_radius: f32,
    pub pill_minimum_collision_lenght: f32,
    pub use_world_up_for_look_around: f32,
    pub input_camera_look_forward: f32,
    pub input_camera_look_side: f32,
    pub input_camera_look_delta: f32,
    pub input_camera_look_back: bool,
}

pub trait PhysicalCameraTransformerEntityDataTrait: CameraTransformerEntityDataTrait {
    fn look_around_pivot_transform(&self) -> &super::core::LinearTransform;
    fn follow_target_transform(&self) -> &super::core::LinearTransform;
    fn look_at_target_transform(&self) -> &super::core::LinearTransform;
    fn follow_distance(&self) -> &f32;
    fn follow_distance_max(&self) -> &f32;
    fn follow_distance_change_speed(&self) -> &f32;
    fn follow_height(&self) -> &f32;
    fn speed_control(&self) -> &bool;
    fn ref_max_speed(&self) -> &f32;
    fn follow_distance_curve(&self) -> &super::core::AudioCurve;
    fn follow_distance_max_curve(&self) -> &super::core::AudioCurve;
    fn follow_distance_change_speed_curve(&self) -> &super::core::AudioCurve;
    fn follow_height_curve(&self) -> &super::core::AudioCurve;
    fn convergence_speeds(&self) -> &super::core::Vec3;
    fn momentum_per_axis(&self) -> &super::core::Vec3;
    fn damping_per_axis(&self) -> &super::core::Vec3;
    fn reference_up_blend_body(&self) -> &f32;
    fn reference_up_blend_world(&self) -> &f32;
    fn reference_up_blend_camera(&self) -> &f32;
    fn follow_distance_min(&self) -> &f32;
    fn start_reversing_speed_threshold(&self) -> &f32;
    fn enable_in_air_landing_logic(&self) -> &bool;
    fn max_landing_intensity_threshold(&self) -> &f32;
    fn min_landing_intensity_threshold(&self) -> &f32;
    fn landing_params_duration(&self) -> &f32;
    fn impact_force_to_height_multiplier_curve(&self) -> &super::core::AudioCurve;
    fn landing_convergence_speeds(&self) -> &super::core::Vec3;
    fn landing_momentum_per_axis(&self) -> &super::core::Vec3;
    fn landing_damping_per_axis(&self) -> &super::core::Vec3;
    fn params_override(&self) -> &bool;
    fn in_air_look_c_o_m_weight(&self) -> &f32;
    fn velocity_based_look_at_min_speed(&self) -> &f32;
    fn velocity_based_look_at_max_speed(&self) -> &f32;
    fn look_at_blend_between_direction_and_velocity(&self) -> &f32;
    fn look_target_offset(&self) -> &super::core::Vec3;
    fn look_c_o_m_weight(&self) -> &f32;
    fn move_target_flattening(&self) -> &f32;
    fn look_lerp(&self) -> &f32;
    fn angle_to_look_c_o_m_weight_curve(&self) -> &super::core::AudioCurve;
    fn use_angle_to_look_c_o_m_weight_curve(&self) -> &bool;
    fn pill_minimum_collision_radius(&self) -> &f32;
    fn pill_maximum_collision_radius(&self) -> &f32;
    fn pill_minimum_collision_lenght(&self) -> &f32;
    fn use_world_up_for_look_around(&self) -> &f32;
    fn input_camera_look_forward(&self) -> &f32;
    fn input_camera_look_side(&self) -> &f32;
    fn input_camera_look_delta(&self) -> &f32;
    fn input_camera_look_back(&self) -> &bool;
}

impl PhysicalCameraTransformerEntityDataTrait for PhysicalCameraTransformerEntityData {
    fn look_around_pivot_transform(&self) -> &super::core::LinearTransform {
        &self.look_around_pivot_transform
    }
    fn follow_target_transform(&self) -> &super::core::LinearTransform {
        &self.follow_target_transform
    }
    fn look_at_target_transform(&self) -> &super::core::LinearTransform {
        &self.look_at_target_transform
    }
    fn follow_distance(&self) -> &f32 {
        &self.follow_distance
    }
    fn follow_distance_max(&self) -> &f32 {
        &self.follow_distance_max
    }
    fn follow_distance_change_speed(&self) -> &f32 {
        &self.follow_distance_change_speed
    }
    fn follow_height(&self) -> &f32 {
        &self.follow_height
    }
    fn speed_control(&self) -> &bool {
        &self.speed_control
    }
    fn ref_max_speed(&self) -> &f32 {
        &self.ref_max_speed
    }
    fn follow_distance_curve(&self) -> &super::core::AudioCurve {
        &self.follow_distance_curve
    }
    fn follow_distance_max_curve(&self) -> &super::core::AudioCurve {
        &self.follow_distance_max_curve
    }
    fn follow_distance_change_speed_curve(&self) -> &super::core::AudioCurve {
        &self.follow_distance_change_speed_curve
    }
    fn follow_height_curve(&self) -> &super::core::AudioCurve {
        &self.follow_height_curve
    }
    fn convergence_speeds(&self) -> &super::core::Vec3 {
        &self.convergence_speeds
    }
    fn momentum_per_axis(&self) -> &super::core::Vec3 {
        &self.momentum_per_axis
    }
    fn damping_per_axis(&self) -> &super::core::Vec3 {
        &self.damping_per_axis
    }
    fn reference_up_blend_body(&self) -> &f32 {
        &self.reference_up_blend_body
    }
    fn reference_up_blend_world(&self) -> &f32 {
        &self.reference_up_blend_world
    }
    fn reference_up_blend_camera(&self) -> &f32 {
        &self.reference_up_blend_camera
    }
    fn follow_distance_min(&self) -> &f32 {
        &self.follow_distance_min
    }
    fn start_reversing_speed_threshold(&self) -> &f32 {
        &self.start_reversing_speed_threshold
    }
    fn enable_in_air_landing_logic(&self) -> &bool {
        &self.enable_in_air_landing_logic
    }
    fn max_landing_intensity_threshold(&self) -> &f32 {
        &self.max_landing_intensity_threshold
    }
    fn min_landing_intensity_threshold(&self) -> &f32 {
        &self.min_landing_intensity_threshold
    }
    fn landing_params_duration(&self) -> &f32 {
        &self.landing_params_duration
    }
    fn impact_force_to_height_multiplier_curve(&self) -> &super::core::AudioCurve {
        &self.impact_force_to_height_multiplier_curve
    }
    fn landing_convergence_speeds(&self) -> &super::core::Vec3 {
        &self.landing_convergence_speeds
    }
    fn landing_momentum_per_axis(&self) -> &super::core::Vec3 {
        &self.landing_momentum_per_axis
    }
    fn landing_damping_per_axis(&self) -> &super::core::Vec3 {
        &self.landing_damping_per_axis
    }
    fn params_override(&self) -> &bool {
        &self.params_override
    }
    fn in_air_look_c_o_m_weight(&self) -> &f32 {
        &self.in_air_look_c_o_m_weight
    }
    fn velocity_based_look_at_min_speed(&self) -> &f32 {
        &self.velocity_based_look_at_min_speed
    }
    fn velocity_based_look_at_max_speed(&self) -> &f32 {
        &self.velocity_based_look_at_max_speed
    }
    fn look_at_blend_between_direction_and_velocity(&self) -> &f32 {
        &self.look_at_blend_between_direction_and_velocity
    }
    fn look_target_offset(&self) -> &super::core::Vec3 {
        &self.look_target_offset
    }
    fn look_c_o_m_weight(&self) -> &f32 {
        &self.look_c_o_m_weight
    }
    fn move_target_flattening(&self) -> &f32 {
        &self.move_target_flattening
    }
    fn look_lerp(&self) -> &f32 {
        &self.look_lerp
    }
    fn angle_to_look_c_o_m_weight_curve(&self) -> &super::core::AudioCurve {
        &self.angle_to_look_c_o_m_weight_curve
    }
    fn use_angle_to_look_c_o_m_weight_curve(&self) -> &bool {
        &self.use_angle_to_look_c_o_m_weight_curve
    }
    fn pill_minimum_collision_radius(&self) -> &f32 {
        &self.pill_minimum_collision_radius
    }
    fn pill_maximum_collision_radius(&self) -> &f32 {
        &self.pill_maximum_collision_radius
    }
    fn pill_minimum_collision_lenght(&self) -> &f32 {
        &self.pill_minimum_collision_lenght
    }
    fn use_world_up_for_look_around(&self) -> &f32 {
        &self.use_world_up_for_look_around
    }
    fn input_camera_look_forward(&self) -> &f32 {
        &self.input_camera_look_forward
    }
    fn input_camera_look_side(&self) -> &f32 {
        &self.input_camera_look_side
    }
    fn input_camera_look_delta(&self) -> &f32 {
        &self.input_camera_look_delta
    }
    fn input_camera_look_back(&self) -> &bool {
        &self.input_camera_look_back
    }
}

impl CameraTransformerEntityDataTrait for PhysicalCameraTransformerEntityData {
    fn update_pass(&self) -> &CameraTransformerUpdatePass {
        self._glacier_base.update_pass()
    }
    fn camera_transformer_update_priority(&self) -> &i32 {
        self._glacier_base.camera_transformer_update_priority()
    }
    fn active(&self) -> &bool {
        self._glacier_base.active()
    }
}

impl super::entity::EntityDataTrait for PhysicalCameraTransformerEntityData {
}

impl super::entity::GameObjectDataTrait for PhysicalCameraTransformerEntityData {
}

impl super::core::DataBusPeerTrait for PhysicalCameraTransformerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for PhysicalCameraTransformerEntityData {
}

impl super::core::DataContainerTrait for PhysicalCameraTransformerEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PHYSICALCAMERATRANSFORMERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicalCameraTransformerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CAMERATRANSFORMERENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PhysicalCameraTransformerEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "LookAroundPivotTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(PhysicalCameraTransformerEntityData, look_around_pivot_transform),
            },
            FieldInfoData {
                name: "FollowTargetTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(PhysicalCameraTransformerEntityData, follow_target_transform),
            },
            FieldInfoData {
                name: "LookAtTargetTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(PhysicalCameraTransformerEntityData, look_at_target_transform),
            },
            FieldInfoData {
                name: "FollowDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicalCameraTransformerEntityData, follow_distance),
            },
            FieldInfoData {
                name: "FollowDistanceMax",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicalCameraTransformerEntityData, follow_distance_max),
            },
            FieldInfoData {
                name: "FollowDistanceChangeSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicalCameraTransformerEntityData, follow_distance_change_speed),
            },
            FieldInfoData {
                name: "FollowHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicalCameraTransformerEntityData, follow_height),
            },
            FieldInfoData {
                name: "SpeedControl",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PhysicalCameraTransformerEntityData, speed_control),
            },
            FieldInfoData {
                name: "RefMaxSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicalCameraTransformerEntityData, ref_max_speed),
            },
            FieldInfoData {
                name: "FollowDistanceCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioCurve",
                rust_offset: offset_of!(PhysicalCameraTransformerEntityData, follow_distance_curve),
            },
            FieldInfoData {
                name: "FollowDistanceMaxCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioCurve",
                rust_offset: offset_of!(PhysicalCameraTransformerEntityData, follow_distance_max_curve),
            },
            FieldInfoData {
                name: "FollowDistanceChangeSpeedCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioCurve",
                rust_offset: offset_of!(PhysicalCameraTransformerEntityData, follow_distance_change_speed_curve),
            },
            FieldInfoData {
                name: "FollowHeightCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioCurve",
                rust_offset: offset_of!(PhysicalCameraTransformerEntityData, follow_height_curve),
            },
            FieldInfoData {
                name: "ConvergenceSpeeds",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(PhysicalCameraTransformerEntityData, convergence_speeds),
            },
            FieldInfoData {
                name: "MomentumPerAxis",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(PhysicalCameraTransformerEntityData, momentum_per_axis),
            },
            FieldInfoData {
                name: "DampingPerAxis",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(PhysicalCameraTransformerEntityData, damping_per_axis),
            },
            FieldInfoData {
                name: "ReferenceUpBlendBody",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicalCameraTransformerEntityData, reference_up_blend_body),
            },
            FieldInfoData {
                name: "ReferenceUpBlendWorld",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicalCameraTransformerEntityData, reference_up_blend_world),
            },
            FieldInfoData {
                name: "ReferenceUpBlendCamera",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicalCameraTransformerEntityData, reference_up_blend_camera),
            },
            FieldInfoData {
                name: "FollowDistanceMin",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicalCameraTransformerEntityData, follow_distance_min),
            },
            FieldInfoData {
                name: "StartReversingSpeedThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicalCameraTransformerEntityData, start_reversing_speed_threshold),
            },
            FieldInfoData {
                name: "EnableInAirLandingLogic",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PhysicalCameraTransformerEntityData, enable_in_air_landing_logic),
            },
            FieldInfoData {
                name: "MaxLandingIntensityThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicalCameraTransformerEntityData, max_landing_intensity_threshold),
            },
            FieldInfoData {
                name: "MinLandingIntensityThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicalCameraTransformerEntityData, min_landing_intensity_threshold),
            },
            FieldInfoData {
                name: "LandingParamsDuration",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicalCameraTransformerEntityData, landing_params_duration),
            },
            FieldInfoData {
                name: "ImpactForceToHeightMultiplierCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioCurve",
                rust_offset: offset_of!(PhysicalCameraTransformerEntityData, impact_force_to_height_multiplier_curve),
            },
            FieldInfoData {
                name: "LandingConvergenceSpeeds",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(PhysicalCameraTransformerEntityData, landing_convergence_speeds),
            },
            FieldInfoData {
                name: "LandingMomentumPerAxis",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(PhysicalCameraTransformerEntityData, landing_momentum_per_axis),
            },
            FieldInfoData {
                name: "LandingDampingPerAxis",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(PhysicalCameraTransformerEntityData, landing_damping_per_axis),
            },
            FieldInfoData {
                name: "ParamsOverride",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PhysicalCameraTransformerEntityData, params_override),
            },
            FieldInfoData {
                name: "InAirLookCOMWeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicalCameraTransformerEntityData, in_air_look_c_o_m_weight),
            },
            FieldInfoData {
                name: "VelocityBasedLookAtMinSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicalCameraTransformerEntityData, velocity_based_look_at_min_speed),
            },
            FieldInfoData {
                name: "VelocityBasedLookAtMaxSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicalCameraTransformerEntityData, velocity_based_look_at_max_speed),
            },
            FieldInfoData {
                name: "LookAtBlendBetweenDirectionAndVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicalCameraTransformerEntityData, look_at_blend_between_direction_and_velocity),
            },
            FieldInfoData {
                name: "LookTargetOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(PhysicalCameraTransformerEntityData, look_target_offset),
            },
            FieldInfoData {
                name: "LookCOMWeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicalCameraTransformerEntityData, look_c_o_m_weight),
            },
            FieldInfoData {
                name: "MoveTargetFlattening",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicalCameraTransformerEntityData, move_target_flattening),
            },
            FieldInfoData {
                name: "LookLerp",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicalCameraTransformerEntityData, look_lerp),
            },
            FieldInfoData {
                name: "AngleToLookCOMWeightCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioCurve",
                rust_offset: offset_of!(PhysicalCameraTransformerEntityData, angle_to_look_c_o_m_weight_curve),
            },
            FieldInfoData {
                name: "UseAngleToLookCOMWeightCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PhysicalCameraTransformerEntityData, use_angle_to_look_c_o_m_weight_curve),
            },
            FieldInfoData {
                name: "PillMinimumCollisionRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicalCameraTransformerEntityData, pill_minimum_collision_radius),
            },
            FieldInfoData {
                name: "PillMaximumCollisionRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicalCameraTransformerEntityData, pill_maximum_collision_radius),
            },
            FieldInfoData {
                name: "PillMinimumCollisionLenght",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicalCameraTransformerEntityData, pill_minimum_collision_lenght),
            },
            FieldInfoData {
                name: "UseWorldUpForLookAround",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicalCameraTransformerEntityData, use_world_up_for_look_around),
            },
            FieldInfoData {
                name: "InputCameraLookForward",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicalCameraTransformerEntityData, input_camera_look_forward),
            },
            FieldInfoData {
                name: "InputCameraLookSide",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicalCameraTransformerEntityData, input_camera_look_side),
            },
            FieldInfoData {
                name: "InputCameraLookDelta",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicalCameraTransformerEntityData, input_camera_look_delta),
            },
            FieldInfoData {
                name: "InputCameraLookBack",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PhysicalCameraTransformerEntityData, input_camera_look_back),
            },
        ],
    }),
    array_type: Some(PHYSICALCAMERATRANSFORMERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PhysicalCameraTransformerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PHYSICALCAMERATRANSFORMERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PHYSICALCAMERATRANSFORMERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicalCameraTransformerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PhysicalCameraTransformerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct HoverCameraTransformerEntityData {
    pub _glacier_base: CameraTransformerEntityData,
    pub move_frame: super::core::LinearTransform,
    pub normalised_zoom: f32,
    pub pitch_control_input: f32,
    pub aiming_pivot_point: super::core::LinearTransform,
    pub mouse_control_active: bool,
}

pub trait HoverCameraTransformerEntityDataTrait: CameraTransformerEntityDataTrait {
    fn move_frame(&self) -> &super::core::LinearTransform;
    fn normalised_zoom(&self) -> &f32;
    fn pitch_control_input(&self) -> &f32;
    fn aiming_pivot_point(&self) -> &super::core::LinearTransform;
    fn mouse_control_active(&self) -> &bool;
}

impl HoverCameraTransformerEntityDataTrait for HoverCameraTransformerEntityData {
    fn move_frame(&self) -> &super::core::LinearTransform {
        &self.move_frame
    }
    fn normalised_zoom(&self) -> &f32 {
        &self.normalised_zoom
    }
    fn pitch_control_input(&self) -> &f32 {
        &self.pitch_control_input
    }
    fn aiming_pivot_point(&self) -> &super::core::LinearTransform {
        &self.aiming_pivot_point
    }
    fn mouse_control_active(&self) -> &bool {
        &self.mouse_control_active
    }
}

impl CameraTransformerEntityDataTrait for HoverCameraTransformerEntityData {
    fn update_pass(&self) -> &CameraTransformerUpdatePass {
        self._glacier_base.update_pass()
    }
    fn camera_transformer_update_priority(&self) -> &i32 {
        self._glacier_base.camera_transformer_update_priority()
    }
    fn active(&self) -> &bool {
        self._glacier_base.active()
    }
}

impl super::entity::EntityDataTrait for HoverCameraTransformerEntityData {
}

impl super::entity::GameObjectDataTrait for HoverCameraTransformerEntityData {
}

impl super::core::DataBusPeerTrait for HoverCameraTransformerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for HoverCameraTransformerEntityData {
}

impl super::core::DataContainerTrait for HoverCameraTransformerEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static HOVERCAMERATRANSFORMERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HoverCameraTransformerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CAMERATRANSFORMERENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<HoverCameraTransformerEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MoveFrame",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(HoverCameraTransformerEntityData, move_frame),
            },
            FieldInfoData {
                name: "NormalisedZoom",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverCameraTransformerEntityData, normalised_zoom),
            },
            FieldInfoData {
                name: "PitchControlInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverCameraTransformerEntityData, pitch_control_input),
            },
            FieldInfoData {
                name: "AimingPivotPoint",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(HoverCameraTransformerEntityData, aiming_pivot_point),
            },
            FieldInfoData {
                name: "MouseControlActive",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(HoverCameraTransformerEntityData, mouse_control_active),
            },
        ],
    }),
    array_type: Some(HOVERCAMERATRANSFORMERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for HoverCameraTransformerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        HOVERCAMERATRANSFORMERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static HOVERCAMERATRANSFORMERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HoverCameraTransformerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("HoverCameraTransformerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CockpitCameraTransformerEntityData {
    pub _glacier_base: CameraTransformerEntityData,
    pub pilot_zoom: f32,
    pub move_frame: super::core::LinearTransform,
    pub visual_frame: super::core::LinearTransform,
    pub correction_transform: super::core::LinearTransform,
    pub pitch_input: f32,
    pub roll_input: f32,
    pub yaw_input: f32,
}

pub trait CockpitCameraTransformerEntityDataTrait: CameraTransformerEntityDataTrait {
    fn pilot_zoom(&self) -> &f32;
    fn move_frame(&self) -> &super::core::LinearTransform;
    fn visual_frame(&self) -> &super::core::LinearTransform;
    fn correction_transform(&self) -> &super::core::LinearTransform;
    fn pitch_input(&self) -> &f32;
    fn roll_input(&self) -> &f32;
    fn yaw_input(&self) -> &f32;
}

impl CockpitCameraTransformerEntityDataTrait for CockpitCameraTransformerEntityData {
    fn pilot_zoom(&self) -> &f32 {
        &self.pilot_zoom
    }
    fn move_frame(&self) -> &super::core::LinearTransform {
        &self.move_frame
    }
    fn visual_frame(&self) -> &super::core::LinearTransform {
        &self.visual_frame
    }
    fn correction_transform(&self) -> &super::core::LinearTransform {
        &self.correction_transform
    }
    fn pitch_input(&self) -> &f32 {
        &self.pitch_input
    }
    fn roll_input(&self) -> &f32 {
        &self.roll_input
    }
    fn yaw_input(&self) -> &f32 {
        &self.yaw_input
    }
}

impl CameraTransformerEntityDataTrait for CockpitCameraTransformerEntityData {
    fn update_pass(&self) -> &CameraTransformerUpdatePass {
        self._glacier_base.update_pass()
    }
    fn camera_transformer_update_priority(&self) -> &i32 {
        self._glacier_base.camera_transformer_update_priority()
    }
    fn active(&self) -> &bool {
        self._glacier_base.active()
    }
}

impl super::entity::EntityDataTrait for CockpitCameraTransformerEntityData {
}

impl super::entity::GameObjectDataTrait for CockpitCameraTransformerEntityData {
}

impl super::core::DataBusPeerTrait for CockpitCameraTransformerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for CockpitCameraTransformerEntityData {
}

impl super::core::DataContainerTrait for CockpitCameraTransformerEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static COCKPITCAMERATRANSFORMERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CockpitCameraTransformerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CAMERATRANSFORMERENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CockpitCameraTransformerEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PilotZoom",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CockpitCameraTransformerEntityData, pilot_zoom),
            },
            FieldInfoData {
                name: "MoveFrame",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(CockpitCameraTransformerEntityData, move_frame),
            },
            FieldInfoData {
                name: "VisualFrame",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(CockpitCameraTransformerEntityData, visual_frame),
            },
            FieldInfoData {
                name: "CorrectionTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(CockpitCameraTransformerEntityData, correction_transform),
            },
            FieldInfoData {
                name: "PitchInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CockpitCameraTransformerEntityData, pitch_input),
            },
            FieldInfoData {
                name: "RollInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CockpitCameraTransformerEntityData, roll_input),
            },
            FieldInfoData {
                name: "YawInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CockpitCameraTransformerEntityData, yaw_input),
            },
        ],
    }),
    array_type: Some(COCKPITCAMERATRANSFORMERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CockpitCameraTransformerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        COCKPITCAMERATRANSFORMERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static COCKPITCAMERATRANSFORMERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CockpitCameraTransformerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CockpitCameraTransformerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RearViewCameraTransformerEntityData {
    pub _glacier_base: CameraTransformerEntityData,
    pub move_frame: super::core::LinearTransform,
    pub visual_frame: super::core::LinearTransform,
    pub correction_transform: super::core::LinearTransform,
    pub is_first_person: bool,
    pub collision_radius: f32,
}

pub trait RearViewCameraTransformerEntityDataTrait: CameraTransformerEntityDataTrait {
    fn move_frame(&self) -> &super::core::LinearTransform;
    fn visual_frame(&self) -> &super::core::LinearTransform;
    fn correction_transform(&self) -> &super::core::LinearTransform;
    fn is_first_person(&self) -> &bool;
    fn collision_radius(&self) -> &f32;
}

impl RearViewCameraTransformerEntityDataTrait for RearViewCameraTransformerEntityData {
    fn move_frame(&self) -> &super::core::LinearTransform {
        &self.move_frame
    }
    fn visual_frame(&self) -> &super::core::LinearTransform {
        &self.visual_frame
    }
    fn correction_transform(&self) -> &super::core::LinearTransform {
        &self.correction_transform
    }
    fn is_first_person(&self) -> &bool {
        &self.is_first_person
    }
    fn collision_radius(&self) -> &f32 {
        &self.collision_radius
    }
}

impl CameraTransformerEntityDataTrait for RearViewCameraTransformerEntityData {
    fn update_pass(&self) -> &CameraTransformerUpdatePass {
        self._glacier_base.update_pass()
    }
    fn camera_transformer_update_priority(&self) -> &i32 {
        self._glacier_base.camera_transformer_update_priority()
    }
    fn active(&self) -> &bool {
        self._glacier_base.active()
    }
}

impl super::entity::EntityDataTrait for RearViewCameraTransformerEntityData {
}

impl super::entity::GameObjectDataTrait for RearViewCameraTransformerEntityData {
}

impl super::core::DataBusPeerTrait for RearViewCameraTransformerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for RearViewCameraTransformerEntityData {
}

impl super::core::DataContainerTrait for RearViewCameraTransformerEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static REARVIEWCAMERATRANSFORMERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RearViewCameraTransformerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CAMERATRANSFORMERENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RearViewCameraTransformerEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MoveFrame",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(RearViewCameraTransformerEntityData, move_frame),
            },
            FieldInfoData {
                name: "VisualFrame",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(RearViewCameraTransformerEntityData, visual_frame),
            },
            FieldInfoData {
                name: "CorrectionTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(RearViewCameraTransformerEntityData, correction_transform),
            },
            FieldInfoData {
                name: "IsFirstPerson",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RearViewCameraTransformerEntityData, is_first_person),
            },
            FieldInfoData {
                name: "CollisionRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RearViewCameraTransformerEntityData, collision_radius),
            },
        ],
    }),
    array_type: Some(REARVIEWCAMERATRANSFORMERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for RearViewCameraTransformerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        REARVIEWCAMERATRANSFORMERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static REARVIEWCAMERATRANSFORMERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RearViewCameraTransformerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("RearViewCameraTransformerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FollowCameraTransformerEntityData {
    pub _glacier_base: CameraTransformerEntityData,
    pub move_frame: super::core::LinearTransform,
    pub visual_frame: super::core::LinearTransform,
    pub correction_transform: super::core::LinearTransform,
    pub normalised_zoom: f32,
}

pub trait FollowCameraTransformerEntityDataTrait: CameraTransformerEntityDataTrait {
    fn move_frame(&self) -> &super::core::LinearTransform;
    fn visual_frame(&self) -> &super::core::LinearTransform;
    fn correction_transform(&self) -> &super::core::LinearTransform;
    fn normalised_zoom(&self) -> &f32;
}

impl FollowCameraTransformerEntityDataTrait for FollowCameraTransformerEntityData {
    fn move_frame(&self) -> &super::core::LinearTransform {
        &self.move_frame
    }
    fn visual_frame(&self) -> &super::core::LinearTransform {
        &self.visual_frame
    }
    fn correction_transform(&self) -> &super::core::LinearTransform {
        &self.correction_transform
    }
    fn normalised_zoom(&self) -> &f32 {
        &self.normalised_zoom
    }
}

impl CameraTransformerEntityDataTrait for FollowCameraTransformerEntityData {
    fn update_pass(&self) -> &CameraTransformerUpdatePass {
        self._glacier_base.update_pass()
    }
    fn camera_transformer_update_priority(&self) -> &i32 {
        self._glacier_base.camera_transformer_update_priority()
    }
    fn active(&self) -> &bool {
        self._glacier_base.active()
    }
}

impl super::entity::EntityDataTrait for FollowCameraTransformerEntityData {
}

impl super::entity::GameObjectDataTrait for FollowCameraTransformerEntityData {
}

impl super::core::DataBusPeerTrait for FollowCameraTransformerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for FollowCameraTransformerEntityData {
}

impl super::core::DataContainerTrait for FollowCameraTransformerEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static FOLLOWCAMERATRANSFORMERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowCameraTransformerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CAMERATRANSFORMERENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FollowCameraTransformerEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MoveFrame",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(FollowCameraTransformerEntityData, move_frame),
            },
            FieldInfoData {
                name: "VisualFrame",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(FollowCameraTransformerEntityData, visual_frame),
            },
            FieldInfoData {
                name: "CorrectionTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(FollowCameraTransformerEntityData, correction_transform),
            },
            FieldInfoData {
                name: "NormalisedZoom",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowCameraTransformerEntityData, normalised_zoom),
            },
        ],
    }),
    array_type: Some(FOLLOWCAMERATRANSFORMERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for FollowCameraTransformerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        FOLLOWCAMERATRANSFORMERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static FOLLOWCAMERATRANSFORMERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowCameraTransformerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("FollowCameraTransformerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CameraSlerpTransformEntityData {
    pub _glacier_base: CameraTransformerEntityData,
    pub translation_duration_x: f32,
    pub translation_duration_y: f32,
    pub translation_duration_z: f32,
    pub rotation_duration: f32,
    pub only_write_if_modified: bool,
    pub in_transform: super::core::LinearTransform,
}

pub trait CameraSlerpTransformEntityDataTrait: CameraTransformerEntityDataTrait {
    fn translation_duration_x(&self) -> &f32;
    fn translation_duration_y(&self) -> &f32;
    fn translation_duration_z(&self) -> &f32;
    fn rotation_duration(&self) -> &f32;
    fn only_write_if_modified(&self) -> &bool;
    fn in_transform(&self) -> &super::core::LinearTransform;
}

impl CameraSlerpTransformEntityDataTrait for CameraSlerpTransformEntityData {
    fn translation_duration_x(&self) -> &f32 {
        &self.translation_duration_x
    }
    fn translation_duration_y(&self) -> &f32 {
        &self.translation_duration_y
    }
    fn translation_duration_z(&self) -> &f32 {
        &self.translation_duration_z
    }
    fn rotation_duration(&self) -> &f32 {
        &self.rotation_duration
    }
    fn only_write_if_modified(&self) -> &bool {
        &self.only_write_if_modified
    }
    fn in_transform(&self) -> &super::core::LinearTransform {
        &self.in_transform
    }
}

impl CameraTransformerEntityDataTrait for CameraSlerpTransformEntityData {
    fn update_pass(&self) -> &CameraTransformerUpdatePass {
        self._glacier_base.update_pass()
    }
    fn camera_transformer_update_priority(&self) -> &i32 {
        self._glacier_base.camera_transformer_update_priority()
    }
    fn active(&self) -> &bool {
        self._glacier_base.active()
    }
}

impl super::entity::EntityDataTrait for CameraSlerpTransformEntityData {
}

impl super::entity::GameObjectDataTrait for CameraSlerpTransformEntityData {
}

impl super::core::DataBusPeerTrait for CameraSlerpTransformEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for CameraSlerpTransformEntityData {
}

impl super::core::DataContainerTrait for CameraSlerpTransformEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CAMERASLERPTRANSFORMENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraSlerpTransformEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CAMERATRANSFORMERENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraSlerpTransformEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "TranslationDurationX",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraSlerpTransformEntityData, translation_duration_x),
            },
            FieldInfoData {
                name: "TranslationDurationY",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraSlerpTransformEntityData, translation_duration_y),
            },
            FieldInfoData {
                name: "TranslationDurationZ",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraSlerpTransformEntityData, translation_duration_z),
            },
            FieldInfoData {
                name: "RotationDuration",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraSlerpTransformEntityData, rotation_duration),
            },
            FieldInfoData {
                name: "OnlyWriteIfModified",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraSlerpTransformEntityData, only_write_if_modified),
            },
            FieldInfoData {
                name: "InTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(CameraSlerpTransformEntityData, in_transform),
            },
        ],
    }),
    array_type: Some(CAMERASLERPTRANSFORMENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CameraSlerpTransformEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERASLERPTRANSFORMENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CAMERASLERPTRANSFORMENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraSlerpTransformEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CameraSlerpTransformEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SpeederCameraTransformerEntityData {
    pub _glacier_base: CameraTransformerEntityData,
    pub follow_target_transform: super::core::LinearTransform,
    pub look_at_target_transform: super::core::LinearTransform,
    pub follow_distance: f32,
    pub follow_distance_max: f32,
    pub follow_distance_change_speed: f32,
    pub follow_height: f32,
    pub speed_control: bool,
    pub ref_max_speed: f32,
    pub follow_distance_curve: super::core::AudioCurve,
    pub follow_distance_max_curve: super::core::AudioCurve,
    pub follow_distance_change_speed_curve: super::core::AudioCurve,
    pub follow_height_curve: super::core::AudioCurve,
    pub convergence_speeds: super::core::Vec3,
    pub look_target_offset: super::core::Vec3,
    pub look_c_o_m_weight: f32,
    pub move_target_flattening: f32,
    pub look_lerp: f32,
    pub momentum: f32,
    pub momentum_per_axis: super::core::Vec3,
    pub damping_per_axis: super::core::Vec3,
    pub reference_up_blend_body: f32,
    pub reference_up_blend_world: f32,
    pub reference_up_blend_camera: f32,
}

pub trait SpeederCameraTransformerEntityDataTrait: CameraTransformerEntityDataTrait {
    fn follow_target_transform(&self) -> &super::core::LinearTransform;
    fn look_at_target_transform(&self) -> &super::core::LinearTransform;
    fn follow_distance(&self) -> &f32;
    fn follow_distance_max(&self) -> &f32;
    fn follow_distance_change_speed(&self) -> &f32;
    fn follow_height(&self) -> &f32;
    fn speed_control(&self) -> &bool;
    fn ref_max_speed(&self) -> &f32;
    fn follow_distance_curve(&self) -> &super::core::AudioCurve;
    fn follow_distance_max_curve(&self) -> &super::core::AudioCurve;
    fn follow_distance_change_speed_curve(&self) -> &super::core::AudioCurve;
    fn follow_height_curve(&self) -> &super::core::AudioCurve;
    fn convergence_speeds(&self) -> &super::core::Vec3;
    fn look_target_offset(&self) -> &super::core::Vec3;
    fn look_c_o_m_weight(&self) -> &f32;
    fn move_target_flattening(&self) -> &f32;
    fn look_lerp(&self) -> &f32;
    fn momentum(&self) -> &f32;
    fn momentum_per_axis(&self) -> &super::core::Vec3;
    fn damping_per_axis(&self) -> &super::core::Vec3;
    fn reference_up_blend_body(&self) -> &f32;
    fn reference_up_blend_world(&self) -> &f32;
    fn reference_up_blend_camera(&self) -> &f32;
}

impl SpeederCameraTransformerEntityDataTrait for SpeederCameraTransformerEntityData {
    fn follow_target_transform(&self) -> &super::core::LinearTransform {
        &self.follow_target_transform
    }
    fn look_at_target_transform(&self) -> &super::core::LinearTransform {
        &self.look_at_target_transform
    }
    fn follow_distance(&self) -> &f32 {
        &self.follow_distance
    }
    fn follow_distance_max(&self) -> &f32 {
        &self.follow_distance_max
    }
    fn follow_distance_change_speed(&self) -> &f32 {
        &self.follow_distance_change_speed
    }
    fn follow_height(&self) -> &f32 {
        &self.follow_height
    }
    fn speed_control(&self) -> &bool {
        &self.speed_control
    }
    fn ref_max_speed(&self) -> &f32 {
        &self.ref_max_speed
    }
    fn follow_distance_curve(&self) -> &super::core::AudioCurve {
        &self.follow_distance_curve
    }
    fn follow_distance_max_curve(&self) -> &super::core::AudioCurve {
        &self.follow_distance_max_curve
    }
    fn follow_distance_change_speed_curve(&self) -> &super::core::AudioCurve {
        &self.follow_distance_change_speed_curve
    }
    fn follow_height_curve(&self) -> &super::core::AudioCurve {
        &self.follow_height_curve
    }
    fn convergence_speeds(&self) -> &super::core::Vec3 {
        &self.convergence_speeds
    }
    fn look_target_offset(&self) -> &super::core::Vec3 {
        &self.look_target_offset
    }
    fn look_c_o_m_weight(&self) -> &f32 {
        &self.look_c_o_m_weight
    }
    fn move_target_flattening(&self) -> &f32 {
        &self.move_target_flattening
    }
    fn look_lerp(&self) -> &f32 {
        &self.look_lerp
    }
    fn momentum(&self) -> &f32 {
        &self.momentum
    }
    fn momentum_per_axis(&self) -> &super::core::Vec3 {
        &self.momentum_per_axis
    }
    fn damping_per_axis(&self) -> &super::core::Vec3 {
        &self.damping_per_axis
    }
    fn reference_up_blend_body(&self) -> &f32 {
        &self.reference_up_blend_body
    }
    fn reference_up_blend_world(&self) -> &f32 {
        &self.reference_up_blend_world
    }
    fn reference_up_blend_camera(&self) -> &f32 {
        &self.reference_up_blend_camera
    }
}

impl CameraTransformerEntityDataTrait for SpeederCameraTransformerEntityData {
    fn update_pass(&self) -> &CameraTransformerUpdatePass {
        self._glacier_base.update_pass()
    }
    fn camera_transformer_update_priority(&self) -> &i32 {
        self._glacier_base.camera_transformer_update_priority()
    }
    fn active(&self) -> &bool {
        self._glacier_base.active()
    }
}

impl super::entity::EntityDataTrait for SpeederCameraTransformerEntityData {
}

impl super::entity::GameObjectDataTrait for SpeederCameraTransformerEntityData {
}

impl super::core::DataBusPeerTrait for SpeederCameraTransformerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for SpeederCameraTransformerEntityData {
}

impl super::core::DataContainerTrait for SpeederCameraTransformerEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SPEEDERCAMERATRANSFORMERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpeederCameraTransformerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CAMERATRANSFORMERENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SpeederCameraTransformerEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "FollowTargetTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(SpeederCameraTransformerEntityData, follow_target_transform),
            },
            FieldInfoData {
                name: "LookAtTargetTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(SpeederCameraTransformerEntityData, look_at_target_transform),
            },
            FieldInfoData {
                name: "FollowDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpeederCameraTransformerEntityData, follow_distance),
            },
            FieldInfoData {
                name: "FollowDistanceMax",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpeederCameraTransformerEntityData, follow_distance_max),
            },
            FieldInfoData {
                name: "FollowDistanceChangeSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpeederCameraTransformerEntityData, follow_distance_change_speed),
            },
            FieldInfoData {
                name: "FollowHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpeederCameraTransformerEntityData, follow_height),
            },
            FieldInfoData {
                name: "SpeedControl",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SpeederCameraTransformerEntityData, speed_control),
            },
            FieldInfoData {
                name: "RefMaxSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpeederCameraTransformerEntityData, ref_max_speed),
            },
            FieldInfoData {
                name: "FollowDistanceCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioCurve",
                rust_offset: offset_of!(SpeederCameraTransformerEntityData, follow_distance_curve),
            },
            FieldInfoData {
                name: "FollowDistanceMaxCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioCurve",
                rust_offset: offset_of!(SpeederCameraTransformerEntityData, follow_distance_max_curve),
            },
            FieldInfoData {
                name: "FollowDistanceChangeSpeedCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioCurve",
                rust_offset: offset_of!(SpeederCameraTransformerEntityData, follow_distance_change_speed_curve),
            },
            FieldInfoData {
                name: "FollowHeightCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioCurve",
                rust_offset: offset_of!(SpeederCameraTransformerEntityData, follow_height_curve),
            },
            FieldInfoData {
                name: "ConvergenceSpeeds",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SpeederCameraTransformerEntityData, convergence_speeds),
            },
            FieldInfoData {
                name: "LookTargetOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SpeederCameraTransformerEntityData, look_target_offset),
            },
            FieldInfoData {
                name: "LookCOMWeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpeederCameraTransformerEntityData, look_c_o_m_weight),
            },
            FieldInfoData {
                name: "MoveTargetFlattening",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpeederCameraTransformerEntityData, move_target_flattening),
            },
            FieldInfoData {
                name: "LookLerp",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpeederCameraTransformerEntityData, look_lerp),
            },
            FieldInfoData {
                name: "Momentum",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpeederCameraTransformerEntityData, momentum),
            },
            FieldInfoData {
                name: "MomentumPerAxis",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SpeederCameraTransformerEntityData, momentum_per_axis),
            },
            FieldInfoData {
                name: "DampingPerAxis",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SpeederCameraTransformerEntityData, damping_per_axis),
            },
            FieldInfoData {
                name: "ReferenceUpBlendBody",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpeederCameraTransformerEntityData, reference_up_blend_body),
            },
            FieldInfoData {
                name: "ReferenceUpBlendWorld",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpeederCameraTransformerEntityData, reference_up_blend_world),
            },
            FieldInfoData {
                name: "ReferenceUpBlendCamera",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpeederCameraTransformerEntityData, reference_up_blend_camera),
            },
        ],
    }),
    array_type: Some(SPEEDERCAMERATRANSFORMERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SpeederCameraTransformerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SPEEDERCAMERATRANSFORMERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SPEEDERCAMERATRANSFORMERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpeederCameraTransformerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("SpeederCameraTransformerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VelocityRedirectCameraTransformerEntityData {
    pub _glacier_base: CameraTransformerEntityData,
    pub in_transform: super::core::LinearTransform,
    pub world_lin_vel: super::core::Vec3,
    pub world_ang_vel: super::core::Vec3,
    pub redirect_data: Vec<RedirectData>,
    pub lin_speed_scale_curve: super::core::AudioCurve,
}

pub trait VelocityRedirectCameraTransformerEntityDataTrait: CameraTransformerEntityDataTrait {
    fn in_transform(&self) -> &super::core::LinearTransform;
    fn world_lin_vel(&self) -> &super::core::Vec3;
    fn world_ang_vel(&self) -> &super::core::Vec3;
    fn redirect_data(&self) -> &Vec<RedirectData>;
    fn lin_speed_scale_curve(&self) -> &super::core::AudioCurve;
}

impl VelocityRedirectCameraTransformerEntityDataTrait for VelocityRedirectCameraTransformerEntityData {
    fn in_transform(&self) -> &super::core::LinearTransform {
        &self.in_transform
    }
    fn world_lin_vel(&self) -> &super::core::Vec3 {
        &self.world_lin_vel
    }
    fn world_ang_vel(&self) -> &super::core::Vec3 {
        &self.world_ang_vel
    }
    fn redirect_data(&self) -> &Vec<RedirectData> {
        &self.redirect_data
    }
    fn lin_speed_scale_curve(&self) -> &super::core::AudioCurve {
        &self.lin_speed_scale_curve
    }
}

impl CameraTransformerEntityDataTrait for VelocityRedirectCameraTransformerEntityData {
    fn update_pass(&self) -> &CameraTransformerUpdatePass {
        self._glacier_base.update_pass()
    }
    fn camera_transformer_update_priority(&self) -> &i32 {
        self._glacier_base.camera_transformer_update_priority()
    }
    fn active(&self) -> &bool {
        self._glacier_base.active()
    }
}

impl super::entity::EntityDataTrait for VelocityRedirectCameraTransformerEntityData {
}

impl super::entity::GameObjectDataTrait for VelocityRedirectCameraTransformerEntityData {
}

impl super::core::DataBusPeerTrait for VelocityRedirectCameraTransformerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for VelocityRedirectCameraTransformerEntityData {
}

impl super::core::DataContainerTrait for VelocityRedirectCameraTransformerEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static VELOCITYREDIRECTCAMERATRANSFORMERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VelocityRedirectCameraTransformerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CAMERATRANSFORMERENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VelocityRedirectCameraTransformerEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "InTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(VelocityRedirectCameraTransformerEntityData, in_transform),
            },
            FieldInfoData {
                name: "WorldLinVel",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(VelocityRedirectCameraTransformerEntityData, world_lin_vel),
            },
            FieldInfoData {
                name: "WorldAngVel",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(VelocityRedirectCameraTransformerEntityData, world_ang_vel),
            },
            FieldInfoData {
                name: "RedirectData",
                flags: MemberInfoFlags::new(144),
                field_type: "RedirectData-Array",
                rust_offset: offset_of!(VelocityRedirectCameraTransformerEntityData, redirect_data),
            },
            FieldInfoData {
                name: "LinSpeedScaleCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioCurve",
                rust_offset: offset_of!(VelocityRedirectCameraTransformerEntityData, lin_speed_scale_curve),
            },
        ],
    }),
    array_type: Some(VELOCITYREDIRECTCAMERATRANSFORMERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VelocityRedirectCameraTransformerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VELOCITYREDIRECTCAMERATRANSFORMERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VELOCITYREDIRECTCAMERATRANSFORMERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VelocityRedirectCameraTransformerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("VelocityRedirectCameraTransformerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RedirectData {
    pub source_velocity: QuantityAxisPair,
    pub destination_offset: QuantityAxisPair,
    pub inertia: f32,
    pub conversion_rate: f32,
}

pub trait RedirectDataTrait: TypeObject {
    fn source_velocity(&self) -> &QuantityAxisPair;
    fn destination_offset(&self) -> &QuantityAxisPair;
    fn inertia(&self) -> &f32;
    fn conversion_rate(&self) -> &f32;
}

impl RedirectDataTrait for RedirectData {
    fn source_velocity(&self) -> &QuantityAxisPair {
        &self.source_velocity
    }
    fn destination_offset(&self) -> &QuantityAxisPair {
        &self.destination_offset
    }
    fn inertia(&self) -> &f32 {
        &self.inertia
    }
    fn conversion_rate(&self) -> &f32 {
        &self.conversion_rate
    }
}

pub static REDIRECTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RedirectData",
    flags: MemberInfoFlags::new(36937),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RedirectData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SourceVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: "QuantityAxisPair",
                rust_offset: offset_of!(RedirectData, source_velocity),
            },
            FieldInfoData {
                name: "DestinationOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "QuantityAxisPair",
                rust_offset: offset_of!(RedirectData, destination_offset),
            },
            FieldInfoData {
                name: "Inertia",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RedirectData, inertia),
            },
            FieldInfoData {
                name: "ConversionRate",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RedirectData, conversion_rate),
            },
        ],
    }),
    array_type: Some(REDIRECTDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for RedirectData {
    fn type_info(&self) -> &'static TypeInfo {
        REDIRECTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static REDIRECTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RedirectData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("RedirectData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct QuantityAxisPair {
    pub quantity: PhysicsQuantity,
    pub axis: PhysicsActionAxis,
}

pub trait QuantityAxisPairTrait: TypeObject {
    fn quantity(&self) -> &PhysicsQuantity;
    fn axis(&self) -> &PhysicsActionAxis;
}

impl QuantityAxisPairTrait for QuantityAxisPair {
    fn quantity(&self) -> &PhysicsQuantity {
        &self.quantity
    }
    fn axis(&self) -> &PhysicsActionAxis {
        &self.axis
    }
}

pub static QUANTITYAXISPAIR_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "QuantityAxisPair",
    flags: MemberInfoFlags::new(36937),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<QuantityAxisPair as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Quantity",
                flags: MemberInfoFlags::new(0),
                field_type: "PhysicsQuantity",
                rust_offset: offset_of!(QuantityAxisPair, quantity),
            },
            FieldInfoData {
                name: "Axis",
                flags: MemberInfoFlags::new(0),
                field_type: "PhysicsActionAxis",
                rust_offset: offset_of!(QuantityAxisPair, axis),
            },
        ],
    }),
    array_type: Some(QUANTITYAXISPAIR_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for QuantityAxisPair {
    fn type_info(&self) -> &'static TypeInfo {
        QUANTITYAXISPAIR_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static QUANTITYAXISPAIR_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "QuantityAxisPair-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("QuantityAxisPair"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ThirdPersonCameraTransformerEntityData {
    pub _glacier_base: CameraTransformerEntityData,
    pub realm: super::core::Realm,
    pub in_roll_input: f32,
    pub in_yaw_input: f32,
    pub in_pitch_input: f32,
    pub pitch_min_angle: f32,
    pub pitch_max_angle: f32,
    pub pitch_default_angle: f32,
    pub pitch_cushion_angle: f32,
    pub pitch_cushion_softness: f32,
    pub yaw_min_angle: f32,
    pub yaw_max_angle: f32,
    pub yaw_default_angle: f32,
    pub yaw_cushion_angle: f32,
    pub yaw_cushion_softness: f32,
    pub roll_max_angle: f32,
    pub pitch_acc_inertia: ThirdPersonCamInertiaValues,
    pub yaw_acc_inertia: ThirdPersonCamInertiaValues,
    pub roll_acc_inertia: ThirdPersonCamInertiaValues,
    pub rot_speed: f32,
    pub rotation_offset: super::core::LinearTransform,
    pub override_yaw: f32,
    pub override_pitch: f32,
}

pub trait ThirdPersonCameraTransformerEntityDataTrait: CameraTransformerEntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn in_roll_input(&self) -> &f32;
    fn in_yaw_input(&self) -> &f32;
    fn in_pitch_input(&self) -> &f32;
    fn pitch_min_angle(&self) -> &f32;
    fn pitch_max_angle(&self) -> &f32;
    fn pitch_default_angle(&self) -> &f32;
    fn pitch_cushion_angle(&self) -> &f32;
    fn pitch_cushion_softness(&self) -> &f32;
    fn yaw_min_angle(&self) -> &f32;
    fn yaw_max_angle(&self) -> &f32;
    fn yaw_default_angle(&self) -> &f32;
    fn yaw_cushion_angle(&self) -> &f32;
    fn yaw_cushion_softness(&self) -> &f32;
    fn roll_max_angle(&self) -> &f32;
    fn pitch_acc_inertia(&self) -> &ThirdPersonCamInertiaValues;
    fn yaw_acc_inertia(&self) -> &ThirdPersonCamInertiaValues;
    fn roll_acc_inertia(&self) -> &ThirdPersonCamInertiaValues;
    fn rot_speed(&self) -> &f32;
    fn rotation_offset(&self) -> &super::core::LinearTransform;
    fn override_yaw(&self) -> &f32;
    fn override_pitch(&self) -> &f32;
}

impl ThirdPersonCameraTransformerEntityDataTrait for ThirdPersonCameraTransformerEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn in_roll_input(&self) -> &f32 {
        &self.in_roll_input
    }
    fn in_yaw_input(&self) -> &f32 {
        &self.in_yaw_input
    }
    fn in_pitch_input(&self) -> &f32 {
        &self.in_pitch_input
    }
    fn pitch_min_angle(&self) -> &f32 {
        &self.pitch_min_angle
    }
    fn pitch_max_angle(&self) -> &f32 {
        &self.pitch_max_angle
    }
    fn pitch_default_angle(&self) -> &f32 {
        &self.pitch_default_angle
    }
    fn pitch_cushion_angle(&self) -> &f32 {
        &self.pitch_cushion_angle
    }
    fn pitch_cushion_softness(&self) -> &f32 {
        &self.pitch_cushion_softness
    }
    fn yaw_min_angle(&self) -> &f32 {
        &self.yaw_min_angle
    }
    fn yaw_max_angle(&self) -> &f32 {
        &self.yaw_max_angle
    }
    fn yaw_default_angle(&self) -> &f32 {
        &self.yaw_default_angle
    }
    fn yaw_cushion_angle(&self) -> &f32 {
        &self.yaw_cushion_angle
    }
    fn yaw_cushion_softness(&self) -> &f32 {
        &self.yaw_cushion_softness
    }
    fn roll_max_angle(&self) -> &f32 {
        &self.roll_max_angle
    }
    fn pitch_acc_inertia(&self) -> &ThirdPersonCamInertiaValues {
        &self.pitch_acc_inertia
    }
    fn yaw_acc_inertia(&self) -> &ThirdPersonCamInertiaValues {
        &self.yaw_acc_inertia
    }
    fn roll_acc_inertia(&self) -> &ThirdPersonCamInertiaValues {
        &self.roll_acc_inertia
    }
    fn rot_speed(&self) -> &f32 {
        &self.rot_speed
    }
    fn rotation_offset(&self) -> &super::core::LinearTransform {
        &self.rotation_offset
    }
    fn override_yaw(&self) -> &f32 {
        &self.override_yaw
    }
    fn override_pitch(&self) -> &f32 {
        &self.override_pitch
    }
}

impl CameraTransformerEntityDataTrait for ThirdPersonCameraTransformerEntityData {
    fn update_pass(&self) -> &CameraTransformerUpdatePass {
        self._glacier_base.update_pass()
    }
    fn camera_transformer_update_priority(&self) -> &i32 {
        self._glacier_base.camera_transformer_update_priority()
    }
    fn active(&self) -> &bool {
        self._glacier_base.active()
    }
}

impl super::entity::EntityDataTrait for ThirdPersonCameraTransformerEntityData {
}

impl super::entity::GameObjectDataTrait for ThirdPersonCameraTransformerEntityData {
}

impl super::core::DataBusPeerTrait for ThirdPersonCameraTransformerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for ThirdPersonCameraTransformerEntityData {
}

impl super::core::DataContainerTrait for ThirdPersonCameraTransformerEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static THIRDPERSONCAMERATRANSFORMERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ThirdPersonCameraTransformerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CAMERATRANSFORMERENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ThirdPersonCameraTransformerEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(ThirdPersonCameraTransformerEntityData, realm),
            },
            FieldInfoData {
                name: "InRollInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ThirdPersonCameraTransformerEntityData, in_roll_input),
            },
            FieldInfoData {
                name: "InYawInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ThirdPersonCameraTransformerEntityData, in_yaw_input),
            },
            FieldInfoData {
                name: "InPitchInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ThirdPersonCameraTransformerEntityData, in_pitch_input),
            },
            FieldInfoData {
                name: "PitchMinAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ThirdPersonCameraTransformerEntityData, pitch_min_angle),
            },
            FieldInfoData {
                name: "PitchMaxAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ThirdPersonCameraTransformerEntityData, pitch_max_angle),
            },
            FieldInfoData {
                name: "PitchDefaultAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ThirdPersonCameraTransformerEntityData, pitch_default_angle),
            },
            FieldInfoData {
                name: "PitchCushionAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ThirdPersonCameraTransformerEntityData, pitch_cushion_angle),
            },
            FieldInfoData {
                name: "PitchCushionSoftness",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ThirdPersonCameraTransformerEntityData, pitch_cushion_softness),
            },
            FieldInfoData {
                name: "YawMinAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ThirdPersonCameraTransformerEntityData, yaw_min_angle),
            },
            FieldInfoData {
                name: "YawMaxAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ThirdPersonCameraTransformerEntityData, yaw_max_angle),
            },
            FieldInfoData {
                name: "YawDefaultAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ThirdPersonCameraTransformerEntityData, yaw_default_angle),
            },
            FieldInfoData {
                name: "YawCushionAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ThirdPersonCameraTransformerEntityData, yaw_cushion_angle),
            },
            FieldInfoData {
                name: "YawCushionSoftness",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ThirdPersonCameraTransformerEntityData, yaw_cushion_softness),
            },
            FieldInfoData {
                name: "RollMaxAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ThirdPersonCameraTransformerEntityData, roll_max_angle),
            },
            FieldInfoData {
                name: "PitchAccInertia",
                flags: MemberInfoFlags::new(0),
                field_type: "ThirdPersonCamInertiaValues",
                rust_offset: offset_of!(ThirdPersonCameraTransformerEntityData, pitch_acc_inertia),
            },
            FieldInfoData {
                name: "YawAccInertia",
                flags: MemberInfoFlags::new(0),
                field_type: "ThirdPersonCamInertiaValues",
                rust_offset: offset_of!(ThirdPersonCameraTransformerEntityData, yaw_acc_inertia),
            },
            FieldInfoData {
                name: "RollAccInertia",
                flags: MemberInfoFlags::new(0),
                field_type: "ThirdPersonCamInertiaValues",
                rust_offset: offset_of!(ThirdPersonCameraTransformerEntityData, roll_acc_inertia),
            },
            FieldInfoData {
                name: "RotSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ThirdPersonCameraTransformerEntityData, rot_speed),
            },
            FieldInfoData {
                name: "RotationOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(ThirdPersonCameraTransformerEntityData, rotation_offset),
            },
            FieldInfoData {
                name: "OverrideYaw",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ThirdPersonCameraTransformerEntityData, override_yaw),
            },
            FieldInfoData {
                name: "OverridePitch",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ThirdPersonCameraTransformerEntityData, override_pitch),
            },
        ],
    }),
    array_type: Some(THIRDPERSONCAMERATRANSFORMERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ThirdPersonCameraTransformerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        THIRDPERSONCAMERATRANSFORMERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static THIRDPERSONCAMERATRANSFORMERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ThirdPersonCameraTransformerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("ThirdPersonCameraTransformerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ArmCollisionCameraTransformerEntityData {
    pub _glacier_base: CameraTransformerEntityData,
    pub max_pitch: f32,
    pub enable_soft_collision: bool,
    pub collision_blend_in: f32,
    pub collision_blend_out: f32,
    pub collision_width_padding: f32,
    pub reduce_arm_length_looking_up: bool,
    pub max_reduced_arm_length: f32,
    pub reduce_min_pitch: f32,
    pub reduce_max_pitch: f32,
    pub camera_joint_transform: super::core::LinearTransform,
    pub camera_arm_length: f32,
    pub use_look_at: bool,
}

pub trait ArmCollisionCameraTransformerEntityDataTrait: CameraTransformerEntityDataTrait {
    fn max_pitch(&self) -> &f32;
    fn enable_soft_collision(&self) -> &bool;
    fn collision_blend_in(&self) -> &f32;
    fn collision_blend_out(&self) -> &f32;
    fn collision_width_padding(&self) -> &f32;
    fn reduce_arm_length_looking_up(&self) -> &bool;
    fn max_reduced_arm_length(&self) -> &f32;
    fn reduce_min_pitch(&self) -> &f32;
    fn reduce_max_pitch(&self) -> &f32;
    fn camera_joint_transform(&self) -> &super::core::LinearTransform;
    fn camera_arm_length(&self) -> &f32;
    fn use_look_at(&self) -> &bool;
}

impl ArmCollisionCameraTransformerEntityDataTrait for ArmCollisionCameraTransformerEntityData {
    fn max_pitch(&self) -> &f32 {
        &self.max_pitch
    }
    fn enable_soft_collision(&self) -> &bool {
        &self.enable_soft_collision
    }
    fn collision_blend_in(&self) -> &f32 {
        &self.collision_blend_in
    }
    fn collision_blend_out(&self) -> &f32 {
        &self.collision_blend_out
    }
    fn collision_width_padding(&self) -> &f32 {
        &self.collision_width_padding
    }
    fn reduce_arm_length_looking_up(&self) -> &bool {
        &self.reduce_arm_length_looking_up
    }
    fn max_reduced_arm_length(&self) -> &f32 {
        &self.max_reduced_arm_length
    }
    fn reduce_min_pitch(&self) -> &f32 {
        &self.reduce_min_pitch
    }
    fn reduce_max_pitch(&self) -> &f32 {
        &self.reduce_max_pitch
    }
    fn camera_joint_transform(&self) -> &super::core::LinearTransform {
        &self.camera_joint_transform
    }
    fn camera_arm_length(&self) -> &f32 {
        &self.camera_arm_length
    }
    fn use_look_at(&self) -> &bool {
        &self.use_look_at
    }
}

impl CameraTransformerEntityDataTrait for ArmCollisionCameraTransformerEntityData {
    fn update_pass(&self) -> &CameraTransformerUpdatePass {
        self._glacier_base.update_pass()
    }
    fn camera_transformer_update_priority(&self) -> &i32 {
        self._glacier_base.camera_transformer_update_priority()
    }
    fn active(&self) -> &bool {
        self._glacier_base.active()
    }
}

impl super::entity::EntityDataTrait for ArmCollisionCameraTransformerEntityData {
}

impl super::entity::GameObjectDataTrait for ArmCollisionCameraTransformerEntityData {
}

impl super::core::DataBusPeerTrait for ArmCollisionCameraTransformerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for ArmCollisionCameraTransformerEntityData {
}

impl super::core::DataContainerTrait for ArmCollisionCameraTransformerEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static ARMCOLLISIONCAMERATRANSFORMERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ArmCollisionCameraTransformerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CAMERATRANSFORMERENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ArmCollisionCameraTransformerEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MaxPitch",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ArmCollisionCameraTransformerEntityData, max_pitch),
            },
            FieldInfoData {
                name: "EnableSoftCollision",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ArmCollisionCameraTransformerEntityData, enable_soft_collision),
            },
            FieldInfoData {
                name: "CollisionBlendIn",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ArmCollisionCameraTransformerEntityData, collision_blend_in),
            },
            FieldInfoData {
                name: "CollisionBlendOut",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ArmCollisionCameraTransformerEntityData, collision_blend_out),
            },
            FieldInfoData {
                name: "CollisionWidthPadding",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ArmCollisionCameraTransformerEntityData, collision_width_padding),
            },
            FieldInfoData {
                name: "ReduceArmLengthLookingUp",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ArmCollisionCameraTransformerEntityData, reduce_arm_length_looking_up),
            },
            FieldInfoData {
                name: "MaxReducedArmLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ArmCollisionCameraTransformerEntityData, max_reduced_arm_length),
            },
            FieldInfoData {
                name: "ReduceMinPitch",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ArmCollisionCameraTransformerEntityData, reduce_min_pitch),
            },
            FieldInfoData {
                name: "ReduceMaxPitch",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ArmCollisionCameraTransformerEntityData, reduce_max_pitch),
            },
            FieldInfoData {
                name: "CameraJointTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(ArmCollisionCameraTransformerEntityData, camera_joint_transform),
            },
            FieldInfoData {
                name: "CameraArmLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ArmCollisionCameraTransformerEntityData, camera_arm_length),
            },
            FieldInfoData {
                name: "UseLookAt",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ArmCollisionCameraTransformerEntityData, use_look_at),
            },
        ],
    }),
    array_type: Some(ARMCOLLISIONCAMERATRANSFORMERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ArmCollisionCameraTransformerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        ARMCOLLISIONCAMERATRANSFORMERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ARMCOLLISIONCAMERATRANSFORMERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ArmCollisionCameraTransformerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("ArmCollisionCameraTransformerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ThirdPersonCamInertiaValues {
    pub input_inertia: f32,
    pub no_input_inertia: f32,
}

pub trait ThirdPersonCamInertiaValuesTrait: TypeObject {
    fn input_inertia(&self) -> &f32;
    fn no_input_inertia(&self) -> &f32;
}

impl ThirdPersonCamInertiaValuesTrait for ThirdPersonCamInertiaValues {
    fn input_inertia(&self) -> &f32 {
        &self.input_inertia
    }
    fn no_input_inertia(&self) -> &f32 {
        &self.no_input_inertia
    }
}

pub static THIRDPERSONCAMINERTIAVALUES_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ThirdPersonCamInertiaValues",
    flags: MemberInfoFlags::new(36937),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ThirdPersonCamInertiaValues as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "InputInertia",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ThirdPersonCamInertiaValues, input_inertia),
            },
            FieldInfoData {
                name: "NoInputInertia",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ThirdPersonCamInertiaValues, no_input_inertia),
            },
        ],
    }),
    array_type: Some(THIRDPERSONCAMINERTIAVALUES_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for ThirdPersonCamInertiaValues {
    fn type_info(&self) -> &'static TypeInfo {
        THIRDPERSONCAMINERTIAVALUES_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static THIRDPERSONCAMINERTIAVALUES_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ThirdPersonCamInertiaValues-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("ThirdPersonCamInertiaValues"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct YawOnlyCameraTransformerEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub in_transform: super::core::LinearTransform,
}

pub trait YawOnlyCameraTransformerEntityDataTrait: super::entity::EntityDataTrait {
    fn in_transform(&self) -> &super::core::LinearTransform;
}

impl YawOnlyCameraTransformerEntityDataTrait for YawOnlyCameraTransformerEntityData {
    fn in_transform(&self) -> &super::core::LinearTransform {
        &self.in_transform
    }
}

impl super::entity::EntityDataTrait for YawOnlyCameraTransformerEntityData {
}

impl super::entity::GameObjectDataTrait for YawOnlyCameraTransformerEntityData {
}

impl super::core::DataBusPeerTrait for YawOnlyCameraTransformerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for YawOnlyCameraTransformerEntityData {
}

impl super::core::DataContainerTrait for YawOnlyCameraTransformerEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static YAWONLYCAMERATRANSFORMERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "YawOnlyCameraTransformerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<YawOnlyCameraTransformerEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "InTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(YawOnlyCameraTransformerEntityData, in_transform),
            },
        ],
    }),
    array_type: Some(YAWONLYCAMERATRANSFORMERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for YawOnlyCameraTransformerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        YAWONLYCAMERATRANSFORMERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static YAWONLYCAMERATRANSFORMERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "YawOnlyCameraTransformerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("YawOnlyCameraTransformerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct StarfighterCameraTransformerEntityData {
    pub _glacier_base: CameraTransformerEntityData,
    pub in_transform: super::core::LinearTransform,
    pub cam_lin_offset: super::core::Vec3,
    pub cam_ang_offset: super::core::Vec3,
    pub look_ahead_lin: super::core::Vec3,
    pub look_ahead_ang: super::core::Vec3,
    pub look_ahead_ang_inertia: f32,
    pub look_ahead_lin_inertia: f32,
}

pub trait StarfighterCameraTransformerEntityDataTrait: CameraTransformerEntityDataTrait {
    fn in_transform(&self) -> &super::core::LinearTransform;
    fn cam_lin_offset(&self) -> &super::core::Vec3;
    fn cam_ang_offset(&self) -> &super::core::Vec3;
    fn look_ahead_lin(&self) -> &super::core::Vec3;
    fn look_ahead_ang(&self) -> &super::core::Vec3;
    fn look_ahead_ang_inertia(&self) -> &f32;
    fn look_ahead_lin_inertia(&self) -> &f32;
}

impl StarfighterCameraTransformerEntityDataTrait for StarfighterCameraTransformerEntityData {
    fn in_transform(&self) -> &super::core::LinearTransform {
        &self.in_transform
    }
    fn cam_lin_offset(&self) -> &super::core::Vec3 {
        &self.cam_lin_offset
    }
    fn cam_ang_offset(&self) -> &super::core::Vec3 {
        &self.cam_ang_offset
    }
    fn look_ahead_lin(&self) -> &super::core::Vec3 {
        &self.look_ahead_lin
    }
    fn look_ahead_ang(&self) -> &super::core::Vec3 {
        &self.look_ahead_ang
    }
    fn look_ahead_ang_inertia(&self) -> &f32 {
        &self.look_ahead_ang_inertia
    }
    fn look_ahead_lin_inertia(&self) -> &f32 {
        &self.look_ahead_lin_inertia
    }
}

impl CameraTransformerEntityDataTrait for StarfighterCameraTransformerEntityData {
    fn update_pass(&self) -> &CameraTransformerUpdatePass {
        self._glacier_base.update_pass()
    }
    fn camera_transformer_update_priority(&self) -> &i32 {
        self._glacier_base.camera_transformer_update_priority()
    }
    fn active(&self) -> &bool {
        self._glacier_base.active()
    }
}

impl super::entity::EntityDataTrait for StarfighterCameraTransformerEntityData {
}

impl super::entity::GameObjectDataTrait for StarfighterCameraTransformerEntityData {
}

impl super::core::DataBusPeerTrait for StarfighterCameraTransformerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for StarfighterCameraTransformerEntityData {
}

impl super::core::DataContainerTrait for StarfighterCameraTransformerEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static STARFIGHTERCAMERATRANSFORMERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StarfighterCameraTransformerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CAMERATRANSFORMERENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StarfighterCameraTransformerEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "InTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(StarfighterCameraTransformerEntityData, in_transform),
            },
            FieldInfoData {
                name: "CamLinOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(StarfighterCameraTransformerEntityData, cam_lin_offset),
            },
            FieldInfoData {
                name: "CamAngOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(StarfighterCameraTransformerEntityData, cam_ang_offset),
            },
            FieldInfoData {
                name: "LookAheadLin",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(StarfighterCameraTransformerEntityData, look_ahead_lin),
            },
            FieldInfoData {
                name: "LookAheadAng",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(StarfighterCameraTransformerEntityData, look_ahead_ang),
            },
            FieldInfoData {
                name: "LookAheadAngInertia",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterCameraTransformerEntityData, look_ahead_ang_inertia),
            },
            FieldInfoData {
                name: "LookAheadLinInertia",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterCameraTransformerEntityData, look_ahead_lin_inertia),
            },
        ],
    }),
    array_type: Some(STARFIGHTERCAMERATRANSFORMERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for StarfighterCameraTransformerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        STARFIGHTERCAMERATRANSFORMERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static STARFIGHTERCAMERATRANSFORMERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StarfighterCameraTransformerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("StarfighterCameraTransformerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CameraInertiaTransformEntityData {
    pub _glacier_base: CameraTransformerEntityData,
    pub in_transform: super::core::LinearTransform,
    pub lin_inertia_x: f32,
    pub lin_inertia_y: f32,
    pub lin_inertia_z: f32,
    pub ang_inertia: f32,
    pub is_world_space_transform: bool,
}

pub trait CameraInertiaTransformEntityDataTrait: CameraTransformerEntityDataTrait {
    fn in_transform(&self) -> &super::core::LinearTransform;
    fn lin_inertia_x(&self) -> &f32;
    fn lin_inertia_y(&self) -> &f32;
    fn lin_inertia_z(&self) -> &f32;
    fn ang_inertia(&self) -> &f32;
    fn is_world_space_transform(&self) -> &bool;
}

impl CameraInertiaTransformEntityDataTrait for CameraInertiaTransformEntityData {
    fn in_transform(&self) -> &super::core::LinearTransform {
        &self.in_transform
    }
    fn lin_inertia_x(&self) -> &f32 {
        &self.lin_inertia_x
    }
    fn lin_inertia_y(&self) -> &f32 {
        &self.lin_inertia_y
    }
    fn lin_inertia_z(&self) -> &f32 {
        &self.lin_inertia_z
    }
    fn ang_inertia(&self) -> &f32 {
        &self.ang_inertia
    }
    fn is_world_space_transform(&self) -> &bool {
        &self.is_world_space_transform
    }
}

impl CameraTransformerEntityDataTrait for CameraInertiaTransformEntityData {
    fn update_pass(&self) -> &CameraTransformerUpdatePass {
        self._glacier_base.update_pass()
    }
    fn camera_transformer_update_priority(&self) -> &i32 {
        self._glacier_base.camera_transformer_update_priority()
    }
    fn active(&self) -> &bool {
        self._glacier_base.active()
    }
}

impl super::entity::EntityDataTrait for CameraInertiaTransformEntityData {
}

impl super::entity::GameObjectDataTrait for CameraInertiaTransformEntityData {
}

impl super::core::DataBusPeerTrait for CameraInertiaTransformEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for CameraInertiaTransformEntityData {
}

impl super::core::DataContainerTrait for CameraInertiaTransformEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CAMERAINERTIATRANSFORMENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraInertiaTransformEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CAMERATRANSFORMERENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraInertiaTransformEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "InTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(CameraInertiaTransformEntityData, in_transform),
            },
            FieldInfoData {
                name: "LinInertiaX",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraInertiaTransformEntityData, lin_inertia_x),
            },
            FieldInfoData {
                name: "LinInertiaY",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraInertiaTransformEntityData, lin_inertia_y),
            },
            FieldInfoData {
                name: "LinInertiaZ",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraInertiaTransformEntityData, lin_inertia_z),
            },
            FieldInfoData {
                name: "AngInertia",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraInertiaTransformEntityData, ang_inertia),
            },
            FieldInfoData {
                name: "IsWorldSpaceTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraInertiaTransformEntityData, is_world_space_transform),
            },
        ],
    }),
    array_type: Some(CAMERAINERTIATRANSFORMENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CameraInertiaTransformEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERAINERTIATRANSFORMENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CAMERAINERTIATRANSFORMENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraInertiaTransformEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CameraInertiaTransformEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CameraTransformerEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub update_pass: CameraTransformerUpdatePass,
    pub camera_transformer_update_priority: i32,
    pub active: bool,
}

pub trait CameraTransformerEntityDataTrait: super::entity::EntityDataTrait {
    fn update_pass(&self) -> &CameraTransformerUpdatePass;
    fn camera_transformer_update_priority(&self) -> &i32;
    fn active(&self) -> &bool;
}

impl CameraTransformerEntityDataTrait for CameraTransformerEntityData {
    fn update_pass(&self) -> &CameraTransformerUpdatePass {
        &self.update_pass
    }
    fn camera_transformer_update_priority(&self) -> &i32 {
        &self.camera_transformer_update_priority
    }
    fn active(&self) -> &bool {
        &self.active
    }
}

impl super::entity::EntityDataTrait for CameraTransformerEntityData {
}

impl super::entity::GameObjectDataTrait for CameraTransformerEntityData {
}

impl super::core::DataBusPeerTrait for CameraTransformerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for CameraTransformerEntityData {
}

impl super::core::DataContainerTrait for CameraTransformerEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CAMERATRANSFORMERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraTransformerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraTransformerEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "UpdatePass",
                flags: MemberInfoFlags::new(0),
                field_type: "CameraTransformerUpdatePass",
                rust_offset: offset_of!(CameraTransformerEntityData, update_pass),
            },
            FieldInfoData {
                name: "CameraTransformerUpdatePriority",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CameraTransformerEntityData, camera_transformer_update_priority),
            },
            FieldInfoData {
                name: "Active",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraTransformerEntityData, active),
            },
        ],
    }),
    array_type: Some(CAMERATRANSFORMERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CameraTransformerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERATRANSFORMERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CAMERATRANSFORMERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraTransformerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CameraTransformerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct HoverCameraConfigEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub camera_offset: super::core::Vec3,
    pub camera_offset_zoomed: super::core::Vec3,
    pub look_ahead_offset_z: f32,
    pub look_ahead_offset_z_zoomed: f32,
    pub look_ahead_extrapolation: f32,
    pub linear_extrapolation: f32,
    pub follow_offset_z: f32,
    pub follow_offset_z_zoomed: f32,
    pub lerp_axis_factor: super::core::Vec3,
    pub lerp_axis_factor_zoomed: super::core::Vec3,
    pub target_upright_lerp: f32,
    pub target_upright_lerp_smoothing: f32,
    pub look_direction_lerp: f32,
    pub look_direction_lerp_zoomed: f32,
    pub pitch: f32,
    pub pitch_zoomed: f32,
    pub crosshair_pitch: f32,
    pub crosshair_pitch_zoomed: f32,
    pub max_allowed_roll_angle_camera_to_target: f32,
    pub camera_to_target_roll_angle_smoothing: f32,
    pub follow_offset_dead_zone: super::core::Vec3,
    pub aiming_vertical_cutoff: f32,
    pub pitch_speed: f32,
    pub pitch_speed_mouse: f32,
    pub pitch_control_deadzone: f32,
    pub pitch_control_deadzone_mouse: f32,
    pub pitch_up_angle: f32,
    pub pitch_down_angle: f32,
    pub sphere_collision_radius: f32,
    pub safe_offset: super::core::Vec3,
    pub collision_lerp_rate: f32,
    pub min_collision_time: f32,
    pub pill_minimum_collision_radius: f32,
    pub pill_maximum_collision_radius: f32,
    pub pill_minimum_collision_length: f32,
}

pub trait HoverCameraConfigEntityDataTrait: super::entity::EntityDataTrait {
    fn camera_offset(&self) -> &super::core::Vec3;
    fn camera_offset_zoomed(&self) -> &super::core::Vec3;
    fn look_ahead_offset_z(&self) -> &f32;
    fn look_ahead_offset_z_zoomed(&self) -> &f32;
    fn look_ahead_extrapolation(&self) -> &f32;
    fn linear_extrapolation(&self) -> &f32;
    fn follow_offset_z(&self) -> &f32;
    fn follow_offset_z_zoomed(&self) -> &f32;
    fn lerp_axis_factor(&self) -> &super::core::Vec3;
    fn lerp_axis_factor_zoomed(&self) -> &super::core::Vec3;
    fn target_upright_lerp(&self) -> &f32;
    fn target_upright_lerp_smoothing(&self) -> &f32;
    fn look_direction_lerp(&self) -> &f32;
    fn look_direction_lerp_zoomed(&self) -> &f32;
    fn pitch(&self) -> &f32;
    fn pitch_zoomed(&self) -> &f32;
    fn crosshair_pitch(&self) -> &f32;
    fn crosshair_pitch_zoomed(&self) -> &f32;
    fn max_allowed_roll_angle_camera_to_target(&self) -> &f32;
    fn camera_to_target_roll_angle_smoothing(&self) -> &f32;
    fn follow_offset_dead_zone(&self) -> &super::core::Vec3;
    fn aiming_vertical_cutoff(&self) -> &f32;
    fn pitch_speed(&self) -> &f32;
    fn pitch_speed_mouse(&self) -> &f32;
    fn pitch_control_deadzone(&self) -> &f32;
    fn pitch_control_deadzone_mouse(&self) -> &f32;
    fn pitch_up_angle(&self) -> &f32;
    fn pitch_down_angle(&self) -> &f32;
    fn sphere_collision_radius(&self) -> &f32;
    fn safe_offset(&self) -> &super::core::Vec3;
    fn collision_lerp_rate(&self) -> &f32;
    fn min_collision_time(&self) -> &f32;
    fn pill_minimum_collision_radius(&self) -> &f32;
    fn pill_maximum_collision_radius(&self) -> &f32;
    fn pill_minimum_collision_length(&self) -> &f32;
}

impl HoverCameraConfigEntityDataTrait for HoverCameraConfigEntityData {
    fn camera_offset(&self) -> &super::core::Vec3 {
        &self.camera_offset
    }
    fn camera_offset_zoomed(&self) -> &super::core::Vec3 {
        &self.camera_offset_zoomed
    }
    fn look_ahead_offset_z(&self) -> &f32 {
        &self.look_ahead_offset_z
    }
    fn look_ahead_offset_z_zoomed(&self) -> &f32 {
        &self.look_ahead_offset_z_zoomed
    }
    fn look_ahead_extrapolation(&self) -> &f32 {
        &self.look_ahead_extrapolation
    }
    fn linear_extrapolation(&self) -> &f32 {
        &self.linear_extrapolation
    }
    fn follow_offset_z(&self) -> &f32 {
        &self.follow_offset_z
    }
    fn follow_offset_z_zoomed(&self) -> &f32 {
        &self.follow_offset_z_zoomed
    }
    fn lerp_axis_factor(&self) -> &super::core::Vec3 {
        &self.lerp_axis_factor
    }
    fn lerp_axis_factor_zoomed(&self) -> &super::core::Vec3 {
        &self.lerp_axis_factor_zoomed
    }
    fn target_upright_lerp(&self) -> &f32 {
        &self.target_upright_lerp
    }
    fn target_upright_lerp_smoothing(&self) -> &f32 {
        &self.target_upright_lerp_smoothing
    }
    fn look_direction_lerp(&self) -> &f32 {
        &self.look_direction_lerp
    }
    fn look_direction_lerp_zoomed(&self) -> &f32 {
        &self.look_direction_lerp_zoomed
    }
    fn pitch(&self) -> &f32 {
        &self.pitch
    }
    fn pitch_zoomed(&self) -> &f32 {
        &self.pitch_zoomed
    }
    fn crosshair_pitch(&self) -> &f32 {
        &self.crosshair_pitch
    }
    fn crosshair_pitch_zoomed(&self) -> &f32 {
        &self.crosshair_pitch_zoomed
    }
    fn max_allowed_roll_angle_camera_to_target(&self) -> &f32 {
        &self.max_allowed_roll_angle_camera_to_target
    }
    fn camera_to_target_roll_angle_smoothing(&self) -> &f32 {
        &self.camera_to_target_roll_angle_smoothing
    }
    fn follow_offset_dead_zone(&self) -> &super::core::Vec3 {
        &self.follow_offset_dead_zone
    }
    fn aiming_vertical_cutoff(&self) -> &f32 {
        &self.aiming_vertical_cutoff
    }
    fn pitch_speed(&self) -> &f32 {
        &self.pitch_speed
    }
    fn pitch_speed_mouse(&self) -> &f32 {
        &self.pitch_speed_mouse
    }
    fn pitch_control_deadzone(&self) -> &f32 {
        &self.pitch_control_deadzone
    }
    fn pitch_control_deadzone_mouse(&self) -> &f32 {
        &self.pitch_control_deadzone_mouse
    }
    fn pitch_up_angle(&self) -> &f32 {
        &self.pitch_up_angle
    }
    fn pitch_down_angle(&self) -> &f32 {
        &self.pitch_down_angle
    }
    fn sphere_collision_radius(&self) -> &f32 {
        &self.sphere_collision_radius
    }
    fn safe_offset(&self) -> &super::core::Vec3 {
        &self.safe_offset
    }
    fn collision_lerp_rate(&self) -> &f32 {
        &self.collision_lerp_rate
    }
    fn min_collision_time(&self) -> &f32 {
        &self.min_collision_time
    }
    fn pill_minimum_collision_radius(&self) -> &f32 {
        &self.pill_minimum_collision_radius
    }
    fn pill_maximum_collision_radius(&self) -> &f32 {
        &self.pill_maximum_collision_radius
    }
    fn pill_minimum_collision_length(&self) -> &f32 {
        &self.pill_minimum_collision_length
    }
}

impl super::entity::EntityDataTrait for HoverCameraConfigEntityData {
}

impl super::entity::GameObjectDataTrait for HoverCameraConfigEntityData {
}

impl super::core::DataBusPeerTrait for HoverCameraConfigEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for HoverCameraConfigEntityData {
}

impl super::core::DataContainerTrait for HoverCameraConfigEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static HOVERCAMERACONFIGENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HoverCameraConfigEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<HoverCameraConfigEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "CameraOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(HoverCameraConfigEntityData, camera_offset),
            },
            FieldInfoData {
                name: "CameraOffsetZoomed",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(HoverCameraConfigEntityData, camera_offset_zoomed),
            },
            FieldInfoData {
                name: "LookAheadOffsetZ",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverCameraConfigEntityData, look_ahead_offset_z),
            },
            FieldInfoData {
                name: "LookAheadOffsetZ_Zoomed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverCameraConfigEntityData, look_ahead_offset_z_zoomed),
            },
            FieldInfoData {
                name: "LookAheadExtrapolation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverCameraConfigEntityData, look_ahead_extrapolation),
            },
            FieldInfoData {
                name: "LinearExtrapolation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverCameraConfigEntityData, linear_extrapolation),
            },
            FieldInfoData {
                name: "FollowOffsetZ",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverCameraConfigEntityData, follow_offset_z),
            },
            FieldInfoData {
                name: "FollowOffsetZ_Zoomed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverCameraConfigEntityData, follow_offset_z_zoomed),
            },
            FieldInfoData {
                name: "LerpAxisFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(HoverCameraConfigEntityData, lerp_axis_factor),
            },
            FieldInfoData {
                name: "LerpAxisFactorZoomed",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(HoverCameraConfigEntityData, lerp_axis_factor_zoomed),
            },
            FieldInfoData {
                name: "TargetUprightLerp",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverCameraConfigEntityData, target_upright_lerp),
            },
            FieldInfoData {
                name: "TargetUprightLerpSmoothing",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverCameraConfigEntityData, target_upright_lerp_smoothing),
            },
            FieldInfoData {
                name: "LookDirectionLerp",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverCameraConfigEntityData, look_direction_lerp),
            },
            FieldInfoData {
                name: "LookDirectionLerpZoomed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverCameraConfigEntityData, look_direction_lerp_zoomed),
            },
            FieldInfoData {
                name: "Pitch",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverCameraConfigEntityData, pitch),
            },
            FieldInfoData {
                name: "PitchZoomed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverCameraConfigEntityData, pitch_zoomed),
            },
            FieldInfoData {
                name: "CrosshairPitch",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverCameraConfigEntityData, crosshair_pitch),
            },
            FieldInfoData {
                name: "CrosshairPitchZoomed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverCameraConfigEntityData, crosshair_pitch_zoomed),
            },
            FieldInfoData {
                name: "MaxAllowedRollAngleCameraToTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverCameraConfigEntityData, max_allowed_roll_angle_camera_to_target),
            },
            FieldInfoData {
                name: "CameraToTargetRollAngleSmoothing",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverCameraConfigEntityData, camera_to_target_roll_angle_smoothing),
            },
            FieldInfoData {
                name: "FollowOffsetDeadZone",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(HoverCameraConfigEntityData, follow_offset_dead_zone),
            },
            FieldInfoData {
                name: "AimingVerticalCutoff",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverCameraConfigEntityData, aiming_vertical_cutoff),
            },
            FieldInfoData {
                name: "PitchSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverCameraConfigEntityData, pitch_speed),
            },
            FieldInfoData {
                name: "PitchSpeedMouse",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverCameraConfigEntityData, pitch_speed_mouse),
            },
            FieldInfoData {
                name: "PitchControlDeadzone",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverCameraConfigEntityData, pitch_control_deadzone),
            },
            FieldInfoData {
                name: "PitchControlDeadzoneMouse",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverCameraConfigEntityData, pitch_control_deadzone_mouse),
            },
            FieldInfoData {
                name: "PitchUpAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverCameraConfigEntityData, pitch_up_angle),
            },
            FieldInfoData {
                name: "PitchDownAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverCameraConfigEntityData, pitch_down_angle),
            },
            FieldInfoData {
                name: "SphereCollisionRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverCameraConfigEntityData, sphere_collision_radius),
            },
            FieldInfoData {
                name: "SafeOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(HoverCameraConfigEntityData, safe_offset),
            },
            FieldInfoData {
                name: "CollisionLerpRate",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverCameraConfigEntityData, collision_lerp_rate),
            },
            FieldInfoData {
                name: "MinCollisionTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverCameraConfigEntityData, min_collision_time),
            },
            FieldInfoData {
                name: "PillMinimumCollisionRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverCameraConfigEntityData, pill_minimum_collision_radius),
            },
            FieldInfoData {
                name: "PillMaximumCollisionRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverCameraConfigEntityData, pill_maximum_collision_radius),
            },
            FieldInfoData {
                name: "PillMinimumCollisionLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverCameraConfigEntityData, pill_minimum_collision_length),
            },
        ],
    }),
    array_type: Some(HOVERCAMERACONFIGENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for HoverCameraConfigEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        HOVERCAMERACONFIGENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static HOVERCAMERACONFIGENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HoverCameraConfigEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("HoverCameraConfigEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CockpitCameraConfigEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub crosshair_offset_z: f32,
    pub crosshair_offset_z_zoomed: f32,
    pub linear_extrapolation: f32,
    pub use_extrapolated_look_target: bool,
    pub look_ahead_distance: f32,
    pub look_ahead_time: f32,
    pub look_ahead_time2: f32,
    pub look_steer: super::core::Vec3,
    pub acceleration_scale: super::core::Vec3,
    pub position_offset: super::core::Vec3,
    pub position_offset_zoomed: super::core::Vec3,
    pub translation_scale: super::core::Vec3,
    pub rotation_lerp: f32,
    pub roll_scale: f32,
    pub roll_extrapolation_time: f32,
    pub ref_up_max_angle_diff: f32,
    pub ref_up_near_lerp: f32,
}

pub trait CockpitCameraConfigEntityDataTrait: super::entity::EntityDataTrait {
    fn crosshair_offset_z(&self) -> &f32;
    fn crosshair_offset_z_zoomed(&self) -> &f32;
    fn linear_extrapolation(&self) -> &f32;
    fn use_extrapolated_look_target(&self) -> &bool;
    fn look_ahead_distance(&self) -> &f32;
    fn look_ahead_time(&self) -> &f32;
    fn look_ahead_time2(&self) -> &f32;
    fn look_steer(&self) -> &super::core::Vec3;
    fn acceleration_scale(&self) -> &super::core::Vec3;
    fn position_offset(&self) -> &super::core::Vec3;
    fn position_offset_zoomed(&self) -> &super::core::Vec3;
    fn translation_scale(&self) -> &super::core::Vec3;
    fn rotation_lerp(&self) -> &f32;
    fn roll_scale(&self) -> &f32;
    fn roll_extrapolation_time(&self) -> &f32;
    fn ref_up_max_angle_diff(&self) -> &f32;
    fn ref_up_near_lerp(&self) -> &f32;
}

impl CockpitCameraConfigEntityDataTrait for CockpitCameraConfigEntityData {
    fn crosshair_offset_z(&self) -> &f32 {
        &self.crosshair_offset_z
    }
    fn crosshair_offset_z_zoomed(&self) -> &f32 {
        &self.crosshair_offset_z_zoomed
    }
    fn linear_extrapolation(&self) -> &f32 {
        &self.linear_extrapolation
    }
    fn use_extrapolated_look_target(&self) -> &bool {
        &self.use_extrapolated_look_target
    }
    fn look_ahead_distance(&self) -> &f32 {
        &self.look_ahead_distance
    }
    fn look_ahead_time(&self) -> &f32 {
        &self.look_ahead_time
    }
    fn look_ahead_time2(&self) -> &f32 {
        &self.look_ahead_time2
    }
    fn look_steer(&self) -> &super::core::Vec3 {
        &self.look_steer
    }
    fn acceleration_scale(&self) -> &super::core::Vec3 {
        &self.acceleration_scale
    }
    fn position_offset(&self) -> &super::core::Vec3 {
        &self.position_offset
    }
    fn position_offset_zoomed(&self) -> &super::core::Vec3 {
        &self.position_offset_zoomed
    }
    fn translation_scale(&self) -> &super::core::Vec3 {
        &self.translation_scale
    }
    fn rotation_lerp(&self) -> &f32 {
        &self.rotation_lerp
    }
    fn roll_scale(&self) -> &f32 {
        &self.roll_scale
    }
    fn roll_extrapolation_time(&self) -> &f32 {
        &self.roll_extrapolation_time
    }
    fn ref_up_max_angle_diff(&self) -> &f32 {
        &self.ref_up_max_angle_diff
    }
    fn ref_up_near_lerp(&self) -> &f32 {
        &self.ref_up_near_lerp
    }
}

impl super::entity::EntityDataTrait for CockpitCameraConfigEntityData {
}

impl super::entity::GameObjectDataTrait for CockpitCameraConfigEntityData {
}

impl super::core::DataBusPeerTrait for CockpitCameraConfigEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for CockpitCameraConfigEntityData {
}

impl super::core::DataContainerTrait for CockpitCameraConfigEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static COCKPITCAMERACONFIGENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CockpitCameraConfigEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CockpitCameraConfigEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "CrosshairOffsetZ",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CockpitCameraConfigEntityData, crosshair_offset_z),
            },
            FieldInfoData {
                name: "CrosshairOffsetZ_Zoomed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CockpitCameraConfigEntityData, crosshair_offset_z_zoomed),
            },
            FieldInfoData {
                name: "LinearExtrapolation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CockpitCameraConfigEntityData, linear_extrapolation),
            },
            FieldInfoData {
                name: "UseExtrapolatedLookTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CockpitCameraConfigEntityData, use_extrapolated_look_target),
            },
            FieldInfoData {
                name: "LookAheadDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CockpitCameraConfigEntityData, look_ahead_distance),
            },
            FieldInfoData {
                name: "LookAheadTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CockpitCameraConfigEntityData, look_ahead_time),
            },
            FieldInfoData {
                name: "LookAheadTime2",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CockpitCameraConfigEntityData, look_ahead_time2),
            },
            FieldInfoData {
                name: "LookSteer",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(CockpitCameraConfigEntityData, look_steer),
            },
            FieldInfoData {
                name: "AccelerationScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(CockpitCameraConfigEntityData, acceleration_scale),
            },
            FieldInfoData {
                name: "PositionOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(CockpitCameraConfigEntityData, position_offset),
            },
            FieldInfoData {
                name: "PositionOffsetZoomed",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(CockpitCameraConfigEntityData, position_offset_zoomed),
            },
            FieldInfoData {
                name: "TranslationScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(CockpitCameraConfigEntityData, translation_scale),
            },
            FieldInfoData {
                name: "RotationLerp",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CockpitCameraConfigEntityData, rotation_lerp),
            },
            FieldInfoData {
                name: "RollScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CockpitCameraConfigEntityData, roll_scale),
            },
            FieldInfoData {
                name: "RollExtrapolationTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CockpitCameraConfigEntityData, roll_extrapolation_time),
            },
            FieldInfoData {
                name: "RefUpMaxAngleDiff",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CockpitCameraConfigEntityData, ref_up_max_angle_diff),
            },
            FieldInfoData {
                name: "RefUpNearLerp",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CockpitCameraConfigEntityData, ref_up_near_lerp),
            },
        ],
    }),
    array_type: Some(COCKPITCAMERACONFIGENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CockpitCameraConfigEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        COCKPITCAMERACONFIGENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static COCKPITCAMERACONFIGENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CockpitCameraConfigEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CockpitCameraConfigEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RearViewCameraConfigEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub camera_offset: super::core::Vec3,
    pub look_behind_offset_z: f32,
    pub linear_extrapolation: f32,
    pub use_extrapolated_look_target: bool,
    pub ahead_offset_z: f32,
    pub lerp_axis_factor: super::core::Vec3,
    pub target_upright_lerp: f32,
    pub target_upright_lerp_smoothing: f32,
    pub look_direction_lerp: f32,
    pub pitch: f32,
    pub max_allowed_roll_angle_camera_to_target: f32,
    pub camera_to_target_roll_angle_smoothing: f32,
    pub follow_offset_dead_zone: super::core::Vec3,
    pub swing_offset: f32,
    pub max_yaw_speed_for_max_swing: f32,
    pub camera_to_target_roll_response_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
    pub camera_to_target_vel_against_roll_velocity_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
    pub camera_to_target_vel_against_pitch_yaw_velocity_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
}

pub trait RearViewCameraConfigEntityDataTrait: super::entity::EntityDataTrait {
    fn camera_offset(&self) -> &super::core::Vec3;
    fn look_behind_offset_z(&self) -> &f32;
    fn linear_extrapolation(&self) -> &f32;
    fn use_extrapolated_look_target(&self) -> &bool;
    fn ahead_offset_z(&self) -> &f32;
    fn lerp_axis_factor(&self) -> &super::core::Vec3;
    fn target_upright_lerp(&self) -> &f32;
    fn target_upright_lerp_smoothing(&self) -> &f32;
    fn look_direction_lerp(&self) -> &f32;
    fn pitch(&self) -> &f32;
    fn max_allowed_roll_angle_camera_to_target(&self) -> &f32;
    fn camera_to_target_roll_angle_smoothing(&self) -> &f32;
    fn follow_offset_dead_zone(&self) -> &super::core::Vec3;
    fn swing_offset(&self) -> &f32;
    fn max_yaw_speed_for_max_swing(&self) -> &f32;
    fn camera_to_target_roll_response_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn camera_to_target_vel_against_roll_velocity_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn camera_to_target_vel_against_pitch_yaw_velocity_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
}

impl RearViewCameraConfigEntityDataTrait for RearViewCameraConfigEntityData {
    fn camera_offset(&self) -> &super::core::Vec3 {
        &self.camera_offset
    }
    fn look_behind_offset_z(&self) -> &f32 {
        &self.look_behind_offset_z
    }
    fn linear_extrapolation(&self) -> &f32 {
        &self.linear_extrapolation
    }
    fn use_extrapolated_look_target(&self) -> &bool {
        &self.use_extrapolated_look_target
    }
    fn ahead_offset_z(&self) -> &f32 {
        &self.ahead_offset_z
    }
    fn lerp_axis_factor(&self) -> &super::core::Vec3 {
        &self.lerp_axis_factor
    }
    fn target_upright_lerp(&self) -> &f32 {
        &self.target_upright_lerp
    }
    fn target_upright_lerp_smoothing(&self) -> &f32 {
        &self.target_upright_lerp_smoothing
    }
    fn look_direction_lerp(&self) -> &f32 {
        &self.look_direction_lerp
    }
    fn pitch(&self) -> &f32 {
        &self.pitch
    }
    fn max_allowed_roll_angle_camera_to_target(&self) -> &f32 {
        &self.max_allowed_roll_angle_camera_to_target
    }
    fn camera_to_target_roll_angle_smoothing(&self) -> &f32 {
        &self.camera_to_target_roll_angle_smoothing
    }
    fn follow_offset_dead_zone(&self) -> &super::core::Vec3 {
        &self.follow_offset_dead_zone
    }
    fn swing_offset(&self) -> &f32 {
        &self.swing_offset
    }
    fn max_yaw_speed_for_max_swing(&self) -> &f32 {
        &self.max_yaw_speed_for_max_swing
    }
    fn camera_to_target_roll_response_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.camera_to_target_roll_response_curve
    }
    fn camera_to_target_vel_against_roll_velocity_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.camera_to_target_vel_against_roll_velocity_curve
    }
    fn camera_to_target_vel_against_pitch_yaw_velocity_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.camera_to_target_vel_against_pitch_yaw_velocity_curve
    }
}

impl super::entity::EntityDataTrait for RearViewCameraConfigEntityData {
}

impl super::entity::GameObjectDataTrait for RearViewCameraConfigEntityData {
}

impl super::core::DataBusPeerTrait for RearViewCameraConfigEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for RearViewCameraConfigEntityData {
}

impl super::core::DataContainerTrait for RearViewCameraConfigEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static REARVIEWCAMERACONFIGENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RearViewCameraConfigEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RearViewCameraConfigEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "CameraOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(RearViewCameraConfigEntityData, camera_offset),
            },
            FieldInfoData {
                name: "LookBehindOffsetZ",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RearViewCameraConfigEntityData, look_behind_offset_z),
            },
            FieldInfoData {
                name: "LinearExtrapolation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RearViewCameraConfigEntityData, linear_extrapolation),
            },
            FieldInfoData {
                name: "UseExtrapolatedLookTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RearViewCameraConfigEntityData, use_extrapolated_look_target),
            },
            FieldInfoData {
                name: "AheadOffsetZ",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RearViewCameraConfigEntityData, ahead_offset_z),
            },
            FieldInfoData {
                name: "LerpAxisFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(RearViewCameraConfigEntityData, lerp_axis_factor),
            },
            FieldInfoData {
                name: "TargetUprightLerp",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RearViewCameraConfigEntityData, target_upright_lerp),
            },
            FieldInfoData {
                name: "TargetUprightLerpSmoothing",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RearViewCameraConfigEntityData, target_upright_lerp_smoothing),
            },
            FieldInfoData {
                name: "LookDirectionLerp",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RearViewCameraConfigEntityData, look_direction_lerp),
            },
            FieldInfoData {
                name: "Pitch",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RearViewCameraConfigEntityData, pitch),
            },
            FieldInfoData {
                name: "MaxAllowedRollAngleCameraToTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RearViewCameraConfigEntityData, max_allowed_roll_angle_camera_to_target),
            },
            FieldInfoData {
                name: "CameraToTargetRollAngleSmoothing",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RearViewCameraConfigEntityData, camera_to_target_roll_angle_smoothing),
            },
            FieldInfoData {
                name: "FollowOffsetDeadZone",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(RearViewCameraConfigEntityData, follow_offset_dead_zone),
            },
            FieldInfoData {
                name: "SwingOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RearViewCameraConfigEntityData, swing_offset),
            },
            FieldInfoData {
                name: "MaxYawSpeedForMaxSwing",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RearViewCameraConfigEntityData, max_yaw_speed_for_max_swing),
            },
            FieldInfoData {
                name: "CameraToTargetRollResponseCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(RearViewCameraConfigEntityData, camera_to_target_roll_response_curve),
            },
            FieldInfoData {
                name: "CameraToTargetVelAgainstRollVelocityCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(RearViewCameraConfigEntityData, camera_to_target_vel_against_roll_velocity_curve),
            },
            FieldInfoData {
                name: "CameraToTargetVelAgainstPitchYawVelocityCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(RearViewCameraConfigEntityData, camera_to_target_vel_against_pitch_yaw_velocity_curve),
            },
        ],
    }),
    array_type: Some(REARVIEWCAMERACONFIGENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for RearViewCameraConfigEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        REARVIEWCAMERACONFIGENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static REARVIEWCAMERACONFIGENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RearViewCameraConfigEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("RearViewCameraConfigEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FollowCameraConfigEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub camera_offset: super::core::Vec3,
    pub camera_offset_zoomed: super::core::Vec3,
    pub look_ahead_offset_z: f32,
    pub look_ahead_offset_z_zoomed: f32,
    pub crosshair_offset_z: f32,
    pub crosshair_offset_z_zoomed: f32,
    pub linear_extrapolation: f32,
    pub use_extrapolated_look_target: bool,
    pub collision_lerp_rate: f32,
    pub collision_radius: f32,
    pub follow_offset_z: f32,
    pub follow_offset_z_zoomed: f32,
    pub lerp_axis_factor: super::core::Vec3,
    pub lerp_axis_factor_zoomed: super::core::Vec3,
    pub target_upright_lerp: f32,
    pub target_upright_lerp_smoothing: f32,
    pub look_direction_lerp: f32,
    pub look_direction_lerp_zoomed: f32,
    pub pitch: f32,
    pub pitch_zoomed: f32,
    pub max_allowed_roll_angle_camera_to_target: f32,
    pub camera_to_target_roll_angle_smoothing: f32,
    pub follow_offset_dead_zone: super::core::Vec3,
    pub min_distance_to_vehicle: f32,
    pub max_angle_to_vehicle: f32,
    pub camera_to_target_roll_response_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
    pub camera_to_target_vel_against_roll_velocity_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
    pub camera_to_target_vel_against_pitch_yaw_velocity_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
}

pub trait FollowCameraConfigEntityDataTrait: super::entity::EntityDataTrait {
    fn camera_offset(&self) -> &super::core::Vec3;
    fn camera_offset_zoomed(&self) -> &super::core::Vec3;
    fn look_ahead_offset_z(&self) -> &f32;
    fn look_ahead_offset_z_zoomed(&self) -> &f32;
    fn crosshair_offset_z(&self) -> &f32;
    fn crosshair_offset_z_zoomed(&self) -> &f32;
    fn linear_extrapolation(&self) -> &f32;
    fn use_extrapolated_look_target(&self) -> &bool;
    fn collision_lerp_rate(&self) -> &f32;
    fn collision_radius(&self) -> &f32;
    fn follow_offset_z(&self) -> &f32;
    fn follow_offset_z_zoomed(&self) -> &f32;
    fn lerp_axis_factor(&self) -> &super::core::Vec3;
    fn lerp_axis_factor_zoomed(&self) -> &super::core::Vec3;
    fn target_upright_lerp(&self) -> &f32;
    fn target_upright_lerp_smoothing(&self) -> &f32;
    fn look_direction_lerp(&self) -> &f32;
    fn look_direction_lerp_zoomed(&self) -> &f32;
    fn pitch(&self) -> &f32;
    fn pitch_zoomed(&self) -> &f32;
    fn max_allowed_roll_angle_camera_to_target(&self) -> &f32;
    fn camera_to_target_roll_angle_smoothing(&self) -> &f32;
    fn follow_offset_dead_zone(&self) -> &super::core::Vec3;
    fn min_distance_to_vehicle(&self) -> &f32;
    fn max_angle_to_vehicle(&self) -> &f32;
    fn camera_to_target_roll_response_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn camera_to_target_vel_against_roll_velocity_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn camera_to_target_vel_against_pitch_yaw_velocity_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
}

impl FollowCameraConfigEntityDataTrait for FollowCameraConfigEntityData {
    fn camera_offset(&self) -> &super::core::Vec3 {
        &self.camera_offset
    }
    fn camera_offset_zoomed(&self) -> &super::core::Vec3 {
        &self.camera_offset_zoomed
    }
    fn look_ahead_offset_z(&self) -> &f32 {
        &self.look_ahead_offset_z
    }
    fn look_ahead_offset_z_zoomed(&self) -> &f32 {
        &self.look_ahead_offset_z_zoomed
    }
    fn crosshair_offset_z(&self) -> &f32 {
        &self.crosshair_offset_z
    }
    fn crosshair_offset_z_zoomed(&self) -> &f32 {
        &self.crosshair_offset_z_zoomed
    }
    fn linear_extrapolation(&self) -> &f32 {
        &self.linear_extrapolation
    }
    fn use_extrapolated_look_target(&self) -> &bool {
        &self.use_extrapolated_look_target
    }
    fn collision_lerp_rate(&self) -> &f32 {
        &self.collision_lerp_rate
    }
    fn collision_radius(&self) -> &f32 {
        &self.collision_radius
    }
    fn follow_offset_z(&self) -> &f32 {
        &self.follow_offset_z
    }
    fn follow_offset_z_zoomed(&self) -> &f32 {
        &self.follow_offset_z_zoomed
    }
    fn lerp_axis_factor(&self) -> &super::core::Vec3 {
        &self.lerp_axis_factor
    }
    fn lerp_axis_factor_zoomed(&self) -> &super::core::Vec3 {
        &self.lerp_axis_factor_zoomed
    }
    fn target_upright_lerp(&self) -> &f32 {
        &self.target_upright_lerp
    }
    fn target_upright_lerp_smoothing(&self) -> &f32 {
        &self.target_upright_lerp_smoothing
    }
    fn look_direction_lerp(&self) -> &f32 {
        &self.look_direction_lerp
    }
    fn look_direction_lerp_zoomed(&self) -> &f32 {
        &self.look_direction_lerp_zoomed
    }
    fn pitch(&self) -> &f32 {
        &self.pitch
    }
    fn pitch_zoomed(&self) -> &f32 {
        &self.pitch_zoomed
    }
    fn max_allowed_roll_angle_camera_to_target(&self) -> &f32 {
        &self.max_allowed_roll_angle_camera_to_target
    }
    fn camera_to_target_roll_angle_smoothing(&self) -> &f32 {
        &self.camera_to_target_roll_angle_smoothing
    }
    fn follow_offset_dead_zone(&self) -> &super::core::Vec3 {
        &self.follow_offset_dead_zone
    }
    fn min_distance_to_vehicle(&self) -> &f32 {
        &self.min_distance_to_vehicle
    }
    fn max_angle_to_vehicle(&self) -> &f32 {
        &self.max_angle_to_vehicle
    }
    fn camera_to_target_roll_response_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.camera_to_target_roll_response_curve
    }
    fn camera_to_target_vel_against_roll_velocity_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.camera_to_target_vel_against_roll_velocity_curve
    }
    fn camera_to_target_vel_against_pitch_yaw_velocity_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.camera_to_target_vel_against_pitch_yaw_velocity_curve
    }
}

impl super::entity::EntityDataTrait for FollowCameraConfigEntityData {
}

impl super::entity::GameObjectDataTrait for FollowCameraConfigEntityData {
}

impl super::core::DataBusPeerTrait for FollowCameraConfigEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for FollowCameraConfigEntityData {
}

impl super::core::DataContainerTrait for FollowCameraConfigEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static FOLLOWCAMERACONFIGENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowCameraConfigEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FollowCameraConfigEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "CameraOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(FollowCameraConfigEntityData, camera_offset),
            },
            FieldInfoData {
                name: "CameraOffsetZoomed",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(FollowCameraConfigEntityData, camera_offset_zoomed),
            },
            FieldInfoData {
                name: "LookAheadOffsetZ",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowCameraConfigEntityData, look_ahead_offset_z),
            },
            FieldInfoData {
                name: "LookAheadOffsetZ_Zoomed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowCameraConfigEntityData, look_ahead_offset_z_zoomed),
            },
            FieldInfoData {
                name: "CrosshairOffsetZ",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowCameraConfigEntityData, crosshair_offset_z),
            },
            FieldInfoData {
                name: "CrosshairOffsetZ_Zoomed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowCameraConfigEntityData, crosshair_offset_z_zoomed),
            },
            FieldInfoData {
                name: "LinearExtrapolation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowCameraConfigEntityData, linear_extrapolation),
            },
            FieldInfoData {
                name: "UseExtrapolatedLookTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FollowCameraConfigEntityData, use_extrapolated_look_target),
            },
            FieldInfoData {
                name: "CollisionLerpRate",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowCameraConfigEntityData, collision_lerp_rate),
            },
            FieldInfoData {
                name: "CollisionRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowCameraConfigEntityData, collision_radius),
            },
            FieldInfoData {
                name: "FollowOffsetZ",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowCameraConfigEntityData, follow_offset_z),
            },
            FieldInfoData {
                name: "FollowOffsetZ_Zoomed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowCameraConfigEntityData, follow_offset_z_zoomed),
            },
            FieldInfoData {
                name: "LerpAxisFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(FollowCameraConfigEntityData, lerp_axis_factor),
            },
            FieldInfoData {
                name: "LerpAxisFactorZoomed",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(FollowCameraConfigEntityData, lerp_axis_factor_zoomed),
            },
            FieldInfoData {
                name: "TargetUprightLerp",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowCameraConfigEntityData, target_upright_lerp),
            },
            FieldInfoData {
                name: "TargetUprightLerpSmoothing",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowCameraConfigEntityData, target_upright_lerp_smoothing),
            },
            FieldInfoData {
                name: "LookDirectionLerp",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowCameraConfigEntityData, look_direction_lerp),
            },
            FieldInfoData {
                name: "LookDirectionLerpZoomed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowCameraConfigEntityData, look_direction_lerp_zoomed),
            },
            FieldInfoData {
                name: "Pitch",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowCameraConfigEntityData, pitch),
            },
            FieldInfoData {
                name: "PitchZoomed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowCameraConfigEntityData, pitch_zoomed),
            },
            FieldInfoData {
                name: "MaxAllowedRollAngleCameraToTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowCameraConfigEntityData, max_allowed_roll_angle_camera_to_target),
            },
            FieldInfoData {
                name: "CameraToTargetRollAngleSmoothing",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowCameraConfigEntityData, camera_to_target_roll_angle_smoothing),
            },
            FieldInfoData {
                name: "FollowOffsetDeadZone",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(FollowCameraConfigEntityData, follow_offset_dead_zone),
            },
            FieldInfoData {
                name: "MinDistanceToVehicle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowCameraConfigEntityData, min_distance_to_vehicle),
            },
            FieldInfoData {
                name: "MaxAngleToVehicle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowCameraConfigEntityData, max_angle_to_vehicle),
            },
            FieldInfoData {
                name: "CameraToTargetRollResponseCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(FollowCameraConfigEntityData, camera_to_target_roll_response_curve),
            },
            FieldInfoData {
                name: "CameraToTargetVelAgainstRollVelocityCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(FollowCameraConfigEntityData, camera_to_target_vel_against_roll_velocity_curve),
            },
            FieldInfoData {
                name: "CameraToTargetVelAgainstPitchYawVelocityCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(FollowCameraConfigEntityData, camera_to_target_vel_against_pitch_yaw_velocity_curve),
            },
        ],
    }),
    array_type: Some(FOLLOWCAMERACONFIGENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for FollowCameraConfigEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        FOLLOWCAMERACONFIGENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static FOLLOWCAMERACONFIGENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowCameraConfigEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("FollowCameraConfigEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CameraTransformerUpdatePass {
    #[default]
    CameraTransformerUpdatePass_Instant = 0,
    CameraTransformerUpdatePass_PreSim = 1,
    CameraTransformerUpdatePass_PostSim = 2,
    CameraTransformerUpdatePass_PostFrame = 3,
    CameraTransformerUpdatePass_None = 4,
}

pub static CAMERATRANSFORMERUPDATEPASS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraTransformerUpdatePass",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(CAMERATRANSFORMERUPDATEPASS_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CameraTransformerUpdatePass {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERATRANSFORMERUPDATEPASS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CAMERATRANSFORMERUPDATEPASS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraTransformerUpdatePass-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CameraTransformerUpdatePass"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BarrageEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub area_center_transform: super::core::LinearTransform,
    pub time_between_shots: f32,
    pub time_between_shots_variance: f32,
    pub inner_radius: f32,
    pub outer_radius: f32,
    pub shot_spawn_height: f32,
}

pub trait BarrageEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn area_center_transform(&self) -> &super::core::LinearTransform;
    fn time_between_shots(&self) -> &f32;
    fn time_between_shots_variance(&self) -> &f32;
    fn inner_radius(&self) -> &f32;
    fn outer_radius(&self) -> &f32;
    fn shot_spawn_height(&self) -> &f32;
}

impl BarrageEntityDataTrait for BarrageEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn area_center_transform(&self) -> &super::core::LinearTransform {
        &self.area_center_transform
    }
    fn time_between_shots(&self) -> &f32 {
        &self.time_between_shots
    }
    fn time_between_shots_variance(&self) -> &f32 {
        &self.time_between_shots_variance
    }
    fn inner_radius(&self) -> &f32 {
        &self.inner_radius
    }
    fn outer_radius(&self) -> &f32 {
        &self.outer_radius
    }
    fn shot_spawn_height(&self) -> &f32 {
        &self.shot_spawn_height
    }
}

impl super::entity::EntityDataTrait for BarrageEntityData {
}

impl super::entity::GameObjectDataTrait for BarrageEntityData {
}

impl super::core::DataBusPeerTrait for BarrageEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for BarrageEntityData {
}

impl super::core::DataContainerTrait for BarrageEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static BARRAGEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BarrageEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BarrageEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(BarrageEntityData, realm),
            },
            FieldInfoData {
                name: "AreaCenterTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(BarrageEntityData, area_center_transform),
            },
            FieldInfoData {
                name: "TimeBetweenShots",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BarrageEntityData, time_between_shots),
            },
            FieldInfoData {
                name: "TimeBetweenShotsVariance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BarrageEntityData, time_between_shots_variance),
            },
            FieldInfoData {
                name: "InnerRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BarrageEntityData, inner_radius),
            },
            FieldInfoData {
                name: "OuterRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BarrageEntityData, outer_radius),
            },
            FieldInfoData {
                name: "ShotSpawnHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BarrageEntityData, shot_spawn_height),
            },
        ],
    }),
    array_type: Some(BARRAGEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for BarrageEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        BARRAGEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static BARRAGEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BarrageEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("BarrageEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct QueryResultPlayerInspectorEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub query: QueryEntityResult,
}

pub trait QueryResultPlayerInspectorEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn query(&self) -> &QueryEntityResult;
}

impl QueryResultPlayerInspectorEntityDataTrait for QueryResultPlayerInspectorEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn query(&self) -> &QueryEntityResult {
        &self.query
    }
}

impl super::entity::EntityDataTrait for QueryResultPlayerInspectorEntityData {
}

impl super::entity::GameObjectDataTrait for QueryResultPlayerInspectorEntityData {
}

impl super::core::DataBusPeerTrait for QueryResultPlayerInspectorEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for QueryResultPlayerInspectorEntityData {
}

impl super::core::DataContainerTrait for QueryResultPlayerInspectorEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static QUERYRESULTPLAYERINSPECTORENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "QueryResultPlayerInspectorEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<QueryResultPlayerInspectorEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(QueryResultPlayerInspectorEntityData, realm),
            },
            FieldInfoData {
                name: "Query",
                flags: MemberInfoFlags::new(0),
                field_type: "QueryEntityResult",
                rust_offset: offset_of!(QueryResultPlayerInspectorEntityData, query),
            },
        ],
    }),
    array_type: Some(QUERYRESULTPLAYERINSPECTORENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for QueryResultPlayerInspectorEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        QUERYRESULTPLAYERINSPECTORENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static QUERYRESULTPLAYERINSPECTORENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "QueryResultPlayerInspectorEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("QueryResultPlayerInspectorEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterAnimatableMeshProxyComponentData {
    pub _glacier_base: super::game_shared::MeshComponentData,
}

pub trait CharacterAnimatableMeshProxyComponentDataTrait: super::game_shared::MeshComponentDataTrait {
}

impl CharacterAnimatableMeshProxyComponentDataTrait for CharacterAnimatableMeshProxyComponentData {
}

impl super::game_shared::MeshComponentDataTrait for CharacterAnimatableMeshProxyComponentData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn mesh(&self) -> &Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        self._glacier_base.mesh()
    }
}

impl super::entity::GameComponentDataTrait for CharacterAnimatableMeshProxyComponentData {
}

impl super::entity::ComponentDataTrait for CharacterAnimatableMeshProxyComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
}

impl super::entity::GameObjectDataTrait for CharacterAnimatableMeshProxyComponentData {
}

impl super::core::DataBusPeerTrait for CharacterAnimatableMeshProxyComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for CharacterAnimatableMeshProxyComponentData {
}

impl super::core::DataContainerTrait for CharacterAnimatableMeshProxyComponentData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERANIMATABLEMESHPROXYCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterAnimatableMeshProxyComponentData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::game_shared::MESHCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterAnimatableMeshProxyComponentData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(CHARACTERANIMATABLEMESHPROXYCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CharacterAnimatableMeshProxyComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERANIMATABLEMESHPROXYCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERANIMATABLEMESHPROXYCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterAnimatableMeshProxyComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterAnimatableMeshProxyComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VaultComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub start_height_max: f32,
    pub start_height_min: f32,
    pub detect_distance: f32,
    pub detect_distance_moving: f32,
    pub high_vault_threshold: f32,
    pub ticks_up: u32,
    pub ticks_up_high: u32,
    pub ticks_over: u32,
    pub ticks_over_high: u32,
    pub binding: VaultBinding,
    pub binding1p_only: Vault1pOnlyBinding,
    pub binding3p_only: Vault3pOnlyBinding,
}

pub trait VaultComponentDataTrait: super::entity::GameComponentDataTrait {
    fn start_height_max(&self) -> &f32;
    fn start_height_min(&self) -> &f32;
    fn detect_distance(&self) -> &f32;
    fn detect_distance_moving(&self) -> &f32;
    fn high_vault_threshold(&self) -> &f32;
    fn ticks_up(&self) -> &u32;
    fn ticks_up_high(&self) -> &u32;
    fn ticks_over(&self) -> &u32;
    fn ticks_over_high(&self) -> &u32;
    fn binding(&self) -> &VaultBinding;
    fn binding1p_only(&self) -> &Vault1pOnlyBinding;
    fn binding3p_only(&self) -> &Vault3pOnlyBinding;
}

impl VaultComponentDataTrait for VaultComponentData {
    fn start_height_max(&self) -> &f32 {
        &self.start_height_max
    }
    fn start_height_min(&self) -> &f32 {
        &self.start_height_min
    }
    fn detect_distance(&self) -> &f32 {
        &self.detect_distance
    }
    fn detect_distance_moving(&self) -> &f32 {
        &self.detect_distance_moving
    }
    fn high_vault_threshold(&self) -> &f32 {
        &self.high_vault_threshold
    }
    fn ticks_up(&self) -> &u32 {
        &self.ticks_up
    }
    fn ticks_up_high(&self) -> &u32 {
        &self.ticks_up_high
    }
    fn ticks_over(&self) -> &u32 {
        &self.ticks_over
    }
    fn ticks_over_high(&self) -> &u32 {
        &self.ticks_over_high
    }
    fn binding(&self) -> &VaultBinding {
        &self.binding
    }
    fn binding1p_only(&self) -> &Vault1pOnlyBinding {
        &self.binding1p_only
    }
    fn binding3p_only(&self) -> &Vault3pOnlyBinding {
        &self.binding3p_only
    }
}

impl super::entity::GameComponentDataTrait for VaultComponentData {
}

impl super::entity::ComponentDataTrait for VaultComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
}

impl super::entity::GameObjectDataTrait for VaultComponentData {
}

impl super::core::DataBusPeerTrait for VaultComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for VaultComponentData {
}

impl super::core::DataContainerTrait for VaultComponentData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static VAULTCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VaultComponentData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VaultComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "StartHeightMax",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VaultComponentData, start_height_max),
            },
            FieldInfoData {
                name: "StartHeightMin",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VaultComponentData, start_height_min),
            },
            FieldInfoData {
                name: "DetectDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VaultComponentData, detect_distance),
            },
            FieldInfoData {
                name: "DetectDistanceMoving",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VaultComponentData, detect_distance_moving),
            },
            FieldInfoData {
                name: "HighVaultThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VaultComponentData, high_vault_threshold),
            },
            FieldInfoData {
                name: "TicksUp",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(VaultComponentData, ticks_up),
            },
            FieldInfoData {
                name: "TicksUpHigh",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(VaultComponentData, ticks_up_high),
            },
            FieldInfoData {
                name: "TicksOver",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(VaultComponentData, ticks_over),
            },
            FieldInfoData {
                name: "TicksOverHigh",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(VaultComponentData, ticks_over_high),
            },
            FieldInfoData {
                name: "Binding",
                flags: MemberInfoFlags::new(0),
                field_type: "VaultBinding",
                rust_offset: offset_of!(VaultComponentData, binding),
            },
            FieldInfoData {
                name: "Binding1pOnly",
                flags: MemberInfoFlags::new(0),
                field_type: "Vault1pOnlyBinding",
                rust_offset: offset_of!(VaultComponentData, binding1p_only),
            },
            FieldInfoData {
                name: "Binding3pOnly",
                flags: MemberInfoFlags::new(0),
                field_type: "Vault3pOnlyBinding",
                rust_offset: offset_of!(VaultComponentData, binding3p_only),
            },
        ],
    }),
    array_type: Some(VAULTCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VaultComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        VAULTCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VAULTCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VaultComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("VaultComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Vault3pOnlyBinding {
    pub is_vaulting: super::ant::AntRef,
}

pub trait Vault3pOnlyBindingTrait: TypeObject {
    fn is_vaulting(&self) -> &super::ant::AntRef;
}

impl Vault3pOnlyBindingTrait for Vault3pOnlyBinding {
    fn is_vaulting(&self) -> &super::ant::AntRef {
        &self.is_vaulting
    }
}

pub static VAULT3PONLYBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vault3pOnlyBinding",
    flags: MemberInfoFlags::new(32841),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vault3pOnlyBinding as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "IsVaulting",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(Vault3pOnlyBinding, is_vaulting),
            },
        ],
    }),
    array_type: Some(VAULT3PONLYBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for Vault3pOnlyBinding {
    fn type_info(&self) -> &'static TypeInfo {
        VAULT3PONLYBINDING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VAULT3PONLYBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vault3pOnlyBinding-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("Vault3pOnlyBinding"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Vault1pOnlyBinding {
    pub is_vaulting: super::ant::AntRef,
}

pub trait Vault1pOnlyBindingTrait: TypeObject {
    fn is_vaulting(&self) -> &super::ant::AntRef;
}

impl Vault1pOnlyBindingTrait for Vault1pOnlyBinding {
    fn is_vaulting(&self) -> &super::ant::AntRef {
        &self.is_vaulting
    }
}

pub static VAULT1PONLYBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vault1pOnlyBinding",
    flags: MemberInfoFlags::new(32841),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vault1pOnlyBinding as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "IsVaulting",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(Vault1pOnlyBinding, is_vaulting),
            },
        ],
    }),
    array_type: Some(VAULT1PONLYBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for Vault1pOnlyBinding {
    fn type_info(&self) -> &'static TypeInfo {
        VAULT1PONLYBINDING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VAULT1PONLYBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vault1pOnlyBinding-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("Vault1pOnlyBinding"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VaultBinding {
    pub vault_active: super::ant::AntRef,
    pub vault_cancel: super::ant::AntRef,
    pub vault_depth_distance: super::ant::AntRef,
    pub vault_end_height: super::ant::AntRef,
    pub vault_start_distance: super::ant::AntRef,
    pub vault_start_height: super::ant::AntRef,
    pub vault_type: super::ant::AntRef,
}

pub trait VaultBindingTrait: TypeObject {
    fn vault_active(&self) -> &super::ant::AntRef;
    fn vault_cancel(&self) -> &super::ant::AntRef;
    fn vault_depth_distance(&self) -> &super::ant::AntRef;
    fn vault_end_height(&self) -> &super::ant::AntRef;
    fn vault_start_distance(&self) -> &super::ant::AntRef;
    fn vault_start_height(&self) -> &super::ant::AntRef;
    fn vault_type(&self) -> &super::ant::AntRef;
}

impl VaultBindingTrait for VaultBinding {
    fn vault_active(&self) -> &super::ant::AntRef {
        &self.vault_active
    }
    fn vault_cancel(&self) -> &super::ant::AntRef {
        &self.vault_cancel
    }
    fn vault_depth_distance(&self) -> &super::ant::AntRef {
        &self.vault_depth_distance
    }
    fn vault_end_height(&self) -> &super::ant::AntRef {
        &self.vault_end_height
    }
    fn vault_start_distance(&self) -> &super::ant::AntRef {
        &self.vault_start_distance
    }
    fn vault_start_height(&self) -> &super::ant::AntRef {
        &self.vault_start_height
    }
    fn vault_type(&self) -> &super::ant::AntRef {
        &self.vault_type
    }
}

pub static VAULTBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VaultBinding",
    flags: MemberInfoFlags::new(32841),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VaultBinding as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "VaultActive",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VaultBinding, vault_active),
            },
            FieldInfoData {
                name: "VaultCancel",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VaultBinding, vault_cancel),
            },
            FieldInfoData {
                name: "VaultDepthDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VaultBinding, vault_depth_distance),
            },
            FieldInfoData {
                name: "VaultEndHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VaultBinding, vault_end_height),
            },
            FieldInfoData {
                name: "VaultStartDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VaultBinding, vault_start_distance),
            },
            FieldInfoData {
                name: "VaultStartHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VaultBinding, vault_start_height),
            },
            FieldInfoData {
                name: "VaultType",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VaultBinding, vault_type),
            },
        ],
    }),
    array_type: Some(VAULTBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for VaultBinding {
    fn type_info(&self) -> &'static TypeInfo {
        VAULTBINDING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VAULTBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VaultBinding-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("VaultBinding"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum VaultType {
    #[default]
    VaultType_None = 0,
    VaultType_Over = 1,
    VaultType_Up = 2,
    VaultType_UpWater = 3,
    VaultType_Count = 4,
}

pub static VAULTTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VaultType",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(VAULTTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for VaultType {
    fn type_info(&self) -> &'static TypeInfo {
        VAULTTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VAULTTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VaultType-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("VaultType"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum VaultState {
    #[default]
    VaultState_None = 0,
    VaultState_WaitingForAnimation = 1,
    VaultState_InAnimation = 2,
    VaultState_Cancel = 3,
    VaultState_Count = 4,
}

pub static VAULTSTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VaultState",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(VAULTSTATE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for VaultState {
    fn type_info(&self) -> &'static TypeInfo {
        VAULTSTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VAULTSTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VaultState-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("VaultState"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoldierSuppressionComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub reaction_to_suppression: SuppressionReactionData,
    pub suppression_resist_modifier: f32,
    pub suppression_boost_modifier: f32,
    pub suppression_decay: f32,
    pub suppression_sphere_radius: f32,
    pub fall_off_delay: f32,
    pub fall_off_multiplier: f32,
    pub suppression_aborts_health_regeneration: bool,
    pub check_line_of_sight: bool,
    pub is_a_i_suppressed: bool,
    pub suppressed_effect_timescale: f32,
    pub suppression_level_write_enabled: bool,
    pub ignore_bullet_suppression: bool,
    pub ignore_explosion_suppression: bool,
    pub ignore_gas_suppression: bool,
}

pub trait SoldierSuppressionComponentDataTrait: super::entity::GameComponentDataTrait {
    fn reaction_to_suppression(&self) -> &SuppressionReactionData;
    fn suppression_resist_modifier(&self) -> &f32;
    fn suppression_boost_modifier(&self) -> &f32;
    fn suppression_decay(&self) -> &f32;
    fn suppression_sphere_radius(&self) -> &f32;
    fn fall_off_delay(&self) -> &f32;
    fn fall_off_multiplier(&self) -> &f32;
    fn suppression_aborts_health_regeneration(&self) -> &bool;
    fn check_line_of_sight(&self) -> &bool;
    fn is_a_i_suppressed(&self) -> &bool;
    fn suppressed_effect_timescale(&self) -> &f32;
    fn suppression_level_write_enabled(&self) -> &bool;
    fn ignore_bullet_suppression(&self) -> &bool;
    fn ignore_explosion_suppression(&self) -> &bool;
    fn ignore_gas_suppression(&self) -> &bool;
}

impl SoldierSuppressionComponentDataTrait for SoldierSuppressionComponentData {
    fn reaction_to_suppression(&self) -> &SuppressionReactionData {
        &self.reaction_to_suppression
    }
    fn suppression_resist_modifier(&self) -> &f32 {
        &self.suppression_resist_modifier
    }
    fn suppression_boost_modifier(&self) -> &f32 {
        &self.suppression_boost_modifier
    }
    fn suppression_decay(&self) -> &f32 {
        &self.suppression_decay
    }
    fn suppression_sphere_radius(&self) -> &f32 {
        &self.suppression_sphere_radius
    }
    fn fall_off_delay(&self) -> &f32 {
        &self.fall_off_delay
    }
    fn fall_off_multiplier(&self) -> &f32 {
        &self.fall_off_multiplier
    }
    fn suppression_aborts_health_regeneration(&self) -> &bool {
        &self.suppression_aborts_health_regeneration
    }
    fn check_line_of_sight(&self) -> &bool {
        &self.check_line_of_sight
    }
    fn is_a_i_suppressed(&self) -> &bool {
        &self.is_a_i_suppressed
    }
    fn suppressed_effect_timescale(&self) -> &f32 {
        &self.suppressed_effect_timescale
    }
    fn suppression_level_write_enabled(&self) -> &bool {
        &self.suppression_level_write_enabled
    }
    fn ignore_bullet_suppression(&self) -> &bool {
        &self.ignore_bullet_suppression
    }
    fn ignore_explosion_suppression(&self) -> &bool {
        &self.ignore_explosion_suppression
    }
    fn ignore_gas_suppression(&self) -> &bool {
        &self.ignore_gas_suppression
    }
}

impl super::entity::GameComponentDataTrait for SoldierSuppressionComponentData {
}

impl super::entity::ComponentDataTrait for SoldierSuppressionComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
}

impl super::entity::GameObjectDataTrait for SoldierSuppressionComponentData {
}

impl super::core::DataBusPeerTrait for SoldierSuppressionComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for SoldierSuppressionComponentData {
}

impl super::core::DataContainerTrait for SoldierSuppressionComponentData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SOLDIERSUPPRESSIONCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierSuppressionComponentData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierSuppressionComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ReactionToSuppression",
                flags: MemberInfoFlags::new(0),
                field_type: "SuppressionReactionData",
                rust_offset: offset_of!(SoldierSuppressionComponentData, reaction_to_suppression),
            },
            FieldInfoData {
                name: "SuppressionResistModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierSuppressionComponentData, suppression_resist_modifier),
            },
            FieldInfoData {
                name: "SuppressionBoostModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierSuppressionComponentData, suppression_boost_modifier),
            },
            FieldInfoData {
                name: "SuppressionDecay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierSuppressionComponentData, suppression_decay),
            },
            FieldInfoData {
                name: "SuppressionSphereRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierSuppressionComponentData, suppression_sphere_radius),
            },
            FieldInfoData {
                name: "FallOffDelay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierSuppressionComponentData, fall_off_delay),
            },
            FieldInfoData {
                name: "FallOffMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierSuppressionComponentData, fall_off_multiplier),
            },
            FieldInfoData {
                name: "SuppressionAbortsHealthRegeneration",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierSuppressionComponentData, suppression_aborts_health_regeneration),
            },
            FieldInfoData {
                name: "CheckLineOfSight",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierSuppressionComponentData, check_line_of_sight),
            },
            FieldInfoData {
                name: "IsAISuppressed",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierSuppressionComponentData, is_a_i_suppressed),
            },
            FieldInfoData {
                name: "SuppressedEffectTimescale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierSuppressionComponentData, suppressed_effect_timescale),
            },
            FieldInfoData {
                name: "SuppressionLevelWriteEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierSuppressionComponentData, suppression_level_write_enabled),
            },
            FieldInfoData {
                name: "IgnoreBulletSuppression",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierSuppressionComponentData, ignore_bullet_suppression),
            },
            FieldInfoData {
                name: "IgnoreExplosionSuppression",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierSuppressionComponentData, ignore_explosion_suppression),
            },
            FieldInfoData {
                name: "IgnoreGasSuppression",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierSuppressionComponentData, ignore_gas_suppression),
            },
        ],
    }),
    array_type: Some(SOLDIERSUPPRESSIONCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SoldierSuppressionComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERSUPPRESSIONCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SOLDIERSUPPRESSIONCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierSuppressionComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("SoldierSuppressionComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum SuppressionType {
    #[default]
    SuppressionType_Bullet = 0,
    SuppressionType_Explosion = 1,
    SuppressionType_Gas = 2,
    SuppressionType_Count = 3,
}

pub static SUPPRESSIONTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SuppressionType",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(SUPPRESSIONTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SuppressionType {
    fn type_info(&self) -> &'static TypeInfo {
        SUPPRESSIONTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SUPPRESSIONTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SuppressionType-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("SuppressionType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SuppressionReactionData {
    pub suppression_high_threshold: f32,
    pub suppression_low_threshold: f32,
    pub suppression_u_i_threshold: f32,
}

pub trait SuppressionReactionDataTrait: TypeObject {
    fn suppression_high_threshold(&self) -> &f32;
    fn suppression_low_threshold(&self) -> &f32;
    fn suppression_u_i_threshold(&self) -> &f32;
}

impl SuppressionReactionDataTrait for SuppressionReactionData {
    fn suppression_high_threshold(&self) -> &f32 {
        &self.suppression_high_threshold
    }
    fn suppression_low_threshold(&self) -> &f32 {
        &self.suppression_low_threshold
    }
    fn suppression_u_i_threshold(&self) -> &f32 {
        &self.suppression_u_i_threshold
    }
}

pub static SUPPRESSIONREACTIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SuppressionReactionData",
    flags: MemberInfoFlags::new(36937),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SuppressionReactionData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SuppressionHighThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SuppressionReactionData, suppression_high_threshold),
            },
            FieldInfoData {
                name: "SuppressionLowThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SuppressionReactionData, suppression_low_threshold),
            },
            FieldInfoData {
                name: "SuppressionUIThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SuppressionReactionData, suppression_u_i_threshold),
            },
        ],
    }),
    array_type: Some(SUPPRESSIONREACTIONDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for SuppressionReactionData {
    fn type_info(&self) -> &'static TypeInfo {
        SUPPRESSIONREACTIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SUPPRESSIONREACTIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SuppressionReactionData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("SuppressionReactionData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SuppressionSettings {
    pub _glacier_base: super::core::DataContainer,
}

pub trait SuppressionSettingsTrait: super::core::DataContainerTrait {
}

impl SuppressionSettingsTrait for SuppressionSettings {
}

impl super::core::DataContainerTrait for SuppressionSettings {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SUPPRESSIONSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SuppressionSettings",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SuppressionSettings as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SUPPRESSIONSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SuppressionSettings {
    fn type_info(&self) -> &'static TypeInfo {
        SUPPRESSIONSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SUPPRESSIONSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SuppressionSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("SuppressionSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TransformAreaQueryEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub transform: super::core::LinearTransform,
}

pub trait TransformAreaQueryEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn transform(&self) -> &super::core::LinearTransform;
}

impl TransformAreaQueryEntityDataTrait for TransformAreaQueryEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn transform(&self) -> &super::core::LinearTransform {
        &self.transform
    }
}

impl super::entity::EntityDataTrait for TransformAreaQueryEntityData {
}

impl super::entity::GameObjectDataTrait for TransformAreaQueryEntityData {
}

impl super::core::DataBusPeerTrait for TransformAreaQueryEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for TransformAreaQueryEntityData {
}

impl super::core::DataContainerTrait for TransformAreaQueryEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static TRANSFORMAREAQUERYENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformAreaQueryEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformAreaQueryEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(TransformAreaQueryEntityData, realm),
            },
            FieldInfoData {
                name: "Transform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(TransformAreaQueryEntityData, transform),
            },
        ],
    }),
    array_type: Some(TRANSFORMAREAQUERYENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for TransformAreaQueryEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMAREAQUERYENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static TRANSFORMAREAQUERYENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformAreaQueryEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("TransformAreaQueryEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TrackRespawnManagerEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub other_player_spawn_distance_threshold: f32,
    pub respawn_type: TrackRespawnType,
    pub node_forward_one_angle_cosine_space: f32,
    pub catchup_type: CoopCatchupType,
    pub catchup_distance_threshold: f32,
}

pub trait TrackRespawnManagerEntityDataTrait: super::entity::EntityDataTrait {
    fn other_player_spawn_distance_threshold(&self) -> &f32;
    fn respawn_type(&self) -> &TrackRespawnType;
    fn node_forward_one_angle_cosine_space(&self) -> &f32;
    fn catchup_type(&self) -> &CoopCatchupType;
    fn catchup_distance_threshold(&self) -> &f32;
}

impl TrackRespawnManagerEntityDataTrait for TrackRespawnManagerEntityData {
    fn other_player_spawn_distance_threshold(&self) -> &f32 {
        &self.other_player_spawn_distance_threshold
    }
    fn respawn_type(&self) -> &TrackRespawnType {
        &self.respawn_type
    }
    fn node_forward_one_angle_cosine_space(&self) -> &f32 {
        &self.node_forward_one_angle_cosine_space
    }
    fn catchup_type(&self) -> &CoopCatchupType {
        &self.catchup_type
    }
    fn catchup_distance_threshold(&self) -> &f32 {
        &self.catchup_distance_threshold
    }
}

impl super::entity::EntityDataTrait for TrackRespawnManagerEntityData {
}

impl super::entity::GameObjectDataTrait for TrackRespawnManagerEntityData {
}

impl super::core::DataBusPeerTrait for TrackRespawnManagerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for TrackRespawnManagerEntityData {
}

impl super::core::DataContainerTrait for TrackRespawnManagerEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static TRACKRESPAWNMANAGERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TrackRespawnManagerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TrackRespawnManagerEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "OtherPlayerSpawnDistanceThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TrackRespawnManagerEntityData, other_player_spawn_distance_threshold),
            },
            FieldInfoData {
                name: "RespawnType",
                flags: MemberInfoFlags::new(0),
                field_type: "TrackRespawnType",
                rust_offset: offset_of!(TrackRespawnManagerEntityData, respawn_type),
            },
            FieldInfoData {
                name: "NodeForwardOneAngleCosineSpace",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TrackRespawnManagerEntityData, node_forward_one_angle_cosine_space),
            },
            FieldInfoData {
                name: "CatchupType",
                flags: MemberInfoFlags::new(0),
                field_type: "CoopCatchupType",
                rust_offset: offset_of!(TrackRespawnManagerEntityData, catchup_type),
            },
            FieldInfoData {
                name: "CatchupDistanceThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TrackRespawnManagerEntityData, catchup_distance_threshold),
            },
        ],
    }),
    array_type: Some(TRACKRESPAWNMANAGERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TrackRespawnManagerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TRACKRESPAWNMANAGERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static TRACKRESPAWNMANAGERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TrackRespawnManagerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("TrackRespawnManagerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CoopCatchupType {
    #[default]
    CoopCatchupType_None = 0,
    CoopCatchupType_ClosestNode = 1,
}

pub static COOPCATCHUPTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoopCatchupType",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(COOPCATCHUPTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CoopCatchupType {
    fn type_info(&self) -> &'static TypeInfo {
        COOPCATCHUPTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static COOPCATCHUPTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoopCatchupType-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CoopCatchupType"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum TrackRespawnType {
    #[default]
    TrackRespawnType_ClosestNode = 0,
    TrackRespawnType_SpecificIndex = 1,
    TrackRespawnType_ClosestNodeBehindPlayer = 2,
}

pub static TRACKRESPAWNTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TrackRespawnType",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(TRACKRESPAWNTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for TrackRespawnType {
    fn type_info(&self) -> &'static TypeInfo {
        TRACKRESPAWNTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static TRACKRESPAWNTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TrackRespawnType-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("TrackRespawnType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TrackRespawnNodeEntityData {
    pub _glacier_base: super::entity::LocatorEntityData,
}

pub trait TrackRespawnNodeEntityDataTrait: super::entity::LocatorEntityDataTrait {
}

impl TrackRespawnNodeEntityDataTrait for TrackRespawnNodeEntityData {
}

impl super::entity::LocatorEntityDataTrait for TrackRespawnNodeEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
}

impl super::entity::SpatialEntityDataTrait for TrackRespawnNodeEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
}

impl super::entity::EntityDataTrait for TrackRespawnNodeEntityData {
}

impl super::entity::GameObjectDataTrait for TrackRespawnNodeEntityData {
}

impl super::core::DataBusPeerTrait for TrackRespawnNodeEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for TrackRespawnNodeEntityData {
}

impl super::core::DataContainerTrait for TrackRespawnNodeEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static TRACKRESPAWNNODEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TrackRespawnNodeEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::LOCATORENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TrackRespawnNodeEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(TRACKRESPAWNNODEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for TrackRespawnNodeEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TRACKRESPAWNNODEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static TRACKRESPAWNNODEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TrackRespawnNodeEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("TrackRespawnNodeEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TargetCyclingEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub initial_target: QueryEntityResult,
    pub target_list: QueryEntityResult,
}

pub trait TargetCyclingEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn initial_target(&self) -> &QueryEntityResult;
    fn target_list(&self) -> &QueryEntityResult;
}

impl TargetCyclingEntityDataTrait for TargetCyclingEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn initial_target(&self) -> &QueryEntityResult {
        &self.initial_target
    }
    fn target_list(&self) -> &QueryEntityResult {
        &self.target_list
    }
}

impl super::entity::EntityDataTrait for TargetCyclingEntityData {
}

impl super::entity::GameObjectDataTrait for TargetCyclingEntityData {
}

impl super::core::DataBusPeerTrait for TargetCyclingEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for TargetCyclingEntityData {
}

impl super::core::DataContainerTrait for TargetCyclingEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static TARGETCYCLINGENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TargetCyclingEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TargetCyclingEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(TargetCyclingEntityData, realm),
            },
            FieldInfoData {
                name: "InitialTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "QueryEntityResult",
                rust_offset: offset_of!(TargetCyclingEntityData, initial_target),
            },
            FieldInfoData {
                name: "TargetList",
                flags: MemberInfoFlags::new(0),
                field_type: "QueryEntityResult",
                rust_offset: offset_of!(TargetCyclingEntityData, target_list),
            },
        ],
    }),
    array_type: Some(TARGETCYCLINGENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TargetCyclingEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TARGETCYCLINGENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static TARGETCYCLINGENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TargetCyclingEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("TargetCyclingEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct StarfighterOverlapEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
}

pub trait StarfighterOverlapEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
}

impl StarfighterOverlapEntityDataTrait for StarfighterOverlapEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
}

impl super::entity::EntityDataTrait for StarfighterOverlapEntityData {
}

impl super::entity::GameObjectDataTrait for StarfighterOverlapEntityData {
}

impl super::core::DataBusPeerTrait for StarfighterOverlapEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for StarfighterOverlapEntityData {
}

impl super::core::DataContainerTrait for StarfighterOverlapEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static STARFIGHTEROVERLAPENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StarfighterOverlapEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StarfighterOverlapEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(StarfighterOverlapEntityData, realm),
            },
        ],
    }),
    array_type: Some(STARFIGHTEROVERLAPENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for StarfighterOverlapEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        STARFIGHTEROVERLAPENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static STARFIGHTEROVERLAPENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StarfighterOverlapEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("StarfighterOverlapEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct StarfighterOverlapConfigEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub is_hero_ship: bool,
    pub is_empire: bool,
}

pub trait StarfighterOverlapConfigEntityDataTrait: super::entity::EntityDataTrait {
    fn is_hero_ship(&self) -> &bool;
    fn is_empire(&self) -> &bool;
}

impl StarfighterOverlapConfigEntityDataTrait for StarfighterOverlapConfigEntityData {
    fn is_hero_ship(&self) -> &bool {
        &self.is_hero_ship
    }
    fn is_empire(&self) -> &bool {
        &self.is_empire
    }
}

impl super::entity::EntityDataTrait for StarfighterOverlapConfigEntityData {
}

impl super::entity::GameObjectDataTrait for StarfighterOverlapConfigEntityData {
}

impl super::core::DataBusPeerTrait for StarfighterOverlapConfigEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for StarfighterOverlapConfigEntityData {
}

impl super::core::DataContainerTrait for StarfighterOverlapConfigEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static STARFIGHTEROVERLAPCONFIGENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StarfighterOverlapConfigEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StarfighterOverlapConfigEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "IsHeroShip",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(StarfighterOverlapConfigEntityData, is_hero_ship),
            },
            FieldInfoData {
                name: "IsEmpire",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(StarfighterOverlapConfigEntityData, is_empire),
            },
        ],
    }),
    array_type: Some(STARFIGHTEROVERLAPCONFIGENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for StarfighterOverlapConfigEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        STARFIGHTEROVERLAPCONFIGENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static STARFIGHTEROVERLAPCONFIGENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StarfighterOverlapConfigEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("StarfighterOverlapConfigEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct StarfighterAvoidanceZoneEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub local_player_only: bool,
}

pub trait StarfighterAvoidanceZoneEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn local_player_only(&self) -> &bool;
}

impl StarfighterAvoidanceZoneEntityDataTrait for StarfighterAvoidanceZoneEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn local_player_only(&self) -> &bool {
        &self.local_player_only
    }
}

impl super::entity::EntityDataTrait for StarfighterAvoidanceZoneEntityData {
}

impl super::entity::GameObjectDataTrait for StarfighterAvoidanceZoneEntityData {
}

impl super::core::DataBusPeerTrait for StarfighterAvoidanceZoneEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for StarfighterAvoidanceZoneEntityData {
}

impl super::core::DataContainerTrait for StarfighterAvoidanceZoneEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static STARFIGHTERAVOIDANCEZONEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StarfighterAvoidanceZoneEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StarfighterAvoidanceZoneEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(StarfighterAvoidanceZoneEntityData, realm),
            },
            FieldInfoData {
                name: "LocalPlayerOnly",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(StarfighterAvoidanceZoneEntityData, local_player_only),
            },
        ],
    }),
    array_type: Some(STARFIGHTERAVOIDANCEZONEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for StarfighterAvoidanceZoneEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        STARFIGHTERAVOIDANCEZONEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static STARFIGHTERAVOIDANCEZONEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StarfighterAvoidanceZoneEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("StarfighterAvoidanceZoneEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SkiSpeederPhysicsActionData {
    pub _glacier_base: PhysicsActionBaseData,
    pub max_speed: f32,
    pub min_speed: f32,
    pub accelerator_strength: f32,
    pub boost_max_speed: f32,
    pub throttle_input: i32,
    pub strafe_input: i32,
    pub strafe_force: f32,
    pub roll_offset_angle_when_strafing: f32,
    pub turn_speed_min: f32,
    pub turn_speed_max: f32,
    pub turn_speed_in_air: f32,
    pub turn_input: i32,
    pub turn_spring_strength: f32,
    pub turn_spring_damping_coefficient: f32,
    pub turn_steer_rates: super::core::Vec3,
    pub roll_offset_angle_when_turning: f32,
    pub roll_spring_strength: f32,
    pub roll_spring_damping_coefficient: f32,
    pub side_damping: f32,
    pub ground_detection_ray_length: f32,
    pub ground_detection_ray_sweep_angle: f32,
    pub lift_coefficient_min: f32,
    pub lift_coefficient_max: f32,
    pub in_air_pitch_range_max: f32,
    pub in_air_pitch_range_min: f32,
    pub in_air_pitch_spring_strength: f32,
    pub in_air_pitch_spring_damping_coefficient: f32,
    pub align_pitch_upright_vs_velocity_direction: f32,
    pub pitch_input: i32,
}

pub trait SkiSpeederPhysicsActionDataTrait: PhysicsActionBaseDataTrait {
    fn max_speed(&self) -> &f32;
    fn min_speed(&self) -> &f32;
    fn accelerator_strength(&self) -> &f32;
    fn boost_max_speed(&self) -> &f32;
    fn throttle_input(&self) -> &i32;
    fn strafe_input(&self) -> &i32;
    fn strafe_force(&self) -> &f32;
    fn roll_offset_angle_when_strafing(&self) -> &f32;
    fn turn_speed_min(&self) -> &f32;
    fn turn_speed_max(&self) -> &f32;
    fn turn_speed_in_air(&self) -> &f32;
    fn turn_input(&self) -> &i32;
    fn turn_spring_strength(&self) -> &f32;
    fn turn_spring_damping_coefficient(&self) -> &f32;
    fn turn_steer_rates(&self) -> &super::core::Vec3;
    fn roll_offset_angle_when_turning(&self) -> &f32;
    fn roll_spring_strength(&self) -> &f32;
    fn roll_spring_damping_coefficient(&self) -> &f32;
    fn side_damping(&self) -> &f32;
    fn ground_detection_ray_length(&self) -> &f32;
    fn ground_detection_ray_sweep_angle(&self) -> &f32;
    fn lift_coefficient_min(&self) -> &f32;
    fn lift_coefficient_max(&self) -> &f32;
    fn in_air_pitch_range_max(&self) -> &f32;
    fn in_air_pitch_range_min(&self) -> &f32;
    fn in_air_pitch_spring_strength(&self) -> &f32;
    fn in_air_pitch_spring_damping_coefficient(&self) -> &f32;
    fn align_pitch_upright_vs_velocity_direction(&self) -> &f32;
    fn pitch_input(&self) -> &i32;
}

impl SkiSpeederPhysicsActionDataTrait for SkiSpeederPhysicsActionData {
    fn max_speed(&self) -> &f32 {
        &self.max_speed
    }
    fn min_speed(&self) -> &f32 {
        &self.min_speed
    }
    fn accelerator_strength(&self) -> &f32 {
        &self.accelerator_strength
    }
    fn boost_max_speed(&self) -> &f32 {
        &self.boost_max_speed
    }
    fn throttle_input(&self) -> &i32 {
        &self.throttle_input
    }
    fn strafe_input(&self) -> &i32 {
        &self.strafe_input
    }
    fn strafe_force(&self) -> &f32 {
        &self.strafe_force
    }
    fn roll_offset_angle_when_strafing(&self) -> &f32 {
        &self.roll_offset_angle_when_strafing
    }
    fn turn_speed_min(&self) -> &f32 {
        &self.turn_speed_min
    }
    fn turn_speed_max(&self) -> &f32 {
        &self.turn_speed_max
    }
    fn turn_speed_in_air(&self) -> &f32 {
        &self.turn_speed_in_air
    }
    fn turn_input(&self) -> &i32 {
        &self.turn_input
    }
    fn turn_spring_strength(&self) -> &f32 {
        &self.turn_spring_strength
    }
    fn turn_spring_damping_coefficient(&self) -> &f32 {
        &self.turn_spring_damping_coefficient
    }
    fn turn_steer_rates(&self) -> &super::core::Vec3 {
        &self.turn_steer_rates
    }
    fn roll_offset_angle_when_turning(&self) -> &f32 {
        &self.roll_offset_angle_when_turning
    }
    fn roll_spring_strength(&self) -> &f32 {
        &self.roll_spring_strength
    }
    fn roll_spring_damping_coefficient(&self) -> &f32 {
        &self.roll_spring_damping_coefficient
    }
    fn side_damping(&self) -> &f32 {
        &self.side_damping
    }
    fn ground_detection_ray_length(&self) -> &f32 {
        &self.ground_detection_ray_length
    }
    fn ground_detection_ray_sweep_angle(&self) -> &f32 {
        &self.ground_detection_ray_sweep_angle
    }
    fn lift_coefficient_min(&self) -> &f32 {
        &self.lift_coefficient_min
    }
    fn lift_coefficient_max(&self) -> &f32 {
        &self.lift_coefficient_max
    }
    fn in_air_pitch_range_max(&self) -> &f32 {
        &self.in_air_pitch_range_max
    }
    fn in_air_pitch_range_min(&self) -> &f32 {
        &self.in_air_pitch_range_min
    }
    fn in_air_pitch_spring_strength(&self) -> &f32 {
        &self.in_air_pitch_spring_strength
    }
    fn in_air_pitch_spring_damping_coefficient(&self) -> &f32 {
        &self.in_air_pitch_spring_damping_coefficient
    }
    fn align_pitch_upright_vs_velocity_direction(&self) -> &f32 {
        &self.align_pitch_upright_vs_velocity_direction
    }
    fn pitch_input(&self) -> &i32 {
        &self.pitch_input
    }
}

impl PhysicsActionBaseDataTrait for SkiSpeederPhysicsActionData {
    fn blend_factor(&self) -> &f32 {
        self._glacier_base.blend_factor()
    }
    fn input_blend_factor(&self) -> &f32 {
        self._glacier_base.input_blend_factor()
    }
    fn clamp_lin_acc(&self) -> &f32 {
        self._glacier_base.clamp_lin_acc()
    }
    fn clamp_ang_acc(&self) -> &f32 {
        self._glacier_base.clamp_ang_acc()
    }
    fn blend_factor_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.blend_factor_curve()
    }
    fn collision_response_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.collision_response_curve()
    }
}

impl super::entity::EntityDataTrait for SkiSpeederPhysicsActionData {
}

impl super::entity::GameObjectDataTrait for SkiSpeederPhysicsActionData {
}

impl super::core::DataBusPeerTrait for SkiSpeederPhysicsActionData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for SkiSpeederPhysicsActionData {
}

impl super::core::DataContainerTrait for SkiSpeederPhysicsActionData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SKISPEEDERPHYSICSACTIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SkiSpeederPhysicsActionData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PHYSICSACTIONBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SkiSpeederPhysicsActionData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MaxSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkiSpeederPhysicsActionData, max_speed),
            },
            FieldInfoData {
                name: "MinSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkiSpeederPhysicsActionData, min_speed),
            },
            FieldInfoData {
                name: "AcceleratorStrength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkiSpeederPhysicsActionData, accelerator_strength),
            },
            FieldInfoData {
                name: "BoostMaxSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkiSpeederPhysicsActionData, boost_max_speed),
            },
            FieldInfoData {
                name: "ThrottleInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SkiSpeederPhysicsActionData, throttle_input),
            },
            FieldInfoData {
                name: "StrafeInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SkiSpeederPhysicsActionData, strafe_input),
            },
            FieldInfoData {
                name: "StrafeForce",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkiSpeederPhysicsActionData, strafe_force),
            },
            FieldInfoData {
                name: "RollOffsetAngleWhenStrafing",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkiSpeederPhysicsActionData, roll_offset_angle_when_strafing),
            },
            FieldInfoData {
                name: "TurnSpeedMin",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkiSpeederPhysicsActionData, turn_speed_min),
            },
            FieldInfoData {
                name: "TurnSpeedMax",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkiSpeederPhysicsActionData, turn_speed_max),
            },
            FieldInfoData {
                name: "TurnSpeedInAir",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkiSpeederPhysicsActionData, turn_speed_in_air),
            },
            FieldInfoData {
                name: "TurnInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SkiSpeederPhysicsActionData, turn_input),
            },
            FieldInfoData {
                name: "TurnSpringStrength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkiSpeederPhysicsActionData, turn_spring_strength),
            },
            FieldInfoData {
                name: "TurnSpringDampingCoefficient",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkiSpeederPhysicsActionData, turn_spring_damping_coefficient),
            },
            FieldInfoData {
                name: "TurnSteerRates",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SkiSpeederPhysicsActionData, turn_steer_rates),
            },
            FieldInfoData {
                name: "RollOffsetAngleWhenTurning",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkiSpeederPhysicsActionData, roll_offset_angle_when_turning),
            },
            FieldInfoData {
                name: "RollSpringStrength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkiSpeederPhysicsActionData, roll_spring_strength),
            },
            FieldInfoData {
                name: "RollSpringDampingCoefficient",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkiSpeederPhysicsActionData, roll_spring_damping_coefficient),
            },
            FieldInfoData {
                name: "SideDamping",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkiSpeederPhysicsActionData, side_damping),
            },
            FieldInfoData {
                name: "GroundDetectionRayLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkiSpeederPhysicsActionData, ground_detection_ray_length),
            },
            FieldInfoData {
                name: "GroundDetectionRaySweepAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkiSpeederPhysicsActionData, ground_detection_ray_sweep_angle),
            },
            FieldInfoData {
                name: "LiftCoefficientMin",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkiSpeederPhysicsActionData, lift_coefficient_min),
            },
            FieldInfoData {
                name: "LiftCoefficientMax",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkiSpeederPhysicsActionData, lift_coefficient_max),
            },
            FieldInfoData {
                name: "InAirPitchRangeMax",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkiSpeederPhysicsActionData, in_air_pitch_range_max),
            },
            FieldInfoData {
                name: "InAirPitchRangeMin",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkiSpeederPhysicsActionData, in_air_pitch_range_min),
            },
            FieldInfoData {
                name: "InAirPitchSpringStrength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkiSpeederPhysicsActionData, in_air_pitch_spring_strength),
            },
            FieldInfoData {
                name: "InAirPitchSpringDampingCoefficient",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkiSpeederPhysicsActionData, in_air_pitch_spring_damping_coefficient),
            },
            FieldInfoData {
                name: "AlignPitchUprightVsVelocityDirection",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SkiSpeederPhysicsActionData, align_pitch_upright_vs_velocity_direction),
            },
            FieldInfoData {
                name: "PitchInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SkiSpeederPhysicsActionData, pitch_input),
            },
        ],
    }),
    array_type: Some(SKISPEEDERPHYSICSACTIONDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SkiSpeederPhysicsActionData {
    fn type_info(&self) -> &'static TypeInfo {
        SKISPEEDERPHYSICSACTIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SKISPEEDERPHYSICSACTIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SkiSpeederPhysicsActionData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("SkiSpeederPhysicsActionData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ShieldControllerEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub enabled: bool,
    pub team: super::gameplay_sim::TeamId,
    pub offset_transform: super::core::LinearTransform,
    pub shield: Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>>,
    pub max_health: f32,
    pub explosion_type: ShieldExplosionType,
    pub shield_radius: f32,
    pub shield_offset_transform: super::core::LinearTransform,
}

pub trait ShieldControllerEntityDataTrait: super::entity::EntityDataTrait {
    fn enabled(&self) -> &bool;
    fn team(&self) -> &super::gameplay_sim::TeamId;
    fn offset_transform(&self) -> &super::core::LinearTransform;
    fn shield(&self) -> &Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>>;
    fn max_health(&self) -> &f32;
    fn explosion_type(&self) -> &ShieldExplosionType;
    fn shield_radius(&self) -> &f32;
    fn shield_offset_transform(&self) -> &super::core::LinearTransform;
}

impl ShieldControllerEntityDataTrait for ShieldControllerEntityData {
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn team(&self) -> &super::gameplay_sim::TeamId {
        &self.team
    }
    fn offset_transform(&self) -> &super::core::LinearTransform {
        &self.offset_transform
    }
    fn shield(&self) -> &Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>> {
        &self.shield
    }
    fn max_health(&self) -> &f32 {
        &self.max_health
    }
    fn explosion_type(&self) -> &ShieldExplosionType {
        &self.explosion_type
    }
    fn shield_radius(&self) -> &f32 {
        &self.shield_radius
    }
    fn shield_offset_transform(&self) -> &super::core::LinearTransform {
        &self.shield_offset_transform
    }
}

impl super::entity::EntityDataTrait for ShieldControllerEntityData {
}

impl super::entity::GameObjectDataTrait for ShieldControllerEntityData {
}

impl super::core::DataBusPeerTrait for ShieldControllerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for ShieldControllerEntityData {
}

impl super::core::DataContainerTrait for ShieldControllerEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SHIELDCONTROLLERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ShieldControllerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ShieldControllerEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ShieldControllerEntityData, enabled),
            },
            FieldInfoData {
                name: "Team",
                flags: MemberInfoFlags::new(0),
                field_type: "TeamId",
                rust_offset: offset_of!(ShieldControllerEntityData, team),
            },
            FieldInfoData {
                name: "OffsetTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(ShieldControllerEntityData, offset_transform),
            },
            FieldInfoData {
                name: "Shield",
                flags: MemberInfoFlags::new(0),
                field_type: "ObjectBlueprint",
                rust_offset: offset_of!(ShieldControllerEntityData, shield),
            },
            FieldInfoData {
                name: "MaxHealth",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ShieldControllerEntityData, max_health),
            },
            FieldInfoData {
                name: "ExplosionType",
                flags: MemberInfoFlags::new(0),
                field_type: "ShieldExplosionType",
                rust_offset: offset_of!(ShieldControllerEntityData, explosion_type),
            },
            FieldInfoData {
                name: "ShieldRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ShieldControllerEntityData, shield_radius),
            },
            FieldInfoData {
                name: "ShieldOffsetTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(ShieldControllerEntityData, shield_offset_transform),
            },
        ],
    }),
    array_type: Some(SHIELDCONTROLLERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ShieldControllerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SHIELDCONTROLLERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SHIELDCONTROLLERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ShieldControllerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("ShieldControllerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum ShieldExplosionType {
    #[default]
    ShieldExplosionType_None = 0,
    ShieldExplosionType_Spherical = 1,
}

pub static SHIELDEXPLOSIONTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ShieldExplosionType",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(SHIELDEXPLOSIONTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for ShieldExplosionType {
    fn type_info(&self) -> &'static TypeInfo {
        SHIELDEXPLOSIONTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SHIELDEXPLOSIONTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ShieldExplosionType-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("ShieldExplosionType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ReceiveEventEntityData {
    pub _glacier_base: RemoteEventEntityData,
    pub dummy: bool,
}

pub trait ReceiveEventEntityDataTrait: RemoteEventEntityDataTrait {
    fn dummy(&self) -> &bool;
}

impl ReceiveEventEntityDataTrait for ReceiveEventEntityData {
    fn dummy(&self) -> &bool {
        &self.dummy
    }
}

impl RemoteEventEntityDataTrait for ReceiveEventEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn type_asset_id(&self) -> &u32 {
        self._glacier_base.type_asset_id()
    }
    fn event_ids(&self) -> &Vec<i32> {
        self._glacier_base.event_ids()
    }
    fn remote_properties(&self) -> &Vec<RemotePropertyDefinition> {
        self._glacier_base.remote_properties()
    }
    fn player_target(&self) -> &QueryEntityResult {
        self._glacier_base.player_target()
    }
    fn filter_on_player(&self) -> &bool {
        self._glacier_base.filter_on_player()
    }
}

impl super::entity::EntityDataTrait for ReceiveEventEntityData {
}

impl super::entity::GameObjectDataTrait for ReceiveEventEntityData {
}

impl super::core::DataBusPeerTrait for ReceiveEventEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for ReceiveEventEntityData {
}

impl super::core::DataContainerTrait for ReceiveEventEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static RECEIVEEVENTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReceiveEventEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(REMOTEEVENTENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ReceiveEventEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Dummy",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ReceiveEventEntityData, dummy),
            },
        ],
    }),
    array_type: Some(RECEIVEEVENTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ReceiveEventEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        RECEIVEEVENTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static RECEIVEEVENTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReceiveEventEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("ReceiveEventEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SendEventEntityData {
    pub _glacier_base: RemoteEventEntityData,
    pub dummy: bool,
}

pub trait SendEventEntityDataTrait: RemoteEventEntityDataTrait {
    fn dummy(&self) -> &bool;
}

impl SendEventEntityDataTrait for SendEventEntityData {
    fn dummy(&self) -> &bool {
        &self.dummy
    }
}

impl RemoteEventEntityDataTrait for SendEventEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn type_asset_id(&self) -> &u32 {
        self._glacier_base.type_asset_id()
    }
    fn event_ids(&self) -> &Vec<i32> {
        self._glacier_base.event_ids()
    }
    fn remote_properties(&self) -> &Vec<RemotePropertyDefinition> {
        self._glacier_base.remote_properties()
    }
    fn player_target(&self) -> &QueryEntityResult {
        self._glacier_base.player_target()
    }
    fn filter_on_player(&self) -> &bool {
        self._glacier_base.filter_on_player()
    }
}

impl super::entity::EntityDataTrait for SendEventEntityData {
}

impl super::entity::GameObjectDataTrait for SendEventEntityData {
}

impl super::core::DataBusPeerTrait for SendEventEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for SendEventEntityData {
}

impl super::core::DataContainerTrait for SendEventEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SENDEVENTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SendEventEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(REMOTEEVENTENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SendEventEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Dummy",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SendEventEntityData, dummy),
            },
        ],
    }),
    array_type: Some(SENDEVENTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SendEventEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SENDEVENTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SENDEVENTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SendEventEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("SendEventEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RemoteEventEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub type_asset_id: u32,
    pub event_ids: Vec<i32>,
    pub remote_properties: Vec<RemotePropertyDefinition>,
    pub player_target: QueryEntityResult,
    pub filter_on_player: bool,
}

pub trait RemoteEventEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn type_asset_id(&self) -> &u32;
    fn event_ids(&self) -> &Vec<i32>;
    fn remote_properties(&self) -> &Vec<RemotePropertyDefinition>;
    fn player_target(&self) -> &QueryEntityResult;
    fn filter_on_player(&self) -> &bool;
}

impl RemoteEventEntityDataTrait for RemoteEventEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn type_asset_id(&self) -> &u32 {
        &self.type_asset_id
    }
    fn event_ids(&self) -> &Vec<i32> {
        &self.event_ids
    }
    fn remote_properties(&self) -> &Vec<RemotePropertyDefinition> {
        &self.remote_properties
    }
    fn player_target(&self) -> &QueryEntityResult {
        &self.player_target
    }
    fn filter_on_player(&self) -> &bool {
        &self.filter_on_player
    }
}

impl super::entity::EntityDataTrait for RemoteEventEntityData {
}

impl super::entity::GameObjectDataTrait for RemoteEventEntityData {
}

impl super::core::DataBusPeerTrait for RemoteEventEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for RemoteEventEntityData {
}

impl super::core::DataContainerTrait for RemoteEventEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static REMOTEEVENTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RemoteEventEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RemoteEventEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(RemoteEventEntityData, realm),
            },
            FieldInfoData {
                name: "TypeAssetId",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(RemoteEventEntityData, type_asset_id),
            },
            FieldInfoData {
                name: "EventIds",
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(RemoteEventEntityData, event_ids),
            },
            FieldInfoData {
                name: "RemoteProperties",
                flags: MemberInfoFlags::new(144),
                field_type: "RemotePropertyDefinition-Array",
                rust_offset: offset_of!(RemoteEventEntityData, remote_properties),
            },
            FieldInfoData {
                name: "PlayerTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "QueryEntityResult",
                rust_offset: offset_of!(RemoteEventEntityData, player_target),
            },
            FieldInfoData {
                name: "FilterOnPlayer",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RemoteEventEntityData, filter_on_player),
            },
        ],
    }),
    array_type: Some(REMOTEEVENTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for RemoteEventEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        REMOTEEVENTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static REMOTEEVENTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RemoteEventEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("RemoteEventEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RemoteEventEntityTypeAsset {
    pub _glacier_base: super::core::DataContainerPolicyAsset,
    pub properties: Vec<RemotePropertyDefinition>,
}

pub trait RemoteEventEntityTypeAssetTrait: super::core::DataContainerPolicyAssetTrait {
    fn properties(&self) -> &Vec<RemotePropertyDefinition>;
}

impl RemoteEventEntityTypeAssetTrait for RemoteEventEntityTypeAsset {
    fn properties(&self) -> &Vec<RemotePropertyDefinition> {
        &self.properties
    }
}

impl super::core::DataContainerPolicyAssetTrait for RemoteEventEntityTypeAsset {
}

impl super::core::AssetTrait for RemoteEventEntityTypeAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for RemoteEventEntityTypeAsset {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static REMOTEEVENTENTITYTYPEASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RemoteEventEntityTypeAsset",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINERPOLICYASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RemoteEventEntityTypeAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Properties",
                flags: MemberInfoFlags::new(144),
                field_type: "RemotePropertyDefinition-Array",
                rust_offset: offset_of!(RemoteEventEntityTypeAsset, properties),
            },
        ],
    }),
    array_type: Some(REMOTEEVENTENTITYTYPEASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RemoteEventEntityTypeAsset {
    fn type_info(&self) -> &'static TypeInfo {
        REMOTEEVENTENTITYTYPEASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static REMOTEEVENTENTITYTYPEASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RemoteEventEntityTypeAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("RemoteEventEntityTypeAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RemotePropertyDefinition {
    pub property_id: i32,
    pub property_type: RemotePropertyType,
}

pub trait RemotePropertyDefinitionTrait: TypeObject {
    fn property_id(&self) -> &i32;
    fn property_type(&self) -> &RemotePropertyType;
}

impl RemotePropertyDefinitionTrait for RemotePropertyDefinition {
    fn property_id(&self) -> &i32 {
        &self.property_id
    }
    fn property_type(&self) -> &RemotePropertyType {
        &self.property_type
    }
}

pub static REMOTEPROPERTYDEFINITION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RemotePropertyDefinition",
    flags: MemberInfoFlags::new(32841),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RemotePropertyDefinition as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PropertyId",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(RemotePropertyDefinition, property_id),
            },
            FieldInfoData {
                name: "PropertyType",
                flags: MemberInfoFlags::new(0),
                field_type: "RemotePropertyType",
                rust_offset: offset_of!(RemotePropertyDefinition, property_type),
            },
        ],
    }),
    array_type: Some(REMOTEPROPERTYDEFINITION_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for RemotePropertyDefinition {
    fn type_info(&self) -> &'static TypeInfo {
        REMOTEPROPERTYDEFINITION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static REMOTEPROPERTYDEFINITION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RemotePropertyDefinition-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("RemotePropertyDefinition"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum RemotePropertyType {
    #[default]
    RemotePropertyType_Bool = 0,
    RemotePropertyType_Int = 1,
    RemotePropertyType_Float = 2,
    RemotePropertyType_String = 3,
}

pub static REMOTEPROPERTYTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RemotePropertyType",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(REMOTEPROPERTYTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for RemotePropertyType {
    fn type_info(&self) -> &'static TypeInfo {
        REMOTEPROPERTYTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static REMOTEPROPERTYTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RemotePropertyType-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("RemotePropertyType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RemoteEventEventTriggeredMessage {
}

pub trait RemoteEventEventTriggeredMessageTrait: TypeObject {
}

impl RemoteEventEventTriggeredMessageTrait for RemoteEventEventTriggeredMessage {
}

pub static REMOTEEVENTEVENTTRIGGEREDMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RemoteEventEventTriggeredMessage",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RemoteEventEventTriggeredMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for RemoteEventEventTriggeredMessage {
    fn type_info(&self) -> &'static TypeInfo {
        REMOTEEVENTEVENTTRIGGEREDMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}

#[derive(Clone, Debug, Default)]
pub struct RemoteEventProperty {
    pub property_id: i32,
    pub pointer_cast_to_int: u64,
}

pub trait RemoteEventPropertyTrait: TypeObject {
    fn property_id(&self) -> &i32;
    fn pointer_cast_to_int(&self) -> &u64;
}

impl RemoteEventPropertyTrait for RemoteEventProperty {
    fn property_id(&self) -> &i32 {
        &self.property_id
    }
    fn pointer_cast_to_int(&self) -> &u64 {
        &self.pointer_cast_to_int
    }
}

pub static REMOTEEVENTPROPERTY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RemoteEventProperty",
    flags: MemberInfoFlags::new(36937),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RemoteEventProperty as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PropertyId",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(RemoteEventProperty, property_id),
            },
            FieldInfoData {
                name: "PointerCastToInt",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint64",
                rust_offset: offset_of!(RemoteEventProperty, pointer_cast_to_int),
            },
        ],
    }),
    array_type: Some(REMOTEEVENTPROPERTY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RemoteEventProperty {
    fn type_info(&self) -> &'static TypeInfo {
        REMOTEEVENTPROPERTY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static REMOTEEVENTPROPERTY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RemoteEventProperty-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("RemoteEventProperty"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PropertyToInputEntityData {
    pub _glacier_base: super::entity::EntityData,
}

pub trait PropertyToInputEntityDataTrait: super::entity::EntityDataTrait {
}

impl PropertyToInputEntityDataTrait for PropertyToInputEntityData {
}

impl super::entity::EntityDataTrait for PropertyToInputEntityData {
}

impl super::entity::GameObjectDataTrait for PropertyToInputEntityData {
}

impl super::core::DataBusPeerTrait for PropertyToInputEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for PropertyToInputEntityData {
}

impl super::core::DataContainerTrait for PropertyToInputEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PROPERTYTOINPUTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PropertyToInputEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PropertyToInputEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(PROPERTYTOINPUTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PropertyToInputEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PROPERTYTOINPUTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PROPERTYTOINPUTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PropertyToInputEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PropertyToInputEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlayerEventToQueryResultEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub reset_on_event: bool,
    pub filtered_types: QueryEntityFilter,
}

pub trait PlayerEventToQueryResultEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn reset_on_event(&self) -> &bool;
    fn filtered_types(&self) -> &QueryEntityFilter;
}

impl PlayerEventToQueryResultEntityDataTrait for PlayerEventToQueryResultEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn reset_on_event(&self) -> &bool {
        &self.reset_on_event
    }
    fn filtered_types(&self) -> &QueryEntityFilter {
        &self.filtered_types
    }
}

impl super::entity::EntityDataTrait for PlayerEventToQueryResultEntityData {
}

impl super::entity::GameObjectDataTrait for PlayerEventToQueryResultEntityData {
}

impl super::core::DataBusPeerTrait for PlayerEventToQueryResultEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for PlayerEventToQueryResultEntityData {
}

impl super::core::DataContainerTrait for PlayerEventToQueryResultEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PLAYEREVENTTOQUERYRESULTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerEventToQueryResultEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayerEventToQueryResultEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(PlayerEventToQueryResultEntityData, realm),
            },
            FieldInfoData {
                name: "ResetOnEvent",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayerEventToQueryResultEntityData, reset_on_event),
            },
            FieldInfoData {
                name: "FilteredTypes",
                flags: MemberInfoFlags::new(0),
                field_type: "QueryEntityFilter",
                rust_offset: offset_of!(PlayerEventToQueryResultEntityData, filtered_types),
            },
        ],
    }),
    array_type: Some(PLAYEREVENTTOQUERYRESULTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PlayerEventToQueryResultEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYEREVENTTOQUERYRESULTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PLAYEREVENTTOQUERYRESULTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerEventToQueryResultEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PlayerEventToQueryResultEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PhysicsLockHeightVolumeEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub allow_overlapping_volumes: bool,
    pub apply_raycast_culling_for_speederbike_physics: bool,
    pub apply_raycast_culling_for_hover_tank_physics: bool,
}

pub trait PhysicsLockHeightVolumeEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn allow_overlapping_volumes(&self) -> &bool;
    fn apply_raycast_culling_for_speederbike_physics(&self) -> &bool;
    fn apply_raycast_culling_for_hover_tank_physics(&self) -> &bool;
}

impl PhysicsLockHeightVolumeEntityDataTrait for PhysicsLockHeightVolumeEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn allow_overlapping_volumes(&self) -> &bool {
        &self.allow_overlapping_volumes
    }
    fn apply_raycast_culling_for_speederbike_physics(&self) -> &bool {
        &self.apply_raycast_culling_for_speederbike_physics
    }
    fn apply_raycast_culling_for_hover_tank_physics(&self) -> &bool {
        &self.apply_raycast_culling_for_hover_tank_physics
    }
}

impl super::entity::EntityDataTrait for PhysicsLockHeightVolumeEntityData {
}

impl super::entity::GameObjectDataTrait for PhysicsLockHeightVolumeEntityData {
}

impl super::core::DataBusPeerTrait for PhysicsLockHeightVolumeEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for PhysicsLockHeightVolumeEntityData {
}

impl super::core::DataContainerTrait for PhysicsLockHeightVolumeEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PHYSICSLOCKHEIGHTVOLUMEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsLockHeightVolumeEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PhysicsLockHeightVolumeEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(PhysicsLockHeightVolumeEntityData, realm),
            },
            FieldInfoData {
                name: "AllowOverlappingVolumes",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PhysicsLockHeightVolumeEntityData, allow_overlapping_volumes),
            },
            FieldInfoData {
                name: "ApplyRaycastCullingForSpeederbikePhysics",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PhysicsLockHeightVolumeEntityData, apply_raycast_culling_for_speederbike_physics),
            },
            FieldInfoData {
                name: "ApplyRaycastCullingForHoverTankPhysics",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PhysicsLockHeightVolumeEntityData, apply_raycast_culling_for_hover_tank_physics),
            },
        ],
    }),
    array_type: Some(PHYSICSLOCKHEIGHTVOLUMEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PhysicsLockHeightVolumeEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PHYSICSLOCKHEIGHTVOLUMEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PHYSICSLOCKHEIGHTVOLUMEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsLockHeightVolumeEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PhysicsLockHeightVolumeEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PhysicsFilterMetadataEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub ignored_by_raycasts_from_a_a_t_hover_lift: bool,
}

pub trait PhysicsFilterMetadataEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn ignored_by_raycasts_from_a_a_t_hover_lift(&self) -> &bool;
}

impl PhysicsFilterMetadataEntityDataTrait for PhysicsFilterMetadataEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn ignored_by_raycasts_from_a_a_t_hover_lift(&self) -> &bool {
        &self.ignored_by_raycasts_from_a_a_t_hover_lift
    }
}

impl super::entity::EntityDataTrait for PhysicsFilterMetadataEntityData {
}

impl super::entity::GameObjectDataTrait for PhysicsFilterMetadataEntityData {
}

impl super::core::DataBusPeerTrait for PhysicsFilterMetadataEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for PhysicsFilterMetadataEntityData {
}

impl super::core::DataContainerTrait for PhysicsFilterMetadataEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PHYSICSFILTERMETADATAENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsFilterMetadataEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PhysicsFilterMetadataEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(PhysicsFilterMetadataEntityData, realm),
            },
            FieldInfoData {
                name: "IgnoredByRaycastsFromAATHoverLift",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PhysicsFilterMetadataEntityData, ignored_by_raycasts_from_a_a_t_hover_lift),
            },
        ],
    }),
    array_type: Some(PHYSICSFILTERMETADATAENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PhysicsFilterMetadataEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PHYSICSFILTERMETADATAENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PHYSICSFILTERMETADATAENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsFilterMetadataEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PhysicsFilterMetadataEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct StarfighterCollisionRepulsorPhysicsActionData {
    pub _glacier_base: PhysicsActionBaseData,
    pub default_evasive_input_pitch_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
    pub default_evasive_input_roll_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
    pub default_evasive_input_yaw_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
    pub default_evasive_input_throttle_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
    pub rear_ending_evasive_input_pitch_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
    pub rear_ending_evasive_input_roll_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
    pub rear_ending_evasive_input_yaw_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
    pub rear_ending_evasive_input_throttle_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
    pub side_swipe_evasive_input_pitch_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
    pub side_swipe_evasive_input_roll_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
    pub side_swipe_evasive_input_yaw_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
    pub side_swipe_evasive_input_throttle_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
    pub head_on_evasive_input_pitch_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
    pub head_on_evasive_input_roll_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
    pub head_on_evasive_input_yaw_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
    pub head_on_evasive_input_throttle_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
    pub t_bone_evasive_input_pitch_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
    pub t_bone_evasive_input_roll_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
    pub t_bone_evasive_input_yaw_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
    pub t_bone_evasive_input_throttle_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
    pub rear_end_target_speed_percentage: f32,
    pub use_rear_end_speed_percentage: bool,
    pub allow_default_collisions: bool,
    pub allow_head_on_collisions: bool,
    pub allow_rear_end_collisions: bool,
    pub allow_t_bone_collisions: bool,
    pub allow_side_swipe_collisions: bool,
    pub min_closing_speed_default: f32,
    pub min_closing_speed_rear_end: f32,
    pub min_closing_speed_side_swipe: f32,
    pub min_closing_speed_head_on: f32,
    pub min_closing_speed_t_bone: f32,
    pub max_angle_for_head_on: f32,
    pub max_angle_for_side_swipe: f32,
    pub max_angle_for_t_bone: f32,
    pub max_angle_for_rear_end: f32,
    pub client_move_frame: super::core::LinearTransform,
}

pub trait StarfighterCollisionRepulsorPhysicsActionDataTrait: PhysicsActionBaseDataTrait {
    fn default_evasive_input_pitch_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn default_evasive_input_roll_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn default_evasive_input_yaw_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn default_evasive_input_throttle_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn rear_ending_evasive_input_pitch_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn rear_ending_evasive_input_roll_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn rear_ending_evasive_input_yaw_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn rear_ending_evasive_input_throttle_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn side_swipe_evasive_input_pitch_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn side_swipe_evasive_input_roll_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn side_swipe_evasive_input_yaw_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn side_swipe_evasive_input_throttle_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn head_on_evasive_input_pitch_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn head_on_evasive_input_roll_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn head_on_evasive_input_yaw_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn head_on_evasive_input_throttle_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn t_bone_evasive_input_pitch_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn t_bone_evasive_input_roll_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn t_bone_evasive_input_yaw_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn t_bone_evasive_input_throttle_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn rear_end_target_speed_percentage(&self) -> &f32;
    fn use_rear_end_speed_percentage(&self) -> &bool;
    fn allow_default_collisions(&self) -> &bool;
    fn allow_head_on_collisions(&self) -> &bool;
    fn allow_rear_end_collisions(&self) -> &bool;
    fn allow_t_bone_collisions(&self) -> &bool;
    fn allow_side_swipe_collisions(&self) -> &bool;
    fn min_closing_speed_default(&self) -> &f32;
    fn min_closing_speed_rear_end(&self) -> &f32;
    fn min_closing_speed_side_swipe(&self) -> &f32;
    fn min_closing_speed_head_on(&self) -> &f32;
    fn min_closing_speed_t_bone(&self) -> &f32;
    fn max_angle_for_head_on(&self) -> &f32;
    fn max_angle_for_side_swipe(&self) -> &f32;
    fn max_angle_for_t_bone(&self) -> &f32;
    fn max_angle_for_rear_end(&self) -> &f32;
    fn client_move_frame(&self) -> &super::core::LinearTransform;
}

impl StarfighterCollisionRepulsorPhysicsActionDataTrait for StarfighterCollisionRepulsorPhysicsActionData {
    fn default_evasive_input_pitch_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.default_evasive_input_pitch_curve
    }
    fn default_evasive_input_roll_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.default_evasive_input_roll_curve
    }
    fn default_evasive_input_yaw_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.default_evasive_input_yaw_curve
    }
    fn default_evasive_input_throttle_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.default_evasive_input_throttle_curve
    }
    fn rear_ending_evasive_input_pitch_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.rear_ending_evasive_input_pitch_curve
    }
    fn rear_ending_evasive_input_roll_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.rear_ending_evasive_input_roll_curve
    }
    fn rear_ending_evasive_input_yaw_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.rear_ending_evasive_input_yaw_curve
    }
    fn rear_ending_evasive_input_throttle_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.rear_ending_evasive_input_throttle_curve
    }
    fn side_swipe_evasive_input_pitch_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.side_swipe_evasive_input_pitch_curve
    }
    fn side_swipe_evasive_input_roll_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.side_swipe_evasive_input_roll_curve
    }
    fn side_swipe_evasive_input_yaw_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.side_swipe_evasive_input_yaw_curve
    }
    fn side_swipe_evasive_input_throttle_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.side_swipe_evasive_input_throttle_curve
    }
    fn head_on_evasive_input_pitch_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.head_on_evasive_input_pitch_curve
    }
    fn head_on_evasive_input_roll_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.head_on_evasive_input_roll_curve
    }
    fn head_on_evasive_input_yaw_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.head_on_evasive_input_yaw_curve
    }
    fn head_on_evasive_input_throttle_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.head_on_evasive_input_throttle_curve
    }
    fn t_bone_evasive_input_pitch_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.t_bone_evasive_input_pitch_curve
    }
    fn t_bone_evasive_input_roll_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.t_bone_evasive_input_roll_curve
    }
    fn t_bone_evasive_input_yaw_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.t_bone_evasive_input_yaw_curve
    }
    fn t_bone_evasive_input_throttle_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.t_bone_evasive_input_throttle_curve
    }
    fn rear_end_target_speed_percentage(&self) -> &f32 {
        &self.rear_end_target_speed_percentage
    }
    fn use_rear_end_speed_percentage(&self) -> &bool {
        &self.use_rear_end_speed_percentage
    }
    fn allow_default_collisions(&self) -> &bool {
        &self.allow_default_collisions
    }
    fn allow_head_on_collisions(&self) -> &bool {
        &self.allow_head_on_collisions
    }
    fn allow_rear_end_collisions(&self) -> &bool {
        &self.allow_rear_end_collisions
    }
    fn allow_t_bone_collisions(&self) -> &bool {
        &self.allow_t_bone_collisions
    }
    fn allow_side_swipe_collisions(&self) -> &bool {
        &self.allow_side_swipe_collisions
    }
    fn min_closing_speed_default(&self) -> &f32 {
        &self.min_closing_speed_default
    }
    fn min_closing_speed_rear_end(&self) -> &f32 {
        &self.min_closing_speed_rear_end
    }
    fn min_closing_speed_side_swipe(&self) -> &f32 {
        &self.min_closing_speed_side_swipe
    }
    fn min_closing_speed_head_on(&self) -> &f32 {
        &self.min_closing_speed_head_on
    }
    fn min_closing_speed_t_bone(&self) -> &f32 {
        &self.min_closing_speed_t_bone
    }
    fn max_angle_for_head_on(&self) -> &f32 {
        &self.max_angle_for_head_on
    }
    fn max_angle_for_side_swipe(&self) -> &f32 {
        &self.max_angle_for_side_swipe
    }
    fn max_angle_for_t_bone(&self) -> &f32 {
        &self.max_angle_for_t_bone
    }
    fn max_angle_for_rear_end(&self) -> &f32 {
        &self.max_angle_for_rear_end
    }
    fn client_move_frame(&self) -> &super::core::LinearTransform {
        &self.client_move_frame
    }
}

impl PhysicsActionBaseDataTrait for StarfighterCollisionRepulsorPhysicsActionData {
    fn blend_factor(&self) -> &f32 {
        self._glacier_base.blend_factor()
    }
    fn input_blend_factor(&self) -> &f32 {
        self._glacier_base.input_blend_factor()
    }
    fn clamp_lin_acc(&self) -> &f32 {
        self._glacier_base.clamp_lin_acc()
    }
    fn clamp_ang_acc(&self) -> &f32 {
        self._glacier_base.clamp_ang_acc()
    }
    fn blend_factor_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.blend_factor_curve()
    }
    fn collision_response_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.collision_response_curve()
    }
}

impl super::entity::EntityDataTrait for StarfighterCollisionRepulsorPhysicsActionData {
}

impl super::entity::GameObjectDataTrait for StarfighterCollisionRepulsorPhysicsActionData {
}

impl super::core::DataBusPeerTrait for StarfighterCollisionRepulsorPhysicsActionData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for StarfighterCollisionRepulsorPhysicsActionData {
}

impl super::core::DataContainerTrait for StarfighterCollisionRepulsorPhysicsActionData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static STARFIGHTERCOLLISIONREPULSORPHYSICSACTIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StarfighterCollisionRepulsorPhysicsActionData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PHYSICSACTIONBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StarfighterCollisionRepulsorPhysicsActionData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DefaultEvasiveInputPitchCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(StarfighterCollisionRepulsorPhysicsActionData, default_evasive_input_pitch_curve),
            },
            FieldInfoData {
                name: "DefaultEvasiveInputRollCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(StarfighterCollisionRepulsorPhysicsActionData, default_evasive_input_roll_curve),
            },
            FieldInfoData {
                name: "DefaultEvasiveInputYawCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(StarfighterCollisionRepulsorPhysicsActionData, default_evasive_input_yaw_curve),
            },
            FieldInfoData {
                name: "DefaultEvasiveInputThrottleCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(StarfighterCollisionRepulsorPhysicsActionData, default_evasive_input_throttle_curve),
            },
            FieldInfoData {
                name: "RearEndingEvasiveInputPitchCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(StarfighterCollisionRepulsorPhysicsActionData, rear_ending_evasive_input_pitch_curve),
            },
            FieldInfoData {
                name: "RearEndingEvasiveInputRollCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(StarfighterCollisionRepulsorPhysicsActionData, rear_ending_evasive_input_roll_curve),
            },
            FieldInfoData {
                name: "RearEndingEvasiveInputYawCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(StarfighterCollisionRepulsorPhysicsActionData, rear_ending_evasive_input_yaw_curve),
            },
            FieldInfoData {
                name: "RearEndingEvasiveInputThrottleCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(StarfighterCollisionRepulsorPhysicsActionData, rear_ending_evasive_input_throttle_curve),
            },
            FieldInfoData {
                name: "SideSwipeEvasiveInputPitchCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(StarfighterCollisionRepulsorPhysicsActionData, side_swipe_evasive_input_pitch_curve),
            },
            FieldInfoData {
                name: "SideSwipeEvasiveInputRollCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(StarfighterCollisionRepulsorPhysicsActionData, side_swipe_evasive_input_roll_curve),
            },
            FieldInfoData {
                name: "SideSwipeEvasiveInputYawCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(StarfighterCollisionRepulsorPhysicsActionData, side_swipe_evasive_input_yaw_curve),
            },
            FieldInfoData {
                name: "SideSwipeEvasiveInputThrottleCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(StarfighterCollisionRepulsorPhysicsActionData, side_swipe_evasive_input_throttle_curve),
            },
            FieldInfoData {
                name: "HeadOnEvasiveInputPitchCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(StarfighterCollisionRepulsorPhysicsActionData, head_on_evasive_input_pitch_curve),
            },
            FieldInfoData {
                name: "HeadOnEvasiveInputRollCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(StarfighterCollisionRepulsorPhysicsActionData, head_on_evasive_input_roll_curve),
            },
            FieldInfoData {
                name: "HeadOnEvasiveInputYawCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(StarfighterCollisionRepulsorPhysicsActionData, head_on_evasive_input_yaw_curve),
            },
            FieldInfoData {
                name: "HeadOnEvasiveInputThrottleCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(StarfighterCollisionRepulsorPhysicsActionData, head_on_evasive_input_throttle_curve),
            },
            FieldInfoData {
                name: "TBoneEvasiveInputPitchCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(StarfighterCollisionRepulsorPhysicsActionData, t_bone_evasive_input_pitch_curve),
            },
            FieldInfoData {
                name: "TBoneEvasiveInputRollCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(StarfighterCollisionRepulsorPhysicsActionData, t_bone_evasive_input_roll_curve),
            },
            FieldInfoData {
                name: "TBoneEvasiveInputYawCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(StarfighterCollisionRepulsorPhysicsActionData, t_bone_evasive_input_yaw_curve),
            },
            FieldInfoData {
                name: "TBoneEvasiveInputThrottleCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(StarfighterCollisionRepulsorPhysicsActionData, t_bone_evasive_input_throttle_curve),
            },
            FieldInfoData {
                name: "RearEndTargetSpeedPercentage",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterCollisionRepulsorPhysicsActionData, rear_end_target_speed_percentage),
            },
            FieldInfoData {
                name: "UseRearEndSpeedPercentage",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(StarfighterCollisionRepulsorPhysicsActionData, use_rear_end_speed_percentage),
            },
            FieldInfoData {
                name: "AllowDefaultCollisions",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(StarfighterCollisionRepulsorPhysicsActionData, allow_default_collisions),
            },
            FieldInfoData {
                name: "AllowHeadOnCollisions",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(StarfighterCollisionRepulsorPhysicsActionData, allow_head_on_collisions),
            },
            FieldInfoData {
                name: "AllowRearEndCollisions",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(StarfighterCollisionRepulsorPhysicsActionData, allow_rear_end_collisions),
            },
            FieldInfoData {
                name: "AllowTBoneCollisions",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(StarfighterCollisionRepulsorPhysicsActionData, allow_t_bone_collisions),
            },
            FieldInfoData {
                name: "AllowSideSwipeCollisions",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(StarfighterCollisionRepulsorPhysicsActionData, allow_side_swipe_collisions),
            },
            FieldInfoData {
                name: "MinClosingSpeedDefault",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterCollisionRepulsorPhysicsActionData, min_closing_speed_default),
            },
            FieldInfoData {
                name: "MinClosingSpeedRearEnd",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterCollisionRepulsorPhysicsActionData, min_closing_speed_rear_end),
            },
            FieldInfoData {
                name: "MinClosingSpeedSideSwipe",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterCollisionRepulsorPhysicsActionData, min_closing_speed_side_swipe),
            },
            FieldInfoData {
                name: "MinClosingSpeedHeadOn",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterCollisionRepulsorPhysicsActionData, min_closing_speed_head_on),
            },
            FieldInfoData {
                name: "MinClosingSpeedTBone",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterCollisionRepulsorPhysicsActionData, min_closing_speed_t_bone),
            },
            FieldInfoData {
                name: "MaxAngleForHeadOn",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterCollisionRepulsorPhysicsActionData, max_angle_for_head_on),
            },
            FieldInfoData {
                name: "MaxAngleForSideSwipe",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterCollisionRepulsorPhysicsActionData, max_angle_for_side_swipe),
            },
            FieldInfoData {
                name: "MaxAngleForTBone",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterCollisionRepulsorPhysicsActionData, max_angle_for_t_bone),
            },
            FieldInfoData {
                name: "MaxAngleForRearEnd",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterCollisionRepulsorPhysicsActionData, max_angle_for_rear_end),
            },
            FieldInfoData {
                name: "ClientMoveFrame",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(StarfighterCollisionRepulsorPhysicsActionData, client_move_frame),
            },
        ],
    }),
    array_type: Some(STARFIGHTERCOLLISIONREPULSORPHYSICSACTIONDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for StarfighterCollisionRepulsorPhysicsActionData {
    fn type_info(&self) -> &'static TypeInfo {
        STARFIGHTERCOLLISIONREPULSORPHYSICSACTIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static STARFIGHTERCOLLISIONREPULSORPHYSICSACTIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StarfighterCollisionRepulsorPhysicsActionData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("StarfighterCollisionRepulsorPhysicsActionData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct StarfighterSpinoutPhysicsActionData {
    pub _glacier_base: PhysicsActionBaseData,
    pub pitch_speed_to_add: f32,
    pub roll_speed_to_add: f32,
    pub spinout_time: f32,
}

pub trait StarfighterSpinoutPhysicsActionDataTrait: PhysicsActionBaseDataTrait {
    fn pitch_speed_to_add(&self) -> &f32;
    fn roll_speed_to_add(&self) -> &f32;
    fn spinout_time(&self) -> &f32;
}

impl StarfighterSpinoutPhysicsActionDataTrait for StarfighterSpinoutPhysicsActionData {
    fn pitch_speed_to_add(&self) -> &f32 {
        &self.pitch_speed_to_add
    }
    fn roll_speed_to_add(&self) -> &f32 {
        &self.roll_speed_to_add
    }
    fn spinout_time(&self) -> &f32 {
        &self.spinout_time
    }
}

impl PhysicsActionBaseDataTrait for StarfighterSpinoutPhysicsActionData {
    fn blend_factor(&self) -> &f32 {
        self._glacier_base.blend_factor()
    }
    fn input_blend_factor(&self) -> &f32 {
        self._glacier_base.input_blend_factor()
    }
    fn clamp_lin_acc(&self) -> &f32 {
        self._glacier_base.clamp_lin_acc()
    }
    fn clamp_ang_acc(&self) -> &f32 {
        self._glacier_base.clamp_ang_acc()
    }
    fn blend_factor_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.blend_factor_curve()
    }
    fn collision_response_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.collision_response_curve()
    }
}

impl super::entity::EntityDataTrait for StarfighterSpinoutPhysicsActionData {
}

impl super::entity::GameObjectDataTrait for StarfighterSpinoutPhysicsActionData {
}

impl super::core::DataBusPeerTrait for StarfighterSpinoutPhysicsActionData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for StarfighterSpinoutPhysicsActionData {
}

impl super::core::DataContainerTrait for StarfighterSpinoutPhysicsActionData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static STARFIGHTERSPINOUTPHYSICSACTIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StarfighterSpinoutPhysicsActionData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PHYSICSACTIONBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StarfighterSpinoutPhysicsActionData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PitchSpeedToAdd",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterSpinoutPhysicsActionData, pitch_speed_to_add),
            },
            FieldInfoData {
                name: "RollSpeedToAdd",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterSpinoutPhysicsActionData, roll_speed_to_add),
            },
            FieldInfoData {
                name: "SpinoutTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterSpinoutPhysicsActionData, spinout_time),
            },
        ],
    }),
    array_type: Some(STARFIGHTERSPINOUTPHYSICSACTIONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for StarfighterSpinoutPhysicsActionData {
    fn type_info(&self) -> &'static TypeInfo {
        STARFIGHTERSPINOUTPHYSICSACTIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static STARFIGHTERSPINOUTPHYSICSACTIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StarfighterSpinoutPhysicsActionData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("StarfighterSpinoutPhysicsActionData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct HoverTankPhysicsActionData {
    pub _glacier_base: PhysicsActionBaseData,
    pub input_action_yaw: i32,
    pub input_action_pitch: i32,
    pub input_action_throttle: i32,
    pub input_action_strafe: i32,
    pub input_action_zoom: i32,
    pub input_pilot_zoom_threshold: f32,
    pub r_s_turn_pow: f32,
    pub r_s_turn_pow_user_setting_deviation: f32,
    pub target_linear_speed: super::core::Vec3,
    pub target_linear_speed_zoomed: super::core::Vec3,
    pub driving_axis_force: super::core::Vec2,
    pub steer_rate_throttle: super::core::Vec3,
    pub steer_rate_strafe: super::core::Vec3,
    pub target_yaw_vel: f32,
    pub target_yaw_vel_zoomed: f32,
    pub yaw_torque: f32,
    pub steer_rate_yaw: super::core::Vec3,
    pub in_air_control_fade: f32,
    pub boost_fade_smoothing: f32,
    pub boost_target_speed: super::core::Vec3,
    pub boost_target_yaw_vel: f32,
    pub siege_mode_target_speed: super::core::Vec3,
    pub siege_mode_target_yaw_vel: f32,
    pub siege_mode_handling_smoothing: f32,
    pub in_air_factor: f32,
    pub siege_mode_factor: f32,
    pub is_boosting: bool,
    pub vehicle_up_normal: super::core::Vec3,
}

pub trait HoverTankPhysicsActionDataTrait: PhysicsActionBaseDataTrait {
    fn input_action_yaw(&self) -> &i32;
    fn input_action_pitch(&self) -> &i32;
    fn input_action_throttle(&self) -> &i32;
    fn input_action_strafe(&self) -> &i32;
    fn input_action_zoom(&self) -> &i32;
    fn input_pilot_zoom_threshold(&self) -> &f32;
    fn r_s_turn_pow(&self) -> &f32;
    fn r_s_turn_pow_user_setting_deviation(&self) -> &f32;
    fn target_linear_speed(&self) -> &super::core::Vec3;
    fn target_linear_speed_zoomed(&self) -> &super::core::Vec3;
    fn driving_axis_force(&self) -> &super::core::Vec2;
    fn steer_rate_throttle(&self) -> &super::core::Vec3;
    fn steer_rate_strafe(&self) -> &super::core::Vec3;
    fn target_yaw_vel(&self) -> &f32;
    fn target_yaw_vel_zoomed(&self) -> &f32;
    fn yaw_torque(&self) -> &f32;
    fn steer_rate_yaw(&self) -> &super::core::Vec3;
    fn in_air_control_fade(&self) -> &f32;
    fn boost_fade_smoothing(&self) -> &f32;
    fn boost_target_speed(&self) -> &super::core::Vec3;
    fn boost_target_yaw_vel(&self) -> &f32;
    fn siege_mode_target_speed(&self) -> &super::core::Vec3;
    fn siege_mode_target_yaw_vel(&self) -> &f32;
    fn siege_mode_handling_smoothing(&self) -> &f32;
    fn in_air_factor(&self) -> &f32;
    fn siege_mode_factor(&self) -> &f32;
    fn is_boosting(&self) -> &bool;
    fn vehicle_up_normal(&self) -> &super::core::Vec3;
}

impl HoverTankPhysicsActionDataTrait for HoverTankPhysicsActionData {
    fn input_action_yaw(&self) -> &i32 {
        &self.input_action_yaw
    }
    fn input_action_pitch(&self) -> &i32 {
        &self.input_action_pitch
    }
    fn input_action_throttle(&self) -> &i32 {
        &self.input_action_throttle
    }
    fn input_action_strafe(&self) -> &i32 {
        &self.input_action_strafe
    }
    fn input_action_zoom(&self) -> &i32 {
        &self.input_action_zoom
    }
    fn input_pilot_zoom_threshold(&self) -> &f32 {
        &self.input_pilot_zoom_threshold
    }
    fn r_s_turn_pow(&self) -> &f32 {
        &self.r_s_turn_pow
    }
    fn r_s_turn_pow_user_setting_deviation(&self) -> &f32 {
        &self.r_s_turn_pow_user_setting_deviation
    }
    fn target_linear_speed(&self) -> &super::core::Vec3 {
        &self.target_linear_speed
    }
    fn target_linear_speed_zoomed(&self) -> &super::core::Vec3 {
        &self.target_linear_speed_zoomed
    }
    fn driving_axis_force(&self) -> &super::core::Vec2 {
        &self.driving_axis_force
    }
    fn steer_rate_throttle(&self) -> &super::core::Vec3 {
        &self.steer_rate_throttle
    }
    fn steer_rate_strafe(&self) -> &super::core::Vec3 {
        &self.steer_rate_strafe
    }
    fn target_yaw_vel(&self) -> &f32 {
        &self.target_yaw_vel
    }
    fn target_yaw_vel_zoomed(&self) -> &f32 {
        &self.target_yaw_vel_zoomed
    }
    fn yaw_torque(&self) -> &f32 {
        &self.yaw_torque
    }
    fn steer_rate_yaw(&self) -> &super::core::Vec3 {
        &self.steer_rate_yaw
    }
    fn in_air_control_fade(&self) -> &f32 {
        &self.in_air_control_fade
    }
    fn boost_fade_smoothing(&self) -> &f32 {
        &self.boost_fade_smoothing
    }
    fn boost_target_speed(&self) -> &super::core::Vec3 {
        &self.boost_target_speed
    }
    fn boost_target_yaw_vel(&self) -> &f32 {
        &self.boost_target_yaw_vel
    }
    fn siege_mode_target_speed(&self) -> &super::core::Vec3 {
        &self.siege_mode_target_speed
    }
    fn siege_mode_target_yaw_vel(&self) -> &f32 {
        &self.siege_mode_target_yaw_vel
    }
    fn siege_mode_handling_smoothing(&self) -> &f32 {
        &self.siege_mode_handling_smoothing
    }
    fn in_air_factor(&self) -> &f32 {
        &self.in_air_factor
    }
    fn siege_mode_factor(&self) -> &f32 {
        &self.siege_mode_factor
    }
    fn is_boosting(&self) -> &bool {
        &self.is_boosting
    }
    fn vehicle_up_normal(&self) -> &super::core::Vec3 {
        &self.vehicle_up_normal
    }
}

impl PhysicsActionBaseDataTrait for HoverTankPhysicsActionData {
    fn blend_factor(&self) -> &f32 {
        self._glacier_base.blend_factor()
    }
    fn input_blend_factor(&self) -> &f32 {
        self._glacier_base.input_blend_factor()
    }
    fn clamp_lin_acc(&self) -> &f32 {
        self._glacier_base.clamp_lin_acc()
    }
    fn clamp_ang_acc(&self) -> &f32 {
        self._glacier_base.clamp_ang_acc()
    }
    fn blend_factor_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.blend_factor_curve()
    }
    fn collision_response_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.collision_response_curve()
    }
}

impl super::entity::EntityDataTrait for HoverTankPhysicsActionData {
}

impl super::entity::GameObjectDataTrait for HoverTankPhysicsActionData {
}

impl super::core::DataBusPeerTrait for HoverTankPhysicsActionData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for HoverTankPhysicsActionData {
}

impl super::core::DataContainerTrait for HoverTankPhysicsActionData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static HOVERTANKPHYSICSACTIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HoverTankPhysicsActionData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PHYSICSACTIONBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<HoverTankPhysicsActionData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "InputActionYaw",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(HoverTankPhysicsActionData, input_action_yaw),
            },
            FieldInfoData {
                name: "InputActionPitch",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(HoverTankPhysicsActionData, input_action_pitch),
            },
            FieldInfoData {
                name: "InputActionThrottle",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(HoverTankPhysicsActionData, input_action_throttle),
            },
            FieldInfoData {
                name: "InputActionStrafe",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(HoverTankPhysicsActionData, input_action_strafe),
            },
            FieldInfoData {
                name: "InputActionZoom",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(HoverTankPhysicsActionData, input_action_zoom),
            },
            FieldInfoData {
                name: "InputPilotZoomThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverTankPhysicsActionData, input_pilot_zoom_threshold),
            },
            FieldInfoData {
                name: "RSTurnPow",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverTankPhysicsActionData, r_s_turn_pow),
            },
            FieldInfoData {
                name: "RSTurnPowUserSettingDeviation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverTankPhysicsActionData, r_s_turn_pow_user_setting_deviation),
            },
            FieldInfoData {
                name: "TargetLinearSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(HoverTankPhysicsActionData, target_linear_speed),
            },
            FieldInfoData {
                name: "TargetLinearSpeedZoomed",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(HoverTankPhysicsActionData, target_linear_speed_zoomed),
            },
            FieldInfoData {
                name: "DrivingAxisForce",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(HoverTankPhysicsActionData, driving_axis_force),
            },
            FieldInfoData {
                name: "SteerRateThrottle",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(HoverTankPhysicsActionData, steer_rate_throttle),
            },
            FieldInfoData {
                name: "SteerRateStrafe",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(HoverTankPhysicsActionData, steer_rate_strafe),
            },
            FieldInfoData {
                name: "TargetYawVel",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverTankPhysicsActionData, target_yaw_vel),
            },
            FieldInfoData {
                name: "TargetYawVelZoomed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverTankPhysicsActionData, target_yaw_vel_zoomed),
            },
            FieldInfoData {
                name: "YawTorque",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverTankPhysicsActionData, yaw_torque),
            },
            FieldInfoData {
                name: "SteerRateYaw",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(HoverTankPhysicsActionData, steer_rate_yaw),
            },
            FieldInfoData {
                name: "InAirControlFade",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverTankPhysicsActionData, in_air_control_fade),
            },
            FieldInfoData {
                name: "BoostFadeSmoothing",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverTankPhysicsActionData, boost_fade_smoothing),
            },
            FieldInfoData {
                name: "BoostTargetSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(HoverTankPhysicsActionData, boost_target_speed),
            },
            FieldInfoData {
                name: "BoostTargetYawVel",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverTankPhysicsActionData, boost_target_yaw_vel),
            },
            FieldInfoData {
                name: "SiegeModeTargetSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(HoverTankPhysicsActionData, siege_mode_target_speed),
            },
            FieldInfoData {
                name: "SiegeModeTargetYawVel",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverTankPhysicsActionData, siege_mode_target_yaw_vel),
            },
            FieldInfoData {
                name: "SiegeModeHandlingSmoothing",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverTankPhysicsActionData, siege_mode_handling_smoothing),
            },
            FieldInfoData {
                name: "InAirFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverTankPhysicsActionData, in_air_factor),
            },
            FieldInfoData {
                name: "SiegeModeFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverTankPhysicsActionData, siege_mode_factor),
            },
            FieldInfoData {
                name: "IsBoosting",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(HoverTankPhysicsActionData, is_boosting),
            },
            FieldInfoData {
                name: "VehicleUpNormal",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(HoverTankPhysicsActionData, vehicle_up_normal),
            },
        ],
    }),
    array_type: Some(HOVERTANKPHYSICSACTIONDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for HoverTankPhysicsActionData {
    fn type_info(&self) -> &'static TypeInfo {
        HOVERTANKPHYSICSACTIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static HOVERTANKPHYSICSACTIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HoverTankPhysicsActionData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("HoverTankPhysicsActionData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct HoverLiftPhysicsActionData {
    pub _glacier_base: PhysicsActionBaseData,
    pub force_absolute_locked_hover: bool,
    pub absolute_hover_height: f32,
    pub hover_force_spring_strength: f32,
    pub hover_force_upward_damping: f32,
    pub hover_force_downward_damping: f32,
    pub spring_compression_smoothing: f32,
    pub spring_decompression_smoothing: f32,
    pub lift_skirt_filter_offset: f32,
    pub hover_spring_max_length: f32,
    pub hover_spring_rest_length: f32,
    pub raycast_length: f32,
    pub ground_plane_small_smoothing: f32,
    pub ground_plane_large_smoothing: f32,
    pub align_with_up_angle_min: f32,
    pub extreme_angle_resist_min: f32,
    pub extreme_angle_resist_max: f32,
    pub ground_align_strength: f32,
    pub ground_align_damping: f32,
    pub maximum_floor_angle: f32,
    pub raycast_vertical_offset: f32,
    pub centre_raycast_offset: super::core::Vec2,
    pub left_raycast_offset: f32,
    pub right_raycast_offset: f32,
    pub front_raycast_offset: f32,
    pub back_raycast_offset: f32,
    pub in_air_effect_start_factor: f32,
    pub in_air_align_strength: f32,
    pub in_air_factor_smoothing: f32,
    pub siege_mode_hover_height_modifier: f32,
    pub siege_mode_fade_in_smoothing: f32,
    pub siege_mode_fade_out_smoothing: f32,
    pub is_in_siege_mode: bool,
    pub fake_roll_max_turn_speed: f32,
    pub fake_roll_when_turning: f32,
    pub fake_roll_max_strafe_speed: f32,
    pub fake_roll_when_strafing: f32,
    pub fake_pitch_max_drive_speed: f32,
    pub fake_pitch_when_driving: f32,
}

pub trait HoverLiftPhysicsActionDataTrait: PhysicsActionBaseDataTrait {
    fn force_absolute_locked_hover(&self) -> &bool;
    fn absolute_hover_height(&self) -> &f32;
    fn hover_force_spring_strength(&self) -> &f32;
    fn hover_force_upward_damping(&self) -> &f32;
    fn hover_force_downward_damping(&self) -> &f32;
    fn spring_compression_smoothing(&self) -> &f32;
    fn spring_decompression_smoothing(&self) -> &f32;
    fn lift_skirt_filter_offset(&self) -> &f32;
    fn hover_spring_max_length(&self) -> &f32;
    fn hover_spring_rest_length(&self) -> &f32;
    fn raycast_length(&self) -> &f32;
    fn ground_plane_small_smoothing(&self) -> &f32;
    fn ground_plane_large_smoothing(&self) -> &f32;
    fn align_with_up_angle_min(&self) -> &f32;
    fn extreme_angle_resist_min(&self) -> &f32;
    fn extreme_angle_resist_max(&self) -> &f32;
    fn ground_align_strength(&self) -> &f32;
    fn ground_align_damping(&self) -> &f32;
    fn maximum_floor_angle(&self) -> &f32;
    fn raycast_vertical_offset(&self) -> &f32;
    fn centre_raycast_offset(&self) -> &super::core::Vec2;
    fn left_raycast_offset(&self) -> &f32;
    fn right_raycast_offset(&self) -> &f32;
    fn front_raycast_offset(&self) -> &f32;
    fn back_raycast_offset(&self) -> &f32;
    fn in_air_effect_start_factor(&self) -> &f32;
    fn in_air_align_strength(&self) -> &f32;
    fn in_air_factor_smoothing(&self) -> &f32;
    fn siege_mode_hover_height_modifier(&self) -> &f32;
    fn siege_mode_fade_in_smoothing(&self) -> &f32;
    fn siege_mode_fade_out_smoothing(&self) -> &f32;
    fn is_in_siege_mode(&self) -> &bool;
    fn fake_roll_max_turn_speed(&self) -> &f32;
    fn fake_roll_when_turning(&self) -> &f32;
    fn fake_roll_max_strafe_speed(&self) -> &f32;
    fn fake_roll_when_strafing(&self) -> &f32;
    fn fake_pitch_max_drive_speed(&self) -> &f32;
    fn fake_pitch_when_driving(&self) -> &f32;
}

impl HoverLiftPhysicsActionDataTrait for HoverLiftPhysicsActionData {
    fn force_absolute_locked_hover(&self) -> &bool {
        &self.force_absolute_locked_hover
    }
    fn absolute_hover_height(&self) -> &f32 {
        &self.absolute_hover_height
    }
    fn hover_force_spring_strength(&self) -> &f32 {
        &self.hover_force_spring_strength
    }
    fn hover_force_upward_damping(&self) -> &f32 {
        &self.hover_force_upward_damping
    }
    fn hover_force_downward_damping(&self) -> &f32 {
        &self.hover_force_downward_damping
    }
    fn spring_compression_smoothing(&self) -> &f32 {
        &self.spring_compression_smoothing
    }
    fn spring_decompression_smoothing(&self) -> &f32 {
        &self.spring_decompression_smoothing
    }
    fn lift_skirt_filter_offset(&self) -> &f32 {
        &self.lift_skirt_filter_offset
    }
    fn hover_spring_max_length(&self) -> &f32 {
        &self.hover_spring_max_length
    }
    fn hover_spring_rest_length(&self) -> &f32 {
        &self.hover_spring_rest_length
    }
    fn raycast_length(&self) -> &f32 {
        &self.raycast_length
    }
    fn ground_plane_small_smoothing(&self) -> &f32 {
        &self.ground_plane_small_smoothing
    }
    fn ground_plane_large_smoothing(&self) -> &f32 {
        &self.ground_plane_large_smoothing
    }
    fn align_with_up_angle_min(&self) -> &f32 {
        &self.align_with_up_angle_min
    }
    fn extreme_angle_resist_min(&self) -> &f32 {
        &self.extreme_angle_resist_min
    }
    fn extreme_angle_resist_max(&self) -> &f32 {
        &self.extreme_angle_resist_max
    }
    fn ground_align_strength(&self) -> &f32 {
        &self.ground_align_strength
    }
    fn ground_align_damping(&self) -> &f32 {
        &self.ground_align_damping
    }
    fn maximum_floor_angle(&self) -> &f32 {
        &self.maximum_floor_angle
    }
    fn raycast_vertical_offset(&self) -> &f32 {
        &self.raycast_vertical_offset
    }
    fn centre_raycast_offset(&self) -> &super::core::Vec2 {
        &self.centre_raycast_offset
    }
    fn left_raycast_offset(&self) -> &f32 {
        &self.left_raycast_offset
    }
    fn right_raycast_offset(&self) -> &f32 {
        &self.right_raycast_offset
    }
    fn front_raycast_offset(&self) -> &f32 {
        &self.front_raycast_offset
    }
    fn back_raycast_offset(&self) -> &f32 {
        &self.back_raycast_offset
    }
    fn in_air_effect_start_factor(&self) -> &f32 {
        &self.in_air_effect_start_factor
    }
    fn in_air_align_strength(&self) -> &f32 {
        &self.in_air_align_strength
    }
    fn in_air_factor_smoothing(&self) -> &f32 {
        &self.in_air_factor_smoothing
    }
    fn siege_mode_hover_height_modifier(&self) -> &f32 {
        &self.siege_mode_hover_height_modifier
    }
    fn siege_mode_fade_in_smoothing(&self) -> &f32 {
        &self.siege_mode_fade_in_smoothing
    }
    fn siege_mode_fade_out_smoothing(&self) -> &f32 {
        &self.siege_mode_fade_out_smoothing
    }
    fn is_in_siege_mode(&self) -> &bool {
        &self.is_in_siege_mode
    }
    fn fake_roll_max_turn_speed(&self) -> &f32 {
        &self.fake_roll_max_turn_speed
    }
    fn fake_roll_when_turning(&self) -> &f32 {
        &self.fake_roll_when_turning
    }
    fn fake_roll_max_strafe_speed(&self) -> &f32 {
        &self.fake_roll_max_strafe_speed
    }
    fn fake_roll_when_strafing(&self) -> &f32 {
        &self.fake_roll_when_strafing
    }
    fn fake_pitch_max_drive_speed(&self) -> &f32 {
        &self.fake_pitch_max_drive_speed
    }
    fn fake_pitch_when_driving(&self) -> &f32 {
        &self.fake_pitch_when_driving
    }
}

impl PhysicsActionBaseDataTrait for HoverLiftPhysicsActionData {
    fn blend_factor(&self) -> &f32 {
        self._glacier_base.blend_factor()
    }
    fn input_blend_factor(&self) -> &f32 {
        self._glacier_base.input_blend_factor()
    }
    fn clamp_lin_acc(&self) -> &f32 {
        self._glacier_base.clamp_lin_acc()
    }
    fn clamp_ang_acc(&self) -> &f32 {
        self._glacier_base.clamp_ang_acc()
    }
    fn blend_factor_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.blend_factor_curve()
    }
    fn collision_response_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.collision_response_curve()
    }
}

impl super::entity::EntityDataTrait for HoverLiftPhysicsActionData {
}

impl super::entity::GameObjectDataTrait for HoverLiftPhysicsActionData {
}

impl super::core::DataBusPeerTrait for HoverLiftPhysicsActionData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for HoverLiftPhysicsActionData {
}

impl super::core::DataContainerTrait for HoverLiftPhysicsActionData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static HOVERLIFTPHYSICSACTIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HoverLiftPhysicsActionData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PHYSICSACTIONBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<HoverLiftPhysicsActionData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ForceAbsoluteLockedHover",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(HoverLiftPhysicsActionData, force_absolute_locked_hover),
            },
            FieldInfoData {
                name: "AbsoluteHoverHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverLiftPhysicsActionData, absolute_hover_height),
            },
            FieldInfoData {
                name: "HoverForceSpringStrength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverLiftPhysicsActionData, hover_force_spring_strength),
            },
            FieldInfoData {
                name: "HoverForceUpwardDamping",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverLiftPhysicsActionData, hover_force_upward_damping),
            },
            FieldInfoData {
                name: "HoverForceDownwardDamping",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverLiftPhysicsActionData, hover_force_downward_damping),
            },
            FieldInfoData {
                name: "SpringCompressionSmoothing",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverLiftPhysicsActionData, spring_compression_smoothing),
            },
            FieldInfoData {
                name: "SpringDecompressionSmoothing",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverLiftPhysicsActionData, spring_decompression_smoothing),
            },
            FieldInfoData {
                name: "LiftSkirtFilterOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverLiftPhysicsActionData, lift_skirt_filter_offset),
            },
            FieldInfoData {
                name: "HoverSpringMaxLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverLiftPhysicsActionData, hover_spring_max_length),
            },
            FieldInfoData {
                name: "HoverSpringRestLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverLiftPhysicsActionData, hover_spring_rest_length),
            },
            FieldInfoData {
                name: "RaycastLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverLiftPhysicsActionData, raycast_length),
            },
            FieldInfoData {
                name: "GroundPlaneSmallSmoothing",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverLiftPhysicsActionData, ground_plane_small_smoothing),
            },
            FieldInfoData {
                name: "GroundPlaneLargeSmoothing",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverLiftPhysicsActionData, ground_plane_large_smoothing),
            },
            FieldInfoData {
                name: "AlignWithUpAngleMin",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverLiftPhysicsActionData, align_with_up_angle_min),
            },
            FieldInfoData {
                name: "ExtremeAngleResistMin",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverLiftPhysicsActionData, extreme_angle_resist_min),
            },
            FieldInfoData {
                name: "ExtremeAngleResistMax",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverLiftPhysicsActionData, extreme_angle_resist_max),
            },
            FieldInfoData {
                name: "GroundAlignStrength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverLiftPhysicsActionData, ground_align_strength),
            },
            FieldInfoData {
                name: "GroundAlignDamping",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverLiftPhysicsActionData, ground_align_damping),
            },
            FieldInfoData {
                name: "MaximumFloorAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverLiftPhysicsActionData, maximum_floor_angle),
            },
            FieldInfoData {
                name: "RaycastVerticalOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverLiftPhysicsActionData, raycast_vertical_offset),
            },
            FieldInfoData {
                name: "CentreRaycastOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(HoverLiftPhysicsActionData, centre_raycast_offset),
            },
            FieldInfoData {
                name: "LeftRaycastOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverLiftPhysicsActionData, left_raycast_offset),
            },
            FieldInfoData {
                name: "RightRaycastOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverLiftPhysicsActionData, right_raycast_offset),
            },
            FieldInfoData {
                name: "FrontRaycastOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverLiftPhysicsActionData, front_raycast_offset),
            },
            FieldInfoData {
                name: "BackRaycastOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverLiftPhysicsActionData, back_raycast_offset),
            },
            FieldInfoData {
                name: "InAirEffectStartFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverLiftPhysicsActionData, in_air_effect_start_factor),
            },
            FieldInfoData {
                name: "InAirAlignStrength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverLiftPhysicsActionData, in_air_align_strength),
            },
            FieldInfoData {
                name: "InAirFactorSmoothing",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverLiftPhysicsActionData, in_air_factor_smoothing),
            },
            FieldInfoData {
                name: "SiegeModeHoverHeightModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverLiftPhysicsActionData, siege_mode_hover_height_modifier),
            },
            FieldInfoData {
                name: "SiegeModeFadeInSmoothing",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverLiftPhysicsActionData, siege_mode_fade_in_smoothing),
            },
            FieldInfoData {
                name: "SiegeModeFadeOutSmoothing",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverLiftPhysicsActionData, siege_mode_fade_out_smoothing),
            },
            FieldInfoData {
                name: "IsInSiegeMode",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(HoverLiftPhysicsActionData, is_in_siege_mode),
            },
            FieldInfoData {
                name: "FakeRollMaxTurnSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverLiftPhysicsActionData, fake_roll_max_turn_speed),
            },
            FieldInfoData {
                name: "FakeRollWhenTurning",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverLiftPhysicsActionData, fake_roll_when_turning),
            },
            FieldInfoData {
                name: "FakeRollMaxStrafeSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverLiftPhysicsActionData, fake_roll_max_strafe_speed),
            },
            FieldInfoData {
                name: "FakeRollWhenStrafing",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverLiftPhysicsActionData, fake_roll_when_strafing),
            },
            FieldInfoData {
                name: "FakePitchMaxDriveSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverLiftPhysicsActionData, fake_pitch_max_drive_speed),
            },
            FieldInfoData {
                name: "FakePitchWhenDriving",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverLiftPhysicsActionData, fake_pitch_when_driving),
            },
        ],
    }),
    array_type: Some(HOVERLIFTPHYSICSACTIONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for HoverLiftPhysicsActionData {
    fn type_info(&self) -> &'static TypeInfo {
        HOVERLIFTPHYSICSACTIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static HOVERLIFTPHYSICSACTIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HoverLiftPhysicsActionData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("HoverLiftPhysicsActionData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct HoverLiftVolumeConfig {
    pub model_offset: super::core::Vec3,
    pub velocity_lookahead_axis_offset: super::core::Vec3,
    pub sphere_radius: f32,
    pub target_rest_length: f32,
}

pub trait HoverLiftVolumeConfigTrait: TypeObject {
    fn model_offset(&self) -> &super::core::Vec3;
    fn velocity_lookahead_axis_offset(&self) -> &super::core::Vec3;
    fn sphere_radius(&self) -> &f32;
    fn target_rest_length(&self) -> &f32;
}

impl HoverLiftVolumeConfigTrait for HoverLiftVolumeConfig {
    fn model_offset(&self) -> &super::core::Vec3 {
        &self.model_offset
    }
    fn velocity_lookahead_axis_offset(&self) -> &super::core::Vec3 {
        &self.velocity_lookahead_axis_offset
    }
    fn sphere_radius(&self) -> &f32 {
        &self.sphere_radius
    }
    fn target_rest_length(&self) -> &f32 {
        &self.target_rest_length
    }
}

pub static HOVERLIFTVOLUMECONFIG_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HoverLiftVolumeConfig",
    flags: MemberInfoFlags::new(36937),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<HoverLiftVolumeConfig as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ModelOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(HoverLiftVolumeConfig, model_offset),
            },
            FieldInfoData {
                name: "VelocityLookaheadAxisOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(HoverLiftVolumeConfig, velocity_lookahead_axis_offset),
            },
            FieldInfoData {
                name: "SphereRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverLiftVolumeConfig, sphere_radius),
            },
            FieldInfoData {
                name: "TargetRestLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverLiftVolumeConfig, target_rest_length),
            },
        ],
    }),
    array_type: Some(HOVERLIFTVOLUMECONFIG_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for HoverLiftVolumeConfig {
    fn type_info(&self) -> &'static TypeInfo {
        HOVERLIFTVOLUMECONFIG_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static HOVERLIFTVOLUMECONFIG_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HoverLiftVolumeConfig-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("HoverLiftVolumeConfig"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MutualRepulsorPhysicsActionData {
    pub _glacier_base: PhysicsActionBaseData,
    pub speed_to_force_curve: super::core::AudioCurve,
    pub distance_to_force_curve: super::core::AudioCurve,
    pub force_multiplier: f32,
}

pub trait MutualRepulsorPhysicsActionDataTrait: PhysicsActionBaseDataTrait {
    fn speed_to_force_curve(&self) -> &super::core::AudioCurve;
    fn distance_to_force_curve(&self) -> &super::core::AudioCurve;
    fn force_multiplier(&self) -> &f32;
}

impl MutualRepulsorPhysicsActionDataTrait for MutualRepulsorPhysicsActionData {
    fn speed_to_force_curve(&self) -> &super::core::AudioCurve {
        &self.speed_to_force_curve
    }
    fn distance_to_force_curve(&self) -> &super::core::AudioCurve {
        &self.distance_to_force_curve
    }
    fn force_multiplier(&self) -> &f32 {
        &self.force_multiplier
    }
}

impl PhysicsActionBaseDataTrait for MutualRepulsorPhysicsActionData {
    fn blend_factor(&self) -> &f32 {
        self._glacier_base.blend_factor()
    }
    fn input_blend_factor(&self) -> &f32 {
        self._glacier_base.input_blend_factor()
    }
    fn clamp_lin_acc(&self) -> &f32 {
        self._glacier_base.clamp_lin_acc()
    }
    fn clamp_ang_acc(&self) -> &f32 {
        self._glacier_base.clamp_ang_acc()
    }
    fn blend_factor_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.blend_factor_curve()
    }
    fn collision_response_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.collision_response_curve()
    }
}

impl super::entity::EntityDataTrait for MutualRepulsorPhysicsActionData {
}

impl super::entity::GameObjectDataTrait for MutualRepulsorPhysicsActionData {
}

impl super::core::DataBusPeerTrait for MutualRepulsorPhysicsActionData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for MutualRepulsorPhysicsActionData {
}

impl super::core::DataContainerTrait for MutualRepulsorPhysicsActionData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static MUTUALREPULSORPHYSICSACTIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MutualRepulsorPhysicsActionData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PHYSICSACTIONBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MutualRepulsorPhysicsActionData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SpeedToForceCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioCurve",
                rust_offset: offset_of!(MutualRepulsorPhysicsActionData, speed_to_force_curve),
            },
            FieldInfoData {
                name: "DistanceToForceCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioCurve",
                rust_offset: offset_of!(MutualRepulsorPhysicsActionData, distance_to_force_curve),
            },
            FieldInfoData {
                name: "ForceMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MutualRepulsorPhysicsActionData, force_multiplier),
            },
        ],
    }),
    array_type: Some(MUTUALREPULSORPHYSICSACTIONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MutualRepulsorPhysicsActionData {
    fn type_info(&self) -> &'static TypeInfo {
        MUTUALREPULSORPHYSICSACTIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static MUTUALREPULSORPHYSICSACTIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MutualRepulsorPhysicsActionData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("MutualRepulsorPhysicsActionData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct StarFighterPhysicsActionData {
    pub _glacier_base: PhysicsActionBaseData,
    pub is_planetary: bool,
    pub is_campaign: bool,
    pub normalised_boost: f32,
    pub boost_duration: f32,
    pub normalised_slowed_power_scale: f32,
    pub disable_zoom: bool,
    pub input_action_pitch: i32,
    pub input_action_yaw: i32,
    pub input_action_roll: i32,
    pub input_action_throttle: i32,
    pub input_action_zoom: i32,
    pub input_action_lock_roll: i32,
    pub left_stick_dead_zone_center: f32,
    pub left_stick_dead_zone_axis: f32,
    pub left_stick_dead_zone_axis_offset: f32,
    pub left_stick_input_squareness: f32,
    pub left_stick_input_power: f32,
    pub left_stick_input_power_alternate: f32,
    pub input_pilot_zoom_threshold: f32,
    pub input_kick: f32,
    pub input_kick_left_stick: f32,
    pub r_s_input_pow: f32,
    pub r_s_input_pow_alternate: f32,
    pub r_s_input_pow_user_setting_deviation: f32,
    pub steer_kick_overall_strength: f32,
    pub steer_kick_minimum_steer_value: f32,
    pub steer_kick_maximum_steer_value: f32,
    pub steer_kick_minimum_input_velocity: f32,
    pub steer_kick_maximum_input_velocity: f32,
    pub small_steer_input_scale: f32,
    pub boost_falloff_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
}

pub trait StarFighterPhysicsActionDataTrait: PhysicsActionBaseDataTrait {
    fn is_planetary(&self) -> &bool;
    fn is_campaign(&self) -> &bool;
    fn normalised_boost(&self) -> &f32;
    fn boost_duration(&self) -> &f32;
    fn normalised_slowed_power_scale(&self) -> &f32;
    fn disable_zoom(&self) -> &bool;
    fn input_action_pitch(&self) -> &i32;
    fn input_action_yaw(&self) -> &i32;
    fn input_action_roll(&self) -> &i32;
    fn input_action_throttle(&self) -> &i32;
    fn input_action_zoom(&self) -> &i32;
    fn input_action_lock_roll(&self) -> &i32;
    fn left_stick_dead_zone_center(&self) -> &f32;
    fn left_stick_dead_zone_axis(&self) -> &f32;
    fn left_stick_dead_zone_axis_offset(&self) -> &f32;
    fn left_stick_input_squareness(&self) -> &f32;
    fn left_stick_input_power(&self) -> &f32;
    fn left_stick_input_power_alternate(&self) -> &f32;
    fn input_pilot_zoom_threshold(&self) -> &f32;
    fn input_kick(&self) -> &f32;
    fn input_kick_left_stick(&self) -> &f32;
    fn r_s_input_pow(&self) -> &f32;
    fn r_s_input_pow_alternate(&self) -> &f32;
    fn r_s_input_pow_user_setting_deviation(&self) -> &f32;
    fn steer_kick_overall_strength(&self) -> &f32;
    fn steer_kick_minimum_steer_value(&self) -> &f32;
    fn steer_kick_maximum_steer_value(&self) -> &f32;
    fn steer_kick_minimum_input_velocity(&self) -> &f32;
    fn steer_kick_maximum_input_velocity(&self) -> &f32;
    fn small_steer_input_scale(&self) -> &f32;
    fn boost_falloff_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
}

impl StarFighterPhysicsActionDataTrait for StarFighterPhysicsActionData {
    fn is_planetary(&self) -> &bool {
        &self.is_planetary
    }
    fn is_campaign(&self) -> &bool {
        &self.is_campaign
    }
    fn normalised_boost(&self) -> &f32 {
        &self.normalised_boost
    }
    fn boost_duration(&self) -> &f32 {
        &self.boost_duration
    }
    fn normalised_slowed_power_scale(&self) -> &f32 {
        &self.normalised_slowed_power_scale
    }
    fn disable_zoom(&self) -> &bool {
        &self.disable_zoom
    }
    fn input_action_pitch(&self) -> &i32 {
        &self.input_action_pitch
    }
    fn input_action_yaw(&self) -> &i32 {
        &self.input_action_yaw
    }
    fn input_action_roll(&self) -> &i32 {
        &self.input_action_roll
    }
    fn input_action_throttle(&self) -> &i32 {
        &self.input_action_throttle
    }
    fn input_action_zoom(&self) -> &i32 {
        &self.input_action_zoom
    }
    fn input_action_lock_roll(&self) -> &i32 {
        &self.input_action_lock_roll
    }
    fn left_stick_dead_zone_center(&self) -> &f32 {
        &self.left_stick_dead_zone_center
    }
    fn left_stick_dead_zone_axis(&self) -> &f32 {
        &self.left_stick_dead_zone_axis
    }
    fn left_stick_dead_zone_axis_offset(&self) -> &f32 {
        &self.left_stick_dead_zone_axis_offset
    }
    fn left_stick_input_squareness(&self) -> &f32 {
        &self.left_stick_input_squareness
    }
    fn left_stick_input_power(&self) -> &f32 {
        &self.left_stick_input_power
    }
    fn left_stick_input_power_alternate(&self) -> &f32 {
        &self.left_stick_input_power_alternate
    }
    fn input_pilot_zoom_threshold(&self) -> &f32 {
        &self.input_pilot_zoom_threshold
    }
    fn input_kick(&self) -> &f32 {
        &self.input_kick
    }
    fn input_kick_left_stick(&self) -> &f32 {
        &self.input_kick_left_stick
    }
    fn r_s_input_pow(&self) -> &f32 {
        &self.r_s_input_pow
    }
    fn r_s_input_pow_alternate(&self) -> &f32 {
        &self.r_s_input_pow_alternate
    }
    fn r_s_input_pow_user_setting_deviation(&self) -> &f32 {
        &self.r_s_input_pow_user_setting_deviation
    }
    fn steer_kick_overall_strength(&self) -> &f32 {
        &self.steer_kick_overall_strength
    }
    fn steer_kick_minimum_steer_value(&self) -> &f32 {
        &self.steer_kick_minimum_steer_value
    }
    fn steer_kick_maximum_steer_value(&self) -> &f32 {
        &self.steer_kick_maximum_steer_value
    }
    fn steer_kick_minimum_input_velocity(&self) -> &f32 {
        &self.steer_kick_minimum_input_velocity
    }
    fn steer_kick_maximum_input_velocity(&self) -> &f32 {
        &self.steer_kick_maximum_input_velocity
    }
    fn small_steer_input_scale(&self) -> &f32 {
        &self.small_steer_input_scale
    }
    fn boost_falloff_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.boost_falloff_curve
    }
}

impl PhysicsActionBaseDataTrait for StarFighterPhysicsActionData {
    fn blend_factor(&self) -> &f32 {
        self._glacier_base.blend_factor()
    }
    fn input_blend_factor(&self) -> &f32 {
        self._glacier_base.input_blend_factor()
    }
    fn clamp_lin_acc(&self) -> &f32 {
        self._glacier_base.clamp_lin_acc()
    }
    fn clamp_ang_acc(&self) -> &f32 {
        self._glacier_base.clamp_ang_acc()
    }
    fn blend_factor_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.blend_factor_curve()
    }
    fn collision_response_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.collision_response_curve()
    }
}

impl super::entity::EntityDataTrait for StarFighterPhysicsActionData {
}

impl super::entity::GameObjectDataTrait for StarFighterPhysicsActionData {
}

impl super::core::DataBusPeerTrait for StarFighterPhysicsActionData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for StarFighterPhysicsActionData {
}

impl super::core::DataContainerTrait for StarFighterPhysicsActionData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static STARFIGHTERPHYSICSACTIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StarFighterPhysicsActionData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PHYSICSACTIONBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StarFighterPhysicsActionData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "IsPlanetary",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(StarFighterPhysicsActionData, is_planetary),
            },
            FieldInfoData {
                name: "IsCampaign",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(StarFighterPhysicsActionData, is_campaign),
            },
            FieldInfoData {
                name: "NormalisedBoost",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarFighterPhysicsActionData, normalised_boost),
            },
            FieldInfoData {
                name: "BoostDuration",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarFighterPhysicsActionData, boost_duration),
            },
            FieldInfoData {
                name: "NormalisedSlowedPowerScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarFighterPhysicsActionData, normalised_slowed_power_scale),
            },
            FieldInfoData {
                name: "DisableZoom",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(StarFighterPhysicsActionData, disable_zoom),
            },
            FieldInfoData {
                name: "InputActionPitch",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(StarFighterPhysicsActionData, input_action_pitch),
            },
            FieldInfoData {
                name: "InputActionYaw",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(StarFighterPhysicsActionData, input_action_yaw),
            },
            FieldInfoData {
                name: "InputActionRoll",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(StarFighterPhysicsActionData, input_action_roll),
            },
            FieldInfoData {
                name: "InputActionThrottle",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(StarFighterPhysicsActionData, input_action_throttle),
            },
            FieldInfoData {
                name: "InputActionZoom",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(StarFighterPhysicsActionData, input_action_zoom),
            },
            FieldInfoData {
                name: "InputActionLockRoll",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(StarFighterPhysicsActionData, input_action_lock_roll),
            },
            FieldInfoData {
                name: "LeftStickDeadZoneCenter",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarFighterPhysicsActionData, left_stick_dead_zone_center),
            },
            FieldInfoData {
                name: "LeftStickDeadZoneAxis",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarFighterPhysicsActionData, left_stick_dead_zone_axis),
            },
            FieldInfoData {
                name: "LeftStickDeadZoneAxisOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarFighterPhysicsActionData, left_stick_dead_zone_axis_offset),
            },
            FieldInfoData {
                name: "LeftStickInputSquareness",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarFighterPhysicsActionData, left_stick_input_squareness),
            },
            FieldInfoData {
                name: "LeftStickInputPower",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarFighterPhysicsActionData, left_stick_input_power),
            },
            FieldInfoData {
                name: "LeftStickInputPowerAlternate",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarFighterPhysicsActionData, left_stick_input_power_alternate),
            },
            FieldInfoData {
                name: "InputPilotZoomThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarFighterPhysicsActionData, input_pilot_zoom_threshold),
            },
            FieldInfoData {
                name: "InputKick",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarFighterPhysicsActionData, input_kick),
            },
            FieldInfoData {
                name: "InputKickLeftStick",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarFighterPhysicsActionData, input_kick_left_stick),
            },
            FieldInfoData {
                name: "RSInputPow",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarFighterPhysicsActionData, r_s_input_pow),
            },
            FieldInfoData {
                name: "RSInputPowAlternate",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarFighterPhysicsActionData, r_s_input_pow_alternate),
            },
            FieldInfoData {
                name: "RSInputPowUserSettingDeviation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarFighterPhysicsActionData, r_s_input_pow_user_setting_deviation),
            },
            FieldInfoData {
                name: "SteerKickOverallStrength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarFighterPhysicsActionData, steer_kick_overall_strength),
            },
            FieldInfoData {
                name: "SteerKickMinimumSteerValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarFighterPhysicsActionData, steer_kick_minimum_steer_value),
            },
            FieldInfoData {
                name: "SteerKickMaximumSteerValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarFighterPhysicsActionData, steer_kick_maximum_steer_value),
            },
            FieldInfoData {
                name: "SteerKickMinimumInputVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarFighterPhysicsActionData, steer_kick_minimum_input_velocity),
            },
            FieldInfoData {
                name: "SteerKickMaximumInputVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarFighterPhysicsActionData, steer_kick_maximum_input_velocity),
            },
            FieldInfoData {
                name: "SmallSteerInputScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarFighterPhysicsActionData, small_steer_input_scale),
            },
            FieldInfoData {
                name: "BoostFalloffCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(StarFighterPhysicsActionData, boost_falloff_curve),
            },
        ],
    }),
    array_type: Some(STARFIGHTERPHYSICSACTIONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for StarFighterPhysicsActionData {
    fn type_info(&self) -> &'static TypeInfo {
        STARFIGHTERPHYSICSACTIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static STARFIGHTERPHYSICSACTIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StarFighterPhysicsActionData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("StarFighterPhysicsActionData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct StarfighterConfigEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub engine_acceleration_rate: f32,
    pub boost_engine_acceleration_rate: f32,
    pub engine_deceleration_rate: f32,
    pub min_speed: f32,
    pub max_speed: f32,
    pub boost_max_speed: f32,
    pub slowed_engine_power_scale: f32,
    pub steer_rate_throttle: super::core::Vec3,
    pub axis_turn_rates: super::core::Vec3,
    pub axis_turn_rates_zoomed: super::core::Vec3,
    pub acceleration_drift_force: super::core::Vec3,
    pub turn_torques: super::core::Vec3,
    pub roll_torque: f32,
    pub yaw_roll_damping_time: f32,
    pub turn_rate_by_speed_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
    pub steer_rates: super::core::Vec3,
    pub steer_rates_zoomed: super::core::Vec3,
    pub steer_rate_roll: super::core::Vec3,
    pub roll_rate_by_roll_ang_vel_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
    pub torque_by_input_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
    pub pitch_down_scale: f32,
    pub target_fake_roll_angle: f32,
    pub fake_roll_max_ang_vel: f32,
    pub max_roll_response_angle: f32,
    pub fake_roll_inverse_scale: f32,
    pub fake_roll_acc_from_yaw_input: f32,
    pub fake_roll_extra_yaw_input: f32,
    pub fake_roll_extra_roll_input: f32,
    pub roll_angular_velocity_deadzone: f32,
    pub air_brake_engine_speed_rate: f32,
    pub air_brake_input_mul: f32,
    pub air_brake_engine_mul: f32,
    pub steer_rate_multiplier_airbraking: f32,
    pub turn_rate_multiplier_airbraking: f32,
    pub air_brake_level_lerp: f32,
    pub self_right_strength: f32,
    pub self_right_factor_yaw: super::core::Vec2,
    pub self_right_factor_pitch: super::core::Vec2,
    pub self_right_factor_roll: super::core::Vec2,
    pub self_right_against_inv_ang_vel: super::core::Vec3,
    pub self_right_against_zoom: super::core::Vec2,
    pub self_right_strength_lerp: f32,
    pub self_right_against_camera_forward_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
    pub self_right_against_world_up_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
    pub upright_roll_damping_time: f32,
    pub self_right_timer_activation_delay: f32,
    pub self_right_timer_minimum_roll_input: f32,
    pub self_right_timer_minimum_throttle_input: f32,
    pub self_right_timer_minimum_yaw_input: f32,
    pub self_right_timer_minimum_pitch_input: f32,
    pub is_airspeeder: bool,
    pub max_speed_override: f32,
    pub boost_max_speed_override: f32,
    pub engine_acceleration_rate_override: f32,
    pub engine_deceleration_rate_override: f32,
    pub axis_turn_rates_override: super::core::Vec3,
    pub axis_turn_rates_zoomed_override: super::core::Vec3,
    pub max_speed_multiplier: f32,
    pub boost_max_speed_multiplier: f32,
    pub engine_acceleration_rate_multiplier: f32,
    pub engine_deceleration_rate_multiplier: f32,
    pub axis_turn_rates_multiplier: super::core::Vec3,
    pub axis_turn_rates_zoomed_multiplier: super::core::Vec3,
}

pub trait StarfighterConfigEntityDataTrait: super::entity::EntityDataTrait {
    fn engine_acceleration_rate(&self) -> &f32;
    fn boost_engine_acceleration_rate(&self) -> &f32;
    fn engine_deceleration_rate(&self) -> &f32;
    fn min_speed(&self) -> &f32;
    fn max_speed(&self) -> &f32;
    fn boost_max_speed(&self) -> &f32;
    fn slowed_engine_power_scale(&self) -> &f32;
    fn steer_rate_throttle(&self) -> &super::core::Vec3;
    fn axis_turn_rates(&self) -> &super::core::Vec3;
    fn axis_turn_rates_zoomed(&self) -> &super::core::Vec3;
    fn acceleration_drift_force(&self) -> &super::core::Vec3;
    fn turn_torques(&self) -> &super::core::Vec3;
    fn roll_torque(&self) -> &f32;
    fn yaw_roll_damping_time(&self) -> &f32;
    fn turn_rate_by_speed_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn steer_rates(&self) -> &super::core::Vec3;
    fn steer_rates_zoomed(&self) -> &super::core::Vec3;
    fn steer_rate_roll(&self) -> &super::core::Vec3;
    fn roll_rate_by_roll_ang_vel_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn torque_by_input_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn pitch_down_scale(&self) -> &f32;
    fn target_fake_roll_angle(&self) -> &f32;
    fn fake_roll_max_ang_vel(&self) -> &f32;
    fn max_roll_response_angle(&self) -> &f32;
    fn fake_roll_inverse_scale(&self) -> &f32;
    fn fake_roll_acc_from_yaw_input(&self) -> &f32;
    fn fake_roll_extra_yaw_input(&self) -> &f32;
    fn fake_roll_extra_roll_input(&self) -> &f32;
    fn roll_angular_velocity_deadzone(&self) -> &f32;
    fn air_brake_engine_speed_rate(&self) -> &f32;
    fn air_brake_input_mul(&self) -> &f32;
    fn air_brake_engine_mul(&self) -> &f32;
    fn steer_rate_multiplier_airbraking(&self) -> &f32;
    fn turn_rate_multiplier_airbraking(&self) -> &f32;
    fn air_brake_level_lerp(&self) -> &f32;
    fn self_right_strength(&self) -> &f32;
    fn self_right_factor_yaw(&self) -> &super::core::Vec2;
    fn self_right_factor_pitch(&self) -> &super::core::Vec2;
    fn self_right_factor_roll(&self) -> &super::core::Vec2;
    fn self_right_against_inv_ang_vel(&self) -> &super::core::Vec3;
    fn self_right_against_zoom(&self) -> &super::core::Vec2;
    fn self_right_strength_lerp(&self) -> &f32;
    fn self_right_against_camera_forward_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn self_right_against_world_up_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn upright_roll_damping_time(&self) -> &f32;
    fn self_right_timer_activation_delay(&self) -> &f32;
    fn self_right_timer_minimum_roll_input(&self) -> &f32;
    fn self_right_timer_minimum_throttle_input(&self) -> &f32;
    fn self_right_timer_minimum_yaw_input(&self) -> &f32;
    fn self_right_timer_minimum_pitch_input(&self) -> &f32;
    fn is_airspeeder(&self) -> &bool;
    fn max_speed_override(&self) -> &f32;
    fn boost_max_speed_override(&self) -> &f32;
    fn engine_acceleration_rate_override(&self) -> &f32;
    fn engine_deceleration_rate_override(&self) -> &f32;
    fn axis_turn_rates_override(&self) -> &super::core::Vec3;
    fn axis_turn_rates_zoomed_override(&self) -> &super::core::Vec3;
    fn max_speed_multiplier(&self) -> &f32;
    fn boost_max_speed_multiplier(&self) -> &f32;
    fn engine_acceleration_rate_multiplier(&self) -> &f32;
    fn engine_deceleration_rate_multiplier(&self) -> &f32;
    fn axis_turn_rates_multiplier(&self) -> &super::core::Vec3;
    fn axis_turn_rates_zoomed_multiplier(&self) -> &super::core::Vec3;
}

impl StarfighterConfigEntityDataTrait for StarfighterConfigEntityData {
    fn engine_acceleration_rate(&self) -> &f32 {
        &self.engine_acceleration_rate
    }
    fn boost_engine_acceleration_rate(&self) -> &f32 {
        &self.boost_engine_acceleration_rate
    }
    fn engine_deceleration_rate(&self) -> &f32 {
        &self.engine_deceleration_rate
    }
    fn min_speed(&self) -> &f32 {
        &self.min_speed
    }
    fn max_speed(&self) -> &f32 {
        &self.max_speed
    }
    fn boost_max_speed(&self) -> &f32 {
        &self.boost_max_speed
    }
    fn slowed_engine_power_scale(&self) -> &f32 {
        &self.slowed_engine_power_scale
    }
    fn steer_rate_throttle(&self) -> &super::core::Vec3 {
        &self.steer_rate_throttle
    }
    fn axis_turn_rates(&self) -> &super::core::Vec3 {
        &self.axis_turn_rates
    }
    fn axis_turn_rates_zoomed(&self) -> &super::core::Vec3 {
        &self.axis_turn_rates_zoomed
    }
    fn acceleration_drift_force(&self) -> &super::core::Vec3 {
        &self.acceleration_drift_force
    }
    fn turn_torques(&self) -> &super::core::Vec3 {
        &self.turn_torques
    }
    fn roll_torque(&self) -> &f32 {
        &self.roll_torque
    }
    fn yaw_roll_damping_time(&self) -> &f32 {
        &self.yaw_roll_damping_time
    }
    fn turn_rate_by_speed_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.turn_rate_by_speed_curve
    }
    fn steer_rates(&self) -> &super::core::Vec3 {
        &self.steer_rates
    }
    fn steer_rates_zoomed(&self) -> &super::core::Vec3 {
        &self.steer_rates_zoomed
    }
    fn steer_rate_roll(&self) -> &super::core::Vec3 {
        &self.steer_rate_roll
    }
    fn roll_rate_by_roll_ang_vel_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.roll_rate_by_roll_ang_vel_curve
    }
    fn torque_by_input_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.torque_by_input_curve
    }
    fn pitch_down_scale(&self) -> &f32 {
        &self.pitch_down_scale
    }
    fn target_fake_roll_angle(&self) -> &f32 {
        &self.target_fake_roll_angle
    }
    fn fake_roll_max_ang_vel(&self) -> &f32 {
        &self.fake_roll_max_ang_vel
    }
    fn max_roll_response_angle(&self) -> &f32 {
        &self.max_roll_response_angle
    }
    fn fake_roll_inverse_scale(&self) -> &f32 {
        &self.fake_roll_inverse_scale
    }
    fn fake_roll_acc_from_yaw_input(&self) -> &f32 {
        &self.fake_roll_acc_from_yaw_input
    }
    fn fake_roll_extra_yaw_input(&self) -> &f32 {
        &self.fake_roll_extra_yaw_input
    }
    fn fake_roll_extra_roll_input(&self) -> &f32 {
        &self.fake_roll_extra_roll_input
    }
    fn roll_angular_velocity_deadzone(&self) -> &f32 {
        &self.roll_angular_velocity_deadzone
    }
    fn air_brake_engine_speed_rate(&self) -> &f32 {
        &self.air_brake_engine_speed_rate
    }
    fn air_brake_input_mul(&self) -> &f32 {
        &self.air_brake_input_mul
    }
    fn air_brake_engine_mul(&self) -> &f32 {
        &self.air_brake_engine_mul
    }
    fn steer_rate_multiplier_airbraking(&self) -> &f32 {
        &self.steer_rate_multiplier_airbraking
    }
    fn turn_rate_multiplier_airbraking(&self) -> &f32 {
        &self.turn_rate_multiplier_airbraking
    }
    fn air_brake_level_lerp(&self) -> &f32 {
        &self.air_brake_level_lerp
    }
    fn self_right_strength(&self) -> &f32 {
        &self.self_right_strength
    }
    fn self_right_factor_yaw(&self) -> &super::core::Vec2 {
        &self.self_right_factor_yaw
    }
    fn self_right_factor_pitch(&self) -> &super::core::Vec2 {
        &self.self_right_factor_pitch
    }
    fn self_right_factor_roll(&self) -> &super::core::Vec2 {
        &self.self_right_factor_roll
    }
    fn self_right_against_inv_ang_vel(&self) -> &super::core::Vec3 {
        &self.self_right_against_inv_ang_vel
    }
    fn self_right_against_zoom(&self) -> &super::core::Vec2 {
        &self.self_right_against_zoom
    }
    fn self_right_strength_lerp(&self) -> &f32 {
        &self.self_right_strength_lerp
    }
    fn self_right_against_camera_forward_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.self_right_against_camera_forward_curve
    }
    fn self_right_against_world_up_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.self_right_against_world_up_curve
    }
    fn upright_roll_damping_time(&self) -> &f32 {
        &self.upright_roll_damping_time
    }
    fn self_right_timer_activation_delay(&self) -> &f32 {
        &self.self_right_timer_activation_delay
    }
    fn self_right_timer_minimum_roll_input(&self) -> &f32 {
        &self.self_right_timer_minimum_roll_input
    }
    fn self_right_timer_minimum_throttle_input(&self) -> &f32 {
        &self.self_right_timer_minimum_throttle_input
    }
    fn self_right_timer_minimum_yaw_input(&self) -> &f32 {
        &self.self_right_timer_minimum_yaw_input
    }
    fn self_right_timer_minimum_pitch_input(&self) -> &f32 {
        &self.self_right_timer_minimum_pitch_input
    }
    fn is_airspeeder(&self) -> &bool {
        &self.is_airspeeder
    }
    fn max_speed_override(&self) -> &f32 {
        &self.max_speed_override
    }
    fn boost_max_speed_override(&self) -> &f32 {
        &self.boost_max_speed_override
    }
    fn engine_acceleration_rate_override(&self) -> &f32 {
        &self.engine_acceleration_rate_override
    }
    fn engine_deceleration_rate_override(&self) -> &f32 {
        &self.engine_deceleration_rate_override
    }
    fn axis_turn_rates_override(&self) -> &super::core::Vec3 {
        &self.axis_turn_rates_override
    }
    fn axis_turn_rates_zoomed_override(&self) -> &super::core::Vec3 {
        &self.axis_turn_rates_zoomed_override
    }
    fn max_speed_multiplier(&self) -> &f32 {
        &self.max_speed_multiplier
    }
    fn boost_max_speed_multiplier(&self) -> &f32 {
        &self.boost_max_speed_multiplier
    }
    fn engine_acceleration_rate_multiplier(&self) -> &f32 {
        &self.engine_acceleration_rate_multiplier
    }
    fn engine_deceleration_rate_multiplier(&self) -> &f32 {
        &self.engine_deceleration_rate_multiplier
    }
    fn axis_turn_rates_multiplier(&self) -> &super::core::Vec3 {
        &self.axis_turn_rates_multiplier
    }
    fn axis_turn_rates_zoomed_multiplier(&self) -> &super::core::Vec3 {
        &self.axis_turn_rates_zoomed_multiplier
    }
}

impl super::entity::EntityDataTrait for StarfighterConfigEntityData {
}

impl super::entity::GameObjectDataTrait for StarfighterConfigEntityData {
}

impl super::core::DataBusPeerTrait for StarfighterConfigEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for StarfighterConfigEntityData {
}

impl super::core::DataContainerTrait for StarfighterConfigEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static STARFIGHTERCONFIGENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StarfighterConfigEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StarfighterConfigEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "EngineAccelerationRate",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterConfigEntityData, engine_acceleration_rate),
            },
            FieldInfoData {
                name: "BoostEngineAccelerationRate",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterConfigEntityData, boost_engine_acceleration_rate),
            },
            FieldInfoData {
                name: "EngineDecelerationRate",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterConfigEntityData, engine_deceleration_rate),
            },
            FieldInfoData {
                name: "MinSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterConfigEntityData, min_speed),
            },
            FieldInfoData {
                name: "MaxSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterConfigEntityData, max_speed),
            },
            FieldInfoData {
                name: "BoostMaxSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterConfigEntityData, boost_max_speed),
            },
            FieldInfoData {
                name: "SlowedEnginePowerScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterConfigEntityData, slowed_engine_power_scale),
            },
            FieldInfoData {
                name: "SteerRateThrottle",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(StarfighterConfigEntityData, steer_rate_throttle),
            },
            FieldInfoData {
                name: "AxisTurnRates",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(StarfighterConfigEntityData, axis_turn_rates),
            },
            FieldInfoData {
                name: "AxisTurnRatesZoomed",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(StarfighterConfigEntityData, axis_turn_rates_zoomed),
            },
            FieldInfoData {
                name: "AccelerationDriftForce",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(StarfighterConfigEntityData, acceleration_drift_force),
            },
            FieldInfoData {
                name: "TurnTorques",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(StarfighterConfigEntityData, turn_torques),
            },
            FieldInfoData {
                name: "RollTorque",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterConfigEntityData, roll_torque),
            },
            FieldInfoData {
                name: "YawRollDampingTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterConfigEntityData, yaw_roll_damping_time),
            },
            FieldInfoData {
                name: "TurnRateBySpeedCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(StarfighterConfigEntityData, turn_rate_by_speed_curve),
            },
            FieldInfoData {
                name: "SteerRates",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(StarfighterConfigEntityData, steer_rates),
            },
            FieldInfoData {
                name: "SteerRatesZoomed",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(StarfighterConfigEntityData, steer_rates_zoomed),
            },
            FieldInfoData {
                name: "SteerRateRoll",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(StarfighterConfigEntityData, steer_rate_roll),
            },
            FieldInfoData {
                name: "RollRateByRollAngVelCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(StarfighterConfigEntityData, roll_rate_by_roll_ang_vel_curve),
            },
            FieldInfoData {
                name: "TorqueByInputCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(StarfighterConfigEntityData, torque_by_input_curve),
            },
            FieldInfoData {
                name: "PitchDownScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterConfigEntityData, pitch_down_scale),
            },
            FieldInfoData {
                name: "TargetFakeRollAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterConfigEntityData, target_fake_roll_angle),
            },
            FieldInfoData {
                name: "FakeRollMaxAngVel",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterConfigEntityData, fake_roll_max_ang_vel),
            },
            FieldInfoData {
                name: "MaxRollResponseAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterConfigEntityData, max_roll_response_angle),
            },
            FieldInfoData {
                name: "FakeRollInverseScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterConfigEntityData, fake_roll_inverse_scale),
            },
            FieldInfoData {
                name: "FakeRollAccFromYawInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterConfigEntityData, fake_roll_acc_from_yaw_input),
            },
            FieldInfoData {
                name: "FakeRollExtraYawInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterConfigEntityData, fake_roll_extra_yaw_input),
            },
            FieldInfoData {
                name: "FakeRollExtraRollInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterConfigEntityData, fake_roll_extra_roll_input),
            },
            FieldInfoData {
                name: "RollAngularVelocityDeadzone",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterConfigEntityData, roll_angular_velocity_deadzone),
            },
            FieldInfoData {
                name: "AirBrakeEngineSpeedRate",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterConfigEntityData, air_brake_engine_speed_rate),
            },
            FieldInfoData {
                name: "AirBrakeInputMul",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterConfigEntityData, air_brake_input_mul),
            },
            FieldInfoData {
                name: "AirBrakeEngineMul",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterConfigEntityData, air_brake_engine_mul),
            },
            FieldInfoData {
                name: "SteerRateMultiplierAirbraking",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterConfigEntityData, steer_rate_multiplier_airbraking),
            },
            FieldInfoData {
                name: "TurnRateMultiplierAirbraking",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterConfigEntityData, turn_rate_multiplier_airbraking),
            },
            FieldInfoData {
                name: "AirBrakeLevelLerp",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterConfigEntityData, air_brake_level_lerp),
            },
            FieldInfoData {
                name: "SelfRightStrength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterConfigEntityData, self_right_strength),
            },
            FieldInfoData {
                name: "SelfRightFactorYaw",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(StarfighterConfigEntityData, self_right_factor_yaw),
            },
            FieldInfoData {
                name: "SelfRightFactorPitch",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(StarfighterConfigEntityData, self_right_factor_pitch),
            },
            FieldInfoData {
                name: "SelfRightFactorRoll",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(StarfighterConfigEntityData, self_right_factor_roll),
            },
            FieldInfoData {
                name: "SelfRightAgainstInvAngVel",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(StarfighterConfigEntityData, self_right_against_inv_ang_vel),
            },
            FieldInfoData {
                name: "SelfRightAgainstZoom",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(StarfighterConfigEntityData, self_right_against_zoom),
            },
            FieldInfoData {
                name: "SelfRightStrengthLerp",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterConfigEntityData, self_right_strength_lerp),
            },
            FieldInfoData {
                name: "SelfRightAgainstCameraForwardCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(StarfighterConfigEntityData, self_right_against_camera_forward_curve),
            },
            FieldInfoData {
                name: "SelfRightAgainstWorldUpCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(StarfighterConfigEntityData, self_right_against_world_up_curve),
            },
            FieldInfoData {
                name: "UprightRollDampingTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterConfigEntityData, upright_roll_damping_time),
            },
            FieldInfoData {
                name: "SelfRightTimerActivationDelay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterConfigEntityData, self_right_timer_activation_delay),
            },
            FieldInfoData {
                name: "SelfRightTimerMinimumRollInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterConfigEntityData, self_right_timer_minimum_roll_input),
            },
            FieldInfoData {
                name: "SelfRightTimerMinimumThrottleInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterConfigEntityData, self_right_timer_minimum_throttle_input),
            },
            FieldInfoData {
                name: "SelfRightTimerMinimumYawInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterConfigEntityData, self_right_timer_minimum_yaw_input),
            },
            FieldInfoData {
                name: "SelfRightTimerMinimumPitchInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterConfigEntityData, self_right_timer_minimum_pitch_input),
            },
            FieldInfoData {
                name: "IsAirspeeder",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(StarfighterConfigEntityData, is_airspeeder),
            },
            FieldInfoData {
                name: "MaxSpeedOverride",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterConfigEntityData, max_speed_override),
            },
            FieldInfoData {
                name: "BoostMaxSpeedOverride",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterConfigEntityData, boost_max_speed_override),
            },
            FieldInfoData {
                name: "EngineAccelerationRateOverride",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterConfigEntityData, engine_acceleration_rate_override),
            },
            FieldInfoData {
                name: "EngineDecelerationRateOverride",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterConfigEntityData, engine_deceleration_rate_override),
            },
            FieldInfoData {
                name: "AxisTurnRatesOverride",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(StarfighterConfigEntityData, axis_turn_rates_override),
            },
            FieldInfoData {
                name: "AxisTurnRatesZoomedOverride",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(StarfighterConfigEntityData, axis_turn_rates_zoomed_override),
            },
            FieldInfoData {
                name: "MaxSpeedMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterConfigEntityData, max_speed_multiplier),
            },
            FieldInfoData {
                name: "BoostMaxSpeedMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterConfigEntityData, boost_max_speed_multiplier),
            },
            FieldInfoData {
                name: "EngineAccelerationRateMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterConfigEntityData, engine_acceleration_rate_multiplier),
            },
            FieldInfoData {
                name: "EngineDecelerationRateMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StarfighterConfigEntityData, engine_deceleration_rate_multiplier),
            },
            FieldInfoData {
                name: "AxisTurnRatesMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(StarfighterConfigEntityData, axis_turn_rates_multiplier),
            },
            FieldInfoData {
                name: "AxisTurnRatesZoomedMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(StarfighterConfigEntityData, axis_turn_rates_zoomed_multiplier),
            },
        ],
    }),
    array_type: Some(STARFIGHTERCONFIGENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for StarfighterConfigEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        STARFIGHTERCONFIGENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static STARFIGHTERCONFIGENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StarfighterConfigEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("StarfighterConfigEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SpeederBikePhysicsActionData {
    pub _glacier_base: PhysicsActionBaseData,
    pub is_boosting: bool,
    pub max_torque_scales: super::core::Vec3,
    pub look_frame_offset: super::core::LinearTransform,
    pub height_look_scale: f32,
    pub input_action_pitch: i32,
    pub input_action_yaw: i32,
    pub input_action_throttle: i32,
    pub input_action_boost: i32,
    pub input_action_strafe: i32,
    pub r_s_turn_pow: f32,
    pub r_s_turn_pow_user_setting_deviation: f32,
    pub strafe_speed_factor: f32,
    pub strafe_state_change_rate: f32,
    pub strafe_deadzone: f32,
    pub strafe_speed: f32,
    pub strafe_acceleration: f32,
    pub boost_rate: f32,
    pub acc_rate: f32,
    pub diff_to_acc: f32,
    pub extra_gravity: f32,
    pub anti_pitch: f32,
    pub anti_drift: f32,
    pub camber_thrust_pow: f32,
    pub move_frame_turn_rate: f32,
    pub strafe_angle: super::core::Vec2,
    pub turn_pow: super::core::Vec2,
    pub move_pow: super::core::Vec2,
    pub turn_rate: super::core::Vec2,
    pub cruise_speed_m_p_s: f32,
    pub strafe_speed_m_p_s: f32,
    pub acceleration_min_max: super::core::Vec2,
    pub force_min_max: super::core::Vec2,
    pub boost_turn: super::core::Vec2,
    pub turn_steer_rate: super::core::Vec3,
    pub strafe_steer_rate: super::core::Vec3,
    pub height_steer_rate: super::core::Vec3,
    pub pitch_steer_rate: super::core::Vec3,
    pub force_rate: super::core::Vec3,
    pub force_apply_offset: super::core::Vec3,
    pub roll_gravity: super::core::Vec3,
    pub diff_pow: super::core::Vec3,
    pub turn_torque: super::core::Vec3,
    pub diff_to_torque: super::core::Vec3,
    pub tail_drag: super::core::Vec3,
    pub static_tail_drag: super::core::Vec3,
    pub local_tail_offset: super::core::Vec3,
    pub look_convergence: f32,
    pub upright_smoothing: f32,
    pub upright_extrapolate: f32,
    pub yaw_extrapolate: f32,
    pub yaw_extrapolate_strafe: f32,
    pub turn_rate_curve: super::core::AudioCurve,
    pub strafe_angle_curve: super::core::AudioCurve,
    pub thrust_per_height_curve: super::core::AudioCurve,
    pub gravity_curve: super::core::AudioCurve,
    pub height_curve: super::core::AudioCurve,
    pub anti_pitch_curve: super::core::AudioCurve,
    pub boost_curve: super::core::AudioCurve,
    pub use_set_and_forget_throttle: bool,
    pub set_and_forget_throttle_input_accel_rate: f32,
    pub set_and_forget_throttle_input_decel_rate: f32,
    pub reference_max_speed: f32,
    pub base_slipstreaming_value: f32,
    pub slipstreaming_angle_multiplier: super::core::AudioCurve,
    pub slipstreaming_distance_multiplier: super::core::AudioCurve,
}

pub trait SpeederBikePhysicsActionDataTrait: PhysicsActionBaseDataTrait {
    fn is_boosting(&self) -> &bool;
    fn max_torque_scales(&self) -> &super::core::Vec3;
    fn look_frame_offset(&self) -> &super::core::LinearTransform;
    fn height_look_scale(&self) -> &f32;
    fn input_action_pitch(&self) -> &i32;
    fn input_action_yaw(&self) -> &i32;
    fn input_action_throttle(&self) -> &i32;
    fn input_action_boost(&self) -> &i32;
    fn input_action_strafe(&self) -> &i32;
    fn r_s_turn_pow(&self) -> &f32;
    fn r_s_turn_pow_user_setting_deviation(&self) -> &f32;
    fn strafe_speed_factor(&self) -> &f32;
    fn strafe_state_change_rate(&self) -> &f32;
    fn strafe_deadzone(&self) -> &f32;
    fn strafe_speed(&self) -> &f32;
    fn strafe_acceleration(&self) -> &f32;
    fn boost_rate(&self) -> &f32;
    fn acc_rate(&self) -> &f32;
    fn diff_to_acc(&self) -> &f32;
    fn extra_gravity(&self) -> &f32;
    fn anti_pitch(&self) -> &f32;
    fn anti_drift(&self) -> &f32;
    fn camber_thrust_pow(&self) -> &f32;
    fn move_frame_turn_rate(&self) -> &f32;
    fn strafe_angle(&self) -> &super::core::Vec2;
    fn turn_pow(&self) -> &super::core::Vec2;
    fn move_pow(&self) -> &super::core::Vec2;
    fn turn_rate(&self) -> &super::core::Vec2;
    fn cruise_speed_m_p_s(&self) -> &f32;
    fn strafe_speed_m_p_s(&self) -> &f32;
    fn acceleration_min_max(&self) -> &super::core::Vec2;
    fn force_min_max(&self) -> &super::core::Vec2;
    fn boost_turn(&self) -> &super::core::Vec2;
    fn turn_steer_rate(&self) -> &super::core::Vec3;
    fn strafe_steer_rate(&self) -> &super::core::Vec3;
    fn height_steer_rate(&self) -> &super::core::Vec3;
    fn pitch_steer_rate(&self) -> &super::core::Vec3;
    fn force_rate(&self) -> &super::core::Vec3;
    fn force_apply_offset(&self) -> &super::core::Vec3;
    fn roll_gravity(&self) -> &super::core::Vec3;
    fn diff_pow(&self) -> &super::core::Vec3;
    fn turn_torque(&self) -> &super::core::Vec3;
    fn diff_to_torque(&self) -> &super::core::Vec3;
    fn tail_drag(&self) -> &super::core::Vec3;
    fn static_tail_drag(&self) -> &super::core::Vec3;
    fn local_tail_offset(&self) -> &super::core::Vec3;
    fn look_convergence(&self) -> &f32;
    fn upright_smoothing(&self) -> &f32;
    fn upright_extrapolate(&self) -> &f32;
    fn yaw_extrapolate(&self) -> &f32;
    fn yaw_extrapolate_strafe(&self) -> &f32;
    fn turn_rate_curve(&self) -> &super::core::AudioCurve;
    fn strafe_angle_curve(&self) -> &super::core::AudioCurve;
    fn thrust_per_height_curve(&self) -> &super::core::AudioCurve;
    fn gravity_curve(&self) -> &super::core::AudioCurve;
    fn height_curve(&self) -> &super::core::AudioCurve;
    fn anti_pitch_curve(&self) -> &super::core::AudioCurve;
    fn boost_curve(&self) -> &super::core::AudioCurve;
    fn use_set_and_forget_throttle(&self) -> &bool;
    fn set_and_forget_throttle_input_accel_rate(&self) -> &f32;
    fn set_and_forget_throttle_input_decel_rate(&self) -> &f32;
    fn reference_max_speed(&self) -> &f32;
    fn base_slipstreaming_value(&self) -> &f32;
    fn slipstreaming_angle_multiplier(&self) -> &super::core::AudioCurve;
    fn slipstreaming_distance_multiplier(&self) -> &super::core::AudioCurve;
}

impl SpeederBikePhysicsActionDataTrait for SpeederBikePhysicsActionData {
    fn is_boosting(&self) -> &bool {
        &self.is_boosting
    }
    fn max_torque_scales(&self) -> &super::core::Vec3 {
        &self.max_torque_scales
    }
    fn look_frame_offset(&self) -> &super::core::LinearTransform {
        &self.look_frame_offset
    }
    fn height_look_scale(&self) -> &f32 {
        &self.height_look_scale
    }
    fn input_action_pitch(&self) -> &i32 {
        &self.input_action_pitch
    }
    fn input_action_yaw(&self) -> &i32 {
        &self.input_action_yaw
    }
    fn input_action_throttle(&self) -> &i32 {
        &self.input_action_throttle
    }
    fn input_action_boost(&self) -> &i32 {
        &self.input_action_boost
    }
    fn input_action_strafe(&self) -> &i32 {
        &self.input_action_strafe
    }
    fn r_s_turn_pow(&self) -> &f32 {
        &self.r_s_turn_pow
    }
    fn r_s_turn_pow_user_setting_deviation(&self) -> &f32 {
        &self.r_s_turn_pow_user_setting_deviation
    }
    fn strafe_speed_factor(&self) -> &f32 {
        &self.strafe_speed_factor
    }
    fn strafe_state_change_rate(&self) -> &f32 {
        &self.strafe_state_change_rate
    }
    fn strafe_deadzone(&self) -> &f32 {
        &self.strafe_deadzone
    }
    fn strafe_speed(&self) -> &f32 {
        &self.strafe_speed
    }
    fn strafe_acceleration(&self) -> &f32 {
        &self.strafe_acceleration
    }
    fn boost_rate(&self) -> &f32 {
        &self.boost_rate
    }
    fn acc_rate(&self) -> &f32 {
        &self.acc_rate
    }
    fn diff_to_acc(&self) -> &f32 {
        &self.diff_to_acc
    }
    fn extra_gravity(&self) -> &f32 {
        &self.extra_gravity
    }
    fn anti_pitch(&self) -> &f32 {
        &self.anti_pitch
    }
    fn anti_drift(&self) -> &f32 {
        &self.anti_drift
    }
    fn camber_thrust_pow(&self) -> &f32 {
        &self.camber_thrust_pow
    }
    fn move_frame_turn_rate(&self) -> &f32 {
        &self.move_frame_turn_rate
    }
    fn strafe_angle(&self) -> &super::core::Vec2 {
        &self.strafe_angle
    }
    fn turn_pow(&self) -> &super::core::Vec2 {
        &self.turn_pow
    }
    fn move_pow(&self) -> &super::core::Vec2 {
        &self.move_pow
    }
    fn turn_rate(&self) -> &super::core::Vec2 {
        &self.turn_rate
    }
    fn cruise_speed_m_p_s(&self) -> &f32 {
        &self.cruise_speed_m_p_s
    }
    fn strafe_speed_m_p_s(&self) -> &f32 {
        &self.strafe_speed_m_p_s
    }
    fn acceleration_min_max(&self) -> &super::core::Vec2 {
        &self.acceleration_min_max
    }
    fn force_min_max(&self) -> &super::core::Vec2 {
        &self.force_min_max
    }
    fn boost_turn(&self) -> &super::core::Vec2 {
        &self.boost_turn
    }
    fn turn_steer_rate(&self) -> &super::core::Vec3 {
        &self.turn_steer_rate
    }
    fn strafe_steer_rate(&self) -> &super::core::Vec3 {
        &self.strafe_steer_rate
    }
    fn height_steer_rate(&self) -> &super::core::Vec3 {
        &self.height_steer_rate
    }
    fn pitch_steer_rate(&self) -> &super::core::Vec3 {
        &self.pitch_steer_rate
    }
    fn force_rate(&self) -> &super::core::Vec3 {
        &self.force_rate
    }
    fn force_apply_offset(&self) -> &super::core::Vec3 {
        &self.force_apply_offset
    }
    fn roll_gravity(&self) -> &super::core::Vec3 {
        &self.roll_gravity
    }
    fn diff_pow(&self) -> &super::core::Vec3 {
        &self.diff_pow
    }
    fn turn_torque(&self) -> &super::core::Vec3 {
        &self.turn_torque
    }
    fn diff_to_torque(&self) -> &super::core::Vec3 {
        &self.diff_to_torque
    }
    fn tail_drag(&self) -> &super::core::Vec3 {
        &self.tail_drag
    }
    fn static_tail_drag(&self) -> &super::core::Vec3 {
        &self.static_tail_drag
    }
    fn local_tail_offset(&self) -> &super::core::Vec3 {
        &self.local_tail_offset
    }
    fn look_convergence(&self) -> &f32 {
        &self.look_convergence
    }
    fn upright_smoothing(&self) -> &f32 {
        &self.upright_smoothing
    }
    fn upright_extrapolate(&self) -> &f32 {
        &self.upright_extrapolate
    }
    fn yaw_extrapolate(&self) -> &f32 {
        &self.yaw_extrapolate
    }
    fn yaw_extrapolate_strafe(&self) -> &f32 {
        &self.yaw_extrapolate_strafe
    }
    fn turn_rate_curve(&self) -> &super::core::AudioCurve {
        &self.turn_rate_curve
    }
    fn strafe_angle_curve(&self) -> &super::core::AudioCurve {
        &self.strafe_angle_curve
    }
    fn thrust_per_height_curve(&self) -> &super::core::AudioCurve {
        &self.thrust_per_height_curve
    }
    fn gravity_curve(&self) -> &super::core::AudioCurve {
        &self.gravity_curve
    }
    fn height_curve(&self) -> &super::core::AudioCurve {
        &self.height_curve
    }
    fn anti_pitch_curve(&self) -> &super::core::AudioCurve {
        &self.anti_pitch_curve
    }
    fn boost_curve(&self) -> &super::core::AudioCurve {
        &self.boost_curve
    }
    fn use_set_and_forget_throttle(&self) -> &bool {
        &self.use_set_and_forget_throttle
    }
    fn set_and_forget_throttle_input_accel_rate(&self) -> &f32 {
        &self.set_and_forget_throttle_input_accel_rate
    }
    fn set_and_forget_throttle_input_decel_rate(&self) -> &f32 {
        &self.set_and_forget_throttle_input_decel_rate
    }
    fn reference_max_speed(&self) -> &f32 {
        &self.reference_max_speed
    }
    fn base_slipstreaming_value(&self) -> &f32 {
        &self.base_slipstreaming_value
    }
    fn slipstreaming_angle_multiplier(&self) -> &super::core::AudioCurve {
        &self.slipstreaming_angle_multiplier
    }
    fn slipstreaming_distance_multiplier(&self) -> &super::core::AudioCurve {
        &self.slipstreaming_distance_multiplier
    }
}

impl PhysicsActionBaseDataTrait for SpeederBikePhysicsActionData {
    fn blend_factor(&self) -> &f32 {
        self._glacier_base.blend_factor()
    }
    fn input_blend_factor(&self) -> &f32 {
        self._glacier_base.input_blend_factor()
    }
    fn clamp_lin_acc(&self) -> &f32 {
        self._glacier_base.clamp_lin_acc()
    }
    fn clamp_ang_acc(&self) -> &f32 {
        self._glacier_base.clamp_ang_acc()
    }
    fn blend_factor_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.blend_factor_curve()
    }
    fn collision_response_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.collision_response_curve()
    }
}

impl super::entity::EntityDataTrait for SpeederBikePhysicsActionData {
}

impl super::entity::GameObjectDataTrait for SpeederBikePhysicsActionData {
}

impl super::core::DataBusPeerTrait for SpeederBikePhysicsActionData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for SpeederBikePhysicsActionData {
}

impl super::core::DataContainerTrait for SpeederBikePhysicsActionData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SPEEDERBIKEPHYSICSACTIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpeederBikePhysicsActionData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PHYSICSACTIONBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SpeederBikePhysicsActionData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "IsBoosting",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, is_boosting),
            },
            FieldInfoData {
                name: "MaxTorqueScales",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, max_torque_scales),
            },
            FieldInfoData {
                name: "LookFrameOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, look_frame_offset),
            },
            FieldInfoData {
                name: "HeightLookScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, height_look_scale),
            },
            FieldInfoData {
                name: "InputActionPitch",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, input_action_pitch),
            },
            FieldInfoData {
                name: "InputActionYaw",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, input_action_yaw),
            },
            FieldInfoData {
                name: "InputActionThrottle",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, input_action_throttle),
            },
            FieldInfoData {
                name: "InputActionBoost",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, input_action_boost),
            },
            FieldInfoData {
                name: "InputActionStrafe",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, input_action_strafe),
            },
            FieldInfoData {
                name: "RSTurnPow",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, r_s_turn_pow),
            },
            FieldInfoData {
                name: "RSTurnPowUserSettingDeviation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, r_s_turn_pow_user_setting_deviation),
            },
            FieldInfoData {
                name: "StrafeSpeedFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, strafe_speed_factor),
            },
            FieldInfoData {
                name: "StrafeStateChangeRate",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, strafe_state_change_rate),
            },
            FieldInfoData {
                name: "StrafeDeadzone",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, strafe_deadzone),
            },
            FieldInfoData {
                name: "StrafeSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, strafe_speed),
            },
            FieldInfoData {
                name: "StrafeAcceleration",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, strafe_acceleration),
            },
            FieldInfoData {
                name: "BoostRate",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, boost_rate),
            },
            FieldInfoData {
                name: "AccRate",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, acc_rate),
            },
            FieldInfoData {
                name: "DiffToAcc",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, diff_to_acc),
            },
            FieldInfoData {
                name: "ExtraGravity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, extra_gravity),
            },
            FieldInfoData {
                name: "AntiPitch",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, anti_pitch),
            },
            FieldInfoData {
                name: "AntiDrift",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, anti_drift),
            },
            FieldInfoData {
                name: "CamberThrustPow",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, camber_thrust_pow),
            },
            FieldInfoData {
                name: "MoveFrameTurnRate",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, move_frame_turn_rate),
            },
            FieldInfoData {
                name: "StrafeAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, strafe_angle),
            },
            FieldInfoData {
                name: "TurnPow",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, turn_pow),
            },
            FieldInfoData {
                name: "MovePow",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, move_pow),
            },
            FieldInfoData {
                name: "TurnRate",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, turn_rate),
            },
            FieldInfoData {
                name: "CruiseSpeedMPS",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, cruise_speed_m_p_s),
            },
            FieldInfoData {
                name: "StrafeSpeedMPS",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, strafe_speed_m_p_s),
            },
            FieldInfoData {
                name: "AccelerationMinMax",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, acceleration_min_max),
            },
            FieldInfoData {
                name: "ForceMinMax",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, force_min_max),
            },
            FieldInfoData {
                name: "BoostTurn",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, boost_turn),
            },
            FieldInfoData {
                name: "TurnSteerRate",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, turn_steer_rate),
            },
            FieldInfoData {
                name: "StrafeSteerRate",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, strafe_steer_rate),
            },
            FieldInfoData {
                name: "HeightSteerRate",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, height_steer_rate),
            },
            FieldInfoData {
                name: "PitchSteerRate",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, pitch_steer_rate),
            },
            FieldInfoData {
                name: "ForceRate",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, force_rate),
            },
            FieldInfoData {
                name: "ForceApplyOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, force_apply_offset),
            },
            FieldInfoData {
                name: "RollGravity",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, roll_gravity),
            },
            FieldInfoData {
                name: "DiffPow",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, diff_pow),
            },
            FieldInfoData {
                name: "TurnTorque",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, turn_torque),
            },
            FieldInfoData {
                name: "DiffToTorque",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, diff_to_torque),
            },
            FieldInfoData {
                name: "TailDrag",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, tail_drag),
            },
            FieldInfoData {
                name: "StaticTailDrag",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, static_tail_drag),
            },
            FieldInfoData {
                name: "LocalTailOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, local_tail_offset),
            },
            FieldInfoData {
                name: "LookConvergence",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, look_convergence),
            },
            FieldInfoData {
                name: "UprightSmoothing",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, upright_smoothing),
            },
            FieldInfoData {
                name: "UprightExtrapolate",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, upright_extrapolate),
            },
            FieldInfoData {
                name: "YawExtrapolate",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, yaw_extrapolate),
            },
            FieldInfoData {
                name: "YawExtrapolateStrafe",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, yaw_extrapolate_strafe),
            },
            FieldInfoData {
                name: "TurnRateCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioCurve",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, turn_rate_curve),
            },
            FieldInfoData {
                name: "StrafeAngleCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioCurve",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, strafe_angle_curve),
            },
            FieldInfoData {
                name: "ThrustPerHeightCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioCurve",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, thrust_per_height_curve),
            },
            FieldInfoData {
                name: "GravityCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioCurve",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, gravity_curve),
            },
            FieldInfoData {
                name: "HeightCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioCurve",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, height_curve),
            },
            FieldInfoData {
                name: "AntiPitchCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioCurve",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, anti_pitch_curve),
            },
            FieldInfoData {
                name: "BoostCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioCurve",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, boost_curve),
            },
            FieldInfoData {
                name: "UseSetAndForgetThrottle",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, use_set_and_forget_throttle),
            },
            FieldInfoData {
                name: "SetAndForgetThrottleInputAccelRate",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, set_and_forget_throttle_input_accel_rate),
            },
            FieldInfoData {
                name: "SetAndForgetThrottleInputDecelRate",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, set_and_forget_throttle_input_decel_rate),
            },
            FieldInfoData {
                name: "ReferenceMaxSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, reference_max_speed),
            },
            FieldInfoData {
                name: "BaseSlipstreamingValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, base_slipstreaming_value),
            },
            FieldInfoData {
                name: "SlipstreamingAngleMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioCurve",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, slipstreaming_angle_multiplier),
            },
            FieldInfoData {
                name: "SlipstreamingDistanceMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioCurve",
                rust_offset: offset_of!(SpeederBikePhysicsActionData, slipstreaming_distance_multiplier),
            },
        ],
    }),
    array_type: Some(SPEEDERBIKEPHYSICSACTIONDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SpeederBikePhysicsActionData {
    fn type_info(&self) -> &'static TypeInfo {
        SPEEDERBIKEPHYSICSACTIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SPEEDERBIKEPHYSICSACTIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpeederBikePhysicsActionData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("SpeederBikePhysicsActionData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RepulsorLiftPhysicsActionData {
    pub _glacier_base: PhysicsActionBaseData,
    pub height_steer_input_action: i32,
    pub height_steer_rate: super::core::Vec3,
    pub height_curve: super::core::AudioCurve,
    pub allow_height_curve_override: bool,
    pub hover_height_no_player: f32,
    pub hover_over_water: bool,
    pub gravity_curve: super::core::AudioCurve,
    pub extra_gravity: f32,
    pub front_offset: super::core::Vec3,
    pub rear_offset: super::core::Vec3,
    pub extrapolate_time: f32,
    pub front_down_extrapolate_time: f32,
    pub min_hit_normal_y: f32,
    pub hover_height: f32,
    pub raycast_height_multiplier: f32,
    pub raycast_input_steer_amount: f32,
    pub raycast_steer_rate: super::core::Vec3,
    pub raycast_steer_input_action: i32,
    pub forward_raycast_count: u32,
    pub over_cast: f32,
    pub over_cast2: f32,
    pub cast_width: f32,
    pub min_sample_dist: f32,
    pub max_slope: f32,
    pub over_wall_look_ahead: f32,
    pub std_dev_spring: f32,
    pub std_dev_bumper: f32,
    pub spring_c: f32,
    pub collision_spring_strength: f32,
    pub collision_spring_min_distance: f32,
    pub min_reasonable_speed: f32,
    pub max_forwards_angle: f32,
    pub forwards_smoothing: f32,
    pub force_per_vertical_velocity_curve: super::core::AudioCurve,
    pub max_vel_slope: f32,
    pub repulsor_strength: f32,
    pub max_slope_for_positive_repulsor: f32,
    pub repulsor_strength_positive: f32,
    pub repulsor_strength_negative: f32,
    pub repulsor_damping_positive: f32,
    pub repulsor_damping_negative: f32,
    pub repulsor_damping_positive_non_critical: f32,
    pub repulsor_damping_negative_non_critical: f32,
    pub sample_purge_min_side_distance: f32,
    pub height_force_fade_start: f32,
    pub height_force_fade_end: f32,
    pub velocity_slope_scalar: f32,
    pub repulsor_damping: f32,
    pub max_force: f32,
    pub target_hover_height: f32,
    pub max_height_cast_origin_offset_local_space: super::core::Vec3,
    pub max_height_raycast_length: f32,
    pub max_height_clearance: f32,
    pub min_ground_clearance: f32,
    pub max_height_up_adjustment_speed: f32,
    pub max_height_down_adjustment_speed: f32,
    pub y_intercept_lerp: f32,
    pub slope_lerp: f32,
    pub standard_deviation_lerp: f32,
}

pub trait RepulsorLiftPhysicsActionDataTrait: PhysicsActionBaseDataTrait {
    fn height_steer_input_action(&self) -> &i32;
    fn height_steer_rate(&self) -> &super::core::Vec3;
    fn height_curve(&self) -> &super::core::AudioCurve;
    fn allow_height_curve_override(&self) -> &bool;
    fn hover_height_no_player(&self) -> &f32;
    fn hover_over_water(&self) -> &bool;
    fn gravity_curve(&self) -> &super::core::AudioCurve;
    fn extra_gravity(&self) -> &f32;
    fn front_offset(&self) -> &super::core::Vec3;
    fn rear_offset(&self) -> &super::core::Vec3;
    fn extrapolate_time(&self) -> &f32;
    fn front_down_extrapolate_time(&self) -> &f32;
    fn min_hit_normal_y(&self) -> &f32;
    fn hover_height(&self) -> &f32;
    fn raycast_height_multiplier(&self) -> &f32;
    fn raycast_input_steer_amount(&self) -> &f32;
    fn raycast_steer_rate(&self) -> &super::core::Vec3;
    fn raycast_steer_input_action(&self) -> &i32;
    fn forward_raycast_count(&self) -> &u32;
    fn over_cast(&self) -> &f32;
    fn over_cast2(&self) -> &f32;
    fn cast_width(&self) -> &f32;
    fn min_sample_dist(&self) -> &f32;
    fn max_slope(&self) -> &f32;
    fn over_wall_look_ahead(&self) -> &f32;
    fn std_dev_spring(&self) -> &f32;
    fn std_dev_bumper(&self) -> &f32;
    fn spring_c(&self) -> &f32;
    fn collision_spring_strength(&self) -> &f32;
    fn collision_spring_min_distance(&self) -> &f32;
    fn min_reasonable_speed(&self) -> &f32;
    fn max_forwards_angle(&self) -> &f32;
    fn forwards_smoothing(&self) -> &f32;
    fn force_per_vertical_velocity_curve(&self) -> &super::core::AudioCurve;
    fn max_vel_slope(&self) -> &f32;
    fn repulsor_strength(&self) -> &f32;
    fn max_slope_for_positive_repulsor(&self) -> &f32;
    fn repulsor_strength_positive(&self) -> &f32;
    fn repulsor_strength_negative(&self) -> &f32;
    fn repulsor_damping_positive(&self) -> &f32;
    fn repulsor_damping_negative(&self) -> &f32;
    fn repulsor_damping_positive_non_critical(&self) -> &f32;
    fn repulsor_damping_negative_non_critical(&self) -> &f32;
    fn sample_purge_min_side_distance(&self) -> &f32;
    fn height_force_fade_start(&self) -> &f32;
    fn height_force_fade_end(&self) -> &f32;
    fn velocity_slope_scalar(&self) -> &f32;
    fn repulsor_damping(&self) -> &f32;
    fn max_force(&self) -> &f32;
    fn target_hover_height(&self) -> &f32;
    fn max_height_cast_origin_offset_local_space(&self) -> &super::core::Vec3;
    fn max_height_raycast_length(&self) -> &f32;
    fn max_height_clearance(&self) -> &f32;
    fn min_ground_clearance(&self) -> &f32;
    fn max_height_up_adjustment_speed(&self) -> &f32;
    fn max_height_down_adjustment_speed(&self) -> &f32;
    fn y_intercept_lerp(&self) -> &f32;
    fn slope_lerp(&self) -> &f32;
    fn standard_deviation_lerp(&self) -> &f32;
}

impl RepulsorLiftPhysicsActionDataTrait for RepulsorLiftPhysicsActionData {
    fn height_steer_input_action(&self) -> &i32 {
        &self.height_steer_input_action
    }
    fn height_steer_rate(&self) -> &super::core::Vec3 {
        &self.height_steer_rate
    }
    fn height_curve(&self) -> &super::core::AudioCurve {
        &self.height_curve
    }
    fn allow_height_curve_override(&self) -> &bool {
        &self.allow_height_curve_override
    }
    fn hover_height_no_player(&self) -> &f32 {
        &self.hover_height_no_player
    }
    fn hover_over_water(&self) -> &bool {
        &self.hover_over_water
    }
    fn gravity_curve(&self) -> &super::core::AudioCurve {
        &self.gravity_curve
    }
    fn extra_gravity(&self) -> &f32 {
        &self.extra_gravity
    }
    fn front_offset(&self) -> &super::core::Vec3 {
        &self.front_offset
    }
    fn rear_offset(&self) -> &super::core::Vec3 {
        &self.rear_offset
    }
    fn extrapolate_time(&self) -> &f32 {
        &self.extrapolate_time
    }
    fn front_down_extrapolate_time(&self) -> &f32 {
        &self.front_down_extrapolate_time
    }
    fn min_hit_normal_y(&self) -> &f32 {
        &self.min_hit_normal_y
    }
    fn hover_height(&self) -> &f32 {
        &self.hover_height
    }
    fn raycast_height_multiplier(&self) -> &f32 {
        &self.raycast_height_multiplier
    }
    fn raycast_input_steer_amount(&self) -> &f32 {
        &self.raycast_input_steer_amount
    }
    fn raycast_steer_rate(&self) -> &super::core::Vec3 {
        &self.raycast_steer_rate
    }
    fn raycast_steer_input_action(&self) -> &i32 {
        &self.raycast_steer_input_action
    }
    fn forward_raycast_count(&self) -> &u32 {
        &self.forward_raycast_count
    }
    fn over_cast(&self) -> &f32 {
        &self.over_cast
    }
    fn over_cast2(&self) -> &f32 {
        &self.over_cast2
    }
    fn cast_width(&self) -> &f32 {
        &self.cast_width
    }
    fn min_sample_dist(&self) -> &f32 {
        &self.min_sample_dist
    }
    fn max_slope(&self) -> &f32 {
        &self.max_slope
    }
    fn over_wall_look_ahead(&self) -> &f32 {
        &self.over_wall_look_ahead
    }
    fn std_dev_spring(&self) -> &f32 {
        &self.std_dev_spring
    }
    fn std_dev_bumper(&self) -> &f32 {
        &self.std_dev_bumper
    }
    fn spring_c(&self) -> &f32 {
        &self.spring_c
    }
    fn collision_spring_strength(&self) -> &f32 {
        &self.collision_spring_strength
    }
    fn collision_spring_min_distance(&self) -> &f32 {
        &self.collision_spring_min_distance
    }
    fn min_reasonable_speed(&self) -> &f32 {
        &self.min_reasonable_speed
    }
    fn max_forwards_angle(&self) -> &f32 {
        &self.max_forwards_angle
    }
    fn forwards_smoothing(&self) -> &f32 {
        &self.forwards_smoothing
    }
    fn force_per_vertical_velocity_curve(&self) -> &super::core::AudioCurve {
        &self.force_per_vertical_velocity_curve
    }
    fn max_vel_slope(&self) -> &f32 {
        &self.max_vel_slope
    }
    fn repulsor_strength(&self) -> &f32 {
        &self.repulsor_strength
    }
    fn max_slope_for_positive_repulsor(&self) -> &f32 {
        &self.max_slope_for_positive_repulsor
    }
    fn repulsor_strength_positive(&self) -> &f32 {
        &self.repulsor_strength_positive
    }
    fn repulsor_strength_negative(&self) -> &f32 {
        &self.repulsor_strength_negative
    }
    fn repulsor_damping_positive(&self) -> &f32 {
        &self.repulsor_damping_positive
    }
    fn repulsor_damping_negative(&self) -> &f32 {
        &self.repulsor_damping_negative
    }
    fn repulsor_damping_positive_non_critical(&self) -> &f32 {
        &self.repulsor_damping_positive_non_critical
    }
    fn repulsor_damping_negative_non_critical(&self) -> &f32 {
        &self.repulsor_damping_negative_non_critical
    }
    fn sample_purge_min_side_distance(&self) -> &f32 {
        &self.sample_purge_min_side_distance
    }
    fn height_force_fade_start(&self) -> &f32 {
        &self.height_force_fade_start
    }
    fn height_force_fade_end(&self) -> &f32 {
        &self.height_force_fade_end
    }
    fn velocity_slope_scalar(&self) -> &f32 {
        &self.velocity_slope_scalar
    }
    fn repulsor_damping(&self) -> &f32 {
        &self.repulsor_damping
    }
    fn max_force(&self) -> &f32 {
        &self.max_force
    }
    fn target_hover_height(&self) -> &f32 {
        &self.target_hover_height
    }
    fn max_height_cast_origin_offset_local_space(&self) -> &super::core::Vec3 {
        &self.max_height_cast_origin_offset_local_space
    }
    fn max_height_raycast_length(&self) -> &f32 {
        &self.max_height_raycast_length
    }
    fn max_height_clearance(&self) -> &f32 {
        &self.max_height_clearance
    }
    fn min_ground_clearance(&self) -> &f32 {
        &self.min_ground_clearance
    }
    fn max_height_up_adjustment_speed(&self) -> &f32 {
        &self.max_height_up_adjustment_speed
    }
    fn max_height_down_adjustment_speed(&self) -> &f32 {
        &self.max_height_down_adjustment_speed
    }
    fn y_intercept_lerp(&self) -> &f32 {
        &self.y_intercept_lerp
    }
    fn slope_lerp(&self) -> &f32 {
        &self.slope_lerp
    }
    fn standard_deviation_lerp(&self) -> &f32 {
        &self.standard_deviation_lerp
    }
}

impl PhysicsActionBaseDataTrait for RepulsorLiftPhysicsActionData {
    fn blend_factor(&self) -> &f32 {
        self._glacier_base.blend_factor()
    }
    fn input_blend_factor(&self) -> &f32 {
        self._glacier_base.input_blend_factor()
    }
    fn clamp_lin_acc(&self) -> &f32 {
        self._glacier_base.clamp_lin_acc()
    }
    fn clamp_ang_acc(&self) -> &f32 {
        self._glacier_base.clamp_ang_acc()
    }
    fn blend_factor_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.blend_factor_curve()
    }
    fn collision_response_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.collision_response_curve()
    }
}

impl super::entity::EntityDataTrait for RepulsorLiftPhysicsActionData {
}

impl super::entity::GameObjectDataTrait for RepulsorLiftPhysicsActionData {
}

impl super::core::DataBusPeerTrait for RepulsorLiftPhysicsActionData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for RepulsorLiftPhysicsActionData {
}

impl super::core::DataContainerTrait for RepulsorLiftPhysicsActionData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static REPULSORLIFTPHYSICSACTIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RepulsorLiftPhysicsActionData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PHYSICSACTIONBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RepulsorLiftPhysicsActionData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "HeightSteerInputAction",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, height_steer_input_action),
            },
            FieldInfoData {
                name: "HeightSteerRate",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, height_steer_rate),
            },
            FieldInfoData {
                name: "HeightCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioCurve",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, height_curve),
            },
            FieldInfoData {
                name: "AllowHeightCurveOverride",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, allow_height_curve_override),
            },
            FieldInfoData {
                name: "HoverHeightNoPlayer",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, hover_height_no_player),
            },
            FieldInfoData {
                name: "HoverOverWater",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, hover_over_water),
            },
            FieldInfoData {
                name: "GravityCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioCurve",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, gravity_curve),
            },
            FieldInfoData {
                name: "ExtraGravity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, extra_gravity),
            },
            FieldInfoData {
                name: "FrontOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, front_offset),
            },
            FieldInfoData {
                name: "RearOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, rear_offset),
            },
            FieldInfoData {
                name: "ExtrapolateTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, extrapolate_time),
            },
            FieldInfoData {
                name: "FrontDownExtrapolateTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, front_down_extrapolate_time),
            },
            FieldInfoData {
                name: "MinHitNormalY",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, min_hit_normal_y),
            },
            FieldInfoData {
                name: "HoverHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, hover_height),
            },
            FieldInfoData {
                name: "RaycastHeightMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, raycast_height_multiplier),
            },
            FieldInfoData {
                name: "RaycastInputSteerAmount",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, raycast_input_steer_amount),
            },
            FieldInfoData {
                name: "RaycastSteerRate",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, raycast_steer_rate),
            },
            FieldInfoData {
                name: "RaycastSteerInputAction",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, raycast_steer_input_action),
            },
            FieldInfoData {
                name: "ForwardRaycastCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, forward_raycast_count),
            },
            FieldInfoData {
                name: "OverCast",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, over_cast),
            },
            FieldInfoData {
                name: "OverCast2",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, over_cast2),
            },
            FieldInfoData {
                name: "CastWidth",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, cast_width),
            },
            FieldInfoData {
                name: "MinSampleDist",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, min_sample_dist),
            },
            FieldInfoData {
                name: "MaxSlope",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, max_slope),
            },
            FieldInfoData {
                name: "OverWallLookAhead",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, over_wall_look_ahead),
            },
            FieldInfoData {
                name: "StdDevSpring",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, std_dev_spring),
            },
            FieldInfoData {
                name: "StdDevBumper",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, std_dev_bumper),
            },
            FieldInfoData {
                name: "SpringC",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, spring_c),
            },
            FieldInfoData {
                name: "CollisionSpringStrength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, collision_spring_strength),
            },
            FieldInfoData {
                name: "CollisionSpringMinDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, collision_spring_min_distance),
            },
            FieldInfoData {
                name: "MinReasonableSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, min_reasonable_speed),
            },
            FieldInfoData {
                name: "MaxForwardsAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, max_forwards_angle),
            },
            FieldInfoData {
                name: "ForwardsSmoothing",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, forwards_smoothing),
            },
            FieldInfoData {
                name: "ForcePerVerticalVelocityCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioCurve",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, force_per_vertical_velocity_curve),
            },
            FieldInfoData {
                name: "MaxVelSlope",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, max_vel_slope),
            },
            FieldInfoData {
                name: "RepulsorStrength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, repulsor_strength),
            },
            FieldInfoData {
                name: "MaxSlopeForPositiveRepulsor",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, max_slope_for_positive_repulsor),
            },
            FieldInfoData {
                name: "RepulsorStrengthPositive",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, repulsor_strength_positive),
            },
            FieldInfoData {
                name: "RepulsorStrengthNegative",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, repulsor_strength_negative),
            },
            FieldInfoData {
                name: "RepulsorDampingPositive",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, repulsor_damping_positive),
            },
            FieldInfoData {
                name: "RepulsorDampingNegative",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, repulsor_damping_negative),
            },
            FieldInfoData {
                name: "RepulsorDampingPositiveNonCritical",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, repulsor_damping_positive_non_critical),
            },
            FieldInfoData {
                name: "RepulsorDampingNegativeNonCritical",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, repulsor_damping_negative_non_critical),
            },
            FieldInfoData {
                name: "SamplePurgeMinSideDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, sample_purge_min_side_distance),
            },
            FieldInfoData {
                name: "HeightForceFadeStart",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, height_force_fade_start),
            },
            FieldInfoData {
                name: "HeightForceFadeEnd",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, height_force_fade_end),
            },
            FieldInfoData {
                name: "VelocitySlopeScalar",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, velocity_slope_scalar),
            },
            FieldInfoData {
                name: "RepulsorDamping",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, repulsor_damping),
            },
            FieldInfoData {
                name: "MaxForce",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, max_force),
            },
            FieldInfoData {
                name: "TargetHoverHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, target_hover_height),
            },
            FieldInfoData {
                name: "MaxHeightCastOriginOffsetLocalSpace",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, max_height_cast_origin_offset_local_space),
            },
            FieldInfoData {
                name: "MaxHeightRaycastLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, max_height_raycast_length),
            },
            FieldInfoData {
                name: "MaxHeightClearance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, max_height_clearance),
            },
            FieldInfoData {
                name: "MinGroundClearance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, min_ground_clearance),
            },
            FieldInfoData {
                name: "MaxHeightUpAdjustmentSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, max_height_up_adjustment_speed),
            },
            FieldInfoData {
                name: "MaxHeightDownAdjustmentSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, max_height_down_adjustment_speed),
            },
            FieldInfoData {
                name: "YInterceptLerp",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, y_intercept_lerp),
            },
            FieldInfoData {
                name: "SlopeLerp",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, slope_lerp),
            },
            FieldInfoData {
                name: "StandardDeviationLerp",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RepulsorLiftPhysicsActionData, standard_deviation_lerp),
            },
        ],
    }),
    array_type: Some(REPULSORLIFTPHYSICSACTIONDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for RepulsorLiftPhysicsActionData {
    fn type_info(&self) -> &'static TypeInfo {
        REPULSORLIFTPHYSICSACTIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static REPULSORLIFTPHYSICSACTIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RepulsorLiftPhysicsActionData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("RepulsorLiftPhysicsActionData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GroundFollowPhysicsActionData {
    pub _glacier_base: PhysicsActionBaseData,
    pub ray_offsets: Vec<super::core::Vec3>,
    pub ray_length: f32,
    pub process_type: RayProcessType,
    pub max_slope_angle: f32,
    pub inertia: f32,
}

pub trait GroundFollowPhysicsActionDataTrait: PhysicsActionBaseDataTrait {
    fn ray_offsets(&self) -> &Vec<super::core::Vec3>;
    fn ray_length(&self) -> &f32;
    fn process_type(&self) -> &RayProcessType;
    fn max_slope_angle(&self) -> &f32;
    fn inertia(&self) -> &f32;
}

impl GroundFollowPhysicsActionDataTrait for GroundFollowPhysicsActionData {
    fn ray_offsets(&self) -> &Vec<super::core::Vec3> {
        &self.ray_offsets
    }
    fn ray_length(&self) -> &f32 {
        &self.ray_length
    }
    fn process_type(&self) -> &RayProcessType {
        &self.process_type
    }
    fn max_slope_angle(&self) -> &f32 {
        &self.max_slope_angle
    }
    fn inertia(&self) -> &f32 {
        &self.inertia
    }
}

impl PhysicsActionBaseDataTrait for GroundFollowPhysicsActionData {
    fn blend_factor(&self) -> &f32 {
        self._glacier_base.blend_factor()
    }
    fn input_blend_factor(&self) -> &f32 {
        self._glacier_base.input_blend_factor()
    }
    fn clamp_lin_acc(&self) -> &f32 {
        self._glacier_base.clamp_lin_acc()
    }
    fn clamp_ang_acc(&self) -> &f32 {
        self._glacier_base.clamp_ang_acc()
    }
    fn blend_factor_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.blend_factor_curve()
    }
    fn collision_response_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.collision_response_curve()
    }
}

impl super::entity::EntityDataTrait for GroundFollowPhysicsActionData {
}

impl super::entity::GameObjectDataTrait for GroundFollowPhysicsActionData {
}

impl super::core::DataBusPeerTrait for GroundFollowPhysicsActionData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for GroundFollowPhysicsActionData {
}

impl super::core::DataContainerTrait for GroundFollowPhysicsActionData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static GROUNDFOLLOWPHYSICSACTIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GroundFollowPhysicsActionData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PHYSICSACTIONBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GroundFollowPhysicsActionData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "RayOffsets",
                flags: MemberInfoFlags::new(144),
                field_type: "Vec3-Array",
                rust_offset: offset_of!(GroundFollowPhysicsActionData, ray_offsets),
            },
            FieldInfoData {
                name: "RayLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GroundFollowPhysicsActionData, ray_length),
            },
            FieldInfoData {
                name: "ProcessType",
                flags: MemberInfoFlags::new(0),
                field_type: "RayProcessType",
                rust_offset: offset_of!(GroundFollowPhysicsActionData, process_type),
            },
            FieldInfoData {
                name: "MaxSlopeAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GroundFollowPhysicsActionData, max_slope_angle),
            },
            FieldInfoData {
                name: "Inertia",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GroundFollowPhysicsActionData, inertia),
            },
        ],
    }),
    array_type: Some(GROUNDFOLLOWPHYSICSACTIONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for GroundFollowPhysicsActionData {
    fn type_info(&self) -> &'static TypeInfo {
        GROUNDFOLLOWPHYSICSACTIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static GROUNDFOLLOWPHYSICSACTIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GroundFollowPhysicsActionData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("GroundFollowPhysicsActionData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum RayProcessType {
    #[default]
    RayProcessType_AverageResult = 0,
    RayProcessType_SmallestDifference = 1,
}

pub static RAYPROCESSTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RayProcessType",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(RAYPROCESSTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for RayProcessType {
    fn type_info(&self) -> &'static TypeInfo {
        RAYPROCESSTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static RAYPROCESSTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RayProcessType-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("RayProcessType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct InputReaderActionData {
    pub _glacier_base: PhysicsActionBaseData,
    pub input_action: i32,
    pub mute_value_during_correction: bool,
    pub only_write_if_modified: bool,
}

pub trait InputReaderActionDataTrait: PhysicsActionBaseDataTrait {
    fn input_action(&self) -> &i32;
    fn mute_value_during_correction(&self) -> &bool;
    fn only_write_if_modified(&self) -> &bool;
}

impl InputReaderActionDataTrait for InputReaderActionData {
    fn input_action(&self) -> &i32 {
        &self.input_action
    }
    fn mute_value_during_correction(&self) -> &bool {
        &self.mute_value_during_correction
    }
    fn only_write_if_modified(&self) -> &bool {
        &self.only_write_if_modified
    }
}

impl PhysicsActionBaseDataTrait for InputReaderActionData {
    fn blend_factor(&self) -> &f32 {
        self._glacier_base.blend_factor()
    }
    fn input_blend_factor(&self) -> &f32 {
        self._glacier_base.input_blend_factor()
    }
    fn clamp_lin_acc(&self) -> &f32 {
        self._glacier_base.clamp_lin_acc()
    }
    fn clamp_ang_acc(&self) -> &f32 {
        self._glacier_base.clamp_ang_acc()
    }
    fn blend_factor_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.blend_factor_curve()
    }
    fn collision_response_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.collision_response_curve()
    }
}

impl super::entity::EntityDataTrait for InputReaderActionData {
}

impl super::entity::GameObjectDataTrait for InputReaderActionData {
}

impl super::core::DataBusPeerTrait for InputReaderActionData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for InputReaderActionData {
}

impl super::core::DataContainerTrait for InputReaderActionData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static INPUTREADERACTIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InputReaderActionData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PHYSICSACTIONBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<InputReaderActionData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "InputAction",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(InputReaderActionData, input_action),
            },
            FieldInfoData {
                name: "MuteValueDuringCorrection",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(InputReaderActionData, mute_value_during_correction),
            },
            FieldInfoData {
                name: "OnlyWriteIfModified",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(InputReaderActionData, only_write_if_modified),
            },
        ],
    }),
    array_type: Some(INPUTREADERACTIONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for InputReaderActionData {
    fn type_info(&self) -> &'static TypeInfo {
        INPUTREADERACTIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static INPUTREADERACTIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InputReaderActionData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("InputReaderActionData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FloatStateActionData {
    pub _glacier_base: PhysicsActionBaseData,
    pub inertia: f32,
    pub min_value: f32,
    pub max_value: f32,
    pub networked_bits: u32,
    pub default_value: f32,
    pub mute_value_during_correction: bool,
    pub only_write_if_modified: bool,
    pub set: f32,
    pub add: f32,
    pub sub: f32,
    pub mul: f32,
}

pub trait FloatStateActionDataTrait: PhysicsActionBaseDataTrait {
    fn inertia(&self) -> &f32;
    fn min_value(&self) -> &f32;
    fn max_value(&self) -> &f32;
    fn networked_bits(&self) -> &u32;
    fn default_value(&self) -> &f32;
    fn mute_value_during_correction(&self) -> &bool;
    fn only_write_if_modified(&self) -> &bool;
    fn set(&self) -> &f32;
    fn add(&self) -> &f32;
    fn sub(&self) -> &f32;
    fn mul(&self) -> &f32;
}

impl FloatStateActionDataTrait for FloatStateActionData {
    fn inertia(&self) -> &f32 {
        &self.inertia
    }
    fn min_value(&self) -> &f32 {
        &self.min_value
    }
    fn max_value(&self) -> &f32 {
        &self.max_value
    }
    fn networked_bits(&self) -> &u32 {
        &self.networked_bits
    }
    fn default_value(&self) -> &f32 {
        &self.default_value
    }
    fn mute_value_during_correction(&self) -> &bool {
        &self.mute_value_during_correction
    }
    fn only_write_if_modified(&self) -> &bool {
        &self.only_write_if_modified
    }
    fn set(&self) -> &f32 {
        &self.set
    }
    fn add(&self) -> &f32 {
        &self.add
    }
    fn sub(&self) -> &f32 {
        &self.sub
    }
    fn mul(&self) -> &f32 {
        &self.mul
    }
}

impl PhysicsActionBaseDataTrait for FloatStateActionData {
    fn blend_factor(&self) -> &f32 {
        self._glacier_base.blend_factor()
    }
    fn input_blend_factor(&self) -> &f32 {
        self._glacier_base.input_blend_factor()
    }
    fn clamp_lin_acc(&self) -> &f32 {
        self._glacier_base.clamp_lin_acc()
    }
    fn clamp_ang_acc(&self) -> &f32 {
        self._glacier_base.clamp_ang_acc()
    }
    fn blend_factor_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.blend_factor_curve()
    }
    fn collision_response_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.collision_response_curve()
    }
}

impl super::entity::EntityDataTrait for FloatStateActionData {
}

impl super::entity::GameObjectDataTrait for FloatStateActionData {
}

impl super::core::DataBusPeerTrait for FloatStateActionData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for FloatStateActionData {
}

impl super::core::DataContainerTrait for FloatStateActionData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static FLOATSTATEACTIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatStateActionData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PHYSICSACTIONBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FloatStateActionData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Inertia",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FloatStateActionData, inertia),
            },
            FieldInfoData {
                name: "MinValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FloatStateActionData, min_value),
            },
            FieldInfoData {
                name: "MaxValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FloatStateActionData, max_value),
            },
            FieldInfoData {
                name: "NetworkedBits",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(FloatStateActionData, networked_bits),
            },
            FieldInfoData {
                name: "DefaultValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FloatStateActionData, default_value),
            },
            FieldInfoData {
                name: "MuteValueDuringCorrection",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FloatStateActionData, mute_value_during_correction),
            },
            FieldInfoData {
                name: "OnlyWriteIfModified",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FloatStateActionData, only_write_if_modified),
            },
            FieldInfoData {
                name: "Set",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FloatStateActionData, set),
            },
            FieldInfoData {
                name: "Add",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FloatStateActionData, add),
            },
            FieldInfoData {
                name: "Sub",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FloatStateActionData, sub),
            },
            FieldInfoData {
                name: "Mul",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FloatStateActionData, mul),
            },
        ],
    }),
    array_type: Some(FLOATSTATEACTIONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FloatStateActionData {
    fn type_info(&self) -> &'static TypeInfo {
        FLOATSTATEACTIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static FLOATSTATEACTIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatStateActionData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("FloatStateActionData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ScriptedMotionPhysicsActionData {
    pub _glacier_base: PhysicsActionBaseData,
    pub input_combo: Vec<ScriptedMotionInput>,
    pub scripted_motion: Vec<ScriptedMotionData>,
    pub disable_script_triggering: bool,
    pub script_tick_length: u32,
    pub angular_smoothing_ticks: u32,
    pub linear_smoothing_ticks: u32,
    pub camera_transform_hint: super::core::LinearTransform,
    pub auto_level_roll: bool,
    pub auto_level_always_up: bool,
}

pub trait ScriptedMotionPhysicsActionDataTrait: PhysicsActionBaseDataTrait {
    fn input_combo(&self) -> &Vec<ScriptedMotionInput>;
    fn scripted_motion(&self) -> &Vec<ScriptedMotionData>;
    fn disable_script_triggering(&self) -> &bool;
    fn script_tick_length(&self) -> &u32;
    fn angular_smoothing_ticks(&self) -> &u32;
    fn linear_smoothing_ticks(&self) -> &u32;
    fn camera_transform_hint(&self) -> &super::core::LinearTransform;
    fn auto_level_roll(&self) -> &bool;
    fn auto_level_always_up(&self) -> &bool;
}

impl ScriptedMotionPhysicsActionDataTrait for ScriptedMotionPhysicsActionData {
    fn input_combo(&self) -> &Vec<ScriptedMotionInput> {
        &self.input_combo
    }
    fn scripted_motion(&self) -> &Vec<ScriptedMotionData> {
        &self.scripted_motion
    }
    fn disable_script_triggering(&self) -> &bool {
        &self.disable_script_triggering
    }
    fn script_tick_length(&self) -> &u32 {
        &self.script_tick_length
    }
    fn angular_smoothing_ticks(&self) -> &u32 {
        &self.angular_smoothing_ticks
    }
    fn linear_smoothing_ticks(&self) -> &u32 {
        &self.linear_smoothing_ticks
    }
    fn camera_transform_hint(&self) -> &super::core::LinearTransform {
        &self.camera_transform_hint
    }
    fn auto_level_roll(&self) -> &bool {
        &self.auto_level_roll
    }
    fn auto_level_always_up(&self) -> &bool {
        &self.auto_level_always_up
    }
}

impl PhysicsActionBaseDataTrait for ScriptedMotionPhysicsActionData {
    fn blend_factor(&self) -> &f32 {
        self._glacier_base.blend_factor()
    }
    fn input_blend_factor(&self) -> &f32 {
        self._glacier_base.input_blend_factor()
    }
    fn clamp_lin_acc(&self) -> &f32 {
        self._glacier_base.clamp_lin_acc()
    }
    fn clamp_ang_acc(&self) -> &f32 {
        self._glacier_base.clamp_ang_acc()
    }
    fn blend_factor_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.blend_factor_curve()
    }
    fn collision_response_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.collision_response_curve()
    }
}

impl super::entity::EntityDataTrait for ScriptedMotionPhysicsActionData {
}

impl super::entity::GameObjectDataTrait for ScriptedMotionPhysicsActionData {
}

impl super::core::DataBusPeerTrait for ScriptedMotionPhysicsActionData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for ScriptedMotionPhysicsActionData {
}

impl super::core::DataContainerTrait for ScriptedMotionPhysicsActionData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SCRIPTEDMOTIONPHYSICSACTIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScriptedMotionPhysicsActionData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PHYSICSACTIONBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ScriptedMotionPhysicsActionData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "InputCombo",
                flags: MemberInfoFlags::new(144),
                field_type: "ScriptedMotionInput-Array",
                rust_offset: offset_of!(ScriptedMotionPhysicsActionData, input_combo),
            },
            FieldInfoData {
                name: "ScriptedMotion",
                flags: MemberInfoFlags::new(144),
                field_type: "ScriptedMotionData-Array",
                rust_offset: offset_of!(ScriptedMotionPhysicsActionData, scripted_motion),
            },
            FieldInfoData {
                name: "DisableScriptTriggering",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ScriptedMotionPhysicsActionData, disable_script_triggering),
            },
            FieldInfoData {
                name: "ScriptTickLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(ScriptedMotionPhysicsActionData, script_tick_length),
            },
            FieldInfoData {
                name: "AngularSmoothingTicks",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(ScriptedMotionPhysicsActionData, angular_smoothing_ticks),
            },
            FieldInfoData {
                name: "LinearSmoothingTicks",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(ScriptedMotionPhysicsActionData, linear_smoothing_ticks),
            },
            FieldInfoData {
                name: "CameraTransformHint",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(ScriptedMotionPhysicsActionData, camera_transform_hint),
            },
            FieldInfoData {
                name: "AutoLevelRoll",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ScriptedMotionPhysicsActionData, auto_level_roll),
            },
            FieldInfoData {
                name: "AutoLevelAlwaysUp",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ScriptedMotionPhysicsActionData, auto_level_always_up),
            },
        ],
    }),
    array_type: Some(SCRIPTEDMOTIONPHYSICSACTIONDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ScriptedMotionPhysicsActionData {
    fn type_info(&self) -> &'static TypeInfo {
        SCRIPTEDMOTIONPHYSICSACTIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SCRIPTEDMOTIONPHYSICSACTIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScriptedMotionPhysicsActionData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("ScriptedMotionPhysicsActionData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ScriptedMotionInput {
    pub input_action: i32,
    pub is: ScriptedMotionCompare,
    pub threshold: f32,
}

pub trait ScriptedMotionInputTrait: TypeObject {
    fn input_action(&self) -> &i32;
    fn is(&self) -> &ScriptedMotionCompare;
    fn threshold(&self) -> &f32;
}

impl ScriptedMotionInputTrait for ScriptedMotionInput {
    fn input_action(&self) -> &i32 {
        &self.input_action
    }
    fn is(&self) -> &ScriptedMotionCompare {
        &self.is
    }
    fn threshold(&self) -> &f32 {
        &self.threshold
    }
}

pub static SCRIPTEDMOTIONINPUT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScriptedMotionInput",
    flags: MemberInfoFlags::new(36937),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ScriptedMotionInput as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "InputAction",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ScriptedMotionInput, input_action),
            },
            FieldInfoData {
                name: "Is",
                flags: MemberInfoFlags::new(0),
                field_type: "ScriptedMotionCompare",
                rust_offset: offset_of!(ScriptedMotionInput, is),
            },
            FieldInfoData {
                name: "Threshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ScriptedMotionInput, threshold),
            },
        ],
    }),
    array_type: Some(SCRIPTEDMOTIONINPUT_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for ScriptedMotionInput {
    fn type_info(&self) -> &'static TypeInfo {
        SCRIPTEDMOTIONINPUT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SCRIPTEDMOTIONINPUT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScriptedMotionInput-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("ScriptedMotionInput"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum ScriptedMotionCompare {
    #[default]
    GreaterOrEqual = 0,
    LessOrEqual = 1,
}

pub static SCRIPTEDMOTIONCOMPARE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScriptedMotionCompare",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(SCRIPTEDMOTIONCOMPARE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for ScriptedMotionCompare {
    fn type_info(&self) -> &'static TypeInfo {
        SCRIPTEDMOTIONCOMPARE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SCRIPTEDMOTIONCOMPARE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScriptedMotionCompare-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("ScriptedMotionCompare"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ScriptedMotionData {
    pub quantity: PhysicsQuantity,
    pub axis: PhysicsActionAxis,
    pub distance_curve: super::core::AudioCurve,
}

pub trait ScriptedMotionDataTrait: TypeObject {
    fn quantity(&self) -> &PhysicsQuantity;
    fn axis(&self) -> &PhysicsActionAxis;
    fn distance_curve(&self) -> &super::core::AudioCurve;
}

impl ScriptedMotionDataTrait for ScriptedMotionData {
    fn quantity(&self) -> &PhysicsQuantity {
        &self.quantity
    }
    fn axis(&self) -> &PhysicsActionAxis {
        &self.axis
    }
    fn distance_curve(&self) -> &super::core::AudioCurve {
        &self.distance_curve
    }
}

pub static SCRIPTEDMOTIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScriptedMotionData",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ScriptedMotionData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Quantity",
                flags: MemberInfoFlags::new(0),
                field_type: "PhysicsQuantity",
                rust_offset: offset_of!(ScriptedMotionData, quantity),
            },
            FieldInfoData {
                name: "Axis",
                flags: MemberInfoFlags::new(0),
                field_type: "PhysicsActionAxis",
                rust_offset: offset_of!(ScriptedMotionData, axis),
            },
            FieldInfoData {
                name: "DistanceCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioCurve",
                rust_offset: offset_of!(ScriptedMotionData, distance_curve),
            },
        ],
    }),
    array_type: Some(SCRIPTEDMOTIONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ScriptedMotionData {
    fn type_info(&self) -> &'static TypeInfo {
        SCRIPTEDMOTIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SCRIPTEDMOTIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScriptedMotionData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("ScriptedMotionData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct HoverNoisePhysicsActionData {
    pub _glacier_base: PhysicsActionBaseData,
    pub base_frequency: f32,
    pub noises: Vec<HoverNoiseData>,
}

pub trait HoverNoisePhysicsActionDataTrait: PhysicsActionBaseDataTrait {
    fn base_frequency(&self) -> &f32;
    fn noises(&self) -> &Vec<HoverNoiseData>;
}

impl HoverNoisePhysicsActionDataTrait for HoverNoisePhysicsActionData {
    fn base_frequency(&self) -> &f32 {
        &self.base_frequency
    }
    fn noises(&self) -> &Vec<HoverNoiseData> {
        &self.noises
    }
}

impl PhysicsActionBaseDataTrait for HoverNoisePhysicsActionData {
    fn blend_factor(&self) -> &f32 {
        self._glacier_base.blend_factor()
    }
    fn input_blend_factor(&self) -> &f32 {
        self._glacier_base.input_blend_factor()
    }
    fn clamp_lin_acc(&self) -> &f32 {
        self._glacier_base.clamp_lin_acc()
    }
    fn clamp_ang_acc(&self) -> &f32 {
        self._glacier_base.clamp_ang_acc()
    }
    fn blend_factor_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.blend_factor_curve()
    }
    fn collision_response_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.collision_response_curve()
    }
}

impl super::entity::EntityDataTrait for HoverNoisePhysicsActionData {
}

impl super::entity::GameObjectDataTrait for HoverNoisePhysicsActionData {
}

impl super::core::DataBusPeerTrait for HoverNoisePhysicsActionData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for HoverNoisePhysicsActionData {
}

impl super::core::DataContainerTrait for HoverNoisePhysicsActionData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static HOVERNOISEPHYSICSACTIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HoverNoisePhysicsActionData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PHYSICSACTIONBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<HoverNoisePhysicsActionData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "BaseFrequency",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverNoisePhysicsActionData, base_frequency),
            },
            FieldInfoData {
                name: "Noises",
                flags: MemberInfoFlags::new(144),
                field_type: "HoverNoiseData-Array",
                rust_offset: offset_of!(HoverNoisePhysicsActionData, noises),
            },
        ],
    }),
    array_type: Some(HOVERNOISEPHYSICSACTIONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for HoverNoisePhysicsActionData {
    fn type_info(&self) -> &'static TypeInfo {
        HOVERNOISEPHYSICSACTIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static HOVERNOISEPHYSICSACTIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HoverNoisePhysicsActionData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("HoverNoisePhysicsActionData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct HoverNoiseData {
    pub quantity: PhysicsQuantity,
    pub axis: PhysicsActionAxis,
    pub amplitude: f32,
    pub frequency_modifier: f32,
    pub noise_type: HoverNoiseType,
}

pub trait HoverNoiseDataTrait: TypeObject {
    fn quantity(&self) -> &PhysicsQuantity;
    fn axis(&self) -> &PhysicsActionAxis;
    fn amplitude(&self) -> &f32;
    fn frequency_modifier(&self) -> &f32;
    fn noise_type(&self) -> &HoverNoiseType;
}

impl HoverNoiseDataTrait for HoverNoiseData {
    fn quantity(&self) -> &PhysicsQuantity {
        &self.quantity
    }
    fn axis(&self) -> &PhysicsActionAxis {
        &self.axis
    }
    fn amplitude(&self) -> &f32 {
        &self.amplitude
    }
    fn frequency_modifier(&self) -> &f32 {
        &self.frequency_modifier
    }
    fn noise_type(&self) -> &HoverNoiseType {
        &self.noise_type
    }
}

pub static HOVERNOISEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HoverNoiseData",
    flags: MemberInfoFlags::new(36937),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<HoverNoiseData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Quantity",
                flags: MemberInfoFlags::new(0),
                field_type: "PhysicsQuantity",
                rust_offset: offset_of!(HoverNoiseData, quantity),
            },
            FieldInfoData {
                name: "Axis",
                flags: MemberInfoFlags::new(0),
                field_type: "PhysicsActionAxis",
                rust_offset: offset_of!(HoverNoiseData, axis),
            },
            FieldInfoData {
                name: "Amplitude",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverNoiseData, amplitude),
            },
            FieldInfoData {
                name: "FrequencyModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HoverNoiseData, frequency_modifier),
            },
            FieldInfoData {
                name: "NoiseType",
                flags: MemberInfoFlags::new(0),
                field_type: "HoverNoiseType",
                rust_offset: offset_of!(HoverNoiseData, noise_type),
            },
        ],
    }),
    array_type: Some(HOVERNOISEDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for HoverNoiseData {
    fn type_info(&self) -> &'static TypeInfo {
        HOVERNOISEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static HOVERNOISEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HoverNoiseData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("HoverNoiseData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum HoverNoiseType {
    #[default]
    Perlin = 0,
    Sinus = 1,
}

pub static HOVERNOISETYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HoverNoiseType",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(HOVERNOISETYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for HoverNoiseType {
    fn type_info(&self) -> &'static TypeInfo {
        HOVERNOISETYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static HOVERNOISETYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HoverNoiseType-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("HoverNoiseType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MotionDampingPhysicsActionData {
    pub _glacier_base: PhysicsActionBaseData,
    pub forward_damping: f32,
    pub side_damping: f32,
    pub up_damping: f32,
    pub roll_damping: f32,
    pub pitch_damping: f32,
    pub yaw_damping: f32,
}

pub trait MotionDampingPhysicsActionDataTrait: PhysicsActionBaseDataTrait {
    fn forward_damping(&self) -> &f32;
    fn side_damping(&self) -> &f32;
    fn up_damping(&self) -> &f32;
    fn roll_damping(&self) -> &f32;
    fn pitch_damping(&self) -> &f32;
    fn yaw_damping(&self) -> &f32;
}

impl MotionDampingPhysicsActionDataTrait for MotionDampingPhysicsActionData {
    fn forward_damping(&self) -> &f32 {
        &self.forward_damping
    }
    fn side_damping(&self) -> &f32 {
        &self.side_damping
    }
    fn up_damping(&self) -> &f32 {
        &self.up_damping
    }
    fn roll_damping(&self) -> &f32 {
        &self.roll_damping
    }
    fn pitch_damping(&self) -> &f32 {
        &self.pitch_damping
    }
    fn yaw_damping(&self) -> &f32 {
        &self.yaw_damping
    }
}

impl PhysicsActionBaseDataTrait for MotionDampingPhysicsActionData {
    fn blend_factor(&self) -> &f32 {
        self._glacier_base.blend_factor()
    }
    fn input_blend_factor(&self) -> &f32 {
        self._glacier_base.input_blend_factor()
    }
    fn clamp_lin_acc(&self) -> &f32 {
        self._glacier_base.clamp_lin_acc()
    }
    fn clamp_ang_acc(&self) -> &f32 {
        self._glacier_base.clamp_ang_acc()
    }
    fn blend_factor_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.blend_factor_curve()
    }
    fn collision_response_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.collision_response_curve()
    }
}

impl super::entity::EntityDataTrait for MotionDampingPhysicsActionData {
}

impl super::entity::GameObjectDataTrait for MotionDampingPhysicsActionData {
}

impl super::core::DataBusPeerTrait for MotionDampingPhysicsActionData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for MotionDampingPhysicsActionData {
}

impl super::core::DataContainerTrait for MotionDampingPhysicsActionData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static MOTIONDAMPINGPHYSICSACTIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MotionDampingPhysicsActionData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PHYSICSACTIONBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MotionDampingPhysicsActionData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ForwardDamping",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MotionDampingPhysicsActionData, forward_damping),
            },
            FieldInfoData {
                name: "SideDamping",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MotionDampingPhysicsActionData, side_damping),
            },
            FieldInfoData {
                name: "UpDamping",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MotionDampingPhysicsActionData, up_damping),
            },
            FieldInfoData {
                name: "RollDamping",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MotionDampingPhysicsActionData, roll_damping),
            },
            FieldInfoData {
                name: "PitchDamping",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MotionDampingPhysicsActionData, pitch_damping),
            },
            FieldInfoData {
                name: "YawDamping",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MotionDampingPhysicsActionData, yaw_damping),
            },
        ],
    }),
    array_type: Some(MOTIONDAMPINGPHYSICSACTIONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MotionDampingPhysicsActionData {
    fn type_info(&self) -> &'static TypeInfo {
        MOTIONDAMPINGPHYSICSACTIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static MOTIONDAMPINGPHYSICSACTIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MotionDampingPhysicsActionData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("MotionDampingPhysicsActionData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CameraRelSteeringPhysicsActionData {
    pub _glacier_base: PhysicsActionBaseData,
    pub input_action_yaw: i32,
    pub input_action_pitch: i32,
    pub input_action_roll: i32,
    pub yaw_max_speed: f32,
    pub yaw_max_speed_multiplier_curve: super::core::AudioCurve,
    pub yaw_inertia_on_input: f32,
    pub yaw_inertia_on_no_input: f32,
    pub pitch_max_speed: f32,
    pub pitch_max_speed_multiplier_curve: super::core::AudioCurve,
    pub pitch_inertia_on_input: f32,
    pub pitch_inertia_on_no_input: f32,
    pub roll_max_speed: f32,
    pub roll_max_speed_multiplier_curve: super::core::AudioCurve,
    pub roll_inertia_on_input: f32,
    pub roll_inertia_on_no_input: f32,
    pub visual_roll_max_angle: f32,
    pub visual_roll_yaw_speed_for_max_angle: f32,
    pub visual_roll_inc_inertia: f32,
    pub visual_roll_dec_inertia: f32,
    pub auto_roll_on_yaw_fade_out_angle: f32,
    pub num_sim_steps_to_reach_camera_transform: f32,
    pub reset_target_orientation: bool,
}

pub trait CameraRelSteeringPhysicsActionDataTrait: PhysicsActionBaseDataTrait {
    fn input_action_yaw(&self) -> &i32;
    fn input_action_pitch(&self) -> &i32;
    fn input_action_roll(&self) -> &i32;
    fn yaw_max_speed(&self) -> &f32;
    fn yaw_max_speed_multiplier_curve(&self) -> &super::core::AudioCurve;
    fn yaw_inertia_on_input(&self) -> &f32;
    fn yaw_inertia_on_no_input(&self) -> &f32;
    fn pitch_max_speed(&self) -> &f32;
    fn pitch_max_speed_multiplier_curve(&self) -> &super::core::AudioCurve;
    fn pitch_inertia_on_input(&self) -> &f32;
    fn pitch_inertia_on_no_input(&self) -> &f32;
    fn roll_max_speed(&self) -> &f32;
    fn roll_max_speed_multiplier_curve(&self) -> &super::core::AudioCurve;
    fn roll_inertia_on_input(&self) -> &f32;
    fn roll_inertia_on_no_input(&self) -> &f32;
    fn visual_roll_max_angle(&self) -> &f32;
    fn visual_roll_yaw_speed_for_max_angle(&self) -> &f32;
    fn visual_roll_inc_inertia(&self) -> &f32;
    fn visual_roll_dec_inertia(&self) -> &f32;
    fn auto_roll_on_yaw_fade_out_angle(&self) -> &f32;
    fn num_sim_steps_to_reach_camera_transform(&self) -> &f32;
    fn reset_target_orientation(&self) -> &bool;
}

impl CameraRelSteeringPhysicsActionDataTrait for CameraRelSteeringPhysicsActionData {
    fn input_action_yaw(&self) -> &i32 {
        &self.input_action_yaw
    }
    fn input_action_pitch(&self) -> &i32 {
        &self.input_action_pitch
    }
    fn input_action_roll(&self) -> &i32 {
        &self.input_action_roll
    }
    fn yaw_max_speed(&self) -> &f32 {
        &self.yaw_max_speed
    }
    fn yaw_max_speed_multiplier_curve(&self) -> &super::core::AudioCurve {
        &self.yaw_max_speed_multiplier_curve
    }
    fn yaw_inertia_on_input(&self) -> &f32 {
        &self.yaw_inertia_on_input
    }
    fn yaw_inertia_on_no_input(&self) -> &f32 {
        &self.yaw_inertia_on_no_input
    }
    fn pitch_max_speed(&self) -> &f32 {
        &self.pitch_max_speed
    }
    fn pitch_max_speed_multiplier_curve(&self) -> &super::core::AudioCurve {
        &self.pitch_max_speed_multiplier_curve
    }
    fn pitch_inertia_on_input(&self) -> &f32 {
        &self.pitch_inertia_on_input
    }
    fn pitch_inertia_on_no_input(&self) -> &f32 {
        &self.pitch_inertia_on_no_input
    }
    fn roll_max_speed(&self) -> &f32 {
        &self.roll_max_speed
    }
    fn roll_max_speed_multiplier_curve(&self) -> &super::core::AudioCurve {
        &self.roll_max_speed_multiplier_curve
    }
    fn roll_inertia_on_input(&self) -> &f32 {
        &self.roll_inertia_on_input
    }
    fn roll_inertia_on_no_input(&self) -> &f32 {
        &self.roll_inertia_on_no_input
    }
    fn visual_roll_max_angle(&self) -> &f32 {
        &self.visual_roll_max_angle
    }
    fn visual_roll_yaw_speed_for_max_angle(&self) -> &f32 {
        &self.visual_roll_yaw_speed_for_max_angle
    }
    fn visual_roll_inc_inertia(&self) -> &f32 {
        &self.visual_roll_inc_inertia
    }
    fn visual_roll_dec_inertia(&self) -> &f32 {
        &self.visual_roll_dec_inertia
    }
    fn auto_roll_on_yaw_fade_out_angle(&self) -> &f32 {
        &self.auto_roll_on_yaw_fade_out_angle
    }
    fn num_sim_steps_to_reach_camera_transform(&self) -> &f32 {
        &self.num_sim_steps_to_reach_camera_transform
    }
    fn reset_target_orientation(&self) -> &bool {
        &self.reset_target_orientation
    }
}

impl PhysicsActionBaseDataTrait for CameraRelSteeringPhysicsActionData {
    fn blend_factor(&self) -> &f32 {
        self._glacier_base.blend_factor()
    }
    fn input_blend_factor(&self) -> &f32 {
        self._glacier_base.input_blend_factor()
    }
    fn clamp_lin_acc(&self) -> &f32 {
        self._glacier_base.clamp_lin_acc()
    }
    fn clamp_ang_acc(&self) -> &f32 {
        self._glacier_base.clamp_ang_acc()
    }
    fn blend_factor_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.blend_factor_curve()
    }
    fn collision_response_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.collision_response_curve()
    }
}

impl super::entity::EntityDataTrait for CameraRelSteeringPhysicsActionData {
}

impl super::entity::GameObjectDataTrait for CameraRelSteeringPhysicsActionData {
}

impl super::core::DataBusPeerTrait for CameraRelSteeringPhysicsActionData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for CameraRelSteeringPhysicsActionData {
}

impl super::core::DataContainerTrait for CameraRelSteeringPhysicsActionData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CAMERARELSTEERINGPHYSICSACTIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraRelSteeringPhysicsActionData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PHYSICSACTIONBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraRelSteeringPhysicsActionData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "InputActionYaw",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CameraRelSteeringPhysicsActionData, input_action_yaw),
            },
            FieldInfoData {
                name: "InputActionPitch",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CameraRelSteeringPhysicsActionData, input_action_pitch),
            },
            FieldInfoData {
                name: "InputActionRoll",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CameraRelSteeringPhysicsActionData, input_action_roll),
            },
            FieldInfoData {
                name: "YawMaxSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelSteeringPhysicsActionData, yaw_max_speed),
            },
            FieldInfoData {
                name: "YawMaxSpeedMultiplierCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioCurve",
                rust_offset: offset_of!(CameraRelSteeringPhysicsActionData, yaw_max_speed_multiplier_curve),
            },
            FieldInfoData {
                name: "YawInertiaOnInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelSteeringPhysicsActionData, yaw_inertia_on_input),
            },
            FieldInfoData {
                name: "YawInertiaOnNoInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelSteeringPhysicsActionData, yaw_inertia_on_no_input),
            },
            FieldInfoData {
                name: "PitchMaxSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelSteeringPhysicsActionData, pitch_max_speed),
            },
            FieldInfoData {
                name: "PitchMaxSpeedMultiplierCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioCurve",
                rust_offset: offset_of!(CameraRelSteeringPhysicsActionData, pitch_max_speed_multiplier_curve),
            },
            FieldInfoData {
                name: "PitchInertiaOnInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelSteeringPhysicsActionData, pitch_inertia_on_input),
            },
            FieldInfoData {
                name: "PitchInertiaOnNoInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelSteeringPhysicsActionData, pitch_inertia_on_no_input),
            },
            FieldInfoData {
                name: "RollMaxSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelSteeringPhysicsActionData, roll_max_speed),
            },
            FieldInfoData {
                name: "RollMaxSpeedMultiplierCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioCurve",
                rust_offset: offset_of!(CameraRelSteeringPhysicsActionData, roll_max_speed_multiplier_curve),
            },
            FieldInfoData {
                name: "RollInertiaOnInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelSteeringPhysicsActionData, roll_inertia_on_input),
            },
            FieldInfoData {
                name: "RollInertiaOnNoInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelSteeringPhysicsActionData, roll_inertia_on_no_input),
            },
            FieldInfoData {
                name: "VisualRollMaxAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelSteeringPhysicsActionData, visual_roll_max_angle),
            },
            FieldInfoData {
                name: "VisualRollYawSpeedForMaxAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelSteeringPhysicsActionData, visual_roll_yaw_speed_for_max_angle),
            },
            FieldInfoData {
                name: "VisualRollIncInertia",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelSteeringPhysicsActionData, visual_roll_inc_inertia),
            },
            FieldInfoData {
                name: "VisualRollDecInertia",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelSteeringPhysicsActionData, visual_roll_dec_inertia),
            },
            FieldInfoData {
                name: "AutoRollOnYawFadeOutAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelSteeringPhysicsActionData, auto_roll_on_yaw_fade_out_angle),
            },
            FieldInfoData {
                name: "NumSimStepsToReachCameraTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelSteeringPhysicsActionData, num_sim_steps_to_reach_camera_transform),
            },
            FieldInfoData {
                name: "ResetTargetOrientation",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraRelSteeringPhysicsActionData, reset_target_orientation),
            },
        ],
    }),
    array_type: Some(CAMERARELSTEERINGPHYSICSACTIONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CameraRelSteeringPhysicsActionData {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERARELSTEERINGPHYSICSACTIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CAMERARELSTEERINGPHYSICSACTIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraRelSteeringPhysicsActionData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CameraRelSteeringPhysicsActionData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PropertyReaderPhysicsActionData {
    pub _glacier_base: PhysicsActionBaseData,
    pub acceleration_inertia: f32,
    pub mute_values_during_correction: bool,
}

pub trait PropertyReaderPhysicsActionDataTrait: PhysicsActionBaseDataTrait {
    fn acceleration_inertia(&self) -> &f32;
    fn mute_values_during_correction(&self) -> &bool;
}

impl PropertyReaderPhysicsActionDataTrait for PropertyReaderPhysicsActionData {
    fn acceleration_inertia(&self) -> &f32 {
        &self.acceleration_inertia
    }
    fn mute_values_during_correction(&self) -> &bool {
        &self.mute_values_during_correction
    }
}

impl PhysicsActionBaseDataTrait for PropertyReaderPhysicsActionData {
    fn blend_factor(&self) -> &f32 {
        self._glacier_base.blend_factor()
    }
    fn input_blend_factor(&self) -> &f32 {
        self._glacier_base.input_blend_factor()
    }
    fn clamp_lin_acc(&self) -> &f32 {
        self._glacier_base.clamp_lin_acc()
    }
    fn clamp_ang_acc(&self) -> &f32 {
        self._glacier_base.clamp_ang_acc()
    }
    fn blend_factor_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.blend_factor_curve()
    }
    fn collision_response_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.collision_response_curve()
    }
}

impl super::entity::EntityDataTrait for PropertyReaderPhysicsActionData {
}

impl super::entity::GameObjectDataTrait for PropertyReaderPhysicsActionData {
}

impl super::core::DataBusPeerTrait for PropertyReaderPhysicsActionData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for PropertyReaderPhysicsActionData {
}

impl super::core::DataContainerTrait for PropertyReaderPhysicsActionData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PROPERTYREADERPHYSICSACTIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PropertyReaderPhysicsActionData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PHYSICSACTIONBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PropertyReaderPhysicsActionData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AccelerationInertia",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PropertyReaderPhysicsActionData, acceleration_inertia),
            },
            FieldInfoData {
                name: "MuteValuesDuringCorrection",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PropertyReaderPhysicsActionData, mute_values_during_correction),
            },
        ],
    }),
    array_type: Some(PROPERTYREADERPHYSICSACTIONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PropertyReaderPhysicsActionData {
    fn type_info(&self) -> &'static TypeInfo {
        PROPERTYREADERPHYSICSACTIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PROPERTYREADERPHYSICSACTIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PropertyReaderPhysicsActionData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PropertyReaderPhysicsActionData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ForceOverTimePhysicsActionData {
    pub _glacier_base: PhysicsActionBaseData,
    pub input_action: i32,
    pub input_dead_zone: f32,
    pub quantity: PhysicsQuantity,
    pub axis: PhysicsActionAxis,
    pub force_strength: f32,
    pub scale_on_mass: bool,
    pub force_time: f32,
    pub cooldown_time: f32,
    pub linear_offset: super::core::Vec3,
    pub linear_offset_space: PhysicsSpace,
}

pub trait ForceOverTimePhysicsActionDataTrait: PhysicsActionBaseDataTrait {
    fn input_action(&self) -> &i32;
    fn input_dead_zone(&self) -> &f32;
    fn quantity(&self) -> &PhysicsQuantity;
    fn axis(&self) -> &PhysicsActionAxis;
    fn force_strength(&self) -> &f32;
    fn scale_on_mass(&self) -> &bool;
    fn force_time(&self) -> &f32;
    fn cooldown_time(&self) -> &f32;
    fn linear_offset(&self) -> &super::core::Vec3;
    fn linear_offset_space(&self) -> &PhysicsSpace;
}

impl ForceOverTimePhysicsActionDataTrait for ForceOverTimePhysicsActionData {
    fn input_action(&self) -> &i32 {
        &self.input_action
    }
    fn input_dead_zone(&self) -> &f32 {
        &self.input_dead_zone
    }
    fn quantity(&self) -> &PhysicsQuantity {
        &self.quantity
    }
    fn axis(&self) -> &PhysicsActionAxis {
        &self.axis
    }
    fn force_strength(&self) -> &f32 {
        &self.force_strength
    }
    fn scale_on_mass(&self) -> &bool {
        &self.scale_on_mass
    }
    fn force_time(&self) -> &f32 {
        &self.force_time
    }
    fn cooldown_time(&self) -> &f32 {
        &self.cooldown_time
    }
    fn linear_offset(&self) -> &super::core::Vec3 {
        &self.linear_offset
    }
    fn linear_offset_space(&self) -> &PhysicsSpace {
        &self.linear_offset_space
    }
}

impl PhysicsActionBaseDataTrait for ForceOverTimePhysicsActionData {
    fn blend_factor(&self) -> &f32 {
        self._glacier_base.blend_factor()
    }
    fn input_blend_factor(&self) -> &f32 {
        self._glacier_base.input_blend_factor()
    }
    fn clamp_lin_acc(&self) -> &f32 {
        self._glacier_base.clamp_lin_acc()
    }
    fn clamp_ang_acc(&self) -> &f32 {
        self._glacier_base.clamp_ang_acc()
    }
    fn blend_factor_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.blend_factor_curve()
    }
    fn collision_response_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.collision_response_curve()
    }
}

impl super::entity::EntityDataTrait for ForceOverTimePhysicsActionData {
}

impl super::entity::GameObjectDataTrait for ForceOverTimePhysicsActionData {
}

impl super::core::DataBusPeerTrait for ForceOverTimePhysicsActionData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for ForceOverTimePhysicsActionData {
}

impl super::core::DataContainerTrait for ForceOverTimePhysicsActionData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static FORCEOVERTIMEPHYSICSACTIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ForceOverTimePhysicsActionData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PHYSICSACTIONBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ForceOverTimePhysicsActionData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "InputAction",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ForceOverTimePhysicsActionData, input_action),
            },
            FieldInfoData {
                name: "InputDeadZone",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ForceOverTimePhysicsActionData, input_dead_zone),
            },
            FieldInfoData {
                name: "Quantity",
                flags: MemberInfoFlags::new(0),
                field_type: "PhysicsQuantity",
                rust_offset: offset_of!(ForceOverTimePhysicsActionData, quantity),
            },
            FieldInfoData {
                name: "Axis",
                flags: MemberInfoFlags::new(0),
                field_type: "PhysicsActionAxis",
                rust_offset: offset_of!(ForceOverTimePhysicsActionData, axis),
            },
            FieldInfoData {
                name: "ForceStrength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ForceOverTimePhysicsActionData, force_strength),
            },
            FieldInfoData {
                name: "ScaleOnMass",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ForceOverTimePhysicsActionData, scale_on_mass),
            },
            FieldInfoData {
                name: "ForceTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ForceOverTimePhysicsActionData, force_time),
            },
            FieldInfoData {
                name: "CooldownTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ForceOverTimePhysicsActionData, cooldown_time),
            },
            FieldInfoData {
                name: "LinearOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(ForceOverTimePhysicsActionData, linear_offset),
            },
            FieldInfoData {
                name: "LinearOffsetSpace",
                flags: MemberInfoFlags::new(0),
                field_type: "PhysicsSpace",
                rust_offset: offset_of!(ForceOverTimePhysicsActionData, linear_offset_space),
            },
        ],
    }),
    array_type: Some(FORCEOVERTIMEPHYSICSACTIONDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ForceOverTimePhysicsActionData {
    fn type_info(&self) -> &'static TypeInfo {
        FORCEOVERTIMEPHYSICSACTIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static FORCEOVERTIMEPHYSICSACTIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ForceOverTimePhysicsActionData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("ForceOverTimePhysicsActionData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SpringSetPhysicsActionData {
    pub _glacier_base: PhysicsActionBaseData,
    pub collide_against_water: bool,
    pub spring_length: f32,
    pub spring_strength: f32,
    pub compression_damping: f32,
    pub expansion_damping: f32,
    pub pow_strength: f32,
    pub pow_damping: f32,
    pub springs: Vec<PhysicsActionSpringData>,
}

pub trait SpringSetPhysicsActionDataTrait: PhysicsActionBaseDataTrait {
    fn collide_against_water(&self) -> &bool;
    fn spring_length(&self) -> &f32;
    fn spring_strength(&self) -> &f32;
    fn compression_damping(&self) -> &f32;
    fn expansion_damping(&self) -> &f32;
    fn pow_strength(&self) -> &f32;
    fn pow_damping(&self) -> &f32;
    fn springs(&self) -> &Vec<PhysicsActionSpringData>;
}

impl SpringSetPhysicsActionDataTrait for SpringSetPhysicsActionData {
    fn collide_against_water(&self) -> &bool {
        &self.collide_against_water
    }
    fn spring_length(&self) -> &f32 {
        &self.spring_length
    }
    fn spring_strength(&self) -> &f32 {
        &self.spring_strength
    }
    fn compression_damping(&self) -> &f32 {
        &self.compression_damping
    }
    fn expansion_damping(&self) -> &f32 {
        &self.expansion_damping
    }
    fn pow_strength(&self) -> &f32 {
        &self.pow_strength
    }
    fn pow_damping(&self) -> &f32 {
        &self.pow_damping
    }
    fn springs(&self) -> &Vec<PhysicsActionSpringData> {
        &self.springs
    }
}

impl PhysicsActionBaseDataTrait for SpringSetPhysicsActionData {
    fn blend_factor(&self) -> &f32 {
        self._glacier_base.blend_factor()
    }
    fn input_blend_factor(&self) -> &f32 {
        self._glacier_base.input_blend_factor()
    }
    fn clamp_lin_acc(&self) -> &f32 {
        self._glacier_base.clamp_lin_acc()
    }
    fn clamp_ang_acc(&self) -> &f32 {
        self._glacier_base.clamp_ang_acc()
    }
    fn blend_factor_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.blend_factor_curve()
    }
    fn collision_response_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.collision_response_curve()
    }
}

impl super::entity::EntityDataTrait for SpringSetPhysicsActionData {
}

impl super::entity::GameObjectDataTrait for SpringSetPhysicsActionData {
}

impl super::core::DataBusPeerTrait for SpringSetPhysicsActionData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for SpringSetPhysicsActionData {
}

impl super::core::DataContainerTrait for SpringSetPhysicsActionData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SPRINGSETPHYSICSACTIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpringSetPhysicsActionData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PHYSICSACTIONBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SpringSetPhysicsActionData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "CollideAgainstWater",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SpringSetPhysicsActionData, collide_against_water),
            },
            FieldInfoData {
                name: "SpringLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpringSetPhysicsActionData, spring_length),
            },
            FieldInfoData {
                name: "SpringStrength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpringSetPhysicsActionData, spring_strength),
            },
            FieldInfoData {
                name: "CompressionDamping",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpringSetPhysicsActionData, compression_damping),
            },
            FieldInfoData {
                name: "ExpansionDamping",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpringSetPhysicsActionData, expansion_damping),
            },
            FieldInfoData {
                name: "PowStrength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpringSetPhysicsActionData, pow_strength),
            },
            FieldInfoData {
                name: "PowDamping",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpringSetPhysicsActionData, pow_damping),
            },
            FieldInfoData {
                name: "Springs",
                flags: MemberInfoFlags::new(144),
                field_type: "PhysicsActionSpringData-Array",
                rust_offset: offset_of!(SpringSetPhysicsActionData, springs),
            },
        ],
    }),
    array_type: Some(SPRINGSETPHYSICSACTIONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SpringSetPhysicsActionData {
    fn type_info(&self) -> &'static TypeInfo {
        SPRINGSETPHYSICSACTIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SPRINGSETPHYSICSACTIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpringSetPhysicsActionData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("SpringSetPhysicsActionData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VelocityOnInputPhysicsActionData {
    pub _glacier_base: PhysicsActionBaseData,
    pub input_action: i32,
    pub ignore_input: bool,
    pub quantity: PhysicsQuantity,
    pub axis: PhysicsActionAxis,
    pub target_speed: f32,
    pub input_smooth_time: f32,
    pub no_input_smooth_time: f32,
}

pub trait VelocityOnInputPhysicsActionDataTrait: PhysicsActionBaseDataTrait {
    fn input_action(&self) -> &i32;
    fn ignore_input(&self) -> &bool;
    fn quantity(&self) -> &PhysicsQuantity;
    fn axis(&self) -> &PhysicsActionAxis;
    fn target_speed(&self) -> &f32;
    fn input_smooth_time(&self) -> &f32;
    fn no_input_smooth_time(&self) -> &f32;
}

impl VelocityOnInputPhysicsActionDataTrait for VelocityOnInputPhysicsActionData {
    fn input_action(&self) -> &i32 {
        &self.input_action
    }
    fn ignore_input(&self) -> &bool {
        &self.ignore_input
    }
    fn quantity(&self) -> &PhysicsQuantity {
        &self.quantity
    }
    fn axis(&self) -> &PhysicsActionAxis {
        &self.axis
    }
    fn target_speed(&self) -> &f32 {
        &self.target_speed
    }
    fn input_smooth_time(&self) -> &f32 {
        &self.input_smooth_time
    }
    fn no_input_smooth_time(&self) -> &f32 {
        &self.no_input_smooth_time
    }
}

impl PhysicsActionBaseDataTrait for VelocityOnInputPhysicsActionData {
    fn blend_factor(&self) -> &f32 {
        self._glacier_base.blend_factor()
    }
    fn input_blend_factor(&self) -> &f32 {
        self._glacier_base.input_blend_factor()
    }
    fn clamp_lin_acc(&self) -> &f32 {
        self._glacier_base.clamp_lin_acc()
    }
    fn clamp_ang_acc(&self) -> &f32 {
        self._glacier_base.clamp_ang_acc()
    }
    fn blend_factor_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.blend_factor_curve()
    }
    fn collision_response_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.collision_response_curve()
    }
}

impl super::entity::EntityDataTrait for VelocityOnInputPhysicsActionData {
}

impl super::entity::GameObjectDataTrait for VelocityOnInputPhysicsActionData {
}

impl super::core::DataBusPeerTrait for VelocityOnInputPhysicsActionData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for VelocityOnInputPhysicsActionData {
}

impl super::core::DataContainerTrait for VelocityOnInputPhysicsActionData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static VELOCITYONINPUTPHYSICSACTIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VelocityOnInputPhysicsActionData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PHYSICSACTIONBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VelocityOnInputPhysicsActionData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "InputAction",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(VelocityOnInputPhysicsActionData, input_action),
            },
            FieldInfoData {
                name: "IgnoreInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VelocityOnInputPhysicsActionData, ignore_input),
            },
            FieldInfoData {
                name: "Quantity",
                flags: MemberInfoFlags::new(0),
                field_type: "PhysicsQuantity",
                rust_offset: offset_of!(VelocityOnInputPhysicsActionData, quantity),
            },
            FieldInfoData {
                name: "Axis",
                flags: MemberInfoFlags::new(0),
                field_type: "PhysicsActionAxis",
                rust_offset: offset_of!(VelocityOnInputPhysicsActionData, axis),
            },
            FieldInfoData {
                name: "TargetSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VelocityOnInputPhysicsActionData, target_speed),
            },
            FieldInfoData {
                name: "InputSmoothTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VelocityOnInputPhysicsActionData, input_smooth_time),
            },
            FieldInfoData {
                name: "NoInputSmoothTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VelocityOnInputPhysicsActionData, no_input_smooth_time),
            },
        ],
    }),
    array_type: Some(VELOCITYONINPUTPHYSICSACTIONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VelocityOnInputPhysicsActionData {
    fn type_info(&self) -> &'static TypeInfo {
        VELOCITYONINPUTPHYSICSACTIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VELOCITYONINPUTPHYSICSACTIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VelocityOnInputPhysicsActionData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("VelocityOnInputPhysicsActionData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WorldRelSteeringPhysicsActionData {
    pub _glacier_base: PhysicsActionBaseData,
    pub input_action_pitch: i32,
    pub input_action_yaw: i32,
    pub max_yaw_speed: f32,
    pub max_pitch_speed: f32,
    pub yaw_smooth_time: f32,
    pub yaw_smooth_time_no_input: f32,
    pub pitch_smooth_time: f32,
    pub pitch_smooth_time_no_input: f32,
    pub max_rotation_speed_curve: super::core::AudioCurve,
}

pub trait WorldRelSteeringPhysicsActionDataTrait: PhysicsActionBaseDataTrait {
    fn input_action_pitch(&self) -> &i32;
    fn input_action_yaw(&self) -> &i32;
    fn max_yaw_speed(&self) -> &f32;
    fn max_pitch_speed(&self) -> &f32;
    fn yaw_smooth_time(&self) -> &f32;
    fn yaw_smooth_time_no_input(&self) -> &f32;
    fn pitch_smooth_time(&self) -> &f32;
    fn pitch_smooth_time_no_input(&self) -> &f32;
    fn max_rotation_speed_curve(&self) -> &super::core::AudioCurve;
}

impl WorldRelSteeringPhysicsActionDataTrait for WorldRelSteeringPhysicsActionData {
    fn input_action_pitch(&self) -> &i32 {
        &self.input_action_pitch
    }
    fn input_action_yaw(&self) -> &i32 {
        &self.input_action_yaw
    }
    fn max_yaw_speed(&self) -> &f32 {
        &self.max_yaw_speed
    }
    fn max_pitch_speed(&self) -> &f32 {
        &self.max_pitch_speed
    }
    fn yaw_smooth_time(&self) -> &f32 {
        &self.yaw_smooth_time
    }
    fn yaw_smooth_time_no_input(&self) -> &f32 {
        &self.yaw_smooth_time_no_input
    }
    fn pitch_smooth_time(&self) -> &f32 {
        &self.pitch_smooth_time
    }
    fn pitch_smooth_time_no_input(&self) -> &f32 {
        &self.pitch_smooth_time_no_input
    }
    fn max_rotation_speed_curve(&self) -> &super::core::AudioCurve {
        &self.max_rotation_speed_curve
    }
}

impl PhysicsActionBaseDataTrait for WorldRelSteeringPhysicsActionData {
    fn blend_factor(&self) -> &f32 {
        self._glacier_base.blend_factor()
    }
    fn input_blend_factor(&self) -> &f32 {
        self._glacier_base.input_blend_factor()
    }
    fn clamp_lin_acc(&self) -> &f32 {
        self._glacier_base.clamp_lin_acc()
    }
    fn clamp_ang_acc(&self) -> &f32 {
        self._glacier_base.clamp_ang_acc()
    }
    fn blend_factor_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.blend_factor_curve()
    }
    fn collision_response_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.collision_response_curve()
    }
}

impl super::entity::EntityDataTrait for WorldRelSteeringPhysicsActionData {
}

impl super::entity::GameObjectDataTrait for WorldRelSteeringPhysicsActionData {
}

impl super::core::DataBusPeerTrait for WorldRelSteeringPhysicsActionData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for WorldRelSteeringPhysicsActionData {
}

impl super::core::DataContainerTrait for WorldRelSteeringPhysicsActionData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static WORLDRELSTEERINGPHYSICSACTIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WorldRelSteeringPhysicsActionData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PHYSICSACTIONBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WorldRelSteeringPhysicsActionData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "InputActionPitch",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(WorldRelSteeringPhysicsActionData, input_action_pitch),
            },
            FieldInfoData {
                name: "InputActionYaw",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(WorldRelSteeringPhysicsActionData, input_action_yaw),
            },
            FieldInfoData {
                name: "MaxYawSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WorldRelSteeringPhysicsActionData, max_yaw_speed),
            },
            FieldInfoData {
                name: "MaxPitchSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WorldRelSteeringPhysicsActionData, max_pitch_speed),
            },
            FieldInfoData {
                name: "YawSmoothTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WorldRelSteeringPhysicsActionData, yaw_smooth_time),
            },
            FieldInfoData {
                name: "YawSmoothTimeNoInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WorldRelSteeringPhysicsActionData, yaw_smooth_time_no_input),
            },
            FieldInfoData {
                name: "PitchSmoothTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WorldRelSteeringPhysicsActionData, pitch_smooth_time),
            },
            FieldInfoData {
                name: "PitchSmoothTimeNoInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WorldRelSteeringPhysicsActionData, pitch_smooth_time_no_input),
            },
            FieldInfoData {
                name: "MaxRotationSpeedCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioCurve",
                rust_offset: offset_of!(WorldRelSteeringPhysicsActionData, max_rotation_speed_curve),
            },
        ],
    }),
    array_type: Some(WORLDRELSTEERINGPHYSICSACTIONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WorldRelSteeringPhysicsActionData {
    fn type_info(&self) -> &'static TypeInfo {
        WORLDRELSTEERINGPHYSICSACTIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static WORLDRELSTEERINGPHYSICSACTIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WorldRelSteeringPhysicsActionData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("WorldRelSteeringPhysicsActionData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SimpleEnginePhysicsActionData {
    pub _glacier_base: PhysicsActionBaseData,
    pub input_action: i32,
    pub speed_idle: f32,
    pub speed_min: f32,
    pub speed_max: f32,
    pub acceleration_smooth_time: f32,
    pub deacceleration_smooth_time: f32,
    pub speed_boost_while_turning: f32,
}

pub trait SimpleEnginePhysicsActionDataTrait: PhysicsActionBaseDataTrait {
    fn input_action(&self) -> &i32;
    fn speed_idle(&self) -> &f32;
    fn speed_min(&self) -> &f32;
    fn speed_max(&self) -> &f32;
    fn acceleration_smooth_time(&self) -> &f32;
    fn deacceleration_smooth_time(&self) -> &f32;
    fn speed_boost_while_turning(&self) -> &f32;
}

impl SimpleEnginePhysicsActionDataTrait for SimpleEnginePhysicsActionData {
    fn input_action(&self) -> &i32 {
        &self.input_action
    }
    fn speed_idle(&self) -> &f32 {
        &self.speed_idle
    }
    fn speed_min(&self) -> &f32 {
        &self.speed_min
    }
    fn speed_max(&self) -> &f32 {
        &self.speed_max
    }
    fn acceleration_smooth_time(&self) -> &f32 {
        &self.acceleration_smooth_time
    }
    fn deacceleration_smooth_time(&self) -> &f32 {
        &self.deacceleration_smooth_time
    }
    fn speed_boost_while_turning(&self) -> &f32 {
        &self.speed_boost_while_turning
    }
}

impl PhysicsActionBaseDataTrait for SimpleEnginePhysicsActionData {
    fn blend_factor(&self) -> &f32 {
        self._glacier_base.blend_factor()
    }
    fn input_blend_factor(&self) -> &f32 {
        self._glacier_base.input_blend_factor()
    }
    fn clamp_lin_acc(&self) -> &f32 {
        self._glacier_base.clamp_lin_acc()
    }
    fn clamp_ang_acc(&self) -> &f32 {
        self._glacier_base.clamp_ang_acc()
    }
    fn blend_factor_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.blend_factor_curve()
    }
    fn collision_response_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.collision_response_curve()
    }
}

impl super::entity::EntityDataTrait for SimpleEnginePhysicsActionData {
}

impl super::entity::GameObjectDataTrait for SimpleEnginePhysicsActionData {
}

impl super::core::DataBusPeerTrait for SimpleEnginePhysicsActionData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for SimpleEnginePhysicsActionData {
}

impl super::core::DataContainerTrait for SimpleEnginePhysicsActionData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SIMPLEENGINEPHYSICSACTIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleEnginePhysicsActionData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PHYSICSACTIONBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SimpleEnginePhysicsActionData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "InputAction",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SimpleEnginePhysicsActionData, input_action),
            },
            FieldInfoData {
                name: "SpeedIdle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SimpleEnginePhysicsActionData, speed_idle),
            },
            FieldInfoData {
                name: "SpeedMin",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SimpleEnginePhysicsActionData, speed_min),
            },
            FieldInfoData {
                name: "SpeedMax",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SimpleEnginePhysicsActionData, speed_max),
            },
            FieldInfoData {
                name: "AccelerationSmoothTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SimpleEnginePhysicsActionData, acceleration_smooth_time),
            },
            FieldInfoData {
                name: "DeaccelerationSmoothTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SimpleEnginePhysicsActionData, deacceleration_smooth_time),
            },
            FieldInfoData {
                name: "SpeedBoostWhileTurning",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SimpleEnginePhysicsActionData, speed_boost_while_turning),
            },
        ],
    }),
    array_type: Some(SIMPLEENGINEPHYSICSACTIONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SimpleEnginePhysicsActionData {
    fn type_info(&self) -> &'static TypeInfo {
        SIMPLEENGINEPHYSICSACTIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SIMPLEENGINEPHYSICSACTIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleEnginePhysicsActionData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("SimpleEnginePhysicsActionData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RollOnInputPhysicsActionData {
    pub _glacier_base: PhysicsActionBaseData,
    pub roll_inputs: Vec<RollOnInputData>,
    pub max_roll_angle: f32,
    pub smooth_time: f32,
    pub smooth_time_no_input: f32,
}

pub trait RollOnInputPhysicsActionDataTrait: PhysicsActionBaseDataTrait {
    fn roll_inputs(&self) -> &Vec<RollOnInputData>;
    fn max_roll_angle(&self) -> &f32;
    fn smooth_time(&self) -> &f32;
    fn smooth_time_no_input(&self) -> &f32;
}

impl RollOnInputPhysicsActionDataTrait for RollOnInputPhysicsActionData {
    fn roll_inputs(&self) -> &Vec<RollOnInputData> {
        &self.roll_inputs
    }
    fn max_roll_angle(&self) -> &f32 {
        &self.max_roll_angle
    }
    fn smooth_time(&self) -> &f32 {
        &self.smooth_time
    }
    fn smooth_time_no_input(&self) -> &f32 {
        &self.smooth_time_no_input
    }
}

impl PhysicsActionBaseDataTrait for RollOnInputPhysicsActionData {
    fn blend_factor(&self) -> &f32 {
        self._glacier_base.blend_factor()
    }
    fn input_blend_factor(&self) -> &f32 {
        self._glacier_base.input_blend_factor()
    }
    fn clamp_lin_acc(&self) -> &f32 {
        self._glacier_base.clamp_lin_acc()
    }
    fn clamp_ang_acc(&self) -> &f32 {
        self._glacier_base.clamp_ang_acc()
    }
    fn blend_factor_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.blend_factor_curve()
    }
    fn collision_response_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.collision_response_curve()
    }
}

impl super::entity::EntityDataTrait for RollOnInputPhysicsActionData {
}

impl super::entity::GameObjectDataTrait for RollOnInputPhysicsActionData {
}

impl super::core::DataBusPeerTrait for RollOnInputPhysicsActionData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for RollOnInputPhysicsActionData {
}

impl super::core::DataContainerTrait for RollOnInputPhysicsActionData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static ROLLONINPUTPHYSICSACTIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RollOnInputPhysicsActionData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PHYSICSACTIONBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RollOnInputPhysicsActionData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "RollInputs",
                flags: MemberInfoFlags::new(144),
                field_type: "RollOnInputData-Array",
                rust_offset: offset_of!(RollOnInputPhysicsActionData, roll_inputs),
            },
            FieldInfoData {
                name: "MaxRollAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RollOnInputPhysicsActionData, max_roll_angle),
            },
            FieldInfoData {
                name: "SmoothTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RollOnInputPhysicsActionData, smooth_time),
            },
            FieldInfoData {
                name: "SmoothTimeNoInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RollOnInputPhysicsActionData, smooth_time_no_input),
            },
        ],
    }),
    array_type: Some(ROLLONINPUTPHYSICSACTIONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RollOnInputPhysicsActionData {
    fn type_info(&self) -> &'static TypeInfo {
        ROLLONINPUTPHYSICSACTIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ROLLONINPUTPHYSICSACTIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RollOnInputPhysicsActionData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("RollOnInputPhysicsActionData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RollOnInputData {
    pub input_action: i32,
    pub roll_angle: f32,
}

pub trait RollOnInputDataTrait: TypeObject {
    fn input_action(&self) -> &i32;
    fn roll_angle(&self) -> &f32;
}

impl RollOnInputDataTrait for RollOnInputData {
    fn input_action(&self) -> &i32 {
        &self.input_action
    }
    fn roll_angle(&self) -> &f32 {
        &self.roll_angle
    }
}

pub static ROLLONINPUTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RollOnInputData",
    flags: MemberInfoFlags::new(36937),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RollOnInputData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "InputAction",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(RollOnInputData, input_action),
            },
            FieldInfoData {
                name: "RollAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RollOnInputData, roll_angle),
            },
        ],
    }),
    array_type: Some(ROLLONINPUTDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for RollOnInputData {
    fn type_info(&self) -> &'static TypeInfo {
        ROLLONINPUTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ROLLONINPUTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RollOnInputData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("RollOnInputData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ConstraintPhysicsActionData {
    pub _glacier_base: PhysicsActionBaseData,
    pub aabb_min: super::core::Vec3,
    pub aabb_max: super::core::Vec3,
    pub aabb_fade_range: super::core::Vec3,
    pub aabb_smooth_time: super::core::Vec3,
    pub rot_min: super::core::Vec3,
    pub rot_max: super::core::Vec3,
    pub rot_fade_range: super::core::Vec3,
    pub rot_smooth_time: super::core::Vec3,
}

pub trait ConstraintPhysicsActionDataTrait: PhysicsActionBaseDataTrait {
    fn aabb_min(&self) -> &super::core::Vec3;
    fn aabb_max(&self) -> &super::core::Vec3;
    fn aabb_fade_range(&self) -> &super::core::Vec3;
    fn aabb_smooth_time(&self) -> &super::core::Vec3;
    fn rot_min(&self) -> &super::core::Vec3;
    fn rot_max(&self) -> &super::core::Vec3;
    fn rot_fade_range(&self) -> &super::core::Vec3;
    fn rot_smooth_time(&self) -> &super::core::Vec3;
}

impl ConstraintPhysicsActionDataTrait for ConstraintPhysicsActionData {
    fn aabb_min(&self) -> &super::core::Vec3 {
        &self.aabb_min
    }
    fn aabb_max(&self) -> &super::core::Vec3 {
        &self.aabb_max
    }
    fn aabb_fade_range(&self) -> &super::core::Vec3 {
        &self.aabb_fade_range
    }
    fn aabb_smooth_time(&self) -> &super::core::Vec3 {
        &self.aabb_smooth_time
    }
    fn rot_min(&self) -> &super::core::Vec3 {
        &self.rot_min
    }
    fn rot_max(&self) -> &super::core::Vec3 {
        &self.rot_max
    }
    fn rot_fade_range(&self) -> &super::core::Vec3 {
        &self.rot_fade_range
    }
    fn rot_smooth_time(&self) -> &super::core::Vec3 {
        &self.rot_smooth_time
    }
}

impl PhysicsActionBaseDataTrait for ConstraintPhysicsActionData {
    fn blend_factor(&self) -> &f32 {
        self._glacier_base.blend_factor()
    }
    fn input_blend_factor(&self) -> &f32 {
        self._glacier_base.input_blend_factor()
    }
    fn clamp_lin_acc(&self) -> &f32 {
        self._glacier_base.clamp_lin_acc()
    }
    fn clamp_ang_acc(&self) -> &f32 {
        self._glacier_base.clamp_ang_acc()
    }
    fn blend_factor_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.blend_factor_curve()
    }
    fn collision_response_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.collision_response_curve()
    }
}

impl super::entity::EntityDataTrait for ConstraintPhysicsActionData {
}

impl super::entity::GameObjectDataTrait for ConstraintPhysicsActionData {
}

impl super::core::DataBusPeerTrait for ConstraintPhysicsActionData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for ConstraintPhysicsActionData {
}

impl super::core::DataContainerTrait for ConstraintPhysicsActionData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CONSTRAINTPHYSICSACTIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ConstraintPhysicsActionData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PHYSICSACTIONBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ConstraintPhysicsActionData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AabbMin",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(ConstraintPhysicsActionData, aabb_min),
            },
            FieldInfoData {
                name: "AabbMax",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(ConstraintPhysicsActionData, aabb_max),
            },
            FieldInfoData {
                name: "AabbFadeRange",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(ConstraintPhysicsActionData, aabb_fade_range),
            },
            FieldInfoData {
                name: "AabbSmoothTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(ConstraintPhysicsActionData, aabb_smooth_time),
            },
            FieldInfoData {
                name: "RotMin",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(ConstraintPhysicsActionData, rot_min),
            },
            FieldInfoData {
                name: "RotMax",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(ConstraintPhysicsActionData, rot_max),
            },
            FieldInfoData {
                name: "RotFadeRange",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(ConstraintPhysicsActionData, rot_fade_range),
            },
            FieldInfoData {
                name: "RotSmoothTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(ConstraintPhysicsActionData, rot_smooth_time),
            },
        ],
    }),
    array_type: Some(CONSTRAINTPHYSICSACTIONDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ConstraintPhysicsActionData {
    fn type_info(&self) -> &'static TypeInfo {
        CONSTRAINTPHYSICSACTIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CONSTRAINTPHYSICSACTIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ConstraintPhysicsActionData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("ConstraintPhysicsActionData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AntiGravityPhysicsActionData {
    pub _glacier_base: PhysicsActionBaseData,
}

pub trait AntiGravityPhysicsActionDataTrait: PhysicsActionBaseDataTrait {
}

impl AntiGravityPhysicsActionDataTrait for AntiGravityPhysicsActionData {
}

impl PhysicsActionBaseDataTrait for AntiGravityPhysicsActionData {
    fn blend_factor(&self) -> &f32 {
        self._glacier_base.blend_factor()
    }
    fn input_blend_factor(&self) -> &f32 {
        self._glacier_base.input_blend_factor()
    }
    fn clamp_lin_acc(&self) -> &f32 {
        self._glacier_base.clamp_lin_acc()
    }
    fn clamp_ang_acc(&self) -> &f32 {
        self._glacier_base.clamp_ang_acc()
    }
    fn blend_factor_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.blend_factor_curve()
    }
    fn collision_response_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.collision_response_curve()
    }
}

impl super::entity::EntityDataTrait for AntiGravityPhysicsActionData {
}

impl super::entity::GameObjectDataTrait for AntiGravityPhysicsActionData {
}

impl super::core::DataBusPeerTrait for AntiGravityPhysicsActionData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for AntiGravityPhysicsActionData {
}

impl super::core::DataContainerTrait for AntiGravityPhysicsActionData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static ANTIGRAVITYPHYSICSACTIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntiGravityPhysicsActionData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PHYSICSACTIONBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AntiGravityPhysicsActionData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(ANTIGRAVITYPHYSICSACTIONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AntiGravityPhysicsActionData {
    fn type_info(&self) -> &'static TypeInfo {
        ANTIGRAVITYPHYSICSACTIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ANTIGRAVITYPHYSICSACTIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntiGravityPhysicsActionData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("AntiGravityPhysicsActionData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ForcePhysicsActionData {
    pub _glacier_base: PhysicsActionBaseData,
    pub input_action: i32,
    pub force: super::core::Vec3,
}

pub trait ForcePhysicsActionDataTrait: PhysicsActionBaseDataTrait {
    fn input_action(&self) -> &i32;
    fn force(&self) -> &super::core::Vec3;
}

impl ForcePhysicsActionDataTrait for ForcePhysicsActionData {
    fn input_action(&self) -> &i32 {
        &self.input_action
    }
    fn force(&self) -> &super::core::Vec3 {
        &self.force
    }
}

impl PhysicsActionBaseDataTrait for ForcePhysicsActionData {
    fn blend_factor(&self) -> &f32 {
        self._glacier_base.blend_factor()
    }
    fn input_blend_factor(&self) -> &f32 {
        self._glacier_base.input_blend_factor()
    }
    fn clamp_lin_acc(&self) -> &f32 {
        self._glacier_base.clamp_lin_acc()
    }
    fn clamp_ang_acc(&self) -> &f32 {
        self._glacier_base.clamp_ang_acc()
    }
    fn blend_factor_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.blend_factor_curve()
    }
    fn collision_response_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.collision_response_curve()
    }
}

impl super::entity::EntityDataTrait for ForcePhysicsActionData {
}

impl super::entity::GameObjectDataTrait for ForcePhysicsActionData {
}

impl super::core::DataBusPeerTrait for ForcePhysicsActionData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for ForcePhysicsActionData {
}

impl super::core::DataContainerTrait for ForcePhysicsActionData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static FORCEPHYSICSACTIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ForcePhysicsActionData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PHYSICSACTIONBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ForcePhysicsActionData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "InputAction",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ForcePhysicsActionData, input_action),
            },
            FieldInfoData {
                name: "Force",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(ForcePhysicsActionData, force),
            },
        ],
    }),
    array_type: Some(FORCEPHYSICSACTIONDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ForcePhysicsActionData {
    fn type_info(&self) -> &'static TypeInfo {
        FORCEPHYSICSACTIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static FORCEPHYSICSACTIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ForcePhysicsActionData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("ForcePhysicsActionData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PhysicsActionBaseData {
    pub _glacier_base: super::entity::EntityData,
    pub blend_factor: f32,
    pub input_blend_factor: f32,
    pub clamp_lin_acc: f32,
    pub clamp_ang_acc: f32,
    pub blend_factor_curve: super::core::AudioCurve,
    pub collision_response_curve: super::core::AudioCurve,
}

pub trait PhysicsActionBaseDataTrait: super::entity::EntityDataTrait {
    fn blend_factor(&self) -> &f32;
    fn input_blend_factor(&self) -> &f32;
    fn clamp_lin_acc(&self) -> &f32;
    fn clamp_ang_acc(&self) -> &f32;
    fn blend_factor_curve(&self) -> &super::core::AudioCurve;
    fn collision_response_curve(&self) -> &super::core::AudioCurve;
}

impl PhysicsActionBaseDataTrait for PhysicsActionBaseData {
    fn blend_factor(&self) -> &f32 {
        &self.blend_factor
    }
    fn input_blend_factor(&self) -> &f32 {
        &self.input_blend_factor
    }
    fn clamp_lin_acc(&self) -> &f32 {
        &self.clamp_lin_acc
    }
    fn clamp_ang_acc(&self) -> &f32 {
        &self.clamp_ang_acc
    }
    fn blend_factor_curve(&self) -> &super::core::AudioCurve {
        &self.blend_factor_curve
    }
    fn collision_response_curve(&self) -> &super::core::AudioCurve {
        &self.collision_response_curve
    }
}

impl super::entity::EntityDataTrait for PhysicsActionBaseData {
}

impl super::entity::GameObjectDataTrait for PhysicsActionBaseData {
}

impl super::core::DataBusPeerTrait for PhysicsActionBaseData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for PhysicsActionBaseData {
}

impl super::core::DataContainerTrait for PhysicsActionBaseData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PHYSICSACTIONBASEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsActionBaseData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PhysicsActionBaseData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "BlendFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicsActionBaseData, blend_factor),
            },
            FieldInfoData {
                name: "InputBlendFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicsActionBaseData, input_blend_factor),
            },
            FieldInfoData {
                name: "ClampLinAcc",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicsActionBaseData, clamp_lin_acc),
            },
            FieldInfoData {
                name: "ClampAngAcc",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicsActionBaseData, clamp_ang_acc),
            },
            FieldInfoData {
                name: "BlendFactorCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioCurve",
                rust_offset: offset_of!(PhysicsActionBaseData, blend_factor_curve),
            },
            FieldInfoData {
                name: "CollisionResponseCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioCurve",
                rust_offset: offset_of!(PhysicsActionBaseData, collision_response_curve),
            },
        ],
    }),
    array_type: Some(PHYSICSACTIONBASEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PhysicsActionBaseData {
    fn type_info(&self) -> &'static TypeInfo {
        PHYSICSACTIONBASEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PHYSICSACTIONBASEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsActionBaseData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PhysicsActionBaseData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PhysicsActionCollectionComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub blend_factor: f32,
    pub clamp_angular_speed: f32,
    pub clamp_linear_speed: f32,
    pub clamp_lin_acc: f32,
    pub clamp_ang_acc: f32,
    pub min_collision_speed_for_response: f32,
    pub report_heavy_dynamic_collision_as_static: bool,
    pub heavy_dynamic_collision_mass_limit: f32,
}

pub trait PhysicsActionCollectionComponentDataTrait: super::entity::GameComponentDataTrait {
    fn blend_factor(&self) -> &f32;
    fn clamp_angular_speed(&self) -> &f32;
    fn clamp_linear_speed(&self) -> &f32;
    fn clamp_lin_acc(&self) -> &f32;
    fn clamp_ang_acc(&self) -> &f32;
    fn min_collision_speed_for_response(&self) -> &f32;
    fn report_heavy_dynamic_collision_as_static(&self) -> &bool;
    fn heavy_dynamic_collision_mass_limit(&self) -> &f32;
}

impl PhysicsActionCollectionComponentDataTrait for PhysicsActionCollectionComponentData {
    fn blend_factor(&self) -> &f32 {
        &self.blend_factor
    }
    fn clamp_angular_speed(&self) -> &f32 {
        &self.clamp_angular_speed
    }
    fn clamp_linear_speed(&self) -> &f32 {
        &self.clamp_linear_speed
    }
    fn clamp_lin_acc(&self) -> &f32 {
        &self.clamp_lin_acc
    }
    fn clamp_ang_acc(&self) -> &f32 {
        &self.clamp_ang_acc
    }
    fn min_collision_speed_for_response(&self) -> &f32 {
        &self.min_collision_speed_for_response
    }
    fn report_heavy_dynamic_collision_as_static(&self) -> &bool {
        &self.report_heavy_dynamic_collision_as_static
    }
    fn heavy_dynamic_collision_mass_limit(&self) -> &f32 {
        &self.heavy_dynamic_collision_mass_limit
    }
}

impl super::entity::GameComponentDataTrait for PhysicsActionCollectionComponentData {
}

impl super::entity::ComponentDataTrait for PhysicsActionCollectionComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
}

impl super::entity::GameObjectDataTrait for PhysicsActionCollectionComponentData {
}

impl super::core::DataBusPeerTrait for PhysicsActionCollectionComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for PhysicsActionCollectionComponentData {
}

impl super::core::DataContainerTrait for PhysicsActionCollectionComponentData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PHYSICSACTIONCOLLECTIONCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsActionCollectionComponentData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PhysicsActionCollectionComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "BlendFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicsActionCollectionComponentData, blend_factor),
            },
            FieldInfoData {
                name: "ClampAngularSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicsActionCollectionComponentData, clamp_angular_speed),
            },
            FieldInfoData {
                name: "ClampLinearSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicsActionCollectionComponentData, clamp_linear_speed),
            },
            FieldInfoData {
                name: "ClampLinAcc",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicsActionCollectionComponentData, clamp_lin_acc),
            },
            FieldInfoData {
                name: "ClampAngAcc",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicsActionCollectionComponentData, clamp_ang_acc),
            },
            FieldInfoData {
                name: "MinCollisionSpeedForResponse",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicsActionCollectionComponentData, min_collision_speed_for_response),
            },
            FieldInfoData {
                name: "ReportHeavyDynamicCollisionAsStatic",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PhysicsActionCollectionComponentData, report_heavy_dynamic_collision_as_static),
            },
            FieldInfoData {
                name: "HeavyDynamicCollisionMassLimit",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicsActionCollectionComponentData, heavy_dynamic_collision_mass_limit),
            },
        ],
    }),
    array_type: Some(PHYSICSACTIONCOLLECTIONCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PhysicsActionCollectionComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        PHYSICSACTIONCOLLECTIONCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PHYSICSACTIONCOLLECTIONCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsActionCollectionComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PhysicsActionCollectionComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PhysicsActionSpringData {
    pub model_offset: super::core::Vec3,
    pub direction: PhysicsActionAxis,
    pub invert_direction: bool,
    pub max_surface_angle: f32,
    pub predicted_time: f32,
    pub min_predicted_distance: f32,
    pub max_predicted_steps: i32,
}

pub trait PhysicsActionSpringDataTrait: TypeObject {
    fn model_offset(&self) -> &super::core::Vec3;
    fn direction(&self) -> &PhysicsActionAxis;
    fn invert_direction(&self) -> &bool;
    fn max_surface_angle(&self) -> &f32;
    fn predicted_time(&self) -> &f32;
    fn min_predicted_distance(&self) -> &f32;
    fn max_predicted_steps(&self) -> &i32;
}

impl PhysicsActionSpringDataTrait for PhysicsActionSpringData {
    fn model_offset(&self) -> &super::core::Vec3 {
        &self.model_offset
    }
    fn direction(&self) -> &PhysicsActionAxis {
        &self.direction
    }
    fn invert_direction(&self) -> &bool {
        &self.invert_direction
    }
    fn max_surface_angle(&self) -> &f32 {
        &self.max_surface_angle
    }
    fn predicted_time(&self) -> &f32 {
        &self.predicted_time
    }
    fn min_predicted_distance(&self) -> &f32 {
        &self.min_predicted_distance
    }
    fn max_predicted_steps(&self) -> &i32 {
        &self.max_predicted_steps
    }
}

pub static PHYSICSACTIONSPRINGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsActionSpringData",
    flags: MemberInfoFlags::new(36937),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PhysicsActionSpringData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ModelOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(PhysicsActionSpringData, model_offset),
            },
            FieldInfoData {
                name: "Direction",
                flags: MemberInfoFlags::new(0),
                field_type: "PhysicsActionAxis",
                rust_offset: offset_of!(PhysicsActionSpringData, direction),
            },
            FieldInfoData {
                name: "InvertDirection",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PhysicsActionSpringData, invert_direction),
            },
            FieldInfoData {
                name: "MaxSurfaceAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicsActionSpringData, max_surface_angle),
            },
            FieldInfoData {
                name: "PredictedTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicsActionSpringData, predicted_time),
            },
            FieldInfoData {
                name: "MinPredictedDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicsActionSpringData, min_predicted_distance),
            },
            FieldInfoData {
                name: "MaxPredictedSteps",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(PhysicsActionSpringData, max_predicted_steps),
            },
        ],
    }),
    array_type: Some(PHYSICSACTIONSPRINGDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PhysicsActionSpringData {
    fn type_info(&self) -> &'static TypeInfo {
        PHYSICSACTIONSPRINGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PHYSICSACTIONSPRINGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsActionSpringData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PhysicsActionSpringData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum PhysicsSpace {
    #[default]
    ModelSpace = 0,
    WorldSpace = 1,
}

pub static PHYSICSSPACE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsSpace",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(PHYSICSSPACE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for PhysicsSpace {
    fn type_info(&self) -> &'static TypeInfo {
        PHYSICSSPACE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PHYSICSSPACE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsSpace-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PhysicsSpace"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum PhysicsQuantity {
    #[default]
    Linear = 0,
    Angular = 1,
}

pub static PHYSICSQUANTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsQuantity",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(PHYSICSQUANTITY_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for PhysicsQuantity {
    fn type_info(&self) -> &'static TypeInfo {
        PHYSICSQUANTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PHYSICSQUANTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsQuantity-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PhysicsQuantity"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum PhysicsActionAxis {
    #[default]
    WorldX = 0,
    WorldY = 1,
    WorldZ = 2,
    ModelX = 3,
    ModelY = 4,
    ModelZ = 5,
    SideXZ = 6,
    ForwardXZ = 7,
}

pub static PHYSICSACTIONAXIS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsActionAxis",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(PHYSICSACTIONAXIS_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for PhysicsActionAxis {
    fn type_info(&self) -> &'static TypeInfo {
        PHYSICSACTIONAXIS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PHYSICSACTIONAXIS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsActionAxis-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PhysicsActionAxis"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct OverrideJointEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub bone_index: i32,
}

pub trait OverrideJointEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn bone_index(&self) -> &i32;
}

impl OverrideJointEntityDataTrait for OverrideJointEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn bone_index(&self) -> &i32 {
        &self.bone_index
    }
}

impl super::entity::EntityDataTrait for OverrideJointEntityData {
}

impl super::entity::GameObjectDataTrait for OverrideJointEntityData {
}

impl super::core::DataBusPeerTrait for OverrideJointEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for OverrideJointEntityData {
}

impl super::core::DataContainerTrait for OverrideJointEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static OVERRIDEJOINTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OverrideJointEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<OverrideJointEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(OverrideJointEntityData, realm),
            },
            FieldInfoData {
                name: "BoneIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(OverrideJointEntityData, bone_index),
            },
        ],
    }),
    array_type: Some(OVERRIDEJOINTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for OverrideJointEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        OVERRIDEJOINTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static OVERRIDEJOINTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OverrideJointEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("OverrideJointEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ObstacleDetectionHintData {
    pub _glacier_base: super::entity::EntityData,
    pub hint_mode: HintModeType,
    pub enabled: bool,
    pub follow_owner_transform: bool,
}

pub trait ObstacleDetectionHintDataTrait: super::entity::EntityDataTrait {
    fn hint_mode(&self) -> &HintModeType;
    fn enabled(&self) -> &bool;
    fn follow_owner_transform(&self) -> &bool;
}

impl ObstacleDetectionHintDataTrait for ObstacleDetectionHintData {
    fn hint_mode(&self) -> &HintModeType {
        &self.hint_mode
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn follow_owner_transform(&self) -> &bool {
        &self.follow_owner_transform
    }
}

impl super::entity::EntityDataTrait for ObstacleDetectionHintData {
}

impl super::entity::GameObjectDataTrait for ObstacleDetectionHintData {
}

impl super::core::DataBusPeerTrait for ObstacleDetectionHintData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for ObstacleDetectionHintData {
}

impl super::core::DataContainerTrait for ObstacleDetectionHintData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static OBSTACLEDETECTIONHINTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObstacleDetectionHintData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ObstacleDetectionHintData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "HintMode",
                flags: MemberInfoFlags::new(0),
                field_type: "HintModeType",
                rust_offset: offset_of!(ObstacleDetectionHintData, hint_mode),
            },
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ObstacleDetectionHintData, enabled),
            },
            FieldInfoData {
                name: "FollowOwnerTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ObstacleDetectionHintData, follow_owner_transform),
            },
        ],
    }),
    array_type: Some(OBSTACLEDETECTIONHINTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ObstacleDetectionHintData {
    fn type_info(&self) -> &'static TypeInfo {
        OBSTACLEDETECTIONHINTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static OBSTACLEDETECTIONHINTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObstacleDetectionHintData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("ObstacleDetectionHintData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum HintModeType {
    #[default]
    HintMode_Avoid = 0,
    HintMode_Lean = 1,
}

pub static HINTMODETYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HintModeType",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(HINTMODETYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for HintModeType {
    fn type_info(&self) -> &'static TypeInfo {
        HINTMODETYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static HINTMODETYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HintModeType-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("HintModeType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ObstacleDetectionEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub toggle_sprint: bool,
    pub true_toggle_sprint: bool,
    pub remove_sprint: bool,
    pub allow_jumping: bool,
    pub max_yaw_speed: f32,
    pub max_jump_height: f32,
    pub translation_offset: super::core::Vec3,
    pub half_extents: super::core::Vec3,
    pub create_avoidance_for_other_detectors: bool,
    pub toggle_sprint_threshold: f32,
    pub jump_cooldown: f32,
    pub min_jump_velocity: f32,
    pub min_medium_jump_velocity: f32,
    pub min_high_jump_velocity: f32,
    pub high_jump_height: f32,
    pub medium_jump_height: f32,
    pub low_jump_height: f32,
    pub min_jump_height: f32,
    pub reject_water_depth: f32,
    pub collision_layer: super::physics::RigidBodyCollisionLayer,
    pub throttle_input: i32,
    pub brake_input: i32,
    pub brake_in_air_input: i32,
    pub steer_input: i32,
    pub jump_input: i32,
    pub sprint_input: i32,
}

pub trait ObstacleDetectionEntityDataTrait: super::entity::EntityDataTrait {
    fn toggle_sprint(&self) -> &bool;
    fn true_toggle_sprint(&self) -> &bool;
    fn remove_sprint(&self) -> &bool;
    fn allow_jumping(&self) -> &bool;
    fn max_yaw_speed(&self) -> &f32;
    fn max_jump_height(&self) -> &f32;
    fn translation_offset(&self) -> &super::core::Vec3;
    fn half_extents(&self) -> &super::core::Vec3;
    fn create_avoidance_for_other_detectors(&self) -> &bool;
    fn toggle_sprint_threshold(&self) -> &f32;
    fn jump_cooldown(&self) -> &f32;
    fn min_jump_velocity(&self) -> &f32;
    fn min_medium_jump_velocity(&self) -> &f32;
    fn min_high_jump_velocity(&self) -> &f32;
    fn high_jump_height(&self) -> &f32;
    fn medium_jump_height(&self) -> &f32;
    fn low_jump_height(&self) -> &f32;
    fn min_jump_height(&self) -> &f32;
    fn reject_water_depth(&self) -> &f32;
    fn collision_layer(&self) -> &super::physics::RigidBodyCollisionLayer;
    fn throttle_input(&self) -> &i32;
    fn brake_input(&self) -> &i32;
    fn brake_in_air_input(&self) -> &i32;
    fn steer_input(&self) -> &i32;
    fn jump_input(&self) -> &i32;
    fn sprint_input(&self) -> &i32;
}

impl ObstacleDetectionEntityDataTrait for ObstacleDetectionEntityData {
    fn toggle_sprint(&self) -> &bool {
        &self.toggle_sprint
    }
    fn true_toggle_sprint(&self) -> &bool {
        &self.true_toggle_sprint
    }
    fn remove_sprint(&self) -> &bool {
        &self.remove_sprint
    }
    fn allow_jumping(&self) -> &bool {
        &self.allow_jumping
    }
    fn max_yaw_speed(&self) -> &f32 {
        &self.max_yaw_speed
    }
    fn max_jump_height(&self) -> &f32 {
        &self.max_jump_height
    }
    fn translation_offset(&self) -> &super::core::Vec3 {
        &self.translation_offset
    }
    fn half_extents(&self) -> &super::core::Vec3 {
        &self.half_extents
    }
    fn create_avoidance_for_other_detectors(&self) -> &bool {
        &self.create_avoidance_for_other_detectors
    }
    fn toggle_sprint_threshold(&self) -> &f32 {
        &self.toggle_sprint_threshold
    }
    fn jump_cooldown(&self) -> &f32 {
        &self.jump_cooldown
    }
    fn min_jump_velocity(&self) -> &f32 {
        &self.min_jump_velocity
    }
    fn min_medium_jump_velocity(&self) -> &f32 {
        &self.min_medium_jump_velocity
    }
    fn min_high_jump_velocity(&self) -> &f32 {
        &self.min_high_jump_velocity
    }
    fn high_jump_height(&self) -> &f32 {
        &self.high_jump_height
    }
    fn medium_jump_height(&self) -> &f32 {
        &self.medium_jump_height
    }
    fn low_jump_height(&self) -> &f32 {
        &self.low_jump_height
    }
    fn min_jump_height(&self) -> &f32 {
        &self.min_jump_height
    }
    fn reject_water_depth(&self) -> &f32 {
        &self.reject_water_depth
    }
    fn collision_layer(&self) -> &super::physics::RigidBodyCollisionLayer {
        &self.collision_layer
    }
    fn throttle_input(&self) -> &i32 {
        &self.throttle_input
    }
    fn brake_input(&self) -> &i32 {
        &self.brake_input
    }
    fn brake_in_air_input(&self) -> &i32 {
        &self.brake_in_air_input
    }
    fn steer_input(&self) -> &i32 {
        &self.steer_input
    }
    fn jump_input(&self) -> &i32 {
        &self.jump_input
    }
    fn sprint_input(&self) -> &i32 {
        &self.sprint_input
    }
}

impl super::entity::EntityDataTrait for ObstacleDetectionEntityData {
}

impl super::entity::GameObjectDataTrait for ObstacleDetectionEntityData {
}

impl super::core::DataBusPeerTrait for ObstacleDetectionEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for ObstacleDetectionEntityData {
}

impl super::core::DataContainerTrait for ObstacleDetectionEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static OBSTACLEDETECTIONENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObstacleDetectionEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ObstacleDetectionEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ToggleSprint",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ObstacleDetectionEntityData, toggle_sprint),
            },
            FieldInfoData {
                name: "TrueToggleSprint",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ObstacleDetectionEntityData, true_toggle_sprint),
            },
            FieldInfoData {
                name: "RemoveSprint",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ObstacleDetectionEntityData, remove_sprint),
            },
            FieldInfoData {
                name: "AllowJumping",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ObstacleDetectionEntityData, allow_jumping),
            },
            FieldInfoData {
                name: "MaxYawSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ObstacleDetectionEntityData, max_yaw_speed),
            },
            FieldInfoData {
                name: "MaxJumpHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ObstacleDetectionEntityData, max_jump_height),
            },
            FieldInfoData {
                name: "TranslationOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(ObstacleDetectionEntityData, translation_offset),
            },
            FieldInfoData {
                name: "HalfExtents",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(ObstacleDetectionEntityData, half_extents),
            },
            FieldInfoData {
                name: "CreateAvoidanceForOtherDetectors",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ObstacleDetectionEntityData, create_avoidance_for_other_detectors),
            },
            FieldInfoData {
                name: "ToggleSprintThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ObstacleDetectionEntityData, toggle_sprint_threshold),
            },
            FieldInfoData {
                name: "JumpCooldown",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ObstacleDetectionEntityData, jump_cooldown),
            },
            FieldInfoData {
                name: "MinJumpVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ObstacleDetectionEntityData, min_jump_velocity),
            },
            FieldInfoData {
                name: "MinMediumJumpVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ObstacleDetectionEntityData, min_medium_jump_velocity),
            },
            FieldInfoData {
                name: "MinHighJumpVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ObstacleDetectionEntityData, min_high_jump_velocity),
            },
            FieldInfoData {
                name: "HighJumpHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ObstacleDetectionEntityData, high_jump_height),
            },
            FieldInfoData {
                name: "MediumJumpHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ObstacleDetectionEntityData, medium_jump_height),
            },
            FieldInfoData {
                name: "LowJumpHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ObstacleDetectionEntityData, low_jump_height),
            },
            FieldInfoData {
                name: "MinJumpHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ObstacleDetectionEntityData, min_jump_height),
            },
            FieldInfoData {
                name: "RejectWaterDepth",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ObstacleDetectionEntityData, reject_water_depth),
            },
            FieldInfoData {
                name: "CollisionLayer",
                flags: MemberInfoFlags::new(0),
                field_type: "RigidBodyCollisionLayer",
                rust_offset: offset_of!(ObstacleDetectionEntityData, collision_layer),
            },
            FieldInfoData {
                name: "ThrottleInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ObstacleDetectionEntityData, throttle_input),
            },
            FieldInfoData {
                name: "BrakeInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ObstacleDetectionEntityData, brake_input),
            },
            FieldInfoData {
                name: "BrakeInAirInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ObstacleDetectionEntityData, brake_in_air_input),
            },
            FieldInfoData {
                name: "SteerInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ObstacleDetectionEntityData, steer_input),
            },
            FieldInfoData {
                name: "JumpInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ObstacleDetectionEntityData, jump_input),
            },
            FieldInfoData {
                name: "SprintInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ObstacleDetectionEntityData, sprint_input),
            },
        ],
    }),
    array_type: Some(OBSTACLEDETECTIONENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ObstacleDetectionEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        OBSTACLEDETECTIONENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static OBSTACLEDETECTIONENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObstacleDetectionEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("ObstacleDetectionEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LocalPlayerLODEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub distance: f32,
    pub update_interval: f32,
}

pub trait LocalPlayerLODEntityDataTrait: super::entity::EntityDataTrait {
    fn distance(&self) -> &f32;
    fn update_interval(&self) -> &f32;
}

impl LocalPlayerLODEntityDataTrait for LocalPlayerLODEntityData {
    fn distance(&self) -> &f32 {
        &self.distance
    }
    fn update_interval(&self) -> &f32 {
        &self.update_interval
    }
}

impl super::entity::EntityDataTrait for LocalPlayerLODEntityData {
}

impl super::entity::GameObjectDataTrait for LocalPlayerLODEntityData {
}

impl super::core::DataBusPeerTrait for LocalPlayerLODEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for LocalPlayerLODEntityData {
}

impl super::core::DataContainerTrait for LocalPlayerLODEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static LOCALPLAYERLODENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalPlayerLODEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LocalPlayerLODEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Distance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LocalPlayerLODEntityData, distance),
            },
            FieldInfoData {
                name: "UpdateInterval",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LocalPlayerLODEntityData, update_interval),
            },
        ],
    }),
    array_type: Some(LOCALPLAYERLODENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LocalPlayerLODEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        LOCALPLAYERLODENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static LOCALPLAYERLODENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalPlayerLODEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("LocalPlayerLODEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CameraLODEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub max_test_distance: f32,
    pub update_interval: f32,
}

pub trait CameraLODEntityDataTrait: super::entity::EntityDataTrait {
    fn max_test_distance(&self) -> &f32;
    fn update_interval(&self) -> &f32;
}

impl CameraLODEntityDataTrait for CameraLODEntityData {
    fn max_test_distance(&self) -> &f32 {
        &self.max_test_distance
    }
    fn update_interval(&self) -> &f32 {
        &self.update_interval
    }
}

impl super::entity::EntityDataTrait for CameraLODEntityData {
}

impl super::entity::GameObjectDataTrait for CameraLODEntityData {
}

impl super::core::DataBusPeerTrait for CameraLODEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for CameraLODEntityData {
}

impl super::core::DataContainerTrait for CameraLODEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CAMERALODENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraLODEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraLODEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MaxTestDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraLODEntityData, max_test_distance),
            },
            FieldInfoData {
                name: "UpdateInterval",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraLODEntityData, update_interval),
            },
        ],
    }),
    array_type: Some(CAMERALODENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CameraLODEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERALODENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CAMERALODENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraLODEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CameraLODEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LinearRepulsorLiftPhysicsActionData {
    pub _glacier_base: PhysicsActionBaseData,
    pub ray_origin_local: super::core::Vec3,
    pub ray_count: u32,
    pub ray_forward_reach_min: f32,
    pub ray_forward_reach_max: f32,
    pub ray_forward_reach_speed_for_min: f32,
    pub ray_forward_reach_speed_for_max: f32,
    pub ray_cast_length: f32,
    pub minimum_uprightness_for_raycast_hit: f32,
    pub far_raycast_slope_bias_factor: f32,
    pub dynamic_extra_hover_height: f32,
    pub max_range_for_full_dynamic_hover_height: f32,
    pub max_strafe_raycast_offset: f32,
    pub max_strafe_speed_for_raycast_offset: f32,
    pub average_height_samples: bool,
    pub max_height_bias: f32,
    pub use_body_aligned_raycasts: bool,
    pub target_hover_height: f32,
    pub ground_spring_strength: f32,
    pub ground_spring_damping_coefficient: f32,
    pub slope_based_pitch_spring: f32,
    pub slope_based_pitch_spring_damping_coefficient: f32,
    pub ground_slope_vs_velocity_slope: f32,
    pub velocity_slope_speed: f32,
    pub pitch_input: i32,
    pub resting_pitch_aim_angle: f32,
    pub min_pitch_aim_angle: f32,
    pub max_pitch_aim_angle: f32,
    pub pitch_control_curve: super::core::AudioCurve,
    pub extra_gravity_scale: f32,
    pub always_apply_extra_gravity: bool,
}

pub trait LinearRepulsorLiftPhysicsActionDataTrait: PhysicsActionBaseDataTrait {
    fn ray_origin_local(&self) -> &super::core::Vec3;
    fn ray_count(&self) -> &u32;
    fn ray_forward_reach_min(&self) -> &f32;
    fn ray_forward_reach_max(&self) -> &f32;
    fn ray_forward_reach_speed_for_min(&self) -> &f32;
    fn ray_forward_reach_speed_for_max(&self) -> &f32;
    fn ray_cast_length(&self) -> &f32;
    fn minimum_uprightness_for_raycast_hit(&self) -> &f32;
    fn far_raycast_slope_bias_factor(&self) -> &f32;
    fn dynamic_extra_hover_height(&self) -> &f32;
    fn max_range_for_full_dynamic_hover_height(&self) -> &f32;
    fn max_strafe_raycast_offset(&self) -> &f32;
    fn max_strafe_speed_for_raycast_offset(&self) -> &f32;
    fn average_height_samples(&self) -> &bool;
    fn max_height_bias(&self) -> &f32;
    fn use_body_aligned_raycasts(&self) -> &bool;
    fn target_hover_height(&self) -> &f32;
    fn ground_spring_strength(&self) -> &f32;
    fn ground_spring_damping_coefficient(&self) -> &f32;
    fn slope_based_pitch_spring(&self) -> &f32;
    fn slope_based_pitch_spring_damping_coefficient(&self) -> &f32;
    fn ground_slope_vs_velocity_slope(&self) -> &f32;
    fn velocity_slope_speed(&self) -> &f32;
    fn pitch_input(&self) -> &i32;
    fn resting_pitch_aim_angle(&self) -> &f32;
    fn min_pitch_aim_angle(&self) -> &f32;
    fn max_pitch_aim_angle(&self) -> &f32;
    fn pitch_control_curve(&self) -> &super::core::AudioCurve;
    fn extra_gravity_scale(&self) -> &f32;
    fn always_apply_extra_gravity(&self) -> &bool;
}

impl LinearRepulsorLiftPhysicsActionDataTrait for LinearRepulsorLiftPhysicsActionData {
    fn ray_origin_local(&self) -> &super::core::Vec3 {
        &self.ray_origin_local
    }
    fn ray_count(&self) -> &u32 {
        &self.ray_count
    }
    fn ray_forward_reach_min(&self) -> &f32 {
        &self.ray_forward_reach_min
    }
    fn ray_forward_reach_max(&self) -> &f32 {
        &self.ray_forward_reach_max
    }
    fn ray_forward_reach_speed_for_min(&self) -> &f32 {
        &self.ray_forward_reach_speed_for_min
    }
    fn ray_forward_reach_speed_for_max(&self) -> &f32 {
        &self.ray_forward_reach_speed_for_max
    }
    fn ray_cast_length(&self) -> &f32 {
        &self.ray_cast_length
    }
    fn minimum_uprightness_for_raycast_hit(&self) -> &f32 {
        &self.minimum_uprightness_for_raycast_hit
    }
    fn far_raycast_slope_bias_factor(&self) -> &f32 {
        &self.far_raycast_slope_bias_factor
    }
    fn dynamic_extra_hover_height(&self) -> &f32 {
        &self.dynamic_extra_hover_height
    }
    fn max_range_for_full_dynamic_hover_height(&self) -> &f32 {
        &self.max_range_for_full_dynamic_hover_height
    }
    fn max_strafe_raycast_offset(&self) -> &f32 {
        &self.max_strafe_raycast_offset
    }
    fn max_strafe_speed_for_raycast_offset(&self) -> &f32 {
        &self.max_strafe_speed_for_raycast_offset
    }
    fn average_height_samples(&self) -> &bool {
        &self.average_height_samples
    }
    fn max_height_bias(&self) -> &f32 {
        &self.max_height_bias
    }
    fn use_body_aligned_raycasts(&self) -> &bool {
        &self.use_body_aligned_raycasts
    }
    fn target_hover_height(&self) -> &f32 {
        &self.target_hover_height
    }
    fn ground_spring_strength(&self) -> &f32 {
        &self.ground_spring_strength
    }
    fn ground_spring_damping_coefficient(&self) -> &f32 {
        &self.ground_spring_damping_coefficient
    }
    fn slope_based_pitch_spring(&self) -> &f32 {
        &self.slope_based_pitch_spring
    }
    fn slope_based_pitch_spring_damping_coefficient(&self) -> &f32 {
        &self.slope_based_pitch_spring_damping_coefficient
    }
    fn ground_slope_vs_velocity_slope(&self) -> &f32 {
        &self.ground_slope_vs_velocity_slope
    }
    fn velocity_slope_speed(&self) -> &f32 {
        &self.velocity_slope_speed
    }
    fn pitch_input(&self) -> &i32 {
        &self.pitch_input
    }
    fn resting_pitch_aim_angle(&self) -> &f32 {
        &self.resting_pitch_aim_angle
    }
    fn min_pitch_aim_angle(&self) -> &f32 {
        &self.min_pitch_aim_angle
    }
    fn max_pitch_aim_angle(&self) -> &f32 {
        &self.max_pitch_aim_angle
    }
    fn pitch_control_curve(&self) -> &super::core::AudioCurve {
        &self.pitch_control_curve
    }
    fn extra_gravity_scale(&self) -> &f32 {
        &self.extra_gravity_scale
    }
    fn always_apply_extra_gravity(&self) -> &bool {
        &self.always_apply_extra_gravity
    }
}

impl PhysicsActionBaseDataTrait for LinearRepulsorLiftPhysicsActionData {
    fn blend_factor(&self) -> &f32 {
        self._glacier_base.blend_factor()
    }
    fn input_blend_factor(&self) -> &f32 {
        self._glacier_base.input_blend_factor()
    }
    fn clamp_lin_acc(&self) -> &f32 {
        self._glacier_base.clamp_lin_acc()
    }
    fn clamp_ang_acc(&self) -> &f32 {
        self._glacier_base.clamp_ang_acc()
    }
    fn blend_factor_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.blend_factor_curve()
    }
    fn collision_response_curve(&self) -> &super::core::AudioCurve {
        self._glacier_base.collision_response_curve()
    }
}

impl super::entity::EntityDataTrait for LinearRepulsorLiftPhysicsActionData {
}

impl super::entity::GameObjectDataTrait for LinearRepulsorLiftPhysicsActionData {
}

impl super::core::DataBusPeerTrait for LinearRepulsorLiftPhysicsActionData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for LinearRepulsorLiftPhysicsActionData {
}

impl super::core::DataContainerTrait for LinearRepulsorLiftPhysicsActionData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static LINEARREPULSORLIFTPHYSICSACTIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinearRepulsorLiftPhysicsActionData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PHYSICSACTIONBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LinearRepulsorLiftPhysicsActionData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "RayOriginLocal",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(LinearRepulsorLiftPhysicsActionData, ray_origin_local),
            },
            FieldInfoData {
                name: "RayCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(LinearRepulsorLiftPhysicsActionData, ray_count),
            },
            FieldInfoData {
                name: "RayForwardReachMin",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LinearRepulsorLiftPhysicsActionData, ray_forward_reach_min),
            },
            FieldInfoData {
                name: "RayForwardReachMax",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LinearRepulsorLiftPhysicsActionData, ray_forward_reach_max),
            },
            FieldInfoData {
                name: "RayForwardReachSpeedForMin",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LinearRepulsorLiftPhysicsActionData, ray_forward_reach_speed_for_min),
            },
            FieldInfoData {
                name: "RayForwardReachSpeedForMax",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LinearRepulsorLiftPhysicsActionData, ray_forward_reach_speed_for_max),
            },
            FieldInfoData {
                name: "RayCastLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LinearRepulsorLiftPhysicsActionData, ray_cast_length),
            },
            FieldInfoData {
                name: "MinimumUprightnessForRaycastHit",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LinearRepulsorLiftPhysicsActionData, minimum_uprightness_for_raycast_hit),
            },
            FieldInfoData {
                name: "FarRaycastSlopeBiasFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LinearRepulsorLiftPhysicsActionData, far_raycast_slope_bias_factor),
            },
            FieldInfoData {
                name: "DynamicExtraHoverHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LinearRepulsorLiftPhysicsActionData, dynamic_extra_hover_height),
            },
            FieldInfoData {
                name: "MaxRangeForFullDynamicHoverHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LinearRepulsorLiftPhysicsActionData, max_range_for_full_dynamic_hover_height),
            },
            FieldInfoData {
                name: "MaxStrafeRaycastOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LinearRepulsorLiftPhysicsActionData, max_strafe_raycast_offset),
            },
            FieldInfoData {
                name: "MaxStrafeSpeedForRaycastOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LinearRepulsorLiftPhysicsActionData, max_strafe_speed_for_raycast_offset),
            },
            FieldInfoData {
                name: "AverageHeightSamples",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LinearRepulsorLiftPhysicsActionData, average_height_samples),
            },
            FieldInfoData {
                name: "MaxHeightBias",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LinearRepulsorLiftPhysicsActionData, max_height_bias),
            },
            FieldInfoData {
                name: "UseBodyAlignedRaycasts",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LinearRepulsorLiftPhysicsActionData, use_body_aligned_raycasts),
            },
            FieldInfoData {
                name: "TargetHoverHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LinearRepulsorLiftPhysicsActionData, target_hover_height),
            },
            FieldInfoData {
                name: "GroundSpringStrength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LinearRepulsorLiftPhysicsActionData, ground_spring_strength),
            },
            FieldInfoData {
                name: "GroundSpringDampingCoefficient",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LinearRepulsorLiftPhysicsActionData, ground_spring_damping_coefficient),
            },
            FieldInfoData {
                name: "SlopeBasedPitchSpring",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LinearRepulsorLiftPhysicsActionData, slope_based_pitch_spring),
            },
            FieldInfoData {
                name: "SlopeBasedPitchSpringDampingCoefficient",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LinearRepulsorLiftPhysicsActionData, slope_based_pitch_spring_damping_coefficient),
            },
            FieldInfoData {
                name: "GroundSlopeVsVelocitySlope",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LinearRepulsorLiftPhysicsActionData, ground_slope_vs_velocity_slope),
            },
            FieldInfoData {
                name: "VelocitySlopeSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LinearRepulsorLiftPhysicsActionData, velocity_slope_speed),
            },
            FieldInfoData {
                name: "PitchInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(LinearRepulsorLiftPhysicsActionData, pitch_input),
            },
            FieldInfoData {
                name: "RestingPitchAimAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LinearRepulsorLiftPhysicsActionData, resting_pitch_aim_angle),
            },
            FieldInfoData {
                name: "MinPitchAimAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LinearRepulsorLiftPhysicsActionData, min_pitch_aim_angle),
            },
            FieldInfoData {
                name: "MaxPitchAimAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LinearRepulsorLiftPhysicsActionData, max_pitch_aim_angle),
            },
            FieldInfoData {
                name: "PitchControlCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioCurve",
                rust_offset: offset_of!(LinearRepulsorLiftPhysicsActionData, pitch_control_curve),
            },
            FieldInfoData {
                name: "ExtraGravityScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LinearRepulsorLiftPhysicsActionData, extra_gravity_scale),
            },
            FieldInfoData {
                name: "AlwaysApplyExtraGravity",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LinearRepulsorLiftPhysicsActionData, always_apply_extra_gravity),
            },
        ],
    }),
    array_type: Some(LINEARREPULSORLIFTPHYSICSACTIONDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for LinearRepulsorLiftPhysicsActionData {
    fn type_info(&self) -> &'static TypeInfo {
        LINEARREPULSORLIFTPHYSICSACTIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static LINEARREPULSORLIFTPHYSICSACTIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinearRepulsorLiftPhysicsActionData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("LinearRepulsorLiftPhysicsActionData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct IsLookedAtTargetOverrideEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub enabled: bool,
    pub local_player_id: super::core::LocalPlayerId,
    pub transform: super::core::LinearTransform,
}

pub trait IsLookedAtTargetOverrideEntityDataTrait: super::entity::EntityDataTrait {
    fn enabled(&self) -> &bool;
    fn local_player_id(&self) -> &super::core::LocalPlayerId;
    fn transform(&self) -> &super::core::LinearTransform;
}

impl IsLookedAtTargetOverrideEntityDataTrait for IsLookedAtTargetOverrideEntityData {
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn local_player_id(&self) -> &super::core::LocalPlayerId {
        &self.local_player_id
    }
    fn transform(&self) -> &super::core::LinearTransform {
        &self.transform
    }
}

impl super::entity::EntityDataTrait for IsLookedAtTargetOverrideEntityData {
}

impl super::entity::GameObjectDataTrait for IsLookedAtTargetOverrideEntityData {
}

impl super::core::DataBusPeerTrait for IsLookedAtTargetOverrideEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for IsLookedAtTargetOverrideEntityData {
}

impl super::core::DataContainerTrait for IsLookedAtTargetOverrideEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static ISLOOKEDATTARGETOVERRIDEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IsLookedAtTargetOverrideEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<IsLookedAtTargetOverrideEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(IsLookedAtTargetOverrideEntityData, enabled),
            },
            FieldInfoData {
                name: "LocalPlayerId",
                flags: MemberInfoFlags::new(0),
                field_type: "LocalPlayerId",
                rust_offset: offset_of!(IsLookedAtTargetOverrideEntityData, local_player_id),
            },
            FieldInfoData {
                name: "Transform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(IsLookedAtTargetOverrideEntityData, transform),
            },
        ],
    }),
    array_type: Some(ISLOOKEDATTARGETOVERRIDEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for IsLookedAtTargetOverrideEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        ISLOOKEDATTARGETOVERRIDEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ISLOOKEDATTARGETOVERRIDEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IsLookedAtTargetOverrideEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("IsLookedAtTargetOverrideEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct IsLookedAtEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub entity_type: Option<Arc<Mutex<dyn super::dice_commons_shared::EntityTransformLinkDataTrait>>>,
    pub exclusive: bool,
    pub blocking: bool,
    pub enabled: bool,
    pub sphere_radius: f32,
    pub capsule_height: f32,
}

pub trait IsLookedAtEntityDataTrait: super::entity::EntityDataTrait {
    fn entity_type(&self) -> &Option<Arc<Mutex<dyn super::dice_commons_shared::EntityTransformLinkDataTrait>>>;
    fn exclusive(&self) -> &bool;
    fn blocking(&self) -> &bool;
    fn enabled(&self) -> &bool;
    fn sphere_radius(&self) -> &f32;
    fn capsule_height(&self) -> &f32;
}

impl IsLookedAtEntityDataTrait for IsLookedAtEntityData {
    fn entity_type(&self) -> &Option<Arc<Mutex<dyn super::dice_commons_shared::EntityTransformLinkDataTrait>>> {
        &self.entity_type
    }
    fn exclusive(&self) -> &bool {
        &self.exclusive
    }
    fn blocking(&self) -> &bool {
        &self.blocking
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn sphere_radius(&self) -> &f32 {
        &self.sphere_radius
    }
    fn capsule_height(&self) -> &f32 {
        &self.capsule_height
    }
}

impl super::entity::EntityDataTrait for IsLookedAtEntityData {
}

impl super::entity::GameObjectDataTrait for IsLookedAtEntityData {
}

impl super::core::DataBusPeerTrait for IsLookedAtEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for IsLookedAtEntityData {
}

impl super::core::DataContainerTrait for IsLookedAtEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static ISLOOKEDATENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IsLookedAtEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<IsLookedAtEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "EntityType",
                flags: MemberInfoFlags::new(0),
                field_type: "EntityTransformLinkData",
                rust_offset: offset_of!(IsLookedAtEntityData, entity_type),
            },
            FieldInfoData {
                name: "Exclusive",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(IsLookedAtEntityData, exclusive),
            },
            FieldInfoData {
                name: "Blocking",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(IsLookedAtEntityData, blocking),
            },
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(IsLookedAtEntityData, enabled),
            },
            FieldInfoData {
                name: "SphereRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(IsLookedAtEntityData, sphere_radius),
            },
            FieldInfoData {
                name: "CapsuleHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(IsLookedAtEntityData, capsule_height),
            },
        ],
    }),
    array_type: Some(ISLOOKEDATENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for IsLookedAtEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        ISLOOKEDATENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ISLOOKEDATENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IsLookedAtEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("IsLookedAtEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateCameraRelativeSteeringControllerData {
    pub _glacier_base: CharacterStateBaseControllerData,
    pub ant_controller: super::ant::AntRef,
    pub up_hill_modification: HillModification,
    pub down_hill_modification: HillModification,
    pub velocity: f32,
    pub speed_input: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub sprint_top_speed_multiplier: f32,
    pub sprint_top_speed_multiplier_input: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub gain: f32,
    pub gain_curve: super::core::AudioCurve,
    pub gain_drift_factor: f32,
    pub sprint_gain: f32,
    pub sprint_gain_curve: super::core::AudioCurve,
    pub stop_gain: f32,
    pub stop_gain_curve: super::core::AudioCurve,
    pub sprinting_input: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub allow_strafing: bool,
    pub strafe_scale: f32,
    pub throttle_input: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub constant_throttle_input: f32,
    pub strafe_input: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub constant_strafe_input: f32,
    pub normal_channel: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub position_channel: Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>,
    pub velocity_channel: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub acceleration_channel: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
}

pub trait CharacterStateCameraRelativeSteeringControllerDataTrait: CharacterStateBaseControllerDataTrait {
    fn ant_controller(&self) -> &super::ant::AntRef;
    fn up_hill_modification(&self) -> &HillModification;
    fn down_hill_modification(&self) -> &HillModification;
    fn velocity(&self) -> &f32;
    fn speed_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn sprint_top_speed_multiplier(&self) -> &f32;
    fn sprint_top_speed_multiplier_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn gain(&self) -> &f32;
    fn gain_curve(&self) -> &super::core::AudioCurve;
    fn gain_drift_factor(&self) -> &f32;
    fn sprint_gain(&self) -> &f32;
    fn sprint_gain_curve(&self) -> &super::core::AudioCurve;
    fn stop_gain(&self) -> &f32;
    fn stop_gain_curve(&self) -> &super::core::AudioCurve;
    fn sprinting_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn allow_strafing(&self) -> &bool;
    fn strafe_scale(&self) -> &f32;
    fn throttle_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn constant_throttle_input(&self) -> &f32;
    fn strafe_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn constant_strafe_input(&self) -> &f32;
    fn normal_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn position_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>;
    fn velocity_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn acceleration_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
}

impl CharacterStateCameraRelativeSteeringControllerDataTrait for CharacterStateCameraRelativeSteeringControllerData {
    fn ant_controller(&self) -> &super::ant::AntRef {
        &self.ant_controller
    }
    fn up_hill_modification(&self) -> &HillModification {
        &self.up_hill_modification
    }
    fn down_hill_modification(&self) -> &HillModification {
        &self.down_hill_modification
    }
    fn velocity(&self) -> &f32 {
        &self.velocity
    }
    fn speed_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.speed_input
    }
    fn sprint_top_speed_multiplier(&self) -> &f32 {
        &self.sprint_top_speed_multiplier
    }
    fn sprint_top_speed_multiplier_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.sprint_top_speed_multiplier_input
    }
    fn gain(&self) -> &f32 {
        &self.gain
    }
    fn gain_curve(&self) -> &super::core::AudioCurve {
        &self.gain_curve
    }
    fn gain_drift_factor(&self) -> &f32 {
        &self.gain_drift_factor
    }
    fn sprint_gain(&self) -> &f32 {
        &self.sprint_gain
    }
    fn sprint_gain_curve(&self) -> &super::core::AudioCurve {
        &self.sprint_gain_curve
    }
    fn stop_gain(&self) -> &f32 {
        &self.stop_gain
    }
    fn stop_gain_curve(&self) -> &super::core::AudioCurve {
        &self.stop_gain_curve
    }
    fn sprinting_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.sprinting_input
    }
    fn allow_strafing(&self) -> &bool {
        &self.allow_strafing
    }
    fn strafe_scale(&self) -> &f32 {
        &self.strafe_scale
    }
    fn throttle_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.throttle_input
    }
    fn constant_throttle_input(&self) -> &f32 {
        &self.constant_throttle_input
    }
    fn strafe_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.strafe_input
    }
    fn constant_strafe_input(&self) -> &f32 {
        &self.constant_strafe_input
    }
    fn normal_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.normal_channel
    }
    fn position_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>> {
        &self.position_channel
    }
    fn velocity_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.velocity_channel
    }
    fn acceleration_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.acceleration_channel
    }
}

impl CharacterStateBaseControllerDataTrait for CharacterStateCameraRelativeSteeringControllerData {
    fn asset_index(&self) -> &i32 {
        self._glacier_base.asset_index()
    }
    fn subjects(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>> {
        self._glacier_base.subjects()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for CharacterStateCameraRelativeSteeringControllerData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATECAMERARELATIVESTEERINGCONTROLLERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateCameraRelativeSteeringControllerData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEBASECONTROLLERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateCameraRelativeSteeringControllerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AntController",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CharacterStateCameraRelativeSteeringControllerData, ant_controller),
            },
            FieldInfoData {
                name: "UpHillModification",
                flags: MemberInfoFlags::new(0),
                field_type: "HillModification",
                rust_offset: offset_of!(CharacterStateCameraRelativeSteeringControllerData, up_hill_modification),
            },
            FieldInfoData {
                name: "DownHillModification",
                flags: MemberInfoFlags::new(0),
                field_type: "HillModification",
                rust_offset: offset_of!(CharacterStateCameraRelativeSteeringControllerData, down_hill_modification),
            },
            FieldInfoData {
                name: "Velocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateCameraRelativeSteeringControllerData, velocity),
            },
            FieldInfoData {
                name: "SpeedInput",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateCameraRelativeSteeringControllerData, speed_input),
            },
            FieldInfoData {
                name: "SprintTopSpeedMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateCameraRelativeSteeringControllerData, sprint_top_speed_multiplier),
            },
            FieldInfoData {
                name: "SprintTopSpeedMultiplierInput",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateCameraRelativeSteeringControllerData, sprint_top_speed_multiplier_input),
            },
            FieldInfoData {
                name: "Gain",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateCameraRelativeSteeringControllerData, gain),
            },
            FieldInfoData {
                name: "GainCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioCurve",
                rust_offset: offset_of!(CharacterStateCameraRelativeSteeringControllerData, gain_curve),
            },
            FieldInfoData {
                name: "GainDriftFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateCameraRelativeSteeringControllerData, gain_drift_factor),
            },
            FieldInfoData {
                name: "SprintGain",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateCameraRelativeSteeringControllerData, sprint_gain),
            },
            FieldInfoData {
                name: "SprintGainCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioCurve",
                rust_offset: offset_of!(CharacterStateCameraRelativeSteeringControllerData, sprint_gain_curve),
            },
            FieldInfoData {
                name: "StopGain",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateCameraRelativeSteeringControllerData, stop_gain),
            },
            FieldInfoData {
                name: "StopGainCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioCurve",
                rust_offset: offset_of!(CharacterStateCameraRelativeSteeringControllerData, stop_gain_curve),
            },
            FieldInfoData {
                name: "SprintingInput",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(CharacterStateCameraRelativeSteeringControllerData, sprinting_input),
            },
            FieldInfoData {
                name: "AllowStrafing",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateCameraRelativeSteeringControllerData, allow_strafing),
            },
            FieldInfoData {
                name: "StrafeScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateCameraRelativeSteeringControllerData, strafe_scale),
            },
            FieldInfoData {
                name: "ThrottleInput",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateCameraRelativeSteeringControllerData, throttle_input),
            },
            FieldInfoData {
                name: "ConstantThrottleInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateCameraRelativeSteeringControllerData, constant_throttle_input),
            },
            FieldInfoData {
                name: "StrafeInput",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateCameraRelativeSteeringControllerData, strafe_input),
            },
            FieldInfoData {
                name: "ConstantStrafeInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateCameraRelativeSteeringControllerData, constant_strafe_input),
            },
            FieldInfoData {
                name: "NormalChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateCameraRelativeSteeringControllerData, normal_channel),
            },
            FieldInfoData {
                name: "PositionChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(CharacterStateCameraRelativeSteeringControllerData, position_channel),
            },
            FieldInfoData {
                name: "VelocityChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateCameraRelativeSteeringControllerData, velocity_channel),
            },
            FieldInfoData {
                name: "AccelerationChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateCameraRelativeSteeringControllerData, acceleration_channel),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATECAMERARELATIVESTEERINGCONTROLLERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateCameraRelativeSteeringControllerData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATECAMERARELATIVESTEERINGCONTROLLERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATECAMERARELATIVESTEERINGCONTROLLERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateCameraRelativeSteeringControllerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateCameraRelativeSteeringControllerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateRotateWithYawControllerData {
    pub _glacier_base: CharacterStateBaseControllerData,
    pub rotation_speed: f32,
    pub delta_yaw_speed_scale: f32,
    pub yaw: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub yaw_rotation_scale: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub delta_yaw: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub current_transform: Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>,
    pub angular_velocity: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub ant_controller: super::ant::AntRef,
}

pub trait CharacterStateRotateWithYawControllerDataTrait: CharacterStateBaseControllerDataTrait {
    fn rotation_speed(&self) -> &f32;
    fn delta_yaw_speed_scale(&self) -> &f32;
    fn yaw(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn yaw_rotation_scale(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn delta_yaw(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn current_transform(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>;
    fn angular_velocity(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn ant_controller(&self) -> &super::ant::AntRef;
}

impl CharacterStateRotateWithYawControllerDataTrait for CharacterStateRotateWithYawControllerData {
    fn rotation_speed(&self) -> &f32 {
        &self.rotation_speed
    }
    fn delta_yaw_speed_scale(&self) -> &f32 {
        &self.delta_yaw_speed_scale
    }
    fn yaw(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.yaw
    }
    fn yaw_rotation_scale(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.yaw_rotation_scale
    }
    fn delta_yaw(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.delta_yaw
    }
    fn current_transform(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>> {
        &self.current_transform
    }
    fn angular_velocity(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.angular_velocity
    }
    fn ant_controller(&self) -> &super::ant::AntRef {
        &self.ant_controller
    }
}

impl CharacterStateBaseControllerDataTrait for CharacterStateRotateWithYawControllerData {
    fn asset_index(&self) -> &i32 {
        self._glacier_base.asset_index()
    }
    fn subjects(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>> {
        self._glacier_base.subjects()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for CharacterStateRotateWithYawControllerData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATEROTATEWITHYAWCONTROLLERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateRotateWithYawControllerData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEBASECONTROLLERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateRotateWithYawControllerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "RotationSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateRotateWithYawControllerData, rotation_speed),
            },
            FieldInfoData {
                name: "DeltaYawSpeedScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateRotateWithYawControllerData, delta_yaw_speed_scale),
            },
            FieldInfoData {
                name: "Yaw",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateRotateWithYawControllerData, yaw),
            },
            FieldInfoData {
                name: "YawRotationScale",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateRotateWithYawControllerData, yaw_rotation_scale),
            },
            FieldInfoData {
                name: "DeltaYaw",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateRotateWithYawControllerData, delta_yaw),
            },
            FieldInfoData {
                name: "CurrentTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(CharacterStateRotateWithYawControllerData, current_transform),
            },
            FieldInfoData {
                name: "AngularVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateRotateWithYawControllerData, angular_velocity),
            },
            FieldInfoData {
                name: "AntController",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CharacterStateRotateWithYawControllerData, ant_controller),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEROTATEWITHYAWCONTROLLERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateRotateWithYawControllerData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEROTATEWITHYAWCONTROLLERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEROTATEWITHYAWCONTROLLERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateRotateWithYawControllerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateRotateWithYawControllerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateAdjustToGroundControllerData {
    pub _glacier_base: CharacterStateBaseControllerData,
    pub adjust_to_ground_mode: AdjustToGroundModeEnum,
    pub rot_fade_range: super::core::Vec2,
    pub rot_smooth_time: super::core::Vec2,
    pub ground_normal: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub current_transform: Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>,
    pub angular_velocity: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub ant_controller: super::ant::AntRef,
}

pub trait CharacterStateAdjustToGroundControllerDataTrait: CharacterStateBaseControllerDataTrait {
    fn adjust_to_ground_mode(&self) -> &AdjustToGroundModeEnum;
    fn rot_fade_range(&self) -> &super::core::Vec2;
    fn rot_smooth_time(&self) -> &super::core::Vec2;
    fn ground_normal(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn current_transform(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>;
    fn angular_velocity(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn ant_controller(&self) -> &super::ant::AntRef;
}

impl CharacterStateAdjustToGroundControllerDataTrait for CharacterStateAdjustToGroundControllerData {
    fn adjust_to_ground_mode(&self) -> &AdjustToGroundModeEnum {
        &self.adjust_to_ground_mode
    }
    fn rot_fade_range(&self) -> &super::core::Vec2 {
        &self.rot_fade_range
    }
    fn rot_smooth_time(&self) -> &super::core::Vec2 {
        &self.rot_smooth_time
    }
    fn ground_normal(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.ground_normal
    }
    fn current_transform(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>> {
        &self.current_transform
    }
    fn angular_velocity(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.angular_velocity
    }
    fn ant_controller(&self) -> &super::ant::AntRef {
        &self.ant_controller
    }
}

impl CharacterStateBaseControllerDataTrait for CharacterStateAdjustToGroundControllerData {
    fn asset_index(&self) -> &i32 {
        self._glacier_base.asset_index()
    }
    fn subjects(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>> {
        self._glacier_base.subjects()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for CharacterStateAdjustToGroundControllerData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATEADJUSTTOGROUNDCONTROLLERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateAdjustToGroundControllerData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEBASECONTROLLERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateAdjustToGroundControllerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AdjustToGroundMode",
                flags: MemberInfoFlags::new(0),
                field_type: "AdjustToGroundModeEnum",
                rust_offset: offset_of!(CharacterStateAdjustToGroundControllerData, adjust_to_ground_mode),
            },
            FieldInfoData {
                name: "RotFadeRange",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(CharacterStateAdjustToGroundControllerData, rot_fade_range),
            },
            FieldInfoData {
                name: "RotSmoothTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(CharacterStateAdjustToGroundControllerData, rot_smooth_time),
            },
            FieldInfoData {
                name: "GroundNormal",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateAdjustToGroundControllerData, ground_normal),
            },
            FieldInfoData {
                name: "CurrentTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(CharacterStateAdjustToGroundControllerData, current_transform),
            },
            FieldInfoData {
                name: "AngularVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateAdjustToGroundControllerData, angular_velocity),
            },
            FieldInfoData {
                name: "AntController",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CharacterStateAdjustToGroundControllerData, ant_controller),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEADJUSTTOGROUNDCONTROLLERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateAdjustToGroundControllerData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEADJUSTTOGROUNDCONTROLLERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEADJUSTTOGROUNDCONTROLLERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateAdjustToGroundControllerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateAdjustToGroundControllerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum AdjustToGroundModeEnum {
    #[default]
    AdjustToGroundMode_StayUpright = 0,
    AdjustToGroundMode_FollowSurfaceNormal = 1,
}

pub static ADJUSTTOGROUNDMODEENUM_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AdjustToGroundModeEnum",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(ADJUSTTOGROUNDMODEENUM_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AdjustToGroundModeEnum {
    fn type_info(&self) -> &'static TypeInfo {
        ADJUSTTOGROUNDMODEENUM_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ADJUSTTOGROUNDMODEENUM_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AdjustToGroundModeEnum-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("AdjustToGroundModeEnum"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateJetpackControllerData {
    pub _glacier_base: AirControlCapableControllerData,
    pub min_active_time: f32,
    pub max_active_time: f32,
    pub minimum_time_before_land: f32,
    pub target_velocity_x_z_when_landing: f32,
    pub brake_thrust_y: f32,
    pub brake_thrust_x_z: f32,
    pub target_velocity_x_z_when_flying: f32,
    pub target_velocity_y_when_flying: f32,
    pub max_height_over_ground: f32,
    pub character_transform: Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>,
    pub current_velocity: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub thrust_input: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub throttle_input: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub strafe_input: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub is_on_ground: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub distance_from_ground: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub jetpack_active: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub jetpack_finished: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub jetpack_state_channel: Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>,
    pub height_limit_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
}

pub trait CharacterStateJetpackControllerDataTrait: AirControlCapableControllerDataTrait {
    fn min_active_time(&self) -> &f32;
    fn max_active_time(&self) -> &f32;
    fn minimum_time_before_land(&self) -> &f32;
    fn target_velocity_x_z_when_landing(&self) -> &f32;
    fn brake_thrust_y(&self) -> &f32;
    fn brake_thrust_x_z(&self) -> &f32;
    fn target_velocity_x_z_when_flying(&self) -> &f32;
    fn target_velocity_y_when_flying(&self) -> &f32;
    fn max_height_over_ground(&self) -> &f32;
    fn character_transform(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>;
    fn current_velocity(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn thrust_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn throttle_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn strafe_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn is_on_ground(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn distance_from_ground(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn jetpack_active(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn jetpack_finished(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn jetpack_state_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>;
    fn height_limit_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
}

impl CharacterStateJetpackControllerDataTrait for CharacterStateJetpackControllerData {
    fn min_active_time(&self) -> &f32 {
        &self.min_active_time
    }
    fn max_active_time(&self) -> &f32 {
        &self.max_active_time
    }
    fn minimum_time_before_land(&self) -> &f32 {
        &self.minimum_time_before_land
    }
    fn target_velocity_x_z_when_landing(&self) -> &f32 {
        &self.target_velocity_x_z_when_landing
    }
    fn brake_thrust_y(&self) -> &f32 {
        &self.brake_thrust_y
    }
    fn brake_thrust_x_z(&self) -> &f32 {
        &self.brake_thrust_x_z
    }
    fn target_velocity_x_z_when_flying(&self) -> &f32 {
        &self.target_velocity_x_z_when_flying
    }
    fn target_velocity_y_when_flying(&self) -> &f32 {
        &self.target_velocity_y_when_flying
    }
    fn max_height_over_ground(&self) -> &f32 {
        &self.max_height_over_ground
    }
    fn character_transform(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>> {
        &self.character_transform
    }
    fn current_velocity(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.current_velocity
    }
    fn thrust_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.thrust_input
    }
    fn throttle_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.throttle_input
    }
    fn strafe_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.strafe_input
    }
    fn is_on_ground(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.is_on_ground
    }
    fn distance_from_ground(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.distance_from_ground
    }
    fn jetpack_active(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.jetpack_active
    }
    fn jetpack_finished(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.jetpack_finished
    }
    fn jetpack_state_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>> {
        &self.jetpack_state_channel
    }
    fn height_limit_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.height_limit_channel
    }
}

impl AirControlCapableControllerDataTrait for CharacterStateJetpackControllerData {
    fn forward_thrust(&self) -> &f32 {
        self._glacier_base.forward_thrust()
    }
    fn up_thrust(&self) -> &f32 {
        self._glacier_base.up_thrust()
    }
    fn extra_up_thrust_from_falling(&self) -> &f32 {
        self._glacier_base.extra_up_thrust_from_falling()
    }
    fn air_control_modifier_forward(&self) -> &f32 {
        self._glacier_base.air_control_modifier_forward()
    }
    fn air_control_modifier_backward(&self) -> &f32 {
        self._glacier_base.air_control_modifier_backward()
    }
    fn air_control_modifier_strafe(&self) -> &f32 {
        self._glacier_base.air_control_modifier_strafe()
    }
    fn movement_mode(&self) -> &DSJetpackMovementMode {
        self._glacier_base.movement_mode()
    }
    fn acceleration(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        self._glacier_base.acceleration()
    }
    fn aimer_yaw_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        self._glacier_base.aimer_yaw_input()
    }
    fn ant_controller(&self) -> &super::ant::AntRef {
        self._glacier_base.ant_controller()
    }
}

impl CharacterStateBaseControllerDataTrait for CharacterStateJetpackControllerData {
    fn asset_index(&self) -> &i32 {
        self._glacier_base.asset_index()
    }
    fn subjects(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>> {
        self._glacier_base.subjects()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for CharacterStateJetpackControllerData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATEJETPACKCONTROLLERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateJetpackControllerData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIRCONTROLCAPABLECONTROLLERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateJetpackControllerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MinActiveTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateJetpackControllerData, min_active_time),
            },
            FieldInfoData {
                name: "MaxActiveTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateJetpackControllerData, max_active_time),
            },
            FieldInfoData {
                name: "MinimumTimeBeforeLand",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateJetpackControllerData, minimum_time_before_land),
            },
            FieldInfoData {
                name: "TargetVelocityXZWhenLanding",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateJetpackControllerData, target_velocity_x_z_when_landing),
            },
            FieldInfoData {
                name: "BrakeThrustY",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateJetpackControllerData, brake_thrust_y),
            },
            FieldInfoData {
                name: "BrakeThrustXZ",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateJetpackControllerData, brake_thrust_x_z),
            },
            FieldInfoData {
                name: "TargetVelocityXZWhenFlying",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateJetpackControllerData, target_velocity_x_z_when_flying),
            },
            FieldInfoData {
                name: "TargetVelocityYWhenFlying",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateJetpackControllerData, target_velocity_y_when_flying),
            },
            FieldInfoData {
                name: "MaxHeightOverGround",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateJetpackControllerData, max_height_over_ground),
            },
            FieldInfoData {
                name: "CharacterTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(CharacterStateJetpackControllerData, character_transform),
            },
            FieldInfoData {
                name: "CurrentVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateJetpackControllerData, current_velocity),
            },
            FieldInfoData {
                name: "ThrustInput",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateJetpackControllerData, thrust_input),
            },
            FieldInfoData {
                name: "ThrottleInput",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateJetpackControllerData, throttle_input),
            },
            FieldInfoData {
                name: "StrafeInput",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateJetpackControllerData, strafe_input),
            },
            FieldInfoData {
                name: "IsOnGround",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(CharacterStateJetpackControllerData, is_on_ground),
            },
            FieldInfoData {
                name: "DistanceFromGround",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateJetpackControllerData, distance_from_ground),
            },
            FieldInfoData {
                name: "JetpackActive",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(CharacterStateJetpackControllerData, jetpack_active),
            },
            FieldInfoData {
                name: "JetpackFinished",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(CharacterStateJetpackControllerData, jetpack_finished),
            },
            FieldInfoData {
                name: "JetpackStateChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "IntChannelData",
                rust_offset: offset_of!(CharacterStateJetpackControllerData, jetpack_state_channel),
            },
            FieldInfoData {
                name: "HeightLimitChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateJetpackControllerData, height_limit_channel),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEJETPACKCONTROLLERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateJetpackControllerData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEJETPACKCONTROLLERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEJETPACKCONTROLLERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateJetpackControllerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateJetpackControllerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateJumpPackControllerData {
    pub _glacier_base: AirControlCapableControllerData,
    pub min_active_time: f32,
    pub max_active_time: f32,
    pub accelerate_time: f32,
    pub max_accelerate_time: f32,
    pub minimum_time_before_land: f32,
    pub start_brake_time_y: f32,
    pub target_velocity_y_when_landing: f32,
    pub brake_thrust_y: f32,
    pub start_brake_time_x_z: f32,
    pub target_velocity_x_z_when_landing: f32,
    pub brake_thrust_x_z: f32,
    pub activate_on_ground_only: bool,
    pub reset_y_velocity_on_activation: bool,
    pub character_transform: Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>,
    pub current_velocity: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub throttle_input: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub strafe_input: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub is_on_ground: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub distance_from_ground: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub jetpack_active: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub jetpack_finished: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub jetpack_state_channel: Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>,
}

pub trait CharacterStateJumpPackControllerDataTrait: AirControlCapableControllerDataTrait {
    fn min_active_time(&self) -> &f32;
    fn max_active_time(&self) -> &f32;
    fn accelerate_time(&self) -> &f32;
    fn max_accelerate_time(&self) -> &f32;
    fn minimum_time_before_land(&self) -> &f32;
    fn start_brake_time_y(&self) -> &f32;
    fn target_velocity_y_when_landing(&self) -> &f32;
    fn brake_thrust_y(&self) -> &f32;
    fn start_brake_time_x_z(&self) -> &f32;
    fn target_velocity_x_z_when_landing(&self) -> &f32;
    fn brake_thrust_x_z(&self) -> &f32;
    fn activate_on_ground_only(&self) -> &bool;
    fn reset_y_velocity_on_activation(&self) -> &bool;
    fn character_transform(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>;
    fn current_velocity(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn throttle_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn strafe_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn is_on_ground(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn distance_from_ground(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn jetpack_active(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn jetpack_finished(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn jetpack_state_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>;
}

impl CharacterStateJumpPackControllerDataTrait for CharacterStateJumpPackControllerData {
    fn min_active_time(&self) -> &f32 {
        &self.min_active_time
    }
    fn max_active_time(&self) -> &f32 {
        &self.max_active_time
    }
    fn accelerate_time(&self) -> &f32 {
        &self.accelerate_time
    }
    fn max_accelerate_time(&self) -> &f32 {
        &self.max_accelerate_time
    }
    fn minimum_time_before_land(&self) -> &f32 {
        &self.minimum_time_before_land
    }
    fn start_brake_time_y(&self) -> &f32 {
        &self.start_brake_time_y
    }
    fn target_velocity_y_when_landing(&self) -> &f32 {
        &self.target_velocity_y_when_landing
    }
    fn brake_thrust_y(&self) -> &f32 {
        &self.brake_thrust_y
    }
    fn start_brake_time_x_z(&self) -> &f32 {
        &self.start_brake_time_x_z
    }
    fn target_velocity_x_z_when_landing(&self) -> &f32 {
        &self.target_velocity_x_z_when_landing
    }
    fn brake_thrust_x_z(&self) -> &f32 {
        &self.brake_thrust_x_z
    }
    fn activate_on_ground_only(&self) -> &bool {
        &self.activate_on_ground_only
    }
    fn reset_y_velocity_on_activation(&self) -> &bool {
        &self.reset_y_velocity_on_activation
    }
    fn character_transform(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>> {
        &self.character_transform
    }
    fn current_velocity(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.current_velocity
    }
    fn throttle_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.throttle_input
    }
    fn strafe_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.strafe_input
    }
    fn is_on_ground(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.is_on_ground
    }
    fn distance_from_ground(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.distance_from_ground
    }
    fn jetpack_active(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.jetpack_active
    }
    fn jetpack_finished(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.jetpack_finished
    }
    fn jetpack_state_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>> {
        &self.jetpack_state_channel
    }
}

impl AirControlCapableControllerDataTrait for CharacterStateJumpPackControllerData {
    fn forward_thrust(&self) -> &f32 {
        self._glacier_base.forward_thrust()
    }
    fn up_thrust(&self) -> &f32 {
        self._glacier_base.up_thrust()
    }
    fn extra_up_thrust_from_falling(&self) -> &f32 {
        self._glacier_base.extra_up_thrust_from_falling()
    }
    fn air_control_modifier_forward(&self) -> &f32 {
        self._glacier_base.air_control_modifier_forward()
    }
    fn air_control_modifier_backward(&self) -> &f32 {
        self._glacier_base.air_control_modifier_backward()
    }
    fn air_control_modifier_strafe(&self) -> &f32 {
        self._glacier_base.air_control_modifier_strafe()
    }
    fn movement_mode(&self) -> &DSJetpackMovementMode {
        self._glacier_base.movement_mode()
    }
    fn acceleration(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        self._glacier_base.acceleration()
    }
    fn aimer_yaw_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        self._glacier_base.aimer_yaw_input()
    }
    fn ant_controller(&self) -> &super::ant::AntRef {
        self._glacier_base.ant_controller()
    }
}

impl CharacterStateBaseControllerDataTrait for CharacterStateJumpPackControllerData {
    fn asset_index(&self) -> &i32 {
        self._glacier_base.asset_index()
    }
    fn subjects(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>> {
        self._glacier_base.subjects()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for CharacterStateJumpPackControllerData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATEJUMPPACKCONTROLLERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateJumpPackControllerData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIRCONTROLCAPABLECONTROLLERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateJumpPackControllerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MinActiveTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateJumpPackControllerData, min_active_time),
            },
            FieldInfoData {
                name: "MaxActiveTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateJumpPackControllerData, max_active_time),
            },
            FieldInfoData {
                name: "AccelerateTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateJumpPackControllerData, accelerate_time),
            },
            FieldInfoData {
                name: "MaxAccelerateTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateJumpPackControllerData, max_accelerate_time),
            },
            FieldInfoData {
                name: "MinimumTimeBeforeLand",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateJumpPackControllerData, minimum_time_before_land),
            },
            FieldInfoData {
                name: "StartBrakeTimeY",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateJumpPackControllerData, start_brake_time_y),
            },
            FieldInfoData {
                name: "TargetVelocityYWhenLanding",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateJumpPackControllerData, target_velocity_y_when_landing),
            },
            FieldInfoData {
                name: "BrakeThrustY",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateJumpPackControllerData, brake_thrust_y),
            },
            FieldInfoData {
                name: "StartBrakeTimeXZ",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateJumpPackControllerData, start_brake_time_x_z),
            },
            FieldInfoData {
                name: "TargetVelocityXZWhenLanding",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateJumpPackControllerData, target_velocity_x_z_when_landing),
            },
            FieldInfoData {
                name: "BrakeThrustXZ",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateJumpPackControllerData, brake_thrust_x_z),
            },
            FieldInfoData {
                name: "ActivateOnGroundOnly",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateJumpPackControllerData, activate_on_ground_only),
            },
            FieldInfoData {
                name: "ResetYVelocityOnActivation",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateJumpPackControllerData, reset_y_velocity_on_activation),
            },
            FieldInfoData {
                name: "CharacterTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(CharacterStateJumpPackControllerData, character_transform),
            },
            FieldInfoData {
                name: "CurrentVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateJumpPackControllerData, current_velocity),
            },
            FieldInfoData {
                name: "ThrottleInput",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateJumpPackControllerData, throttle_input),
            },
            FieldInfoData {
                name: "StrafeInput",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateJumpPackControllerData, strafe_input),
            },
            FieldInfoData {
                name: "IsOnGround",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(CharacterStateJumpPackControllerData, is_on_ground),
            },
            FieldInfoData {
                name: "DistanceFromGround",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateJumpPackControllerData, distance_from_ground),
            },
            FieldInfoData {
                name: "JetpackActive",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(CharacterStateJumpPackControllerData, jetpack_active),
            },
            FieldInfoData {
                name: "JetpackFinished",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(CharacterStateJumpPackControllerData, jetpack_finished),
            },
            FieldInfoData {
                name: "JetpackStateChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "IntChannelData",
                rust_offset: offset_of!(CharacterStateJumpPackControllerData, jetpack_state_channel),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEJUMPPACKCONTROLLERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateJumpPackControllerData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEJUMPPACKCONTROLLERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEJUMPPACKCONTROLLERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateJumpPackControllerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateJumpPackControllerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AirControlCapableControllerData {
    pub _glacier_base: CharacterStateBaseControllerData,
    pub forward_thrust: f32,
    pub up_thrust: f32,
    pub extra_up_thrust_from_falling: f32,
    pub air_control_modifier_forward: f32,
    pub air_control_modifier_backward: f32,
    pub air_control_modifier_strafe: f32,
    pub movement_mode: DSJetpackMovementMode,
    pub acceleration: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub aimer_yaw_input: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub ant_controller: super::ant::AntRef,
}

pub trait AirControlCapableControllerDataTrait: CharacterStateBaseControllerDataTrait {
    fn forward_thrust(&self) -> &f32;
    fn up_thrust(&self) -> &f32;
    fn extra_up_thrust_from_falling(&self) -> &f32;
    fn air_control_modifier_forward(&self) -> &f32;
    fn air_control_modifier_backward(&self) -> &f32;
    fn air_control_modifier_strafe(&self) -> &f32;
    fn movement_mode(&self) -> &DSJetpackMovementMode;
    fn acceleration(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn aimer_yaw_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn ant_controller(&self) -> &super::ant::AntRef;
}

impl AirControlCapableControllerDataTrait for AirControlCapableControllerData {
    fn forward_thrust(&self) -> &f32 {
        &self.forward_thrust
    }
    fn up_thrust(&self) -> &f32 {
        &self.up_thrust
    }
    fn extra_up_thrust_from_falling(&self) -> &f32 {
        &self.extra_up_thrust_from_falling
    }
    fn air_control_modifier_forward(&self) -> &f32 {
        &self.air_control_modifier_forward
    }
    fn air_control_modifier_backward(&self) -> &f32 {
        &self.air_control_modifier_backward
    }
    fn air_control_modifier_strafe(&self) -> &f32 {
        &self.air_control_modifier_strafe
    }
    fn movement_mode(&self) -> &DSJetpackMovementMode {
        &self.movement_mode
    }
    fn acceleration(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.acceleration
    }
    fn aimer_yaw_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.aimer_yaw_input
    }
    fn ant_controller(&self) -> &super::ant::AntRef {
        &self.ant_controller
    }
}

impl CharacterStateBaseControllerDataTrait for AirControlCapableControllerData {
    fn asset_index(&self) -> &i32 {
        self._glacier_base.asset_index()
    }
    fn subjects(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>> {
        self._glacier_base.subjects()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for AirControlCapableControllerData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static AIRCONTROLCAPABLECONTROLLERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AirControlCapableControllerData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEBASECONTROLLERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AirControlCapableControllerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ForwardThrust",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AirControlCapableControllerData, forward_thrust),
            },
            FieldInfoData {
                name: "UpThrust",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AirControlCapableControllerData, up_thrust),
            },
            FieldInfoData {
                name: "ExtraUpThrustFromFalling",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AirControlCapableControllerData, extra_up_thrust_from_falling),
            },
            FieldInfoData {
                name: "AirControlModifierForward",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AirControlCapableControllerData, air_control_modifier_forward),
            },
            FieldInfoData {
                name: "AirControlModifierBackward",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AirControlCapableControllerData, air_control_modifier_backward),
            },
            FieldInfoData {
                name: "AirControlModifierStrafe",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AirControlCapableControllerData, air_control_modifier_strafe),
            },
            FieldInfoData {
                name: "MovementMode",
                flags: MemberInfoFlags::new(0),
                field_type: "DSJetpackMovementMode",
                rust_offset: offset_of!(AirControlCapableControllerData, movement_mode),
            },
            FieldInfoData {
                name: "Acceleration",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(AirControlCapableControllerData, acceleration),
            },
            FieldInfoData {
                name: "AimerYawInput",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(AirControlCapableControllerData, aimer_yaw_input),
            },
            FieldInfoData {
                name: "AntController",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AirControlCapableControllerData, ant_controller),
            },
        ],
    }),
    array_type: Some(AIRCONTROLCAPABLECONTROLLERDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for AirControlCapableControllerData {
    fn type_info(&self) -> &'static TypeInfo {
        AIRCONTROLCAPABLECONTROLLERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static AIRCONTROLCAPABLECONTROLLERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AirControlCapableControllerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("AirControlCapableControllerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum DSJetpackMovementMode {
    #[default]
    JetpackMovementMode_WithVelocity = 0,
    JetpackMovementMode_WithCharacterFacing = 1,
}

pub static DSJETPACKMOVEMENTMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DSJetpackMovementMode",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(DSJETPACKMOVEMENTMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for DSJetpackMovementMode {
    fn type_info(&self) -> &'static TypeInfo {
        DSJETPACKMOVEMENTMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static DSJETPACKMOVEMENTMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DSJetpackMovementMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("DSJetpackMovementMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateSlidingControllerData {
    pub _glacier_base: CharacterStateBaseControllerData,
    pub horizontal_input_scale: f32,
    pub gravity_scale: f32,
    pub velocity: f32,
    pub gain: f32,
    pub ant_controller: super::ant::AntRef,
    pub character_spring_scale: f32,
    pub allowed_distance_from_ground: f32,
    pub throttle_input: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub strafe_input: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub distance_from_ground: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub normal_channel: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub position_channel: Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>,
    pub velocity_channel: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub acceleration_channel: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub angular_velocity_channel: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub movement_yaw_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub rotate_with_yaw_strength: f32,
    pub friction: f32,
}

pub trait CharacterStateSlidingControllerDataTrait: CharacterStateBaseControllerDataTrait {
    fn horizontal_input_scale(&self) -> &f32;
    fn gravity_scale(&self) -> &f32;
    fn velocity(&self) -> &f32;
    fn gain(&self) -> &f32;
    fn ant_controller(&self) -> &super::ant::AntRef;
    fn character_spring_scale(&self) -> &f32;
    fn allowed_distance_from_ground(&self) -> &f32;
    fn throttle_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn strafe_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn distance_from_ground(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn normal_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn position_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>;
    fn velocity_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn acceleration_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn angular_velocity_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn movement_yaw_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn rotate_with_yaw_strength(&self) -> &f32;
    fn friction(&self) -> &f32;
}

impl CharacterStateSlidingControllerDataTrait for CharacterStateSlidingControllerData {
    fn horizontal_input_scale(&self) -> &f32 {
        &self.horizontal_input_scale
    }
    fn gravity_scale(&self) -> &f32 {
        &self.gravity_scale
    }
    fn velocity(&self) -> &f32 {
        &self.velocity
    }
    fn gain(&self) -> &f32 {
        &self.gain
    }
    fn ant_controller(&self) -> &super::ant::AntRef {
        &self.ant_controller
    }
    fn character_spring_scale(&self) -> &f32 {
        &self.character_spring_scale
    }
    fn allowed_distance_from_ground(&self) -> &f32 {
        &self.allowed_distance_from_ground
    }
    fn throttle_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.throttle_input
    }
    fn strafe_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.strafe_input
    }
    fn distance_from_ground(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.distance_from_ground
    }
    fn normal_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.normal_channel
    }
    fn position_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>> {
        &self.position_channel
    }
    fn velocity_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.velocity_channel
    }
    fn acceleration_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.acceleration_channel
    }
    fn angular_velocity_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.angular_velocity_channel
    }
    fn movement_yaw_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.movement_yaw_channel
    }
    fn rotate_with_yaw_strength(&self) -> &f32 {
        &self.rotate_with_yaw_strength
    }
    fn friction(&self) -> &f32 {
        &self.friction
    }
}

impl CharacterStateBaseControllerDataTrait for CharacterStateSlidingControllerData {
    fn asset_index(&self) -> &i32 {
        self._glacier_base.asset_index()
    }
    fn subjects(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>> {
        self._glacier_base.subjects()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for CharacterStateSlidingControllerData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATESLIDINGCONTROLLERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateSlidingControllerData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEBASECONTROLLERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateSlidingControllerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "HorizontalInputScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateSlidingControllerData, horizontal_input_scale),
            },
            FieldInfoData {
                name: "GravityScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateSlidingControllerData, gravity_scale),
            },
            FieldInfoData {
                name: "Velocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateSlidingControllerData, velocity),
            },
            FieldInfoData {
                name: "Gain",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateSlidingControllerData, gain),
            },
            FieldInfoData {
                name: "AntController",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CharacterStateSlidingControllerData, ant_controller),
            },
            FieldInfoData {
                name: "CharacterSpringScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateSlidingControllerData, character_spring_scale),
            },
            FieldInfoData {
                name: "AllowedDistanceFromGround",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateSlidingControllerData, allowed_distance_from_ground),
            },
            FieldInfoData {
                name: "ThrottleInput",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateSlidingControllerData, throttle_input),
            },
            FieldInfoData {
                name: "StrafeInput",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateSlidingControllerData, strafe_input),
            },
            FieldInfoData {
                name: "DistanceFromGround",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateSlidingControllerData, distance_from_ground),
            },
            FieldInfoData {
                name: "NormalChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateSlidingControllerData, normal_channel),
            },
            FieldInfoData {
                name: "PositionChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(CharacterStateSlidingControllerData, position_channel),
            },
            FieldInfoData {
                name: "VelocityChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateSlidingControllerData, velocity_channel),
            },
            FieldInfoData {
                name: "AccelerationChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateSlidingControllerData, acceleration_channel),
            },
            FieldInfoData {
                name: "AngularVelocityChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateSlidingControllerData, angular_velocity_channel),
            },
            FieldInfoData {
                name: "MovementYawChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateSlidingControllerData, movement_yaw_channel),
            },
            FieldInfoData {
                name: "RotateWithYawStrength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateSlidingControllerData, rotate_with_yaw_strength),
            },
            FieldInfoData {
                name: "Friction",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateSlidingControllerData, friction),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATESLIDINGCONTROLLERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateSlidingControllerData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATESLIDINGCONTROLLERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATESLIDINGCONTROLLERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateSlidingControllerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateSlidingControllerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateMoveToTargetControllerData {
    pub _glacier_base: CharacterStateBaseControllerData,
    pub movement_type: MoveToControllerType,
    pub distance_tolerance: f32,
    pub velocity: f32,
    pub speed_input: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub time_to_target: f32,
    pub pause_time_after_move: f32,
    pub slow_down_factor_in_pause: f32,
    pub time_input: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub ant_controller: super::ant::AntRef,
    pub target_position_input: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub target_transform_input: Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>,
    pub reached_target_output: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub position_channel: Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>,
    pub velocity_channel: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub acceleration_channel: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
}

pub trait CharacterStateMoveToTargetControllerDataTrait: CharacterStateBaseControllerDataTrait {
    fn movement_type(&self) -> &MoveToControllerType;
    fn distance_tolerance(&self) -> &f32;
    fn velocity(&self) -> &f32;
    fn speed_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn time_to_target(&self) -> &f32;
    fn pause_time_after_move(&self) -> &f32;
    fn slow_down_factor_in_pause(&self) -> &f32;
    fn time_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn ant_controller(&self) -> &super::ant::AntRef;
    fn target_position_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn target_transform_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>;
    fn reached_target_output(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn position_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>;
    fn velocity_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn acceleration_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
}

impl CharacterStateMoveToTargetControllerDataTrait for CharacterStateMoveToTargetControllerData {
    fn movement_type(&self) -> &MoveToControllerType {
        &self.movement_type
    }
    fn distance_tolerance(&self) -> &f32 {
        &self.distance_tolerance
    }
    fn velocity(&self) -> &f32 {
        &self.velocity
    }
    fn speed_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.speed_input
    }
    fn time_to_target(&self) -> &f32 {
        &self.time_to_target
    }
    fn pause_time_after_move(&self) -> &f32 {
        &self.pause_time_after_move
    }
    fn slow_down_factor_in_pause(&self) -> &f32 {
        &self.slow_down_factor_in_pause
    }
    fn time_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.time_input
    }
    fn ant_controller(&self) -> &super::ant::AntRef {
        &self.ant_controller
    }
    fn target_position_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.target_position_input
    }
    fn target_transform_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>> {
        &self.target_transform_input
    }
    fn reached_target_output(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.reached_target_output
    }
    fn position_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>> {
        &self.position_channel
    }
    fn velocity_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.velocity_channel
    }
    fn acceleration_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.acceleration_channel
    }
}

impl CharacterStateBaseControllerDataTrait for CharacterStateMoveToTargetControllerData {
    fn asset_index(&self) -> &i32 {
        self._glacier_base.asset_index()
    }
    fn subjects(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>> {
        self._glacier_base.subjects()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for CharacterStateMoveToTargetControllerData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATEMOVETOTARGETCONTROLLERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateMoveToTargetControllerData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEBASECONTROLLERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateMoveToTargetControllerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MovementType",
                flags: MemberInfoFlags::new(0),
                field_type: "MoveToControllerType",
                rust_offset: offset_of!(CharacterStateMoveToTargetControllerData, movement_type),
            },
            FieldInfoData {
                name: "DistanceTolerance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateMoveToTargetControllerData, distance_tolerance),
            },
            FieldInfoData {
                name: "Velocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateMoveToTargetControllerData, velocity),
            },
            FieldInfoData {
                name: "SpeedInput",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateMoveToTargetControllerData, speed_input),
            },
            FieldInfoData {
                name: "TimeToTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateMoveToTargetControllerData, time_to_target),
            },
            FieldInfoData {
                name: "PauseTimeAfterMove",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateMoveToTargetControllerData, pause_time_after_move),
            },
            FieldInfoData {
                name: "SlowDownFactorInPause",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateMoveToTargetControllerData, slow_down_factor_in_pause),
            },
            FieldInfoData {
                name: "TimeInput",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateMoveToTargetControllerData, time_input),
            },
            FieldInfoData {
                name: "AntController",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CharacterStateMoveToTargetControllerData, ant_controller),
            },
            FieldInfoData {
                name: "TargetPositionInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateMoveToTargetControllerData, target_position_input),
            },
            FieldInfoData {
                name: "TargetTransformInput",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(CharacterStateMoveToTargetControllerData, target_transform_input),
            },
            FieldInfoData {
                name: "ReachedTargetOutput",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(CharacterStateMoveToTargetControllerData, reached_target_output),
            },
            FieldInfoData {
                name: "PositionChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(CharacterStateMoveToTargetControllerData, position_channel),
            },
            FieldInfoData {
                name: "VelocityChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateMoveToTargetControllerData, velocity_channel),
            },
            FieldInfoData {
                name: "AccelerationChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateMoveToTargetControllerData, acceleration_channel),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEMOVETOTARGETCONTROLLERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateMoveToTargetControllerData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEMOVETOTARGETCONTROLLERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEMOVETOTARGETCONTROLLERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateMoveToTargetControllerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateMoveToTargetControllerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum MoveToControllerType {
    #[default]
    MoveToControllerType_ConstantTime = 0,
    MoveToControllerType_ConstantSpeed = 1,
}

pub static MOVETOCONTROLLERTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MoveToControllerType",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(MOVETOCONTROLLERTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for MoveToControllerType {
    fn type_info(&self) -> &'static TypeInfo {
        MOVETOCONTROLLERTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static MOVETOCONTROLLERTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MoveToControllerType-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("MoveToControllerType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateClimbingControllerData {
    pub _glacier_base: CharacterStateBaseControllerData,
    pub ant_controller: super::ant::AntRef,
    pub climbing_requested_channel: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub climbing_input_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub slide_down_channel: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub jump_input_channel: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub stop_climbing_channel: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub jump_from_climb_channel: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub character_transform: Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>,
    pub a_i_trajectory: Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>,
    pub connect: Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>,
    pub ladder_transform: Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>,
    pub ladder_height_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub velocity_channel: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub acceleration_channel: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub snap_to_ladder_speed: f32,
    pub climb_speed: f32,
    pub align_with_ladder: bool,
}

pub trait CharacterStateClimbingControllerDataTrait: CharacterStateBaseControllerDataTrait {
    fn ant_controller(&self) -> &super::ant::AntRef;
    fn climbing_requested_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn climbing_input_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn slide_down_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn jump_input_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn stop_climbing_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn jump_from_climb_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn character_transform(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>;
    fn a_i_trajectory(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>;
    fn connect(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>;
    fn ladder_transform(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>;
    fn ladder_height_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn velocity_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn acceleration_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn snap_to_ladder_speed(&self) -> &f32;
    fn climb_speed(&self) -> &f32;
    fn align_with_ladder(&self) -> &bool;
}

impl CharacterStateClimbingControllerDataTrait for CharacterStateClimbingControllerData {
    fn ant_controller(&self) -> &super::ant::AntRef {
        &self.ant_controller
    }
    fn climbing_requested_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.climbing_requested_channel
    }
    fn climbing_input_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.climbing_input_channel
    }
    fn slide_down_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.slide_down_channel
    }
    fn jump_input_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.jump_input_channel
    }
    fn stop_climbing_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.stop_climbing_channel
    }
    fn jump_from_climb_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.jump_from_climb_channel
    }
    fn character_transform(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>> {
        &self.character_transform
    }
    fn a_i_trajectory(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>> {
        &self.a_i_trajectory
    }
    fn connect(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>> {
        &self.connect
    }
    fn ladder_transform(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>> {
        &self.ladder_transform
    }
    fn ladder_height_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.ladder_height_channel
    }
    fn velocity_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.velocity_channel
    }
    fn acceleration_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.acceleration_channel
    }
    fn snap_to_ladder_speed(&self) -> &f32 {
        &self.snap_to_ladder_speed
    }
    fn climb_speed(&self) -> &f32 {
        &self.climb_speed
    }
    fn align_with_ladder(&self) -> &bool {
        &self.align_with_ladder
    }
}

impl CharacterStateBaseControllerDataTrait for CharacterStateClimbingControllerData {
    fn asset_index(&self) -> &i32 {
        self._glacier_base.asset_index()
    }
    fn subjects(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>> {
        self._glacier_base.subjects()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for CharacterStateClimbingControllerData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATECLIMBINGCONTROLLERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateClimbingControllerData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEBASECONTROLLERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateClimbingControllerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AntController",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CharacterStateClimbingControllerData, ant_controller),
            },
            FieldInfoData {
                name: "ClimbingRequestedChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(CharacterStateClimbingControllerData, climbing_requested_channel),
            },
            FieldInfoData {
                name: "ClimbingInputChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateClimbingControllerData, climbing_input_channel),
            },
            FieldInfoData {
                name: "SlideDownChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(CharacterStateClimbingControllerData, slide_down_channel),
            },
            FieldInfoData {
                name: "JumpInputChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(CharacterStateClimbingControllerData, jump_input_channel),
            },
            FieldInfoData {
                name: "StopClimbingChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(CharacterStateClimbingControllerData, stop_climbing_channel),
            },
            FieldInfoData {
                name: "JumpFromClimbChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(CharacterStateClimbingControllerData, jump_from_climb_channel),
            },
            FieldInfoData {
                name: "CharacterTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(CharacterStateClimbingControllerData, character_transform),
            },
            FieldInfoData {
                name: "AITrajectory",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(CharacterStateClimbingControllerData, a_i_trajectory),
            },
            FieldInfoData {
                name: "Connect",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(CharacterStateClimbingControllerData, connect),
            },
            FieldInfoData {
                name: "LadderTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(CharacterStateClimbingControllerData, ladder_transform),
            },
            FieldInfoData {
                name: "LadderHeightChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateClimbingControllerData, ladder_height_channel),
            },
            FieldInfoData {
                name: "VelocityChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateClimbingControllerData, velocity_channel),
            },
            FieldInfoData {
                name: "AccelerationChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateClimbingControllerData, acceleration_channel),
            },
            FieldInfoData {
                name: "SnapToLadderSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateClimbingControllerData, snap_to_ladder_speed),
            },
            FieldInfoData {
                name: "ClimbSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateClimbingControllerData, climb_speed),
            },
            FieldInfoData {
                name: "AlignWithLadder",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateClimbingControllerData, align_with_ladder),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATECLIMBINGCONTROLLERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateClimbingControllerData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATECLIMBINGCONTROLLERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATECLIMBINGCONTROLLERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateClimbingControllerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateClimbingControllerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateCheckStartVaultControllerData {
    pub _glacier_base: CharacterStateBaseControllerData,
    pub ant_controller: super::ant::AntRef,
    pub character_transform: Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>,
    pub vault_requested_channel: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub throttle_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub pitch_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub ground_distance_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub velocity_channel: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub in_air_channel: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub in_water_channel: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub sprint_channel: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub start_vault_channel: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub vault_start_align_transform_channel: Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>,
    pub vault_end_follow_offset_x_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub vault_end_follow_offset_y_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub vault_end_follow_offset_z_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub vault_type_channel: Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>,
    pub physics_state_channel: Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>,
    pub vault_start_height_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub vault_end_height_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub auto_vault: bool,
    pub start_height_max: f32,
    pub start_height_min: f32,
    pub detect_distance: f32,
    pub detect_distance_moving: f32,
    pub detect_distance_vault_grab: f32,
    pub detect_distance_moving_vault_grab: f32,
    pub max_vault_height: f32,
    pub vault_grab_min_ground_distance: f32,
    pub vault_grab_min_fall_speed: f32,
    pub disallowed_poses: Vec<i32>,
    pub disallowed_physics_states: Vec<i32>,
}

pub trait CharacterStateCheckStartVaultControllerDataTrait: CharacterStateBaseControllerDataTrait {
    fn ant_controller(&self) -> &super::ant::AntRef;
    fn character_transform(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>;
    fn vault_requested_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn throttle_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn pitch_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn ground_distance_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn velocity_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn in_air_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn in_water_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn sprint_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn start_vault_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn vault_start_align_transform_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>;
    fn vault_end_follow_offset_x_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn vault_end_follow_offset_y_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn vault_end_follow_offset_z_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn vault_type_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>;
    fn physics_state_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>;
    fn vault_start_height_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn vault_end_height_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn auto_vault(&self) -> &bool;
    fn start_height_max(&self) -> &f32;
    fn start_height_min(&self) -> &f32;
    fn detect_distance(&self) -> &f32;
    fn detect_distance_moving(&self) -> &f32;
    fn detect_distance_vault_grab(&self) -> &f32;
    fn detect_distance_moving_vault_grab(&self) -> &f32;
    fn max_vault_height(&self) -> &f32;
    fn vault_grab_min_ground_distance(&self) -> &f32;
    fn vault_grab_min_fall_speed(&self) -> &f32;
    fn disallowed_poses(&self) -> &Vec<i32>;
    fn disallowed_physics_states(&self) -> &Vec<i32>;
}

impl CharacterStateCheckStartVaultControllerDataTrait for CharacterStateCheckStartVaultControllerData {
    fn ant_controller(&self) -> &super::ant::AntRef {
        &self.ant_controller
    }
    fn character_transform(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>> {
        &self.character_transform
    }
    fn vault_requested_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.vault_requested_channel
    }
    fn throttle_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.throttle_channel
    }
    fn pitch_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.pitch_channel
    }
    fn ground_distance_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.ground_distance_channel
    }
    fn velocity_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.velocity_channel
    }
    fn in_air_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.in_air_channel
    }
    fn in_water_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.in_water_channel
    }
    fn sprint_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.sprint_channel
    }
    fn start_vault_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.start_vault_channel
    }
    fn vault_start_align_transform_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>> {
        &self.vault_start_align_transform_channel
    }
    fn vault_end_follow_offset_x_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.vault_end_follow_offset_x_channel
    }
    fn vault_end_follow_offset_y_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.vault_end_follow_offset_y_channel
    }
    fn vault_end_follow_offset_z_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.vault_end_follow_offset_z_channel
    }
    fn vault_type_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>> {
        &self.vault_type_channel
    }
    fn physics_state_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>> {
        &self.physics_state_channel
    }
    fn vault_start_height_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.vault_start_height_channel
    }
    fn vault_end_height_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.vault_end_height_channel
    }
    fn auto_vault(&self) -> &bool {
        &self.auto_vault
    }
    fn start_height_max(&self) -> &f32 {
        &self.start_height_max
    }
    fn start_height_min(&self) -> &f32 {
        &self.start_height_min
    }
    fn detect_distance(&self) -> &f32 {
        &self.detect_distance
    }
    fn detect_distance_moving(&self) -> &f32 {
        &self.detect_distance_moving
    }
    fn detect_distance_vault_grab(&self) -> &f32 {
        &self.detect_distance_vault_grab
    }
    fn detect_distance_moving_vault_grab(&self) -> &f32 {
        &self.detect_distance_moving_vault_grab
    }
    fn max_vault_height(&self) -> &f32 {
        &self.max_vault_height
    }
    fn vault_grab_min_ground_distance(&self) -> &f32 {
        &self.vault_grab_min_ground_distance
    }
    fn vault_grab_min_fall_speed(&self) -> &f32 {
        &self.vault_grab_min_fall_speed
    }
    fn disallowed_poses(&self) -> &Vec<i32> {
        &self.disallowed_poses
    }
    fn disallowed_physics_states(&self) -> &Vec<i32> {
        &self.disallowed_physics_states
    }
}

impl CharacterStateBaseControllerDataTrait for CharacterStateCheckStartVaultControllerData {
    fn asset_index(&self) -> &i32 {
        self._glacier_base.asset_index()
    }
    fn subjects(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>> {
        self._glacier_base.subjects()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for CharacterStateCheckStartVaultControllerData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATECHECKSTARTVAULTCONTROLLERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateCheckStartVaultControllerData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEBASECONTROLLERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateCheckStartVaultControllerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AntController",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CharacterStateCheckStartVaultControllerData, ant_controller),
            },
            FieldInfoData {
                name: "CharacterTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(CharacterStateCheckStartVaultControllerData, character_transform),
            },
            FieldInfoData {
                name: "VaultRequestedChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(CharacterStateCheckStartVaultControllerData, vault_requested_channel),
            },
            FieldInfoData {
                name: "ThrottleChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateCheckStartVaultControllerData, throttle_channel),
            },
            FieldInfoData {
                name: "PitchChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateCheckStartVaultControllerData, pitch_channel),
            },
            FieldInfoData {
                name: "GroundDistanceChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateCheckStartVaultControllerData, ground_distance_channel),
            },
            FieldInfoData {
                name: "VelocityChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateCheckStartVaultControllerData, velocity_channel),
            },
            FieldInfoData {
                name: "InAirChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(CharacterStateCheckStartVaultControllerData, in_air_channel),
            },
            FieldInfoData {
                name: "InWaterChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(CharacterStateCheckStartVaultControllerData, in_water_channel),
            },
            FieldInfoData {
                name: "SprintChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(CharacterStateCheckStartVaultControllerData, sprint_channel),
            },
            FieldInfoData {
                name: "StartVaultChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(CharacterStateCheckStartVaultControllerData, start_vault_channel),
            },
            FieldInfoData {
                name: "VaultStartAlignTransformChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(CharacterStateCheckStartVaultControllerData, vault_start_align_transform_channel),
            },
            FieldInfoData {
                name: "VaultEndFollowOffsetXChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateCheckStartVaultControllerData, vault_end_follow_offset_x_channel),
            },
            FieldInfoData {
                name: "VaultEndFollowOffsetYChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateCheckStartVaultControllerData, vault_end_follow_offset_y_channel),
            },
            FieldInfoData {
                name: "VaultEndFollowOffsetZChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateCheckStartVaultControllerData, vault_end_follow_offset_z_channel),
            },
            FieldInfoData {
                name: "VaultTypeChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "IntChannelData",
                rust_offset: offset_of!(CharacterStateCheckStartVaultControllerData, vault_type_channel),
            },
            FieldInfoData {
                name: "PhysicsStateChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "IntChannelData",
                rust_offset: offset_of!(CharacterStateCheckStartVaultControllerData, physics_state_channel),
            },
            FieldInfoData {
                name: "VaultStartHeightChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateCheckStartVaultControllerData, vault_start_height_channel),
            },
            FieldInfoData {
                name: "VaultEndHeightChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateCheckStartVaultControllerData, vault_end_height_channel),
            },
            FieldInfoData {
                name: "AutoVault",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateCheckStartVaultControllerData, auto_vault),
            },
            FieldInfoData {
                name: "StartHeightMax",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateCheckStartVaultControllerData, start_height_max),
            },
            FieldInfoData {
                name: "StartHeightMin",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateCheckStartVaultControllerData, start_height_min),
            },
            FieldInfoData {
                name: "DetectDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateCheckStartVaultControllerData, detect_distance),
            },
            FieldInfoData {
                name: "DetectDistanceMoving",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateCheckStartVaultControllerData, detect_distance_moving),
            },
            FieldInfoData {
                name: "DetectDistanceVaultGrab",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateCheckStartVaultControllerData, detect_distance_vault_grab),
            },
            FieldInfoData {
                name: "DetectDistanceMovingVaultGrab",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateCheckStartVaultControllerData, detect_distance_moving_vault_grab),
            },
            FieldInfoData {
                name: "MaxVaultHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateCheckStartVaultControllerData, max_vault_height),
            },
            FieldInfoData {
                name: "VaultGrabMinGroundDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateCheckStartVaultControllerData, vault_grab_min_ground_distance),
            },
            FieldInfoData {
                name: "VaultGrabMinFallSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateCheckStartVaultControllerData, vault_grab_min_fall_speed),
            },
            FieldInfoData {
                name: "DisallowedPoses",
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(CharacterStateCheckStartVaultControllerData, disallowed_poses),
            },
            FieldInfoData {
                name: "DisallowedPhysicsStates",
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(CharacterStateCheckStartVaultControllerData, disallowed_physics_states),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATECHECKSTARTVAULTCONTROLLERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateCheckStartVaultControllerData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATECHECKSTARTVAULTCONTROLLERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATECHECKSTARTVAULTCONTROLLERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateCheckStartVaultControllerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateCheckStartVaultControllerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateCheckStartClimbingControllerData {
    pub _glacier_base: CharacterStateBaseControllerData,
    pub ant_controller: super::ant::AntRef,
    pub enabled_channel: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub climbing_requested_channel: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub start_climbing_channel: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub character_transform: Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>,
    pub ladder_transform: Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>,
    pub ladder_height_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub throttle_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub max_dist_to_ladder: f32,
    pub max_angle_to_ladder: f32,
    pub search_height: f32,
    pub auto_climb: bool,
    pub front_only: bool,
}

pub trait CharacterStateCheckStartClimbingControllerDataTrait: CharacterStateBaseControllerDataTrait {
    fn ant_controller(&self) -> &super::ant::AntRef;
    fn enabled_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn climbing_requested_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn start_climbing_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn character_transform(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>;
    fn ladder_transform(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>;
    fn ladder_height_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn throttle_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn max_dist_to_ladder(&self) -> &f32;
    fn max_angle_to_ladder(&self) -> &f32;
    fn search_height(&self) -> &f32;
    fn auto_climb(&self) -> &bool;
    fn front_only(&self) -> &bool;
}

impl CharacterStateCheckStartClimbingControllerDataTrait for CharacterStateCheckStartClimbingControllerData {
    fn ant_controller(&self) -> &super::ant::AntRef {
        &self.ant_controller
    }
    fn enabled_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.enabled_channel
    }
    fn climbing_requested_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.climbing_requested_channel
    }
    fn start_climbing_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.start_climbing_channel
    }
    fn character_transform(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>> {
        &self.character_transform
    }
    fn ladder_transform(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>> {
        &self.ladder_transform
    }
    fn ladder_height_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.ladder_height_channel
    }
    fn throttle_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.throttle_channel
    }
    fn max_dist_to_ladder(&self) -> &f32 {
        &self.max_dist_to_ladder
    }
    fn max_angle_to_ladder(&self) -> &f32 {
        &self.max_angle_to_ladder
    }
    fn search_height(&self) -> &f32 {
        &self.search_height
    }
    fn auto_climb(&self) -> &bool {
        &self.auto_climb
    }
    fn front_only(&self) -> &bool {
        &self.front_only
    }
}

impl CharacterStateBaseControllerDataTrait for CharacterStateCheckStartClimbingControllerData {
    fn asset_index(&self) -> &i32 {
        self._glacier_base.asset_index()
    }
    fn subjects(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>> {
        self._glacier_base.subjects()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for CharacterStateCheckStartClimbingControllerData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATECHECKSTARTCLIMBINGCONTROLLERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateCheckStartClimbingControllerData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEBASECONTROLLERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateCheckStartClimbingControllerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AntController",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CharacterStateCheckStartClimbingControllerData, ant_controller),
            },
            FieldInfoData {
                name: "EnabledChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(CharacterStateCheckStartClimbingControllerData, enabled_channel),
            },
            FieldInfoData {
                name: "ClimbingRequestedChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(CharacterStateCheckStartClimbingControllerData, climbing_requested_channel),
            },
            FieldInfoData {
                name: "StartClimbingChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(CharacterStateCheckStartClimbingControllerData, start_climbing_channel),
            },
            FieldInfoData {
                name: "CharacterTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(CharacterStateCheckStartClimbingControllerData, character_transform),
            },
            FieldInfoData {
                name: "LadderTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(CharacterStateCheckStartClimbingControllerData, ladder_transform),
            },
            FieldInfoData {
                name: "LadderHeightChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateCheckStartClimbingControllerData, ladder_height_channel),
            },
            FieldInfoData {
                name: "ThrottleChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateCheckStartClimbingControllerData, throttle_channel),
            },
            FieldInfoData {
                name: "MaxDistToLadder",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateCheckStartClimbingControllerData, max_dist_to_ladder),
            },
            FieldInfoData {
                name: "MaxAngleToLadder",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateCheckStartClimbingControllerData, max_angle_to_ladder),
            },
            FieldInfoData {
                name: "SearchHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateCheckStartClimbingControllerData, search_height),
            },
            FieldInfoData {
                name: "AutoClimb",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateCheckStartClimbingControllerData, auto_climb),
            },
            FieldInfoData {
                name: "FrontOnly",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateCheckStartClimbingControllerData, front_only),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATECHECKSTARTCLIMBINGCONTROLLERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateCheckStartClimbingControllerData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATECHECKSTARTCLIMBINGCONTROLLERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATECHECKSTARTCLIMBINGCONTROLLERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateCheckStartClimbingControllerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateCheckStartClimbingControllerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateParachuteControllerData {
    pub _glacier_base: CharacterStateBaseControllerData,
    pub ant_controller: super::ant::AntRef,
    pub enabled_channel: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub transform_channel: Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>,
    pub velocity_channel: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub angular_velocity_channel: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub acceleration_channel: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub input_l_r_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub input_u_d_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub gravity: f32,
    pub terminal_velocity: f32,
    pub forward_drag_coefficient: f32,
    pub bank_offset: f32,
    pub throttle_offset: f32,
    pub brake_offset: f32,
    pub angle_of_attack: f32,
    pub max_pitch_velocity: f32,
    pub max_roll_velocity: f32,
    pub max_yaw_velocity: f32,
    pub deploy_time: f32,
}

pub trait CharacterStateParachuteControllerDataTrait: CharacterStateBaseControllerDataTrait {
    fn ant_controller(&self) -> &super::ant::AntRef;
    fn enabled_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn transform_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>;
    fn velocity_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn angular_velocity_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn acceleration_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn input_l_r_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn input_u_d_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn gravity(&self) -> &f32;
    fn terminal_velocity(&self) -> &f32;
    fn forward_drag_coefficient(&self) -> &f32;
    fn bank_offset(&self) -> &f32;
    fn throttle_offset(&self) -> &f32;
    fn brake_offset(&self) -> &f32;
    fn angle_of_attack(&self) -> &f32;
    fn max_pitch_velocity(&self) -> &f32;
    fn max_roll_velocity(&self) -> &f32;
    fn max_yaw_velocity(&self) -> &f32;
    fn deploy_time(&self) -> &f32;
}

impl CharacterStateParachuteControllerDataTrait for CharacterStateParachuteControllerData {
    fn ant_controller(&self) -> &super::ant::AntRef {
        &self.ant_controller
    }
    fn enabled_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.enabled_channel
    }
    fn transform_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>> {
        &self.transform_channel
    }
    fn velocity_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.velocity_channel
    }
    fn angular_velocity_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.angular_velocity_channel
    }
    fn acceleration_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.acceleration_channel
    }
    fn input_l_r_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.input_l_r_channel
    }
    fn input_u_d_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.input_u_d_channel
    }
    fn gravity(&self) -> &f32 {
        &self.gravity
    }
    fn terminal_velocity(&self) -> &f32 {
        &self.terminal_velocity
    }
    fn forward_drag_coefficient(&self) -> &f32 {
        &self.forward_drag_coefficient
    }
    fn bank_offset(&self) -> &f32 {
        &self.bank_offset
    }
    fn throttle_offset(&self) -> &f32 {
        &self.throttle_offset
    }
    fn brake_offset(&self) -> &f32 {
        &self.brake_offset
    }
    fn angle_of_attack(&self) -> &f32 {
        &self.angle_of_attack
    }
    fn max_pitch_velocity(&self) -> &f32 {
        &self.max_pitch_velocity
    }
    fn max_roll_velocity(&self) -> &f32 {
        &self.max_roll_velocity
    }
    fn max_yaw_velocity(&self) -> &f32 {
        &self.max_yaw_velocity
    }
    fn deploy_time(&self) -> &f32 {
        &self.deploy_time
    }
}

impl CharacterStateBaseControllerDataTrait for CharacterStateParachuteControllerData {
    fn asset_index(&self) -> &i32 {
        self._glacier_base.asset_index()
    }
    fn subjects(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>> {
        self._glacier_base.subjects()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for CharacterStateParachuteControllerData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATEPARACHUTECONTROLLERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateParachuteControllerData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEBASECONTROLLERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateParachuteControllerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AntController",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CharacterStateParachuteControllerData, ant_controller),
            },
            FieldInfoData {
                name: "EnabledChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(CharacterStateParachuteControllerData, enabled_channel),
            },
            FieldInfoData {
                name: "TransformChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(CharacterStateParachuteControllerData, transform_channel),
            },
            FieldInfoData {
                name: "VelocityChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateParachuteControllerData, velocity_channel),
            },
            FieldInfoData {
                name: "AngularVelocityChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateParachuteControllerData, angular_velocity_channel),
            },
            FieldInfoData {
                name: "AccelerationChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateParachuteControllerData, acceleration_channel),
            },
            FieldInfoData {
                name: "InputLRChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateParachuteControllerData, input_l_r_channel),
            },
            FieldInfoData {
                name: "InputUDChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateParachuteControllerData, input_u_d_channel),
            },
            FieldInfoData {
                name: "Gravity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateParachuteControllerData, gravity),
            },
            FieldInfoData {
                name: "TerminalVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateParachuteControllerData, terminal_velocity),
            },
            FieldInfoData {
                name: "ForwardDragCoefficient",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateParachuteControllerData, forward_drag_coefficient),
            },
            FieldInfoData {
                name: "BankOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateParachuteControllerData, bank_offset),
            },
            FieldInfoData {
                name: "ThrottleOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateParachuteControllerData, throttle_offset),
            },
            FieldInfoData {
                name: "BrakeOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateParachuteControllerData, brake_offset),
            },
            FieldInfoData {
                name: "AngleOfAttack",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateParachuteControllerData, angle_of_attack),
            },
            FieldInfoData {
                name: "MaxPitchVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateParachuteControllerData, max_pitch_velocity),
            },
            FieldInfoData {
                name: "MaxRollVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateParachuteControllerData, max_roll_velocity),
            },
            FieldInfoData {
                name: "MaxYawVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateParachuteControllerData, max_yaw_velocity),
            },
            FieldInfoData {
                name: "DeployTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateParachuteControllerData, deploy_time),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEPARACHUTECONTROLLERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateParachuteControllerData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEPARACHUTECONTROLLERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEPARACHUTECONTROLLERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateParachuteControllerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateParachuteControllerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateApplyAccelerationFromInputControllerData {
    pub _glacier_base: CharacterStateBaseControllerData,
    pub ant_controller: super::ant::AntRef,
    pub enabled_channel: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub input_scaling: CharacterStateMovementInputScaling,
    pub sprint_strafe_input_scale: f32,
    pub velocity: f32,
    pub top_speed_modifications: Vec<CharacterStateApplyAccelerationFromInputModification>,
    pub strafe_input_scale_modifications: Vec<CharacterStateApplyAccelerationFromInputModification>,
    pub speed_input: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub clamp_speed_input: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub sprint_top_speed_multiplier: f32,
    pub sprint_top_speed_multiplier_input: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub gain: f32,
    pub sprint_gain: f32,
    pub stop_gain: f32,
    pub sprinting_input: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub throttle_input: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub constant_throttle_input: f32,
    pub strafe_input: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub constant_strafe_input: f32,
    pub normal_channel: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub position_channel: Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>,
    pub velocity_channel: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub acceleration_channel: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub angular_velocity_channel: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub movement_yaw_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub movement_pitch_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub reorient_up_channel: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub rotate_with_yaw_strength: f32,
    pub allow_reduce_speed_in_current_direction: bool,
    pub reorient_up_direction: bool,
    pub reorient_up_default: super::core::Vec3,
}

pub trait CharacterStateApplyAccelerationFromInputControllerDataTrait: CharacterStateBaseControllerDataTrait {
    fn ant_controller(&self) -> &super::ant::AntRef;
    fn enabled_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn input_scaling(&self) -> &CharacterStateMovementInputScaling;
    fn sprint_strafe_input_scale(&self) -> &f32;
    fn velocity(&self) -> &f32;
    fn top_speed_modifications(&self) -> &Vec<CharacterStateApplyAccelerationFromInputModification>;
    fn strafe_input_scale_modifications(&self) -> &Vec<CharacterStateApplyAccelerationFromInputModification>;
    fn speed_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn clamp_speed_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn sprint_top_speed_multiplier(&self) -> &f32;
    fn sprint_top_speed_multiplier_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn gain(&self) -> &f32;
    fn sprint_gain(&self) -> &f32;
    fn stop_gain(&self) -> &f32;
    fn sprinting_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn throttle_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn constant_throttle_input(&self) -> &f32;
    fn strafe_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn constant_strafe_input(&self) -> &f32;
    fn normal_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn position_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>;
    fn velocity_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn acceleration_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn angular_velocity_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn movement_yaw_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn movement_pitch_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn reorient_up_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn rotate_with_yaw_strength(&self) -> &f32;
    fn allow_reduce_speed_in_current_direction(&self) -> &bool;
    fn reorient_up_direction(&self) -> &bool;
    fn reorient_up_default(&self) -> &super::core::Vec3;
}

impl CharacterStateApplyAccelerationFromInputControllerDataTrait for CharacterStateApplyAccelerationFromInputControllerData {
    fn ant_controller(&self) -> &super::ant::AntRef {
        &self.ant_controller
    }
    fn enabled_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.enabled_channel
    }
    fn input_scaling(&self) -> &CharacterStateMovementInputScaling {
        &self.input_scaling
    }
    fn sprint_strafe_input_scale(&self) -> &f32 {
        &self.sprint_strafe_input_scale
    }
    fn velocity(&self) -> &f32 {
        &self.velocity
    }
    fn top_speed_modifications(&self) -> &Vec<CharacterStateApplyAccelerationFromInputModification> {
        &self.top_speed_modifications
    }
    fn strafe_input_scale_modifications(&self) -> &Vec<CharacterStateApplyAccelerationFromInputModification> {
        &self.strafe_input_scale_modifications
    }
    fn speed_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.speed_input
    }
    fn clamp_speed_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.clamp_speed_input
    }
    fn sprint_top_speed_multiplier(&self) -> &f32 {
        &self.sprint_top_speed_multiplier
    }
    fn sprint_top_speed_multiplier_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.sprint_top_speed_multiplier_input
    }
    fn gain(&self) -> &f32 {
        &self.gain
    }
    fn sprint_gain(&self) -> &f32 {
        &self.sprint_gain
    }
    fn stop_gain(&self) -> &f32 {
        &self.stop_gain
    }
    fn sprinting_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.sprinting_input
    }
    fn throttle_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.throttle_input
    }
    fn constant_throttle_input(&self) -> &f32 {
        &self.constant_throttle_input
    }
    fn strafe_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.strafe_input
    }
    fn constant_strafe_input(&self) -> &f32 {
        &self.constant_strafe_input
    }
    fn normal_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.normal_channel
    }
    fn position_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>> {
        &self.position_channel
    }
    fn velocity_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.velocity_channel
    }
    fn acceleration_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.acceleration_channel
    }
    fn angular_velocity_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.angular_velocity_channel
    }
    fn movement_yaw_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.movement_yaw_channel
    }
    fn movement_pitch_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.movement_pitch_channel
    }
    fn reorient_up_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.reorient_up_channel
    }
    fn rotate_with_yaw_strength(&self) -> &f32 {
        &self.rotate_with_yaw_strength
    }
    fn allow_reduce_speed_in_current_direction(&self) -> &bool {
        &self.allow_reduce_speed_in_current_direction
    }
    fn reorient_up_direction(&self) -> &bool {
        &self.reorient_up_direction
    }
    fn reorient_up_default(&self) -> &super::core::Vec3 {
        &self.reorient_up_default
    }
}

impl CharacterStateBaseControllerDataTrait for CharacterStateApplyAccelerationFromInputControllerData {
    fn asset_index(&self) -> &i32 {
        self._glacier_base.asset_index()
    }
    fn subjects(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>> {
        self._glacier_base.subjects()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for CharacterStateApplyAccelerationFromInputControllerData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATEAPPLYACCELERATIONFROMINPUTCONTROLLERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateApplyAccelerationFromInputControllerData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEBASECONTROLLERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateApplyAccelerationFromInputControllerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AntController",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CharacterStateApplyAccelerationFromInputControllerData, ant_controller),
            },
            FieldInfoData {
                name: "EnabledChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(CharacterStateApplyAccelerationFromInputControllerData, enabled_channel),
            },
            FieldInfoData {
                name: "InputScaling",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterStateMovementInputScaling",
                rust_offset: offset_of!(CharacterStateApplyAccelerationFromInputControllerData, input_scaling),
            },
            FieldInfoData {
                name: "SprintStrafeInputScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateApplyAccelerationFromInputControllerData, sprint_strafe_input_scale),
            },
            FieldInfoData {
                name: "Velocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateApplyAccelerationFromInputControllerData, velocity),
            },
            FieldInfoData {
                name: "TopSpeedModifications",
                flags: MemberInfoFlags::new(144),
                field_type: "CharacterStateApplyAccelerationFromInputModification-Array",
                rust_offset: offset_of!(CharacterStateApplyAccelerationFromInputControllerData, top_speed_modifications),
            },
            FieldInfoData {
                name: "StrafeInputScaleModifications",
                flags: MemberInfoFlags::new(144),
                field_type: "CharacterStateApplyAccelerationFromInputModification-Array",
                rust_offset: offset_of!(CharacterStateApplyAccelerationFromInputControllerData, strafe_input_scale_modifications),
            },
            FieldInfoData {
                name: "SpeedInput",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateApplyAccelerationFromInputControllerData, speed_input),
            },
            FieldInfoData {
                name: "ClampSpeedInput",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateApplyAccelerationFromInputControllerData, clamp_speed_input),
            },
            FieldInfoData {
                name: "SprintTopSpeedMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateApplyAccelerationFromInputControllerData, sprint_top_speed_multiplier),
            },
            FieldInfoData {
                name: "SprintTopSpeedMultiplierInput",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateApplyAccelerationFromInputControllerData, sprint_top_speed_multiplier_input),
            },
            FieldInfoData {
                name: "Gain",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateApplyAccelerationFromInputControllerData, gain),
            },
            FieldInfoData {
                name: "SprintGain",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateApplyAccelerationFromInputControllerData, sprint_gain),
            },
            FieldInfoData {
                name: "StopGain",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateApplyAccelerationFromInputControllerData, stop_gain),
            },
            FieldInfoData {
                name: "SprintingInput",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(CharacterStateApplyAccelerationFromInputControllerData, sprinting_input),
            },
            FieldInfoData {
                name: "ThrottleInput",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateApplyAccelerationFromInputControllerData, throttle_input),
            },
            FieldInfoData {
                name: "ConstantThrottleInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateApplyAccelerationFromInputControllerData, constant_throttle_input),
            },
            FieldInfoData {
                name: "StrafeInput",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateApplyAccelerationFromInputControllerData, strafe_input),
            },
            FieldInfoData {
                name: "ConstantStrafeInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateApplyAccelerationFromInputControllerData, constant_strafe_input),
            },
            FieldInfoData {
                name: "NormalChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateApplyAccelerationFromInputControllerData, normal_channel),
            },
            FieldInfoData {
                name: "PositionChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(CharacterStateApplyAccelerationFromInputControllerData, position_channel),
            },
            FieldInfoData {
                name: "VelocityChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateApplyAccelerationFromInputControllerData, velocity_channel),
            },
            FieldInfoData {
                name: "AccelerationChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateApplyAccelerationFromInputControllerData, acceleration_channel),
            },
            FieldInfoData {
                name: "AngularVelocityChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateApplyAccelerationFromInputControllerData, angular_velocity_channel),
            },
            FieldInfoData {
                name: "MovementYawChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateApplyAccelerationFromInputControllerData, movement_yaw_channel),
            },
            FieldInfoData {
                name: "MovementPitchChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateApplyAccelerationFromInputControllerData, movement_pitch_channel),
            },
            FieldInfoData {
                name: "ReorientUpChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateApplyAccelerationFromInputControllerData, reorient_up_channel),
            },
            FieldInfoData {
                name: "RotateWithYawStrength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateApplyAccelerationFromInputControllerData, rotate_with_yaw_strength),
            },
            FieldInfoData {
                name: "AllowReduceSpeedInCurrentDirection",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateApplyAccelerationFromInputControllerData, allow_reduce_speed_in_current_direction),
            },
            FieldInfoData {
                name: "ReorientUpDirection",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateApplyAccelerationFromInputControllerData, reorient_up_direction),
            },
            FieldInfoData {
                name: "ReorientUpDefault",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(CharacterStateApplyAccelerationFromInputControllerData, reorient_up_default),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEAPPLYACCELERATIONFROMINPUTCONTROLLERDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CharacterStateApplyAccelerationFromInputControllerData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEAPPLYACCELERATIONFROMINPUTCONTROLLERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEAPPLYACCELERATIONFROMINPUTCONTROLLERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateApplyAccelerationFromInputControllerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateApplyAccelerationFromInputControllerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateApplyAccelerationFromInputModification {
    pub modification_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub constant_multiplier: f32,
    pub enabled_channel: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
}

pub trait CharacterStateApplyAccelerationFromInputModificationTrait: TypeObject {
    fn modification_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn constant_multiplier(&self) -> &f32;
    fn enabled_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
}

impl CharacterStateApplyAccelerationFromInputModificationTrait for CharacterStateApplyAccelerationFromInputModification {
    fn modification_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.modification_channel
    }
    fn constant_multiplier(&self) -> &f32 {
        &self.constant_multiplier
    }
    fn enabled_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.enabled_channel
    }
}

pub static CHARACTERSTATEAPPLYACCELERATIONFROMINPUTMODIFICATION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateApplyAccelerationFromInputModification",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateApplyAccelerationFromInputModification as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ModificationChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateApplyAccelerationFromInputModification, modification_channel),
            },
            FieldInfoData {
                name: "ConstantMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateApplyAccelerationFromInputModification, constant_multiplier),
            },
            FieldInfoData {
                name: "EnabledChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(CharacterStateApplyAccelerationFromInputModification, enabled_channel),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEAPPLYACCELERATIONFROMINPUTMODIFICATION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateApplyAccelerationFromInputModification {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEAPPLYACCELERATIONFROMINPUTMODIFICATION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEAPPLYACCELERATIONFROMINPUTMODIFICATION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateApplyAccelerationFromInputModification-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateApplyAccelerationFromInputModification"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateMovementInputScaling {
    pub forward_constant: f32,
    pub backward_constant: f32,
    pub left_constant: f32,
    pub right_constant: f32,
    pub up_hill_max_angle: f32,
    pub up_hill_modification: HillModification,
    pub down_hill_modification: HillModification,
}

pub trait CharacterStateMovementInputScalingTrait: TypeObject {
    fn forward_constant(&self) -> &f32;
    fn backward_constant(&self) -> &f32;
    fn left_constant(&self) -> &f32;
    fn right_constant(&self) -> &f32;
    fn up_hill_max_angle(&self) -> &f32;
    fn up_hill_modification(&self) -> &HillModification;
    fn down_hill_modification(&self) -> &HillModification;
}

impl CharacterStateMovementInputScalingTrait for CharacterStateMovementInputScaling {
    fn forward_constant(&self) -> &f32 {
        &self.forward_constant
    }
    fn backward_constant(&self) -> &f32 {
        &self.backward_constant
    }
    fn left_constant(&self) -> &f32 {
        &self.left_constant
    }
    fn right_constant(&self) -> &f32 {
        &self.right_constant
    }
    fn up_hill_max_angle(&self) -> &f32 {
        &self.up_hill_max_angle
    }
    fn up_hill_modification(&self) -> &HillModification {
        &self.up_hill_modification
    }
    fn down_hill_modification(&self) -> &HillModification {
        &self.down_hill_modification
    }
}

pub static CHARACTERSTATEMOVEMENTINPUTSCALING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateMovementInputScaling",
    flags: MemberInfoFlags::new(36937),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateMovementInputScaling as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ForwardConstant",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateMovementInputScaling, forward_constant),
            },
            FieldInfoData {
                name: "BackwardConstant",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateMovementInputScaling, backward_constant),
            },
            FieldInfoData {
                name: "LeftConstant",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateMovementInputScaling, left_constant),
            },
            FieldInfoData {
                name: "RightConstant",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateMovementInputScaling, right_constant),
            },
            FieldInfoData {
                name: "UpHillMaxAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateMovementInputScaling, up_hill_max_angle),
            },
            FieldInfoData {
                name: "UpHillModification",
                flags: MemberInfoFlags::new(0),
                field_type: "HillModification",
                rust_offset: offset_of!(CharacterStateMovementInputScaling, up_hill_modification),
            },
            FieldInfoData {
                name: "DownHillModification",
                flags: MemberInfoFlags::new(0),
                field_type: "HillModification",
                rust_offset: offset_of!(CharacterStateMovementInputScaling, down_hill_modification),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEMOVEMENTINPUTSCALING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for CharacterStateMovementInputScaling {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEMOVEMENTINPUTSCALING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEMOVEMENTINPUTSCALING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateMovementInputScaling-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateMovementInputScaling"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct HillModification {
    pub min_angle: f32,
    pub max_angle: f32,
    pub speed_modifier: f32,
}

pub trait HillModificationTrait: TypeObject {
    fn min_angle(&self) -> &f32;
    fn max_angle(&self) -> &f32;
    fn speed_modifier(&self) -> &f32;
}

impl HillModificationTrait for HillModification {
    fn min_angle(&self) -> &f32 {
        &self.min_angle
    }
    fn max_angle(&self) -> &f32 {
        &self.max_angle
    }
    fn speed_modifier(&self) -> &f32 {
        &self.speed_modifier
    }
}

pub static HILLMODIFICATION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HillModification",
    flags: MemberInfoFlags::new(36937),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<HillModification as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MinAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HillModification, min_angle),
            },
            FieldInfoData {
                name: "MaxAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HillModification, max_angle),
            },
            FieldInfoData {
                name: "SpeedModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HillModification, speed_modifier),
            },
        ],
    }),
    array_type: Some(HILLMODIFICATION_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for HillModification {
    fn type_info(&self) -> &'static TypeInfo {
        HILLMODIFICATION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static HILLMODIFICATION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HillModification-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("HillModification"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateImpulseControllerData {
    pub _glacier_base: CharacterStateBaseControllerData,
    pub base_impulse_magnitude: f32,
    pub air_tweaker: f32,
    pub impulse_modifier: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub impulse_trigger: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub invert_impulse_trigger_channel: bool,
    pub current_transform_channel: Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>,
    pub current_target_transform_channel: Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>,
    pub acceleration: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub ant_controller: super::ant::AntRef,
    pub impulse_duration_ticks: i32,
}

pub trait CharacterStateImpulseControllerDataTrait: CharacterStateBaseControllerDataTrait {
    fn base_impulse_magnitude(&self) -> &f32;
    fn air_tweaker(&self) -> &f32;
    fn impulse_modifier(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn impulse_trigger(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn invert_impulse_trigger_channel(&self) -> &bool;
    fn current_transform_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>;
    fn current_target_transform_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>;
    fn acceleration(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn ant_controller(&self) -> &super::ant::AntRef;
    fn impulse_duration_ticks(&self) -> &i32;
}

impl CharacterStateImpulseControllerDataTrait for CharacterStateImpulseControllerData {
    fn base_impulse_magnitude(&self) -> &f32 {
        &self.base_impulse_magnitude
    }
    fn air_tweaker(&self) -> &f32 {
        &self.air_tweaker
    }
    fn impulse_modifier(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.impulse_modifier
    }
    fn impulse_trigger(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.impulse_trigger
    }
    fn invert_impulse_trigger_channel(&self) -> &bool {
        &self.invert_impulse_trigger_channel
    }
    fn current_transform_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>> {
        &self.current_transform_channel
    }
    fn current_target_transform_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>> {
        &self.current_target_transform_channel
    }
    fn acceleration(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.acceleration
    }
    fn ant_controller(&self) -> &super::ant::AntRef {
        &self.ant_controller
    }
    fn impulse_duration_ticks(&self) -> &i32 {
        &self.impulse_duration_ticks
    }
}

impl CharacterStateBaseControllerDataTrait for CharacterStateImpulseControllerData {
    fn asset_index(&self) -> &i32 {
        self._glacier_base.asset_index()
    }
    fn subjects(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>> {
        self._glacier_base.subjects()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for CharacterStateImpulseControllerData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATEIMPULSECONTROLLERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateImpulseControllerData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEBASECONTROLLERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateImpulseControllerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "BaseImpulseMagnitude",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateImpulseControllerData, base_impulse_magnitude),
            },
            FieldInfoData {
                name: "AirTweaker",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateImpulseControllerData, air_tweaker),
            },
            FieldInfoData {
                name: "ImpulseModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateImpulseControllerData, impulse_modifier),
            },
            FieldInfoData {
                name: "ImpulseTrigger",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(CharacterStateImpulseControllerData, impulse_trigger),
            },
            FieldInfoData {
                name: "InvertImpulseTriggerChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateImpulseControllerData, invert_impulse_trigger_channel),
            },
            FieldInfoData {
                name: "CurrentTransformChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(CharacterStateImpulseControllerData, current_transform_channel),
            },
            FieldInfoData {
                name: "CurrentTargetTransformChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(CharacterStateImpulseControllerData, current_target_transform_channel),
            },
            FieldInfoData {
                name: "Acceleration",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateImpulseControllerData, acceleration),
            },
            FieldInfoData {
                name: "AntController",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CharacterStateImpulseControllerData, ant_controller),
            },
            FieldInfoData {
                name: "ImpulseDurationTicks",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CharacterStateImpulseControllerData, impulse_duration_ticks),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEIMPULSECONTROLLERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateImpulseControllerData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEIMPULSECONTROLLERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEIMPULSECONTROLLERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateImpulseControllerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateImpulseControllerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateConstantVelocityControllerData {
    pub _glacier_base: CharacterStateBaseControllerData,
    pub target_velocity: super::core::Vec3,
    pub weights: super::core::Vec3,
    pub rotate_target_velocity_about_x_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub scale_rotation_value: f32,
    pub clamp_rotation_value_min: f32,
    pub clamp_rotation_value_max: f32,
    pub follow_look_direction: bool,
    pub movement_pitch_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub movement_yaw_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub current_velocity_channel: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub current_transform_channel: Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>,
    pub acceleration: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub ant_controller: super::ant::AntRef,
}

pub trait CharacterStateConstantVelocityControllerDataTrait: CharacterStateBaseControllerDataTrait {
    fn target_velocity(&self) -> &super::core::Vec3;
    fn weights(&self) -> &super::core::Vec3;
    fn rotate_target_velocity_about_x_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn scale_rotation_value(&self) -> &f32;
    fn clamp_rotation_value_min(&self) -> &f32;
    fn clamp_rotation_value_max(&self) -> &f32;
    fn follow_look_direction(&self) -> &bool;
    fn movement_pitch_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn movement_yaw_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn current_velocity_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn current_transform_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>;
    fn acceleration(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn ant_controller(&self) -> &super::ant::AntRef;
}

impl CharacterStateConstantVelocityControllerDataTrait for CharacterStateConstantVelocityControllerData {
    fn target_velocity(&self) -> &super::core::Vec3 {
        &self.target_velocity
    }
    fn weights(&self) -> &super::core::Vec3 {
        &self.weights
    }
    fn rotate_target_velocity_about_x_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.rotate_target_velocity_about_x_channel
    }
    fn scale_rotation_value(&self) -> &f32 {
        &self.scale_rotation_value
    }
    fn clamp_rotation_value_min(&self) -> &f32 {
        &self.clamp_rotation_value_min
    }
    fn clamp_rotation_value_max(&self) -> &f32 {
        &self.clamp_rotation_value_max
    }
    fn follow_look_direction(&self) -> &bool {
        &self.follow_look_direction
    }
    fn movement_pitch_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.movement_pitch_channel
    }
    fn movement_yaw_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.movement_yaw_channel
    }
    fn current_velocity_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.current_velocity_channel
    }
    fn current_transform_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>> {
        &self.current_transform_channel
    }
    fn acceleration(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.acceleration
    }
    fn ant_controller(&self) -> &super::ant::AntRef {
        &self.ant_controller
    }
}

impl CharacterStateBaseControllerDataTrait for CharacterStateConstantVelocityControllerData {
    fn asset_index(&self) -> &i32 {
        self._glacier_base.asset_index()
    }
    fn subjects(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>> {
        self._glacier_base.subjects()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for CharacterStateConstantVelocityControllerData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATECONSTANTVELOCITYCONTROLLERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateConstantVelocityControllerData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEBASECONTROLLERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateConstantVelocityControllerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "TargetVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(CharacterStateConstantVelocityControllerData, target_velocity),
            },
            FieldInfoData {
                name: "Weights",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(CharacterStateConstantVelocityControllerData, weights),
            },
            FieldInfoData {
                name: "RotateTargetVelocityAboutXChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateConstantVelocityControllerData, rotate_target_velocity_about_x_channel),
            },
            FieldInfoData {
                name: "ScaleRotationValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateConstantVelocityControllerData, scale_rotation_value),
            },
            FieldInfoData {
                name: "ClampRotationValueMin",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateConstantVelocityControllerData, clamp_rotation_value_min),
            },
            FieldInfoData {
                name: "ClampRotationValueMax",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateConstantVelocityControllerData, clamp_rotation_value_max),
            },
            FieldInfoData {
                name: "FollowLookDirection",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateConstantVelocityControllerData, follow_look_direction),
            },
            FieldInfoData {
                name: "MovementPitchChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateConstantVelocityControllerData, movement_pitch_channel),
            },
            FieldInfoData {
                name: "MovementYawChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateConstantVelocityControllerData, movement_yaw_channel),
            },
            FieldInfoData {
                name: "CurrentVelocityChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateConstantVelocityControllerData, current_velocity_channel),
            },
            FieldInfoData {
                name: "CurrentTransformChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(CharacterStateConstantVelocityControllerData, current_transform_channel),
            },
            FieldInfoData {
                name: "Acceleration",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateConstantVelocityControllerData, acceleration),
            },
            FieldInfoData {
                name: "AntController",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CharacterStateConstantVelocityControllerData, ant_controller),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATECONSTANTVELOCITYCONTROLLERDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CharacterStateConstantVelocityControllerData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATECONSTANTVELOCITYCONTROLLERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATECONSTANTVELOCITYCONTROLLERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateConstantVelocityControllerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateConstantVelocityControllerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateApplyFrictionControllerData {
    pub _glacier_base: CharacterStateBaseControllerData,
    pub dynamic_friction: f32,
    pub distance_to_ground_cutoff: f32,
    pub gravity: f32,
    pub velocity: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub ground_normal: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub distance_to_ground: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub acceleration: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub ant_controller: super::ant::AntRef,
}

pub trait CharacterStateApplyFrictionControllerDataTrait: CharacterStateBaseControllerDataTrait {
    fn dynamic_friction(&self) -> &f32;
    fn distance_to_ground_cutoff(&self) -> &f32;
    fn gravity(&self) -> &f32;
    fn velocity(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn ground_normal(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn distance_to_ground(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn acceleration(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn ant_controller(&self) -> &super::ant::AntRef;
}

impl CharacterStateApplyFrictionControllerDataTrait for CharacterStateApplyFrictionControllerData {
    fn dynamic_friction(&self) -> &f32 {
        &self.dynamic_friction
    }
    fn distance_to_ground_cutoff(&self) -> &f32 {
        &self.distance_to_ground_cutoff
    }
    fn gravity(&self) -> &f32 {
        &self.gravity
    }
    fn velocity(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.velocity
    }
    fn ground_normal(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.ground_normal
    }
    fn distance_to_ground(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.distance_to_ground
    }
    fn acceleration(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.acceleration
    }
    fn ant_controller(&self) -> &super::ant::AntRef {
        &self.ant_controller
    }
}

impl CharacterStateBaseControllerDataTrait for CharacterStateApplyFrictionControllerData {
    fn asset_index(&self) -> &i32 {
        self._glacier_base.asset_index()
    }
    fn subjects(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>> {
        self._glacier_base.subjects()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for CharacterStateApplyFrictionControllerData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATEAPPLYFRICTIONCONTROLLERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateApplyFrictionControllerData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEBASECONTROLLERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateApplyFrictionControllerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DynamicFriction",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateApplyFrictionControllerData, dynamic_friction),
            },
            FieldInfoData {
                name: "DistanceToGroundCutoff",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateApplyFrictionControllerData, distance_to_ground_cutoff),
            },
            FieldInfoData {
                name: "Gravity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateApplyFrictionControllerData, gravity),
            },
            FieldInfoData {
                name: "Velocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateApplyFrictionControllerData, velocity),
            },
            FieldInfoData {
                name: "GroundNormal",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateApplyFrictionControllerData, ground_normal),
            },
            FieldInfoData {
                name: "DistanceToGround",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateApplyFrictionControllerData, distance_to_ground),
            },
            FieldInfoData {
                name: "Acceleration",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateApplyFrictionControllerData, acceleration),
            },
            FieldInfoData {
                name: "AntController",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CharacterStateApplyFrictionControllerData, ant_controller),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEAPPLYFRICTIONCONTROLLERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateApplyFrictionControllerData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEAPPLYFRICTIONCONTROLLERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEAPPLYFRICTIONCONTROLLERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateApplyFrictionControllerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateApplyFrictionControllerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateFallWithGravityControllerData {
    pub _glacier_base: CharacterStateBaseControllerData,
    pub gravity: f32,
    pub drag: f32,
    pub drag_x_z_coefficient: f32,
    pub drag_x_z_start_speed: f32,
    pub acceleration: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub velocity: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub ant_controller: super::ant::AntRef,
}

pub trait CharacterStateFallWithGravityControllerDataTrait: CharacterStateBaseControllerDataTrait {
    fn gravity(&self) -> &f32;
    fn drag(&self) -> &f32;
    fn drag_x_z_coefficient(&self) -> &f32;
    fn drag_x_z_start_speed(&self) -> &f32;
    fn acceleration(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn velocity(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn ant_controller(&self) -> &super::ant::AntRef;
}

impl CharacterStateFallWithGravityControllerDataTrait for CharacterStateFallWithGravityControllerData {
    fn gravity(&self) -> &f32 {
        &self.gravity
    }
    fn drag(&self) -> &f32 {
        &self.drag
    }
    fn drag_x_z_coefficient(&self) -> &f32 {
        &self.drag_x_z_coefficient
    }
    fn drag_x_z_start_speed(&self) -> &f32 {
        &self.drag_x_z_start_speed
    }
    fn acceleration(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.acceleration
    }
    fn velocity(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.velocity
    }
    fn ant_controller(&self) -> &super::ant::AntRef {
        &self.ant_controller
    }
}

impl CharacterStateBaseControllerDataTrait for CharacterStateFallWithGravityControllerData {
    fn asset_index(&self) -> &i32 {
        self._glacier_base.asset_index()
    }
    fn subjects(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>> {
        self._glacier_base.subjects()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for CharacterStateFallWithGravityControllerData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATEFALLWITHGRAVITYCONTROLLERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateFallWithGravityControllerData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEBASECONTROLLERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateFallWithGravityControllerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Gravity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateFallWithGravityControllerData, gravity),
            },
            FieldInfoData {
                name: "Drag",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateFallWithGravityControllerData, drag),
            },
            FieldInfoData {
                name: "DragXZCoefficient",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateFallWithGravityControllerData, drag_x_z_coefficient),
            },
            FieldInfoData {
                name: "DragXZStartSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateFallWithGravityControllerData, drag_x_z_start_speed),
            },
            FieldInfoData {
                name: "Acceleration",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateFallWithGravityControllerData, acceleration),
            },
            FieldInfoData {
                name: "Velocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateFallWithGravityControllerData, velocity),
            },
            FieldInfoData {
                name: "AntController",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CharacterStateFallWithGravityControllerData, ant_controller),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEFALLWITHGRAVITYCONTROLLERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateFallWithGravityControllerData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEFALLWITHGRAVITYCONTROLLERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEFALLWITHGRAVITYCONTROLLERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateFallWithGravityControllerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateFallWithGravityControllerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateFollowGroundControllerData {
    pub _glacier_base: CharacterStateBaseControllerData,
    pub character_spring_scale_first_frame: f32,
    pub character_spring_scale_moving_under_terrain: f32,
    pub character_spring_scale_moving_over_terrain: f32,
    pub character_spring_scale_still: f32,
    pub fall_with_gravity_distance_from_ground: f32,
    pub gravity_when_falling: f32,
    pub target_offset: f32,
    pub distance_from_ground: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub enabled_channels: Vec<Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>>,
    pub acceleration: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub velocity: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub throttle_input: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub strafe_input: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub ant_controller: super::ant::AntRef,
}

pub trait CharacterStateFollowGroundControllerDataTrait: CharacterStateBaseControllerDataTrait {
    fn character_spring_scale_first_frame(&self) -> &f32;
    fn character_spring_scale_moving_under_terrain(&self) -> &f32;
    fn character_spring_scale_moving_over_terrain(&self) -> &f32;
    fn character_spring_scale_still(&self) -> &f32;
    fn fall_with_gravity_distance_from_ground(&self) -> &f32;
    fn gravity_when_falling(&self) -> &f32;
    fn target_offset(&self) -> &f32;
    fn distance_from_ground(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn enabled_channels(&self) -> &Vec<Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>>;
    fn acceleration(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn velocity(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn throttle_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn strafe_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn ant_controller(&self) -> &super::ant::AntRef;
}

impl CharacterStateFollowGroundControllerDataTrait for CharacterStateFollowGroundControllerData {
    fn character_spring_scale_first_frame(&self) -> &f32 {
        &self.character_spring_scale_first_frame
    }
    fn character_spring_scale_moving_under_terrain(&self) -> &f32 {
        &self.character_spring_scale_moving_under_terrain
    }
    fn character_spring_scale_moving_over_terrain(&self) -> &f32 {
        &self.character_spring_scale_moving_over_terrain
    }
    fn character_spring_scale_still(&self) -> &f32 {
        &self.character_spring_scale_still
    }
    fn fall_with_gravity_distance_from_ground(&self) -> &f32 {
        &self.fall_with_gravity_distance_from_ground
    }
    fn gravity_when_falling(&self) -> &f32 {
        &self.gravity_when_falling
    }
    fn target_offset(&self) -> &f32 {
        &self.target_offset
    }
    fn distance_from_ground(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.distance_from_ground
    }
    fn enabled_channels(&self) -> &Vec<Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>> {
        &self.enabled_channels
    }
    fn acceleration(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.acceleration
    }
    fn velocity(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.velocity
    }
    fn throttle_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.throttle_input
    }
    fn strafe_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.strafe_input
    }
    fn ant_controller(&self) -> &super::ant::AntRef {
        &self.ant_controller
    }
}

impl CharacterStateBaseControllerDataTrait for CharacterStateFollowGroundControllerData {
    fn asset_index(&self) -> &i32 {
        self._glacier_base.asset_index()
    }
    fn subjects(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>> {
        self._glacier_base.subjects()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for CharacterStateFollowGroundControllerData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATEFOLLOWGROUNDCONTROLLERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateFollowGroundControllerData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEBASECONTROLLERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateFollowGroundControllerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "CharacterSpringScaleFirstFrame",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateFollowGroundControllerData, character_spring_scale_first_frame),
            },
            FieldInfoData {
                name: "CharacterSpringScaleMovingUnderTerrain",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateFollowGroundControllerData, character_spring_scale_moving_under_terrain),
            },
            FieldInfoData {
                name: "CharacterSpringScaleMovingOverTerrain",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateFollowGroundControllerData, character_spring_scale_moving_over_terrain),
            },
            FieldInfoData {
                name: "CharacterSpringScaleStill",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateFollowGroundControllerData, character_spring_scale_still),
            },
            FieldInfoData {
                name: "FallWithGravityDistanceFromGround",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateFollowGroundControllerData, fall_with_gravity_distance_from_ground),
            },
            FieldInfoData {
                name: "GravityWhenFalling",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateFollowGroundControllerData, gravity_when_falling),
            },
            FieldInfoData {
                name: "TargetOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateFollowGroundControllerData, target_offset),
            },
            FieldInfoData {
                name: "DistanceFromGround",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateFollowGroundControllerData, distance_from_ground),
            },
            FieldInfoData {
                name: "EnabledChannels",
                flags: MemberInfoFlags::new(144),
                field_type: "BoolChannelData-Array",
                rust_offset: offset_of!(CharacterStateFollowGroundControllerData, enabled_channels),
            },
            FieldInfoData {
                name: "Acceleration",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateFollowGroundControllerData, acceleration),
            },
            FieldInfoData {
                name: "Velocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateFollowGroundControllerData, velocity),
            },
            FieldInfoData {
                name: "ThrottleInput",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateFollowGroundControllerData, throttle_input),
            },
            FieldInfoData {
                name: "StrafeInput",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateFollowGroundControllerData, strafe_input),
            },
            FieldInfoData {
                name: "AntController",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CharacterStateFollowGroundControllerData, ant_controller),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEFOLLOWGROUNDCONTROLLERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateFollowGroundControllerData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEFOLLOWGROUNDCONTROLLERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEFOLLOWGROUNDCONTROLLERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateFollowGroundControllerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateFollowGroundControllerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateCheckSupportControllerData {
    pub _glacier_base: CharacterStateBaseControllerData,
    pub current_motion_state: Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>,
    pub enable_closest_point_check: bool,
    pub closest_point_check_radius: f32,
    pub closest_point_max_x_z_velocity: f32,
    pub enable_height_diff_projection_in_on_ground_state: bool,
    pub enable_height_diff_projection_in_sliding_state: bool,
    pub enable_height_diff_projection_in_other_states: bool,
    pub closest_point_check_offset: super::core::Vec3,
    pub on_ground_action_state_index: i32,
    pub sliding_action_state_index: i32,
    pub step_height_value: f32,
    pub moving_step_height_value: f32,
    pub close_to_ground_threshold: f32,
    pub far_from_ground_threshold: f32,
    pub enter_swim_state_depth: f32,
    pub exit_swim_state_depth: f32,
    pub reject_characters: bool,
    pub check_support_raycast_collision_layer: super::physics::RigidBodyCollisionLayer,
    pub check_support_raycast_count_moving: i32,
    pub check_support_lookahead_distance: f32,
    pub ray_start_height_on_ground: f32,
    pub ray_end_height_on_ground: f32,
    pub triangle_ray_start_height: f32,
    pub triangle_ray_end_height: f32,
    pub ray_start_height_in_air: f32,
    pub ray_end_height_in_air: f32,
    pub speed_for_moving_ray_casts: f32,
    pub physical_radius: f32,
    pub slide_angle: f32,
    pub enabled_channels: Vec<Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>>,
    pub is_supported_channel: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub in_water_channel: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub distance_to_water_surface_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub is_sliding_channel: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub is_close_to_ground: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub is_far_from_ground: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub supported_next_frame_channel: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub distance_from_ground_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub normal_channel: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub ground_velocity_channel: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub step_height: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub position: Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>,
    pub current_velocity: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub throttle_input: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub strafe_input: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub ground_material_channel: Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>,
    pub ground_sound_material_id: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub ant_controller: super::ant::AntRef,
}

pub trait CharacterStateCheckSupportControllerDataTrait: CharacterStateBaseControllerDataTrait {
    fn current_motion_state(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>;
    fn enable_closest_point_check(&self) -> &bool;
    fn closest_point_check_radius(&self) -> &f32;
    fn closest_point_max_x_z_velocity(&self) -> &f32;
    fn enable_height_diff_projection_in_on_ground_state(&self) -> &bool;
    fn enable_height_diff_projection_in_sliding_state(&self) -> &bool;
    fn enable_height_diff_projection_in_other_states(&self) -> &bool;
    fn closest_point_check_offset(&self) -> &super::core::Vec3;
    fn on_ground_action_state_index(&self) -> &i32;
    fn sliding_action_state_index(&self) -> &i32;
    fn step_height_value(&self) -> &f32;
    fn moving_step_height_value(&self) -> &f32;
    fn close_to_ground_threshold(&self) -> &f32;
    fn far_from_ground_threshold(&self) -> &f32;
    fn enter_swim_state_depth(&self) -> &f32;
    fn exit_swim_state_depth(&self) -> &f32;
    fn reject_characters(&self) -> &bool;
    fn check_support_raycast_collision_layer(&self) -> &super::physics::RigidBodyCollisionLayer;
    fn check_support_raycast_count_moving(&self) -> &i32;
    fn check_support_lookahead_distance(&self) -> &f32;
    fn ray_start_height_on_ground(&self) -> &f32;
    fn ray_end_height_on_ground(&self) -> &f32;
    fn triangle_ray_start_height(&self) -> &f32;
    fn triangle_ray_end_height(&self) -> &f32;
    fn ray_start_height_in_air(&self) -> &f32;
    fn ray_end_height_in_air(&self) -> &f32;
    fn speed_for_moving_ray_casts(&self) -> &f32;
    fn physical_radius(&self) -> &f32;
    fn slide_angle(&self) -> &f32;
    fn enabled_channels(&self) -> &Vec<Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>>;
    fn is_supported_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn in_water_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn distance_to_water_surface_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn is_sliding_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn is_close_to_ground(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn is_far_from_ground(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn supported_next_frame_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn distance_from_ground_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn normal_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn ground_velocity_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn step_height(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn position(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>;
    fn current_velocity(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn throttle_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn strafe_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn ground_material_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>;
    fn ground_sound_material_id(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn ant_controller(&self) -> &super::ant::AntRef;
}

impl CharacterStateCheckSupportControllerDataTrait for CharacterStateCheckSupportControllerData {
    fn current_motion_state(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>> {
        &self.current_motion_state
    }
    fn enable_closest_point_check(&self) -> &bool {
        &self.enable_closest_point_check
    }
    fn closest_point_check_radius(&self) -> &f32 {
        &self.closest_point_check_radius
    }
    fn closest_point_max_x_z_velocity(&self) -> &f32 {
        &self.closest_point_max_x_z_velocity
    }
    fn enable_height_diff_projection_in_on_ground_state(&self) -> &bool {
        &self.enable_height_diff_projection_in_on_ground_state
    }
    fn enable_height_diff_projection_in_sliding_state(&self) -> &bool {
        &self.enable_height_diff_projection_in_sliding_state
    }
    fn enable_height_diff_projection_in_other_states(&self) -> &bool {
        &self.enable_height_diff_projection_in_other_states
    }
    fn closest_point_check_offset(&self) -> &super::core::Vec3 {
        &self.closest_point_check_offset
    }
    fn on_ground_action_state_index(&self) -> &i32 {
        &self.on_ground_action_state_index
    }
    fn sliding_action_state_index(&self) -> &i32 {
        &self.sliding_action_state_index
    }
    fn step_height_value(&self) -> &f32 {
        &self.step_height_value
    }
    fn moving_step_height_value(&self) -> &f32 {
        &self.moving_step_height_value
    }
    fn close_to_ground_threshold(&self) -> &f32 {
        &self.close_to_ground_threshold
    }
    fn far_from_ground_threshold(&self) -> &f32 {
        &self.far_from_ground_threshold
    }
    fn enter_swim_state_depth(&self) -> &f32 {
        &self.enter_swim_state_depth
    }
    fn exit_swim_state_depth(&self) -> &f32 {
        &self.exit_swim_state_depth
    }
    fn reject_characters(&self) -> &bool {
        &self.reject_characters
    }
    fn check_support_raycast_collision_layer(&self) -> &super::physics::RigidBodyCollisionLayer {
        &self.check_support_raycast_collision_layer
    }
    fn check_support_raycast_count_moving(&self) -> &i32 {
        &self.check_support_raycast_count_moving
    }
    fn check_support_lookahead_distance(&self) -> &f32 {
        &self.check_support_lookahead_distance
    }
    fn ray_start_height_on_ground(&self) -> &f32 {
        &self.ray_start_height_on_ground
    }
    fn ray_end_height_on_ground(&self) -> &f32 {
        &self.ray_end_height_on_ground
    }
    fn triangle_ray_start_height(&self) -> &f32 {
        &self.triangle_ray_start_height
    }
    fn triangle_ray_end_height(&self) -> &f32 {
        &self.triangle_ray_end_height
    }
    fn ray_start_height_in_air(&self) -> &f32 {
        &self.ray_start_height_in_air
    }
    fn ray_end_height_in_air(&self) -> &f32 {
        &self.ray_end_height_in_air
    }
    fn speed_for_moving_ray_casts(&self) -> &f32 {
        &self.speed_for_moving_ray_casts
    }
    fn physical_radius(&self) -> &f32 {
        &self.physical_radius
    }
    fn slide_angle(&self) -> &f32 {
        &self.slide_angle
    }
    fn enabled_channels(&self) -> &Vec<Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>> {
        &self.enabled_channels
    }
    fn is_supported_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.is_supported_channel
    }
    fn in_water_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.in_water_channel
    }
    fn distance_to_water_surface_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.distance_to_water_surface_channel
    }
    fn is_sliding_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.is_sliding_channel
    }
    fn is_close_to_ground(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.is_close_to_ground
    }
    fn is_far_from_ground(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.is_far_from_ground
    }
    fn supported_next_frame_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.supported_next_frame_channel
    }
    fn distance_from_ground_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.distance_from_ground_channel
    }
    fn normal_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.normal_channel
    }
    fn ground_velocity_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.ground_velocity_channel
    }
    fn step_height(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.step_height
    }
    fn position(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>> {
        &self.position
    }
    fn current_velocity(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.current_velocity
    }
    fn throttle_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.throttle_input
    }
    fn strafe_input(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.strafe_input
    }
    fn ground_material_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>> {
        &self.ground_material_channel
    }
    fn ground_sound_material_id(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.ground_sound_material_id
    }
    fn ant_controller(&self) -> &super::ant::AntRef {
        &self.ant_controller
    }
}

impl CharacterStateBaseControllerDataTrait for CharacterStateCheckSupportControllerData {
    fn asset_index(&self) -> &i32 {
        self._glacier_base.asset_index()
    }
    fn subjects(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>> {
        self._glacier_base.subjects()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for CharacterStateCheckSupportControllerData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATECHECKSUPPORTCONTROLLERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateCheckSupportControllerData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEBASECONTROLLERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateCheckSupportControllerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "CurrentMotionState",
                flags: MemberInfoFlags::new(0),
                field_type: "IntChannelData",
                rust_offset: offset_of!(CharacterStateCheckSupportControllerData, current_motion_state),
            },
            FieldInfoData {
                name: "EnableClosestPointCheck",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateCheckSupportControllerData, enable_closest_point_check),
            },
            FieldInfoData {
                name: "ClosestPointCheckRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateCheckSupportControllerData, closest_point_check_radius),
            },
            FieldInfoData {
                name: "ClosestPointMaxXZVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateCheckSupportControllerData, closest_point_max_x_z_velocity),
            },
            FieldInfoData {
                name: "EnableHeightDiffProjectionInOnGroundState",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateCheckSupportControllerData, enable_height_diff_projection_in_on_ground_state),
            },
            FieldInfoData {
                name: "EnableHeightDiffProjectionInSlidingState",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateCheckSupportControllerData, enable_height_diff_projection_in_sliding_state),
            },
            FieldInfoData {
                name: "EnableHeightDiffProjectionInOtherStates",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateCheckSupportControllerData, enable_height_diff_projection_in_other_states),
            },
            FieldInfoData {
                name: "ClosestPointCheckOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(CharacterStateCheckSupportControllerData, closest_point_check_offset),
            },
            FieldInfoData {
                name: "OnGroundActionStateIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CharacterStateCheckSupportControllerData, on_ground_action_state_index),
            },
            FieldInfoData {
                name: "SlidingActionStateIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CharacterStateCheckSupportControllerData, sliding_action_state_index),
            },
            FieldInfoData {
                name: "StepHeightValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateCheckSupportControllerData, step_height_value),
            },
            FieldInfoData {
                name: "MovingStepHeightValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateCheckSupportControllerData, moving_step_height_value),
            },
            FieldInfoData {
                name: "CloseToGroundThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateCheckSupportControllerData, close_to_ground_threshold),
            },
            FieldInfoData {
                name: "FarFromGroundThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateCheckSupportControllerData, far_from_ground_threshold),
            },
            FieldInfoData {
                name: "EnterSwimStateDepth",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateCheckSupportControllerData, enter_swim_state_depth),
            },
            FieldInfoData {
                name: "ExitSwimStateDepth",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateCheckSupportControllerData, exit_swim_state_depth),
            },
            FieldInfoData {
                name: "RejectCharacters",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateCheckSupportControllerData, reject_characters),
            },
            FieldInfoData {
                name: "CheckSupportRaycastCollisionLayer",
                flags: MemberInfoFlags::new(0),
                field_type: "RigidBodyCollisionLayer",
                rust_offset: offset_of!(CharacterStateCheckSupportControllerData, check_support_raycast_collision_layer),
            },
            FieldInfoData {
                name: "CheckSupportRaycastCountMoving",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CharacterStateCheckSupportControllerData, check_support_raycast_count_moving),
            },
            FieldInfoData {
                name: "CheckSupportLookaheadDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateCheckSupportControllerData, check_support_lookahead_distance),
            },
            FieldInfoData {
                name: "RayStartHeightOnGround",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateCheckSupportControllerData, ray_start_height_on_ground),
            },
            FieldInfoData {
                name: "RayEndHeightOnGround",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateCheckSupportControllerData, ray_end_height_on_ground),
            },
            FieldInfoData {
                name: "TriangleRayStartHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateCheckSupportControllerData, triangle_ray_start_height),
            },
            FieldInfoData {
                name: "TriangleRayEndHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateCheckSupportControllerData, triangle_ray_end_height),
            },
            FieldInfoData {
                name: "RayStartHeightInAir",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateCheckSupportControllerData, ray_start_height_in_air),
            },
            FieldInfoData {
                name: "RayEndHeightInAir",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateCheckSupportControllerData, ray_end_height_in_air),
            },
            FieldInfoData {
                name: "SpeedForMovingRayCasts",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateCheckSupportControllerData, speed_for_moving_ray_casts),
            },
            FieldInfoData {
                name: "PhysicalRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateCheckSupportControllerData, physical_radius),
            },
            FieldInfoData {
                name: "SlideAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateCheckSupportControllerData, slide_angle),
            },
            FieldInfoData {
                name: "EnabledChannels",
                flags: MemberInfoFlags::new(144),
                field_type: "BoolChannelData-Array",
                rust_offset: offset_of!(CharacterStateCheckSupportControllerData, enabled_channels),
            },
            FieldInfoData {
                name: "IsSupportedChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(CharacterStateCheckSupportControllerData, is_supported_channel),
            },
            FieldInfoData {
                name: "InWaterChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(CharacterStateCheckSupportControllerData, in_water_channel),
            },
            FieldInfoData {
                name: "DistanceToWaterSurfaceChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateCheckSupportControllerData, distance_to_water_surface_channel),
            },
            FieldInfoData {
                name: "IsSlidingChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(CharacterStateCheckSupportControllerData, is_sliding_channel),
            },
            FieldInfoData {
                name: "IsCloseToGround",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(CharacterStateCheckSupportControllerData, is_close_to_ground),
            },
            FieldInfoData {
                name: "IsFarFromGround",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(CharacterStateCheckSupportControllerData, is_far_from_ground),
            },
            FieldInfoData {
                name: "SupportedNextFrameChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(CharacterStateCheckSupportControllerData, supported_next_frame_channel),
            },
            FieldInfoData {
                name: "DistanceFromGroundChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateCheckSupportControllerData, distance_from_ground_channel),
            },
            FieldInfoData {
                name: "NormalChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateCheckSupportControllerData, normal_channel),
            },
            FieldInfoData {
                name: "GroundVelocityChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateCheckSupportControllerData, ground_velocity_channel),
            },
            FieldInfoData {
                name: "StepHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateCheckSupportControllerData, step_height),
            },
            FieldInfoData {
                name: "Position",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(CharacterStateCheckSupportControllerData, position),
            },
            FieldInfoData {
                name: "CurrentVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateCheckSupportControllerData, current_velocity),
            },
            FieldInfoData {
                name: "ThrottleInput",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateCheckSupportControllerData, throttle_input),
            },
            FieldInfoData {
                name: "StrafeInput",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateCheckSupportControllerData, strafe_input),
            },
            FieldInfoData {
                name: "GroundMaterialChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "IntChannelData",
                rust_offset: offset_of!(CharacterStateCheckSupportControllerData, ground_material_channel),
            },
            FieldInfoData {
                name: "GroundSoundMaterialId",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateCheckSupportControllerData, ground_sound_material_id),
            },
            FieldInfoData {
                name: "AntController",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CharacterStateCheckSupportControllerData, ant_controller),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATECHECKSUPPORTCONTROLLERDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CharacterStateCheckSupportControllerData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATECHECKSUPPORTCONTROLLERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATECHECKSUPPORTCONTROLLERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateCheckSupportControllerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateCheckSupportControllerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStatePoseControllerData {
    pub _glacier_base: CharacterStateBaseControllerData,
    pub poses: Vec<Option<Arc<Mutex<dyn super::physics::CharacterPoseDataTrait>>>>,
    pub pose_infos: Vec<Option<Arc<Mutex<dyn super::physics::CharacterStatePoseInfoTrait>>>>,
    pub allow_pose_change_during_transition: bool,
    pub sprinting: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub desired_pose: Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>,
    pub override_desired_pose_with_stand: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub current_pose: Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>,
    pub changing_to_pose: Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>,
    pub step_height: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub max_speed: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub local_eye_position_channel: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub ant_controller: super::ant::AntRef,
}

pub trait CharacterStatePoseControllerDataTrait: CharacterStateBaseControllerDataTrait {
    fn poses(&self) -> &Vec<Option<Arc<Mutex<dyn super::physics::CharacterPoseDataTrait>>>>;
    fn pose_infos(&self) -> &Vec<Option<Arc<Mutex<dyn super::physics::CharacterStatePoseInfoTrait>>>>;
    fn allow_pose_change_during_transition(&self) -> &bool;
    fn sprinting(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn desired_pose(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>;
    fn override_desired_pose_with_stand(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn current_pose(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>;
    fn changing_to_pose(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>;
    fn step_height(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn max_speed(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn local_eye_position_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn ant_controller(&self) -> &super::ant::AntRef;
}

impl CharacterStatePoseControllerDataTrait for CharacterStatePoseControllerData {
    fn poses(&self) -> &Vec<Option<Arc<Mutex<dyn super::physics::CharacterPoseDataTrait>>>> {
        &self.poses
    }
    fn pose_infos(&self) -> &Vec<Option<Arc<Mutex<dyn super::physics::CharacterStatePoseInfoTrait>>>> {
        &self.pose_infos
    }
    fn allow_pose_change_during_transition(&self) -> &bool {
        &self.allow_pose_change_during_transition
    }
    fn sprinting(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.sprinting
    }
    fn desired_pose(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>> {
        &self.desired_pose
    }
    fn override_desired_pose_with_stand(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.override_desired_pose_with_stand
    }
    fn current_pose(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>> {
        &self.current_pose
    }
    fn changing_to_pose(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>> {
        &self.changing_to_pose
    }
    fn step_height(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.step_height
    }
    fn max_speed(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.max_speed
    }
    fn local_eye_position_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.local_eye_position_channel
    }
    fn ant_controller(&self) -> &super::ant::AntRef {
        &self.ant_controller
    }
}

impl CharacterStateBaseControllerDataTrait for CharacterStatePoseControllerData {
    fn asset_index(&self) -> &i32 {
        self._glacier_base.asset_index()
    }
    fn subjects(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>> {
        self._glacier_base.subjects()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for CharacterStatePoseControllerData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATEPOSECONTROLLERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStatePoseControllerData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEBASECONTROLLERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStatePoseControllerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Poses",
                flags: MemberInfoFlags::new(144),
                field_type: "CharacterPoseData-Array",
                rust_offset: offset_of!(CharacterStatePoseControllerData, poses),
            },
            FieldInfoData {
                name: "PoseInfos",
                flags: MemberInfoFlags::new(144),
                field_type: "CharacterStatePoseInfo-Array",
                rust_offset: offset_of!(CharacterStatePoseControllerData, pose_infos),
            },
            FieldInfoData {
                name: "AllowPoseChangeDuringTransition",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStatePoseControllerData, allow_pose_change_during_transition),
            },
            FieldInfoData {
                name: "Sprinting",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(CharacterStatePoseControllerData, sprinting),
            },
            FieldInfoData {
                name: "DesiredPose",
                flags: MemberInfoFlags::new(0),
                field_type: "IntChannelData",
                rust_offset: offset_of!(CharacterStatePoseControllerData, desired_pose),
            },
            FieldInfoData {
                name: "OverrideDesiredPoseWithStand",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(CharacterStatePoseControllerData, override_desired_pose_with_stand),
            },
            FieldInfoData {
                name: "CurrentPose",
                flags: MemberInfoFlags::new(0),
                field_type: "IntChannelData",
                rust_offset: offset_of!(CharacterStatePoseControllerData, current_pose),
            },
            FieldInfoData {
                name: "ChangingToPose",
                flags: MemberInfoFlags::new(0),
                field_type: "IntChannelData",
                rust_offset: offset_of!(CharacterStatePoseControllerData, changing_to_pose),
            },
            FieldInfoData {
                name: "StepHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStatePoseControllerData, step_height),
            },
            FieldInfoData {
                name: "MaxSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStatePoseControllerData, max_speed),
            },
            FieldInfoData {
                name: "LocalEyePositionChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStatePoseControllerData, local_eye_position_channel),
            },
            FieldInfoData {
                name: "AntController",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CharacterStatePoseControllerData, ant_controller),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEPOSECONTROLLERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStatePoseControllerData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEPOSECONTROLLERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEPOSECONTROLLERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStatePoseControllerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStatePoseControllerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateAuthoritativeMotionControllerData {
    pub _glacier_base: CharacterStateBaseControllerData,
    pub authoritative_velocity: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub current_velocity: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub ant_controller: super::ant::AntRef,
}

pub trait CharacterStateAuthoritativeMotionControllerDataTrait: CharacterStateBaseControllerDataTrait {
    fn authoritative_velocity(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn current_velocity(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn ant_controller(&self) -> &super::ant::AntRef;
}

impl CharacterStateAuthoritativeMotionControllerDataTrait for CharacterStateAuthoritativeMotionControllerData {
    fn authoritative_velocity(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.authoritative_velocity
    }
    fn current_velocity(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.current_velocity
    }
    fn ant_controller(&self) -> &super::ant::AntRef {
        &self.ant_controller
    }
}

impl CharacterStateBaseControllerDataTrait for CharacterStateAuthoritativeMotionControllerData {
    fn asset_index(&self) -> &i32 {
        self._glacier_base.asset_index()
    }
    fn subjects(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>> {
        self._glacier_base.subjects()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for CharacterStateAuthoritativeMotionControllerData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATEAUTHORITATIVEMOTIONCONTROLLERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateAuthoritativeMotionControllerData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEBASECONTROLLERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateAuthoritativeMotionControllerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AuthoritativeVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateAuthoritativeMotionControllerData, authoritative_velocity),
            },
            FieldInfoData {
                name: "CurrentVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateAuthoritativeMotionControllerData, current_velocity),
            },
            FieldInfoData {
                name: "AntController",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CharacterStateAuthoritativeMotionControllerData, ant_controller),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEAUTHORITATIVEMOTIONCONTROLLERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateAuthoritativeMotionControllerData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEAUTHORITATIVEMOTIONCONTROLLERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEAUTHORITATIVEMOTIONCONTROLLERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateAuthoritativeMotionControllerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateAuthoritativeMotionControllerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateNetworkEndControllerData {
    pub _glacier_base: CharacterStateBaseControllerData,
    pub length: u32,
    pub wrap_phase: bool,
    pub ant_controller: super::ant::AntRef,
}

pub trait CharacterStateNetworkEndControllerDataTrait: CharacterStateBaseControllerDataTrait {
    fn length(&self) -> &u32;
    fn wrap_phase(&self) -> &bool;
    fn ant_controller(&self) -> &super::ant::AntRef;
}

impl CharacterStateNetworkEndControllerDataTrait for CharacterStateNetworkEndControllerData {
    fn length(&self) -> &u32 {
        &self.length
    }
    fn wrap_phase(&self) -> &bool {
        &self.wrap_phase
    }
    fn ant_controller(&self) -> &super::ant::AntRef {
        &self.ant_controller
    }
}

impl CharacterStateBaseControllerDataTrait for CharacterStateNetworkEndControllerData {
    fn asset_index(&self) -> &i32 {
        self._glacier_base.asset_index()
    }
    fn subjects(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>> {
        self._glacier_base.subjects()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for CharacterStateNetworkEndControllerData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATENETWORKENDCONTROLLERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateNetworkEndControllerData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEBASECONTROLLERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateNetworkEndControllerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Length",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(CharacterStateNetworkEndControllerData, length),
            },
            FieldInfoData {
                name: "WrapPhase",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateNetworkEndControllerData, wrap_phase),
            },
            FieldInfoData {
                name: "AntController",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CharacterStateNetworkEndControllerData, ant_controller),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATENETWORKENDCONTROLLERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateNetworkEndControllerData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATENETWORKENDCONTROLLERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATENETWORKENDCONTROLLERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateNetworkEndControllerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateNetworkEndControllerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateMirrorControllerData {
    pub _glacier_base: CharacterStateBaseControllerData,
}

pub trait CharacterStateMirrorControllerDataTrait: CharacterStateBaseControllerDataTrait {
}

impl CharacterStateMirrorControllerDataTrait for CharacterStateMirrorControllerData {
}

impl CharacterStateBaseControllerDataTrait for CharacterStateMirrorControllerData {
    fn asset_index(&self) -> &i32 {
        self._glacier_base.asset_index()
    }
    fn subjects(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>> {
        self._glacier_base.subjects()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for CharacterStateMirrorControllerData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATEMIRRORCONTROLLERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateMirrorControllerData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEBASECONTROLLERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateMirrorControllerData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(CHARACTERSTATEMIRRORCONTROLLERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateMirrorControllerData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEMIRRORCONTROLLERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEMIRRORCONTROLLERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateMirrorControllerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateMirrorControllerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateLayerControllerData {
    pub _glacier_base: CharacterStateBaseControllerData,
    pub layer_infos: Vec<LayerElementInfo>,
}

pub trait CharacterStateLayerControllerDataTrait: CharacterStateBaseControllerDataTrait {
    fn layer_infos(&self) -> &Vec<LayerElementInfo>;
}

impl CharacterStateLayerControllerDataTrait for CharacterStateLayerControllerData {
    fn layer_infos(&self) -> &Vec<LayerElementInfo> {
        &self.layer_infos
    }
}

impl CharacterStateBaseControllerDataTrait for CharacterStateLayerControllerData {
    fn asset_index(&self) -> &i32 {
        self._glacier_base.asset_index()
    }
    fn subjects(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>> {
        self._glacier_base.subjects()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for CharacterStateLayerControllerData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATELAYERCONTROLLERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateLayerControllerData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEBASECONTROLLERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateLayerControllerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "LayerInfos",
                flags: MemberInfoFlags::new(144),
                field_type: "LayerElementInfo-Array",
                rust_offset: offset_of!(CharacterStateLayerControllerData, layer_infos),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATELAYERCONTROLLERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateLayerControllerData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATELAYERCONTROLLERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATELAYERCONTROLLERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateLayerControllerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateLayerControllerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LayerElementInfo {
    pub weight: f32,
    pub element_blend_mode: BlendMode,
}

pub trait LayerElementInfoTrait: TypeObject {
    fn weight(&self) -> &f32;
    fn element_blend_mode(&self) -> &BlendMode;
}

impl LayerElementInfoTrait for LayerElementInfo {
    fn weight(&self) -> &f32 {
        &self.weight
    }
    fn element_blend_mode(&self) -> &BlendMode {
        &self.element_blend_mode
    }
}

pub static LAYERELEMENTINFO_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LayerElementInfo",
    flags: MemberInfoFlags::new(36937),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LayerElementInfo as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Weight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LayerElementInfo, weight),
            },
            FieldInfoData {
                name: "ElementBlendMode",
                flags: MemberInfoFlags::new(0),
                field_type: "BlendMode",
                rust_offset: offset_of!(LayerElementInfo, element_blend_mode),
            },
        ],
    }),
    array_type: Some(LAYERELEMENTINFO_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for LayerElementInfo {
    fn type_info(&self) -> &'static TypeInfo {
        LAYERELEMENTINFO_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static LAYERELEMENTINFO_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LayerElementInfo-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("LayerElementInfo"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum BlendMode {
    #[default]
    BlendMode_Blend = 0,
    BlendMode_Additive = 1,
    BlendMode_Subtractive = 2,
}

pub static BLENDMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BlendMode",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(BLENDMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for BlendMode {
    fn type_info(&self) -> &'static TypeInfo {
        BLENDMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static BLENDMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BlendMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("BlendMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateKeyframedVec3ChannelControllerData {
    pub _glacier_base: CharacterStateBaseControllerData,
    pub tracks: Vec<CharacterStateVec3TrackData>,
    pub channels: Vec<Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>>,
}

pub trait CharacterStateKeyframedVec3ChannelControllerDataTrait: CharacterStateBaseControllerDataTrait {
    fn tracks(&self) -> &Vec<CharacterStateVec3TrackData>;
    fn channels(&self) -> &Vec<Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>>;
}

impl CharacterStateKeyframedVec3ChannelControllerDataTrait for CharacterStateKeyframedVec3ChannelControllerData {
    fn tracks(&self) -> &Vec<CharacterStateVec3TrackData> {
        &self.tracks
    }
    fn channels(&self) -> &Vec<Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>> {
        &self.channels
    }
}

impl CharacterStateBaseControllerDataTrait for CharacterStateKeyframedVec3ChannelControllerData {
    fn asset_index(&self) -> &i32 {
        self._glacier_base.asset_index()
    }
    fn subjects(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>> {
        self._glacier_base.subjects()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for CharacterStateKeyframedVec3ChannelControllerData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATEKEYFRAMEDVEC3CHANNELCONTROLLERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateKeyframedVec3ChannelControllerData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEBASECONTROLLERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateKeyframedVec3ChannelControllerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Tracks",
                flags: MemberInfoFlags::new(144),
                field_type: "CharacterStateVec3TrackData-Array",
                rust_offset: offset_of!(CharacterStateKeyframedVec3ChannelControllerData, tracks),
            },
            FieldInfoData {
                name: "Channels",
                flags: MemberInfoFlags::new(144),
                field_type: "Vec3ChannelData-Array",
                rust_offset: offset_of!(CharacterStateKeyframedVec3ChannelControllerData, channels),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEKEYFRAMEDVEC3CHANNELCONTROLLERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateKeyframedVec3ChannelControllerData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEKEYFRAMEDVEC3CHANNELCONTROLLERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEKEYFRAMEDVEC3CHANNELCONTROLLERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateKeyframedVec3ChannelControllerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateKeyframedVec3ChannelControllerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateVec3TrackData {
    pub vec3_tags: Vec<CharacterStateVec3TagData>,
}

pub trait CharacterStateVec3TrackDataTrait: TypeObject {
    fn vec3_tags(&self) -> &Vec<CharacterStateVec3TagData>;
}

impl CharacterStateVec3TrackDataTrait for CharacterStateVec3TrackData {
    fn vec3_tags(&self) -> &Vec<CharacterStateVec3TagData> {
        &self.vec3_tags
    }
}

pub static CHARACTERSTATEVEC3TRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateVec3TrackData",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateVec3TrackData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Vec3Tags",
                flags: MemberInfoFlags::new(144),
                field_type: "CharacterStateVec3TagData-Array",
                rust_offset: offset_of!(CharacterStateVec3TrackData, vec3_tags),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEVEC3TRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateVec3TrackData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEVEC3TRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEVEC3TRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateVec3TrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateVec3TrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateVec3TagData {
    pub copy_from: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub keyframes: Vec<Vec3KeyFrameData>,
    pub reset_mode: TagResetMode,
    pub reset_value: super::core::Vec3,
    pub time: u32,
    pub duration: u32,
}

pub trait CharacterStateVec3TagDataTrait: TypeObject {
    fn copy_from(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn keyframes(&self) -> &Vec<Vec3KeyFrameData>;
    fn reset_mode(&self) -> &TagResetMode;
    fn reset_value(&self) -> &super::core::Vec3;
    fn time(&self) -> &u32;
    fn duration(&self) -> &u32;
}

impl CharacterStateVec3TagDataTrait for CharacterStateVec3TagData {
    fn copy_from(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.copy_from
    }
    fn keyframes(&self) -> &Vec<Vec3KeyFrameData> {
        &self.keyframes
    }
    fn reset_mode(&self) -> &TagResetMode {
        &self.reset_mode
    }
    fn reset_value(&self) -> &super::core::Vec3 {
        &self.reset_value
    }
    fn time(&self) -> &u32 {
        &self.time
    }
    fn duration(&self) -> &u32 {
        &self.duration
    }
}

pub static CHARACTERSTATEVEC3TAGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateVec3TagData",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateVec3TagData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "CopyFrom",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateVec3TagData, copy_from),
            },
            FieldInfoData {
                name: "Keyframes",
                flags: MemberInfoFlags::new(144),
                field_type: "Vec3KeyFrameData-Array",
                rust_offset: offset_of!(CharacterStateVec3TagData, keyframes),
            },
            FieldInfoData {
                name: "ResetMode",
                flags: MemberInfoFlags::new(0),
                field_type: "TagResetMode",
                rust_offset: offset_of!(CharacterStateVec3TagData, reset_mode),
            },
            FieldInfoData {
                name: "ResetValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(CharacterStateVec3TagData, reset_value),
            },
            FieldInfoData {
                name: "Time",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(CharacterStateVec3TagData, time),
            },
            FieldInfoData {
                name: "Duration",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(CharacterStateVec3TagData, duration),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEVEC3TAGDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CharacterStateVec3TagData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEVEC3TAGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEVEC3TAGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateVec3TagData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateVec3TagData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Vec3KeyFrameData {
    pub on: bool,
    pub time: f32,
    pub value: super::core::Vec3,
}

pub trait Vec3KeyFrameDataTrait: TypeObject {
    fn on(&self) -> &bool;
    fn time(&self) -> &f32;
    fn value(&self) -> &super::core::Vec3;
}

impl Vec3KeyFrameDataTrait for Vec3KeyFrameData {
    fn on(&self) -> &bool {
        &self.on
    }
    fn time(&self) -> &f32 {
        &self.time
    }
    fn value(&self) -> &super::core::Vec3 {
        &self.value
    }
}

pub static VEC3KEYFRAMEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3KeyFrameData",
    flags: MemberInfoFlags::new(36937),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec3KeyFrameData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "On",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(Vec3KeyFrameData, on),
            },
            FieldInfoData {
                name: "Time",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(Vec3KeyFrameData, time),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(Vec3KeyFrameData, value),
            },
        ],
    }),
    array_type: Some(VEC3KEYFRAMEDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for Vec3KeyFrameData {
    fn type_info(&self) -> &'static TypeInfo {
        VEC3KEYFRAMEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VEC3KEYFRAMEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3KeyFrameData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("Vec3KeyFrameData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateKeyframedTransformChannelControllerData {
    pub _glacier_base: CharacterStateBaseControllerData,
    pub tracks: Vec<CharacterStateTransformTrackData>,
    pub channels: Vec<Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>>,
}

pub trait CharacterStateKeyframedTransformChannelControllerDataTrait: CharacterStateBaseControllerDataTrait {
    fn tracks(&self) -> &Vec<CharacterStateTransformTrackData>;
    fn channels(&self) -> &Vec<Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>>;
}

impl CharacterStateKeyframedTransformChannelControllerDataTrait for CharacterStateKeyframedTransformChannelControllerData {
    fn tracks(&self) -> &Vec<CharacterStateTransformTrackData> {
        &self.tracks
    }
    fn channels(&self) -> &Vec<Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>> {
        &self.channels
    }
}

impl CharacterStateBaseControllerDataTrait for CharacterStateKeyframedTransformChannelControllerData {
    fn asset_index(&self) -> &i32 {
        self._glacier_base.asset_index()
    }
    fn subjects(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>> {
        self._glacier_base.subjects()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for CharacterStateKeyframedTransformChannelControllerData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATEKEYFRAMEDTRANSFORMCHANNELCONTROLLERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateKeyframedTransformChannelControllerData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEBASECONTROLLERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateKeyframedTransformChannelControllerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Tracks",
                flags: MemberInfoFlags::new(144),
                field_type: "CharacterStateTransformTrackData-Array",
                rust_offset: offset_of!(CharacterStateKeyframedTransformChannelControllerData, tracks),
            },
            FieldInfoData {
                name: "Channels",
                flags: MemberInfoFlags::new(144),
                field_type: "TransformChannelData-Array",
                rust_offset: offset_of!(CharacterStateKeyframedTransformChannelControllerData, channels),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEKEYFRAMEDTRANSFORMCHANNELCONTROLLERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateKeyframedTransformChannelControllerData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEKEYFRAMEDTRANSFORMCHANNELCONTROLLERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEKEYFRAMEDTRANSFORMCHANNELCONTROLLERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateKeyframedTransformChannelControllerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateKeyframedTransformChannelControllerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateTransformTrackData {
    pub keyframes: Vec<TransformKeyFrameData>,
}

pub trait CharacterStateTransformTrackDataTrait: TypeObject {
    fn keyframes(&self) -> &Vec<TransformKeyFrameData>;
}

impl CharacterStateTransformTrackDataTrait for CharacterStateTransformTrackData {
    fn keyframes(&self) -> &Vec<TransformKeyFrameData> {
        &self.keyframes
    }
}

pub static CHARACTERSTATETRANSFORMTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateTransformTrackData",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateTransformTrackData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Keyframes",
                flags: MemberInfoFlags::new(144),
                field_type: "TransformKeyFrameData-Array",
                rust_offset: offset_of!(CharacterStateTransformTrackData, keyframes),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATETRANSFORMTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateTransformTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATETRANSFORMTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATETRANSFORMTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateTransformTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateTransformTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TransformKeyFrameData {
    pub on: bool,
    pub time: u32,
    pub value: super::core::LinearTransform,
}

pub trait TransformKeyFrameDataTrait: TypeObject {
    fn on(&self) -> &bool;
    fn time(&self) -> &u32;
    fn value(&self) -> &super::core::LinearTransform;
}

impl TransformKeyFrameDataTrait for TransformKeyFrameData {
    fn on(&self) -> &bool {
        &self.on
    }
    fn time(&self) -> &u32 {
        &self.time
    }
    fn value(&self) -> &super::core::LinearTransform {
        &self.value
    }
}

pub static TRANSFORMKEYFRAMEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformKeyFrameData",
    flags: MemberInfoFlags::new(36937),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformKeyFrameData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "On",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TransformKeyFrameData, on),
            },
            FieldInfoData {
                name: "Time",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(TransformKeyFrameData, time),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(TransformKeyFrameData, value),
            },
        ],
    }),
    array_type: Some(TRANSFORMKEYFRAMEDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for TransformKeyFrameData {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMKEYFRAMEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static TRANSFORMKEYFRAMEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformKeyFrameData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("TransformKeyFrameData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateKeyframedFloatChannelControllerData {
    pub _glacier_base: CharacterStateBaseControllerData,
    pub tracks: Vec<CharacterStateFloatTrackData>,
    pub channels: Vec<Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>>,
}

pub trait CharacterStateKeyframedFloatChannelControllerDataTrait: CharacterStateBaseControllerDataTrait {
    fn tracks(&self) -> &Vec<CharacterStateFloatTrackData>;
    fn channels(&self) -> &Vec<Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>>;
}

impl CharacterStateKeyframedFloatChannelControllerDataTrait for CharacterStateKeyframedFloatChannelControllerData {
    fn tracks(&self) -> &Vec<CharacterStateFloatTrackData> {
        &self.tracks
    }
    fn channels(&self) -> &Vec<Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>> {
        &self.channels
    }
}

impl CharacterStateBaseControllerDataTrait for CharacterStateKeyframedFloatChannelControllerData {
    fn asset_index(&self) -> &i32 {
        self._glacier_base.asset_index()
    }
    fn subjects(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>> {
        self._glacier_base.subjects()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for CharacterStateKeyframedFloatChannelControllerData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATEKEYFRAMEDFLOATCHANNELCONTROLLERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateKeyframedFloatChannelControllerData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEBASECONTROLLERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateKeyframedFloatChannelControllerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Tracks",
                flags: MemberInfoFlags::new(144),
                field_type: "CharacterStateFloatTrackData-Array",
                rust_offset: offset_of!(CharacterStateKeyframedFloatChannelControllerData, tracks),
            },
            FieldInfoData {
                name: "Channels",
                flags: MemberInfoFlags::new(144),
                field_type: "FloatChannelData-Array",
                rust_offset: offset_of!(CharacterStateKeyframedFloatChannelControllerData, channels),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEKEYFRAMEDFLOATCHANNELCONTROLLERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateKeyframedFloatChannelControllerData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEKEYFRAMEDFLOATCHANNELCONTROLLERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEKEYFRAMEDFLOATCHANNELCONTROLLERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateKeyframedFloatChannelControllerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateKeyframedFloatChannelControllerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateFloatTrackData {
    pub float_tags: Vec<CharacterStateFloatTagData>,
}

pub trait CharacterStateFloatTrackDataTrait: TypeObject {
    fn float_tags(&self) -> &Vec<CharacterStateFloatTagData>;
}

impl CharacterStateFloatTrackDataTrait for CharacterStateFloatTrackData {
    fn float_tags(&self) -> &Vec<CharacterStateFloatTagData> {
        &self.float_tags
    }
}

pub static CHARACTERSTATEFLOATTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateFloatTrackData",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateFloatTrackData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "FloatTags",
                flags: MemberInfoFlags::new(144),
                field_type: "CharacterStateFloatTagData-Array",
                rust_offset: offset_of!(CharacterStateFloatTrackData, float_tags),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEFLOATTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateFloatTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEFLOATTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEFLOATTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateFloatTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateFloatTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateFloatTagData {
    pub copy_from: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub keyframes: Vec<FloatKeyFrameData>,
    pub reset_mode: TagResetMode,
    pub reset_value: f32,
    pub time: u32,
    pub duration: u32,
}

pub trait CharacterStateFloatTagDataTrait: TypeObject {
    fn copy_from(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn keyframes(&self) -> &Vec<FloatKeyFrameData>;
    fn reset_mode(&self) -> &TagResetMode;
    fn reset_value(&self) -> &f32;
    fn time(&self) -> &u32;
    fn duration(&self) -> &u32;
}

impl CharacterStateFloatTagDataTrait for CharacterStateFloatTagData {
    fn copy_from(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.copy_from
    }
    fn keyframes(&self) -> &Vec<FloatKeyFrameData> {
        &self.keyframes
    }
    fn reset_mode(&self) -> &TagResetMode {
        &self.reset_mode
    }
    fn reset_value(&self) -> &f32 {
        &self.reset_value
    }
    fn time(&self) -> &u32 {
        &self.time
    }
    fn duration(&self) -> &u32 {
        &self.duration
    }
}

pub static CHARACTERSTATEFLOATTAGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateFloatTagData",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateFloatTagData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "CopyFrom",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateFloatTagData, copy_from),
            },
            FieldInfoData {
                name: "Keyframes",
                flags: MemberInfoFlags::new(144),
                field_type: "FloatKeyFrameData-Array",
                rust_offset: offset_of!(CharacterStateFloatTagData, keyframes),
            },
            FieldInfoData {
                name: "ResetMode",
                flags: MemberInfoFlags::new(0),
                field_type: "TagResetMode",
                rust_offset: offset_of!(CharacterStateFloatTagData, reset_mode),
            },
            FieldInfoData {
                name: "ResetValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateFloatTagData, reset_value),
            },
            FieldInfoData {
                name: "Time",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(CharacterStateFloatTagData, time),
            },
            FieldInfoData {
                name: "Duration",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(CharacterStateFloatTagData, duration),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEFLOATTAGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateFloatTagData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEFLOATTAGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEFLOATTAGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateFloatTagData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateFloatTagData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FloatKeyFrameData {
    pub on: bool,
    pub time: f32,
    pub value: f32,
}

pub trait FloatKeyFrameDataTrait: TypeObject {
    fn on(&self) -> &bool;
    fn time(&self) -> &f32;
    fn value(&self) -> &f32;
}

impl FloatKeyFrameDataTrait for FloatKeyFrameData {
    fn on(&self) -> &bool {
        &self.on
    }
    fn time(&self) -> &f32 {
        &self.time
    }
    fn value(&self) -> &f32 {
        &self.value
    }
}

pub static FLOATKEYFRAMEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatKeyFrameData",
    flags: MemberInfoFlags::new(36937),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FloatKeyFrameData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "On",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FloatKeyFrameData, on),
            },
            FieldInfoData {
                name: "Time",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FloatKeyFrameData, time),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FloatKeyFrameData, value),
            },
        ],
    }),
    array_type: Some(FLOATKEYFRAMEDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for FloatKeyFrameData {
    fn type_info(&self) -> &'static TypeInfo {
        FLOATKEYFRAMEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static FLOATKEYFRAMEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatKeyFrameData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("FloatKeyFrameData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateKeyframedChannelControllerData {
    pub _glacier_base: CharacterStateBaseControllerData,
    pub bool_channel_controller: Option<Arc<Mutex<dyn CharacterStateKeyframedBoolChannelControllerDataTrait>>>,
    pub int_channel_controller: Option<Arc<Mutex<dyn CharacterStateKeyframedIntChannelControllerDataTrait>>>,
    pub float_channel_controller: Option<Arc<Mutex<dyn CharacterStateKeyframedFloatChannelControllerDataTrait>>>,
    pub vec3_channel_controller: Option<Arc<Mutex<dyn CharacterStateKeyframedVec3ChannelControllerDataTrait>>>,
    pub animation_only_tags: Vec<AnimationOnlyTagCollection>,
}

pub trait CharacterStateKeyframedChannelControllerDataTrait: CharacterStateBaseControllerDataTrait {
    fn bool_channel_controller(&self) -> &Option<Arc<Mutex<dyn CharacterStateKeyframedBoolChannelControllerDataTrait>>>;
    fn int_channel_controller(&self) -> &Option<Arc<Mutex<dyn CharacterStateKeyframedIntChannelControllerDataTrait>>>;
    fn float_channel_controller(&self) -> &Option<Arc<Mutex<dyn CharacterStateKeyframedFloatChannelControllerDataTrait>>>;
    fn vec3_channel_controller(&self) -> &Option<Arc<Mutex<dyn CharacterStateKeyframedVec3ChannelControllerDataTrait>>>;
    fn animation_only_tags(&self) -> &Vec<AnimationOnlyTagCollection>;
}

impl CharacterStateKeyframedChannelControllerDataTrait for CharacterStateKeyframedChannelControllerData {
    fn bool_channel_controller(&self) -> &Option<Arc<Mutex<dyn CharacterStateKeyframedBoolChannelControllerDataTrait>>> {
        &self.bool_channel_controller
    }
    fn int_channel_controller(&self) -> &Option<Arc<Mutex<dyn CharacterStateKeyframedIntChannelControllerDataTrait>>> {
        &self.int_channel_controller
    }
    fn float_channel_controller(&self) -> &Option<Arc<Mutex<dyn CharacterStateKeyframedFloatChannelControllerDataTrait>>> {
        &self.float_channel_controller
    }
    fn vec3_channel_controller(&self) -> &Option<Arc<Mutex<dyn CharacterStateKeyframedVec3ChannelControllerDataTrait>>> {
        &self.vec3_channel_controller
    }
    fn animation_only_tags(&self) -> &Vec<AnimationOnlyTagCollection> {
        &self.animation_only_tags
    }
}

impl CharacterStateBaseControllerDataTrait for CharacterStateKeyframedChannelControllerData {
    fn asset_index(&self) -> &i32 {
        self._glacier_base.asset_index()
    }
    fn subjects(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>> {
        self._glacier_base.subjects()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for CharacterStateKeyframedChannelControllerData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATEKEYFRAMEDCHANNELCONTROLLERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateKeyframedChannelControllerData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEBASECONTROLLERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateKeyframedChannelControllerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "BoolChannelController",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterStateKeyframedBoolChannelControllerData",
                rust_offset: offset_of!(CharacterStateKeyframedChannelControllerData, bool_channel_controller),
            },
            FieldInfoData {
                name: "IntChannelController",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterStateKeyframedIntChannelControllerData",
                rust_offset: offset_of!(CharacterStateKeyframedChannelControllerData, int_channel_controller),
            },
            FieldInfoData {
                name: "FloatChannelController",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterStateKeyframedFloatChannelControllerData",
                rust_offset: offset_of!(CharacterStateKeyframedChannelControllerData, float_channel_controller),
            },
            FieldInfoData {
                name: "Vec3ChannelController",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterStateKeyframedVec3ChannelControllerData",
                rust_offset: offset_of!(CharacterStateKeyframedChannelControllerData, vec3_channel_controller),
            },
            FieldInfoData {
                name: "AnimationOnlyTags",
                flags: MemberInfoFlags::new(144),
                field_type: "AnimationOnlyTagCollection-Array",
                rust_offset: offset_of!(CharacterStateKeyframedChannelControllerData, animation_only_tags),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEKEYFRAMEDCHANNELCONTROLLERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateKeyframedChannelControllerData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEKEYFRAMEDCHANNELCONTROLLERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEKEYFRAMEDCHANNELCONTROLLERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateKeyframedChannelControllerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateKeyframedChannelControllerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AnimationOnlyTagCollection {
    pub tag_collection: super::ant::AntRef,
}

pub trait AnimationOnlyTagCollectionTrait: TypeObject {
    fn tag_collection(&self) -> &super::ant::AntRef;
}

impl AnimationOnlyTagCollectionTrait for AnimationOnlyTagCollection {
    fn tag_collection(&self) -> &super::ant::AntRef {
        &self.tag_collection
    }
}

pub static ANIMATIONONLYTAGCOLLECTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimationOnlyTagCollection",
    flags: MemberInfoFlags::new(32841),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AnimationOnlyTagCollection as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "TagCollection",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimationOnlyTagCollection, tag_collection),
            },
        ],
    }),
    array_type: Some(ANIMATIONONLYTAGCOLLECTION_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AnimationOnlyTagCollection {
    fn type_info(&self) -> &'static TypeInfo {
        ANIMATIONONLYTAGCOLLECTION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ANIMATIONONLYTAGCOLLECTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimationOnlyTagCollection-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("AnimationOnlyTagCollection"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateKeyframedIntChannelControllerData {
    pub _glacier_base: CharacterStateBaseControllerData,
    pub tracks: Vec<CharacterStateIntTrackData>,
    pub channels: Vec<Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>>,
}

pub trait CharacterStateKeyframedIntChannelControllerDataTrait: CharacterStateBaseControllerDataTrait {
    fn tracks(&self) -> &Vec<CharacterStateIntTrackData>;
    fn channels(&self) -> &Vec<Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>>;
}

impl CharacterStateKeyframedIntChannelControllerDataTrait for CharacterStateKeyframedIntChannelControllerData {
    fn tracks(&self) -> &Vec<CharacterStateIntTrackData> {
        &self.tracks
    }
    fn channels(&self) -> &Vec<Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>> {
        &self.channels
    }
}

impl CharacterStateBaseControllerDataTrait for CharacterStateKeyframedIntChannelControllerData {
    fn asset_index(&self) -> &i32 {
        self._glacier_base.asset_index()
    }
    fn subjects(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>> {
        self._glacier_base.subjects()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for CharacterStateKeyframedIntChannelControllerData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATEKEYFRAMEDINTCHANNELCONTROLLERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateKeyframedIntChannelControllerData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEBASECONTROLLERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateKeyframedIntChannelControllerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Tracks",
                flags: MemberInfoFlags::new(144),
                field_type: "CharacterStateIntTrackData-Array",
                rust_offset: offset_of!(CharacterStateKeyframedIntChannelControllerData, tracks),
            },
            FieldInfoData {
                name: "Channels",
                flags: MemberInfoFlags::new(144),
                field_type: "IntChannelData-Array",
                rust_offset: offset_of!(CharacterStateKeyframedIntChannelControllerData, channels),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEKEYFRAMEDINTCHANNELCONTROLLERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateKeyframedIntChannelControllerData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEKEYFRAMEDINTCHANNELCONTROLLERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEKEYFRAMEDINTCHANNELCONTROLLERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateKeyframedIntChannelControllerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateKeyframedIntChannelControllerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateIntTrackData {
    pub keyframes: Vec<IntKeyFrameData>,
}

pub trait CharacterStateIntTrackDataTrait: TypeObject {
    fn keyframes(&self) -> &Vec<IntKeyFrameData>;
}

impl CharacterStateIntTrackDataTrait for CharacterStateIntTrackData {
    fn keyframes(&self) -> &Vec<IntKeyFrameData> {
        &self.keyframes
    }
}

pub static CHARACTERSTATEINTTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateIntTrackData",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateIntTrackData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Keyframes",
                flags: MemberInfoFlags::new(144),
                field_type: "IntKeyFrameData-Array",
                rust_offset: offset_of!(CharacterStateIntTrackData, keyframes),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEINTTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateIntTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEINTTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEINTTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateIntTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateIntTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct IntKeyFrameData {
    pub reset_mode: TagResetMode,
    pub time: u32,
    pub length: u32,
    pub value: i32,
    pub reset_value: i32,
    pub copy_from: Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>,
}

pub trait IntKeyFrameDataTrait: TypeObject {
    fn reset_mode(&self) -> &TagResetMode;
    fn time(&self) -> &u32;
    fn length(&self) -> &u32;
    fn value(&self) -> &i32;
    fn reset_value(&self) -> &i32;
    fn copy_from(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>;
}

impl IntKeyFrameDataTrait for IntKeyFrameData {
    fn reset_mode(&self) -> &TagResetMode {
        &self.reset_mode
    }
    fn time(&self) -> &u32 {
        &self.time
    }
    fn length(&self) -> &u32 {
        &self.length
    }
    fn value(&self) -> &i32 {
        &self.value
    }
    fn reset_value(&self) -> &i32 {
        &self.reset_value
    }
    fn copy_from(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>> {
        &self.copy_from
    }
}

pub static INTKEYFRAMEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntKeyFrameData",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<IntKeyFrameData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ResetMode",
                flags: MemberInfoFlags::new(0),
                field_type: "TagResetMode",
                rust_offset: offset_of!(IntKeyFrameData, reset_mode),
            },
            FieldInfoData {
                name: "Time",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(IntKeyFrameData, time),
            },
            FieldInfoData {
                name: "Length",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(IntKeyFrameData, length),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(IntKeyFrameData, value),
            },
            FieldInfoData {
                name: "ResetValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(IntKeyFrameData, reset_value),
            },
            FieldInfoData {
                name: "CopyFrom",
                flags: MemberInfoFlags::new(0),
                field_type: "IntChannelData",
                rust_offset: offset_of!(IntKeyFrameData, copy_from),
            },
        ],
    }),
    array_type: Some(INTKEYFRAMEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for IntKeyFrameData {
    fn type_info(&self) -> &'static TypeInfo {
        INTKEYFRAMEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static INTKEYFRAMEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntKeyFrameData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("IntKeyFrameData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateKeyframedBoolChannelControllerData {
    pub _glacier_base: CharacterStateBaseControllerData,
    pub tracks: Vec<CharacterStateBoolTrackData>,
    pub channels: Vec<Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>>,
}

pub trait CharacterStateKeyframedBoolChannelControllerDataTrait: CharacterStateBaseControllerDataTrait {
    fn tracks(&self) -> &Vec<CharacterStateBoolTrackData>;
    fn channels(&self) -> &Vec<Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>>;
}

impl CharacterStateKeyframedBoolChannelControllerDataTrait for CharacterStateKeyframedBoolChannelControllerData {
    fn tracks(&self) -> &Vec<CharacterStateBoolTrackData> {
        &self.tracks
    }
    fn channels(&self) -> &Vec<Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>> {
        &self.channels
    }
}

impl CharacterStateBaseControllerDataTrait for CharacterStateKeyframedBoolChannelControllerData {
    fn asset_index(&self) -> &i32 {
        self._glacier_base.asset_index()
    }
    fn subjects(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>> {
        self._glacier_base.subjects()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for CharacterStateKeyframedBoolChannelControllerData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATEKEYFRAMEDBOOLCHANNELCONTROLLERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateKeyframedBoolChannelControllerData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEBASECONTROLLERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateKeyframedBoolChannelControllerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Tracks",
                flags: MemberInfoFlags::new(144),
                field_type: "CharacterStateBoolTrackData-Array",
                rust_offset: offset_of!(CharacterStateKeyframedBoolChannelControllerData, tracks),
            },
            FieldInfoData {
                name: "Channels",
                flags: MemberInfoFlags::new(144),
                field_type: "BoolChannelData-Array",
                rust_offset: offset_of!(CharacterStateKeyframedBoolChannelControllerData, channels),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEKEYFRAMEDBOOLCHANNELCONTROLLERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateKeyframedBoolChannelControllerData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEKEYFRAMEDBOOLCHANNELCONTROLLERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEKEYFRAMEDBOOLCHANNELCONTROLLERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateKeyframedBoolChannelControllerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateKeyframedBoolChannelControllerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateBoolTrackData {
    pub keyframes: Vec<BoolKeyFrameData>,
}

pub trait CharacterStateBoolTrackDataTrait: TypeObject {
    fn keyframes(&self) -> &Vec<BoolKeyFrameData>;
}

impl CharacterStateBoolTrackDataTrait for CharacterStateBoolTrackData {
    fn keyframes(&self) -> &Vec<BoolKeyFrameData> {
        &self.keyframes
    }
}

pub static CHARACTERSTATEBOOLTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateBoolTrackData",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateBoolTrackData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Keyframes",
                flags: MemberInfoFlags::new(144),
                field_type: "BoolKeyFrameData-Array",
                rust_offset: offset_of!(CharacterStateBoolTrackData, keyframes),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEBOOLTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateBoolTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEBOOLTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEBOOLTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateBoolTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateBoolTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BoolKeyFrameData {
    pub reset_mode: TagResetMode,
    pub mode: TagMode,
    pub copy_from: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub time: u32,
    pub length: u32,
    pub value: bool,
    pub reset_value: bool,
}

pub trait BoolKeyFrameDataTrait: TypeObject {
    fn reset_mode(&self) -> &TagResetMode;
    fn mode(&self) -> &TagMode;
    fn copy_from(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn time(&self) -> &u32;
    fn length(&self) -> &u32;
    fn value(&self) -> &bool;
    fn reset_value(&self) -> &bool;
}

impl BoolKeyFrameDataTrait for BoolKeyFrameData {
    fn reset_mode(&self) -> &TagResetMode {
        &self.reset_mode
    }
    fn mode(&self) -> &TagMode {
        &self.mode
    }
    fn copy_from(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.copy_from
    }
    fn time(&self) -> &u32 {
        &self.time
    }
    fn length(&self) -> &u32 {
        &self.length
    }
    fn value(&self) -> &bool {
        &self.value
    }
    fn reset_value(&self) -> &bool {
        &self.reset_value
    }
}

pub static BOOLKEYFRAMEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolKeyFrameData",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BoolKeyFrameData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ResetMode",
                flags: MemberInfoFlags::new(0),
                field_type: "TagResetMode",
                rust_offset: offset_of!(BoolKeyFrameData, reset_mode),
            },
            FieldInfoData {
                name: "Mode",
                flags: MemberInfoFlags::new(0),
                field_type: "TagMode",
                rust_offset: offset_of!(BoolKeyFrameData, mode),
            },
            FieldInfoData {
                name: "CopyFrom",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(BoolKeyFrameData, copy_from),
            },
            FieldInfoData {
                name: "Time",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(BoolKeyFrameData, time),
            },
            FieldInfoData {
                name: "Length",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(BoolKeyFrameData, length),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BoolKeyFrameData, value),
            },
            FieldInfoData {
                name: "ResetValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BoolKeyFrameData, reset_value),
            },
        ],
    }),
    array_type: Some(BOOLKEYFRAMEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BoolKeyFrameData {
    fn type_info(&self) -> &'static TypeInfo {
        BOOLKEYFRAMEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static BOOLKEYFRAMEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolKeyFrameData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("BoolKeyFrameData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum TagMode {
    #[default]
    TagMode_SetValueOnEnter = 0,
    TagMode_RandomizeValueOnEnter = 1,
}

pub static TAGMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TagMode",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(TAGMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for TagMode {
    fn type_info(&self) -> &'static TypeInfo {
        TAGMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static TAGMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TagMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("TagMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum TagResetMode {
    #[default]
    ResetMode_ResetDisabled = 0,
    ResetMode_ResetToDefault = 1,
    ResetMode_ResetToPrevious = 2,
}

pub static TAGRESETMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TagResetMode",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(TAGRESETMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for TagResetMode {
    fn type_info(&self) -> &'static TypeInfo {
        TAGRESETMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static TAGRESETMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TagResetMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("TagResetMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateIndexChooserControllerData {
    pub _glacier_base: CharacterStateBaseControllerData,
    pub index_channel: Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>,
    pub signal_chooser: Option<Arc<Mutex<dyn SignalChooserDataTrait>>>,
    pub random_chooser: Option<Arc<Mutex<dyn RandomChooserDataTrait>>>,
    pub float_chooser: Option<Arc<Mutex<dyn FloatChooserDataTrait>>>,
    pub context_data_base_chooser: Option<Arc<Mutex<dyn ContextDatabaseChooserDataTrait>>>,
}

pub trait CharacterStateIndexChooserControllerDataTrait: CharacterStateBaseControllerDataTrait {
    fn index_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>;
    fn signal_chooser(&self) -> &Option<Arc<Mutex<dyn SignalChooserDataTrait>>>;
    fn random_chooser(&self) -> &Option<Arc<Mutex<dyn RandomChooserDataTrait>>>;
    fn float_chooser(&self) -> &Option<Arc<Mutex<dyn FloatChooserDataTrait>>>;
    fn context_data_base_chooser(&self) -> &Option<Arc<Mutex<dyn ContextDatabaseChooserDataTrait>>>;
}

impl CharacterStateIndexChooserControllerDataTrait for CharacterStateIndexChooserControllerData {
    fn index_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>> {
        &self.index_channel
    }
    fn signal_chooser(&self) -> &Option<Arc<Mutex<dyn SignalChooserDataTrait>>> {
        &self.signal_chooser
    }
    fn random_chooser(&self) -> &Option<Arc<Mutex<dyn RandomChooserDataTrait>>> {
        &self.random_chooser
    }
    fn float_chooser(&self) -> &Option<Arc<Mutex<dyn FloatChooserDataTrait>>> {
        &self.float_chooser
    }
    fn context_data_base_chooser(&self) -> &Option<Arc<Mutex<dyn ContextDatabaseChooserDataTrait>>> {
        &self.context_data_base_chooser
    }
}

impl CharacterStateBaseControllerDataTrait for CharacterStateIndexChooserControllerData {
    fn asset_index(&self) -> &i32 {
        self._glacier_base.asset_index()
    }
    fn subjects(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>> {
        self._glacier_base.subjects()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for CharacterStateIndexChooserControllerData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATEINDEXCHOOSERCONTROLLERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateIndexChooserControllerData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEBASECONTROLLERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateIndexChooserControllerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "IndexChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "IntChannelData",
                rust_offset: offset_of!(CharacterStateIndexChooserControllerData, index_channel),
            },
            FieldInfoData {
                name: "SignalChooser",
                flags: MemberInfoFlags::new(0),
                field_type: "SignalChooserData",
                rust_offset: offset_of!(CharacterStateIndexChooserControllerData, signal_chooser),
            },
            FieldInfoData {
                name: "RandomChooser",
                flags: MemberInfoFlags::new(0),
                field_type: "RandomChooserData",
                rust_offset: offset_of!(CharacterStateIndexChooserControllerData, random_chooser),
            },
            FieldInfoData {
                name: "FloatChooser",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChooserData",
                rust_offset: offset_of!(CharacterStateIndexChooserControllerData, float_chooser),
            },
            FieldInfoData {
                name: "ContextDataBaseChooser",
                flags: MemberInfoFlags::new(0),
                field_type: "ContextDatabaseChooserData",
                rust_offset: offset_of!(CharacterStateIndexChooserControllerData, context_data_base_chooser),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEINDEXCHOOSERCONTROLLERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateIndexChooserControllerData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEINDEXCHOOSERCONTROLLERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEINDEXCHOOSERCONTROLLERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateIndexChooserControllerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateIndexChooserControllerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FloatChooserData {
    pub _glacier_base: super::core::DataContainer,
    pub input_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub thresholds: Vec<f32>,
}

pub trait FloatChooserDataTrait: super::core::DataContainerTrait {
    fn input_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn thresholds(&self) -> &Vec<f32>;
}

impl FloatChooserDataTrait for FloatChooserData {
    fn input_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.input_channel
    }
    fn thresholds(&self) -> &Vec<f32> {
        &self.thresholds
    }
}

impl super::core::DataContainerTrait for FloatChooserData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static FLOATCHOOSERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatChooserData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FloatChooserData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "InputChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(FloatChooserData, input_channel),
            },
            FieldInfoData {
                name: "Thresholds",
                flags: MemberInfoFlags::new(144),
                field_type: "Float32-Array",
                rust_offset: offset_of!(FloatChooserData, thresholds),
            },
        ],
    }),
    array_type: Some(FLOATCHOOSERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FloatChooserData {
    fn type_info(&self) -> &'static TypeInfo {
        FLOATCHOOSERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static FLOATCHOOSERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatChooserData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("FloatChooserData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RandomChooserData {
    pub _glacier_base: super::core::DataContainer,
    pub limits: Vec<f32>,
}

pub trait RandomChooserDataTrait: super::core::DataContainerTrait {
    fn limits(&self) -> &Vec<f32>;
}

impl RandomChooserDataTrait for RandomChooserData {
    fn limits(&self) -> &Vec<f32> {
        &self.limits
    }
}

impl super::core::DataContainerTrait for RandomChooserData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static RANDOMCHOOSERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RandomChooserData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RandomChooserData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Limits",
                flags: MemberInfoFlags::new(144),
                field_type: "Float32-Array",
                rust_offset: offset_of!(RandomChooserData, limits),
            },
        ],
    }),
    array_type: Some(RANDOMCHOOSERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RandomChooserData {
    fn type_info(&self) -> &'static TypeInfo {
        RANDOMCHOOSERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static RANDOMCHOOSERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RandomChooserData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("RandomChooserData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SignalChooserData {
    pub _glacier_base: super::core::DataContainer,
    pub compare_channels: Vec<Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>>,
    pub subject_matches: Vec<u32>,
    pub subject_masks: Vec<u32>,
}

pub trait SignalChooserDataTrait: super::core::DataContainerTrait {
    fn compare_channels(&self) -> &Vec<Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>>;
    fn subject_matches(&self) -> &Vec<u32>;
    fn subject_masks(&self) -> &Vec<u32>;
}

impl SignalChooserDataTrait for SignalChooserData {
    fn compare_channels(&self) -> &Vec<Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>> {
        &self.compare_channels
    }
    fn subject_matches(&self) -> &Vec<u32> {
        &self.subject_matches
    }
    fn subject_masks(&self) -> &Vec<u32> {
        &self.subject_masks
    }
}

impl super::core::DataContainerTrait for SignalChooserData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SIGNALCHOOSERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SignalChooserData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SignalChooserData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "CompareChannels",
                flags: MemberInfoFlags::new(144),
                field_type: "BoolChannelData-Array",
                rust_offset: offset_of!(SignalChooserData, compare_channels),
            },
            FieldInfoData {
                name: "SubjectMatches",
                flags: MemberInfoFlags::new(144),
                field_type: "Uint32-Array",
                rust_offset: offset_of!(SignalChooserData, subject_matches),
            },
            FieldInfoData {
                name: "SubjectMasks",
                flags: MemberInfoFlags::new(144),
                field_type: "Uint32-Array",
                rust_offset: offset_of!(SignalChooserData, subject_masks),
            },
        ],
    }),
    array_type: Some(SIGNALCHOOSERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SignalChooserData {
    fn type_info(&self) -> &'static TypeInfo {
        SIGNALCHOOSERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SIGNALCHOOSERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SignalChooserData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("SignalChooserData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ContextDatabaseChooserData {
    pub _glacier_base: super::core::DataContainer,
    pub int_value_channels: Vec<Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>>,
    pub subject_int_values: Vec<ContextDatabaseChooserIntData>,
    pub enum_value_channels: Vec<Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>>,
    pub subject_enum_masks: Vec<u64>,
    pub bitmap_value_channels: Vec<Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>>,
    pub subject_bitmaps: Vec<ContextDatabaseChooserBitmapData>,
    pub bool_value_channels: Vec<Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>>,
    pub subject_bool_masks: Vec<u8>,
    pub float_value_channels: Vec<Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>>,
    pub subject_float_ranges: Vec<ContextDatabaseChooserFloatData>,
}

pub trait ContextDatabaseChooserDataTrait: super::core::DataContainerTrait {
    fn int_value_channels(&self) -> &Vec<Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>>;
    fn subject_int_values(&self) -> &Vec<ContextDatabaseChooserIntData>;
    fn enum_value_channels(&self) -> &Vec<Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>>;
    fn subject_enum_masks(&self) -> &Vec<u64>;
    fn bitmap_value_channels(&self) -> &Vec<Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>>;
    fn subject_bitmaps(&self) -> &Vec<ContextDatabaseChooserBitmapData>;
    fn bool_value_channels(&self) -> &Vec<Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>>;
    fn subject_bool_masks(&self) -> &Vec<u8>;
    fn float_value_channels(&self) -> &Vec<Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>>;
    fn subject_float_ranges(&self) -> &Vec<ContextDatabaseChooserFloatData>;
}

impl ContextDatabaseChooserDataTrait for ContextDatabaseChooserData {
    fn int_value_channels(&self) -> &Vec<Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>> {
        &self.int_value_channels
    }
    fn subject_int_values(&self) -> &Vec<ContextDatabaseChooserIntData> {
        &self.subject_int_values
    }
    fn enum_value_channels(&self) -> &Vec<Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>> {
        &self.enum_value_channels
    }
    fn subject_enum_masks(&self) -> &Vec<u64> {
        &self.subject_enum_masks
    }
    fn bitmap_value_channels(&self) -> &Vec<Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>> {
        &self.bitmap_value_channels
    }
    fn subject_bitmaps(&self) -> &Vec<ContextDatabaseChooserBitmapData> {
        &self.subject_bitmaps
    }
    fn bool_value_channels(&self) -> &Vec<Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>> {
        &self.bool_value_channels
    }
    fn subject_bool_masks(&self) -> &Vec<u8> {
        &self.subject_bool_masks
    }
    fn float_value_channels(&self) -> &Vec<Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>> {
        &self.float_value_channels
    }
    fn subject_float_ranges(&self) -> &Vec<ContextDatabaseChooserFloatData> {
        &self.subject_float_ranges
    }
}

impl super::core::DataContainerTrait for ContextDatabaseChooserData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CONTEXTDATABASECHOOSERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ContextDatabaseChooserData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ContextDatabaseChooserData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "IntValueChannels",
                flags: MemberInfoFlags::new(144),
                field_type: "IntChannelData-Array",
                rust_offset: offset_of!(ContextDatabaseChooserData, int_value_channels),
            },
            FieldInfoData {
                name: "SubjectIntValues",
                flags: MemberInfoFlags::new(144),
                field_type: "ContextDatabaseChooserIntData-Array",
                rust_offset: offset_of!(ContextDatabaseChooserData, subject_int_values),
            },
            FieldInfoData {
                name: "EnumValueChannels",
                flags: MemberInfoFlags::new(144),
                field_type: "IntChannelData-Array",
                rust_offset: offset_of!(ContextDatabaseChooserData, enum_value_channels),
            },
            FieldInfoData {
                name: "SubjectEnumMasks",
                flags: MemberInfoFlags::new(144),
                field_type: "Uint64-Array",
                rust_offset: offset_of!(ContextDatabaseChooserData, subject_enum_masks),
            },
            FieldInfoData {
                name: "BitmapValueChannels",
                flags: MemberInfoFlags::new(144),
                field_type: "IntChannelData-Array",
                rust_offset: offset_of!(ContextDatabaseChooserData, bitmap_value_channels),
            },
            FieldInfoData {
                name: "SubjectBitmaps",
                flags: MemberInfoFlags::new(144),
                field_type: "ContextDatabaseChooserBitmapData-Array",
                rust_offset: offset_of!(ContextDatabaseChooserData, subject_bitmaps),
            },
            FieldInfoData {
                name: "BoolValueChannels",
                flags: MemberInfoFlags::new(144),
                field_type: "BoolChannelData-Array",
                rust_offset: offset_of!(ContextDatabaseChooserData, bool_value_channels),
            },
            FieldInfoData {
                name: "SubjectBoolMasks",
                flags: MemberInfoFlags::new(144),
                field_type: "Uint8-Array",
                rust_offset: offset_of!(ContextDatabaseChooserData, subject_bool_masks),
            },
            FieldInfoData {
                name: "FloatValueChannels",
                flags: MemberInfoFlags::new(144),
                field_type: "FloatChannelData-Array",
                rust_offset: offset_of!(ContextDatabaseChooserData, float_value_channels),
            },
            FieldInfoData {
                name: "SubjectFloatRanges",
                flags: MemberInfoFlags::new(144),
                field_type: "ContextDatabaseChooserFloatData-Array",
                rust_offset: offset_of!(ContextDatabaseChooserData, subject_float_ranges),
            },
        ],
    }),
    array_type: Some(CONTEXTDATABASECHOOSERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ContextDatabaseChooserData {
    fn type_info(&self) -> &'static TypeInfo {
        CONTEXTDATABASECHOOSERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CONTEXTDATABASECHOOSERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ContextDatabaseChooserData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("ContextDatabaseChooserData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ContextDatabaseChooserFloatData {
    pub min: Vec<f32>,
    pub max: Vec<f32>,
}

pub trait ContextDatabaseChooserFloatDataTrait: TypeObject {
    fn min(&self) -> &Vec<f32>;
    fn max(&self) -> &Vec<f32>;
}

impl ContextDatabaseChooserFloatDataTrait for ContextDatabaseChooserFloatData {
    fn min(&self) -> &Vec<f32> {
        &self.min
    }
    fn max(&self) -> &Vec<f32> {
        &self.max
    }
}

pub static CONTEXTDATABASECHOOSERFLOATDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ContextDatabaseChooserFloatData",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ContextDatabaseChooserFloatData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Min",
                flags: MemberInfoFlags::new(144),
                field_type: "Float32-Array",
                rust_offset: offset_of!(ContextDatabaseChooserFloatData, min),
            },
            FieldInfoData {
                name: "Max",
                flags: MemberInfoFlags::new(144),
                field_type: "Float32-Array",
                rust_offset: offset_of!(ContextDatabaseChooserFloatData, max),
            },
        ],
    }),
    array_type: Some(CONTEXTDATABASECHOOSERFLOATDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ContextDatabaseChooserFloatData {
    fn type_info(&self) -> &'static TypeInfo {
        CONTEXTDATABASECHOOSERFLOATDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CONTEXTDATABASECHOOSERFLOATDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ContextDatabaseChooserFloatData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("ContextDatabaseChooserFloatData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ContextDatabaseChooserBitmapData {
    pub values: Vec<u32>,
}

pub trait ContextDatabaseChooserBitmapDataTrait: TypeObject {
    fn values(&self) -> &Vec<u32>;
}

impl ContextDatabaseChooserBitmapDataTrait for ContextDatabaseChooserBitmapData {
    fn values(&self) -> &Vec<u32> {
        &self.values
    }
}

pub static CONTEXTDATABASECHOOSERBITMAPDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ContextDatabaseChooserBitmapData",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ContextDatabaseChooserBitmapData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Values",
                flags: MemberInfoFlags::new(144),
                field_type: "Uint32-Array",
                rust_offset: offset_of!(ContextDatabaseChooserBitmapData, values),
            },
        ],
    }),
    array_type: Some(CONTEXTDATABASECHOOSERBITMAPDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ContextDatabaseChooserBitmapData {
    fn type_info(&self) -> &'static TypeInfo {
        CONTEXTDATABASECHOOSERBITMAPDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CONTEXTDATABASECHOOSERBITMAPDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ContextDatabaseChooserBitmapData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("ContextDatabaseChooserBitmapData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ContextDatabaseChooserIntData {
    pub values: Vec<u8>,
}

pub trait ContextDatabaseChooserIntDataTrait: TypeObject {
    fn values(&self) -> &Vec<u8>;
}

impl ContextDatabaseChooserIntDataTrait for ContextDatabaseChooserIntData {
    fn values(&self) -> &Vec<u8> {
        &self.values
    }
}

pub static CONTEXTDATABASECHOOSERINTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ContextDatabaseChooserIntData",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ContextDatabaseChooserIntData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Values",
                flags: MemberInfoFlags::new(144),
                field_type: "Uint8-Array",
                rust_offset: offset_of!(ContextDatabaseChooserIntData, values),
            },
        ],
    }),
    array_type: Some(CONTEXTDATABASECHOOSERINTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ContextDatabaseChooserIntData {
    fn type_info(&self) -> &'static TypeInfo {
        CONTEXTDATABASECHOOSERINTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CONTEXTDATABASECHOOSERINTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ContextDatabaseChooserIntData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("ContextDatabaseChooserIntData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateIKControllerData {
    pub _glacier_base: CharacterStateBaseControllerData,
    pub ant_controller: super::ant::AntRef,
    pub enable_ik_channel: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub blend_out_ticks: f32,
    pub position: Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>,
    pub begin_chain: Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>,
    pub middle_chain: Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>,
    pub end_chain: Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>,
    pub begin_result: Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>,
    pub middle_result: Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>,
    pub end_result: Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>,
    pub target_world_space: Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>,
    pub future_foot: Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>,
    pub foot_planted: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub foot_height: f32,
    pub blend_ticks: u8,
    pub ray_collision_layer: super::physics::RigidBodyCollisionLayer,
    pub ray_start_height: f32,
    pub ray_end_height: f32,
    pub update_raycast_target_threshold: f32,
}

pub trait CharacterStateIKControllerDataTrait: CharacterStateBaseControllerDataTrait {
    fn ant_controller(&self) -> &super::ant::AntRef;
    fn enable_ik_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn blend_out_ticks(&self) -> &f32;
    fn position(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>;
    fn begin_chain(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>;
    fn middle_chain(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>;
    fn end_chain(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>;
    fn begin_result(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>;
    fn middle_result(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>;
    fn end_result(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>;
    fn target_world_space(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>;
    fn future_foot(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>;
    fn foot_planted(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn foot_height(&self) -> &f32;
    fn blend_ticks(&self) -> &u8;
    fn ray_collision_layer(&self) -> &super::physics::RigidBodyCollisionLayer;
    fn ray_start_height(&self) -> &f32;
    fn ray_end_height(&self) -> &f32;
    fn update_raycast_target_threshold(&self) -> &f32;
}

impl CharacterStateIKControllerDataTrait for CharacterStateIKControllerData {
    fn ant_controller(&self) -> &super::ant::AntRef {
        &self.ant_controller
    }
    fn enable_ik_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.enable_ik_channel
    }
    fn blend_out_ticks(&self) -> &f32 {
        &self.blend_out_ticks
    }
    fn position(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>> {
        &self.position
    }
    fn begin_chain(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>> {
        &self.begin_chain
    }
    fn middle_chain(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>> {
        &self.middle_chain
    }
    fn end_chain(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>> {
        &self.end_chain
    }
    fn begin_result(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>> {
        &self.begin_result
    }
    fn middle_result(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>> {
        &self.middle_result
    }
    fn end_result(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>> {
        &self.end_result
    }
    fn target_world_space(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>> {
        &self.target_world_space
    }
    fn future_foot(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>> {
        &self.future_foot
    }
    fn foot_planted(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.foot_planted
    }
    fn foot_height(&self) -> &f32 {
        &self.foot_height
    }
    fn blend_ticks(&self) -> &u8 {
        &self.blend_ticks
    }
    fn ray_collision_layer(&self) -> &super::physics::RigidBodyCollisionLayer {
        &self.ray_collision_layer
    }
    fn ray_start_height(&self) -> &f32 {
        &self.ray_start_height
    }
    fn ray_end_height(&self) -> &f32 {
        &self.ray_end_height
    }
    fn update_raycast_target_threshold(&self) -> &f32 {
        &self.update_raycast_target_threshold
    }
}

impl CharacterStateBaseControllerDataTrait for CharacterStateIKControllerData {
    fn asset_index(&self) -> &i32 {
        self._glacier_base.asset_index()
    }
    fn subjects(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>> {
        self._glacier_base.subjects()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for CharacterStateIKControllerData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATEIKCONTROLLERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateIKControllerData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEBASECONTROLLERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateIKControllerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AntController",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CharacterStateIKControllerData, ant_controller),
            },
            FieldInfoData {
                name: "EnableIkChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(CharacterStateIKControllerData, enable_ik_channel),
            },
            FieldInfoData {
                name: "BlendOutTicks",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateIKControllerData, blend_out_ticks),
            },
            FieldInfoData {
                name: "Position",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(CharacterStateIKControllerData, position),
            },
            FieldInfoData {
                name: "BeginChain",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(CharacterStateIKControllerData, begin_chain),
            },
            FieldInfoData {
                name: "MiddleChain",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(CharacterStateIKControllerData, middle_chain),
            },
            FieldInfoData {
                name: "EndChain",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(CharacterStateIKControllerData, end_chain),
            },
            FieldInfoData {
                name: "BeginResult",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(CharacterStateIKControllerData, begin_result),
            },
            FieldInfoData {
                name: "MiddleResult",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(CharacterStateIKControllerData, middle_result),
            },
            FieldInfoData {
                name: "EndResult",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(CharacterStateIKControllerData, end_result),
            },
            FieldInfoData {
                name: "TargetWorldSpace",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(CharacterStateIKControllerData, target_world_space),
            },
            FieldInfoData {
                name: "FutureFoot",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(CharacterStateIKControllerData, future_foot),
            },
            FieldInfoData {
                name: "FootPlanted",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(CharacterStateIKControllerData, foot_planted),
            },
            FieldInfoData {
                name: "FootHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateIKControllerData, foot_height),
            },
            FieldInfoData {
                name: "BlendTicks",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(CharacterStateIKControllerData, blend_ticks),
            },
            FieldInfoData {
                name: "RayCollisionLayer",
                flags: MemberInfoFlags::new(0),
                field_type: "RigidBodyCollisionLayer",
                rust_offset: offset_of!(CharacterStateIKControllerData, ray_collision_layer),
            },
            FieldInfoData {
                name: "RayStartHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateIKControllerData, ray_start_height),
            },
            FieldInfoData {
                name: "RayEndHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateIKControllerData, ray_end_height),
            },
            FieldInfoData {
                name: "UpdateRaycastTargetThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateIKControllerData, update_raycast_target_threshold),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEIKCONTROLLERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateIKControllerData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEIKCONTROLLERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEIKCONTROLLERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateIKControllerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateIKControllerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateClipFromInputControllerData {
    pub _glacier_base: CharacterStateBaseControllerData,
    pub included_channels: Option<Arc<Mutex<dyn super::soldier_shared::ChannelSetDataTrait>>>,
    pub velocity_channel: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub acceleration_channel: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub pos_and_rot_channel: Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>,
    pub trajectory_channel: Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>,
    pub throttle_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub strafe_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub aim_yaw_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub aim_pitch_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub angular_velocity_channel: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub chosen_clip_index_channel: Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>,
    pub child_controller_extracted_info: Vec<Option<Arc<Mutex<dyn CharacterStateKeyframedTransformChannelControllerDataTrait>>>>,
    pub display_subject_pose: bool,
    pub zero_y_target_velocity_in_compensation: bool,
    pub projected_distance: f32,
    pub desired_local_target_if_no_input_or_velocity: super::core::Vec3,
    pub adjust_direction: bool,
    pub drive_acceleration: bool,
    pub steer_animatable_factor: f32,
    pub angle_influence_multiplier: f32,
    pub end_position_influence_multiplier: f32,
    pub weights_channel: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub weights: super::core::Vec3,
    pub ant_controller: super::ant::AntRef,
}

pub trait CharacterStateClipFromInputControllerDataTrait: CharacterStateBaseControllerDataTrait {
    fn included_channels(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::ChannelSetDataTrait>>>;
    fn velocity_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn acceleration_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn pos_and_rot_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>;
    fn trajectory_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>;
    fn throttle_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn strafe_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn aim_yaw_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn aim_pitch_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn angular_velocity_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn chosen_clip_index_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>;
    fn child_controller_extracted_info(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateKeyframedTransformChannelControllerDataTrait>>>>;
    fn display_subject_pose(&self) -> &bool;
    fn zero_y_target_velocity_in_compensation(&self) -> &bool;
    fn projected_distance(&self) -> &f32;
    fn desired_local_target_if_no_input_or_velocity(&self) -> &super::core::Vec3;
    fn adjust_direction(&self) -> &bool;
    fn drive_acceleration(&self) -> &bool;
    fn steer_animatable_factor(&self) -> &f32;
    fn angle_influence_multiplier(&self) -> &f32;
    fn end_position_influence_multiplier(&self) -> &f32;
    fn weights_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn weights(&self) -> &super::core::Vec3;
    fn ant_controller(&self) -> &super::ant::AntRef;
}

impl CharacterStateClipFromInputControllerDataTrait for CharacterStateClipFromInputControllerData {
    fn included_channels(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::ChannelSetDataTrait>>> {
        &self.included_channels
    }
    fn velocity_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.velocity_channel
    }
    fn acceleration_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.acceleration_channel
    }
    fn pos_and_rot_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>> {
        &self.pos_and_rot_channel
    }
    fn trajectory_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>> {
        &self.trajectory_channel
    }
    fn throttle_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.throttle_channel
    }
    fn strafe_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.strafe_channel
    }
    fn aim_yaw_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.aim_yaw_channel
    }
    fn aim_pitch_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.aim_pitch_channel
    }
    fn angular_velocity_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.angular_velocity_channel
    }
    fn chosen_clip_index_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>> {
        &self.chosen_clip_index_channel
    }
    fn child_controller_extracted_info(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateKeyframedTransformChannelControllerDataTrait>>>> {
        &self.child_controller_extracted_info
    }
    fn display_subject_pose(&self) -> &bool {
        &self.display_subject_pose
    }
    fn zero_y_target_velocity_in_compensation(&self) -> &bool {
        &self.zero_y_target_velocity_in_compensation
    }
    fn projected_distance(&self) -> &f32 {
        &self.projected_distance
    }
    fn desired_local_target_if_no_input_or_velocity(&self) -> &super::core::Vec3 {
        &self.desired_local_target_if_no_input_or_velocity
    }
    fn adjust_direction(&self) -> &bool {
        &self.adjust_direction
    }
    fn drive_acceleration(&self) -> &bool {
        &self.drive_acceleration
    }
    fn steer_animatable_factor(&self) -> &f32 {
        &self.steer_animatable_factor
    }
    fn angle_influence_multiplier(&self) -> &f32 {
        &self.angle_influence_multiplier
    }
    fn end_position_influence_multiplier(&self) -> &f32 {
        &self.end_position_influence_multiplier
    }
    fn weights_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.weights_channel
    }
    fn weights(&self) -> &super::core::Vec3 {
        &self.weights
    }
    fn ant_controller(&self) -> &super::ant::AntRef {
        &self.ant_controller
    }
}

impl CharacterStateBaseControllerDataTrait for CharacterStateClipFromInputControllerData {
    fn asset_index(&self) -> &i32 {
        self._glacier_base.asset_index()
    }
    fn subjects(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>> {
        self._glacier_base.subjects()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for CharacterStateClipFromInputControllerData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATECLIPFROMINPUTCONTROLLERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateClipFromInputControllerData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEBASECONTROLLERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateClipFromInputControllerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "IncludedChannels",
                flags: MemberInfoFlags::new(0),
                field_type: "ChannelSetData",
                rust_offset: offset_of!(CharacterStateClipFromInputControllerData, included_channels),
            },
            FieldInfoData {
                name: "VelocityChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateClipFromInputControllerData, velocity_channel),
            },
            FieldInfoData {
                name: "AccelerationChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateClipFromInputControllerData, acceleration_channel),
            },
            FieldInfoData {
                name: "PosAndRotChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(CharacterStateClipFromInputControllerData, pos_and_rot_channel),
            },
            FieldInfoData {
                name: "TrajectoryChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(CharacterStateClipFromInputControllerData, trajectory_channel),
            },
            FieldInfoData {
                name: "ThrottleChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateClipFromInputControllerData, throttle_channel),
            },
            FieldInfoData {
                name: "StrafeChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateClipFromInputControllerData, strafe_channel),
            },
            FieldInfoData {
                name: "AimYawChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateClipFromInputControllerData, aim_yaw_channel),
            },
            FieldInfoData {
                name: "AimPitchChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateClipFromInputControllerData, aim_pitch_channel),
            },
            FieldInfoData {
                name: "AngularVelocityChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateClipFromInputControllerData, angular_velocity_channel),
            },
            FieldInfoData {
                name: "ChosenClipIndexChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "IntChannelData",
                rust_offset: offset_of!(CharacterStateClipFromInputControllerData, chosen_clip_index_channel),
            },
            FieldInfoData {
                name: "ChildControllerExtractedInfo",
                flags: MemberInfoFlags::new(144),
                field_type: "CharacterStateKeyframedTransformChannelControllerData-Array",
                rust_offset: offset_of!(CharacterStateClipFromInputControllerData, child_controller_extracted_info),
            },
            FieldInfoData {
                name: "DisplaySubjectPose",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateClipFromInputControllerData, display_subject_pose),
            },
            FieldInfoData {
                name: "ZeroYTargetVelocityInCompensation",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateClipFromInputControllerData, zero_y_target_velocity_in_compensation),
            },
            FieldInfoData {
                name: "ProjectedDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateClipFromInputControllerData, projected_distance),
            },
            FieldInfoData {
                name: "DesiredLocalTargetIfNoInputOrVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(CharacterStateClipFromInputControllerData, desired_local_target_if_no_input_or_velocity),
            },
            FieldInfoData {
                name: "AdjustDirection",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateClipFromInputControllerData, adjust_direction),
            },
            FieldInfoData {
                name: "DriveAcceleration",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateClipFromInputControllerData, drive_acceleration),
            },
            FieldInfoData {
                name: "SteerAnimatableFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateClipFromInputControllerData, steer_animatable_factor),
            },
            FieldInfoData {
                name: "AngleInfluenceMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateClipFromInputControllerData, angle_influence_multiplier),
            },
            FieldInfoData {
                name: "EndPositionInfluenceMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateClipFromInputControllerData, end_position_influence_multiplier),
            },
            FieldInfoData {
                name: "WeightsChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateClipFromInputControllerData, weights_channel),
            },
            FieldInfoData {
                name: "Weights",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(CharacterStateClipFromInputControllerData, weights),
            },
            FieldInfoData {
                name: "AntController",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CharacterStateClipFromInputControllerData, ant_controller),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATECLIPFROMINPUTCONTROLLERDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CharacterStateClipFromInputControllerData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATECLIPFROMINPUTCONTROLLERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATECLIPFROMINPUTCONTROLLERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateClipFromInputControllerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateClipFromInputControllerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateWarpClipControllerData {
    pub _glacier_base: CharacterStateBaseControllerData,
    pub ant_controller: super::ant::AntRef,
    pub extended_clip: Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>,
    pub display_subject_pose: bool,
    pub position_channel: Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>,
    pub velocity_channel: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub angular_velocity_channel: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub acceleration_channel: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub root_motion_channel: Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>,
    pub connect_channel: Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>,
    pub have_target_channel: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub warp_clip_targets: Vec<WarpClipTargetData>,
    pub target_connect_channel: Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>,
    pub use_look_at_target_orientation: bool,
    pub allow_pitch_rotation_in_look_at_target: bool,
    pub use_target_translation: bool,
    pub allow_adjust_translation_opposite_to_authored_velocity: bool,
    pub static_blend_weight: f32,
    pub static_blend_weight_translation: super::core::Vec3,
    pub weights_channel: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub weights: super::core::Vec3,
    pub blend_index_channel: Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>,
    pub dynamic_blend_weight_rotation_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub dynamic_blend_weight_translation_channel: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub local_offset_to_target_transform: super::core::LinearTransform,
}

pub trait CharacterStateWarpClipControllerDataTrait: CharacterStateBaseControllerDataTrait {
    fn ant_controller(&self) -> &super::ant::AntRef;
    fn extended_clip(&self) -> &Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>;
    fn display_subject_pose(&self) -> &bool;
    fn position_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>;
    fn velocity_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn angular_velocity_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn acceleration_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn root_motion_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>;
    fn connect_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>;
    fn have_target_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn warp_clip_targets(&self) -> &Vec<WarpClipTargetData>;
    fn target_connect_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>;
    fn use_look_at_target_orientation(&self) -> &bool;
    fn allow_pitch_rotation_in_look_at_target(&self) -> &bool;
    fn use_target_translation(&self) -> &bool;
    fn allow_adjust_translation_opposite_to_authored_velocity(&self) -> &bool;
    fn static_blend_weight(&self) -> &f32;
    fn static_blend_weight_translation(&self) -> &super::core::Vec3;
    fn weights_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn weights(&self) -> &super::core::Vec3;
    fn blend_index_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>;
    fn dynamic_blend_weight_rotation_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn dynamic_blend_weight_translation_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn local_offset_to_target_transform(&self) -> &super::core::LinearTransform;
}

impl CharacterStateWarpClipControllerDataTrait for CharacterStateWarpClipControllerData {
    fn ant_controller(&self) -> &super::ant::AntRef {
        &self.ant_controller
    }
    fn extended_clip(&self) -> &Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>> {
        &self.extended_clip
    }
    fn display_subject_pose(&self) -> &bool {
        &self.display_subject_pose
    }
    fn position_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>> {
        &self.position_channel
    }
    fn velocity_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.velocity_channel
    }
    fn angular_velocity_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.angular_velocity_channel
    }
    fn acceleration_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.acceleration_channel
    }
    fn root_motion_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>> {
        &self.root_motion_channel
    }
    fn connect_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>> {
        &self.connect_channel
    }
    fn have_target_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.have_target_channel
    }
    fn warp_clip_targets(&self) -> &Vec<WarpClipTargetData> {
        &self.warp_clip_targets
    }
    fn target_connect_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>> {
        &self.target_connect_channel
    }
    fn use_look_at_target_orientation(&self) -> &bool {
        &self.use_look_at_target_orientation
    }
    fn allow_pitch_rotation_in_look_at_target(&self) -> &bool {
        &self.allow_pitch_rotation_in_look_at_target
    }
    fn use_target_translation(&self) -> &bool {
        &self.use_target_translation
    }
    fn allow_adjust_translation_opposite_to_authored_velocity(&self) -> &bool {
        &self.allow_adjust_translation_opposite_to_authored_velocity
    }
    fn static_blend_weight(&self) -> &f32 {
        &self.static_blend_weight
    }
    fn static_blend_weight_translation(&self) -> &super::core::Vec3 {
        &self.static_blend_weight_translation
    }
    fn weights_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.weights_channel
    }
    fn weights(&self) -> &super::core::Vec3 {
        &self.weights
    }
    fn blend_index_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>> {
        &self.blend_index_channel
    }
    fn dynamic_blend_weight_rotation_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.dynamic_blend_weight_rotation_channel
    }
    fn dynamic_blend_weight_translation_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.dynamic_blend_weight_translation_channel
    }
    fn local_offset_to_target_transform(&self) -> &super::core::LinearTransform {
        &self.local_offset_to_target_transform
    }
}

impl CharacterStateBaseControllerDataTrait for CharacterStateWarpClipControllerData {
    fn asset_index(&self) -> &i32 {
        self._glacier_base.asset_index()
    }
    fn subjects(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>> {
        self._glacier_base.subjects()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for CharacterStateWarpClipControllerData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATEWARPCLIPCONTROLLERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateWarpClipControllerData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEBASECONTROLLERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateWarpClipControllerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AntController",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CharacterStateWarpClipControllerData, ant_controller),
            },
            FieldInfoData {
                name: "ExtendedClip",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterStateBaseControllerData",
                rust_offset: offset_of!(CharacterStateWarpClipControllerData, extended_clip),
            },
            FieldInfoData {
                name: "DisplaySubjectPose",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateWarpClipControllerData, display_subject_pose),
            },
            FieldInfoData {
                name: "PositionChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(CharacterStateWarpClipControllerData, position_channel),
            },
            FieldInfoData {
                name: "VelocityChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateWarpClipControllerData, velocity_channel),
            },
            FieldInfoData {
                name: "AngularVelocityChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateWarpClipControllerData, angular_velocity_channel),
            },
            FieldInfoData {
                name: "AccelerationChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateWarpClipControllerData, acceleration_channel),
            },
            FieldInfoData {
                name: "RootMotionChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(CharacterStateWarpClipControllerData, root_motion_channel),
            },
            FieldInfoData {
                name: "ConnectChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(CharacterStateWarpClipControllerData, connect_channel),
            },
            FieldInfoData {
                name: "HaveTargetChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(CharacterStateWarpClipControllerData, have_target_channel),
            },
            FieldInfoData {
                name: "WarpClipTargets",
                flags: MemberInfoFlags::new(144),
                field_type: "WarpClipTargetData-Array",
                rust_offset: offset_of!(CharacterStateWarpClipControllerData, warp_clip_targets),
            },
            FieldInfoData {
                name: "TargetConnectChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(CharacterStateWarpClipControllerData, target_connect_channel),
            },
            FieldInfoData {
                name: "UseLookAtTargetOrientation",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateWarpClipControllerData, use_look_at_target_orientation),
            },
            FieldInfoData {
                name: "AllowPitchRotationInLookAtTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateWarpClipControllerData, allow_pitch_rotation_in_look_at_target),
            },
            FieldInfoData {
                name: "UseTargetTranslation",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateWarpClipControllerData, use_target_translation),
            },
            FieldInfoData {
                name: "AllowAdjustTranslationOppositeToAuthoredVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateWarpClipControllerData, allow_adjust_translation_opposite_to_authored_velocity),
            },
            FieldInfoData {
                name: "StaticBlendWeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateWarpClipControllerData, static_blend_weight),
            },
            FieldInfoData {
                name: "StaticBlendWeightTranslation",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(CharacterStateWarpClipControllerData, static_blend_weight_translation),
            },
            FieldInfoData {
                name: "WeightsChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateWarpClipControllerData, weights_channel),
            },
            FieldInfoData {
                name: "Weights",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(CharacterStateWarpClipControllerData, weights),
            },
            FieldInfoData {
                name: "BlendIndexChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "IntChannelData",
                rust_offset: offset_of!(CharacterStateWarpClipControllerData, blend_index_channel),
            },
            FieldInfoData {
                name: "DynamicBlendWeightRotationChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateWarpClipControllerData, dynamic_blend_weight_rotation_channel),
            },
            FieldInfoData {
                name: "DynamicBlendWeightTranslationChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateWarpClipControllerData, dynamic_blend_weight_translation_channel),
            },
            FieldInfoData {
                name: "LocalOffsetToTargetTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(CharacterStateWarpClipControllerData, local_offset_to_target_transform),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEWARPCLIPCONTROLLERDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CharacterStateWarpClipControllerData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEWARPCLIPCONTROLLERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEWARPCLIPCONTROLLERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateWarpClipControllerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateWarpClipControllerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WarpClipTargetData {
    pub target_connect_channel: Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>,
    pub height_offset_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub forward_offset_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub side_offset_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub weights: super::core::Vec3,
}

pub trait WarpClipTargetDataTrait: TypeObject {
    fn target_connect_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>;
    fn height_offset_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn forward_offset_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn side_offset_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn weights(&self) -> &super::core::Vec3;
}

impl WarpClipTargetDataTrait for WarpClipTargetData {
    fn target_connect_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>> {
        &self.target_connect_channel
    }
    fn height_offset_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.height_offset_channel
    }
    fn forward_offset_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.forward_offset_channel
    }
    fn side_offset_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.side_offset_channel
    }
    fn weights(&self) -> &super::core::Vec3 {
        &self.weights
    }
}

pub static WARPCLIPTARGETDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WarpClipTargetData",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WarpClipTargetData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "TargetConnectChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(WarpClipTargetData, target_connect_channel),
            },
            FieldInfoData {
                name: "HeightOffsetChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(WarpClipTargetData, height_offset_channel),
            },
            FieldInfoData {
                name: "ForwardOffsetChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(WarpClipTargetData, forward_offset_channel),
            },
            FieldInfoData {
                name: "SideOffsetChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(WarpClipTargetData, side_offset_channel),
            },
            FieldInfoData {
                name: "Weights",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(WarpClipTargetData, weights),
            },
        ],
    }),
    array_type: Some(WARPCLIPTARGETDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for WarpClipTargetData {
    fn type_info(&self) -> &'static TypeInfo {
        WARPCLIPTARGETDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static WARPCLIPTARGETDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WarpClipTargetData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("WarpClipTargetData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStatePhaseControllerData {
    pub _glacier_base: CharacterStateBaseControllerData,
    pub ant_controller: super::ant::AntRef,
    pub phase_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub time_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub phase_calculation_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub phase_calculation_min_bound: f32,
    pub phase_calculation_max_bound: f32,
}

pub trait CharacterStatePhaseControllerDataTrait: CharacterStateBaseControllerDataTrait {
    fn ant_controller(&self) -> &super::ant::AntRef;
    fn phase_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn time_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn phase_calculation_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn phase_calculation_min_bound(&self) -> &f32;
    fn phase_calculation_max_bound(&self) -> &f32;
}

impl CharacterStatePhaseControllerDataTrait for CharacterStatePhaseControllerData {
    fn ant_controller(&self) -> &super::ant::AntRef {
        &self.ant_controller
    }
    fn phase_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.phase_channel
    }
    fn time_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.time_channel
    }
    fn phase_calculation_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.phase_calculation_channel
    }
    fn phase_calculation_min_bound(&self) -> &f32 {
        &self.phase_calculation_min_bound
    }
    fn phase_calculation_max_bound(&self) -> &f32 {
        &self.phase_calculation_max_bound
    }
}

impl CharacterStateBaseControllerDataTrait for CharacterStatePhaseControllerData {
    fn asset_index(&self) -> &i32 {
        self._glacier_base.asset_index()
    }
    fn subjects(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>> {
        self._glacier_base.subjects()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for CharacterStatePhaseControllerData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATEPHASECONTROLLERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStatePhaseControllerData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEBASECONTROLLERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStatePhaseControllerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AntController",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CharacterStatePhaseControllerData, ant_controller),
            },
            FieldInfoData {
                name: "PhaseChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStatePhaseControllerData, phase_channel),
            },
            FieldInfoData {
                name: "TimeChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStatePhaseControllerData, time_channel),
            },
            FieldInfoData {
                name: "PhaseCalculationChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStatePhaseControllerData, phase_calculation_channel),
            },
            FieldInfoData {
                name: "PhaseCalculationMinBound",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStatePhaseControllerData, phase_calculation_min_bound),
            },
            FieldInfoData {
                name: "PhaseCalculationMaxBound",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStatePhaseControllerData, phase_calculation_max_bound),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEPHASECONTROLLERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStatePhaseControllerData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEPHASECONTROLLERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEPHASECONTROLLERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStatePhaseControllerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStatePhaseControllerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateClipControllerData {
    pub _glacier_base: CharacterStateBaseControllerData,
    pub included_channels: Option<Arc<Mutex<dyn super::soldier_shared::ChannelSetDataTrait>>>,
    pub channel_controller: Option<Arc<Mutex<dyn CharacterStateKeyframedChannelControllerDataTrait>>>,
    pub transform_channel_controller: Option<Arc<Mutex<dyn CharacterStateKeyframedTransformChannelControllerDataTrait>>>,
    pub looping: bool,
    pub length: u32,
    pub clip_offset: u32,
    pub controller: super::ant::AntRef,
    pub clip_infos: Vec<CharacterStateClipInfo>,
    pub override_subjects: Vec<ClipOverrideMapping>,
}

pub trait CharacterStateClipControllerDataTrait: CharacterStateBaseControllerDataTrait {
    fn included_channels(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::ChannelSetDataTrait>>>;
    fn channel_controller(&self) -> &Option<Arc<Mutex<dyn CharacterStateKeyframedChannelControllerDataTrait>>>;
    fn transform_channel_controller(&self) -> &Option<Arc<Mutex<dyn CharacterStateKeyframedTransformChannelControllerDataTrait>>>;
    fn looping(&self) -> &bool;
    fn length(&self) -> &u32;
    fn clip_offset(&self) -> &u32;
    fn controller(&self) -> &super::ant::AntRef;
    fn clip_infos(&self) -> &Vec<CharacterStateClipInfo>;
    fn override_subjects(&self) -> &Vec<ClipOverrideMapping>;
}

impl CharacterStateClipControllerDataTrait for CharacterStateClipControllerData {
    fn included_channels(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::ChannelSetDataTrait>>> {
        &self.included_channels
    }
    fn channel_controller(&self) -> &Option<Arc<Mutex<dyn CharacterStateKeyframedChannelControllerDataTrait>>> {
        &self.channel_controller
    }
    fn transform_channel_controller(&self) -> &Option<Arc<Mutex<dyn CharacterStateKeyframedTransformChannelControllerDataTrait>>> {
        &self.transform_channel_controller
    }
    fn looping(&self) -> &bool {
        &self.looping
    }
    fn length(&self) -> &u32 {
        &self.length
    }
    fn clip_offset(&self) -> &u32 {
        &self.clip_offset
    }
    fn controller(&self) -> &super::ant::AntRef {
        &self.controller
    }
    fn clip_infos(&self) -> &Vec<CharacterStateClipInfo> {
        &self.clip_infos
    }
    fn override_subjects(&self) -> &Vec<ClipOverrideMapping> {
        &self.override_subjects
    }
}

impl CharacterStateBaseControllerDataTrait for CharacterStateClipControllerData {
    fn asset_index(&self) -> &i32 {
        self._glacier_base.asset_index()
    }
    fn subjects(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>> {
        self._glacier_base.subjects()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for CharacterStateClipControllerData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATECLIPCONTROLLERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateClipControllerData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEBASECONTROLLERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateClipControllerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "IncludedChannels",
                flags: MemberInfoFlags::new(0),
                field_type: "ChannelSetData",
                rust_offset: offset_of!(CharacterStateClipControllerData, included_channels),
            },
            FieldInfoData {
                name: "ChannelController",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterStateKeyframedChannelControllerData",
                rust_offset: offset_of!(CharacterStateClipControllerData, channel_controller),
            },
            FieldInfoData {
                name: "TransformChannelController",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterStateKeyframedTransformChannelControllerData",
                rust_offset: offset_of!(CharacterStateClipControllerData, transform_channel_controller),
            },
            FieldInfoData {
                name: "Looping",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateClipControllerData, looping),
            },
            FieldInfoData {
                name: "Length",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(CharacterStateClipControllerData, length),
            },
            FieldInfoData {
                name: "ClipOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(CharacterStateClipControllerData, clip_offset),
            },
            FieldInfoData {
                name: "Controller",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CharacterStateClipControllerData, controller),
            },
            FieldInfoData {
                name: "ClipInfos",
                flags: MemberInfoFlags::new(144),
                field_type: "CharacterStateClipInfo-Array",
                rust_offset: offset_of!(CharacterStateClipControllerData, clip_infos),
            },
            FieldInfoData {
                name: "OverrideSubjects",
                flags: MemberInfoFlags::new(144),
                field_type: "ClipOverrideMapping-Array",
                rust_offset: offset_of!(CharacterStateClipControllerData, override_subjects),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATECLIPCONTROLLERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateClipControllerData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATECLIPCONTROLLERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATECLIPCONTROLLERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateClipControllerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateClipControllerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ClipOverrideMapping {
    pub enum_value: i32,
    pub controller: Option<Arc<Mutex<dyn CharacterStateClipControllerDataTrait>>>,
    pub enum_game_state_guid: glacier_util::guid::Guid,
}

pub trait ClipOverrideMappingTrait: TypeObject {
    fn enum_value(&self) -> &i32;
    fn controller(&self) -> &Option<Arc<Mutex<dyn CharacterStateClipControllerDataTrait>>>;
    fn enum_game_state_guid(&self) -> &glacier_util::guid::Guid;
}

impl ClipOverrideMappingTrait for ClipOverrideMapping {
    fn enum_value(&self) -> &i32 {
        &self.enum_value
    }
    fn controller(&self) -> &Option<Arc<Mutex<dyn CharacterStateClipControllerDataTrait>>> {
        &self.controller
    }
    fn enum_game_state_guid(&self) -> &glacier_util::guid::Guid {
        &self.enum_game_state_guid
    }
}

pub static CLIPOVERRIDEMAPPING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClipOverrideMapping",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ClipOverrideMapping as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "EnumValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ClipOverrideMapping, enum_value),
            },
            FieldInfoData {
                name: "Controller",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterStateClipControllerData",
                rust_offset: offset_of!(ClipOverrideMapping, controller),
            },
            FieldInfoData {
                name: "EnumGameStateGuid",
                flags: MemberInfoFlags::new(0),
                field_type: "Guid",
                rust_offset: offset_of!(ClipOverrideMapping, enum_game_state_guid),
            },
        ],
    }),
    array_type: Some(CLIPOVERRIDEMAPPING_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ClipOverrideMapping {
    fn type_info(&self) -> &'static TypeInfo {
        CLIPOVERRIDEMAPPING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CLIPOVERRIDEMAPPING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClipOverrideMapping-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("ClipOverrideMapping"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateClipInfo {
    pub looping: bool,
    pub length: f32,
    pub clip_offset: u32,
    pub controller: super::ant::AntRef,
    pub start_time: f32,
    pub start_in_time: f32,
    pub end_in_time: f32,
    pub scale: f32,
    pub blend_time: f32,
    pub mirrored: bool,
}

pub trait CharacterStateClipInfoTrait: TypeObject {
    fn looping(&self) -> &bool;
    fn length(&self) -> &f32;
    fn clip_offset(&self) -> &u32;
    fn controller(&self) -> &super::ant::AntRef;
    fn start_time(&self) -> &f32;
    fn start_in_time(&self) -> &f32;
    fn end_in_time(&self) -> &f32;
    fn scale(&self) -> &f32;
    fn blend_time(&self) -> &f32;
    fn mirrored(&self) -> &bool;
}

impl CharacterStateClipInfoTrait for CharacterStateClipInfo {
    fn looping(&self) -> &bool {
        &self.looping
    }
    fn length(&self) -> &f32 {
        &self.length
    }
    fn clip_offset(&self) -> &u32 {
        &self.clip_offset
    }
    fn controller(&self) -> &super::ant::AntRef {
        &self.controller
    }
    fn start_time(&self) -> &f32 {
        &self.start_time
    }
    fn start_in_time(&self) -> &f32 {
        &self.start_in_time
    }
    fn end_in_time(&self) -> &f32 {
        &self.end_in_time
    }
    fn scale(&self) -> &f32 {
        &self.scale
    }
    fn blend_time(&self) -> &f32 {
        &self.blend_time
    }
    fn mirrored(&self) -> &bool {
        &self.mirrored
    }
}

pub static CHARACTERSTATECLIPINFO_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateClipInfo",
    flags: MemberInfoFlags::new(32841),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateClipInfo as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Looping",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateClipInfo, looping),
            },
            FieldInfoData {
                name: "Length",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateClipInfo, length),
            },
            FieldInfoData {
                name: "ClipOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(CharacterStateClipInfo, clip_offset),
            },
            FieldInfoData {
                name: "Controller",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CharacterStateClipInfo, controller),
            },
            FieldInfoData {
                name: "StartTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateClipInfo, start_time),
            },
            FieldInfoData {
                name: "StartInTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateClipInfo, start_in_time),
            },
            FieldInfoData {
                name: "EndInTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateClipInfo, end_in_time),
            },
            FieldInfoData {
                name: "Scale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateClipInfo, scale),
            },
            FieldInfoData {
                name: "BlendTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateClipInfo, blend_time),
            },
            FieldInfoData {
                name: "Mirrored",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterStateClipInfo, mirrored),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATECLIPINFO_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for CharacterStateClipInfo {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATECLIPINFO_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATECLIPINFO_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateClipInfo-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateClipInfo"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateHelperControllerData {
    pub _glacier_base: CharacterStateBaseControllerData,
    pub ant_controller: super::ant::AntRef,
    pub velocity_channel: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub angular_velocity_channel: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub ground_normal_channel: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub forward_ground_angle_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub right_ground_angle_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub forward_speed_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub strafe_speed_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub speed_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub current_transform_channel: Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>,
    pub throttle_input_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub strafe_input_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub is_moving_channel: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub desired_yaw_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub input_magnitude_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub relative_movement_direction_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub has_reached_desired_angle_channel: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub desired_angle_threshold: f32,
    pub has_reached_desired_brake_angle_channel: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub desired_brake_angle_threshold: f32,
    pub is_throttle_or_strafe_input_channel: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub leg_world_yaw_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub current_pose_channel: Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>,
    pub changing_to_pose_channel: Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>,
    pub threshold_items: Vec<VelocityThresholdItem>,
    pub float_channel_threshold_items: Vec<FloatChannelThresholdItem>,
    pub vec3_channel_threshold_items: Vec<Vec3ChannelThresholdItem>,
    pub vec3_channel_range_items: Vec<Vec3ChannelRangeItem>,
    pub within_angle_arc_items: Vec<WithinAngleArcItem>,
    pub positions_within_angles: Vec<PositionWithinAngle>,
    pub angular_yaw_speed_output_items: Vec<AngularYawSpeedOutput>,
}

pub trait CharacterStateHelperControllerDataTrait: CharacterStateBaseControllerDataTrait {
    fn ant_controller(&self) -> &super::ant::AntRef;
    fn velocity_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn angular_velocity_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn ground_normal_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn forward_ground_angle_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn right_ground_angle_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn forward_speed_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn strafe_speed_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn speed_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn current_transform_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>;
    fn throttle_input_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn strafe_input_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn is_moving_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn desired_yaw_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn input_magnitude_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn relative_movement_direction_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn has_reached_desired_angle_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn desired_angle_threshold(&self) -> &f32;
    fn has_reached_desired_brake_angle_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn desired_brake_angle_threshold(&self) -> &f32;
    fn is_throttle_or_strafe_input_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn leg_world_yaw_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn current_pose_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>;
    fn changing_to_pose_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>;
    fn threshold_items(&self) -> &Vec<VelocityThresholdItem>;
    fn float_channel_threshold_items(&self) -> &Vec<FloatChannelThresholdItem>;
    fn vec3_channel_threshold_items(&self) -> &Vec<Vec3ChannelThresholdItem>;
    fn vec3_channel_range_items(&self) -> &Vec<Vec3ChannelRangeItem>;
    fn within_angle_arc_items(&self) -> &Vec<WithinAngleArcItem>;
    fn positions_within_angles(&self) -> &Vec<PositionWithinAngle>;
    fn angular_yaw_speed_output_items(&self) -> &Vec<AngularYawSpeedOutput>;
}

impl CharacterStateHelperControllerDataTrait for CharacterStateHelperControllerData {
    fn ant_controller(&self) -> &super::ant::AntRef {
        &self.ant_controller
    }
    fn velocity_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.velocity_channel
    }
    fn angular_velocity_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.angular_velocity_channel
    }
    fn ground_normal_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.ground_normal_channel
    }
    fn forward_ground_angle_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.forward_ground_angle_channel
    }
    fn right_ground_angle_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.right_ground_angle_channel
    }
    fn forward_speed_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.forward_speed_channel
    }
    fn strafe_speed_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.strafe_speed_channel
    }
    fn speed_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.speed_channel
    }
    fn current_transform_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>> {
        &self.current_transform_channel
    }
    fn throttle_input_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.throttle_input_channel
    }
    fn strafe_input_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.strafe_input_channel
    }
    fn is_moving_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.is_moving_channel
    }
    fn desired_yaw_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.desired_yaw_channel
    }
    fn input_magnitude_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.input_magnitude_channel
    }
    fn relative_movement_direction_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.relative_movement_direction_channel
    }
    fn has_reached_desired_angle_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.has_reached_desired_angle_channel
    }
    fn desired_angle_threshold(&self) -> &f32 {
        &self.desired_angle_threshold
    }
    fn has_reached_desired_brake_angle_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.has_reached_desired_brake_angle_channel
    }
    fn desired_brake_angle_threshold(&self) -> &f32 {
        &self.desired_brake_angle_threshold
    }
    fn is_throttle_or_strafe_input_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.is_throttle_or_strafe_input_channel
    }
    fn leg_world_yaw_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.leg_world_yaw_channel
    }
    fn current_pose_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>> {
        &self.current_pose_channel
    }
    fn changing_to_pose_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>> {
        &self.changing_to_pose_channel
    }
    fn threshold_items(&self) -> &Vec<VelocityThresholdItem> {
        &self.threshold_items
    }
    fn float_channel_threshold_items(&self) -> &Vec<FloatChannelThresholdItem> {
        &self.float_channel_threshold_items
    }
    fn vec3_channel_threshold_items(&self) -> &Vec<Vec3ChannelThresholdItem> {
        &self.vec3_channel_threshold_items
    }
    fn vec3_channel_range_items(&self) -> &Vec<Vec3ChannelRangeItem> {
        &self.vec3_channel_range_items
    }
    fn within_angle_arc_items(&self) -> &Vec<WithinAngleArcItem> {
        &self.within_angle_arc_items
    }
    fn positions_within_angles(&self) -> &Vec<PositionWithinAngle> {
        &self.positions_within_angles
    }
    fn angular_yaw_speed_output_items(&self) -> &Vec<AngularYawSpeedOutput> {
        &self.angular_yaw_speed_output_items
    }
}

impl CharacterStateBaseControllerDataTrait for CharacterStateHelperControllerData {
    fn asset_index(&self) -> &i32 {
        self._glacier_base.asset_index()
    }
    fn subjects(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>> {
        self._glacier_base.subjects()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for CharacterStateHelperControllerData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATEHELPERCONTROLLERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateHelperControllerData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEBASECONTROLLERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateHelperControllerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AntController",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CharacterStateHelperControllerData, ant_controller),
            },
            FieldInfoData {
                name: "VelocityChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateHelperControllerData, velocity_channel),
            },
            FieldInfoData {
                name: "AngularVelocityChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateHelperControllerData, angular_velocity_channel),
            },
            FieldInfoData {
                name: "GroundNormalChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(CharacterStateHelperControllerData, ground_normal_channel),
            },
            FieldInfoData {
                name: "ForwardGroundAngleChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateHelperControllerData, forward_ground_angle_channel),
            },
            FieldInfoData {
                name: "RightGroundAngleChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateHelperControllerData, right_ground_angle_channel),
            },
            FieldInfoData {
                name: "ForwardSpeedChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateHelperControllerData, forward_speed_channel),
            },
            FieldInfoData {
                name: "StrafeSpeedChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateHelperControllerData, strafe_speed_channel),
            },
            FieldInfoData {
                name: "SpeedChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateHelperControllerData, speed_channel),
            },
            FieldInfoData {
                name: "CurrentTransformChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(CharacterStateHelperControllerData, current_transform_channel),
            },
            FieldInfoData {
                name: "ThrottleInputChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateHelperControllerData, throttle_input_channel),
            },
            FieldInfoData {
                name: "StrafeInputChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateHelperControllerData, strafe_input_channel),
            },
            FieldInfoData {
                name: "IsMovingChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(CharacterStateHelperControllerData, is_moving_channel),
            },
            FieldInfoData {
                name: "DesiredYawChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateHelperControllerData, desired_yaw_channel),
            },
            FieldInfoData {
                name: "InputMagnitudeChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateHelperControllerData, input_magnitude_channel),
            },
            FieldInfoData {
                name: "RelativeMovementDirectionChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateHelperControllerData, relative_movement_direction_channel),
            },
            FieldInfoData {
                name: "HasReachedDesiredAngleChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(CharacterStateHelperControllerData, has_reached_desired_angle_channel),
            },
            FieldInfoData {
                name: "DesiredAngleThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateHelperControllerData, desired_angle_threshold),
            },
            FieldInfoData {
                name: "HasReachedDesiredBrakeAngleChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(CharacterStateHelperControllerData, has_reached_desired_brake_angle_channel),
            },
            FieldInfoData {
                name: "DesiredBrakeAngleThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterStateHelperControllerData, desired_brake_angle_threshold),
            },
            FieldInfoData {
                name: "IsThrottleOrStrafeInputChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(CharacterStateHelperControllerData, is_throttle_or_strafe_input_channel),
            },
            FieldInfoData {
                name: "LegWorldYawChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(CharacterStateHelperControllerData, leg_world_yaw_channel),
            },
            FieldInfoData {
                name: "CurrentPoseChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "IntChannelData",
                rust_offset: offset_of!(CharacterStateHelperControllerData, current_pose_channel),
            },
            FieldInfoData {
                name: "ChangingToPoseChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "IntChannelData",
                rust_offset: offset_of!(CharacterStateHelperControllerData, changing_to_pose_channel),
            },
            FieldInfoData {
                name: "ThresholdItems",
                flags: MemberInfoFlags::new(144),
                field_type: "VelocityThresholdItem-Array",
                rust_offset: offset_of!(CharacterStateHelperControllerData, threshold_items),
            },
            FieldInfoData {
                name: "FloatChannelThresholdItems",
                flags: MemberInfoFlags::new(144),
                field_type: "FloatChannelThresholdItem-Array",
                rust_offset: offset_of!(CharacterStateHelperControllerData, float_channel_threshold_items),
            },
            FieldInfoData {
                name: "Vec3ChannelThresholdItems",
                flags: MemberInfoFlags::new(144),
                field_type: "Vec3ChannelThresholdItem-Array",
                rust_offset: offset_of!(CharacterStateHelperControllerData, vec3_channel_threshold_items),
            },
            FieldInfoData {
                name: "Vec3ChannelRangeItems",
                flags: MemberInfoFlags::new(144),
                field_type: "Vec3ChannelRangeItem-Array",
                rust_offset: offset_of!(CharacterStateHelperControllerData, vec3_channel_range_items),
            },
            FieldInfoData {
                name: "WithinAngleArcItems",
                flags: MemberInfoFlags::new(144),
                field_type: "WithinAngleArcItem-Array",
                rust_offset: offset_of!(CharacterStateHelperControllerData, within_angle_arc_items),
            },
            FieldInfoData {
                name: "PositionsWithinAngles",
                flags: MemberInfoFlags::new(144),
                field_type: "PositionWithinAngle-Array",
                rust_offset: offset_of!(CharacterStateHelperControllerData, positions_within_angles),
            },
            FieldInfoData {
                name: "AngularYawSpeedOutputItems",
                flags: MemberInfoFlags::new(144),
                field_type: "AngularYawSpeedOutput-Array",
                rust_offset: offset_of!(CharacterStateHelperControllerData, angular_yaw_speed_output_items),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEHELPERCONTROLLERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateHelperControllerData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEHELPERCONTROLLERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEHELPERCONTROLLERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateHelperControllerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateHelperControllerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AngularYawSpeedOutput {
    pub multiply_value: f32,
    pub addition_value: f32,
    pub angular_yaw_speed_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
}

pub trait AngularYawSpeedOutputTrait: TypeObject {
    fn multiply_value(&self) -> &f32;
    fn addition_value(&self) -> &f32;
    fn angular_yaw_speed_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
}

impl AngularYawSpeedOutputTrait for AngularYawSpeedOutput {
    fn multiply_value(&self) -> &f32 {
        &self.multiply_value
    }
    fn addition_value(&self) -> &f32 {
        &self.addition_value
    }
    fn angular_yaw_speed_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.angular_yaw_speed_channel
    }
}

pub static ANGULARYAWSPEEDOUTPUT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AngularYawSpeedOutput",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AngularYawSpeedOutput as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MultiplyValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AngularYawSpeedOutput, multiply_value),
            },
            FieldInfoData {
                name: "AdditionValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AngularYawSpeedOutput, addition_value),
            },
            FieldInfoData {
                name: "AngularYawSpeedChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(AngularYawSpeedOutput, angular_yaw_speed_channel),
            },
        ],
    }),
    array_type: Some(ANGULARYAWSPEEDOUTPUT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AngularYawSpeedOutput {
    fn type_info(&self) -> &'static TypeInfo {
        ANGULARYAWSPEEDOUTPUT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ANGULARYAWSPEEDOUTPUT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AngularYawSpeedOutput-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("AngularYawSpeedOutput"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PositionWithinAngle {
    pub own_transform: Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>,
    pub target_transform: Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>,
    pub items: Vec<PositionWithinAngleItem>,
}

pub trait PositionWithinAngleTrait: TypeObject {
    fn own_transform(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>;
    fn target_transform(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>>;
    fn items(&self) -> &Vec<PositionWithinAngleItem>;
}

impl PositionWithinAngleTrait for PositionWithinAngle {
    fn own_transform(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>> {
        &self.own_transform
    }
    fn target_transform(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::TransformChannelDataTrait>>> {
        &self.target_transform
    }
    fn items(&self) -> &Vec<PositionWithinAngleItem> {
        &self.items
    }
}

pub static POSITIONWITHINANGLE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PositionWithinAngle",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PositionWithinAngle as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "OwnTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(PositionWithinAngle, own_transform),
            },
            FieldInfoData {
                name: "TargetTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformChannelData",
                rust_offset: offset_of!(PositionWithinAngle, target_transform),
            },
            FieldInfoData {
                name: "Items",
                flags: MemberInfoFlags::new(144),
                field_type: "PositionWithinAngleItem-Array",
                rust_offset: offset_of!(PositionWithinAngle, items),
            },
        ],
    }),
    array_type: Some(POSITIONWITHINANGLE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PositionWithinAngle {
    fn type_info(&self) -> &'static TypeInfo {
        POSITIONWITHINANGLE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static POSITIONWITHINANGLE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PositionWithinAngle-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PositionWithinAngle"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PositionWithinAngleItem {
    pub arc_angle: f32,
    pub invert_test: bool,
    pub within_angle_arc_channel: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
}

pub trait PositionWithinAngleItemTrait: TypeObject {
    fn arc_angle(&self) -> &f32;
    fn invert_test(&self) -> &bool;
    fn within_angle_arc_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
}

impl PositionWithinAngleItemTrait for PositionWithinAngleItem {
    fn arc_angle(&self) -> &f32 {
        &self.arc_angle
    }
    fn invert_test(&self) -> &bool {
        &self.invert_test
    }
    fn within_angle_arc_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.within_angle_arc_channel
    }
}

pub static POSITIONWITHINANGLEITEM_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PositionWithinAngleItem",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PositionWithinAngleItem as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ArcAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PositionWithinAngleItem, arc_angle),
            },
            FieldInfoData {
                name: "InvertTest",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PositionWithinAngleItem, invert_test),
            },
            FieldInfoData {
                name: "WithinAngleArcChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(PositionWithinAngleItem, within_angle_arc_channel),
            },
        ],
    }),
    array_type: Some(POSITIONWITHINANGLEITEM_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PositionWithinAngleItem {
    fn type_info(&self) -> &'static TypeInfo {
        POSITIONWITHINANGLEITEM_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static POSITIONWITHINANGLEITEM_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PositionWithinAngleItem-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PositionWithinAngleItem"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WithinAngleArcItem {
    pub arc_offset: f32,
    pub arc_angle: f32,
    pub invert_test: bool,
    pub angle_input_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub within_angle_arc_channel: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
}

pub trait WithinAngleArcItemTrait: TypeObject {
    fn arc_offset(&self) -> &f32;
    fn arc_angle(&self) -> &f32;
    fn invert_test(&self) -> &bool;
    fn angle_input_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn within_angle_arc_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
}

impl WithinAngleArcItemTrait for WithinAngleArcItem {
    fn arc_offset(&self) -> &f32 {
        &self.arc_offset
    }
    fn arc_angle(&self) -> &f32 {
        &self.arc_angle
    }
    fn invert_test(&self) -> &bool {
        &self.invert_test
    }
    fn angle_input_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.angle_input_channel
    }
    fn within_angle_arc_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.within_angle_arc_channel
    }
}

pub static WITHINANGLEARCITEM_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WithinAngleArcItem",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WithinAngleArcItem as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ArcOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WithinAngleArcItem, arc_offset),
            },
            FieldInfoData {
                name: "ArcAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WithinAngleArcItem, arc_angle),
            },
            FieldInfoData {
                name: "InvertTest",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WithinAngleArcItem, invert_test),
            },
            FieldInfoData {
                name: "AngleInputChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(WithinAngleArcItem, angle_input_channel),
            },
            FieldInfoData {
                name: "WithinAngleArcChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(WithinAngleArcItem, within_angle_arc_channel),
            },
        ],
    }),
    array_type: Some(WITHINANGLEARCITEM_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WithinAngleArcItem {
    fn type_info(&self) -> &'static TypeInfo {
        WITHINANGLEARCITEM_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static WITHINANGLEARCITEM_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WithinAngleArcItem-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("WithinAngleArcItem"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Vec3ChannelRangeItem {
    pub vec3_channel: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub item_mode: Vec3ItemMode,
    pub execution_mode: Vec3ChannelRangeExecutionMode,
    pub ranges: Vec<VelocityRangeItem>,
    pub length_output_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
}

pub trait Vec3ChannelRangeItemTrait: TypeObject {
    fn vec3_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn item_mode(&self) -> &Vec3ItemMode;
    fn execution_mode(&self) -> &Vec3ChannelRangeExecutionMode;
    fn ranges(&self) -> &Vec<VelocityRangeItem>;
    fn length_output_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
}

impl Vec3ChannelRangeItemTrait for Vec3ChannelRangeItem {
    fn vec3_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.vec3_channel
    }
    fn item_mode(&self) -> &Vec3ItemMode {
        &self.item_mode
    }
    fn execution_mode(&self) -> &Vec3ChannelRangeExecutionMode {
        &self.execution_mode
    }
    fn ranges(&self) -> &Vec<VelocityRangeItem> {
        &self.ranges
    }
    fn length_output_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.length_output_channel
    }
}

pub static VEC3CHANNELRANGEITEM_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3ChannelRangeItem",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec3ChannelRangeItem as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Vec3Channel",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(Vec3ChannelRangeItem, vec3_channel),
            },
            FieldInfoData {
                name: "ItemMode",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ItemMode",
                rust_offset: offset_of!(Vec3ChannelRangeItem, item_mode),
            },
            FieldInfoData {
                name: "ExecutionMode",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelRangeExecutionMode",
                rust_offset: offset_of!(Vec3ChannelRangeItem, execution_mode),
            },
            FieldInfoData {
                name: "Ranges",
                flags: MemberInfoFlags::new(144),
                field_type: "VelocityRangeItem-Array",
                rust_offset: offset_of!(Vec3ChannelRangeItem, ranges),
            },
            FieldInfoData {
                name: "LengthOutputChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(Vec3ChannelRangeItem, length_output_channel),
            },
        ],
    }),
    array_type: Some(VEC3CHANNELRANGEITEM_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for Vec3ChannelRangeItem {
    fn type_info(&self) -> &'static TypeInfo {
        VEC3CHANNELRANGEITEM_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VEC3CHANNELRANGEITEM_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3ChannelRangeItem-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("Vec3ChannelRangeItem"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Vec3ChannelThresholdItem {
    pub vec3_channel: Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>,
    pub mode: Vec3ItemMode,
    pub thresholds: Vec<VelocityThresholdItem>,
    pub length_output_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
}

pub trait Vec3ChannelThresholdItemTrait: TypeObject {
    fn vec3_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>>;
    fn mode(&self) -> &Vec3ItemMode;
    fn thresholds(&self) -> &Vec<VelocityThresholdItem>;
    fn length_output_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
}

impl Vec3ChannelThresholdItemTrait for Vec3ChannelThresholdItem {
    fn vec3_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::Vec3ChannelDataTrait>>> {
        &self.vec3_channel
    }
    fn mode(&self) -> &Vec3ItemMode {
        &self.mode
    }
    fn thresholds(&self) -> &Vec<VelocityThresholdItem> {
        &self.thresholds
    }
    fn length_output_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.length_output_channel
    }
}

pub static VEC3CHANNELTHRESHOLDITEM_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3ChannelThresholdItem",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec3ChannelThresholdItem as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Vec3Channel",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ChannelData",
                rust_offset: offset_of!(Vec3ChannelThresholdItem, vec3_channel),
            },
            FieldInfoData {
                name: "Mode",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3ItemMode",
                rust_offset: offset_of!(Vec3ChannelThresholdItem, mode),
            },
            FieldInfoData {
                name: "Thresholds",
                flags: MemberInfoFlags::new(144),
                field_type: "VelocityThresholdItem-Array",
                rust_offset: offset_of!(Vec3ChannelThresholdItem, thresholds),
            },
            FieldInfoData {
                name: "LengthOutputChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(Vec3ChannelThresholdItem, length_output_channel),
            },
        ],
    }),
    array_type: Some(VEC3CHANNELTHRESHOLDITEM_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for Vec3ChannelThresholdItem {
    fn type_info(&self) -> &'static TypeInfo {
        VEC3CHANNELTHRESHOLDITEM_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VEC3CHANNELTHRESHOLDITEM_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3ChannelThresholdItem-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("Vec3ChannelThresholdItem"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FloatChannelThresholdItem {
    pub float_channel: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub thresholds: Vec<VelocityThresholdItem>,
}

pub trait FloatChannelThresholdItemTrait: TypeObject {
    fn float_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn thresholds(&self) -> &Vec<VelocityThresholdItem>;
}

impl FloatChannelThresholdItemTrait for FloatChannelThresholdItem {
    fn float_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.float_channel
    }
    fn thresholds(&self) -> &Vec<VelocityThresholdItem> {
        &self.thresholds
    }
}

pub static FLOATCHANNELTHRESHOLDITEM_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatChannelThresholdItem",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FloatChannelThresholdItem as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "FloatChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(FloatChannelThresholdItem, float_channel),
            },
            FieldInfoData {
                name: "Thresholds",
                flags: MemberInfoFlags::new(144),
                field_type: "VelocityThresholdItem-Array",
                rust_offset: offset_of!(FloatChannelThresholdItem, thresholds),
            },
        ],
    }),
    array_type: Some(FLOATCHANNELTHRESHOLDITEM_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FloatChannelThresholdItem {
    fn type_info(&self) -> &'static TypeInfo {
        FLOATCHANNELTHRESHOLDITEM_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static FLOATCHANNELTHRESHOLDITEM_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatChannelThresholdItem-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("FloatChannelThresholdItem"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum Vec3ChannelRangeExecutionMode {
    #[default]
    Vec3ChannelRangeExecutionMode_All = 0,
    Vec3ChannelRangeExecutionMode_UntilMatch = 1,
}

pub static VEC3CHANNELRANGEEXECUTIONMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3ChannelRangeExecutionMode",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(VEC3CHANNELRANGEEXECUTIONMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for Vec3ChannelRangeExecutionMode {
    fn type_info(&self) -> &'static TypeInfo {
        VEC3CHANNELRANGEEXECUTIONMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VEC3CHANNELRANGEEXECUTIONMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3ChannelRangeExecutionMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("Vec3ChannelRangeExecutionMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum Vec3ItemMode {
    #[default]
    Vec3ChannelThresholdVec3ItemMode_X = 0,
    Vec3ChannelThresholdVec3ItemMode_Y = 1,
    Vec3ChannelThresholdVec3ItemMode_Z = 2,
    Vec3ChannelThresholdVec3ItemMode_Length = 3,
    Vec3ChannelThresholdVec3ItemMode_LengthXZ = 4,
    Vec3ChannelThresholdVec3ItemMode_LengthYZ = 5,
    Vec3ChannelThresholdVec3ItemMode_LengthXY = 6,
}

pub static VEC3ITEMMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3ItemMode",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(VEC3ITEMMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for Vec3ItemMode {
    fn type_info(&self) -> &'static TypeInfo {
        VEC3ITEMMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VEC3ITEMMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3ItemMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("Vec3ItemMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VelocityRangeItem {
    pub min: f32,
    pub max: f32,
    pub inside_range_channel: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub value_to_set: i32,
    pub int_channel: Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>,
    pub bool_channel: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
}

pub trait VelocityRangeItemTrait: TypeObject {
    fn min(&self) -> &f32;
    fn max(&self) -> &f32;
    fn inside_range_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn value_to_set(&self) -> &i32;
    fn int_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>>;
    fn bool_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
}

impl VelocityRangeItemTrait for VelocityRangeItem {
    fn min(&self) -> &f32 {
        &self.min
    }
    fn max(&self) -> &f32 {
        &self.max
    }
    fn inside_range_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.inside_range_channel
    }
    fn value_to_set(&self) -> &i32 {
        &self.value_to_set
    }
    fn int_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::IntChannelDataTrait>>> {
        &self.int_channel
    }
    fn bool_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.bool_channel
    }
}

pub static VELOCITYRANGEITEM_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VelocityRangeItem",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VelocityRangeItem as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Min",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VelocityRangeItem, min),
            },
            FieldInfoData {
                name: "Max",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VelocityRangeItem, max),
            },
            FieldInfoData {
                name: "InsideRangeChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(VelocityRangeItem, inside_range_channel),
            },
            FieldInfoData {
                name: "ValueToSet",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(VelocityRangeItem, value_to_set),
            },
            FieldInfoData {
                name: "IntChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "IntChannelData",
                rust_offset: offset_of!(VelocityRangeItem, int_channel),
            },
            FieldInfoData {
                name: "BoolChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(VelocityRangeItem, bool_channel),
            },
        ],
    }),
    array_type: Some(VELOCITYRANGEITEM_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VelocityRangeItem {
    fn type_info(&self) -> &'static TypeInfo {
        VELOCITYRANGEITEM_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VELOCITYRANGEITEM_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VelocityRangeItem-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("VelocityRangeItem"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VelocityThresholdItem {
    pub invert_test: bool,
    pub threshold: f32,
    pub has_reached_threshold_channel: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
}

pub trait VelocityThresholdItemTrait: TypeObject {
    fn invert_test(&self) -> &bool;
    fn threshold(&self) -> &f32;
    fn has_reached_threshold_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
}

impl VelocityThresholdItemTrait for VelocityThresholdItem {
    fn invert_test(&self) -> &bool {
        &self.invert_test
    }
    fn threshold(&self) -> &f32 {
        &self.threshold
    }
    fn has_reached_threshold_channel(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.has_reached_threshold_channel
    }
}

pub static VELOCITYTHRESHOLDITEM_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VelocityThresholdItem",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VelocityThresholdItem as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "InvertTest",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VelocityThresholdItem, invert_test),
            },
            FieldInfoData {
                name: "Threshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VelocityThresholdItem, threshold),
            },
            FieldInfoData {
                name: "HasReachedThresholdChannel",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(VelocityThresholdItem, has_reached_threshold_channel),
            },
        ],
    }),
    array_type: Some(VELOCITYTHRESHOLDITEM_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VelocityThresholdItem {
    fn type_info(&self) -> &'static TypeInfo {
        VELOCITYTHRESHOLDITEM_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VELOCITYTHRESHOLDITEM_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VelocityThresholdItem-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("VelocityThresholdItem"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateClipOnlyBlendSpaceControllerData {
    pub _glacier_base: CharacterStateBaseControllerData,
    pub voronoi_diagram: VoronoiDiagram,
    pub clip_mode: BlendSpaceClipMode,
    pub channels: Vec<Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>>,
    pub max_diff: Vec<super::core::Vec2>,
}

pub trait CharacterStateClipOnlyBlendSpaceControllerDataTrait: CharacterStateBaseControllerDataTrait {
    fn voronoi_diagram(&self) -> &VoronoiDiagram;
    fn clip_mode(&self) -> &BlendSpaceClipMode;
    fn channels(&self) -> &Vec<Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>>;
    fn max_diff(&self) -> &Vec<super::core::Vec2>;
}

impl CharacterStateClipOnlyBlendSpaceControllerDataTrait for CharacterStateClipOnlyBlendSpaceControllerData {
    fn voronoi_diagram(&self) -> &VoronoiDiagram {
        &self.voronoi_diagram
    }
    fn clip_mode(&self) -> &BlendSpaceClipMode {
        &self.clip_mode
    }
    fn channels(&self) -> &Vec<Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>> {
        &self.channels
    }
    fn max_diff(&self) -> &Vec<super::core::Vec2> {
        &self.max_diff
    }
}

impl CharacterStateBaseControllerDataTrait for CharacterStateClipOnlyBlendSpaceControllerData {
    fn asset_index(&self) -> &i32 {
        self._glacier_base.asset_index()
    }
    fn subjects(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>> {
        self._glacier_base.subjects()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for CharacterStateClipOnlyBlendSpaceControllerData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATECLIPONLYBLENDSPACECONTROLLERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateClipOnlyBlendSpaceControllerData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEBASECONTROLLERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateClipOnlyBlendSpaceControllerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "VoronoiDiagram",
                flags: MemberInfoFlags::new(0),
                field_type: "VoronoiDiagram",
                rust_offset: offset_of!(CharacterStateClipOnlyBlendSpaceControllerData, voronoi_diagram),
            },
            FieldInfoData {
                name: "ClipMode",
                flags: MemberInfoFlags::new(0),
                field_type: "BlendSpaceClipMode",
                rust_offset: offset_of!(CharacterStateClipOnlyBlendSpaceControllerData, clip_mode),
            },
            FieldInfoData {
                name: "Channels",
                flags: MemberInfoFlags::new(144),
                field_type: "FloatChannelData-Array",
                rust_offset: offset_of!(CharacterStateClipOnlyBlendSpaceControllerData, channels),
            },
            FieldInfoData {
                name: "MaxDiff",
                flags: MemberInfoFlags::new(144),
                field_type: "Vec2-Array",
                rust_offset: offset_of!(CharacterStateClipOnlyBlendSpaceControllerData, max_diff),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATECLIPONLYBLENDSPACECONTROLLERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateClipOnlyBlendSpaceControllerData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATECLIPONLYBLENDSPACECONTROLLERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATECLIPONLYBLENDSPACECONTROLLERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateClipOnlyBlendSpaceControllerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateClipOnlyBlendSpaceControllerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateBlendSpaceControllerData {
    pub _glacier_base: CharacterStateBaseControllerData,
    pub voronoi_diagram: VoronoiDiagram,
    pub clip_mode: BlendSpaceClipMode,
    pub channels: Vec<Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>>,
    pub max_diff: Vec<super::core::Vec2>,
}

pub trait CharacterStateBlendSpaceControllerDataTrait: CharacterStateBaseControllerDataTrait {
    fn voronoi_diagram(&self) -> &VoronoiDiagram;
    fn clip_mode(&self) -> &BlendSpaceClipMode;
    fn channels(&self) -> &Vec<Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>>;
    fn max_diff(&self) -> &Vec<super::core::Vec2>;
}

impl CharacterStateBlendSpaceControllerDataTrait for CharacterStateBlendSpaceControllerData {
    fn voronoi_diagram(&self) -> &VoronoiDiagram {
        &self.voronoi_diagram
    }
    fn clip_mode(&self) -> &BlendSpaceClipMode {
        &self.clip_mode
    }
    fn channels(&self) -> &Vec<Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>> {
        &self.channels
    }
    fn max_diff(&self) -> &Vec<super::core::Vec2> {
        &self.max_diff
    }
}

impl CharacterStateBaseControllerDataTrait for CharacterStateBlendSpaceControllerData {
    fn asset_index(&self) -> &i32 {
        self._glacier_base.asset_index()
    }
    fn subjects(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>> {
        self._glacier_base.subjects()
    }
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for CharacterStateBlendSpaceControllerData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATEBLENDSPACECONTROLLERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateBlendSpaceControllerData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSTATEBASECONTROLLERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateBlendSpaceControllerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "VoronoiDiagram",
                flags: MemberInfoFlags::new(0),
                field_type: "VoronoiDiagram",
                rust_offset: offset_of!(CharacterStateBlendSpaceControllerData, voronoi_diagram),
            },
            FieldInfoData {
                name: "ClipMode",
                flags: MemberInfoFlags::new(0),
                field_type: "BlendSpaceClipMode",
                rust_offset: offset_of!(CharacterStateBlendSpaceControllerData, clip_mode),
            },
            FieldInfoData {
                name: "Channels",
                flags: MemberInfoFlags::new(144),
                field_type: "FloatChannelData-Array",
                rust_offset: offset_of!(CharacterStateBlendSpaceControllerData, channels),
            },
            FieldInfoData {
                name: "MaxDiff",
                flags: MemberInfoFlags::new(144),
                field_type: "Vec2-Array",
                rust_offset: offset_of!(CharacterStateBlendSpaceControllerData, max_diff),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEBLENDSPACECONTROLLERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateBlendSpaceControllerData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEBLENDSPACECONTROLLERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEBLENDSPACECONTROLLERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateBlendSpaceControllerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateBlendSpaceControllerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum BlendSpaceClipMode {
    #[default]
    BlendSpaceClipMode_PointToNearestEdge = 0,
    BlendSpaceClipMode_PointPolar = 1,
    BlendSpaceClipMode_FavorXNoExceedY = 2,
    BlendSpaceClipMode_NoClip = 3,
}

pub static BLENDSPACECLIPMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BlendSpaceClipMode",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(BLENDSPACECLIPMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for BlendSpaceClipMode {
    fn type_info(&self) -> &'static TypeInfo {
        BLENDSPACECLIPMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static BLENDSPACECLIPMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BlendSpaceClipMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("BlendSpaceClipMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoronoiDiagram {
    pub pos_min: super::core::Vec2,
    pub pos_max: super::core::Vec2,
    pub pos_centroid: super::core::Vec2,
    pub items: Vec<VoronoiItem>,
    pub triangles: Vec<VoronoiTriangle>,
    pub edges: Vec<VoronoiEdge>,
    pub grid_items: Vec<VoronoiGridItem>,
    pub x_grid_step: f32,
    pub y_grid_step: f32,
    pub rows: u32,
    pub columns: u32,
}

pub trait VoronoiDiagramTrait: TypeObject {
    fn pos_min(&self) -> &super::core::Vec2;
    fn pos_max(&self) -> &super::core::Vec2;
    fn pos_centroid(&self) -> &super::core::Vec2;
    fn items(&self) -> &Vec<VoronoiItem>;
    fn triangles(&self) -> &Vec<VoronoiTriangle>;
    fn edges(&self) -> &Vec<VoronoiEdge>;
    fn grid_items(&self) -> &Vec<VoronoiGridItem>;
    fn x_grid_step(&self) -> &f32;
    fn y_grid_step(&self) -> &f32;
    fn rows(&self) -> &u32;
    fn columns(&self) -> &u32;
}

impl VoronoiDiagramTrait for VoronoiDiagram {
    fn pos_min(&self) -> &super::core::Vec2 {
        &self.pos_min
    }
    fn pos_max(&self) -> &super::core::Vec2 {
        &self.pos_max
    }
    fn pos_centroid(&self) -> &super::core::Vec2 {
        &self.pos_centroid
    }
    fn items(&self) -> &Vec<VoronoiItem> {
        &self.items
    }
    fn triangles(&self) -> &Vec<VoronoiTriangle> {
        &self.triangles
    }
    fn edges(&self) -> &Vec<VoronoiEdge> {
        &self.edges
    }
    fn grid_items(&self) -> &Vec<VoronoiGridItem> {
        &self.grid_items
    }
    fn x_grid_step(&self) -> &f32 {
        &self.x_grid_step
    }
    fn y_grid_step(&self) -> &f32 {
        &self.y_grid_step
    }
    fn rows(&self) -> &u32 {
        &self.rows
    }
    fn columns(&self) -> &u32 {
        &self.columns
    }
}

pub static VORONOIDIAGRAM_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoronoiDiagram",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoronoiDiagram as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PosMin",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(VoronoiDiagram, pos_min),
            },
            FieldInfoData {
                name: "PosMax",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(VoronoiDiagram, pos_max),
            },
            FieldInfoData {
                name: "PosCentroid",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(VoronoiDiagram, pos_centroid),
            },
            FieldInfoData {
                name: "Items",
                flags: MemberInfoFlags::new(144),
                field_type: "VoronoiItem-Array",
                rust_offset: offset_of!(VoronoiDiagram, items),
            },
            FieldInfoData {
                name: "Triangles",
                flags: MemberInfoFlags::new(144),
                field_type: "VoronoiTriangle-Array",
                rust_offset: offset_of!(VoronoiDiagram, triangles),
            },
            FieldInfoData {
                name: "Edges",
                flags: MemberInfoFlags::new(144),
                field_type: "VoronoiEdge-Array",
                rust_offset: offset_of!(VoronoiDiagram, edges),
            },
            FieldInfoData {
                name: "GridItems",
                flags: MemberInfoFlags::new(144),
                field_type: "VoronoiGridItem-Array",
                rust_offset: offset_of!(VoronoiDiagram, grid_items),
            },
            FieldInfoData {
                name: "XGridStep",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VoronoiDiagram, x_grid_step),
            },
            FieldInfoData {
                name: "YGridStep",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VoronoiDiagram, y_grid_step),
            },
            FieldInfoData {
                name: "Rows",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(VoronoiDiagram, rows),
            },
            FieldInfoData {
                name: "Columns",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(VoronoiDiagram, columns),
            },
        ],
    }),
    array_type: Some(VORONOIDIAGRAM_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoronoiDiagram {
    fn type_info(&self) -> &'static TypeInfo {
        VORONOIDIAGRAM_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VORONOIDIAGRAM_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoronoiDiagram-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("VoronoiDiagram"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoronoiEdge {
    pub pos_begin: super::core::Vec2,
    pub pos_end: super::core::Vec2,
    pub vec_edge: super::core::Vec2,
    pub vec_edge_normal: super::core::Vec2,
    pub length: f32,
    pub is_degenerate: bool,
    pub triangle: i32,
}

pub trait VoronoiEdgeTrait: TypeObject {
    fn pos_begin(&self) -> &super::core::Vec2;
    fn pos_end(&self) -> &super::core::Vec2;
    fn vec_edge(&self) -> &super::core::Vec2;
    fn vec_edge_normal(&self) -> &super::core::Vec2;
    fn length(&self) -> &f32;
    fn is_degenerate(&self) -> &bool;
    fn triangle(&self) -> &i32;
}

impl VoronoiEdgeTrait for VoronoiEdge {
    fn pos_begin(&self) -> &super::core::Vec2 {
        &self.pos_begin
    }
    fn pos_end(&self) -> &super::core::Vec2 {
        &self.pos_end
    }
    fn vec_edge(&self) -> &super::core::Vec2 {
        &self.vec_edge
    }
    fn vec_edge_normal(&self) -> &super::core::Vec2 {
        &self.vec_edge_normal
    }
    fn length(&self) -> &f32 {
        &self.length
    }
    fn is_degenerate(&self) -> &bool {
        &self.is_degenerate
    }
    fn triangle(&self) -> &i32 {
        &self.triangle
    }
}

pub static VORONOIEDGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoronoiEdge",
    flags: MemberInfoFlags::new(36937),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoronoiEdge as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PosBegin",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(VoronoiEdge, pos_begin),
            },
            FieldInfoData {
                name: "PosEnd",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(VoronoiEdge, pos_end),
            },
            FieldInfoData {
                name: "VecEdge",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(VoronoiEdge, vec_edge),
            },
            FieldInfoData {
                name: "VecEdgeNormal",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(VoronoiEdge, vec_edge_normal),
            },
            FieldInfoData {
                name: "Length",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VoronoiEdge, length),
            },
            FieldInfoData {
                name: "IsDegenerate",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VoronoiEdge, is_degenerate),
            },
            FieldInfoData {
                name: "Triangle",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(VoronoiEdge, triangle),
            },
        ],
    }),
    array_type: Some(VORONOIEDGE_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for VoronoiEdge {
    fn type_info(&self) -> &'static TypeInfo {
        VORONOIEDGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VORONOIEDGE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoronoiEdge-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("VoronoiEdge"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoronoiTriangle {
    pub pos_verts: Vec<super::core::Vec2>,
    pub vec_edge_normal: Vec<super::core::Vec2>,
    pub v: Vec<i32>,
    pub area: f32,
    pub area_inv: f32,
}

pub trait VoronoiTriangleTrait: TypeObject {
    fn pos_verts(&self) -> &Vec<super::core::Vec2>;
    fn vec_edge_normal(&self) -> &Vec<super::core::Vec2>;
    fn v(&self) -> &Vec<i32>;
    fn area(&self) -> &f32;
    fn area_inv(&self) -> &f32;
}

impl VoronoiTriangleTrait for VoronoiTriangle {
    fn pos_verts(&self) -> &Vec<super::core::Vec2> {
        &self.pos_verts
    }
    fn vec_edge_normal(&self) -> &Vec<super::core::Vec2> {
        &self.vec_edge_normal
    }
    fn v(&self) -> &Vec<i32> {
        &self.v
    }
    fn area(&self) -> &f32 {
        &self.area
    }
    fn area_inv(&self) -> &f32 {
        &self.area_inv
    }
}

pub static VORONOITRIANGLE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoronoiTriangle",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoronoiTriangle as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PosVerts",
                flags: MemberInfoFlags::new(144),
                field_type: "Vec2-Array",
                rust_offset: offset_of!(VoronoiTriangle, pos_verts),
            },
            FieldInfoData {
                name: "VecEdgeNormal",
                flags: MemberInfoFlags::new(144),
                field_type: "Vec2-Array",
                rust_offset: offset_of!(VoronoiTriangle, vec_edge_normal),
            },
            FieldInfoData {
                name: "V",
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(VoronoiTriangle, v),
            },
            FieldInfoData {
                name: "Area",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VoronoiTriangle, area),
            },
            FieldInfoData {
                name: "AreaInv",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VoronoiTriangle, area_inv),
            },
        ],
    }),
    array_type: Some(VORONOITRIANGLE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoronoiTriangle {
    fn type_info(&self) -> &'static TypeInfo {
        VORONOITRIANGLE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VORONOITRIANGLE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoronoiTriangle-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("VoronoiTriangle"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoronoiGridItem {
    pub triangle_indices: Vec<u32>,
}

pub trait VoronoiGridItemTrait: TypeObject {
    fn triangle_indices(&self) -> &Vec<u32>;
}

impl VoronoiGridItemTrait for VoronoiGridItem {
    fn triangle_indices(&self) -> &Vec<u32> {
        &self.triangle_indices
    }
}

pub static VORONOIGRIDITEM_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoronoiGridItem",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoronoiGridItem as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "TriangleIndices",
                flags: MemberInfoFlags::new(144),
                field_type: "Uint32-Array",
                rust_offset: offset_of!(VoronoiGridItem, triangle_indices),
            },
        ],
    }),
    array_type: Some(VORONOIGRIDITEM_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoronoiGridItem {
    fn type_info(&self) -> &'static TypeInfo {
        VORONOIGRIDITEM_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VORONOIGRIDITEM_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoronoiGridItem-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("VoronoiGridItem"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoronoiItem {
    pub asset: Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>,
    pub pos_item: super::core::Vec2,
    pub x_axis: bool,
    pub snap: bool,
}

pub trait VoronoiItemTrait: TypeObject {
    fn asset(&self) -> &Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>;
    fn pos_item(&self) -> &super::core::Vec2;
    fn x_axis(&self) -> &bool;
    fn snap(&self) -> &bool;
}

impl VoronoiItemTrait for VoronoiItem {
    fn asset(&self) -> &Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>> {
        &self.asset
    }
    fn pos_item(&self) -> &super::core::Vec2 {
        &self.pos_item
    }
    fn x_axis(&self) -> &bool {
        &self.x_axis
    }
    fn snap(&self) -> &bool {
        &self.snap
    }
}

pub static VORONOIITEM_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoronoiItem",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoronoiItem as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Asset",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterStateBaseControllerData",
                rust_offset: offset_of!(VoronoiItem, asset),
            },
            FieldInfoData {
                name: "PosItem",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(VoronoiItem, pos_item),
            },
            FieldInfoData {
                name: "XAxis",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VoronoiItem, x_axis),
            },
            FieldInfoData {
                name: "Snap",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VoronoiItem, snap),
            },
        ],
    }),
    array_type: Some(VORONOIITEM_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoronoiItem {
    fn type_info(&self) -> &'static TypeInfo {
        VORONOIITEM_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VORONOIITEM_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoronoiItem-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("VoronoiItem"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum VoronoiGridMode {
    #[default]
    VoronoiGridMode_NoGrid = 0,
    VoronoiGridMode_UseGrid = 1,
}

pub static VORONOIGRIDMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoronoiGridMode",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(VORONOIGRIDMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for VoronoiGridMode {
    fn type_info(&self) -> &'static TypeInfo {
        VORONOIGRIDMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VORONOIGRIDMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoronoiGridMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("VoronoiGridMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateBaseControllerData {
    pub _glacier_base: super::core::DataContainer,
    pub asset_index: i32,
    pub subjects: Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>>,
    pub name: String,
}

pub trait CharacterStateBaseControllerDataTrait: super::core::DataContainerTrait {
    fn asset_index(&self) -> &i32;
    fn subjects(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>>;
    fn name(&self) -> &String;
}

impl CharacterStateBaseControllerDataTrait for CharacterStateBaseControllerData {
    fn asset_index(&self) -> &i32 {
        &self.asset_index
    }
    fn subjects(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterStateBaseControllerDataTrait>>>> {
        &self.subjects
    }
    fn name(&self) -> &String {
        &self.name
    }
}

impl super::core::DataContainerTrait for CharacterStateBaseControllerData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATEBASECONTROLLERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateBaseControllerData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateBaseControllerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AssetIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CharacterStateBaseControllerData, asset_index),
            },
            FieldInfoData {
                name: "Subjects",
                flags: MemberInfoFlags::new(144),
                field_type: "CharacterStateBaseControllerData-Array",
                rust_offset: offset_of!(CharacterStateBaseControllerData, subjects),
            },
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(CharacterStateBaseControllerData, name),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEBASECONTROLLERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateBaseControllerData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEBASECONTROLLERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEBASECONTROLLERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateBaseControllerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateBaseControllerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WaterHitComponentData {
    pub _glacier_base: super::entity::GameComponentData,
}

pub trait WaterHitComponentDataTrait: super::entity::GameComponentDataTrait {
}

impl WaterHitComponentDataTrait for WaterHitComponentData {
}

impl super::entity::GameComponentDataTrait for WaterHitComponentData {
}

impl super::entity::ComponentDataTrait for WaterHitComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
}

impl super::entity::GameObjectDataTrait for WaterHitComponentData {
}

impl super::core::DataBusPeerTrait for WaterHitComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for WaterHitComponentData {
}

impl super::core::DataContainerTrait for WaterHitComponentData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static WATERHITCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WaterHitComponentData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WaterHitComponentData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(WATERHITCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for WaterHitComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        WATERHITCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static WATERHITCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WaterHitComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("WaterHitComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoldierIndoorsEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub indooriness_threshold: f32,
    pub material_ratio_threshold: f32,
    pub indooriness: f32,
    pub material_ratio: f32,
}

pub trait SoldierIndoorsEntityDataTrait: super::entity::EntityDataTrait {
    fn indooriness_threshold(&self) -> &f32;
    fn material_ratio_threshold(&self) -> &f32;
    fn indooriness(&self) -> &f32;
    fn material_ratio(&self) -> &f32;
}

impl SoldierIndoorsEntityDataTrait for SoldierIndoorsEntityData {
    fn indooriness_threshold(&self) -> &f32 {
        &self.indooriness_threshold
    }
    fn material_ratio_threshold(&self) -> &f32 {
        &self.material_ratio_threshold
    }
    fn indooriness(&self) -> &f32 {
        &self.indooriness
    }
    fn material_ratio(&self) -> &f32 {
        &self.material_ratio
    }
}

impl super::entity::EntityDataTrait for SoldierIndoorsEntityData {
}

impl super::entity::GameObjectDataTrait for SoldierIndoorsEntityData {
}

impl super::core::DataBusPeerTrait for SoldierIndoorsEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for SoldierIndoorsEntityData {
}

impl super::core::DataContainerTrait for SoldierIndoorsEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SOLDIERINDOORSENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierIndoorsEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierIndoorsEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "IndoorinessThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierIndoorsEntityData, indooriness_threshold),
            },
            FieldInfoData {
                name: "MaterialRatioThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierIndoorsEntityData, material_ratio_threshold),
            },
            FieldInfoData {
                name: "Indooriness",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierIndoorsEntityData, indooriness),
            },
            FieldInfoData {
                name: "MaterialRatio",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoldierIndoorsEntityData, material_ratio),
            },
        ],
    }),
    array_type: Some(SOLDIERINDOORSENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoldierIndoorsEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERINDOORSENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SOLDIERINDOORSENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierIndoorsEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("SoldierIndoorsEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LocalPlayerNodeData {
    pub _glacier_base: super::audio::AudioGraphNodeData,
    pub player_id: super::audio::AudioGraphNodePort,
    pub team_id: super::audio::AudioGraphNodePort,
    pub is_first_person: super::audio::AudioGraphNodePort,
    pub is_alive: super::audio::AudioGraphNodePort,
    pub is_man_down: super::audio::AudioGraphNodePort,
    pub is_single_player: super::audio::AudioGraphNodePort,
    pub is_a_i_player: super::audio::AudioGraphNodePort,
    pub is_in_vehicle: super::audio::AudioGraphNodePort,
    pub is_vehicle_interior_cam: super::audio::AudioGraphNodePort,
    pub is_zooming: super::audio::AudioGraphNodePort,
    pub health: super::audio::AudioGraphNodePort,
    pub vehicle_health: super::audio::AudioGraphNodePort,
    pub sound_material_id: super::audio::AudioGraphNodePort,
    pub distance_from_sound: super::audio::AudioGraphNodePort,
    pub height_difference: super::audio::AudioGraphNodePort,
    pub character_pose: super::audio::AudioGraphNodePort,
    pub normalized_health: bool,
}

pub trait LocalPlayerNodeDataTrait: super::audio::AudioGraphNodeDataTrait {
    fn player_id(&self) -> &super::audio::AudioGraphNodePort;
    fn team_id(&self) -> &super::audio::AudioGraphNodePort;
    fn is_first_person(&self) -> &super::audio::AudioGraphNodePort;
    fn is_alive(&self) -> &super::audio::AudioGraphNodePort;
    fn is_man_down(&self) -> &super::audio::AudioGraphNodePort;
    fn is_single_player(&self) -> &super::audio::AudioGraphNodePort;
    fn is_a_i_player(&self) -> &super::audio::AudioGraphNodePort;
    fn is_in_vehicle(&self) -> &super::audio::AudioGraphNodePort;
    fn is_vehicle_interior_cam(&self) -> &super::audio::AudioGraphNodePort;
    fn is_zooming(&self) -> &super::audio::AudioGraphNodePort;
    fn health(&self) -> &super::audio::AudioGraphNodePort;
    fn vehicle_health(&self) -> &super::audio::AudioGraphNodePort;
    fn sound_material_id(&self) -> &super::audio::AudioGraphNodePort;
    fn distance_from_sound(&self) -> &super::audio::AudioGraphNodePort;
    fn height_difference(&self) -> &super::audio::AudioGraphNodePort;
    fn character_pose(&self) -> &super::audio::AudioGraphNodePort;
    fn normalized_health(&self) -> &bool;
}

impl LocalPlayerNodeDataTrait for LocalPlayerNodeData {
    fn player_id(&self) -> &super::audio::AudioGraphNodePort {
        &self.player_id
    }
    fn team_id(&self) -> &super::audio::AudioGraphNodePort {
        &self.team_id
    }
    fn is_first_person(&self) -> &super::audio::AudioGraphNodePort {
        &self.is_first_person
    }
    fn is_alive(&self) -> &super::audio::AudioGraphNodePort {
        &self.is_alive
    }
    fn is_man_down(&self) -> &super::audio::AudioGraphNodePort {
        &self.is_man_down
    }
    fn is_single_player(&self) -> &super::audio::AudioGraphNodePort {
        &self.is_single_player
    }
    fn is_a_i_player(&self) -> &super::audio::AudioGraphNodePort {
        &self.is_a_i_player
    }
    fn is_in_vehicle(&self) -> &super::audio::AudioGraphNodePort {
        &self.is_in_vehicle
    }
    fn is_vehicle_interior_cam(&self) -> &super::audio::AudioGraphNodePort {
        &self.is_vehicle_interior_cam
    }
    fn is_zooming(&self) -> &super::audio::AudioGraphNodePort {
        &self.is_zooming
    }
    fn health(&self) -> &super::audio::AudioGraphNodePort {
        &self.health
    }
    fn vehicle_health(&self) -> &super::audio::AudioGraphNodePort {
        &self.vehicle_health
    }
    fn sound_material_id(&self) -> &super::audio::AudioGraphNodePort {
        &self.sound_material_id
    }
    fn distance_from_sound(&self) -> &super::audio::AudioGraphNodePort {
        &self.distance_from_sound
    }
    fn height_difference(&self) -> &super::audio::AudioGraphNodePort {
        &self.height_difference
    }
    fn character_pose(&self) -> &super::audio::AudioGraphNodePort {
        &self.character_pose
    }
    fn normalized_health(&self) -> &bool {
        &self.normalized_health
    }
}

impl super::audio::AudioGraphNodeDataTrait for LocalPlayerNodeData {
}

impl super::core::DataContainerTrait for LocalPlayerNodeData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static LOCALPLAYERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalPlayerNodeData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::audio::AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LocalPlayerNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PlayerId",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LocalPlayerNodeData, player_id),
            },
            FieldInfoData {
                name: "TeamId",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LocalPlayerNodeData, team_id),
            },
            FieldInfoData {
                name: "IsFirstPerson",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LocalPlayerNodeData, is_first_person),
            },
            FieldInfoData {
                name: "IsAlive",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LocalPlayerNodeData, is_alive),
            },
            FieldInfoData {
                name: "IsManDown",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LocalPlayerNodeData, is_man_down),
            },
            FieldInfoData {
                name: "IsSinglePlayer",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LocalPlayerNodeData, is_single_player),
            },
            FieldInfoData {
                name: "IsAIPlayer",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LocalPlayerNodeData, is_a_i_player),
            },
            FieldInfoData {
                name: "IsInVehicle",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LocalPlayerNodeData, is_in_vehicle),
            },
            FieldInfoData {
                name: "IsVehicleInteriorCam",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LocalPlayerNodeData, is_vehicle_interior_cam),
            },
            FieldInfoData {
                name: "IsZooming",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LocalPlayerNodeData, is_zooming),
            },
            FieldInfoData {
                name: "Health",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LocalPlayerNodeData, health),
            },
            FieldInfoData {
                name: "VehicleHealth",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LocalPlayerNodeData, vehicle_health),
            },
            FieldInfoData {
                name: "SoundMaterialId",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LocalPlayerNodeData, sound_material_id),
            },
            FieldInfoData {
                name: "DistanceFromSound",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LocalPlayerNodeData, distance_from_sound),
            },
            FieldInfoData {
                name: "HeightDifference",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LocalPlayerNodeData, height_difference),
            },
            FieldInfoData {
                name: "CharacterPose",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LocalPlayerNodeData, character_pose),
            },
            FieldInfoData {
                name: "NormalizedHealth",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LocalPlayerNodeData, normalized_health),
            },
        ],
    }),
    array_type: Some(LOCALPLAYERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LocalPlayerNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        LOCALPLAYERNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static LOCALPLAYERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalPlayerNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("LocalPlayerNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DiceShooterSurfacePropertySoundData {
    pub _glacier_base: super::entity::PhysicsMaterialRelationPropertyData,
    pub wheel_surface_waves: WheelSurfaceWaveData,
}

pub trait DiceShooterSurfacePropertySoundDataTrait: super::entity::PhysicsMaterialRelationPropertyDataTrait {
    fn wheel_surface_waves(&self) -> &WheelSurfaceWaveData;
}

impl DiceShooterSurfacePropertySoundDataTrait for DiceShooterSurfacePropertySoundData {
    fn wheel_surface_waves(&self) -> &WheelSurfaceWaveData {
        &self.wheel_surface_waves
    }
}

impl super::entity::PhysicsMaterialRelationPropertyDataTrait for DiceShooterSurfacePropertySoundData {
}

impl super::entity::MaterialRelationPropertyDataTrait for DiceShooterSurfacePropertySoundData {
}

impl super::core::DataContainerTrait for DiceShooterSurfacePropertySoundData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static DICESHOOTERSURFACEPROPERTYSOUNDDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DiceShooterSurfacePropertySoundData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::PHYSICSMATERIALRELATIONPROPERTYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DiceShooterSurfacePropertySoundData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "WheelSurfaceWaves",
                flags: MemberInfoFlags::new(0),
                field_type: "WheelSurfaceWaveData",
                rust_offset: offset_of!(DiceShooterSurfacePropertySoundData, wheel_surface_waves),
            },
        ],
    }),
    array_type: Some(DICESHOOTERSURFACEPROPERTYSOUNDDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DiceShooterSurfacePropertySoundData {
    fn type_info(&self) -> &'static TypeInfo {
        DICESHOOTERSURFACEPROPERTYSOUNDDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static DICESHOOTERSURFACEPROPERTYSOUNDDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DiceShooterSurfacePropertySoundData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("DiceShooterSurfacePropertySoundData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WheelSurfaceWaveData {
    pub enter_one_shot: Option<Arc<Mutex<dyn super::audio::SoundWaveAssetBaseTrait>>>,
    pub slow_loop: Option<Arc<Mutex<dyn super::audio::SoundWaveAssetBaseTrait>>>,
    pub medium_loop: Option<Arc<Mutex<dyn super::audio::SoundWaveAssetBaseTrait>>>,
    pub fast_loop: Option<Arc<Mutex<dyn super::audio::SoundWaveAssetBaseTrait>>>,
    pub wheel_spin_loop: Option<Arc<Mutex<dyn super::audio::SoundWaveAssetBaseTrait>>>,
    pub drift_loop: Option<Arc<Mutex<dyn super::audio::SoundWaveAssetBaseTrait>>>,
    pub surface_amplitude: f32,
}

pub trait WheelSurfaceWaveDataTrait: TypeObject {
    fn enter_one_shot(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundWaveAssetBaseTrait>>>;
    fn slow_loop(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundWaveAssetBaseTrait>>>;
    fn medium_loop(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundWaveAssetBaseTrait>>>;
    fn fast_loop(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundWaveAssetBaseTrait>>>;
    fn wheel_spin_loop(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundWaveAssetBaseTrait>>>;
    fn drift_loop(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundWaveAssetBaseTrait>>>;
    fn surface_amplitude(&self) -> &f32;
}

impl WheelSurfaceWaveDataTrait for WheelSurfaceWaveData {
    fn enter_one_shot(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundWaveAssetBaseTrait>>> {
        &self.enter_one_shot
    }
    fn slow_loop(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundWaveAssetBaseTrait>>> {
        &self.slow_loop
    }
    fn medium_loop(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundWaveAssetBaseTrait>>> {
        &self.medium_loop
    }
    fn fast_loop(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundWaveAssetBaseTrait>>> {
        &self.fast_loop
    }
    fn wheel_spin_loop(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundWaveAssetBaseTrait>>> {
        &self.wheel_spin_loop
    }
    fn drift_loop(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundWaveAssetBaseTrait>>> {
        &self.drift_loop
    }
    fn surface_amplitude(&self) -> &f32 {
        &self.surface_amplitude
    }
}

pub static WHEELSURFACEWAVEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WheelSurfaceWaveData",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WheelSurfaceWaveData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "EnterOneShot",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundWaveAssetBase",
                rust_offset: offset_of!(WheelSurfaceWaveData, enter_one_shot),
            },
            FieldInfoData {
                name: "SlowLoop",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundWaveAssetBase",
                rust_offset: offset_of!(WheelSurfaceWaveData, slow_loop),
            },
            FieldInfoData {
                name: "MediumLoop",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundWaveAssetBase",
                rust_offset: offset_of!(WheelSurfaceWaveData, medium_loop),
            },
            FieldInfoData {
                name: "FastLoop",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundWaveAssetBase",
                rust_offset: offset_of!(WheelSurfaceWaveData, fast_loop),
            },
            FieldInfoData {
                name: "WheelSpinLoop",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundWaveAssetBase",
                rust_offset: offset_of!(WheelSurfaceWaveData, wheel_spin_loop),
            },
            FieldInfoData {
                name: "DriftLoop",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundWaveAssetBase",
                rust_offset: offset_of!(WheelSurfaceWaveData, drift_loop),
            },
            FieldInfoData {
                name: "SurfaceAmplitude",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WheelSurfaceWaveData, surface_amplitude),
            },
        ],
    }),
    array_type: Some(WHEELSURFACEWAVEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WheelSurfaceWaveData {
    fn type_info(&self) -> &'static TypeInfo {
        WHEELSURFACEWAVEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static WHEELSURFACEWAVEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WheelSurfaceWaveData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("WheelSurfaceWaveData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DiceShooterMaterialPropertySoundData {
    pub _glacier_base: super::entity::PhysicsMaterialRelationPropertyData,
    pub reflection_coefficient: f32,
}

pub trait DiceShooterMaterialPropertySoundDataTrait: super::entity::PhysicsMaterialRelationPropertyDataTrait {
    fn reflection_coefficient(&self) -> &f32;
}

impl DiceShooterMaterialPropertySoundDataTrait for DiceShooterMaterialPropertySoundData {
    fn reflection_coefficient(&self) -> &f32 {
        &self.reflection_coefficient
    }
}

impl super::entity::PhysicsMaterialRelationPropertyDataTrait for DiceShooterMaterialPropertySoundData {
}

impl super::entity::MaterialRelationPropertyDataTrait for DiceShooterMaterialPropertySoundData {
}

impl super::core::DataContainerTrait for DiceShooterMaterialPropertySoundData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static DICESHOOTERMATERIALPROPERTYSOUNDDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DiceShooterMaterialPropertySoundData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::PHYSICSMATERIALRELATIONPROPERTYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DiceShooterMaterialPropertySoundData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ReflectionCoefficient",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DiceShooterMaterialPropertySoundData, reflection_coefficient),
            },
        ],
    }),
    array_type: Some(DICESHOOTERMATERIALPROPERTYSOUNDDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DiceShooterMaterialPropertySoundData {
    fn type_info(&self) -> &'static TypeInfo {
        DICESHOOTERMATERIALPROPERTYSOUNDDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static DICESHOOTERMATERIALPROPERTYSOUNDDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DiceShooterMaterialPropertySoundData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("DiceShooterMaterialPropertySoundData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ClientVoiceOverQueryEventEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub vo_event: Option<Arc<Mutex<dyn super::audio::VoiceOverEventTrait>>>,
    pub trigger_delay: f32,
    pub finished_delay: f32,
    pub run_once: bool,
    pub cancel_on_deinit: bool,
    pub query_entity_input: QueryEntityResult,
}

pub trait ClientVoiceOverQueryEventEntityDataTrait: super::entity::EntityDataTrait {
    fn vo_event(&self) -> &Option<Arc<Mutex<dyn super::audio::VoiceOverEventTrait>>>;
    fn trigger_delay(&self) -> &f32;
    fn finished_delay(&self) -> &f32;
    fn run_once(&self) -> &bool;
    fn cancel_on_deinit(&self) -> &bool;
    fn query_entity_input(&self) -> &QueryEntityResult;
}

impl ClientVoiceOverQueryEventEntityDataTrait for ClientVoiceOverQueryEventEntityData {
    fn vo_event(&self) -> &Option<Arc<Mutex<dyn super::audio::VoiceOverEventTrait>>> {
        &self.vo_event
    }
    fn trigger_delay(&self) -> &f32 {
        &self.trigger_delay
    }
    fn finished_delay(&self) -> &f32 {
        &self.finished_delay
    }
    fn run_once(&self) -> &bool {
        &self.run_once
    }
    fn cancel_on_deinit(&self) -> &bool {
        &self.cancel_on_deinit
    }
    fn query_entity_input(&self) -> &QueryEntityResult {
        &self.query_entity_input
    }
}

impl super::entity::EntityDataTrait for ClientVoiceOverQueryEventEntityData {
}

impl super::entity::GameObjectDataTrait for ClientVoiceOverQueryEventEntityData {
}

impl super::core::DataBusPeerTrait for ClientVoiceOverQueryEventEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for ClientVoiceOverQueryEventEntityData {
}

impl super::core::DataContainerTrait for ClientVoiceOverQueryEventEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CLIENTVOICEOVERQUERYEVENTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClientVoiceOverQueryEventEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ClientVoiceOverQueryEventEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "VoEvent",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverEvent",
                rust_offset: offset_of!(ClientVoiceOverQueryEventEntityData, vo_event),
            },
            FieldInfoData {
                name: "TriggerDelay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ClientVoiceOverQueryEventEntityData, trigger_delay),
            },
            FieldInfoData {
                name: "FinishedDelay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ClientVoiceOverQueryEventEntityData, finished_delay),
            },
            FieldInfoData {
                name: "RunOnce",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ClientVoiceOverQueryEventEntityData, run_once),
            },
            FieldInfoData {
                name: "CancelOnDeinit",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ClientVoiceOverQueryEventEntityData, cancel_on_deinit),
            },
            FieldInfoData {
                name: "QueryEntityInput",
                flags: MemberInfoFlags::new(0),
                field_type: "QueryEntityResult",
                rust_offset: offset_of!(ClientVoiceOverQueryEventEntityData, query_entity_input),
            },
        ],
    }),
    array_type: Some(CLIENTVOICEOVERQUERYEVENTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ClientVoiceOverQueryEventEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CLIENTVOICEOVERQUERYEVENTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CLIENTVOICEOVERQUERYEVENTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClientVoiceOverQueryEventEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("ClientVoiceOverQueryEventEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ControlInputEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub take_control_entry_index: i32,
    pub rotation_yaw: f32,
    pub rotation_pitch: f32,
    pub rotation_roll: f32,
    pub throttle: f32,
    pub fire: bool,
    pub control_yaw: bool,
    pub control_pitch: bool,
    pub control_roll: bool,
    pub control_throttle: bool,
    pub control_fire: bool,
}

pub trait ControlInputEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn take_control_entry_index(&self) -> &i32;
    fn rotation_yaw(&self) -> &f32;
    fn rotation_pitch(&self) -> &f32;
    fn rotation_roll(&self) -> &f32;
    fn throttle(&self) -> &f32;
    fn fire(&self) -> &bool;
    fn control_yaw(&self) -> &bool;
    fn control_pitch(&self) -> &bool;
    fn control_roll(&self) -> &bool;
    fn control_throttle(&self) -> &bool;
    fn control_fire(&self) -> &bool;
}

impl ControlInputEntityDataTrait for ControlInputEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn take_control_entry_index(&self) -> &i32 {
        &self.take_control_entry_index
    }
    fn rotation_yaw(&self) -> &f32 {
        &self.rotation_yaw
    }
    fn rotation_pitch(&self) -> &f32 {
        &self.rotation_pitch
    }
    fn rotation_roll(&self) -> &f32 {
        &self.rotation_roll
    }
    fn throttle(&self) -> &f32 {
        &self.throttle
    }
    fn fire(&self) -> &bool {
        &self.fire
    }
    fn control_yaw(&self) -> &bool {
        &self.control_yaw
    }
    fn control_pitch(&self) -> &bool {
        &self.control_pitch
    }
    fn control_roll(&self) -> &bool {
        &self.control_roll
    }
    fn control_throttle(&self) -> &bool {
        &self.control_throttle
    }
    fn control_fire(&self) -> &bool {
        &self.control_fire
    }
}

impl super::entity::EntityDataTrait for ControlInputEntityData {
}

impl super::entity::GameObjectDataTrait for ControlInputEntityData {
}

impl super::core::DataBusPeerTrait for ControlInputEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for ControlInputEntityData {
}

impl super::core::DataContainerTrait for ControlInputEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CONTROLINPUTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ControlInputEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ControlInputEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(ControlInputEntityData, realm),
            },
            FieldInfoData {
                name: "TakeControlEntryIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ControlInputEntityData, take_control_entry_index),
            },
            FieldInfoData {
                name: "RotationYaw",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ControlInputEntityData, rotation_yaw),
            },
            FieldInfoData {
                name: "RotationPitch",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ControlInputEntityData, rotation_pitch),
            },
            FieldInfoData {
                name: "RotationRoll",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ControlInputEntityData, rotation_roll),
            },
            FieldInfoData {
                name: "Throttle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ControlInputEntityData, throttle),
            },
            FieldInfoData {
                name: "Fire",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ControlInputEntityData, fire),
            },
            FieldInfoData {
                name: "ControlYaw",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ControlInputEntityData, control_yaw),
            },
            FieldInfoData {
                name: "ControlPitch",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ControlInputEntityData, control_pitch),
            },
            FieldInfoData {
                name: "ControlRoll",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ControlInputEntityData, control_roll),
            },
            FieldInfoData {
                name: "ControlThrottle",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ControlInputEntityData, control_throttle),
            },
            FieldInfoData {
                name: "ControlFire",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ControlInputEntityData, control_fire),
            },
        ],
    }),
    array_type: Some(CONTROLINPUTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ControlInputEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CONTROLINPUTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CONTROLINPUTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ControlInputEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("ControlInputEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FriendZoneEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub enabled: bool,
    pub friendly_weight: i32,
    pub enemy_weight: i32,
    pub corps_weight: i32,
    pub corps_timeout: i32,
    pub count_corpses_for_all_teams: bool,
    pub initial_zone_randomized: bool,
    pub recent_spawn_duration: f32,
    pub recent_spawn_weight: i32,
}

pub trait FriendZoneEntityDataTrait: super::entity::EntityDataTrait {
    fn enabled(&self) -> &bool;
    fn friendly_weight(&self) -> &i32;
    fn enemy_weight(&self) -> &i32;
    fn corps_weight(&self) -> &i32;
    fn corps_timeout(&self) -> &i32;
    fn count_corpses_for_all_teams(&self) -> &bool;
    fn initial_zone_randomized(&self) -> &bool;
    fn recent_spawn_duration(&self) -> &f32;
    fn recent_spawn_weight(&self) -> &i32;
}

impl FriendZoneEntityDataTrait for FriendZoneEntityData {
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn friendly_weight(&self) -> &i32 {
        &self.friendly_weight
    }
    fn enemy_weight(&self) -> &i32 {
        &self.enemy_weight
    }
    fn corps_weight(&self) -> &i32 {
        &self.corps_weight
    }
    fn corps_timeout(&self) -> &i32 {
        &self.corps_timeout
    }
    fn count_corpses_for_all_teams(&self) -> &bool {
        &self.count_corpses_for_all_teams
    }
    fn initial_zone_randomized(&self) -> &bool {
        &self.initial_zone_randomized
    }
    fn recent_spawn_duration(&self) -> &f32 {
        &self.recent_spawn_duration
    }
    fn recent_spawn_weight(&self) -> &i32 {
        &self.recent_spawn_weight
    }
}

impl super::entity::EntityDataTrait for FriendZoneEntityData {
}

impl super::entity::GameObjectDataTrait for FriendZoneEntityData {
}

impl super::core::DataBusPeerTrait for FriendZoneEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for FriendZoneEntityData {
}

impl super::core::DataContainerTrait for FriendZoneEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static FRIENDZONEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FriendZoneEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FriendZoneEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FriendZoneEntityData, enabled),
            },
            FieldInfoData {
                name: "FriendlyWeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(FriendZoneEntityData, friendly_weight),
            },
            FieldInfoData {
                name: "EnemyWeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(FriendZoneEntityData, enemy_weight),
            },
            FieldInfoData {
                name: "CorpsWeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(FriendZoneEntityData, corps_weight),
            },
            FieldInfoData {
                name: "CorpsTimeout",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(FriendZoneEntityData, corps_timeout),
            },
            FieldInfoData {
                name: "CountCorpsesForAllTeams",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FriendZoneEntityData, count_corpses_for_all_teams),
            },
            FieldInfoData {
                name: "InitialZoneRandomized",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FriendZoneEntityData, initial_zone_randomized),
            },
            FieldInfoData {
                name: "RecentSpawnDuration",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FriendZoneEntityData, recent_spawn_duration),
            },
            FieldInfoData {
                name: "RecentSpawnWeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(FriendZoneEntityData, recent_spawn_weight),
            },
        ],
    }),
    array_type: Some(FRIENDZONEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FriendZoneEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        FRIENDZONEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static FRIENDZONEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FriendZoneEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("FriendZoneEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RoundOverEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub team: super::gameplay_sim::TeamId,
}

pub trait RoundOverEntityDataTrait: super::entity::EntityDataTrait {
    fn team(&self) -> &super::gameplay_sim::TeamId;
}

impl RoundOverEntityDataTrait for RoundOverEntityData {
    fn team(&self) -> &super::gameplay_sim::TeamId {
        &self.team
    }
}

impl super::entity::EntityDataTrait for RoundOverEntityData {
}

impl super::entity::GameObjectDataTrait for RoundOverEntityData {
}

impl super::core::DataBusPeerTrait for RoundOverEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for RoundOverEntityData {
}

impl super::core::DataContainerTrait for RoundOverEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static ROUNDOVERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RoundOverEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RoundOverEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Team",
                flags: MemberInfoFlags::new(0),
                field_type: "TeamId",
                rust_offset: offset_of!(RoundOverEntityData, team),
            },
        ],
    }),
    array_type: Some(ROUNDOVERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RoundOverEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        ROUNDOVERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ROUNDOVERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RoundOverEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("RoundOverEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ClientRoundOverMessage {
}

pub trait ClientRoundOverMessageTrait: TypeObject {
}

impl ClientRoundOverMessageTrait for ClientRoundOverMessage {
}

pub static CLIENTROUNDOVERMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClientRoundOverMessage",
    flags: MemberInfoFlags::new(36937),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ClientRoundOverMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for ClientRoundOverMessage {
    fn type_info(&self) -> &'static TypeInfo {
        CLIENTROUNDOVERMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}

#[derive(Clone, Debug, Default)]
pub struct ClientRoundStartedMessage {
}

pub trait ClientRoundStartedMessageTrait: TypeObject {
}

impl ClientRoundStartedMessageTrait for ClientRoundStartedMessage {
}

pub static CLIENTROUNDSTARTEDMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClientRoundStartedMessage",
    flags: MemberInfoFlags::new(36937),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ClientRoundStartedMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for ClientRoundStartedMessage {
    fn type_info(&self) -> &'static TypeInfo {
        CLIENTROUNDSTARTEDMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}

#[derive(Clone, Debug, Default)]
pub struct KillCounterEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub team_id: super::gameplay_sim::TeamId,
    pub ignore_a_i: bool,
    pub ignore_a_i_victims: bool,
    pub max_kill_count: i32,
    pub max_kill_count_modifier: f32,
    pub enemy_weight: f32,
    pub neutral_team_weight: KillWeight,
    pub team_kill_weight: KillWeight,
    pub suicide_weight: f32,
    pub count_suicide: bool,
    pub count_o_o_b_kills: bool,
    pub count_special_unlocks: Vec<Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>>>,
    pub enabled: bool,
}

pub trait KillCounterEntityDataTrait: super::entity::EntityDataTrait {
    fn team_id(&self) -> &super::gameplay_sim::TeamId;
    fn ignore_a_i(&self) -> &bool;
    fn ignore_a_i_victims(&self) -> &bool;
    fn max_kill_count(&self) -> &i32;
    fn max_kill_count_modifier(&self) -> &f32;
    fn enemy_weight(&self) -> &f32;
    fn neutral_team_weight(&self) -> &KillWeight;
    fn team_kill_weight(&self) -> &KillWeight;
    fn suicide_weight(&self) -> &f32;
    fn count_suicide(&self) -> &bool;
    fn count_o_o_b_kills(&self) -> &bool;
    fn count_special_unlocks(&self) -> &Vec<Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>>>;
    fn enabled(&self) -> &bool;
}

impl KillCounterEntityDataTrait for KillCounterEntityData {
    fn team_id(&self) -> &super::gameplay_sim::TeamId {
        &self.team_id
    }
    fn ignore_a_i(&self) -> &bool {
        &self.ignore_a_i
    }
    fn ignore_a_i_victims(&self) -> &bool {
        &self.ignore_a_i_victims
    }
    fn max_kill_count(&self) -> &i32 {
        &self.max_kill_count
    }
    fn max_kill_count_modifier(&self) -> &f32 {
        &self.max_kill_count_modifier
    }
    fn enemy_weight(&self) -> &f32 {
        &self.enemy_weight
    }
    fn neutral_team_weight(&self) -> &KillWeight {
        &self.neutral_team_weight
    }
    fn team_kill_weight(&self) -> &KillWeight {
        &self.team_kill_weight
    }
    fn suicide_weight(&self) -> &f32 {
        &self.suicide_weight
    }
    fn count_suicide(&self) -> &bool {
        &self.count_suicide
    }
    fn count_o_o_b_kills(&self) -> &bool {
        &self.count_o_o_b_kills
    }
    fn count_special_unlocks(&self) -> &Vec<Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>>> {
        &self.count_special_unlocks
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
}

impl super::entity::EntityDataTrait for KillCounterEntityData {
}

impl super::entity::GameObjectDataTrait for KillCounterEntityData {
}

impl super::core::DataBusPeerTrait for KillCounterEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for KillCounterEntityData {
}

impl super::core::DataContainerTrait for KillCounterEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static KILLCOUNTERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "KillCounterEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<KillCounterEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "TeamId",
                flags: MemberInfoFlags::new(0),
                field_type: "TeamId",
                rust_offset: offset_of!(KillCounterEntityData, team_id),
            },
            FieldInfoData {
                name: "IgnoreAI",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(KillCounterEntityData, ignore_a_i),
            },
            FieldInfoData {
                name: "IgnoreAIVictims",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(KillCounterEntityData, ignore_a_i_victims),
            },
            FieldInfoData {
                name: "MaxKillCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(KillCounterEntityData, max_kill_count),
            },
            FieldInfoData {
                name: "MaxKillCountModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(KillCounterEntityData, max_kill_count_modifier),
            },
            FieldInfoData {
                name: "EnemyWeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(KillCounterEntityData, enemy_weight),
            },
            FieldInfoData {
                name: "NeutralTeamWeight",
                flags: MemberInfoFlags::new(0),
                field_type: "KillWeight",
                rust_offset: offset_of!(KillCounterEntityData, neutral_team_weight),
            },
            FieldInfoData {
                name: "TeamKillWeight",
                flags: MemberInfoFlags::new(0),
                field_type: "KillWeight",
                rust_offset: offset_of!(KillCounterEntityData, team_kill_weight),
            },
            FieldInfoData {
                name: "SuicideWeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(KillCounterEntityData, suicide_weight),
            },
            FieldInfoData {
                name: "CountSuicide",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(KillCounterEntityData, count_suicide),
            },
            FieldInfoData {
                name: "CountOOBKills",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(KillCounterEntityData, count_o_o_b_kills),
            },
            FieldInfoData {
                name: "CountSpecialUnlocks",
                flags: MemberInfoFlags::new(144),
                field_type: "UnlockAssetBase-Array",
                rust_offset: offset_of!(KillCounterEntityData, count_special_unlocks),
            },
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(KillCounterEntityData, enabled),
            },
        ],
    }),
    array_type: Some(KILLCOUNTERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for KillCounterEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        KILLCOUNTERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static KILLCOUNTERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "KillCounterEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("KillCounterEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct KillWeight {
    pub low_intense_weight: f32,
    pub high_intense_weight: f32,
    pub cool_down_time: f32,
}

pub trait KillWeightTrait: TypeObject {
    fn low_intense_weight(&self) -> &f32;
    fn high_intense_weight(&self) -> &f32;
    fn cool_down_time(&self) -> &f32;
}

impl KillWeightTrait for KillWeight {
    fn low_intense_weight(&self) -> &f32 {
        &self.low_intense_weight
    }
    fn high_intense_weight(&self) -> &f32 {
        &self.high_intense_weight
    }
    fn cool_down_time(&self) -> &f32 {
        &self.cool_down_time
    }
}

pub static KILLWEIGHT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "KillWeight",
    flags: MemberInfoFlags::new(36937),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<KillWeight as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "LowIntenseWeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(KillWeight, low_intense_weight),
            },
            FieldInfoData {
                name: "HighIntenseWeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(KillWeight, high_intense_weight),
            },
            FieldInfoData {
                name: "CoolDownTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(KillWeight, cool_down_time),
            },
        ],
    }),
    array_type: Some(KILLWEIGHT_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for KillWeight {
    fn type_info(&self) -> &'static TypeInfo {
        KILLWEIGHT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static KILLWEIGHT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "KillWeight-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("KillWeight"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DiceShooterDamageArbitrationSettings {
    pub _glacier_base: super::core::SystemSettings,
    pub server_authoritative_bullet_damage: bool,
    pub server_authoritive_bullet_damage_ignore_combined: bool,
    pub verify_weapon_hash: bool,
    pub allow_no_damage_giver_unlock: bool,
    pub allow_mismatching_damage_giver_unlock: bool,
}

pub trait DiceShooterDamageArbitrationSettingsTrait: super::core::SystemSettingsTrait {
    fn server_authoritative_bullet_damage(&self) -> &bool;
    fn server_authoritive_bullet_damage_ignore_combined(&self) -> &bool;
    fn verify_weapon_hash(&self) -> &bool;
    fn allow_no_damage_giver_unlock(&self) -> &bool;
    fn allow_mismatching_damage_giver_unlock(&self) -> &bool;
}

impl DiceShooterDamageArbitrationSettingsTrait for DiceShooterDamageArbitrationSettings {
    fn server_authoritative_bullet_damage(&self) -> &bool {
        &self.server_authoritative_bullet_damage
    }
    fn server_authoritive_bullet_damage_ignore_combined(&self) -> &bool {
        &self.server_authoritive_bullet_damage_ignore_combined
    }
    fn verify_weapon_hash(&self) -> &bool {
        &self.verify_weapon_hash
    }
    fn allow_no_damage_giver_unlock(&self) -> &bool {
        &self.allow_no_damage_giver_unlock
    }
    fn allow_mismatching_damage_giver_unlock(&self) -> &bool {
        &self.allow_mismatching_damage_giver_unlock
    }
}

impl super::core::SystemSettingsTrait for DiceShooterDamageArbitrationSettings {
    fn platform(&self) -> &super::core::GamePlatform {
        self._glacier_base.platform()
    }
}

impl super::core::DataContainerTrait for DiceShooterDamageArbitrationSettings {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static DICESHOOTERDAMAGEARBITRATIONSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DiceShooterDamageArbitrationSettings",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::SYSTEMSETTINGS_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DiceShooterDamageArbitrationSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ServerAuthoritativeBulletDamage",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DiceShooterDamageArbitrationSettings, server_authoritative_bullet_damage),
            },
            FieldInfoData {
                name: "ServerAuthoritiveBulletDamageIgnoreCombined",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DiceShooterDamageArbitrationSettings, server_authoritive_bullet_damage_ignore_combined),
            },
            FieldInfoData {
                name: "VerifyWeaponHash",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DiceShooterDamageArbitrationSettings, verify_weapon_hash),
            },
            FieldInfoData {
                name: "AllowNoDamageGiverUnlock",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DiceShooterDamageArbitrationSettings, allow_no_damage_giver_unlock),
            },
            FieldInfoData {
                name: "AllowMismatchingDamageGiverUnlock",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DiceShooterDamageArbitrationSettings, allow_mismatching_damage_giver_unlock),
            },
        ],
    }),
    array_type: Some(DICESHOOTERDAMAGEARBITRATIONSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DiceShooterDamageArbitrationSettings {
    fn type_info(&self) -> &'static TypeInfo {
        DICESHOOTERDAMAGEARBITRATIONSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static DICESHOOTERDAMAGEARBITRATIONSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DiceShooterDamageArbitrationSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("DiceShooterDamageArbitrationSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DiceShooterDCBPSTMessage {
}

pub trait DiceShooterDCBPSTMessageTrait: TypeObject {
}

impl DiceShooterDCBPSTMessageTrait for DiceShooterDCBPSTMessage {
}

pub static DICESHOOTERDCBPSTMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DiceShooterDCBPSTMessage",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DiceShooterDCBPSTMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for DiceShooterDCBPSTMessage {
    fn type_info(&self) -> &'static TypeInfo {
        DICESHOOTERDCBPSTMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}

#[derive(Clone, Debug, Default)]
pub struct DiceShooterDCBTMessage {
}

pub trait DiceShooterDCBTMessageTrait: TypeObject {
}

impl DiceShooterDCBTMessageTrait for DiceShooterDCBTMessage {
}

pub static DICESHOOTERDCBTMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DiceShooterDCBTMessage",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DiceShooterDCBTMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for DiceShooterDCBTMessage {
    fn type_info(&self) -> &'static TypeInfo {
        DICESHOOTERDCBTMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}

#[derive(Clone, Debug, Default)]
pub struct EntityCorrectionInterfaceComponentData {
    pub _glacier_base: super::entity::GameComponentData,
}

pub trait EntityCorrectionInterfaceComponentDataTrait: super::entity::GameComponentDataTrait {
}

impl EntityCorrectionInterfaceComponentDataTrait for EntityCorrectionInterfaceComponentData {
}

impl super::entity::GameComponentDataTrait for EntityCorrectionInterfaceComponentData {
}

impl super::entity::ComponentDataTrait for EntityCorrectionInterfaceComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
}

impl super::entity::GameObjectDataTrait for EntityCorrectionInterfaceComponentData {
}

impl super::core::DataBusPeerTrait for EntityCorrectionInterfaceComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for EntityCorrectionInterfaceComponentData {
}

impl super::core::DataContainerTrait for EntityCorrectionInterfaceComponentData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static ENTITYCORRECTIONINTERFACECOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityCorrectionInterfaceComponentData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EntityCorrectionInterfaceComponentData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(ENTITYCORRECTIONINTERFACECOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for EntityCorrectionInterfaceComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        ENTITYCORRECTIONINTERFACECOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ENTITYCORRECTIONINTERFACECOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityCorrectionInterfaceComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("EntityCorrectionInterfaceComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RemoteEntryComponentData {
    pub _glacier_base: DiceShooterVehicleEntryComponentData,
}

pub trait RemoteEntryComponentDataTrait: DiceShooterVehicleEntryComponentDataTrait {
}

impl RemoteEntryComponentDataTrait for RemoteEntryComponentData {
}

impl DiceShooterVehicleEntryComponentDataTrait for RemoteEntryComponentData {
    fn use_vehicle_mouse_profile(&self) -> &bool {
        self._glacier_base.use_vehicle_mouse_profile()
    }
    fn use_star_fighter_mouse_profile(&self) -> &bool {
        self._glacier_base.use_star_fighter_mouse_profile()
    }
    fn reset_aim_on_enter(&self) -> &bool {
        self._glacier_base.reset_aim_on_enter()
    }
    fn reset_aim_in_vehicle_direction(&self) -> &bool {
        self._glacier_base.reset_aim_in_vehicle_direction()
    }
    fn aim_follow_transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.aim_follow_transform()
    }
    fn update_animatable_transform(&self) -> &bool {
        self._glacier_base.update_animatable_transform()
    }
    fn set_entry_transform_to_animatable(&self) -> &bool {
        self._glacier_base.set_entry_transform_to_animatable()
    }
    fn use_soldier_offset_for_root_bone_anim(&self) -> &bool {
        self._glacier_base.use_soldier_offset_for_root_bone_anim()
    }
    fn toggle_zoom(&self) -> &bool {
        self._glacier_base.toggle_zoom()
    }
    fn server_soldier_offset(&self) -> &super::core::Vec3 {
        self._glacier_base.server_soldier_offset()
    }
    fn hide_soldier_dying_in_vehicle(&self) -> &bool {
        self._glacier_base.hide_soldier_dying_in_vehicle()
    }
    fn hide_dead_soldier_on_vehicle_explosion(&self) -> &bool {
        self._glacier_base.hide_dead_soldier_on_vehicle_explosion()
    }
    fn start_death_experience_at_camera_position(&self) -> &bool {
        self._glacier_base.start_death_experience_at_camera_position()
    }
    fn victim_offset_override(&self) -> &super::core::Vec3 {
        self._glacier_base.victim_offset_override()
    }
}

impl super::game_shared::VehicleEntryComponentDataTrait for RemoteEntryComponentData {
    fn number_of_stances(&self) -> &i32 {
        self._glacier_base.number_of_stances()
    }
    fn stances_enabled(&self) -> &bool {
        self._glacier_base.stances_enabled()
    }
    fn entry_component_sound(&self) -> &Option<Arc<Mutex<dyn super::game_shared::EntryComponentSoundDataTrait>>> {
        self._glacier_base.entry_component_sound()
    }
    fn character_collision_offset(&self) -> &super::core::Vec3 {
        self._glacier_base.character_collision_offset()
    }
    fn character_collision_offset_realm(&self) -> &super::core::Realm {
        self._glacier_base.character_collision_offset_realm()
    }
}

impl super::game_shared::PlayerEntryComponentDataTrait for RemoteEntryComponentData {
    fn ant_entry_i_d(&self) -> &String {
        self._glacier_base.ant_entry_i_d()
    }
    fn ant_entry_id(&self) -> &super::game_shared::AntEntryIdEnum {
        self._glacier_base.ant_entry_id()
    }
    fn ant_entry_enumeration(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::AntEnumerationTrait>>> {
        self._glacier_base.ant_entry_enumeration()
    }
    fn animation_acceleration_multiplier(&self) -> &super::core::Vec3 {
        self._glacier_base.animation_acceleration_multiplier()
    }
}

impl super::game_shared::GameEntryComponentDataTrait for RemoteEntryComponentData {
    fn lock_soldier_aiming_to_entry(&self) -> &bool {
        self._glacier_base.lock_soldier_aiming_to_entry()
    }
    fn soldier_offset(&self) -> &super::core::Vec3 {
        self._glacier_base.soldier_offset()
    }
}

impl super::gameplay_sim::EntryComponentDataTrait for RemoteEntryComponentData {
    fn entry_class(&self) -> &super::gameplay_sim::EntryClass {
        self._glacier_base.entry_class()
    }
    fn a_i_data(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::GameAIEntryDataTrait>>> {
        self._glacier_base.a_i_data()
    }
    fn forbidden_for_human(&self) -> &bool {
        self._glacier_base.forbidden_for_human()
    }
    fn input_graph(&self) -> &Option<Arc<Mutex<dyn super::input_shared::InputGraphTrait>>> {
        self._glacier_base.input_graph()
    }
    fn input_concept_definition(&self) -> &Option<Arc<Mutex<dyn super::input_shared::InputActionMapsDataTrait>>> {
        self._glacier_base.input_concept_definition()
    }
    fn action_map_settings_flip_y_scheme_override(&self) -> &i32 {
        self._glacier_base.action_map_settings_flip_y_scheme_override()
    }
    fn input_mapping(&self) -> &Option<Arc<Mutex<dyn super::input_shared::InputConceptToEntryInputActionMappingsTrait>>> {
        self._glacier_base.input_mapping()
    }
    fn input_curves(&self) -> &Vec<Option<Arc<Mutex<dyn super::gameplay_sim::InputCurveDataTrait>>>> {
        self._glacier_base.input_curves()
    }
    fn hud_data(&self) -> &super::gameplay_sim::EntryComponentHudData {
        self._glacier_base.hud_data()
    }
    fn entry_order_number(&self) -> &i32 {
        self._glacier_base.entry_order_number()
    }
    fn enter_impulse(&self) -> &f32 {
        self._glacier_base.enter_impulse()
    }
    fn entry_radius(&self) -> &f32 {
        self._glacier_base.entry_radius()
    }
    fn is_allowed_to_exit_in_air(&self) -> &bool {
        self._glacier_base.is_allowed_to_exit_in_air()
    }
    fn clear_path_to_exit_point_start_offset(&self) -> &super::core::Vec3 {
        self._glacier_base.clear_path_to_exit_point_start_offset()
    }
    fn is_shielded(&self) -> &bool {
        self._glacier_base.is_shielded()
    }
    fn show_soldier_in_entry(&self) -> &bool {
        self._glacier_base.show_soldier_in_entry()
    }
    fn show1p_soldier_in_entry(&self) -> &bool {
        self._glacier_base.show1p_soldier_in_entry()
    }
    fn soldier_transition_invisble_time(&self) -> &f32 {
        self._glacier_base.soldier_transition_invisble_time()
    }
    fn entry_spotting_settings(&self) -> &super::gameplay_sim::EntrySpottingSettings {
        self._glacier_base.entry_spotting_settings()
    }
    fn show_soldier_weapon_in_entry(&self) -> &bool {
        self._glacier_base.show_soldier_weapon_in_entry()
    }
    fn show1p_soldier_in_entry_for_player_only(&self) -> &bool {
        self._glacier_base.show1p_soldier_in_entry_for_player_only()
    }
    fn show3p_soldier_weapon_in_entry(&self) -> &bool {
        self._glacier_base.show3p_soldier_weapon_in_entry()
    }
    fn show_soldier_gear_in_entry(&self) -> &bool {
        self._glacier_base.show_soldier_gear_in_entry()
    }
    fn pose_constraints(&self) -> &super::gameplay_sim::PoseConstraintsData {
        self._glacier_base.pose_constraints()
    }
    fn use_local_transform(&self) -> &bool {
        self._glacier_base.use_local_transform()
    }
    fn trigger_event_on_key(&self) -> &i32 {
        self._glacier_base.trigger_event_on_key()
    }
    fn allow_ragdoll_from_entry(&self) -> &bool {
        self._glacier_base.allow_ragdoll_from_entry()
    }
    fn camera_index(&self) -> &i32 {
        self._glacier_base.camera_index()
    }
}

impl super::entity::GameComponentDataTrait for RemoteEntryComponentData {
}

impl super::entity::ComponentDataTrait for RemoteEntryComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
}

impl super::entity::GameObjectDataTrait for RemoteEntryComponentData {
}

impl super::core::DataBusPeerTrait for RemoteEntryComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for RemoteEntryComponentData {
}

impl super::core::DataContainerTrait for RemoteEntryComponentData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static REMOTEENTRYCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RemoteEntryComponentData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DICESHOOTERVEHICLEENTRYCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RemoteEntryComponentData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(REMOTEENTRYCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for RemoteEntryComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        REMOTEENTRYCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static REMOTEENTRYCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RemoteEntryComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("RemoteEntryComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DiceShooterVehicleEntryComponentData {
    pub _glacier_base: super::game_shared::VehicleEntryComponentData,
    pub use_vehicle_mouse_profile: bool,
    pub use_star_fighter_mouse_profile: bool,
    pub reset_aim_on_enter: bool,
    pub reset_aim_in_vehicle_direction: bool,
    pub aim_follow_transform: super::core::LinearTransform,
    pub update_animatable_transform: bool,
    pub set_entry_transform_to_animatable: bool,
    pub use_soldier_offset_for_root_bone_anim: bool,
    pub toggle_zoom: bool,
    pub server_soldier_offset: super::core::Vec3,
    pub hide_soldier_dying_in_vehicle: bool,
    pub hide_dead_soldier_on_vehicle_explosion: bool,
    pub start_death_experience_at_camera_position: bool,
    pub victim_offset_override: super::core::Vec3,
}

pub trait DiceShooterVehicleEntryComponentDataTrait: super::game_shared::VehicleEntryComponentDataTrait {
    fn use_vehicle_mouse_profile(&self) -> &bool;
    fn use_star_fighter_mouse_profile(&self) -> &bool;
    fn reset_aim_on_enter(&self) -> &bool;
    fn reset_aim_in_vehicle_direction(&self) -> &bool;
    fn aim_follow_transform(&self) -> &super::core::LinearTransform;
    fn update_animatable_transform(&self) -> &bool;
    fn set_entry_transform_to_animatable(&self) -> &bool;
    fn use_soldier_offset_for_root_bone_anim(&self) -> &bool;
    fn toggle_zoom(&self) -> &bool;
    fn server_soldier_offset(&self) -> &super::core::Vec3;
    fn hide_soldier_dying_in_vehicle(&self) -> &bool;
    fn hide_dead_soldier_on_vehicle_explosion(&self) -> &bool;
    fn start_death_experience_at_camera_position(&self) -> &bool;
    fn victim_offset_override(&self) -> &super::core::Vec3;
}

impl DiceShooterVehicleEntryComponentDataTrait for DiceShooterVehicleEntryComponentData {
    fn use_vehicle_mouse_profile(&self) -> &bool {
        &self.use_vehicle_mouse_profile
    }
    fn use_star_fighter_mouse_profile(&self) -> &bool {
        &self.use_star_fighter_mouse_profile
    }
    fn reset_aim_on_enter(&self) -> &bool {
        &self.reset_aim_on_enter
    }
    fn reset_aim_in_vehicle_direction(&self) -> &bool {
        &self.reset_aim_in_vehicle_direction
    }
    fn aim_follow_transform(&self) -> &super::core::LinearTransform {
        &self.aim_follow_transform
    }
    fn update_animatable_transform(&self) -> &bool {
        &self.update_animatable_transform
    }
    fn set_entry_transform_to_animatable(&self) -> &bool {
        &self.set_entry_transform_to_animatable
    }
    fn use_soldier_offset_for_root_bone_anim(&self) -> &bool {
        &self.use_soldier_offset_for_root_bone_anim
    }
    fn toggle_zoom(&self) -> &bool {
        &self.toggle_zoom
    }
    fn server_soldier_offset(&self) -> &super::core::Vec3 {
        &self.server_soldier_offset
    }
    fn hide_soldier_dying_in_vehicle(&self) -> &bool {
        &self.hide_soldier_dying_in_vehicle
    }
    fn hide_dead_soldier_on_vehicle_explosion(&self) -> &bool {
        &self.hide_dead_soldier_on_vehicle_explosion
    }
    fn start_death_experience_at_camera_position(&self) -> &bool {
        &self.start_death_experience_at_camera_position
    }
    fn victim_offset_override(&self) -> &super::core::Vec3 {
        &self.victim_offset_override
    }
}

impl super::game_shared::VehicleEntryComponentDataTrait for DiceShooterVehicleEntryComponentData {
    fn number_of_stances(&self) -> &i32 {
        self._glacier_base.number_of_stances()
    }
    fn stances_enabled(&self) -> &bool {
        self._glacier_base.stances_enabled()
    }
    fn entry_component_sound(&self) -> &Option<Arc<Mutex<dyn super::game_shared::EntryComponentSoundDataTrait>>> {
        self._glacier_base.entry_component_sound()
    }
    fn character_collision_offset(&self) -> &super::core::Vec3 {
        self._glacier_base.character_collision_offset()
    }
    fn character_collision_offset_realm(&self) -> &super::core::Realm {
        self._glacier_base.character_collision_offset_realm()
    }
}

impl super::game_shared::PlayerEntryComponentDataTrait for DiceShooterVehicleEntryComponentData {
    fn ant_entry_i_d(&self) -> &String {
        self._glacier_base.ant_entry_i_d()
    }
    fn ant_entry_id(&self) -> &super::game_shared::AntEntryIdEnum {
        self._glacier_base.ant_entry_id()
    }
    fn ant_entry_enumeration(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::AntEnumerationTrait>>> {
        self._glacier_base.ant_entry_enumeration()
    }
    fn animation_acceleration_multiplier(&self) -> &super::core::Vec3 {
        self._glacier_base.animation_acceleration_multiplier()
    }
}

impl super::game_shared::GameEntryComponentDataTrait for DiceShooterVehicleEntryComponentData {
    fn lock_soldier_aiming_to_entry(&self) -> &bool {
        self._glacier_base.lock_soldier_aiming_to_entry()
    }
    fn soldier_offset(&self) -> &super::core::Vec3 {
        self._glacier_base.soldier_offset()
    }
}

impl super::gameplay_sim::EntryComponentDataTrait for DiceShooterVehicleEntryComponentData {
    fn entry_class(&self) -> &super::gameplay_sim::EntryClass {
        self._glacier_base.entry_class()
    }
    fn a_i_data(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::GameAIEntryDataTrait>>> {
        self._glacier_base.a_i_data()
    }
    fn forbidden_for_human(&self) -> &bool {
        self._glacier_base.forbidden_for_human()
    }
    fn input_graph(&self) -> &Option<Arc<Mutex<dyn super::input_shared::InputGraphTrait>>> {
        self._glacier_base.input_graph()
    }
    fn input_concept_definition(&self) -> &Option<Arc<Mutex<dyn super::input_shared::InputActionMapsDataTrait>>> {
        self._glacier_base.input_concept_definition()
    }
    fn action_map_settings_flip_y_scheme_override(&self) -> &i32 {
        self._glacier_base.action_map_settings_flip_y_scheme_override()
    }
    fn input_mapping(&self) -> &Option<Arc<Mutex<dyn super::input_shared::InputConceptToEntryInputActionMappingsTrait>>> {
        self._glacier_base.input_mapping()
    }
    fn input_curves(&self) -> &Vec<Option<Arc<Mutex<dyn super::gameplay_sim::InputCurveDataTrait>>>> {
        self._glacier_base.input_curves()
    }
    fn hud_data(&self) -> &super::gameplay_sim::EntryComponentHudData {
        self._glacier_base.hud_data()
    }
    fn entry_order_number(&self) -> &i32 {
        self._glacier_base.entry_order_number()
    }
    fn enter_impulse(&self) -> &f32 {
        self._glacier_base.enter_impulse()
    }
    fn entry_radius(&self) -> &f32 {
        self._glacier_base.entry_radius()
    }
    fn is_allowed_to_exit_in_air(&self) -> &bool {
        self._glacier_base.is_allowed_to_exit_in_air()
    }
    fn clear_path_to_exit_point_start_offset(&self) -> &super::core::Vec3 {
        self._glacier_base.clear_path_to_exit_point_start_offset()
    }
    fn is_shielded(&self) -> &bool {
        self._glacier_base.is_shielded()
    }
    fn show_soldier_in_entry(&self) -> &bool {
        self._glacier_base.show_soldier_in_entry()
    }
    fn show1p_soldier_in_entry(&self) -> &bool {
        self._glacier_base.show1p_soldier_in_entry()
    }
    fn soldier_transition_invisble_time(&self) -> &f32 {
        self._glacier_base.soldier_transition_invisble_time()
    }
    fn entry_spotting_settings(&self) -> &super::gameplay_sim::EntrySpottingSettings {
        self._glacier_base.entry_spotting_settings()
    }
    fn show_soldier_weapon_in_entry(&self) -> &bool {
        self._glacier_base.show_soldier_weapon_in_entry()
    }
    fn show1p_soldier_in_entry_for_player_only(&self) -> &bool {
        self._glacier_base.show1p_soldier_in_entry_for_player_only()
    }
    fn show3p_soldier_weapon_in_entry(&self) -> &bool {
        self._glacier_base.show3p_soldier_weapon_in_entry()
    }
    fn show_soldier_gear_in_entry(&self) -> &bool {
        self._glacier_base.show_soldier_gear_in_entry()
    }
    fn pose_constraints(&self) -> &super::gameplay_sim::PoseConstraintsData {
        self._glacier_base.pose_constraints()
    }
    fn use_local_transform(&self) -> &bool {
        self._glacier_base.use_local_transform()
    }
    fn trigger_event_on_key(&self) -> &i32 {
        self._glacier_base.trigger_event_on_key()
    }
    fn allow_ragdoll_from_entry(&self) -> &bool {
        self._glacier_base.allow_ragdoll_from_entry()
    }
    fn camera_index(&self) -> &i32 {
        self._glacier_base.camera_index()
    }
}

impl super::entity::GameComponentDataTrait for DiceShooterVehicleEntryComponentData {
}

impl super::entity::ComponentDataTrait for DiceShooterVehicleEntryComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
}

impl super::entity::GameObjectDataTrait for DiceShooterVehicleEntryComponentData {
}

impl super::core::DataBusPeerTrait for DiceShooterVehicleEntryComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for DiceShooterVehicleEntryComponentData {
}

impl super::core::DataContainerTrait for DiceShooterVehicleEntryComponentData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static DICESHOOTERVEHICLEENTRYCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DiceShooterVehicleEntryComponentData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::game_shared::VEHICLEENTRYCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DiceShooterVehicleEntryComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "UseVehicleMouseProfile",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DiceShooterVehicleEntryComponentData, use_vehicle_mouse_profile),
            },
            FieldInfoData {
                name: "UseStarFighterMouseProfile",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DiceShooterVehicleEntryComponentData, use_star_fighter_mouse_profile),
            },
            FieldInfoData {
                name: "ResetAimOnEnter",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DiceShooterVehicleEntryComponentData, reset_aim_on_enter),
            },
            FieldInfoData {
                name: "ResetAimInVehicleDirection",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DiceShooterVehicleEntryComponentData, reset_aim_in_vehicle_direction),
            },
            FieldInfoData {
                name: "AimFollowTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(DiceShooterVehicleEntryComponentData, aim_follow_transform),
            },
            FieldInfoData {
                name: "UpdateAnimatableTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DiceShooterVehicleEntryComponentData, update_animatable_transform),
            },
            FieldInfoData {
                name: "SetEntryTransformToAnimatable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DiceShooterVehicleEntryComponentData, set_entry_transform_to_animatable),
            },
            FieldInfoData {
                name: "UseSoldierOffsetForRootBoneAnim",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DiceShooterVehicleEntryComponentData, use_soldier_offset_for_root_bone_anim),
            },
            FieldInfoData {
                name: "ToggleZoom",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DiceShooterVehicleEntryComponentData, toggle_zoom),
            },
            FieldInfoData {
                name: "ServerSoldierOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(DiceShooterVehicleEntryComponentData, server_soldier_offset),
            },
            FieldInfoData {
                name: "HideSoldierDyingInVehicle",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DiceShooterVehicleEntryComponentData, hide_soldier_dying_in_vehicle),
            },
            FieldInfoData {
                name: "HideDeadSoldierOnVehicleExplosion",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DiceShooterVehicleEntryComponentData, hide_dead_soldier_on_vehicle_explosion),
            },
            FieldInfoData {
                name: "StartDeathExperienceAtCameraPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DiceShooterVehicleEntryComponentData, start_death_experience_at_camera_position),
            },
            FieldInfoData {
                name: "VictimOffsetOverride",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(DiceShooterVehicleEntryComponentData, victim_offset_override),
            },
        ],
    }),
    array_type: Some(DICESHOOTERVEHICLEENTRYCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for DiceShooterVehicleEntryComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        DICESHOOTERVEHICLEENTRYCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static DICESHOOTERVEHICLEENTRYCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DiceShooterVehicleEntryComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("DiceShooterVehicleEntryComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ShieldPhysicsComponentData {
    pub _glacier_base: super::gameplay_sim::GamePhysicsComponentData,
}

pub trait ShieldPhysicsComponentDataTrait: super::gameplay_sim::GamePhysicsComponentDataTrait {
}

impl ShieldPhysicsComponentDataTrait for ShieldPhysicsComponentData {
}

impl super::gameplay_sim::GamePhysicsComponentDataTrait for ShieldPhysicsComponentData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn effect_parameters(&self) -> &Vec<Option<Arc<Mutex<dyn super::effect_base::EffectParameterTrait>>>> {
        self._glacier_base.effect_parameters()
    }
}

impl super::physics::PhysicsComponentDataTrait for ShieldPhysicsComponentData {
    fn physics_bodies(&self) -> &Vec<Option<Arc<Mutex<dyn super::physics::PhysicsBodyDataTrait>>>> {
        self._glacier_base.physics_bodies()
    }
    fn physics_constraints(&self) -> &Vec<Option<Arc<Mutex<dyn super::physics::PhysicsConstraintDataTrait>>>> {
        self._glacier_base.physics_constraints()
    }
    fn parts(&self) -> &Vec<super::physics::PhysicsPartData> {
        self._glacier_base.parts()
    }
    fn movable_parts(&self) -> &bool {
        self._glacier_base.movable_parts()
    }
    fn internal_collision_disabling(&self) -> &super::physics::InternalCollisionDisablingBehavior {
        self._glacier_base.internal_collision_disabling()
    }
    fn enable_collision_events(&self) -> &bool {
        self._glacier_base.enable_collision_events()
    }
}

impl super::entity::ComponentDataTrait for ShieldPhysicsComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
}

impl super::entity::GameObjectDataTrait for ShieldPhysicsComponentData {
}

impl super::core::DataBusPeerTrait for ShieldPhysicsComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for ShieldPhysicsComponentData {
}

impl super::core::DataContainerTrait for ShieldPhysicsComponentData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SHIELDPHYSICSCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ShieldPhysicsComponentData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::GAMEPHYSICSCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ShieldPhysicsComponentData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SHIELDPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ShieldPhysicsComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        SHIELDPHYSICSCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SHIELDPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ShieldPhysicsComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("ShieldPhysicsComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ShieldHealthComponentData {
    pub _glacier_base: super::gameplay_sim::GameHealthComponentData,
    pub max_health: f32,
    pub self_damage_modifier: f32,
    pub friendy_fire_damage_modifier: f32,
}

pub trait ShieldHealthComponentDataTrait: super::gameplay_sim::GameHealthComponentDataTrait {
    fn max_health(&self) -> &f32;
    fn self_damage_modifier(&self) -> &f32;
    fn friendy_fire_damage_modifier(&self) -> &f32;
}

impl ShieldHealthComponentDataTrait for ShieldHealthComponentData {
    fn max_health(&self) -> &f32 {
        &self.max_health
    }
    fn self_damage_modifier(&self) -> &f32 {
        &self.self_damage_modifier
    }
    fn friendy_fire_damage_modifier(&self) -> &f32 {
        &self.friendy_fire_damage_modifier
    }
}

impl super::gameplay_sim::GameHealthComponentDataTrait for ShieldHealthComponentData {
}

impl super::gameplay_sim::HealthComponentDataTrait for ShieldHealthComponentData {
}

impl super::entity::ComponentDataTrait for ShieldHealthComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
}

impl super::entity::GameObjectDataTrait for ShieldHealthComponentData {
}

impl super::core::DataBusPeerTrait for ShieldHealthComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for ShieldHealthComponentData {
}

impl super::core::DataContainerTrait for ShieldHealthComponentData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SHIELDHEALTHCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ShieldHealthComponentData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::GAMEHEALTHCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ShieldHealthComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MaxHealth",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ShieldHealthComponentData, max_health),
            },
            FieldInfoData {
                name: "SelfDamageModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ShieldHealthComponentData, self_damage_modifier),
            },
            FieldInfoData {
                name: "FriendyFireDamageModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ShieldHealthComponentData, friendy_fire_damage_modifier),
            },
        ],
    }),
    array_type: Some(SHIELDHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ShieldHealthComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        SHIELDHEALTHCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SHIELDHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ShieldHealthComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("ShieldHealthComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ShieldComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub arc_angle: f32,
    pub ignore_friendly_projectiles: bool,
    pub ignore_friendly_explosions: bool,
    pub ignore_outgoing_projectiles: bool,
    pub ignore_own_explosions: bool,
    pub ignore_own_projectiles: bool,
    pub ignore_bullets: bool,
    pub ignore_missiles: bool,
    pub ignore_grenades: bool,
    pub ignore_explosions: bool,
    pub always_block_unlock_ids: Vec<u32>,
    pub ignored_unlock_ids: Vec<u32>,
    pub use_grenade_deflection_speed: bool,
    pub grenade_deflection_speed: f32,
    pub test_occlusion: bool,
    pub render: bool,
}

pub trait ShieldComponentDataTrait: super::entity::GameComponentDataTrait {
    fn arc_angle(&self) -> &f32;
    fn ignore_friendly_projectiles(&self) -> &bool;
    fn ignore_friendly_explosions(&self) -> &bool;
    fn ignore_outgoing_projectiles(&self) -> &bool;
    fn ignore_own_explosions(&self) -> &bool;
    fn ignore_own_projectiles(&self) -> &bool;
    fn ignore_bullets(&self) -> &bool;
    fn ignore_missiles(&self) -> &bool;
    fn ignore_grenades(&self) -> &bool;
    fn ignore_explosions(&self) -> &bool;
    fn always_block_unlock_ids(&self) -> &Vec<u32>;
    fn ignored_unlock_ids(&self) -> &Vec<u32>;
    fn use_grenade_deflection_speed(&self) -> &bool;
    fn grenade_deflection_speed(&self) -> &f32;
    fn test_occlusion(&self) -> &bool;
    fn render(&self) -> &bool;
}

impl ShieldComponentDataTrait for ShieldComponentData {
    fn arc_angle(&self) -> &f32 {
        &self.arc_angle
    }
    fn ignore_friendly_projectiles(&self) -> &bool {
        &self.ignore_friendly_projectiles
    }
    fn ignore_friendly_explosions(&self) -> &bool {
        &self.ignore_friendly_explosions
    }
    fn ignore_outgoing_projectiles(&self) -> &bool {
        &self.ignore_outgoing_projectiles
    }
    fn ignore_own_explosions(&self) -> &bool {
        &self.ignore_own_explosions
    }
    fn ignore_own_projectiles(&self) -> &bool {
        &self.ignore_own_projectiles
    }
    fn ignore_bullets(&self) -> &bool {
        &self.ignore_bullets
    }
    fn ignore_missiles(&self) -> &bool {
        &self.ignore_missiles
    }
    fn ignore_grenades(&self) -> &bool {
        &self.ignore_grenades
    }
    fn ignore_explosions(&self) -> &bool {
        &self.ignore_explosions
    }
    fn always_block_unlock_ids(&self) -> &Vec<u32> {
        &self.always_block_unlock_ids
    }
    fn ignored_unlock_ids(&self) -> &Vec<u32> {
        &self.ignored_unlock_ids
    }
    fn use_grenade_deflection_speed(&self) -> &bool {
        &self.use_grenade_deflection_speed
    }
    fn grenade_deflection_speed(&self) -> &f32 {
        &self.grenade_deflection_speed
    }
    fn test_occlusion(&self) -> &bool {
        &self.test_occlusion
    }
    fn render(&self) -> &bool {
        &self.render
    }
}

impl super::entity::GameComponentDataTrait for ShieldComponentData {
}

impl super::entity::ComponentDataTrait for ShieldComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
}

impl super::entity::GameObjectDataTrait for ShieldComponentData {
}

impl super::core::DataBusPeerTrait for ShieldComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for ShieldComponentData {
}

impl super::core::DataContainerTrait for ShieldComponentData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SHIELDCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ShieldComponentData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ShieldComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ArcAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ShieldComponentData, arc_angle),
            },
            FieldInfoData {
                name: "IgnoreFriendlyProjectiles",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ShieldComponentData, ignore_friendly_projectiles),
            },
            FieldInfoData {
                name: "IgnoreFriendlyExplosions",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ShieldComponentData, ignore_friendly_explosions),
            },
            FieldInfoData {
                name: "IgnoreOutgoingProjectiles",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ShieldComponentData, ignore_outgoing_projectiles),
            },
            FieldInfoData {
                name: "IgnoreOwnExplosions",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ShieldComponentData, ignore_own_explosions),
            },
            FieldInfoData {
                name: "IgnoreOwnProjectiles",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ShieldComponentData, ignore_own_projectiles),
            },
            FieldInfoData {
                name: "IgnoreBullets",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ShieldComponentData, ignore_bullets),
            },
            FieldInfoData {
                name: "IgnoreMissiles",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ShieldComponentData, ignore_missiles),
            },
            FieldInfoData {
                name: "IgnoreGrenades",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ShieldComponentData, ignore_grenades),
            },
            FieldInfoData {
                name: "IgnoreExplosions",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ShieldComponentData, ignore_explosions),
            },
            FieldInfoData {
                name: "AlwaysBlockUnlockIds",
                flags: MemberInfoFlags::new(144),
                field_type: "Uint32-Array",
                rust_offset: offset_of!(ShieldComponentData, always_block_unlock_ids),
            },
            FieldInfoData {
                name: "IgnoredUnlockIds",
                flags: MemberInfoFlags::new(144),
                field_type: "Uint32-Array",
                rust_offset: offset_of!(ShieldComponentData, ignored_unlock_ids),
            },
            FieldInfoData {
                name: "UseGrenadeDeflectionSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ShieldComponentData, use_grenade_deflection_speed),
            },
            FieldInfoData {
                name: "GrenadeDeflectionSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ShieldComponentData, grenade_deflection_speed),
            },
            FieldInfoData {
                name: "TestOcclusion",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ShieldComponentData, test_occlusion),
            },
            FieldInfoData {
                name: "Render",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ShieldComponentData, render),
            },
        ],
    }),
    array_type: Some(SHIELDCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ShieldComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        SHIELDCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SHIELDCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ShieldComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("ShieldComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ShieldControllerComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub enabled: bool,
    pub allow_creation: bool,
    pub team: super::gameplay_sim::TeamId,
    pub shield: Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>>,
    pub shields: Vec<Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>>>,
    pub shield_index: i32,
    pub ignore_explosion_outside_radius: bool,
    pub shield_radius: f32,
    pub shield_offset_transform: super::core::LinearTransform,
    pub max_health: f32,
}

pub trait ShieldControllerComponentDataTrait: super::entity::GameComponentDataTrait {
    fn enabled(&self) -> &bool;
    fn allow_creation(&self) -> &bool;
    fn team(&self) -> &super::gameplay_sim::TeamId;
    fn shield(&self) -> &Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>>;
    fn shields(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>>>;
    fn shield_index(&self) -> &i32;
    fn ignore_explosion_outside_radius(&self) -> &bool;
    fn shield_radius(&self) -> &f32;
    fn shield_offset_transform(&self) -> &super::core::LinearTransform;
    fn max_health(&self) -> &f32;
}

impl ShieldControllerComponentDataTrait for ShieldControllerComponentData {
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn allow_creation(&self) -> &bool {
        &self.allow_creation
    }
    fn team(&self) -> &super::gameplay_sim::TeamId {
        &self.team
    }
    fn shield(&self) -> &Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>> {
        &self.shield
    }
    fn shields(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>>> {
        &self.shields
    }
    fn shield_index(&self) -> &i32 {
        &self.shield_index
    }
    fn ignore_explosion_outside_radius(&self) -> &bool {
        &self.ignore_explosion_outside_radius
    }
    fn shield_radius(&self) -> &f32 {
        &self.shield_radius
    }
    fn shield_offset_transform(&self) -> &super::core::LinearTransform {
        &self.shield_offset_transform
    }
    fn max_health(&self) -> &f32 {
        &self.max_health
    }
}

impl super::entity::GameComponentDataTrait for ShieldControllerComponentData {
}

impl super::entity::ComponentDataTrait for ShieldControllerComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
}

impl super::entity::GameObjectDataTrait for ShieldControllerComponentData {
}

impl super::core::DataBusPeerTrait for ShieldControllerComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for ShieldControllerComponentData {
}

impl super::core::DataContainerTrait for ShieldControllerComponentData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SHIELDCONTROLLERCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ShieldControllerComponentData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ShieldControllerComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ShieldControllerComponentData, enabled),
            },
            FieldInfoData {
                name: "AllowCreation",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ShieldControllerComponentData, allow_creation),
            },
            FieldInfoData {
                name: "Team",
                flags: MemberInfoFlags::new(0),
                field_type: "TeamId",
                rust_offset: offset_of!(ShieldControllerComponentData, team),
            },
            FieldInfoData {
                name: "Shield",
                flags: MemberInfoFlags::new(0),
                field_type: "ObjectBlueprint",
                rust_offset: offset_of!(ShieldControllerComponentData, shield),
            },
            FieldInfoData {
                name: "Shields",
                flags: MemberInfoFlags::new(144),
                field_type: "ObjectBlueprint-Array",
                rust_offset: offset_of!(ShieldControllerComponentData, shields),
            },
            FieldInfoData {
                name: "ShieldIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ShieldControllerComponentData, shield_index),
            },
            FieldInfoData {
                name: "IgnoreExplosionOutsideRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ShieldControllerComponentData, ignore_explosion_outside_radius),
            },
            FieldInfoData {
                name: "ShieldRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ShieldControllerComponentData, shield_radius),
            },
            FieldInfoData {
                name: "ShieldOffsetTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(ShieldControllerComponentData, shield_offset_transform),
            },
            FieldInfoData {
                name: "MaxHealth",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ShieldControllerComponentData, max_health),
            },
        ],
    }),
    array_type: Some(SHIELDCONTROLLERCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ShieldControllerComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        SHIELDCONTROLLERCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SHIELDCONTROLLERCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ShieldControllerComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("ShieldControllerComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ShieldStateComponentData {
    pub _glacier_base: super::entity::GameComponentData,
}

pub trait ShieldStateComponentDataTrait: super::entity::GameComponentDataTrait {
}

impl ShieldStateComponentDataTrait for ShieldStateComponentData {
}

impl super::entity::GameComponentDataTrait for ShieldStateComponentData {
}

impl super::entity::ComponentDataTrait for ShieldStateComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
}

impl super::entity::GameObjectDataTrait for ShieldStateComponentData {
}

impl super::core::DataBusPeerTrait for ShieldStateComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for ShieldStateComponentData {
}

impl super::core::DataContainerTrait for ShieldStateComponentData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SHIELDSTATECOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ShieldStateComponentData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ShieldStateComponentData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SHIELDSTATECOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ShieldStateComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        SHIELDSTATECOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SHIELDSTATECOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ShieldStateComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("ShieldStateComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum ShieldControllerComponentConstants {
    #[default]
    MaxShieldCount = 4,
}

pub static SHIELDCONTROLLERCOMPONENTCONSTANTS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ShieldControllerComponentConstants",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(SHIELDCONTROLLERCOMPONENTCONSTANTS_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for ShieldControllerComponentConstants {
    fn type_info(&self) -> &'static TypeInfo {
        SHIELDCONTROLLERCOMPONENTCONSTANTS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SHIELDCONTROLLERCOMPONENTCONSTANTS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ShieldControllerComponentConstants-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("ShieldControllerComponentConstants"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum ShieldInterceptedType {
    #[default]
    ShieldInterceptedType_None = 0,
    ShieldInterceptedType_Bullet = 1,
    ShieldInterceptedType_Missile = 2,
    ShieldInterceptedType_Grenade = 3,
    ShieldInterceptedType_Explosion = 4,
    ShieldInterceptedType_Arrow = 5,
}

pub static SHIELDINTERCEPTEDTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ShieldInterceptedType",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(SHIELDINTERCEPTEDTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for ShieldInterceptedType {
    fn type_info(&self) -> &'static TypeInfo {
        SHIELDINTERCEPTEDTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SHIELDINTERCEPTEDTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ShieldInterceptedType-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("ShieldInterceptedType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WeaponAttachWithFovScaleData {
    pub _glacier_base: WeaponAttachData,
}

pub trait WeaponAttachWithFovScaleDataTrait: WeaponAttachDataTrait {
}

impl WeaponAttachWithFovScaleDataTrait for WeaponAttachWithFovScaleData {
}

impl WeaponAttachDataTrait for WeaponAttachWithFovScaleData {
    fn bone(&self) -> &super::entity::GameplayBones {
        self._glacier_base.bone()
    }
}

impl super::dice_commons_shared::EntityAttachDataTrait for WeaponAttachWithFovScaleData {
    fn property_name(&self) -> &String {
        self._glacier_base.property_name()
    }
    fn has_dynamic_transform_space_offset(&self) -> &bool {
        self._glacier_base.has_dynamic_transform_space_offset()
    }
    fn use_rotation(&self) -> &bool {
        self._glacier_base.use_rotation()
    }
    fn coordinate_space(&self) -> &Option<Arc<Mutex<dyn super::dice_commons_shared::CoordinateModificationDataTrait>>> {
        self._glacier_base.coordinate_space()
    }
    fn offset(&self) -> &Option<Arc<Mutex<dyn super::dice_commons_shared::OffsetModificationDataTrait>>> {
        self._glacier_base.offset()
    }
}

impl super::dice_commons_shared::EntityLinkDataTrait for WeaponAttachWithFovScaleData {
    fn link_name(&self) -> &String {
        self._glacier_base.link_name()
    }
}

impl super::core::DataContainerTrait for WeaponAttachWithFovScaleData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static WEAPONATTACHWITHFOVSCALEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponAttachWithFovScaleData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(WEAPONATTACHDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WeaponAttachWithFovScaleData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(WEAPONATTACHWITHFOVSCALEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WeaponAttachWithFovScaleData {
    fn type_info(&self) -> &'static TypeInfo {
        WEAPONATTACHWITHFOVSCALEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static WEAPONATTACHWITHFOVSCALEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponAttachWithFovScaleData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("WeaponAttachWithFovScaleData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WeaponAttachData {
    pub _glacier_base: super::dice_commons_shared::EntityAttachData,
    pub bone: super::entity::GameplayBones,
}

pub trait WeaponAttachDataTrait: super::dice_commons_shared::EntityAttachDataTrait {
    fn bone(&self) -> &super::entity::GameplayBones;
}

impl WeaponAttachDataTrait for WeaponAttachData {
    fn bone(&self) -> &super::entity::GameplayBones {
        &self.bone
    }
}

impl super::dice_commons_shared::EntityAttachDataTrait for WeaponAttachData {
    fn property_name(&self) -> &String {
        self._glacier_base.property_name()
    }
    fn has_dynamic_transform_space_offset(&self) -> &bool {
        self._glacier_base.has_dynamic_transform_space_offset()
    }
    fn use_rotation(&self) -> &bool {
        self._glacier_base.use_rotation()
    }
    fn coordinate_space(&self) -> &Option<Arc<Mutex<dyn super::dice_commons_shared::CoordinateModificationDataTrait>>> {
        self._glacier_base.coordinate_space()
    }
    fn offset(&self) -> &Option<Arc<Mutex<dyn super::dice_commons_shared::OffsetModificationDataTrait>>> {
        self._glacier_base.offset()
    }
}

impl super::dice_commons_shared::EntityLinkDataTrait for WeaponAttachData {
    fn link_name(&self) -> &String {
        self._glacier_base.link_name()
    }
}

impl super::core::DataContainerTrait for WeaponAttachData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static WEAPONATTACHDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponAttachData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::dice_commons_shared::ENTITYATTACHDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WeaponAttachData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Bone",
                flags: MemberInfoFlags::new(0),
                field_type: "GameplayBones",
                rust_offset: offset_of!(WeaponAttachData, bone),
            },
        ],
    }),
    array_type: Some(WEAPONATTACHDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WeaponAttachData {
    fn type_info(&self) -> &'static TypeInfo {
        WEAPONATTACHDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static WEAPONATTACHDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponAttachData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("WeaponAttachData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WeaponTransformLinkData {
    pub _glacier_base: super::dice_commons_shared::AnimatableTransformLinkData,
}

pub trait WeaponTransformLinkDataTrait: super::dice_commons_shared::AnimatableTransformLinkDataTrait {
}

impl WeaponTransformLinkDataTrait for WeaponTransformLinkData {
}

impl super::dice_commons_shared::AnimatableTransformLinkDataTrait for WeaponTransformLinkData {
    fn bone(&self) -> &super::entity::GameplayBones {
        self._glacier_base.bone()
    }
}

impl super::dice_commons_shared::EntityTransformLinkDataTrait for WeaponTransformLinkData {
}

impl super::dice_commons_shared::EntityLinkDataTrait for WeaponTransformLinkData {
    fn link_name(&self) -> &String {
        self._glacier_base.link_name()
    }
}

impl super::core::DataContainerTrait for WeaponTransformLinkData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static WEAPONTRANSFORMLINKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponTransformLinkData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::dice_commons_shared::ANIMATABLETRANSFORMLINKDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WeaponTransformLinkData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(WEAPONTRANSFORMLINKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WeaponTransformLinkData {
    fn type_info(&self) -> &'static TypeInfo {
        WEAPONTRANSFORMLINKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static WEAPONTRANSFORMLINKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponTransformLinkData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("WeaponTransformLinkData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DiceTelemetrySettings {
    pub _glacier_base: super::core::SystemSettings,
    pub data_major_version: u32,
    pub data_minor_version: u32,
    pub enable_client_telemetry: bool,
    pub enable_server_telemetry: bool,
    pub client_output_file: bool,
    pub client_file_variation_count: u32,
    pub client_telemetry_update_interval: f32,
    pub verbosity_level: i32,
    pub blaze_metric_values: Vec<String>,
}

pub trait DiceTelemetrySettingsTrait: super::core::SystemSettingsTrait {
    fn data_major_version(&self) -> &u32;
    fn data_minor_version(&self) -> &u32;
    fn enable_client_telemetry(&self) -> &bool;
    fn enable_server_telemetry(&self) -> &bool;
    fn client_output_file(&self) -> &bool;
    fn client_file_variation_count(&self) -> &u32;
    fn client_telemetry_update_interval(&self) -> &f32;
    fn verbosity_level(&self) -> &i32;
    fn blaze_metric_values(&self) -> &Vec<String>;
}

impl DiceTelemetrySettingsTrait for DiceTelemetrySettings {
    fn data_major_version(&self) -> &u32 {
        &self.data_major_version
    }
    fn data_minor_version(&self) -> &u32 {
        &self.data_minor_version
    }
    fn enable_client_telemetry(&self) -> &bool {
        &self.enable_client_telemetry
    }
    fn enable_server_telemetry(&self) -> &bool {
        &self.enable_server_telemetry
    }
    fn client_output_file(&self) -> &bool {
        &self.client_output_file
    }
    fn client_file_variation_count(&self) -> &u32 {
        &self.client_file_variation_count
    }
    fn client_telemetry_update_interval(&self) -> &f32 {
        &self.client_telemetry_update_interval
    }
    fn verbosity_level(&self) -> &i32 {
        &self.verbosity_level
    }
    fn blaze_metric_values(&self) -> &Vec<String> {
        &self.blaze_metric_values
    }
}

impl super::core::SystemSettingsTrait for DiceTelemetrySettings {
    fn platform(&self) -> &super::core::GamePlatform {
        self._glacier_base.platform()
    }
}

impl super::core::DataContainerTrait for DiceTelemetrySettings {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static DICETELEMETRYSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DiceTelemetrySettings",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::SYSTEMSETTINGS_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DiceTelemetrySettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DataMajorVersion",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(DiceTelemetrySettings, data_major_version),
            },
            FieldInfoData {
                name: "DataMinorVersion",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(DiceTelemetrySettings, data_minor_version),
            },
            FieldInfoData {
                name: "EnableClientTelemetry",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DiceTelemetrySettings, enable_client_telemetry),
            },
            FieldInfoData {
                name: "EnableServerTelemetry",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DiceTelemetrySettings, enable_server_telemetry),
            },
            FieldInfoData {
                name: "ClientOutputFile",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DiceTelemetrySettings, client_output_file),
            },
            FieldInfoData {
                name: "ClientFileVariationCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(DiceTelemetrySettings, client_file_variation_count),
            },
            FieldInfoData {
                name: "ClientTelemetryUpdateInterval",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DiceTelemetrySettings, client_telemetry_update_interval),
            },
            FieldInfoData {
                name: "VerbosityLevel",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(DiceTelemetrySettings, verbosity_level),
            },
            FieldInfoData {
                name: "BlazeMetricValues",
                flags: MemberInfoFlags::new(144),
                field_type: "CString-Array",
                rust_offset: offset_of!(DiceTelemetrySettings, blaze_metric_values),
            },
        ],
    }),
    array_type: Some(DICETELEMETRYSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DiceTelemetrySettings {
    fn type_info(&self) -> &'static TypeInfo {
        DICETELEMETRYSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static DICETELEMETRYSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DiceTelemetrySettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("DiceTelemetrySettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ViewQueryEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub angle_penalty: f32,
    pub view_angle: f32,
    pub view_distance: f32,
    pub keep_low_prio_distance: f32,
    pub set_low_prio_distance: f32,
    pub radius: f32,
    pub inner_radius: f32,
    pub lod_distance_for_unprioritized_characters: f32,
    pub lod_distance_for_local_shadow: f32,
    pub forced_low_lod_distance: f32,
    pub max_lod_distance: f32,
    pub max_improvement_per_second: f32,
    pub always_enabled: bool,
    pub is3p: bool,
    pub is_local_player: bool,
    pub force_low_lod: bool,
}

pub trait ViewQueryEntityDataTrait: super::entity::EntityDataTrait {
    fn angle_penalty(&self) -> &f32;
    fn view_angle(&self) -> &f32;
    fn view_distance(&self) -> &f32;
    fn keep_low_prio_distance(&self) -> &f32;
    fn set_low_prio_distance(&self) -> &f32;
    fn radius(&self) -> &f32;
    fn inner_radius(&self) -> &f32;
    fn lod_distance_for_unprioritized_characters(&self) -> &f32;
    fn lod_distance_for_local_shadow(&self) -> &f32;
    fn forced_low_lod_distance(&self) -> &f32;
    fn max_lod_distance(&self) -> &f32;
    fn max_improvement_per_second(&self) -> &f32;
    fn always_enabled(&self) -> &bool;
    fn is3p(&self) -> &bool;
    fn is_local_player(&self) -> &bool;
    fn force_low_lod(&self) -> &bool;
}

impl ViewQueryEntityDataTrait for ViewQueryEntityData {
    fn angle_penalty(&self) -> &f32 {
        &self.angle_penalty
    }
    fn view_angle(&self) -> &f32 {
        &self.view_angle
    }
    fn view_distance(&self) -> &f32 {
        &self.view_distance
    }
    fn keep_low_prio_distance(&self) -> &f32 {
        &self.keep_low_prio_distance
    }
    fn set_low_prio_distance(&self) -> &f32 {
        &self.set_low_prio_distance
    }
    fn radius(&self) -> &f32 {
        &self.radius
    }
    fn inner_radius(&self) -> &f32 {
        &self.inner_radius
    }
    fn lod_distance_for_unprioritized_characters(&self) -> &f32 {
        &self.lod_distance_for_unprioritized_characters
    }
    fn lod_distance_for_local_shadow(&self) -> &f32 {
        &self.lod_distance_for_local_shadow
    }
    fn forced_low_lod_distance(&self) -> &f32 {
        &self.forced_low_lod_distance
    }
    fn max_lod_distance(&self) -> &f32 {
        &self.max_lod_distance
    }
    fn max_improvement_per_second(&self) -> &f32 {
        &self.max_improvement_per_second
    }
    fn always_enabled(&self) -> &bool {
        &self.always_enabled
    }
    fn is3p(&self) -> &bool {
        &self.is3p
    }
    fn is_local_player(&self) -> &bool {
        &self.is_local_player
    }
    fn force_low_lod(&self) -> &bool {
        &self.force_low_lod
    }
}

impl super::entity::EntityDataTrait for ViewQueryEntityData {
}

impl super::entity::GameObjectDataTrait for ViewQueryEntityData {
}

impl super::core::DataBusPeerTrait for ViewQueryEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for ViewQueryEntityData {
}

impl super::core::DataContainerTrait for ViewQueryEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static VIEWQUERYENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ViewQueryEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ViewQueryEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AnglePenalty",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ViewQueryEntityData, angle_penalty),
            },
            FieldInfoData {
                name: "ViewAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ViewQueryEntityData, view_angle),
            },
            FieldInfoData {
                name: "ViewDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ViewQueryEntityData, view_distance),
            },
            FieldInfoData {
                name: "KeepLowPrioDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ViewQueryEntityData, keep_low_prio_distance),
            },
            FieldInfoData {
                name: "SetLowPrioDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ViewQueryEntityData, set_low_prio_distance),
            },
            FieldInfoData {
                name: "Radius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ViewQueryEntityData, radius),
            },
            FieldInfoData {
                name: "InnerRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ViewQueryEntityData, inner_radius),
            },
            FieldInfoData {
                name: "LodDistanceForUnprioritizedCharacters",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ViewQueryEntityData, lod_distance_for_unprioritized_characters),
            },
            FieldInfoData {
                name: "LodDistanceForLocalShadow",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ViewQueryEntityData, lod_distance_for_local_shadow),
            },
            FieldInfoData {
                name: "ForcedLowLodDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ViewQueryEntityData, forced_low_lod_distance),
            },
            FieldInfoData {
                name: "MaxLodDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ViewQueryEntityData, max_lod_distance),
            },
            FieldInfoData {
                name: "MaxImprovementPerSecond",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ViewQueryEntityData, max_improvement_per_second),
            },
            FieldInfoData {
                name: "AlwaysEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ViewQueryEntityData, always_enabled),
            },
            FieldInfoData {
                name: "Is3p",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ViewQueryEntityData, is3p),
            },
            FieldInfoData {
                name: "IsLocalPlayer",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ViewQueryEntityData, is_local_player),
            },
            FieldInfoData {
                name: "ForceLowLod",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ViewQueryEntityData, force_low_lod),
            },
        ],
    }),
    array_type: Some(VIEWQUERYENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ViewQueryEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VIEWQUERYENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VIEWQUERYENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ViewQueryEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("ViewQueryEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TransformQueryEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub entity_type: Option<Arc<Mutex<dyn super::dice_commons_shared::EntityTransformLinkDataTrait>>>,
    pub query_type: TransformQueryType,
    pub query_from_index: i32,
    pub always_enabled: bool,
    pub input: QueryEntityResult,
    pub send_output_on_receive_input: bool,
}

pub trait TransformQueryEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn entity_type(&self) -> &Option<Arc<Mutex<dyn super::dice_commons_shared::EntityTransformLinkDataTrait>>>;
    fn query_type(&self) -> &TransformQueryType;
    fn query_from_index(&self) -> &i32;
    fn always_enabled(&self) -> &bool;
    fn input(&self) -> &QueryEntityResult;
    fn send_output_on_receive_input(&self) -> &bool;
}

impl TransformQueryEntityDataTrait for TransformQueryEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn entity_type(&self) -> &Option<Arc<Mutex<dyn super::dice_commons_shared::EntityTransformLinkDataTrait>>> {
        &self.entity_type
    }
    fn query_type(&self) -> &TransformQueryType {
        &self.query_type
    }
    fn query_from_index(&self) -> &i32 {
        &self.query_from_index
    }
    fn always_enabled(&self) -> &bool {
        &self.always_enabled
    }
    fn input(&self) -> &QueryEntityResult {
        &self.input
    }
    fn send_output_on_receive_input(&self) -> &bool {
        &self.send_output_on_receive_input
    }
}

impl super::entity::EntityDataTrait for TransformQueryEntityData {
}

impl super::entity::GameObjectDataTrait for TransformQueryEntityData {
}

impl super::core::DataBusPeerTrait for TransformQueryEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for TransformQueryEntityData {
}

impl super::core::DataContainerTrait for TransformQueryEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static TRANSFORMQUERYENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformQueryEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformQueryEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(TransformQueryEntityData, realm),
            },
            FieldInfoData {
                name: "EntityType",
                flags: MemberInfoFlags::new(0),
                field_type: "EntityTransformLinkData",
                rust_offset: offset_of!(TransformQueryEntityData, entity_type),
            },
            FieldInfoData {
                name: "QueryType",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformQueryType",
                rust_offset: offset_of!(TransformQueryEntityData, query_type),
            },
            FieldInfoData {
                name: "QueryFromIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(TransformQueryEntityData, query_from_index),
            },
            FieldInfoData {
                name: "AlwaysEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TransformQueryEntityData, always_enabled),
            },
            FieldInfoData {
                name: "Input",
                flags: MemberInfoFlags::new(0),
                field_type: "QueryEntityResult",
                rust_offset: offset_of!(TransformQueryEntityData, input),
            },
            FieldInfoData {
                name: "SendOutputOnReceiveInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TransformQueryEntityData, send_output_on_receive_input),
            },
        ],
    }),
    array_type: Some(TRANSFORMQUERYENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TransformQueryEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMQUERYENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static TRANSFORMQUERYENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformQueryEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("TransformQueryEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum TransformQueryType {
    #[default]
    TQT_LocalTransform = 0,
    TQT_WorldTransform = 1,
}

pub static TRANSFORMQUERYTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformQueryType",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(TRANSFORMQUERYTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for TransformQueryType {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMQUERYTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static TRANSFORMQUERYTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformQueryType-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("TransformQueryType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TerrainRayCastEntityData {
    pub _glacier_base: RayCastEntityData,
}

pub trait TerrainRayCastEntityDataTrait: RayCastEntityDataTrait {
}

impl TerrainRayCastEntityDataTrait for TerrainRayCastEntityData {
}

impl RayCastEntityDataTrait for TerrainRayCastEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn start(&self) -> &super::core::Vec3 {
        self._glacier_base.start()
    }
    fn stop(&self) -> &super::core::Vec3 {
        self._glacier_base.stop()
    }
    fn radius(&self) -> &f32 {
        self._glacier_base.radius()
    }
    fn use_detailed_collision(&self) -> &bool {
        self._glacier_base.use_detailed_collision()
    }
    fn see_through(&self) -> &bool {
        self._glacier_base.see_through()
    }
    fn penetrable(&self) -> &bool {
        self._glacier_base.penetrable()
    }
    fn include_terrain(&self) -> &bool {
        self._glacier_base.include_terrain()
    }
    fn include_water(&self) -> &bool {
        self._glacier_base.include_water()
    }
    fn include_characters(&self) -> &bool {
        self._glacier_base.include_characters()
    }
    fn include_vehicles(&self) -> &bool {
        self._glacier_base.include_vehicles()
    }
    fn include_ragdolls(&self) -> &bool {
        self._glacier_base.include_ragdolls()
    }
    fn include_fixed(&self) -> &bool {
        self._glacier_base.include_fixed()
    }
    fn include_keyframed(&self) -> &bool {
        self._glacier_base.include_keyframed()
    }
    fn include_dynamic(&self) -> &bool {
        self._glacier_base.include_dynamic()
    }
    fn r#async(&self) -> &bool {
        self._glacier_base.r#async()
    }
    fn exclude_attached_controllable(&self) -> &bool {
        self._glacier_base.exclude_attached_controllable()
    }
    fn output_filter(&self) -> &QueryEntityFilter {
        self._glacier_base.output_filter()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
}

impl super::entity::EntityDataTrait for TerrainRayCastEntityData {
}

impl super::entity::GameObjectDataTrait for TerrainRayCastEntityData {
}

impl super::core::DataBusPeerTrait for TerrainRayCastEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for TerrainRayCastEntityData {
}

impl super::core::DataContainerTrait for TerrainRayCastEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static TERRAINRAYCASTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TerrainRayCastEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(RAYCASTENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TerrainRayCastEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(TERRAINRAYCASTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for TerrainRayCastEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TERRAINRAYCASTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static TERRAINRAYCASTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TerrainRayCastEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("TerrainRayCastEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SphereQueryEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub position: super::core::Vec3,
    pub radius: f32,
    pub latency: f32,
    pub always_enabled: bool,
    pub trigger_on_change: bool,
    pub filtered_types: QueryEntityFilter,
    pub debug_data: SphereQueryDebugData,
}

pub trait SphereQueryEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn position(&self) -> &super::core::Vec3;
    fn radius(&self) -> &f32;
    fn latency(&self) -> &f32;
    fn always_enabled(&self) -> &bool;
    fn trigger_on_change(&self) -> &bool;
    fn filtered_types(&self) -> &QueryEntityFilter;
    fn debug_data(&self) -> &SphereQueryDebugData;
}

impl SphereQueryEntityDataTrait for SphereQueryEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn position(&self) -> &super::core::Vec3 {
        &self.position
    }
    fn radius(&self) -> &f32 {
        &self.radius
    }
    fn latency(&self) -> &f32 {
        &self.latency
    }
    fn always_enabled(&self) -> &bool {
        &self.always_enabled
    }
    fn trigger_on_change(&self) -> &bool {
        &self.trigger_on_change
    }
    fn filtered_types(&self) -> &QueryEntityFilter {
        &self.filtered_types
    }
    fn debug_data(&self) -> &SphereQueryDebugData {
        &self.debug_data
    }
}

impl super::entity::EntityDataTrait for SphereQueryEntityData {
}

impl super::entity::GameObjectDataTrait for SphereQueryEntityData {
}

impl super::core::DataBusPeerTrait for SphereQueryEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for SphereQueryEntityData {
}

impl super::core::DataContainerTrait for SphereQueryEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SPHEREQUERYENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SphereQueryEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SphereQueryEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(SphereQueryEntityData, realm),
            },
            FieldInfoData {
                name: "Position",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SphereQueryEntityData, position),
            },
            FieldInfoData {
                name: "Radius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SphereQueryEntityData, radius),
            },
            FieldInfoData {
                name: "Latency",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SphereQueryEntityData, latency),
            },
            FieldInfoData {
                name: "AlwaysEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SphereQueryEntityData, always_enabled),
            },
            FieldInfoData {
                name: "TriggerOnChange",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SphereQueryEntityData, trigger_on_change),
            },
            FieldInfoData {
                name: "FilteredTypes",
                flags: MemberInfoFlags::new(0),
                field_type: "QueryEntityFilter",
                rust_offset: offset_of!(SphereQueryEntityData, filtered_types),
            },
            FieldInfoData {
                name: "DebugData",
                flags: MemberInfoFlags::new(0),
                field_type: "SphereQueryDebugData",
                rust_offset: offset_of!(SphereQueryEntityData, debug_data),
            },
        ],
    }),
    array_type: Some(SPHEREQUERYENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SphereQueryEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SPHEREQUERYENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SPHEREQUERYENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SphereQueryEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("SphereQueryEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SphereQueryDebugData {
    pub debug_query: bool,
    pub debug_draw_color: super::core::Vec4,
    pub debug_life_time: f32,
}

pub trait SphereQueryDebugDataTrait: TypeObject {
    fn debug_query(&self) -> &bool;
    fn debug_draw_color(&self) -> &super::core::Vec4;
    fn debug_life_time(&self) -> &f32;
}

impl SphereQueryDebugDataTrait for SphereQueryDebugData {
    fn debug_query(&self) -> &bool {
        &self.debug_query
    }
    fn debug_draw_color(&self) -> &super::core::Vec4 {
        &self.debug_draw_color
    }
    fn debug_life_time(&self) -> &f32 {
        &self.debug_life_time
    }
}

pub static SPHEREQUERYDEBUGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SphereQueryDebugData",
    flags: MemberInfoFlags::new(36937),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SphereQueryDebugData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DebugQuery",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SphereQueryDebugData, debug_query),
            },
            FieldInfoData {
                name: "DebugDrawColor",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(SphereQueryDebugData, debug_draw_color),
            },
            FieldInfoData {
                name: "DebugLifeTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SphereQueryDebugData, debug_life_time),
            },
        ],
    }),
    array_type: Some(SPHEREQUERYDEBUGDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SphereQueryDebugData {
    fn type_info(&self) -> &'static TypeInfo {
        SPHEREQUERYDEBUGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SPHEREQUERYDEBUGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SphereQueryDebugData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("SphereQueryDebugData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RemoteStateQueryFilterEntityData {
    pub _glacier_base: SimpleStateEntityBaseData,
    pub realm: super::core::Realm,
    pub delay_update: bool,
    pub entities_to_filter: QueryEntityResult,
}

pub trait RemoteStateQueryFilterEntityDataTrait: SimpleStateEntityBaseDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn delay_update(&self) -> &bool;
    fn entities_to_filter(&self) -> &QueryEntityResult;
}

impl RemoteStateQueryFilterEntityDataTrait for RemoteStateQueryFilterEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn delay_update(&self) -> &bool {
        &self.delay_update
    }
    fn entities_to_filter(&self) -> &QueryEntityResult {
        &self.entities_to_filter
    }
}

impl SimpleStateEntityBaseDataTrait for RemoteStateQueryFilterEntityData {
    fn state_input_hash(&self) -> &i32 {
        self._glacier_base.state_input_hash()
    }
    fn state_output_hash(&self) -> &i32 {
        self._glacier_base.state_output_hash()
    }
    fn state(&self) -> &Option<Arc<Mutex<dyn SimpleStateDataTrait>>> {
        self._glacier_base.state()
    }
}

impl super::entity::EntityDataTrait for RemoteStateQueryFilterEntityData {
}

impl super::entity::GameObjectDataTrait for RemoteStateQueryFilterEntityData {
}

impl super::core::DataBusPeerTrait for RemoteStateQueryFilterEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for RemoteStateQueryFilterEntityData {
}

impl super::core::DataContainerTrait for RemoteStateQueryFilterEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static REMOTESTATEQUERYFILTERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RemoteStateQueryFilterEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SIMPLESTATEENTITYBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RemoteStateQueryFilterEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(RemoteStateQueryFilterEntityData, realm),
            },
            FieldInfoData {
                name: "DelayUpdate",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RemoteStateQueryFilterEntityData, delay_update),
            },
            FieldInfoData {
                name: "EntitiesToFilter",
                flags: MemberInfoFlags::new(0),
                field_type: "QueryEntityResult",
                rust_offset: offset_of!(RemoteStateQueryFilterEntityData, entities_to_filter),
            },
        ],
    }),
    array_type: Some(REMOTESTATEQUERYFILTERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RemoteStateQueryFilterEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        REMOTESTATEQUERYFILTERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static REMOTESTATEQUERYFILTERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RemoteStateQueryFilterEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("RemoteStateQueryFilterEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RemoteStateWriteEntityData {
    pub _glacier_base: SimpleStateEntityBaseData,
    pub realm: super::core::Realm,
    pub entities_to_set_state_on: QueryEntityResult,
}

pub trait RemoteStateWriteEntityDataTrait: SimpleStateEntityBaseDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn entities_to_set_state_on(&self) -> &QueryEntityResult;
}

impl RemoteStateWriteEntityDataTrait for RemoteStateWriteEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn entities_to_set_state_on(&self) -> &QueryEntityResult {
        &self.entities_to_set_state_on
    }
}

impl SimpleStateEntityBaseDataTrait for RemoteStateWriteEntityData {
    fn state_input_hash(&self) -> &i32 {
        self._glacier_base.state_input_hash()
    }
    fn state_output_hash(&self) -> &i32 {
        self._glacier_base.state_output_hash()
    }
    fn state(&self) -> &Option<Arc<Mutex<dyn SimpleStateDataTrait>>> {
        self._glacier_base.state()
    }
}

impl super::entity::EntityDataTrait for RemoteStateWriteEntityData {
}

impl super::entity::GameObjectDataTrait for RemoteStateWriteEntityData {
}

impl super::core::DataBusPeerTrait for RemoteStateWriteEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for RemoteStateWriteEntityData {
}

impl super::core::DataContainerTrait for RemoteStateWriteEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static REMOTESTATEWRITEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RemoteStateWriteEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SIMPLESTATEENTITYBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RemoteStateWriteEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(RemoteStateWriteEntityData, realm),
            },
            FieldInfoData {
                name: "EntitiesToSetStateOn",
                flags: MemberInfoFlags::new(0),
                field_type: "QueryEntityResult",
                rust_offset: offset_of!(RemoteStateWriteEntityData, entities_to_set_state_on),
            },
        ],
    }),
    array_type: Some(REMOTESTATEWRITEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RemoteStateWriteEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        REMOTESTATEWRITEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static REMOTESTATEWRITEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RemoteStateWriteEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("RemoteStateWriteEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RemoteStateReadEntityData {
    pub _glacier_base: SimpleStateEntityBaseData,
    pub realm: super::core::Realm,
    pub entities_to_query_state_from: QueryEntityResult,
}

pub trait RemoteStateReadEntityDataTrait: SimpleStateEntityBaseDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn entities_to_query_state_from(&self) -> &QueryEntityResult;
}

impl RemoteStateReadEntityDataTrait for RemoteStateReadEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn entities_to_query_state_from(&self) -> &QueryEntityResult {
        &self.entities_to_query_state_from
    }
}

impl SimpleStateEntityBaseDataTrait for RemoteStateReadEntityData {
    fn state_input_hash(&self) -> &i32 {
        self._glacier_base.state_input_hash()
    }
    fn state_output_hash(&self) -> &i32 {
        self._glacier_base.state_output_hash()
    }
    fn state(&self) -> &Option<Arc<Mutex<dyn SimpleStateDataTrait>>> {
        self._glacier_base.state()
    }
}

impl super::entity::EntityDataTrait for RemoteStateReadEntityData {
}

impl super::entity::GameObjectDataTrait for RemoteStateReadEntityData {
}

impl super::core::DataBusPeerTrait for RemoteStateReadEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for RemoteStateReadEntityData {
}

impl super::core::DataContainerTrait for RemoteStateReadEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static REMOTESTATEREADENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RemoteStateReadEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SIMPLESTATEENTITYBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RemoteStateReadEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(RemoteStateReadEntityData, realm),
            },
            FieldInfoData {
                name: "EntitiesToQueryStateFrom",
                flags: MemberInfoFlags::new(0),
                field_type: "QueryEntityResult",
                rust_offset: offset_of!(RemoteStateReadEntityData, entities_to_query_state_from),
            },
        ],
    }),
    array_type: Some(REMOTESTATEREADENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RemoteStateReadEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        REMOTESTATEREADENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static REMOTESTATEREADENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RemoteStateReadEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("RemoteStateReadEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RemoteStateEntityData {
    pub _glacier_base: SimpleStateEntityBaseData,
    pub realm: super::core::Realm,
    pub entities_to_set_state_on: QueryEntityResult,
    pub entities_to_query_state_from: QueryEntityResult,
}

pub trait RemoteStateEntityDataTrait: SimpleStateEntityBaseDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn entities_to_set_state_on(&self) -> &QueryEntityResult;
    fn entities_to_query_state_from(&self) -> &QueryEntityResult;
}

impl RemoteStateEntityDataTrait for RemoteStateEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn entities_to_set_state_on(&self) -> &QueryEntityResult {
        &self.entities_to_set_state_on
    }
    fn entities_to_query_state_from(&self) -> &QueryEntityResult {
        &self.entities_to_query_state_from
    }
}

impl SimpleStateEntityBaseDataTrait for RemoteStateEntityData {
    fn state_input_hash(&self) -> &i32 {
        self._glacier_base.state_input_hash()
    }
    fn state_output_hash(&self) -> &i32 {
        self._glacier_base.state_output_hash()
    }
    fn state(&self) -> &Option<Arc<Mutex<dyn SimpleStateDataTrait>>> {
        self._glacier_base.state()
    }
}

impl super::entity::EntityDataTrait for RemoteStateEntityData {
}

impl super::entity::GameObjectDataTrait for RemoteStateEntityData {
}

impl super::core::DataBusPeerTrait for RemoteStateEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for RemoteStateEntityData {
}

impl super::core::DataContainerTrait for RemoteStateEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static REMOTESTATEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RemoteStateEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SIMPLESTATEENTITYBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RemoteStateEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(RemoteStateEntityData, realm),
            },
            FieldInfoData {
                name: "EntitiesToSetStateOn",
                flags: MemberInfoFlags::new(0),
                field_type: "QueryEntityResult",
                rust_offset: offset_of!(RemoteStateEntityData, entities_to_set_state_on),
            },
            FieldInfoData {
                name: "EntitiesToQueryStateFrom",
                flags: MemberInfoFlags::new(0),
                field_type: "QueryEntityResult",
                rust_offset: offset_of!(RemoteStateEntityData, entities_to_query_state_from),
            },
        ],
    }),
    array_type: Some(REMOTESTATEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RemoteStateEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        REMOTESTATEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static REMOTESTATEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RemoteStateEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("RemoteStateEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SimpleStateWriteEntityData {
    pub _glacier_base: SimpleStateEntityBaseData,
    pub realm: super::core::Realm,
    pub trigger_on_property_changed: bool,
}

pub trait SimpleStateWriteEntityDataTrait: SimpleStateEntityBaseDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn trigger_on_property_changed(&self) -> &bool;
}

impl SimpleStateWriteEntityDataTrait for SimpleStateWriteEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn trigger_on_property_changed(&self) -> &bool {
        &self.trigger_on_property_changed
    }
}

impl SimpleStateEntityBaseDataTrait for SimpleStateWriteEntityData {
    fn state_input_hash(&self) -> &i32 {
        self._glacier_base.state_input_hash()
    }
    fn state_output_hash(&self) -> &i32 {
        self._glacier_base.state_output_hash()
    }
    fn state(&self) -> &Option<Arc<Mutex<dyn SimpleStateDataTrait>>> {
        self._glacier_base.state()
    }
}

impl super::entity::EntityDataTrait for SimpleStateWriteEntityData {
}

impl super::entity::GameObjectDataTrait for SimpleStateWriteEntityData {
}

impl super::core::DataBusPeerTrait for SimpleStateWriteEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for SimpleStateWriteEntityData {
}

impl super::core::DataContainerTrait for SimpleStateWriteEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SIMPLESTATEWRITEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleStateWriteEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SIMPLESTATEENTITYBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SimpleStateWriteEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(SimpleStateWriteEntityData, realm),
            },
            FieldInfoData {
                name: "TriggerOnPropertyChanged",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SimpleStateWriteEntityData, trigger_on_property_changed),
            },
        ],
    }),
    array_type: Some(SIMPLESTATEWRITEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SimpleStateWriteEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SIMPLESTATEWRITEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SIMPLESTATEWRITEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleStateWriteEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("SimpleStateWriteEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SimpleStateReadEntityData {
    pub _glacier_base: SimpleStateEntityBaseData,
    pub realm: super::core::Realm,
}

pub trait SimpleStateReadEntityDataTrait: SimpleStateEntityBaseDataTrait {
    fn realm(&self) -> &super::core::Realm;
}

impl SimpleStateReadEntityDataTrait for SimpleStateReadEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
}

impl SimpleStateEntityBaseDataTrait for SimpleStateReadEntityData {
    fn state_input_hash(&self) -> &i32 {
        self._glacier_base.state_input_hash()
    }
    fn state_output_hash(&self) -> &i32 {
        self._glacier_base.state_output_hash()
    }
    fn state(&self) -> &Option<Arc<Mutex<dyn SimpleStateDataTrait>>> {
        self._glacier_base.state()
    }
}

impl super::entity::EntityDataTrait for SimpleStateReadEntityData {
}

impl super::entity::GameObjectDataTrait for SimpleStateReadEntityData {
}

impl super::core::DataBusPeerTrait for SimpleStateReadEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for SimpleStateReadEntityData {
}

impl super::core::DataContainerTrait for SimpleStateReadEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SIMPLESTATEREADENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleStateReadEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SIMPLESTATEENTITYBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SimpleStateReadEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(SimpleStateReadEntityData, realm),
            },
        ],
    }),
    array_type: Some(SIMPLESTATEREADENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SimpleStateReadEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SIMPLESTATEREADENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SIMPLESTATEREADENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleStateReadEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("SimpleStateReadEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SimpleStateEntityData {
    pub _glacier_base: SimpleStateEntityBaseData,
    pub realm: super::core::Realm,
    pub initialize_game_state: bool,
    pub trigger_on_property_changed: bool,
}

pub trait SimpleStateEntityDataTrait: SimpleStateEntityBaseDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn initialize_game_state(&self) -> &bool;
    fn trigger_on_property_changed(&self) -> &bool;
}

impl SimpleStateEntityDataTrait for SimpleStateEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn initialize_game_state(&self) -> &bool {
        &self.initialize_game_state
    }
    fn trigger_on_property_changed(&self) -> &bool {
        &self.trigger_on_property_changed
    }
}

impl SimpleStateEntityBaseDataTrait for SimpleStateEntityData {
    fn state_input_hash(&self) -> &i32 {
        self._glacier_base.state_input_hash()
    }
    fn state_output_hash(&self) -> &i32 {
        self._glacier_base.state_output_hash()
    }
    fn state(&self) -> &Option<Arc<Mutex<dyn SimpleStateDataTrait>>> {
        self._glacier_base.state()
    }
}

impl super::entity::EntityDataTrait for SimpleStateEntityData {
}

impl super::entity::GameObjectDataTrait for SimpleStateEntityData {
}

impl super::core::DataBusPeerTrait for SimpleStateEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for SimpleStateEntityData {
}

impl super::core::DataContainerTrait for SimpleStateEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SIMPLESTATEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleStateEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SIMPLESTATEENTITYBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SimpleStateEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(SimpleStateEntityData, realm),
            },
            FieldInfoData {
                name: "InitializeGameState",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SimpleStateEntityData, initialize_game_state),
            },
            FieldInfoData {
                name: "TriggerOnPropertyChanged",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SimpleStateEntityData, trigger_on_property_changed),
            },
        ],
    }),
    array_type: Some(SIMPLESTATEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SimpleStateEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SIMPLESTATEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SIMPLESTATEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleStateEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("SimpleStateEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SimpleStateEntityBaseData {
    pub _glacier_base: super::entity::EntityData,
    pub state_input_hash: i32,
    pub state_output_hash: i32,
    pub state: Option<Arc<Mutex<dyn SimpleStateDataTrait>>>,
}

pub trait SimpleStateEntityBaseDataTrait: super::entity::EntityDataTrait {
    fn state_input_hash(&self) -> &i32;
    fn state_output_hash(&self) -> &i32;
    fn state(&self) -> &Option<Arc<Mutex<dyn SimpleStateDataTrait>>>;
}

impl SimpleStateEntityBaseDataTrait for SimpleStateEntityBaseData {
    fn state_input_hash(&self) -> &i32 {
        &self.state_input_hash
    }
    fn state_output_hash(&self) -> &i32 {
        &self.state_output_hash
    }
    fn state(&self) -> &Option<Arc<Mutex<dyn SimpleStateDataTrait>>> {
        &self.state
    }
}

impl super::entity::EntityDataTrait for SimpleStateEntityBaseData {
}

impl super::entity::GameObjectDataTrait for SimpleStateEntityBaseData {
}

impl super::core::DataBusPeerTrait for SimpleStateEntityBaseData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for SimpleStateEntityBaseData {
}

impl super::core::DataContainerTrait for SimpleStateEntityBaseData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SIMPLESTATEENTITYBASEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleStateEntityBaseData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SimpleStateEntityBaseData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "StateInputHash",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SimpleStateEntityBaseData, state_input_hash),
            },
            FieldInfoData {
                name: "StateOutputHash",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SimpleStateEntityBaseData, state_output_hash),
            },
            FieldInfoData {
                name: "State",
                flags: MemberInfoFlags::new(0),
                field_type: "SimpleStateData",
                rust_offset: offset_of!(SimpleStateEntityBaseData, state),
            },
        ],
    }),
    array_type: Some(SIMPLESTATEENTITYBASEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SimpleStateEntityBaseData {
    fn type_info(&self) -> &'static TypeInfo {
        SIMPLESTATEENTITYBASEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SIMPLESTATEENTITYBASEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleStateEntityBaseData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("SimpleStateEntityBaseData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WriteSimpleFloatStateData {
    pub _glacier_base: WriteSimpleStateData,
    pub value: f32,
}

pub trait WriteSimpleFloatStateDataTrait: WriteSimpleStateDataTrait {
    fn value(&self) -> &f32;
}

impl WriteSimpleFloatStateDataTrait for WriteSimpleFloatStateData {
    fn value(&self) -> &f32 {
        &self.value
    }
}

impl WriteSimpleStateDataTrait for WriteSimpleFloatStateData {
    fn target_simple_state_data(&self) -> &Option<Arc<Mutex<dyn SimpleStateDataTrait>>> {
        self._glacier_base.target_simple_state_data()
    }
}

impl super::core::DataContainerTrait for WriteSimpleFloatStateData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static WRITESIMPLEFLOATSTATEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteSimpleFloatStateData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(WRITESIMPLESTATEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WriteSimpleFloatStateData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WriteSimpleFloatStateData, value),
            },
        ],
    }),
    array_type: Some(WRITESIMPLEFLOATSTATEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WriteSimpleFloatStateData {
    fn type_info(&self) -> &'static TypeInfo {
        WRITESIMPLEFLOATSTATEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static WRITESIMPLEFLOATSTATEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteSimpleFloatStateData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("WriteSimpleFloatStateData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WriteSimpleIntStateData {
    pub _glacier_base: WriteSimpleStateData,
    pub value: i32,
}

pub trait WriteSimpleIntStateDataTrait: WriteSimpleStateDataTrait {
    fn value(&self) -> &i32;
}

impl WriteSimpleIntStateDataTrait for WriteSimpleIntStateData {
    fn value(&self) -> &i32 {
        &self.value
    }
}

impl WriteSimpleStateDataTrait for WriteSimpleIntStateData {
    fn target_simple_state_data(&self) -> &Option<Arc<Mutex<dyn SimpleStateDataTrait>>> {
        self._glacier_base.target_simple_state_data()
    }
}

impl super::core::DataContainerTrait for WriteSimpleIntStateData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static WRITESIMPLEINTSTATEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteSimpleIntStateData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(WRITESIMPLESTATEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WriteSimpleIntStateData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(WriteSimpleIntStateData, value),
            },
        ],
    }),
    array_type: Some(WRITESIMPLEINTSTATEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WriteSimpleIntStateData {
    fn type_info(&self) -> &'static TypeInfo {
        WRITESIMPLEINTSTATEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static WRITESIMPLEINTSTATEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteSimpleIntStateData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("WriteSimpleIntStateData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WriteSimpleTransformStateData {
    pub _glacier_base: WriteSimpleStateData,
    pub value: super::core::LinearTransform,
}

pub trait WriteSimpleTransformStateDataTrait: WriteSimpleStateDataTrait {
    fn value(&self) -> &super::core::LinearTransform;
}

impl WriteSimpleTransformStateDataTrait for WriteSimpleTransformStateData {
    fn value(&self) -> &super::core::LinearTransform {
        &self.value
    }
}

impl WriteSimpleStateDataTrait for WriteSimpleTransformStateData {
    fn target_simple_state_data(&self) -> &Option<Arc<Mutex<dyn SimpleStateDataTrait>>> {
        self._glacier_base.target_simple_state_data()
    }
}

impl super::core::DataContainerTrait for WriteSimpleTransformStateData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static WRITESIMPLETRANSFORMSTATEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteSimpleTransformStateData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(WRITESIMPLESTATEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WriteSimpleTransformStateData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(WriteSimpleTransformStateData, value),
            },
        ],
    }),
    array_type: Some(WRITESIMPLETRANSFORMSTATEDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for WriteSimpleTransformStateData {
    fn type_info(&self) -> &'static TypeInfo {
        WRITESIMPLETRANSFORMSTATEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static WRITESIMPLETRANSFORMSTATEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteSimpleTransformStateData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("WriteSimpleTransformStateData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WriteSimpleBoolStateData {
    pub _glacier_base: WriteSimpleStateData,
    pub value: bool,
}

pub trait WriteSimpleBoolStateDataTrait: WriteSimpleStateDataTrait {
    fn value(&self) -> &bool;
}

impl WriteSimpleBoolStateDataTrait for WriteSimpleBoolStateData {
    fn value(&self) -> &bool {
        &self.value
    }
}

impl WriteSimpleStateDataTrait for WriteSimpleBoolStateData {
    fn target_simple_state_data(&self) -> &Option<Arc<Mutex<dyn SimpleStateDataTrait>>> {
        self._glacier_base.target_simple_state_data()
    }
}

impl super::core::DataContainerTrait for WriteSimpleBoolStateData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static WRITESIMPLEBOOLSTATEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteSimpleBoolStateData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(WRITESIMPLESTATEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WriteSimpleBoolStateData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WriteSimpleBoolStateData, value),
            },
        ],
    }),
    array_type: Some(WRITESIMPLEBOOLSTATEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WriteSimpleBoolStateData {
    fn type_info(&self) -> &'static TypeInfo {
        WRITESIMPLEBOOLSTATEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static WRITESIMPLEBOOLSTATEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteSimpleBoolStateData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("WriteSimpleBoolStateData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WriteSimpleStateData {
    pub _glacier_base: super::core::DataContainer,
    pub target_simple_state_data: Option<Arc<Mutex<dyn SimpleStateDataTrait>>>,
}

pub trait WriteSimpleStateDataTrait: super::core::DataContainerTrait {
    fn target_simple_state_data(&self) -> &Option<Arc<Mutex<dyn SimpleStateDataTrait>>>;
}

impl WriteSimpleStateDataTrait for WriteSimpleStateData {
    fn target_simple_state_data(&self) -> &Option<Arc<Mutex<dyn SimpleStateDataTrait>>> {
        &self.target_simple_state_data
    }
}

impl super::core::DataContainerTrait for WriteSimpleStateData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static WRITESIMPLESTATEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteSimpleStateData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WriteSimpleStateData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "TargetSimpleStateData",
                flags: MemberInfoFlags::new(0),
                field_type: "SimpleStateData",
                rust_offset: offset_of!(WriteSimpleStateData, target_simple_state_data),
            },
        ],
    }),
    array_type: Some(WRITESIMPLESTATEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WriteSimpleStateData {
    fn type_info(&self) -> &'static TypeInfo {
        WRITESIMPLESTATEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static WRITESIMPLESTATEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteSimpleStateData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("WriteSimpleStateData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SimpleEventStateData {
    pub _glacier_base: SimpleStateData,
    pub default_value: u32,
}

pub trait SimpleEventStateDataTrait: SimpleStateDataTrait {
    fn default_value(&self) -> &u32;
}

impl SimpleEventStateDataTrait for SimpleEventStateData {
    fn default_value(&self) -> &u32 {
        &self.default_value
    }
}

impl SimpleStateDataTrait for SimpleEventStateData {
    fn key(&self) -> &glacier_util::guid::Guid {
        self._glacier_base.key()
    }
    fn access_mode(&self) -> &SimpleStateAccessMode {
        self._glacier_base.access_mode()
    }
    fn is_networked(&self) -> &bool {
        self._glacier_base.is_networked()
    }
}

impl super::core::DataContainerTrait for SimpleEventStateData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SIMPLEEVENTSTATEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleEventStateData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SIMPLESTATEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SimpleEventStateData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DefaultValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(SimpleEventStateData, default_value),
            },
        ],
    }),
    array_type: Some(SIMPLEEVENTSTATEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SimpleEventStateData {
    fn type_info(&self) -> &'static TypeInfo {
        SIMPLEEVENTSTATEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SIMPLEEVENTSTATEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleEventStateData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("SimpleEventStateData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SimpleVec3StateData {
    pub _glacier_base: SimpleStateData,
    pub default_value: super::core::Vec3,
}

pub trait SimpleVec3StateDataTrait: SimpleStateDataTrait {
    fn default_value(&self) -> &super::core::Vec3;
}

impl SimpleVec3StateDataTrait for SimpleVec3StateData {
    fn default_value(&self) -> &super::core::Vec3 {
        &self.default_value
    }
}

impl SimpleStateDataTrait for SimpleVec3StateData {
    fn key(&self) -> &glacier_util::guid::Guid {
        self._glacier_base.key()
    }
    fn access_mode(&self) -> &SimpleStateAccessMode {
        self._glacier_base.access_mode()
    }
    fn is_networked(&self) -> &bool {
        self._glacier_base.is_networked()
    }
}

impl super::core::DataContainerTrait for SimpleVec3StateData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SIMPLEVEC3STATEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleVec3StateData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SIMPLESTATEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SimpleVec3StateData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DefaultValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SimpleVec3StateData, default_value),
            },
        ],
    }),
    array_type: Some(SIMPLEVEC3STATEDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SimpleVec3StateData {
    fn type_info(&self) -> &'static TypeInfo {
        SIMPLEVEC3STATEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SIMPLEVEC3STATEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleVec3StateData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("SimpleVec3StateData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SimpleFloatStateData {
    pub _glacier_base: SimpleStateData,
    pub default_value: f32,
}

pub trait SimpleFloatStateDataTrait: SimpleStateDataTrait {
    fn default_value(&self) -> &f32;
}

impl SimpleFloatStateDataTrait for SimpleFloatStateData {
    fn default_value(&self) -> &f32 {
        &self.default_value
    }
}

impl SimpleStateDataTrait for SimpleFloatStateData {
    fn key(&self) -> &glacier_util::guid::Guid {
        self._glacier_base.key()
    }
    fn access_mode(&self) -> &SimpleStateAccessMode {
        self._glacier_base.access_mode()
    }
    fn is_networked(&self) -> &bool {
        self._glacier_base.is_networked()
    }
}

impl super::core::DataContainerTrait for SimpleFloatStateData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SIMPLEFLOATSTATEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleFloatStateData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SIMPLESTATEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SimpleFloatStateData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DefaultValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SimpleFloatStateData, default_value),
            },
        ],
    }),
    array_type: Some(SIMPLEFLOATSTATEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SimpleFloatStateData {
    fn type_info(&self) -> &'static TypeInfo {
        SIMPLEFLOATSTATEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SIMPLEFLOATSTATEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleFloatStateData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("SimpleFloatStateData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SimpleIntStateData {
    pub _glacier_base: SimpleStateData,
    pub default_value: i32,
}

pub trait SimpleIntStateDataTrait: SimpleStateDataTrait {
    fn default_value(&self) -> &i32;
}

impl SimpleIntStateDataTrait for SimpleIntStateData {
    fn default_value(&self) -> &i32 {
        &self.default_value
    }
}

impl SimpleStateDataTrait for SimpleIntStateData {
    fn key(&self) -> &glacier_util::guid::Guid {
        self._glacier_base.key()
    }
    fn access_mode(&self) -> &SimpleStateAccessMode {
        self._glacier_base.access_mode()
    }
    fn is_networked(&self) -> &bool {
        self._glacier_base.is_networked()
    }
}

impl super::core::DataContainerTrait for SimpleIntStateData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SIMPLEINTSTATEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleIntStateData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SIMPLESTATEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SimpleIntStateData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DefaultValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SimpleIntStateData, default_value),
            },
        ],
    }),
    array_type: Some(SIMPLEINTSTATEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SimpleIntStateData {
    fn type_info(&self) -> &'static TypeInfo {
        SIMPLEINTSTATEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SIMPLEINTSTATEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleIntStateData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("SimpleIntStateData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SimpleTransformStateData {
    pub _glacier_base: SimpleStateData,
    pub default_value: super::core::LinearTransform,
}

pub trait SimpleTransformStateDataTrait: SimpleStateDataTrait {
    fn default_value(&self) -> &super::core::LinearTransform;
}

impl SimpleTransformStateDataTrait for SimpleTransformStateData {
    fn default_value(&self) -> &super::core::LinearTransform {
        &self.default_value
    }
}

impl SimpleStateDataTrait for SimpleTransformStateData {
    fn key(&self) -> &glacier_util::guid::Guid {
        self._glacier_base.key()
    }
    fn access_mode(&self) -> &SimpleStateAccessMode {
        self._glacier_base.access_mode()
    }
    fn is_networked(&self) -> &bool {
        self._glacier_base.is_networked()
    }
}

impl super::core::DataContainerTrait for SimpleTransformStateData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SIMPLETRANSFORMSTATEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleTransformStateData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SIMPLESTATEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SimpleTransformStateData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DefaultValue",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(SimpleTransformStateData, default_value),
            },
        ],
    }),
    array_type: Some(SIMPLETRANSFORMSTATEDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SimpleTransformStateData {
    fn type_info(&self) -> &'static TypeInfo {
        SIMPLETRANSFORMSTATEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SIMPLETRANSFORMSTATEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleTransformStateData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("SimpleTransformStateData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SimpleBoolStateData {
    pub _glacier_base: SimpleStateData,
    pub default_value: bool,
}

pub trait SimpleBoolStateDataTrait: SimpleStateDataTrait {
    fn default_value(&self) -> &bool;
}

impl SimpleBoolStateDataTrait for SimpleBoolStateData {
    fn default_value(&self) -> &bool {
        &self.default_value
    }
}

impl SimpleStateDataTrait for SimpleBoolStateData {
    fn key(&self) -> &glacier_util::guid::Guid {
        self._glacier_base.key()
    }
    fn access_mode(&self) -> &SimpleStateAccessMode {
        self._glacier_base.access_mode()
    }
    fn is_networked(&self) -> &bool {
        self._glacier_base.is_networked()
    }
}

impl super::core::DataContainerTrait for SimpleBoolStateData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SIMPLEBOOLSTATEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleBoolStateData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SIMPLESTATEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SimpleBoolStateData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DefaultValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SimpleBoolStateData, default_value),
            },
        ],
    }),
    array_type: Some(SIMPLEBOOLSTATEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SimpleBoolStateData {
    fn type_info(&self) -> &'static TypeInfo {
        SIMPLEBOOLSTATEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SIMPLEBOOLSTATEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleBoolStateData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("SimpleBoolStateData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SimpleStateData {
    pub _glacier_base: super::core::DataContainer,
    pub key: glacier_util::guid::Guid,
    pub access_mode: SimpleStateAccessMode,
    pub is_networked: bool,
}

pub trait SimpleStateDataTrait: super::core::DataContainerTrait {
    fn key(&self) -> &glacier_util::guid::Guid;
    fn access_mode(&self) -> &SimpleStateAccessMode;
    fn is_networked(&self) -> &bool;
}

impl SimpleStateDataTrait for SimpleStateData {
    fn key(&self) -> &glacier_util::guid::Guid {
        &self.key
    }
    fn access_mode(&self) -> &SimpleStateAccessMode {
        &self.access_mode
    }
    fn is_networked(&self) -> &bool {
        &self.is_networked
    }
}

impl super::core::DataContainerTrait for SimpleStateData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SIMPLESTATEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleStateData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SimpleStateData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Key",
                flags: MemberInfoFlags::new(0),
                field_type: "Guid",
                rust_offset: offset_of!(SimpleStateData, key),
            },
            FieldInfoData {
                name: "AccessMode",
                flags: MemberInfoFlags::new(0),
                field_type: "SimpleStateAccessMode",
                rust_offset: offset_of!(SimpleStateData, access_mode),
            },
            FieldInfoData {
                name: "IsNetworked",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SimpleStateData, is_networked),
            },
        ],
    }),
    array_type: Some(SIMPLESTATEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SimpleStateData {
    fn type_info(&self) -> &'static TypeInfo {
        SIMPLESTATEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SIMPLESTATEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleStateData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("SimpleStateData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum SimpleStateAccessMode {
    #[default]
    SimpleStateAccessMode_Private = 0,
    SimpleStateAccessMode_PrivateWritePublicRead = 1,
    SimpleStateAccessMode_Public = 2,
}

pub static SIMPLESTATEACCESSMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleStateAccessMode",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(SIMPLESTATEACCESSMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SimpleStateAccessMode {
    fn type_info(&self) -> &'static TypeInfo {
        SIMPLESTATEACCESSMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SIMPLESTATEACCESSMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleStateAccessMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("SimpleStateAccessMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SetTheoryQueryEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub input1: QueryEntityResult,
    pub input2: QueryEntityResult,
    pub operation: SetTheoryOperation,
    pub update_on_input1_change: bool,
    pub update_on_input2_change: bool,
}

pub trait SetTheoryQueryEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn input1(&self) -> &QueryEntityResult;
    fn input2(&self) -> &QueryEntityResult;
    fn operation(&self) -> &SetTheoryOperation;
    fn update_on_input1_change(&self) -> &bool;
    fn update_on_input2_change(&self) -> &bool;
}

impl SetTheoryQueryEntityDataTrait for SetTheoryQueryEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn input1(&self) -> &QueryEntityResult {
        &self.input1
    }
    fn input2(&self) -> &QueryEntityResult {
        &self.input2
    }
    fn operation(&self) -> &SetTheoryOperation {
        &self.operation
    }
    fn update_on_input1_change(&self) -> &bool {
        &self.update_on_input1_change
    }
    fn update_on_input2_change(&self) -> &bool {
        &self.update_on_input2_change
    }
}

impl super::entity::EntityDataTrait for SetTheoryQueryEntityData {
}

impl super::entity::GameObjectDataTrait for SetTheoryQueryEntityData {
}

impl super::core::DataBusPeerTrait for SetTheoryQueryEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for SetTheoryQueryEntityData {
}

impl super::core::DataContainerTrait for SetTheoryQueryEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SETTHEORYQUERYENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SetTheoryQueryEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SetTheoryQueryEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(SetTheoryQueryEntityData, realm),
            },
            FieldInfoData {
                name: "Input1",
                flags: MemberInfoFlags::new(0),
                field_type: "QueryEntityResult",
                rust_offset: offset_of!(SetTheoryQueryEntityData, input1),
            },
            FieldInfoData {
                name: "Input2",
                flags: MemberInfoFlags::new(0),
                field_type: "QueryEntityResult",
                rust_offset: offset_of!(SetTheoryQueryEntityData, input2),
            },
            FieldInfoData {
                name: "Operation",
                flags: MemberInfoFlags::new(0),
                field_type: "SetTheoryOperation",
                rust_offset: offset_of!(SetTheoryQueryEntityData, operation),
            },
            FieldInfoData {
                name: "UpdateOnInput1Change",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SetTheoryQueryEntityData, update_on_input1_change),
            },
            FieldInfoData {
                name: "UpdateOnInput2Change",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SetTheoryQueryEntityData, update_on_input2_change),
            },
        ],
    }),
    array_type: Some(SETTHEORYQUERYENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SetTheoryQueryEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SETTHEORYQUERYENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SETTHEORYQUERYENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SetTheoryQueryEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("SetTheoryQueryEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum SetTheoryOperation {
    #[default]
    SetTheoryOperation_Union = 0,
    SetTheoryOperation_Intersection = 1,
    SetTheoryOperation_SetDifference = 2,
}

pub static SETTHEORYOPERATION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SetTheoryOperation",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(SETTHEORYOPERATION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SetTheoryOperation {
    fn type_info(&self) -> &'static TypeInfo {
        SETTHEORYOPERATION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SETTHEORYOPERATION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SetTheoryOperation-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("SetTheoryOperation"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RayCastEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub start: super::core::Vec3,
    pub stop: super::core::Vec3,
    pub radius: f32,
    pub use_detailed_collision: bool,
    pub see_through: bool,
    pub penetrable: bool,
    pub include_terrain: bool,
    pub include_water: bool,
    pub include_characters: bool,
    pub include_vehicles: bool,
    pub include_ragdolls: bool,
    pub include_fixed: bool,
    pub include_keyframed: bool,
    pub include_dynamic: bool,
    pub r#async: bool,
    pub exclude_attached_controllable: bool,
    pub output_filter: QueryEntityFilter,
    pub enabled: bool,
}

pub trait RayCastEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn start(&self) -> &super::core::Vec3;
    fn stop(&self) -> &super::core::Vec3;
    fn radius(&self) -> &f32;
    fn use_detailed_collision(&self) -> &bool;
    fn see_through(&self) -> &bool;
    fn penetrable(&self) -> &bool;
    fn include_terrain(&self) -> &bool;
    fn include_water(&self) -> &bool;
    fn include_characters(&self) -> &bool;
    fn include_vehicles(&self) -> &bool;
    fn include_ragdolls(&self) -> &bool;
    fn include_fixed(&self) -> &bool;
    fn include_keyframed(&self) -> &bool;
    fn include_dynamic(&self) -> &bool;
    fn r#async(&self) -> &bool;
    fn exclude_attached_controllable(&self) -> &bool;
    fn output_filter(&self) -> &QueryEntityFilter;
    fn enabled(&self) -> &bool;
}

impl RayCastEntityDataTrait for RayCastEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn start(&self) -> &super::core::Vec3 {
        &self.start
    }
    fn stop(&self) -> &super::core::Vec3 {
        &self.stop
    }
    fn radius(&self) -> &f32 {
        &self.radius
    }
    fn use_detailed_collision(&self) -> &bool {
        &self.use_detailed_collision
    }
    fn see_through(&self) -> &bool {
        &self.see_through
    }
    fn penetrable(&self) -> &bool {
        &self.penetrable
    }
    fn include_terrain(&self) -> &bool {
        &self.include_terrain
    }
    fn include_water(&self) -> &bool {
        &self.include_water
    }
    fn include_characters(&self) -> &bool {
        &self.include_characters
    }
    fn include_vehicles(&self) -> &bool {
        &self.include_vehicles
    }
    fn include_ragdolls(&self) -> &bool {
        &self.include_ragdolls
    }
    fn include_fixed(&self) -> &bool {
        &self.include_fixed
    }
    fn include_keyframed(&self) -> &bool {
        &self.include_keyframed
    }
    fn include_dynamic(&self) -> &bool {
        &self.include_dynamic
    }
    fn r#async(&self) -> &bool {
        &self.r#async
    }
    fn exclude_attached_controllable(&self) -> &bool {
        &self.exclude_attached_controllable
    }
    fn output_filter(&self) -> &QueryEntityFilter {
        &self.output_filter
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
}

impl super::entity::EntityDataTrait for RayCastEntityData {
}

impl super::entity::GameObjectDataTrait for RayCastEntityData {
}

impl super::core::DataBusPeerTrait for RayCastEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for RayCastEntityData {
}

impl super::core::DataContainerTrait for RayCastEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static RAYCASTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RayCastEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RayCastEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(RayCastEntityData, realm),
            },
            FieldInfoData {
                name: "Start",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(RayCastEntityData, start),
            },
            FieldInfoData {
                name: "Stop",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(RayCastEntityData, stop),
            },
            FieldInfoData {
                name: "Radius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RayCastEntityData, radius),
            },
            FieldInfoData {
                name: "UseDetailedCollision",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RayCastEntityData, use_detailed_collision),
            },
            FieldInfoData {
                name: "SeeThrough",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RayCastEntityData, see_through),
            },
            FieldInfoData {
                name: "Penetrable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RayCastEntityData, penetrable),
            },
            FieldInfoData {
                name: "IncludeTerrain",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RayCastEntityData, include_terrain),
            },
            FieldInfoData {
                name: "IncludeWater",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RayCastEntityData, include_water),
            },
            FieldInfoData {
                name: "IncludeCharacters",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RayCastEntityData, include_characters),
            },
            FieldInfoData {
                name: "IncludeVehicles",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RayCastEntityData, include_vehicles),
            },
            FieldInfoData {
                name: "IncludeRagdolls",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RayCastEntityData, include_ragdolls),
            },
            FieldInfoData {
                name: "IncludeFixed",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RayCastEntityData, include_fixed),
            },
            FieldInfoData {
                name: "IncludeKeyframed",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RayCastEntityData, include_keyframed),
            },
            FieldInfoData {
                name: "IncludeDynamic",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RayCastEntityData, include_dynamic),
            },
            FieldInfoData {
                name: "Async",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RayCastEntityData, r#async),
            },
            FieldInfoData {
                name: "ExcludeAttachedControllable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RayCastEntityData, exclude_attached_controllable),
            },
            FieldInfoData {
                name: "OutputFilter",
                flags: MemberInfoFlags::new(0),
                field_type: "QueryEntityFilter",
                rust_offset: offset_of!(RayCastEntityData, output_filter),
            },
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RayCastEntityData, enabled),
            },
        ],
    }),
    array_type: Some(RAYCASTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for RayCastEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        RAYCASTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static RAYCASTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RayCastEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("RayCastEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RaycastEntityResult {
    pub start_pos: super::core::Vec3,
    pub hit_pos: super::core::Vec3,
    pub normal: super::core::Vec3,
    pub material: u32,
    pub lambda: f32,
    pub distance: f32,
    pub has_hit: bool,
    pub is_terrain_hit: bool,
}

pub trait RaycastEntityResultTrait: TypeObject {
    fn start_pos(&self) -> &super::core::Vec3;
    fn hit_pos(&self) -> &super::core::Vec3;
    fn normal(&self) -> &super::core::Vec3;
    fn material(&self) -> &u32;
    fn lambda(&self) -> &f32;
    fn distance(&self) -> &f32;
    fn has_hit(&self) -> &bool;
    fn is_terrain_hit(&self) -> &bool;
}

impl RaycastEntityResultTrait for RaycastEntityResult {
    fn start_pos(&self) -> &super::core::Vec3 {
        &self.start_pos
    }
    fn hit_pos(&self) -> &super::core::Vec3 {
        &self.hit_pos
    }
    fn normal(&self) -> &super::core::Vec3 {
        &self.normal
    }
    fn material(&self) -> &u32 {
        &self.material
    }
    fn lambda(&self) -> &f32 {
        &self.lambda
    }
    fn distance(&self) -> &f32 {
        &self.distance
    }
    fn has_hit(&self) -> &bool {
        &self.has_hit
    }
    fn is_terrain_hit(&self) -> &bool {
        &self.is_terrain_hit
    }
}

pub static RAYCASTENTITYRESULT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RaycastEntityResult",
    flags: MemberInfoFlags::new(36937),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RaycastEntityResult as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "StartPos",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(RaycastEntityResult, start_pos),
            },
            FieldInfoData {
                name: "HitPos",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(RaycastEntityResult, hit_pos),
            },
            FieldInfoData {
                name: "Normal",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(RaycastEntityResult, normal),
            },
            FieldInfoData {
                name: "Material",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(RaycastEntityResult, material),
            },
            FieldInfoData {
                name: "Lambda",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RaycastEntityResult, lambda),
            },
            FieldInfoData {
                name: "Distance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RaycastEntityResult, distance),
            },
            FieldInfoData {
                name: "HasHit",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RaycastEntityResult, has_hit),
            },
            FieldInfoData {
                name: "IsTerrainHit",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RaycastEntityResult, is_terrain_hit),
            },
        ],
    }),
    array_type: Some(RAYCASTENTITYRESULT_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for RaycastEntityResult {
    fn type_info(&self) -> &'static TypeInfo {
        RAYCASTENTITYRESULT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static RAYCASTENTITYRESULT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RaycastEntityResult-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("RaycastEntityResult"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct QuerySplitterEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub output_count: i32,
    pub realm: super::core::Realm,
    pub input: QueryEntityResult,
}

pub trait QuerySplitterEntityDataTrait: super::entity::EntityDataTrait {
    fn output_count(&self) -> &i32;
    fn realm(&self) -> &super::core::Realm;
    fn input(&self) -> &QueryEntityResult;
}

impl QuerySplitterEntityDataTrait for QuerySplitterEntityData {
    fn output_count(&self) -> &i32 {
        &self.output_count
    }
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn input(&self) -> &QueryEntityResult {
        &self.input
    }
}

impl super::entity::EntityDataTrait for QuerySplitterEntityData {
}

impl super::entity::GameObjectDataTrait for QuerySplitterEntityData {
}

impl super::core::DataBusPeerTrait for QuerySplitterEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for QuerySplitterEntityData {
}

impl super::core::DataContainerTrait for QuerySplitterEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static QUERYSPLITTERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "QuerySplitterEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<QuerySplitterEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "OutputCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(QuerySplitterEntityData, output_count),
            },
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(QuerySplitterEntityData, realm),
            },
            FieldInfoData {
                name: "Input",
                flags: MemberInfoFlags::new(0),
                field_type: "QueryEntityResult",
                rust_offset: offset_of!(QuerySplitterEntityData, input),
            },
        ],
    }),
    array_type: Some(QUERYSPLITTERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for QuerySplitterEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        QUERYSPLITTERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static QUERYSPLITTERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "QuerySplitterEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("QuerySplitterEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct QueryResultBufferEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub input: QueryEntityResult,
    pub buffer_on_property_change: bool,
}

pub trait QueryResultBufferEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn input(&self) -> &QueryEntityResult;
    fn buffer_on_property_change(&self) -> &bool;
}

impl QueryResultBufferEntityDataTrait for QueryResultBufferEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn input(&self) -> &QueryEntityResult {
        &self.input
    }
    fn buffer_on_property_change(&self) -> &bool {
        &self.buffer_on_property_change
    }
}

impl super::entity::EntityDataTrait for QueryResultBufferEntityData {
}

impl super::entity::GameObjectDataTrait for QueryResultBufferEntityData {
}

impl super::core::DataBusPeerTrait for QueryResultBufferEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for QueryResultBufferEntityData {
}

impl super::core::DataContainerTrait for QueryResultBufferEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static QUERYRESULTBUFFERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "QueryResultBufferEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<QueryResultBufferEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(QueryResultBufferEntityData, realm),
            },
            FieldInfoData {
                name: "Input",
                flags: MemberInfoFlags::new(0),
                field_type: "QueryEntityResult",
                rust_offset: offset_of!(QueryResultBufferEntityData, input),
            },
            FieldInfoData {
                name: "BufferOnPropertyChange",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(QueryResultBufferEntityData, buffer_on_property_change),
            },
        ],
    }),
    array_type: Some(QUERYRESULTBUFFERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for QueryResultBufferEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        QUERYRESULTBUFFERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static QUERYRESULTBUFFERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "QueryResultBufferEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("QueryResultBufferEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum QueryEntityFilter {
    #[default]
    QueryEntityFilter_Characters = 0,
    QueryEntityFilter_Vehicles = 1,
    QueryEntityFilter_Controllables = 2,
    QueryEntityFilter_StaticObjects = 3,
    QueryEntityFilter_Players = 4,
    QueryEntityFilter_Projectiles = 5,
    QueryEntityFilter_NotSet = 6,
}

pub static QUERYENTITYFILTER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "QueryEntityFilter",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(QUERYENTITYFILTER_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for QueryEntityFilter {
    fn type_info(&self) -> &'static TypeInfo {
        QUERYENTITYFILTER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static QUERYENTITYFILTER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "QueryEntityFilter-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("QueryEntityFilter"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct QueryEntityResult {
    pub query_entity_result_uniqu_i_d: u64,
    pub unused: u32,
}

pub trait QueryEntityResultTrait: TypeObject {
    fn query_entity_result_uniqu_i_d(&self) -> &u64;
    fn unused(&self) -> &u32;
}

impl QueryEntityResultTrait for QueryEntityResult {
    fn query_entity_result_uniqu_i_d(&self) -> &u64 {
        &self.query_entity_result_uniqu_i_d
    }
    fn unused(&self) -> &u32 {
        &self.unused
    }
}

pub static QUERYENTITYRESULT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "QueryEntityResult",
    flags: MemberInfoFlags::new(36937),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<QueryEntityResult as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "QueryEntityResultUniquID",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint64",
                rust_offset: offset_of!(QueryEntityResult, query_entity_result_uniqu_i_d),
            },
            FieldInfoData {
                name: "Unused",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(QueryEntityResult, unused),
            },
        ],
    }),
    array_type: Some(QUERYENTITYRESULT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for QueryEntityResult {
    fn type_info(&self) -> &'static TypeInfo {
        QUERYENTITYRESULT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static QUERYENTITYRESULT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "QueryEntityResult-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("QueryEntityResult"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DynamicQueryFilterEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub filters: Vec<Option<Arc<Mutex<dyn QueryFilterTrait>>>>,
    pub input: QueryEntityResult,
    pub input_data: QueryFilterEntityInputData,
    pub start_transform: super::core::LinearTransform,
    pub line_of_sight_start_transform: super::core::LinearTransform,
    pub latency: f32,
    pub team_id: super::gameplay_sim::TeamId,
}

pub trait DynamicQueryFilterEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn filters(&self) -> &Vec<Option<Arc<Mutex<dyn QueryFilterTrait>>>>;
    fn input(&self) -> &QueryEntityResult;
    fn input_data(&self) -> &QueryFilterEntityInputData;
    fn start_transform(&self) -> &super::core::LinearTransform;
    fn line_of_sight_start_transform(&self) -> &super::core::LinearTransform;
    fn latency(&self) -> &f32;
    fn team_id(&self) -> &super::gameplay_sim::TeamId;
}

impl DynamicQueryFilterEntityDataTrait for DynamicQueryFilterEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn filters(&self) -> &Vec<Option<Arc<Mutex<dyn QueryFilterTrait>>>> {
        &self.filters
    }
    fn input(&self) -> &QueryEntityResult {
        &self.input
    }
    fn input_data(&self) -> &QueryFilterEntityInputData {
        &self.input_data
    }
    fn start_transform(&self) -> &super::core::LinearTransform {
        &self.start_transform
    }
    fn line_of_sight_start_transform(&self) -> &super::core::LinearTransform {
        &self.line_of_sight_start_transform
    }
    fn latency(&self) -> &f32 {
        &self.latency
    }
    fn team_id(&self) -> &super::gameplay_sim::TeamId {
        &self.team_id
    }
}

impl super::entity::EntityDataTrait for DynamicQueryFilterEntityData {
}

impl super::entity::GameObjectDataTrait for DynamicQueryFilterEntityData {
}

impl super::core::DataBusPeerTrait for DynamicQueryFilterEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for DynamicQueryFilterEntityData {
}

impl super::core::DataContainerTrait for DynamicQueryFilterEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static DYNAMICQUERYFILTERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicQueryFilterEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DynamicQueryFilterEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(DynamicQueryFilterEntityData, realm),
            },
            FieldInfoData {
                name: "Filters",
                flags: MemberInfoFlags::new(144),
                field_type: "QueryFilter-Array",
                rust_offset: offset_of!(DynamicQueryFilterEntityData, filters),
            },
            FieldInfoData {
                name: "Input",
                flags: MemberInfoFlags::new(0),
                field_type: "QueryEntityResult",
                rust_offset: offset_of!(DynamicQueryFilterEntityData, input),
            },
            FieldInfoData {
                name: "InputData",
                flags: MemberInfoFlags::new(0),
                field_type: "QueryFilterEntityInputData",
                rust_offset: offset_of!(DynamicQueryFilterEntityData, input_data),
            },
            FieldInfoData {
                name: "StartTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(DynamicQueryFilterEntityData, start_transform),
            },
            FieldInfoData {
                name: "LineOfSightStartTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(DynamicQueryFilterEntityData, line_of_sight_start_transform),
            },
            FieldInfoData {
                name: "Latency",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicQueryFilterEntityData, latency),
            },
            FieldInfoData {
                name: "TeamId",
                flags: MemberInfoFlags::new(0),
                field_type: "TeamId",
                rust_offset: offset_of!(DynamicQueryFilterEntityData, team_id),
            },
        ],
    }),
    array_type: Some(DYNAMICQUERYFILTERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for DynamicQueryFilterEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        DYNAMICQUERYFILTERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static DYNAMICQUERYFILTERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicQueryFilterEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("DynamicQueryFilterEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LateralDistanceQueryFilter {
    pub _glacier_base: QueryFilter,
    pub max_lateral_distance: f32,
}

pub trait LateralDistanceQueryFilterTrait: QueryFilterTrait {
    fn max_lateral_distance(&self) -> &f32;
}

impl LateralDistanceQueryFilterTrait for LateralDistanceQueryFilter {
    fn max_lateral_distance(&self) -> &f32 {
        &self.max_lateral_distance
    }
}

impl QueryFilterTrait for LateralDistanceQueryFilter {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn target_offset(&self) -> &super::core::Vec3 {
        self._glacier_base.target_offset()
    }
}

impl super::entity::GameObjectDataTrait for LateralDistanceQueryFilter {
}

impl super::core::DataBusPeerTrait for LateralDistanceQueryFilter {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for LateralDistanceQueryFilter {
}

impl super::core::DataContainerTrait for LateralDistanceQueryFilter {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static LATERALDISTANCEQUERYFILTER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LateralDistanceQueryFilter",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(QUERYFILTER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LateralDistanceQueryFilter as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MaxLateralDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LateralDistanceQueryFilter, max_lateral_distance),
            },
        ],
    }),
    array_type: Some(LATERALDISTANCEQUERYFILTER_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for LateralDistanceQueryFilter {
    fn type_info(&self) -> &'static TypeInfo {
        LATERALDISTANCEQUERYFILTER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static LATERALDISTANCEQUERYFILTER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LateralDistanceQueryFilter-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("LateralDistanceQueryFilter"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct HeightDifferenceQueryFilter {
    pub _glacier_base: QueryFilter,
    pub lower_max_height_difference: f32,
    pub upper_max_height_difference: f32,
}

pub trait HeightDifferenceQueryFilterTrait: QueryFilterTrait {
    fn lower_max_height_difference(&self) -> &f32;
    fn upper_max_height_difference(&self) -> &f32;
}

impl HeightDifferenceQueryFilterTrait for HeightDifferenceQueryFilter {
    fn lower_max_height_difference(&self) -> &f32 {
        &self.lower_max_height_difference
    }
    fn upper_max_height_difference(&self) -> &f32 {
        &self.upper_max_height_difference
    }
}

impl QueryFilterTrait for HeightDifferenceQueryFilter {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn target_offset(&self) -> &super::core::Vec3 {
        self._glacier_base.target_offset()
    }
}

impl super::entity::GameObjectDataTrait for HeightDifferenceQueryFilter {
}

impl super::core::DataBusPeerTrait for HeightDifferenceQueryFilter {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for HeightDifferenceQueryFilter {
}

impl super::core::DataContainerTrait for HeightDifferenceQueryFilter {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static HEIGHTDIFFERENCEQUERYFILTER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HeightDifferenceQueryFilter",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(QUERYFILTER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<HeightDifferenceQueryFilter as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "LowerMaxHeightDifference",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HeightDifferenceQueryFilter, lower_max_height_difference),
            },
            FieldInfoData {
                name: "UpperMaxHeightDifference",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HeightDifferenceQueryFilter, upper_max_height_difference),
            },
        ],
    }),
    array_type: Some(HEIGHTDIFFERENCEQUERYFILTER_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for HeightDifferenceQueryFilter {
    fn type_info(&self) -> &'static TypeInfo {
        HEIGHTDIFFERENCEQUERYFILTER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static HEIGHTDIFFERENCEQUERYFILTER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HeightDifferenceQueryFilter-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("HeightDifferenceQueryFilter"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MaxResultsQueryFilter {
    pub _glacier_base: QueryFilter,
    pub max_results: i32,
}

pub trait MaxResultsQueryFilterTrait: QueryFilterTrait {
    fn max_results(&self) -> &i32;
}

impl MaxResultsQueryFilterTrait for MaxResultsQueryFilter {
    fn max_results(&self) -> &i32 {
        &self.max_results
    }
}

impl QueryFilterTrait for MaxResultsQueryFilter {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn target_offset(&self) -> &super::core::Vec3 {
        self._glacier_base.target_offset()
    }
}

impl super::entity::GameObjectDataTrait for MaxResultsQueryFilter {
}

impl super::core::DataBusPeerTrait for MaxResultsQueryFilter {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for MaxResultsQueryFilter {
}

impl super::core::DataContainerTrait for MaxResultsQueryFilter {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static MAXRESULTSQUERYFILTER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MaxResultsQueryFilter",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(QUERYFILTER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MaxResultsQueryFilter as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MaxResults",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MaxResultsQueryFilter, max_results),
            },
        ],
    }),
    array_type: Some(MAXRESULTSQUERYFILTER_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for MaxResultsQueryFilter {
    fn type_info(&self) -> &'static TypeInfo {
        MAXRESULTSQUERYFILTER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static MAXRESULTSQUERYFILTER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MaxResultsQueryFilter-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("MaxResultsQueryFilter"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AngleMultiplierQueryFilter {
    pub _glacier_base: QueryFilter,
    pub angle_multiplier: f32,
}

pub trait AngleMultiplierQueryFilterTrait: QueryFilterTrait {
    fn angle_multiplier(&self) -> &f32;
}

impl AngleMultiplierQueryFilterTrait for AngleMultiplierQueryFilter {
    fn angle_multiplier(&self) -> &f32 {
        &self.angle_multiplier
    }
}

impl QueryFilterTrait for AngleMultiplierQueryFilter {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn target_offset(&self) -> &super::core::Vec3 {
        self._glacier_base.target_offset()
    }
}

impl super::entity::GameObjectDataTrait for AngleMultiplierQueryFilter {
}

impl super::core::DataBusPeerTrait for AngleMultiplierQueryFilter {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for AngleMultiplierQueryFilter {
}

impl super::core::DataContainerTrait for AngleMultiplierQueryFilter {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static ANGLEMULTIPLIERQUERYFILTER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AngleMultiplierQueryFilter",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(QUERYFILTER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AngleMultiplierQueryFilter as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AngleMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AngleMultiplierQueryFilter, angle_multiplier),
            },
        ],
    }),
    array_type: Some(ANGLEMULTIPLIERQUERYFILTER_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AngleMultiplierQueryFilter {
    fn type_info(&self) -> &'static TypeInfo {
        ANGLEMULTIPLIERQUERYFILTER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ANGLEMULTIPLIERQUERYFILTER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AngleMultiplierQueryFilter-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("AngleMultiplierQueryFilter"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DistanceMultiplierQueryFilter {
    pub _glacier_base: QueryFilter,
    pub distance_multiplier: f32,
}

pub trait DistanceMultiplierQueryFilterTrait: QueryFilterTrait {
    fn distance_multiplier(&self) -> &f32;
}

impl DistanceMultiplierQueryFilterTrait for DistanceMultiplierQueryFilter {
    fn distance_multiplier(&self) -> &f32 {
        &self.distance_multiplier
    }
}

impl QueryFilterTrait for DistanceMultiplierQueryFilter {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn target_offset(&self) -> &super::core::Vec3 {
        self._glacier_base.target_offset()
    }
}

impl super::entity::GameObjectDataTrait for DistanceMultiplierQueryFilter {
}

impl super::core::DataBusPeerTrait for DistanceMultiplierQueryFilter {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for DistanceMultiplierQueryFilter {
}

impl super::core::DataContainerTrait for DistanceMultiplierQueryFilter {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static DISTANCEMULTIPLIERQUERYFILTER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DistanceMultiplierQueryFilter",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(QUERYFILTER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DistanceMultiplierQueryFilter as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DistanceMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DistanceMultiplierQueryFilter, distance_multiplier),
            },
        ],
    }),
    array_type: Some(DISTANCEMULTIPLIERQUERYFILTER_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for DistanceMultiplierQueryFilter {
    fn type_info(&self) -> &'static TypeInfo {
        DISTANCEMULTIPLIERQUERYFILTER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static DISTANCEMULTIPLIERQUERYFILTER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DistanceMultiplierQueryFilter-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("DistanceMultiplierQueryFilter"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AngleQueryFilter {
    pub _glacier_base: QueryFilter,
    pub filter_out_angle: f32,
    pub filter_out_target_facing_angle: f32,
}

pub trait AngleQueryFilterTrait: QueryFilterTrait {
    fn filter_out_angle(&self) -> &f32;
    fn filter_out_target_facing_angle(&self) -> &f32;
}

impl AngleQueryFilterTrait for AngleQueryFilter {
    fn filter_out_angle(&self) -> &f32 {
        &self.filter_out_angle
    }
    fn filter_out_target_facing_angle(&self) -> &f32 {
        &self.filter_out_target_facing_angle
    }
}

impl QueryFilterTrait for AngleQueryFilter {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn target_offset(&self) -> &super::core::Vec3 {
        self._glacier_base.target_offset()
    }
}

impl super::entity::GameObjectDataTrait for AngleQueryFilter {
}

impl super::core::DataBusPeerTrait for AngleQueryFilter {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for AngleQueryFilter {
}

impl super::core::DataContainerTrait for AngleQueryFilter {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static ANGLEQUERYFILTER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AngleQueryFilter",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(QUERYFILTER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AngleQueryFilter as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "FilterOutAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AngleQueryFilter, filter_out_angle),
            },
            FieldInfoData {
                name: "FilterOutTargetFacingAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AngleQueryFilter, filter_out_target_facing_angle),
            },
        ],
    }),
    array_type: Some(ANGLEQUERYFILTER_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AngleQueryFilter {
    fn type_info(&self) -> &'static TypeInfo {
        ANGLEQUERYFILTER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ANGLEQUERYFILTER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AngleQueryFilter-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("AngleQueryFilter"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DistanceQueryFilter {
    pub _glacier_base: QueryFilter,
    pub filter_out_distance: f32,
}

pub trait DistanceQueryFilterTrait: QueryFilterTrait {
    fn filter_out_distance(&self) -> &f32;
}

impl DistanceQueryFilterTrait for DistanceQueryFilter {
    fn filter_out_distance(&self) -> &f32 {
        &self.filter_out_distance
    }
}

impl QueryFilterTrait for DistanceQueryFilter {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn target_offset(&self) -> &super::core::Vec3 {
        self._glacier_base.target_offset()
    }
}

impl super::entity::GameObjectDataTrait for DistanceQueryFilter {
}

impl super::core::DataBusPeerTrait for DistanceQueryFilter {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for DistanceQueryFilter {
}

impl super::core::DataContainerTrait for DistanceQueryFilter {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static DISTANCEQUERYFILTER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DistanceQueryFilter",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(QUERYFILTER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DistanceQueryFilter as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "FilterOutDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DistanceQueryFilter, filter_out_distance),
            },
        ],
    }),
    array_type: Some(DISTANCEQUERYFILTER_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for DistanceQueryFilter {
    fn type_info(&self) -> &'static TypeInfo {
        DISTANCEQUERYFILTER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static DISTANCEQUERYFILTER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DistanceQueryFilter-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("DistanceQueryFilter"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FacingQueryFilter {
    pub _glacier_base: QueryFilter,
    pub min_target_angle_from_forward_direction: f32,
    pub max_target_angle_from_forward_direction: f32,
}

pub trait FacingQueryFilterTrait: QueryFilterTrait {
    fn min_target_angle_from_forward_direction(&self) -> &f32;
    fn max_target_angle_from_forward_direction(&self) -> &f32;
}

impl FacingQueryFilterTrait for FacingQueryFilter {
    fn min_target_angle_from_forward_direction(&self) -> &f32 {
        &self.min_target_angle_from_forward_direction
    }
    fn max_target_angle_from_forward_direction(&self) -> &f32 {
        &self.max_target_angle_from_forward_direction
    }
}

impl QueryFilterTrait for FacingQueryFilter {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn target_offset(&self) -> &super::core::Vec3 {
        self._glacier_base.target_offset()
    }
}

impl super::entity::GameObjectDataTrait for FacingQueryFilter {
}

impl super::core::DataBusPeerTrait for FacingQueryFilter {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for FacingQueryFilter {
}

impl super::core::DataContainerTrait for FacingQueryFilter {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static FACINGQUERYFILTER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FacingQueryFilter",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(QUERYFILTER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FacingQueryFilter as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MinTargetAngleFromForwardDirection",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FacingQueryFilter, min_target_angle_from_forward_direction),
            },
            FieldInfoData {
                name: "MaxTargetAngleFromForwardDirection",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FacingQueryFilter, max_target_angle_from_forward_direction),
            },
        ],
    }),
    array_type: Some(FACINGQUERYFILTER_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for FacingQueryFilter {
    fn type_info(&self) -> &'static TypeInfo {
        FACINGQUERYFILTER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static FACINGQUERYFILTER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FacingQueryFilter-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("FacingQueryFilter"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BasicQueryFilter {
    pub _glacier_base: QueryFilter,
    pub sort_output_left_to_right: bool,
    pub filter_out_friently: bool,
    pub filter_out_enemies: bool,
    pub filter_out_specific_controllable: bool,
    pub select_only_first_matching: bool,
    pub filter_out_dead_controllables: bool,
}

pub trait BasicQueryFilterTrait: QueryFilterTrait {
    fn sort_output_left_to_right(&self) -> &bool;
    fn filter_out_friently(&self) -> &bool;
    fn filter_out_enemies(&self) -> &bool;
    fn filter_out_specific_controllable(&self) -> &bool;
    fn select_only_first_matching(&self) -> &bool;
    fn filter_out_dead_controllables(&self) -> &bool;
}

impl BasicQueryFilterTrait for BasicQueryFilter {
    fn sort_output_left_to_right(&self) -> &bool {
        &self.sort_output_left_to_right
    }
    fn filter_out_friently(&self) -> &bool {
        &self.filter_out_friently
    }
    fn filter_out_enemies(&self) -> &bool {
        &self.filter_out_enemies
    }
    fn filter_out_specific_controllable(&self) -> &bool {
        &self.filter_out_specific_controllable
    }
    fn select_only_first_matching(&self) -> &bool {
        &self.select_only_first_matching
    }
    fn filter_out_dead_controllables(&self) -> &bool {
        &self.filter_out_dead_controllables
    }
}

impl QueryFilterTrait for BasicQueryFilter {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn target_offset(&self) -> &super::core::Vec3 {
        self._glacier_base.target_offset()
    }
}

impl super::entity::GameObjectDataTrait for BasicQueryFilter {
}

impl super::core::DataBusPeerTrait for BasicQueryFilter {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for BasicQueryFilter {
}

impl super::core::DataContainerTrait for BasicQueryFilter {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static BASICQUERYFILTER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BasicQueryFilter",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(QUERYFILTER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BasicQueryFilter as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SortOutputLeftToRight",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BasicQueryFilter, sort_output_left_to_right),
            },
            FieldInfoData {
                name: "FilterOutFriently",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BasicQueryFilter, filter_out_friently),
            },
            FieldInfoData {
                name: "FilterOutEnemies",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BasicQueryFilter, filter_out_enemies),
            },
            FieldInfoData {
                name: "FilterOutSpecificControllable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BasicQueryFilter, filter_out_specific_controllable),
            },
            FieldInfoData {
                name: "SelectOnlyFirstMatching",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BasicQueryFilter, select_only_first_matching),
            },
            FieldInfoData {
                name: "FilterOutDeadControllables",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BasicQueryFilter, filter_out_dead_controllables),
            },
        ],
    }),
    array_type: Some(BASICQUERYFILTER_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for BasicQueryFilter {
    fn type_info(&self) -> &'static TypeInfo {
        BASICQUERYFILTER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static BASICQUERYFILTER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BasicQueryFilter-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("BasicQueryFilter"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LOSQueryFilter {
    pub _glacier_base: QueryFilter,
    pub filter_clear_line_of_sight: bool,
    pub ignore_characters_for_los: bool,
    pub ignore_see_through_material: bool,
    pub ignore_penetrable_material: bool,
    pub use_detailed_game_world_for_los: bool,
}

pub trait LOSQueryFilterTrait: QueryFilterTrait {
    fn filter_clear_line_of_sight(&self) -> &bool;
    fn ignore_characters_for_los(&self) -> &bool;
    fn ignore_see_through_material(&self) -> &bool;
    fn ignore_penetrable_material(&self) -> &bool;
    fn use_detailed_game_world_for_los(&self) -> &bool;
}

impl LOSQueryFilterTrait for LOSQueryFilter {
    fn filter_clear_line_of_sight(&self) -> &bool {
        &self.filter_clear_line_of_sight
    }
    fn ignore_characters_for_los(&self) -> &bool {
        &self.ignore_characters_for_los
    }
    fn ignore_see_through_material(&self) -> &bool {
        &self.ignore_see_through_material
    }
    fn ignore_penetrable_material(&self) -> &bool {
        &self.ignore_penetrable_material
    }
    fn use_detailed_game_world_for_los(&self) -> &bool {
        &self.use_detailed_game_world_for_los
    }
}

impl QueryFilterTrait for LOSQueryFilter {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn target_offset(&self) -> &super::core::Vec3 {
        self._glacier_base.target_offset()
    }
}

impl super::entity::GameObjectDataTrait for LOSQueryFilter {
}

impl super::core::DataBusPeerTrait for LOSQueryFilter {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for LOSQueryFilter {
}

impl super::core::DataContainerTrait for LOSQueryFilter {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static LOSQUERYFILTER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LOSQueryFilter",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(QUERYFILTER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LOSQueryFilter as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "FilterClearLineOfSight",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LOSQueryFilter, filter_clear_line_of_sight),
            },
            FieldInfoData {
                name: "IgnoreCharactersForLos",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LOSQueryFilter, ignore_characters_for_los),
            },
            FieldInfoData {
                name: "IgnoreSeeThroughMaterial",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LOSQueryFilter, ignore_see_through_material),
            },
            FieldInfoData {
                name: "IgnorePenetrableMaterial",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LOSQueryFilter, ignore_penetrable_material),
            },
            FieldInfoData {
                name: "UseDetailedGameWorldForLos",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LOSQueryFilter, use_detailed_game_world_for_los),
            },
        ],
    }),
    array_type: Some(LOSQUERYFILTER_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for LOSQueryFilter {
    fn type_info(&self) -> &'static TypeInfo {
        LOSQUERYFILTER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static LOSQUERYFILTER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LOSQueryFilter-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("LOSQueryFilter"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct QueryFilter {
    pub _glacier_base: super::entity::GameObjectData,
    pub realm: super::core::Realm,
    pub target_offset: super::core::Vec3,
}

pub trait QueryFilterTrait: super::entity::GameObjectDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn target_offset(&self) -> &super::core::Vec3;
}

impl QueryFilterTrait for QueryFilter {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn target_offset(&self) -> &super::core::Vec3 {
        &self.target_offset
    }
}

impl super::entity::GameObjectDataTrait for QueryFilter {
}

impl super::core::DataBusPeerTrait for QueryFilter {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for QueryFilter {
}

impl super::core::DataContainerTrait for QueryFilter {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static QUERYFILTER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "QueryFilter",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMEOBJECTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<QueryFilter as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(QueryFilter, realm),
            },
            FieldInfoData {
                name: "TargetOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(QueryFilter, target_offset),
            },
        ],
    }),
    array_type: Some(QUERYFILTER_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for QueryFilter {
    fn type_info(&self) -> &'static TypeInfo {
        QUERYFILTER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static QUERYFILTER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "QueryFilter-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("QueryFilter"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct QueryFilterEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub input: QueryEntityResult,
    pub input_data: QueryFilterEntityInputData,
    pub start_transform: super::core::LinearTransform,
    pub line_of_sight_start_transform: super::core::LinearTransform,
    pub latency: f32,
    pub team_id: super::gameplay_sim::TeamId,
}

pub trait QueryFilterEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn input(&self) -> &QueryEntityResult;
    fn input_data(&self) -> &QueryFilterEntityInputData;
    fn start_transform(&self) -> &super::core::LinearTransform;
    fn line_of_sight_start_transform(&self) -> &super::core::LinearTransform;
    fn latency(&self) -> &f32;
    fn team_id(&self) -> &super::gameplay_sim::TeamId;
}

impl QueryFilterEntityDataTrait for QueryFilterEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn input(&self) -> &QueryEntityResult {
        &self.input
    }
    fn input_data(&self) -> &QueryFilterEntityInputData {
        &self.input_data
    }
    fn start_transform(&self) -> &super::core::LinearTransform {
        &self.start_transform
    }
    fn line_of_sight_start_transform(&self) -> &super::core::LinearTransform {
        &self.line_of_sight_start_transform
    }
    fn latency(&self) -> &f32 {
        &self.latency
    }
    fn team_id(&self) -> &super::gameplay_sim::TeamId {
        &self.team_id
    }
}

impl super::entity::EntityDataTrait for QueryFilterEntityData {
}

impl super::entity::GameObjectDataTrait for QueryFilterEntityData {
}

impl super::core::DataBusPeerTrait for QueryFilterEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for QueryFilterEntityData {
}

impl super::core::DataContainerTrait for QueryFilterEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static QUERYFILTERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "QueryFilterEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<QueryFilterEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(QueryFilterEntityData, realm),
            },
            FieldInfoData {
                name: "Input",
                flags: MemberInfoFlags::new(0),
                field_type: "QueryEntityResult",
                rust_offset: offset_of!(QueryFilterEntityData, input),
            },
            FieldInfoData {
                name: "InputData",
                flags: MemberInfoFlags::new(0),
                field_type: "QueryFilterEntityInputData",
                rust_offset: offset_of!(QueryFilterEntityData, input_data),
            },
            FieldInfoData {
                name: "StartTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(QueryFilterEntityData, start_transform),
            },
            FieldInfoData {
                name: "LineOfSightStartTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(QueryFilterEntityData, line_of_sight_start_transform),
            },
            FieldInfoData {
                name: "Latency",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(QueryFilterEntityData, latency),
            },
            FieldInfoData {
                name: "TeamId",
                flags: MemberInfoFlags::new(0),
                field_type: "TeamId",
                rust_offset: offset_of!(QueryFilterEntityData, team_id),
            },
        ],
    }),
    array_type: Some(QUERYFILTERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for QueryFilterEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        QUERYFILTERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static QUERYFILTERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "QueryFilterEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("QueryFilterEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct QueryFilterEntityInputData {
    pub filter_out_distance_type: FilterOutDistanceType,
    pub filter_out_distance: f32,
    pub filter_out_angle: f32,
    pub filter_out_target_facing_angle: f32,
    pub distance_multiplier: f32,
    pub angle_multiplier: f32,
    pub min_target_angle_from_forward_direction: f32,
    pub max_target_angle_from_forward_direction: f32,
    pub use_lower_max_height_difference: bool,
    pub lower_max_height_difference: f32,
    pub use_upper_max_height_difference: bool,
    pub upper_max_height_difference: f32,
    pub use_max_lateral_distance: bool,
    pub max_lateral_distance: f32,
    pub max_results: i32,
    pub sort_output_mode: SortOutputModeType,
    pub sort_output_left_to_right: bool,
    pub filter_out_friently: bool,
    pub filter_out_enemies: bool,
    pub filter_out_shielded: bool,
    pub filter_out_specific_controllable: bool,
    pub select_only_first_matching: bool,
    pub filter_out_dead_controllables: bool,
    pub filter_clear_line_of_sight: bool,
    pub ignore_characters_for_los: bool,
    pub ignore_see_through_material: bool,
    pub ignore_penetrable_material: bool,
    pub use_detailed_game_world_for_los: bool,
    pub target_offset: super::core::Vec3,
    pub debug_query: bool,
    pub debug_draw_color: super::core::Vec4,
    pub debug_life_time: f32,
}

pub trait QueryFilterEntityInputDataTrait: TypeObject {
    fn filter_out_distance_type(&self) -> &FilterOutDistanceType;
    fn filter_out_distance(&self) -> &f32;
    fn filter_out_angle(&self) -> &f32;
    fn filter_out_target_facing_angle(&self) -> &f32;
    fn distance_multiplier(&self) -> &f32;
    fn angle_multiplier(&self) -> &f32;
    fn min_target_angle_from_forward_direction(&self) -> &f32;
    fn max_target_angle_from_forward_direction(&self) -> &f32;
    fn use_lower_max_height_difference(&self) -> &bool;
    fn lower_max_height_difference(&self) -> &f32;
    fn use_upper_max_height_difference(&self) -> &bool;
    fn upper_max_height_difference(&self) -> &f32;
    fn use_max_lateral_distance(&self) -> &bool;
    fn max_lateral_distance(&self) -> &f32;
    fn max_results(&self) -> &i32;
    fn sort_output_mode(&self) -> &SortOutputModeType;
    fn sort_output_left_to_right(&self) -> &bool;
    fn filter_out_friently(&self) -> &bool;
    fn filter_out_enemies(&self) -> &bool;
    fn filter_out_shielded(&self) -> &bool;
    fn filter_out_specific_controllable(&self) -> &bool;
    fn select_only_first_matching(&self) -> &bool;
    fn filter_out_dead_controllables(&self) -> &bool;
    fn filter_clear_line_of_sight(&self) -> &bool;
    fn ignore_characters_for_los(&self) -> &bool;
    fn ignore_see_through_material(&self) -> &bool;
    fn ignore_penetrable_material(&self) -> &bool;
    fn use_detailed_game_world_for_los(&self) -> &bool;
    fn target_offset(&self) -> &super::core::Vec3;
    fn debug_query(&self) -> &bool;
    fn debug_draw_color(&self) -> &super::core::Vec4;
    fn debug_life_time(&self) -> &f32;
}

impl QueryFilterEntityInputDataTrait for QueryFilterEntityInputData {
    fn filter_out_distance_type(&self) -> &FilterOutDistanceType {
        &self.filter_out_distance_type
    }
    fn filter_out_distance(&self) -> &f32 {
        &self.filter_out_distance
    }
    fn filter_out_angle(&self) -> &f32 {
        &self.filter_out_angle
    }
    fn filter_out_target_facing_angle(&self) -> &f32 {
        &self.filter_out_target_facing_angle
    }
    fn distance_multiplier(&self) -> &f32 {
        &self.distance_multiplier
    }
    fn angle_multiplier(&self) -> &f32 {
        &self.angle_multiplier
    }
    fn min_target_angle_from_forward_direction(&self) -> &f32 {
        &self.min_target_angle_from_forward_direction
    }
    fn max_target_angle_from_forward_direction(&self) -> &f32 {
        &self.max_target_angle_from_forward_direction
    }
    fn use_lower_max_height_difference(&self) -> &bool {
        &self.use_lower_max_height_difference
    }
    fn lower_max_height_difference(&self) -> &f32 {
        &self.lower_max_height_difference
    }
    fn use_upper_max_height_difference(&self) -> &bool {
        &self.use_upper_max_height_difference
    }
    fn upper_max_height_difference(&self) -> &f32 {
        &self.upper_max_height_difference
    }
    fn use_max_lateral_distance(&self) -> &bool {
        &self.use_max_lateral_distance
    }
    fn max_lateral_distance(&self) -> &f32 {
        &self.max_lateral_distance
    }
    fn max_results(&self) -> &i32 {
        &self.max_results
    }
    fn sort_output_mode(&self) -> &SortOutputModeType {
        &self.sort_output_mode
    }
    fn sort_output_left_to_right(&self) -> &bool {
        &self.sort_output_left_to_right
    }
    fn filter_out_friently(&self) -> &bool {
        &self.filter_out_friently
    }
    fn filter_out_enemies(&self) -> &bool {
        &self.filter_out_enemies
    }
    fn filter_out_shielded(&self) -> &bool {
        &self.filter_out_shielded
    }
    fn filter_out_specific_controllable(&self) -> &bool {
        &self.filter_out_specific_controllable
    }
    fn select_only_first_matching(&self) -> &bool {
        &self.select_only_first_matching
    }
    fn filter_out_dead_controllables(&self) -> &bool {
        &self.filter_out_dead_controllables
    }
    fn filter_clear_line_of_sight(&self) -> &bool {
        &self.filter_clear_line_of_sight
    }
    fn ignore_characters_for_los(&self) -> &bool {
        &self.ignore_characters_for_los
    }
    fn ignore_see_through_material(&self) -> &bool {
        &self.ignore_see_through_material
    }
    fn ignore_penetrable_material(&self) -> &bool {
        &self.ignore_penetrable_material
    }
    fn use_detailed_game_world_for_los(&self) -> &bool {
        &self.use_detailed_game_world_for_los
    }
    fn target_offset(&self) -> &super::core::Vec3 {
        &self.target_offset
    }
    fn debug_query(&self) -> &bool {
        &self.debug_query
    }
    fn debug_draw_color(&self) -> &super::core::Vec4 {
        &self.debug_draw_color
    }
    fn debug_life_time(&self) -> &f32 {
        &self.debug_life_time
    }
}

pub static QUERYFILTERENTITYINPUTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "QueryFilterEntityInputData",
    flags: MemberInfoFlags::new(36937),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<QueryFilterEntityInputData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "FilterOutDistanceType",
                flags: MemberInfoFlags::new(0),
                field_type: "FilterOutDistanceType",
                rust_offset: offset_of!(QueryFilterEntityInputData, filter_out_distance_type),
            },
            FieldInfoData {
                name: "FilterOutDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(QueryFilterEntityInputData, filter_out_distance),
            },
            FieldInfoData {
                name: "FilterOutAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(QueryFilterEntityInputData, filter_out_angle),
            },
            FieldInfoData {
                name: "FilterOutTargetFacingAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(QueryFilterEntityInputData, filter_out_target_facing_angle),
            },
            FieldInfoData {
                name: "DistanceMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(QueryFilterEntityInputData, distance_multiplier),
            },
            FieldInfoData {
                name: "AngleMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(QueryFilterEntityInputData, angle_multiplier),
            },
            FieldInfoData {
                name: "MinTargetAngleFromForwardDirection",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(QueryFilterEntityInputData, min_target_angle_from_forward_direction),
            },
            FieldInfoData {
                name: "MaxTargetAngleFromForwardDirection",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(QueryFilterEntityInputData, max_target_angle_from_forward_direction),
            },
            FieldInfoData {
                name: "UseLowerMaxHeightDifference",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(QueryFilterEntityInputData, use_lower_max_height_difference),
            },
            FieldInfoData {
                name: "LowerMaxHeightDifference",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(QueryFilterEntityInputData, lower_max_height_difference),
            },
            FieldInfoData {
                name: "UseUpperMaxHeightDifference",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(QueryFilterEntityInputData, use_upper_max_height_difference),
            },
            FieldInfoData {
                name: "UpperMaxHeightDifference",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(QueryFilterEntityInputData, upper_max_height_difference),
            },
            FieldInfoData {
                name: "UseMaxLateralDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(QueryFilterEntityInputData, use_max_lateral_distance),
            },
            FieldInfoData {
                name: "MaxLateralDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(QueryFilterEntityInputData, max_lateral_distance),
            },
            FieldInfoData {
                name: "MaxResults",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(QueryFilterEntityInputData, max_results),
            },
            FieldInfoData {
                name: "SortOutputMode",
                flags: MemberInfoFlags::new(0),
                field_type: "SortOutputModeType",
                rust_offset: offset_of!(QueryFilterEntityInputData, sort_output_mode),
            },
            FieldInfoData {
                name: "SortOutputLeftToRight",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(QueryFilterEntityInputData, sort_output_left_to_right),
            },
            FieldInfoData {
                name: "FilterOutFriently",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(QueryFilterEntityInputData, filter_out_friently),
            },
            FieldInfoData {
                name: "FilterOutEnemies",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(QueryFilterEntityInputData, filter_out_enemies),
            },
            FieldInfoData {
                name: "FilterOutShielded",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(QueryFilterEntityInputData, filter_out_shielded),
            },
            FieldInfoData {
                name: "FilterOutSpecificControllable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(QueryFilterEntityInputData, filter_out_specific_controllable),
            },
            FieldInfoData {
                name: "SelectOnlyFirstMatching",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(QueryFilterEntityInputData, select_only_first_matching),
            },
            FieldInfoData {
                name: "FilterOutDeadControllables",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(QueryFilterEntityInputData, filter_out_dead_controllables),
            },
            FieldInfoData {
                name: "FilterClearLineOfSight",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(QueryFilterEntityInputData, filter_clear_line_of_sight),
            },
            FieldInfoData {
                name: "IgnoreCharactersForLos",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(QueryFilterEntityInputData, ignore_characters_for_los),
            },
            FieldInfoData {
                name: "IgnoreSeeThroughMaterial",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(QueryFilterEntityInputData, ignore_see_through_material),
            },
            FieldInfoData {
                name: "IgnorePenetrableMaterial",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(QueryFilterEntityInputData, ignore_penetrable_material),
            },
            FieldInfoData {
                name: "UseDetailedGameWorldForLos",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(QueryFilterEntityInputData, use_detailed_game_world_for_los),
            },
            FieldInfoData {
                name: "TargetOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(QueryFilterEntityInputData, target_offset),
            },
            FieldInfoData {
                name: "DebugQuery",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(QueryFilterEntityInputData, debug_query),
            },
            FieldInfoData {
                name: "DebugDrawColor",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(QueryFilterEntityInputData, debug_draw_color),
            },
            FieldInfoData {
                name: "DebugLifeTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(QueryFilterEntityInputData, debug_life_time),
            },
        ],
    }),
    array_type: Some(QUERYFILTERENTITYINPUTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for QueryFilterEntityInputData {
    fn type_info(&self) -> &'static TypeInfo {
        QUERYFILTERENTITYINPUTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static QUERYFILTERENTITYINPUTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "QueryFilterEntityInputData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("QueryFilterEntityInputData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum SortOutputModeType {
    #[default]
    SortOutputModeType_None = 0,
    SortOutputModeType_LeftToRight = 1,
    SortOutputModeType_DistanceCloseToFar = 2,
    SortOutputModeType_DistanceFarToClose = 3,
    SortOutputModeType_Random = 4,
}

pub static SORTOUTPUTMODETYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SortOutputModeType",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(SORTOUTPUTMODETYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SortOutputModeType {
    fn type_info(&self) -> &'static TypeInfo {
        SORTOUTPUTMODETYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SORTOUTPUTMODETYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SortOutputModeType-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("SortOutputModeType"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum FilterOutDistanceType {
    #[default]
    FilterOutDistanceType_LessThan = 0,
    FilterOutDistanceType_GreaterThan = 1,
}

pub static FILTEROUTDISTANCETYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FilterOutDistanceType",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(FILTEROUTDISTANCETYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for FilterOutDistanceType {
    fn type_info(&self) -> &'static TypeInfo {
        FILTEROUTDISTANCETYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static FILTEROUTDISTANCETYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FilterOutDistanceType-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("FilterOutDistanceType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct QueryEntityFilterTypeData {
    pub _glacier_base: super::entity::EntityData,
    pub default_value: QueryEntityFilter,
}

pub trait QueryEntityFilterTypeDataTrait: super::entity::EntityDataTrait {
    fn default_value(&self) -> &QueryEntityFilter;
}

impl QueryEntityFilterTypeDataTrait for QueryEntityFilterTypeData {
    fn default_value(&self) -> &QueryEntityFilter {
        &self.default_value
    }
}

impl super::entity::EntityDataTrait for QueryEntityFilterTypeData {
}

impl super::entity::GameObjectDataTrait for QueryEntityFilterTypeData {
}

impl super::core::DataBusPeerTrait for QueryEntityFilterTypeData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for QueryEntityFilterTypeData {
}

impl super::core::DataContainerTrait for QueryEntityFilterTypeData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static QUERYENTITYFILTERTYPEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "QueryEntityFilterTypeData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<QueryEntityFilterTypeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DefaultValue",
                flags: MemberInfoFlags::new(0),
                field_type: "QueryEntityFilter",
                rust_offset: offset_of!(QueryEntityFilterTypeData, default_value),
            },
        ],
    }),
    array_type: Some(QUERYENTITYFILTERTYPEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for QueryEntityFilterTypeData {
    fn type_info(&self) -> &'static TypeInfo {
        QUERYENTITYFILTERTYPEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static QUERYENTITYFILTERTYPEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "QueryEntityFilterTypeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("QueryEntityFilterTypeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct QueryCacheEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub input: QueryEntityResult,
    pub input_data: QueryCacheEntityInputData,
    pub always_enabled: bool,
    pub keep_removed: bool,
    pub send_output_on_receive_input: bool,
    pub only_send_output_if_input_has_changed: bool,
}

pub trait QueryCacheEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn input(&self) -> &QueryEntityResult;
    fn input_data(&self) -> &QueryCacheEntityInputData;
    fn always_enabled(&self) -> &bool;
    fn keep_removed(&self) -> &bool;
    fn send_output_on_receive_input(&self) -> &bool;
    fn only_send_output_if_input_has_changed(&self) -> &bool;
}

impl QueryCacheEntityDataTrait for QueryCacheEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn input(&self) -> &QueryEntityResult {
        &self.input
    }
    fn input_data(&self) -> &QueryCacheEntityInputData {
        &self.input_data
    }
    fn always_enabled(&self) -> &bool {
        &self.always_enabled
    }
    fn keep_removed(&self) -> &bool {
        &self.keep_removed
    }
    fn send_output_on_receive_input(&self) -> &bool {
        &self.send_output_on_receive_input
    }
    fn only_send_output_if_input_has_changed(&self) -> &bool {
        &self.only_send_output_if_input_has_changed
    }
}

impl super::entity::EntityDataTrait for QueryCacheEntityData {
}

impl super::entity::GameObjectDataTrait for QueryCacheEntityData {
}

impl super::core::DataBusPeerTrait for QueryCacheEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for QueryCacheEntityData {
}

impl super::core::DataContainerTrait for QueryCacheEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static QUERYCACHEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "QueryCacheEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<QueryCacheEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(QueryCacheEntityData, realm),
            },
            FieldInfoData {
                name: "Input",
                flags: MemberInfoFlags::new(0),
                field_type: "QueryEntityResult",
                rust_offset: offset_of!(QueryCacheEntityData, input),
            },
            FieldInfoData {
                name: "InputData",
                flags: MemberInfoFlags::new(0),
                field_type: "QueryCacheEntityInputData",
                rust_offset: offset_of!(QueryCacheEntityData, input_data),
            },
            FieldInfoData {
                name: "AlwaysEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(QueryCacheEntityData, always_enabled),
            },
            FieldInfoData {
                name: "KeepRemoved",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(QueryCacheEntityData, keep_removed),
            },
            FieldInfoData {
                name: "SendOutputOnReceiveInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(QueryCacheEntityData, send_output_on_receive_input),
            },
            FieldInfoData {
                name: "OnlySendOutputIfInputHasChanged",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(QueryCacheEntityData, only_send_output_if_input_has_changed),
            },
        ],
    }),
    array_type: Some(QUERYCACHEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for QueryCacheEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        QUERYCACHEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static QUERYCACHEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "QueryCacheEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("QueryCacheEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct QueryCacheEntityInputData {
    pub dummy: bool,
}

pub trait QueryCacheEntityInputDataTrait: TypeObject {
    fn dummy(&self) -> &bool;
}

impl QueryCacheEntityInputDataTrait for QueryCacheEntityInputData {
    fn dummy(&self) -> &bool {
        &self.dummy
    }
}

pub static QUERYCACHEENTITYINPUTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "QueryCacheEntityInputData",
    flags: MemberInfoFlags::new(36937),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<QueryCacheEntityInputData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Dummy",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(QueryCacheEntityInputData, dummy),
            },
        ],
    }),
    array_type: Some(QUERYCACHEENTITYINPUTDATA_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for QueryCacheEntityInputData {
    fn type_info(&self) -> &'static TypeInfo {
        QUERYCACHEENTITYINPUTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static QUERYCACHEENTITYINPUTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "QueryCacheEntityInputData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("QueryCacheEntityInputData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlayersQueryEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub input_data: PlayersQueryEntityInputData,
    pub team_id: super::gameplay_sim::TeamId,
    pub always_enabled: bool,
    pub trigger_on_change: bool,
    pub output_filter: QueryEntityFilter,
}

pub trait PlayersQueryEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn input_data(&self) -> &PlayersQueryEntityInputData;
    fn team_id(&self) -> &super::gameplay_sim::TeamId;
    fn always_enabled(&self) -> &bool;
    fn trigger_on_change(&self) -> &bool;
    fn output_filter(&self) -> &QueryEntityFilter;
}

impl PlayersQueryEntityDataTrait for PlayersQueryEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn input_data(&self) -> &PlayersQueryEntityInputData {
        &self.input_data
    }
    fn team_id(&self) -> &super::gameplay_sim::TeamId {
        &self.team_id
    }
    fn always_enabled(&self) -> &bool {
        &self.always_enabled
    }
    fn trigger_on_change(&self) -> &bool {
        &self.trigger_on_change
    }
    fn output_filter(&self) -> &QueryEntityFilter {
        &self.output_filter
    }
}

impl super::entity::EntityDataTrait for PlayersQueryEntityData {
}

impl super::entity::GameObjectDataTrait for PlayersQueryEntityData {
}

impl super::core::DataBusPeerTrait for PlayersQueryEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for PlayersQueryEntityData {
}

impl super::core::DataContainerTrait for PlayersQueryEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PLAYERSQUERYENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayersQueryEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayersQueryEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(PlayersQueryEntityData, realm),
            },
            FieldInfoData {
                name: "InputData",
                flags: MemberInfoFlags::new(0),
                field_type: "PlayersQueryEntityInputData",
                rust_offset: offset_of!(PlayersQueryEntityData, input_data),
            },
            FieldInfoData {
                name: "TeamId",
                flags: MemberInfoFlags::new(0),
                field_type: "TeamId",
                rust_offset: offset_of!(PlayersQueryEntityData, team_id),
            },
            FieldInfoData {
                name: "AlwaysEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayersQueryEntityData, always_enabled),
            },
            FieldInfoData {
                name: "TriggerOnChange",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayersQueryEntityData, trigger_on_change),
            },
            FieldInfoData {
                name: "OutputFilter",
                flags: MemberInfoFlags::new(0),
                field_type: "QueryEntityFilter",
                rust_offset: offset_of!(PlayersQueryEntityData, output_filter),
            },
        ],
    }),
    array_type: Some(PLAYERSQUERYENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PlayersQueryEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERSQUERYENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PLAYERSQUERYENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayersQueryEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PlayersQueryEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlayersQueryEntityInputData {
    pub filter_out_friently: bool,
    pub filter_out_enemies: bool,
}

pub trait PlayersQueryEntityInputDataTrait: TypeObject {
    fn filter_out_friently(&self) -> &bool;
    fn filter_out_enemies(&self) -> &bool;
}

impl PlayersQueryEntityInputDataTrait for PlayersQueryEntityInputData {
    fn filter_out_friently(&self) -> &bool {
        &self.filter_out_friently
    }
    fn filter_out_enemies(&self) -> &bool {
        &self.filter_out_enemies
    }
}

pub static PLAYERSQUERYENTITYINPUTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayersQueryEntityInputData",
    flags: MemberInfoFlags::new(36937),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayersQueryEntityInputData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "FilterOutFriently",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayersQueryEntityInputData, filter_out_friently),
            },
            FieldInfoData {
                name: "FilterOutEnemies",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayersQueryEntityInputData, filter_out_enemies),
            },
        ],
    }),
    array_type: Some(PLAYERSQUERYENTITYINPUTDATA_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for PlayersQueryEntityInputData {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERSQUERYENTITYINPUTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PLAYERSQUERYENTITYINPUTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayersQueryEntityInputData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PlayersQueryEntityInputData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlayersInsideEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub enabled: bool,
    pub output_filter: QueryEntityFilter,
    pub teams_infos: Vec<PlayersInsideEntity_TeamInfo>,
    pub teams_mask: u32,
    pub allowed_empty_controllable_hashes: Vec<u32>,
}

pub trait PlayersInsideEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn enabled(&self) -> &bool;
    fn output_filter(&self) -> &QueryEntityFilter;
    fn teams_infos(&self) -> &Vec<PlayersInsideEntity_TeamInfo>;
    fn teams_mask(&self) -> &u32;
    fn allowed_empty_controllable_hashes(&self) -> &Vec<u32>;
}

impl PlayersInsideEntityDataTrait for PlayersInsideEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn output_filter(&self) -> &QueryEntityFilter {
        &self.output_filter
    }
    fn teams_infos(&self) -> &Vec<PlayersInsideEntity_TeamInfo> {
        &self.teams_infos
    }
    fn teams_mask(&self) -> &u32 {
        &self.teams_mask
    }
    fn allowed_empty_controllable_hashes(&self) -> &Vec<u32> {
        &self.allowed_empty_controllable_hashes
    }
}

impl super::entity::EntityDataTrait for PlayersInsideEntityData {
}

impl super::entity::GameObjectDataTrait for PlayersInsideEntityData {
}

impl super::core::DataBusPeerTrait for PlayersInsideEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for PlayersInsideEntityData {
}

impl super::core::DataContainerTrait for PlayersInsideEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PLAYERSINSIDEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayersInsideEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayersInsideEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(PlayersInsideEntityData, realm),
            },
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayersInsideEntityData, enabled),
            },
            FieldInfoData {
                name: "OutputFilter",
                flags: MemberInfoFlags::new(0),
                field_type: "QueryEntityFilter",
                rust_offset: offset_of!(PlayersInsideEntityData, output_filter),
            },
            FieldInfoData {
                name: "TeamsInfos",
                flags: MemberInfoFlags::new(144),
                field_type: "PlayersInsideEntity_TeamInfo-Array",
                rust_offset: offset_of!(PlayersInsideEntityData, teams_infos),
            },
            FieldInfoData {
                name: "TeamsMask",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(PlayersInsideEntityData, teams_mask),
            },
            FieldInfoData {
                name: "AllowedEmptyControllableHashes",
                flags: MemberInfoFlags::new(144),
                field_type: "Uint32-Array",
                rust_offset: offset_of!(PlayersInsideEntityData, allowed_empty_controllable_hashes),
            },
        ],
    }),
    array_type: Some(PLAYERSINSIDEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PlayersInsideEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERSINSIDEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PLAYERSINSIDEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayersInsideEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PlayersInsideEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlayersInsideEntity_TeamInfo {
    pub team: super::gameplay_sim::TeamId,
    pub count_property_id: i32,
}

pub trait PlayersInsideEntity_TeamInfoTrait: TypeObject {
    fn team(&self) -> &super::gameplay_sim::TeamId;
    fn count_property_id(&self) -> &i32;
}

impl PlayersInsideEntity_TeamInfoTrait for PlayersInsideEntity_TeamInfo {
    fn team(&self) -> &super::gameplay_sim::TeamId {
        &self.team
    }
    fn count_property_id(&self) -> &i32 {
        &self.count_property_id
    }
}

pub static PLAYERSINSIDEENTITY_TEAMINFO_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayersInsideEntity_TeamInfo",
    flags: MemberInfoFlags::new(36937),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayersInsideEntity_TeamInfo as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Team",
                flags: MemberInfoFlags::new(0),
                field_type: "TeamId",
                rust_offset: offset_of!(PlayersInsideEntity_TeamInfo, team),
            },
            FieldInfoData {
                name: "CountPropertyId",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(PlayersInsideEntity_TeamInfo, count_property_id),
            },
        ],
    }),
    array_type: Some(PLAYERSINSIDEENTITY_TEAMINFO_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for PlayersInsideEntity_TeamInfo {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERSINSIDEENTITY_TEAMINFO_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PLAYERSINSIDEENTITY_TEAMINFO_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayersInsideEntity_TeamInfo-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PlayersInsideEntity_TeamInfo"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PhantomEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub material_offsets: Vec<MaterialOffset>,
    pub realm: super::core::Realm,
    pub position_offset: super::core::Vec3,
    pub box_size: super::core::Vec3,
    pub async_query_pointer_asset: super::ant::AntRef,
    pub phantom_transform: super::core::LinearTransform,
    pub enable_phantom: bool,
    pub include_vehicles: bool,
    pub include_characters: bool,
    pub include_actors: bool,
}

pub trait PhantomEntityDataTrait: super::entity::EntityDataTrait {
    fn material_offsets(&self) -> &Vec<MaterialOffset>;
    fn realm(&self) -> &super::core::Realm;
    fn position_offset(&self) -> &super::core::Vec3;
    fn box_size(&self) -> &super::core::Vec3;
    fn async_query_pointer_asset(&self) -> &super::ant::AntRef;
    fn phantom_transform(&self) -> &super::core::LinearTransform;
    fn enable_phantom(&self) -> &bool;
    fn include_vehicles(&self) -> &bool;
    fn include_characters(&self) -> &bool;
    fn include_actors(&self) -> &bool;
}

impl PhantomEntityDataTrait for PhantomEntityData {
    fn material_offsets(&self) -> &Vec<MaterialOffset> {
        &self.material_offsets
    }
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn position_offset(&self) -> &super::core::Vec3 {
        &self.position_offset
    }
    fn box_size(&self) -> &super::core::Vec3 {
        &self.box_size
    }
    fn async_query_pointer_asset(&self) -> &super::ant::AntRef {
        &self.async_query_pointer_asset
    }
    fn phantom_transform(&self) -> &super::core::LinearTransform {
        &self.phantom_transform
    }
    fn enable_phantom(&self) -> &bool {
        &self.enable_phantom
    }
    fn include_vehicles(&self) -> &bool {
        &self.include_vehicles
    }
    fn include_characters(&self) -> &bool {
        &self.include_characters
    }
    fn include_actors(&self) -> &bool {
        &self.include_actors
    }
}

impl super::entity::EntityDataTrait for PhantomEntityData {
}

impl super::entity::GameObjectDataTrait for PhantomEntityData {
}

impl super::core::DataBusPeerTrait for PhantomEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for PhantomEntityData {
}

impl super::core::DataContainerTrait for PhantomEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PHANTOMENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhantomEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PhantomEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MaterialOffsets",
                flags: MemberInfoFlags::new(144),
                field_type: "MaterialOffset-Array",
                rust_offset: offset_of!(PhantomEntityData, material_offsets),
            },
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(PhantomEntityData, realm),
            },
            FieldInfoData {
                name: "PositionOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(PhantomEntityData, position_offset),
            },
            FieldInfoData {
                name: "BoxSize",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(PhantomEntityData, box_size),
            },
            FieldInfoData {
                name: "AsyncQueryPointerAsset",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhantomEntityData, async_query_pointer_asset),
            },
            FieldInfoData {
                name: "PhantomTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(PhantomEntityData, phantom_transform),
            },
            FieldInfoData {
                name: "EnablePhantom",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PhantomEntityData, enable_phantom),
            },
            FieldInfoData {
                name: "IncludeVehicles",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PhantomEntityData, include_vehicles),
            },
            FieldInfoData {
                name: "IncludeCharacters",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PhantomEntityData, include_characters),
            },
            FieldInfoData {
                name: "IncludeActors",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PhantomEntityData, include_actors),
            },
        ],
    }),
    array_type: Some(PHANTOMENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PhantomEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PHANTOMENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PHANTOMENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhantomEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PhantomEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MaterialOffset {
    pub material: super::entity::MaterialDecl,
    pub offset: f32,
}

pub trait MaterialOffsetTrait: TypeObject {
    fn material(&self) -> &super::entity::MaterialDecl;
    fn offset(&self) -> &f32;
}

impl MaterialOffsetTrait for MaterialOffset {
    fn material(&self) -> &super::entity::MaterialDecl {
        &self.material
    }
    fn offset(&self) -> &f32 {
        &self.offset
    }
}

pub static MATERIALOFFSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MaterialOffset",
    flags: MemberInfoFlags::new(32841),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MaterialOffset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Material",
                flags: MemberInfoFlags::new(0),
                field_type: "MaterialDecl",
                rust_offset: offset_of!(MaterialOffset, material),
            },
            FieldInfoData {
                name: "Offset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MaterialOffset, offset),
            },
        ],
    }),
    array_type: Some(MATERIALOFFSET_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for MaterialOffset {
    fn type_info(&self) -> &'static TypeInfo {
        MATERIALOFFSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static MATERIALOFFSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MaterialOffset-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("MaterialOffset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct OwnerToQueryResultEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub output_filter: QueryEntityFilter,
}

pub trait OwnerToQueryResultEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn output_filter(&self) -> &QueryEntityFilter;
}

impl OwnerToQueryResultEntityDataTrait for OwnerToQueryResultEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn output_filter(&self) -> &QueryEntityFilter {
        &self.output_filter
    }
}

impl super::entity::EntityDataTrait for OwnerToQueryResultEntityData {
}

impl super::entity::GameObjectDataTrait for OwnerToQueryResultEntityData {
}

impl super::core::DataBusPeerTrait for OwnerToQueryResultEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for OwnerToQueryResultEntityData {
}

impl super::core::DataContainerTrait for OwnerToQueryResultEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static OWNERTOQUERYRESULTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OwnerToQueryResultEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<OwnerToQueryResultEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(OwnerToQueryResultEntityData, realm),
            },
            FieldInfoData {
                name: "OutputFilter",
                flags: MemberInfoFlags::new(0),
                field_type: "QueryEntityFilter",
                rust_offset: offset_of!(OwnerToQueryResultEntityData, output_filter),
            },
        ],
    }),
    array_type: Some(OWNERTOQUERYRESULTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for OwnerToQueryResultEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        OWNERTOQUERYRESULTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static OWNERTOQUERYRESULTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OwnerToQueryResultEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("OwnerToQueryResultEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct JointTransformQueryEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub always_enabled: bool,
    pub gameplay_bone: super::entity::GameplayBones,
    pub use_root_for_culled_animatable: bool,
    pub culled_offset: super::core::LinearTransform,
}

pub trait JointTransformQueryEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn always_enabled(&self) -> &bool;
    fn gameplay_bone(&self) -> &super::entity::GameplayBones;
    fn use_root_for_culled_animatable(&self) -> &bool;
    fn culled_offset(&self) -> &super::core::LinearTransform;
}

impl JointTransformQueryEntityDataTrait for JointTransformQueryEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn always_enabled(&self) -> &bool {
        &self.always_enabled
    }
    fn gameplay_bone(&self) -> &super::entity::GameplayBones {
        &self.gameplay_bone
    }
    fn use_root_for_culled_animatable(&self) -> &bool {
        &self.use_root_for_culled_animatable
    }
    fn culled_offset(&self) -> &super::core::LinearTransform {
        &self.culled_offset
    }
}

impl super::entity::EntityDataTrait for JointTransformQueryEntityData {
}

impl super::entity::GameObjectDataTrait for JointTransformQueryEntityData {
}

impl super::core::DataBusPeerTrait for JointTransformQueryEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for JointTransformQueryEntityData {
}

impl super::core::DataContainerTrait for JointTransformQueryEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static JOINTTRANSFORMQUERYENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "JointTransformQueryEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<JointTransformQueryEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(JointTransformQueryEntityData, realm),
            },
            FieldInfoData {
                name: "AlwaysEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(JointTransformQueryEntityData, always_enabled),
            },
            FieldInfoData {
                name: "GameplayBone",
                flags: MemberInfoFlags::new(0),
                field_type: "GameplayBones",
                rust_offset: offset_of!(JointTransformQueryEntityData, gameplay_bone),
            },
            FieldInfoData {
                name: "UseRootForCulledAnimatable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(JointTransformQueryEntityData, use_root_for_culled_animatable),
            },
            FieldInfoData {
                name: "CulledOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(JointTransformQueryEntityData, culled_offset),
            },
        ],
    }),
    array_type: Some(JOINTTRANSFORMQUERYENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for JointTransformQueryEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        JOINTTRANSFORMQUERYENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static JOINTTRANSFORMQUERYENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "JointTransformQueryEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("JointTransformQueryEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct InputQueryEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub action: i32,
    pub mouse_input_scale: f32,
    pub gamepad_input_scale: f32,
    pub enabled: bool,
    pub use_entity_correction_interface: bool,
    pub stateful_mouse_input_detection: bool,
}

pub trait InputQueryEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn action(&self) -> &i32;
    fn mouse_input_scale(&self) -> &f32;
    fn gamepad_input_scale(&self) -> &f32;
    fn enabled(&self) -> &bool;
    fn use_entity_correction_interface(&self) -> &bool;
    fn stateful_mouse_input_detection(&self) -> &bool;
}

impl InputQueryEntityDataTrait for InputQueryEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn action(&self) -> &i32 {
        &self.action
    }
    fn mouse_input_scale(&self) -> &f32 {
        &self.mouse_input_scale
    }
    fn gamepad_input_scale(&self) -> &f32 {
        &self.gamepad_input_scale
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn use_entity_correction_interface(&self) -> &bool {
        &self.use_entity_correction_interface
    }
    fn stateful_mouse_input_detection(&self) -> &bool {
        &self.stateful_mouse_input_detection
    }
}

impl super::entity::EntityDataTrait for InputQueryEntityData {
}

impl super::entity::GameObjectDataTrait for InputQueryEntityData {
}

impl super::core::DataBusPeerTrait for InputQueryEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for InputQueryEntityData {
}

impl super::core::DataContainerTrait for InputQueryEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static INPUTQUERYENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InputQueryEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<InputQueryEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(InputQueryEntityData, realm),
            },
            FieldInfoData {
                name: "Action",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(InputQueryEntityData, action),
            },
            FieldInfoData {
                name: "MouseInputScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(InputQueryEntityData, mouse_input_scale),
            },
            FieldInfoData {
                name: "GamepadInputScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(InputQueryEntityData, gamepad_input_scale),
            },
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(InputQueryEntityData, enabled),
            },
            FieldInfoData {
                name: "UseEntityCorrectionInterface",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(InputQueryEntityData, use_entity_correction_interface),
            },
            FieldInfoData {
                name: "StatefulMouseInputDetection",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(InputQueryEntityData, stateful_mouse_input_detection),
            },
        ],
    }),
    array_type: Some(INPUTQUERYENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for InputQueryEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        INPUTQUERYENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static INPUTQUERYENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InputQueryEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("InputQueryEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GameplayQueryBaseEntityData {
    pub _glacier_base: super::entity::EntityData,
}

pub trait GameplayQueryBaseEntityDataTrait: super::entity::EntityDataTrait {
}

impl GameplayQueryBaseEntityDataTrait for GameplayQueryBaseEntityData {
}

impl super::entity::EntityDataTrait for GameplayQueryBaseEntityData {
}

impl super::entity::GameObjectDataTrait for GameplayQueryBaseEntityData {
}

impl super::core::DataBusPeerTrait for GameplayQueryBaseEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for GameplayQueryBaseEntityData {
}

impl super::core::DataContainerTrait for GameplayQueryBaseEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static GAMEPLAYQUERYBASEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameplayQueryBaseEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GameplayQueryBaseEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(GAMEPLAYQUERYBASEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for GameplayQueryBaseEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        GAMEPLAYQUERYBASEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static GAMEPLAYQUERYBASEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameplayQueryBaseEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("GameplayQueryBaseEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FireProjectileEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub fire_projectile_data: FireProjectileEntityParameters,
    pub fire_projectile_data_list: Vec<FireProjectileEntityParameters>,
    pub shoot_space: super::core::LinearTransform,
    pub visual_shoot_space: super::core::LinearTransform,
    pub time_behind: f32,
    pub index: i32,
    pub is_critical_hit: bool,
    pub damage_multiplier: f32,
    pub explosion_damage_multiplier: f32,
    pub damage_giver: QueryEntityResult,
    pub excluded_physics: QueryEntityResult,
    pub is_remote_damage: bool,
}

pub trait FireProjectileEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn fire_projectile_data(&self) -> &FireProjectileEntityParameters;
    fn fire_projectile_data_list(&self) -> &Vec<FireProjectileEntityParameters>;
    fn shoot_space(&self) -> &super::core::LinearTransform;
    fn visual_shoot_space(&self) -> &super::core::LinearTransform;
    fn time_behind(&self) -> &f32;
    fn index(&self) -> &i32;
    fn is_critical_hit(&self) -> &bool;
    fn damage_multiplier(&self) -> &f32;
    fn explosion_damage_multiplier(&self) -> &f32;
    fn damage_giver(&self) -> &QueryEntityResult;
    fn excluded_physics(&self) -> &QueryEntityResult;
    fn is_remote_damage(&self) -> &bool;
}

impl FireProjectileEntityDataTrait for FireProjectileEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn fire_projectile_data(&self) -> &FireProjectileEntityParameters {
        &self.fire_projectile_data
    }
    fn fire_projectile_data_list(&self) -> &Vec<FireProjectileEntityParameters> {
        &self.fire_projectile_data_list
    }
    fn shoot_space(&self) -> &super::core::LinearTransform {
        &self.shoot_space
    }
    fn visual_shoot_space(&self) -> &super::core::LinearTransform {
        &self.visual_shoot_space
    }
    fn time_behind(&self) -> &f32 {
        &self.time_behind
    }
    fn index(&self) -> &i32 {
        &self.index
    }
    fn is_critical_hit(&self) -> &bool {
        &self.is_critical_hit
    }
    fn damage_multiplier(&self) -> &f32 {
        &self.damage_multiplier
    }
    fn explosion_damage_multiplier(&self) -> &f32 {
        &self.explosion_damage_multiplier
    }
    fn damage_giver(&self) -> &QueryEntityResult {
        &self.damage_giver
    }
    fn excluded_physics(&self) -> &QueryEntityResult {
        &self.excluded_physics
    }
    fn is_remote_damage(&self) -> &bool {
        &self.is_remote_damage
    }
}

impl super::entity::EntityDataTrait for FireProjectileEntityData {
}

impl super::entity::GameObjectDataTrait for FireProjectileEntityData {
}

impl super::core::DataBusPeerTrait for FireProjectileEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for FireProjectileEntityData {
}

impl super::core::DataContainerTrait for FireProjectileEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static FIREPROJECTILEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FireProjectileEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FireProjectileEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(FireProjectileEntityData, realm),
            },
            FieldInfoData {
                name: "FireProjectileData",
                flags: MemberInfoFlags::new(0),
                field_type: "FireProjectileEntityParameters",
                rust_offset: offset_of!(FireProjectileEntityData, fire_projectile_data),
            },
            FieldInfoData {
                name: "FireProjectileDataList",
                flags: MemberInfoFlags::new(144),
                field_type: "FireProjectileEntityParameters-Array",
                rust_offset: offset_of!(FireProjectileEntityData, fire_projectile_data_list),
            },
            FieldInfoData {
                name: "ShootSpace",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(FireProjectileEntityData, shoot_space),
            },
            FieldInfoData {
                name: "VisualShootSpace",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(FireProjectileEntityData, visual_shoot_space),
            },
            FieldInfoData {
                name: "TimeBehind",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FireProjectileEntityData, time_behind),
            },
            FieldInfoData {
                name: "Index",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(FireProjectileEntityData, index),
            },
            FieldInfoData {
                name: "IsCriticalHit",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FireProjectileEntityData, is_critical_hit),
            },
            FieldInfoData {
                name: "DamageMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FireProjectileEntityData, damage_multiplier),
            },
            FieldInfoData {
                name: "ExplosionDamageMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FireProjectileEntityData, explosion_damage_multiplier),
            },
            FieldInfoData {
                name: "DamageGiver",
                flags: MemberInfoFlags::new(0),
                field_type: "QueryEntityResult",
                rust_offset: offset_of!(FireProjectileEntityData, damage_giver),
            },
            FieldInfoData {
                name: "ExcludedPhysics",
                flags: MemberInfoFlags::new(0),
                field_type: "QueryEntityResult",
                rust_offset: offset_of!(FireProjectileEntityData, excluded_physics),
            },
            FieldInfoData {
                name: "IsRemoteDamage",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FireProjectileEntityData, is_remote_damage),
            },
        ],
    }),
    array_type: Some(FIREPROJECTILEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for FireProjectileEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        FIREPROJECTILEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static FIREPROJECTILEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FireProjectileEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("FireProjectileEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FireProjectileEntityOverrideData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub override_fire_projectile_data: bool,
    pub fire_projectile_data: FireProjectileEntityParameters,
    pub override_fire_projectile_data_list: bool,
    pub fire_projectile_data_list: Vec<FireProjectileEntityParameters>,
}

pub trait FireProjectileEntityOverrideDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn override_fire_projectile_data(&self) -> &bool;
    fn fire_projectile_data(&self) -> &FireProjectileEntityParameters;
    fn override_fire_projectile_data_list(&self) -> &bool;
    fn fire_projectile_data_list(&self) -> &Vec<FireProjectileEntityParameters>;
}

impl FireProjectileEntityOverrideDataTrait for FireProjectileEntityOverrideData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn override_fire_projectile_data(&self) -> &bool {
        &self.override_fire_projectile_data
    }
    fn fire_projectile_data(&self) -> &FireProjectileEntityParameters {
        &self.fire_projectile_data
    }
    fn override_fire_projectile_data_list(&self) -> &bool {
        &self.override_fire_projectile_data_list
    }
    fn fire_projectile_data_list(&self) -> &Vec<FireProjectileEntityParameters> {
        &self.fire_projectile_data_list
    }
}

impl super::entity::EntityDataTrait for FireProjectileEntityOverrideData {
}

impl super::entity::GameObjectDataTrait for FireProjectileEntityOverrideData {
}

impl super::core::DataBusPeerTrait for FireProjectileEntityOverrideData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for FireProjectileEntityOverrideData {
}

impl super::core::DataContainerTrait for FireProjectileEntityOverrideData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static FIREPROJECTILEENTITYOVERRIDEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FireProjectileEntityOverrideData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FireProjectileEntityOverrideData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(FireProjectileEntityOverrideData, realm),
            },
            FieldInfoData {
                name: "OverrideFireProjectileData",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FireProjectileEntityOverrideData, override_fire_projectile_data),
            },
            FieldInfoData {
                name: "FireProjectileData",
                flags: MemberInfoFlags::new(0),
                field_type: "FireProjectileEntityParameters",
                rust_offset: offset_of!(FireProjectileEntityOverrideData, fire_projectile_data),
            },
            FieldInfoData {
                name: "OverrideFireProjectileDataList",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FireProjectileEntityOverrideData, override_fire_projectile_data_list),
            },
            FieldInfoData {
                name: "FireProjectileDataList",
                flags: MemberInfoFlags::new(144),
                field_type: "FireProjectileEntityParameters-Array",
                rust_offset: offset_of!(FireProjectileEntityOverrideData, fire_projectile_data_list),
            },
        ],
    }),
    array_type: Some(FIREPROJECTILEENTITYOVERRIDEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FireProjectileEntityOverrideData {
    fn type_info(&self) -> &'static TypeInfo {
        FIREPROJECTILEENTITYOVERRIDEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static FIREPROJECTILEENTITYOVERRIDEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FireProjectileEntityOverrideData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("FireProjectileEntityOverrideData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FireProjectileEntityParameters {
    pub speed: f32,
    pub projectile_blueprint: Option<Arc<Mutex<dyn super::weapon_shared::ProjectileBlueprintTrait>>>,
    pub projectile_data: Option<Arc<Mutex<dyn super::weapon_shared::ProjectileEntityDataTrait>>>,
    pub unlock_asset: Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>>,
    pub spawn_visual_at_weapon_bone: bool,
}

pub trait FireProjectileEntityParametersTrait: TypeObject {
    fn speed(&self) -> &f32;
    fn projectile_blueprint(&self) -> &Option<Arc<Mutex<dyn super::weapon_shared::ProjectileBlueprintTrait>>>;
    fn projectile_data(&self) -> &Option<Arc<Mutex<dyn super::weapon_shared::ProjectileEntityDataTrait>>>;
    fn unlock_asset(&self) -> &Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>>;
    fn spawn_visual_at_weapon_bone(&self) -> &bool;
}

impl FireProjectileEntityParametersTrait for FireProjectileEntityParameters {
    fn speed(&self) -> &f32 {
        &self.speed
    }
    fn projectile_blueprint(&self) -> &Option<Arc<Mutex<dyn super::weapon_shared::ProjectileBlueprintTrait>>> {
        &self.projectile_blueprint
    }
    fn projectile_data(&self) -> &Option<Arc<Mutex<dyn super::weapon_shared::ProjectileEntityDataTrait>>> {
        &self.projectile_data
    }
    fn unlock_asset(&self) -> &Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>> {
        &self.unlock_asset
    }
    fn spawn_visual_at_weapon_bone(&self) -> &bool {
        &self.spawn_visual_at_weapon_bone
    }
}

pub static FIREPROJECTILEENTITYPARAMETERS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FireProjectileEntityParameters",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FireProjectileEntityParameters as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Speed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FireProjectileEntityParameters, speed),
            },
            FieldInfoData {
                name: "ProjectileBlueprint",
                flags: MemberInfoFlags::new(0),
                field_type: "ProjectileBlueprint",
                rust_offset: offset_of!(FireProjectileEntityParameters, projectile_blueprint),
            },
            FieldInfoData {
                name: "ProjectileData",
                flags: MemberInfoFlags::new(0),
                field_type: "ProjectileEntityData",
                rust_offset: offset_of!(FireProjectileEntityParameters, projectile_data),
            },
            FieldInfoData {
                name: "UnlockAsset",
                flags: MemberInfoFlags::new(0),
                field_type: "UnlockAssetBase",
                rust_offset: offset_of!(FireProjectileEntityParameters, unlock_asset),
            },
            FieldInfoData {
                name: "SpawnVisualAtWeaponBone",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FireProjectileEntityParameters, spawn_visual_at_weapon_bone),
            },
        ],
    }),
    array_type: Some(FIREPROJECTILEENTITYPARAMETERS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FireProjectileEntityParameters {
    fn type_info(&self) -> &'static TypeInfo {
        FIREPROJECTILEENTITYPARAMETERS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static FIREPROJECTILEENTITYPARAMETERS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FireProjectileEntityParameters-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("FireProjectileEntityParameters"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DealDamageEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub deal_damage_data: DealDamageEntityParameters,
    pub deal_damage_data_list: Vec<DealDamageEntityParameters>,
    pub damage_giver: QueryEntityResult,
    pub entities_to_damage: QueryEntityResult,
    pub damage_origin: super::core::Vec3,
    pub deal_damage_data_index: i32,
}

pub trait DealDamageEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn deal_damage_data(&self) -> &DealDamageEntityParameters;
    fn deal_damage_data_list(&self) -> &Vec<DealDamageEntityParameters>;
    fn damage_giver(&self) -> &QueryEntityResult;
    fn entities_to_damage(&self) -> &QueryEntityResult;
    fn damage_origin(&self) -> &super::core::Vec3;
    fn deal_damage_data_index(&self) -> &i32;
}

impl DealDamageEntityDataTrait for DealDamageEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn deal_damage_data(&self) -> &DealDamageEntityParameters {
        &self.deal_damage_data
    }
    fn deal_damage_data_list(&self) -> &Vec<DealDamageEntityParameters> {
        &self.deal_damage_data_list
    }
    fn damage_giver(&self) -> &QueryEntityResult {
        &self.damage_giver
    }
    fn entities_to_damage(&self) -> &QueryEntityResult {
        &self.entities_to_damage
    }
    fn damage_origin(&self) -> &super::core::Vec3 {
        &self.damage_origin
    }
    fn deal_damage_data_index(&self) -> &i32 {
        &self.deal_damage_data_index
    }
}

impl super::entity::EntityDataTrait for DealDamageEntityData {
}

impl super::entity::GameObjectDataTrait for DealDamageEntityData {
}

impl super::core::DataBusPeerTrait for DealDamageEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for DealDamageEntityData {
}

impl super::core::DataContainerTrait for DealDamageEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static DEALDAMAGEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DealDamageEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DealDamageEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(DealDamageEntityData, realm),
            },
            FieldInfoData {
                name: "DealDamageData",
                flags: MemberInfoFlags::new(0),
                field_type: "DealDamageEntityParameters",
                rust_offset: offset_of!(DealDamageEntityData, deal_damage_data),
            },
            FieldInfoData {
                name: "DealDamageDataList",
                flags: MemberInfoFlags::new(144),
                field_type: "DealDamageEntityParameters-Array",
                rust_offset: offset_of!(DealDamageEntityData, deal_damage_data_list),
            },
            FieldInfoData {
                name: "DamageGiver",
                flags: MemberInfoFlags::new(0),
                field_type: "QueryEntityResult",
                rust_offset: offset_of!(DealDamageEntityData, damage_giver),
            },
            FieldInfoData {
                name: "EntitiesToDamage",
                flags: MemberInfoFlags::new(0),
                field_type: "QueryEntityResult",
                rust_offset: offset_of!(DealDamageEntityData, entities_to_damage),
            },
            FieldInfoData {
                name: "DamageOrigin",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(DealDamageEntityData, damage_origin),
            },
            FieldInfoData {
                name: "DealDamageDataIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(DealDamageEntityData, deal_damage_data_index),
            },
        ],
    }),
    array_type: Some(DEALDAMAGEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for DealDamageEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        DEALDAMAGEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static DEALDAMAGEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DealDamageEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("DealDamageEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DealDamageEntityParameters {
    pub impulse_magnitude: f32,
    pub damage: f32,
    pub material_pair: super::entity::MaterialDecl,
    pub unlock_asset: Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>>,
}

pub trait DealDamageEntityParametersTrait: TypeObject {
    fn impulse_magnitude(&self) -> &f32;
    fn damage(&self) -> &f32;
    fn material_pair(&self) -> &super::entity::MaterialDecl;
    fn unlock_asset(&self) -> &Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>>;
}

impl DealDamageEntityParametersTrait for DealDamageEntityParameters {
    fn impulse_magnitude(&self) -> &f32 {
        &self.impulse_magnitude
    }
    fn damage(&self) -> &f32 {
        &self.damage
    }
    fn material_pair(&self) -> &super::entity::MaterialDecl {
        &self.material_pair
    }
    fn unlock_asset(&self) -> &Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>> {
        &self.unlock_asset
    }
}

pub static DEALDAMAGEENTITYPARAMETERS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DealDamageEntityParameters",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DealDamageEntityParameters as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ImpulseMagnitude",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DealDamageEntityParameters, impulse_magnitude),
            },
            FieldInfoData {
                name: "Damage",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DealDamageEntityParameters, damage),
            },
            FieldInfoData {
                name: "MaterialPair",
                flags: MemberInfoFlags::new(0),
                field_type: "MaterialDecl",
                rust_offset: offset_of!(DealDamageEntityParameters, material_pair),
            },
            FieldInfoData {
                name: "UnlockAsset",
                flags: MemberInfoFlags::new(0),
                field_type: "UnlockAssetBase",
                rust_offset: offset_of!(DealDamageEntityParameters, unlock_asset),
            },
        ],
    }),
    array_type: Some(DEALDAMAGEENTITYPARAMETERS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DealDamageEntityParameters {
    fn type_info(&self) -> &'static TypeInfo {
        DEALDAMAGEENTITYPARAMETERS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static DEALDAMAGEENTITYPARAMETERS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DealDamageEntityParameters-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("DealDamageEntityParameters"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlayerAbilityWeaponUpgradeSlotModifier {
    pub _glacier_base: PlayerAbilityModifier,
    pub identifier: u32,
    pub is_equipped_hash: u32,
    pub is_unlocked_hash: u32,
    pub player_ability_owner_id: u32,
    pub values: Vec<Option<Arc<Mutex<dyn SoldierWeaponUpgradeSlotModifierValueTrait>>>>,
    pub unlock: Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>>,
    pub force_equipped: bool,
}

pub trait PlayerAbilityWeaponUpgradeSlotModifierTrait: PlayerAbilityModifierTrait {
    fn identifier(&self) -> &u32;
    fn is_equipped_hash(&self) -> &u32;
    fn is_unlocked_hash(&self) -> &u32;
    fn player_ability_owner_id(&self) -> &u32;
    fn values(&self) -> &Vec<Option<Arc<Mutex<dyn SoldierWeaponUpgradeSlotModifierValueTrait>>>>;
    fn unlock(&self) -> &Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>>;
    fn force_equipped(&self) -> &bool;
}

impl PlayerAbilityWeaponUpgradeSlotModifierTrait for PlayerAbilityWeaponUpgradeSlotModifier {
    fn identifier(&self) -> &u32 {
        &self.identifier
    }
    fn is_equipped_hash(&self) -> &u32 {
        &self.is_equipped_hash
    }
    fn is_unlocked_hash(&self) -> &u32 {
        &self.is_unlocked_hash
    }
    fn player_ability_owner_id(&self) -> &u32 {
        &self.player_ability_owner_id
    }
    fn values(&self) -> &Vec<Option<Arc<Mutex<dyn SoldierWeaponUpgradeSlotModifierValueTrait>>>> {
        &self.values
    }
    fn unlock(&self) -> &Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>> {
        &self.unlock
    }
    fn force_equipped(&self) -> &bool {
        &self.force_equipped
    }
}

impl PlayerAbilityModifierTrait for PlayerAbilityWeaponUpgradeSlotModifier {
    fn required_unlock_id(&self) -> &u32 {
        self._glacier_base.required_unlock_id()
    }
}

impl super::core::DataContainerTrait for PlayerAbilityWeaponUpgradeSlotModifier {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PLAYERABILITYWEAPONUPGRADESLOTMODIFIER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityWeaponUpgradeSlotModifier",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PLAYERABILITYMODIFIER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayerAbilityWeaponUpgradeSlotModifier as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Identifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(PlayerAbilityWeaponUpgradeSlotModifier, identifier),
            },
            FieldInfoData {
                name: "IsEquippedHash",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(PlayerAbilityWeaponUpgradeSlotModifier, is_equipped_hash),
            },
            FieldInfoData {
                name: "IsUnlockedHash",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(PlayerAbilityWeaponUpgradeSlotModifier, is_unlocked_hash),
            },
            FieldInfoData {
                name: "PlayerAbilityOwnerId",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(PlayerAbilityWeaponUpgradeSlotModifier, player_ability_owner_id),
            },
            FieldInfoData {
                name: "Values",
                flags: MemberInfoFlags::new(144),
                field_type: "SoldierWeaponUpgradeSlotModifierValue-Array",
                rust_offset: offset_of!(PlayerAbilityWeaponUpgradeSlotModifier, values),
            },
            FieldInfoData {
                name: "Unlock",
                flags: MemberInfoFlags::new(0),
                field_type: "UnlockAssetBase",
                rust_offset: offset_of!(PlayerAbilityWeaponUpgradeSlotModifier, unlock),
            },
            FieldInfoData {
                name: "ForceEquipped",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayerAbilityWeaponUpgradeSlotModifier, force_equipped),
            },
        ],
    }),
    array_type: Some(PLAYERABILITYWEAPONUPGRADESLOTMODIFIER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PlayerAbilityWeaponUpgradeSlotModifier {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERABILITYWEAPONUPGRADESLOTMODIFIER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PLAYERABILITYWEAPONUPGRADESLOTMODIFIER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityWeaponUpgradeSlotModifier-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PlayerAbilityWeaponUpgradeSlotModifier"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoldierWeaponUpgradeSlotModifierValue {
    pub _glacier_base: super::core::DataContainer,
    pub modifier_unlocks: Vec<Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>>>,
    pub secondary_fire_ability: Option<Arc<Mutex<dyn PlayerAbilityAssetTrait>>>,
    pub secondary_fire_ability_id: u32,
    pub min_ability_level: PlayerAbilityLevel,
    pub max_ability_level: PlayerAbilityLevel,
}

pub trait SoldierWeaponUpgradeSlotModifierValueTrait: super::core::DataContainerTrait {
    fn modifier_unlocks(&self) -> &Vec<Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>>>;
    fn secondary_fire_ability(&self) -> &Option<Arc<Mutex<dyn PlayerAbilityAssetTrait>>>;
    fn secondary_fire_ability_id(&self) -> &u32;
    fn min_ability_level(&self) -> &PlayerAbilityLevel;
    fn max_ability_level(&self) -> &PlayerAbilityLevel;
}

impl SoldierWeaponUpgradeSlotModifierValueTrait for SoldierWeaponUpgradeSlotModifierValue {
    fn modifier_unlocks(&self) -> &Vec<Option<Arc<Mutex<dyn super::game_shared::UnlockAssetBaseTrait>>>> {
        &self.modifier_unlocks
    }
    fn secondary_fire_ability(&self) -> &Option<Arc<Mutex<dyn PlayerAbilityAssetTrait>>> {
        &self.secondary_fire_ability
    }
    fn secondary_fire_ability_id(&self) -> &u32 {
        &self.secondary_fire_ability_id
    }
    fn min_ability_level(&self) -> &PlayerAbilityLevel {
        &self.min_ability_level
    }
    fn max_ability_level(&self) -> &PlayerAbilityLevel {
        &self.max_ability_level
    }
}

impl super::core::DataContainerTrait for SoldierWeaponUpgradeSlotModifierValue {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SOLDIERWEAPONUPGRADESLOTMODIFIERVALUE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierWeaponUpgradeSlotModifierValue",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierWeaponUpgradeSlotModifierValue as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ModifierUnlocks",
                flags: MemberInfoFlags::new(144),
                field_type: "UnlockAssetBase-Array",
                rust_offset: offset_of!(SoldierWeaponUpgradeSlotModifierValue, modifier_unlocks),
            },
            FieldInfoData {
                name: "SecondaryFireAbility",
                flags: MemberInfoFlags::new(0),
                field_type: "PlayerAbilityAsset",
                rust_offset: offset_of!(SoldierWeaponUpgradeSlotModifierValue, secondary_fire_ability),
            },
            FieldInfoData {
                name: "SecondaryFireAbilityId",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(SoldierWeaponUpgradeSlotModifierValue, secondary_fire_ability_id),
            },
            FieldInfoData {
                name: "MinAbilityLevel",
                flags: MemberInfoFlags::new(0),
                field_type: "PlayerAbilityLevel",
                rust_offset: offset_of!(SoldierWeaponUpgradeSlotModifierValue, min_ability_level),
            },
            FieldInfoData {
                name: "MaxAbilityLevel",
                flags: MemberInfoFlags::new(0),
                field_type: "PlayerAbilityLevel",
                rust_offset: offset_of!(SoldierWeaponUpgradeSlotModifierValue, max_ability_level),
            },
        ],
    }),
    array_type: Some(SOLDIERWEAPONUPGRADESLOTMODIFIERVALUE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoldierWeaponUpgradeSlotModifierValue {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERWEAPONUPGRADESLOTMODIFIERVALUE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SOLDIERWEAPONUPGRADESLOTMODIFIERVALUE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierWeaponUpgradeSlotModifierValue-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("SoldierWeaponUpgradeSlotModifierValue"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlayerAbilityReferenceData {
    pub _glacier_base: super::entity::LogicReferenceObjectData,
    pub auto_create_abilities: bool,
    pub auto_create_player_abilities: Vec<Option<Arc<Mutex<dyn PlayerAbilityAssetTrait>>>>,
}

pub trait PlayerAbilityReferenceDataTrait: super::entity::LogicReferenceObjectDataTrait {
    fn auto_create_abilities(&self) -> &bool;
    fn auto_create_player_abilities(&self) -> &Vec<Option<Arc<Mutex<dyn PlayerAbilityAssetTrait>>>>;
}

impl PlayerAbilityReferenceDataTrait for PlayerAbilityReferenceData {
    fn auto_create_abilities(&self) -> &bool {
        &self.auto_create_abilities
    }
    fn auto_create_player_abilities(&self) -> &Vec<Option<Arc<Mutex<dyn PlayerAbilityAssetTrait>>>> {
        &self.auto_create_player_abilities
    }
}

impl super::entity::LogicReferenceObjectDataTrait for PlayerAbilityReferenceData {
    fn local_player_id(&self) -> &super::core::LocalPlayerId {
        self._glacier_base.local_player_id()
    }
    fn sub_realm(&self) -> &super::entity::SubRealm {
        self._glacier_base.sub_realm()
    }
}

impl super::entity::ReferenceObjectDataTrait for PlayerAbilityReferenceData {
    fn blueprint_transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.blueprint_transform()
    }
    fn blueprint(&self) -> &Option<Arc<Mutex<dyn super::entity::BlueprintTrait>>> {
        self._glacier_base.blueprint()
    }
    fn object_variation(&self) -> &Option<Arc<Mutex<dyn super::entity::ObjectVariationTrait>>> {
        self._glacier_base.object_variation()
    }
    fn stream_realm(&self) -> &super::entity::StreamRealm {
        self._glacier_base.stream_realm()
    }
    fn radiosity_type_override(&self) -> &super::core::RadiosityTypeOverride {
        self._glacier_base.radiosity_type_override()
    }
    fn lightmap_resolution_scale(&self) -> &u32 {
        self._glacier_base.lightmap_resolution_scale()
    }
    fn lightmap_scale_with_size(&self) -> &bool {
        self._glacier_base.lightmap_scale_with_size()
    }
    fn rendering_overrides(&self) -> &super::core::RenderingOverrides {
        self._glacier_base.rendering_overrides()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn create_indestructible_entity(&self) -> &bool {
        self._glacier_base.create_indestructible_entity()
    }
}

impl super::entity::GameObjectDataTrait for PlayerAbilityReferenceData {
}

impl super::core::DataBusPeerTrait for PlayerAbilityReferenceData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for PlayerAbilityReferenceData {
}

impl super::core::DataContainerTrait for PlayerAbilityReferenceData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PLAYERABILITYREFERENCEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityReferenceData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::LOGICREFERENCEOBJECTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayerAbilityReferenceData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AutoCreateAbilities",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayerAbilityReferenceData, auto_create_abilities),
            },
            FieldInfoData {
                name: "AutoCreatePlayerAbilities",
                flags: MemberInfoFlags::new(144),
                field_type: "PlayerAbilityAsset-Array",
                rust_offset: offset_of!(PlayerAbilityReferenceData, auto_create_player_abilities),
            },
        ],
    }),
    array_type: Some(PLAYERABILITYREFERENCEDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PlayerAbilityReferenceData {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERABILITYREFERENCEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PLAYERABILITYREFERENCEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerAbilityReferenceData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("PlayerAbilityReferenceData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ClientAudioVehicleEngineParametersEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub use_first_person_sounds: bool,
    pub enabled: bool,
}

pub trait ClientAudioVehicleEngineParametersEntityDataTrait: super::entity::EntityDataTrait {
    fn use_first_person_sounds(&self) -> &bool;
    fn enabled(&self) -> &bool;
}

impl ClientAudioVehicleEngineParametersEntityDataTrait for ClientAudioVehicleEngineParametersEntityData {
    fn use_first_person_sounds(&self) -> &bool {
        &self.use_first_person_sounds
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
}

impl super::entity::EntityDataTrait for ClientAudioVehicleEngineParametersEntityData {
}

impl super::entity::GameObjectDataTrait for ClientAudioVehicleEngineParametersEntityData {
}

impl super::core::DataBusPeerTrait for ClientAudioVehicleEngineParametersEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for ClientAudioVehicleEngineParametersEntityData {
}

impl super::core::DataContainerTrait for ClientAudioVehicleEngineParametersEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CLIENTAUDIOVEHICLEENGINEPARAMETERSENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClientAudioVehicleEngineParametersEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ClientAudioVehicleEngineParametersEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "UseFirstPersonSounds",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ClientAudioVehicleEngineParametersEntityData, use_first_person_sounds),
            },
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ClientAudioVehicleEngineParametersEntityData, enabled),
            },
        ],
    }),
    array_type: Some(CLIENTAUDIOVEHICLEENGINEPARAMETERSENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ClientAudioVehicleEngineParametersEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CLIENTAUDIOVEHICLEENGINEPARAMETERSENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CLIENTAUDIOVEHICLEENGINEPARAMETERSENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClientAudioVehicleEngineParametersEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("ClientAudioVehicleEngineParametersEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AudioWheelLogicEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub delta_threshold_for_heavy_impact: f32,
    pub delta_threshold_for_light_impact: f32,
    pub enable_impact_events_on_creation: bool,
    pub output_surface_loops: bool,
    pub default_surface_wave_data: WheelSurfaceWaveData,
    pub time_on_surface_threshold: f32,
    pub is_spinning_threshold: f32,
    pub is_moving_threshold: f32,
    pub culling_distance: f32,
}

pub trait AudioWheelLogicEntityDataTrait: super::entity::EntityDataTrait {
    fn delta_threshold_for_heavy_impact(&self) -> &f32;
    fn delta_threshold_for_light_impact(&self) -> &f32;
    fn enable_impact_events_on_creation(&self) -> &bool;
    fn output_surface_loops(&self) -> &bool;
    fn default_surface_wave_data(&self) -> &WheelSurfaceWaveData;
    fn time_on_surface_threshold(&self) -> &f32;
    fn is_spinning_threshold(&self) -> &f32;
    fn is_moving_threshold(&self) -> &f32;
    fn culling_distance(&self) -> &f32;
}

impl AudioWheelLogicEntityDataTrait for AudioWheelLogicEntityData {
    fn delta_threshold_for_heavy_impact(&self) -> &f32 {
        &self.delta_threshold_for_heavy_impact
    }
    fn delta_threshold_for_light_impact(&self) -> &f32 {
        &self.delta_threshold_for_light_impact
    }
    fn enable_impact_events_on_creation(&self) -> &bool {
        &self.enable_impact_events_on_creation
    }
    fn output_surface_loops(&self) -> &bool {
        &self.output_surface_loops
    }
    fn default_surface_wave_data(&self) -> &WheelSurfaceWaveData {
        &self.default_surface_wave_data
    }
    fn time_on_surface_threshold(&self) -> &f32 {
        &self.time_on_surface_threshold
    }
    fn is_spinning_threshold(&self) -> &f32 {
        &self.is_spinning_threshold
    }
    fn is_moving_threshold(&self) -> &f32 {
        &self.is_moving_threshold
    }
    fn culling_distance(&self) -> &f32 {
        &self.culling_distance
    }
}

impl super::entity::EntityDataTrait for AudioWheelLogicEntityData {
}

impl super::entity::GameObjectDataTrait for AudioWheelLogicEntityData {
}

impl super::core::DataBusPeerTrait for AudioWheelLogicEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for AudioWheelLogicEntityData {
}

impl super::core::DataContainerTrait for AudioWheelLogicEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static AUDIOWHEELLOGICENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioWheelLogicEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AudioWheelLogicEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DeltaThresholdForHeavyImpact",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AudioWheelLogicEntityData, delta_threshold_for_heavy_impact),
            },
            FieldInfoData {
                name: "DeltaThresholdForLightImpact",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AudioWheelLogicEntityData, delta_threshold_for_light_impact),
            },
            FieldInfoData {
                name: "EnableImpactEventsOnCreation",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AudioWheelLogicEntityData, enable_impact_events_on_creation),
            },
            FieldInfoData {
                name: "OutputSurfaceLoops",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AudioWheelLogicEntityData, output_surface_loops),
            },
            FieldInfoData {
                name: "DefaultSurfaceWaveData",
                flags: MemberInfoFlags::new(0),
                field_type: "WheelSurfaceWaveData",
                rust_offset: offset_of!(AudioWheelLogicEntityData, default_surface_wave_data),
            },
            FieldInfoData {
                name: "TimeOnSurfaceThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AudioWheelLogicEntityData, time_on_surface_threshold),
            },
            FieldInfoData {
                name: "IsSpinningThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AudioWheelLogicEntityData, is_spinning_threshold),
            },
            FieldInfoData {
                name: "IsMovingThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AudioWheelLogicEntityData, is_moving_threshold),
            },
            FieldInfoData {
                name: "CullingDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AudioWheelLogicEntityData, culling_distance),
            },
        ],
    }),
    array_type: Some(AUDIOWHEELLOGICENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AudioWheelLogicEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AUDIOWHEELLOGICENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static AUDIOWHEELLOGICENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioWheelLogicEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("AudioWheelLogicEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AudioRaycastInfoEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub use_default_material_when_no_material: bool,
    pub trigger_on_property_change: bool,
    pub input_raycast_result: RaycastEntityResult,
}

pub trait AudioRaycastInfoEntityDataTrait: super::entity::EntityDataTrait {
    fn use_default_material_when_no_material(&self) -> &bool;
    fn trigger_on_property_change(&self) -> &bool;
    fn input_raycast_result(&self) -> &RaycastEntityResult;
}

impl AudioRaycastInfoEntityDataTrait for AudioRaycastInfoEntityData {
    fn use_default_material_when_no_material(&self) -> &bool {
        &self.use_default_material_when_no_material
    }
    fn trigger_on_property_change(&self) -> &bool {
        &self.trigger_on_property_change
    }
    fn input_raycast_result(&self) -> &RaycastEntityResult {
        &self.input_raycast_result
    }
}

impl super::entity::EntityDataTrait for AudioRaycastInfoEntityData {
}

impl super::entity::GameObjectDataTrait for AudioRaycastInfoEntityData {
}

impl super::core::DataBusPeerTrait for AudioRaycastInfoEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for AudioRaycastInfoEntityData {
}

impl super::core::DataContainerTrait for AudioRaycastInfoEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static AUDIORAYCASTINFOENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioRaycastInfoEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AudioRaycastInfoEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "UseDefaultMaterialWhenNoMaterial",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AudioRaycastInfoEntityData, use_default_material_when_no_material),
            },
            FieldInfoData {
                name: "TriggerOnPropertyChange",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AudioRaycastInfoEntityData, trigger_on_property_change),
            },
            FieldInfoData {
                name: "InputRaycastResult",
                flags: MemberInfoFlags::new(0),
                field_type: "RaycastEntityResult",
                rust_offset: offset_of!(AudioRaycastInfoEntityData, input_raycast_result),
            },
        ],
    }),
    array_type: Some(AUDIORAYCASTINFOENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AudioRaycastInfoEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AUDIORAYCASTINFOENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static AUDIORAYCASTINFOENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioRaycastInfoEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("AudioRaycastInfoEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AudioRaycastCalculationEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub input_rays_properties: Vec<RayCalculationProperties>,
    pub number_of_accumulation_frames: u32,
    pub enable_max_indooriness_modifier_ray: bool,
    pub max_indooriness_modifier_ray_index: u32,
    pub clamp_raycasts_at_max_distance: bool,
    pub return_max_distance_if_no_rays_hitting: bool,
    pub use_first_dominant_material: bool,
    pub material_sound_id_when_no_dominant: i32,
    pub take_default_material_when_no_material: bool,
    pub output_hit_sound_materials: Vec<RayHitMaterials>,
    pub continuous_update: bool,
    pub indooriness_exponentiality: f32,
    pub max_indooriness_modifier_ray_value: f32,
}

pub trait AudioRaycastCalculationEntityDataTrait: super::entity::EntityDataTrait {
    fn input_rays_properties(&self) -> &Vec<RayCalculationProperties>;
    fn number_of_accumulation_frames(&self) -> &u32;
    fn enable_max_indooriness_modifier_ray(&self) -> &bool;
    fn max_indooriness_modifier_ray_index(&self) -> &u32;
    fn clamp_raycasts_at_max_distance(&self) -> &bool;
    fn return_max_distance_if_no_rays_hitting(&self) -> &bool;
    fn use_first_dominant_material(&self) -> &bool;
    fn material_sound_id_when_no_dominant(&self) -> &i32;
    fn take_default_material_when_no_material(&self) -> &bool;
    fn output_hit_sound_materials(&self) -> &Vec<RayHitMaterials>;
    fn continuous_update(&self) -> &bool;
    fn indooriness_exponentiality(&self) -> &f32;
    fn max_indooriness_modifier_ray_value(&self) -> &f32;
}

impl AudioRaycastCalculationEntityDataTrait for AudioRaycastCalculationEntityData {
    fn input_rays_properties(&self) -> &Vec<RayCalculationProperties> {
        &self.input_rays_properties
    }
    fn number_of_accumulation_frames(&self) -> &u32 {
        &self.number_of_accumulation_frames
    }
    fn enable_max_indooriness_modifier_ray(&self) -> &bool {
        &self.enable_max_indooriness_modifier_ray
    }
    fn max_indooriness_modifier_ray_index(&self) -> &u32 {
        &self.max_indooriness_modifier_ray_index
    }
    fn clamp_raycasts_at_max_distance(&self) -> &bool {
        &self.clamp_raycasts_at_max_distance
    }
    fn return_max_distance_if_no_rays_hitting(&self) -> &bool {
        &self.return_max_distance_if_no_rays_hitting
    }
    fn use_first_dominant_material(&self) -> &bool {
        &self.use_first_dominant_material
    }
    fn material_sound_id_when_no_dominant(&self) -> &i32 {
        &self.material_sound_id_when_no_dominant
    }
    fn take_default_material_when_no_material(&self) -> &bool {
        &self.take_default_material_when_no_material
    }
    fn output_hit_sound_materials(&self) -> &Vec<RayHitMaterials> {
        &self.output_hit_sound_materials
    }
    fn continuous_update(&self) -> &bool {
        &self.continuous_update
    }
    fn indooriness_exponentiality(&self) -> &f32 {
        &self.indooriness_exponentiality
    }
    fn max_indooriness_modifier_ray_value(&self) -> &f32 {
        &self.max_indooriness_modifier_ray_value
    }
}

impl super::entity::EntityDataTrait for AudioRaycastCalculationEntityData {
}

impl super::entity::GameObjectDataTrait for AudioRaycastCalculationEntityData {
}

impl super::core::DataBusPeerTrait for AudioRaycastCalculationEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for AudioRaycastCalculationEntityData {
}

impl super::core::DataContainerTrait for AudioRaycastCalculationEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static AUDIORAYCASTCALCULATIONENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioRaycastCalculationEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AudioRaycastCalculationEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "InputRaysProperties",
                flags: MemberInfoFlags::new(144),
                field_type: "RayCalculationProperties-Array",
                rust_offset: offset_of!(AudioRaycastCalculationEntityData, input_rays_properties),
            },
            FieldInfoData {
                name: "NumberOfAccumulationFrames",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(AudioRaycastCalculationEntityData, number_of_accumulation_frames),
            },
            FieldInfoData {
                name: "EnableMaxIndoorinessModifierRay",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AudioRaycastCalculationEntityData, enable_max_indooriness_modifier_ray),
            },
            FieldInfoData {
                name: "MaxIndoorinessModifierRayIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(AudioRaycastCalculationEntityData, max_indooriness_modifier_ray_index),
            },
            FieldInfoData {
                name: "ClampRaycastsAtMaxDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AudioRaycastCalculationEntityData, clamp_raycasts_at_max_distance),
            },
            FieldInfoData {
                name: "ReturnMaxDistanceIfNoRaysHitting",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AudioRaycastCalculationEntityData, return_max_distance_if_no_rays_hitting),
            },
            FieldInfoData {
                name: "UseFirstDominantMaterial",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AudioRaycastCalculationEntityData, use_first_dominant_material),
            },
            FieldInfoData {
                name: "MaterialSoundIdWhenNoDominant",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AudioRaycastCalculationEntityData, material_sound_id_when_no_dominant),
            },
            FieldInfoData {
                name: "TakeDefaultMaterialWhenNoMaterial",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AudioRaycastCalculationEntityData, take_default_material_when_no_material),
            },
            FieldInfoData {
                name: "OutputHitSoundMaterials",
                flags: MemberInfoFlags::new(144),
                field_type: "RayHitMaterials-Array",
                rust_offset: offset_of!(AudioRaycastCalculationEntityData, output_hit_sound_materials),
            },
            FieldInfoData {
                name: "ContinuousUpdate",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AudioRaycastCalculationEntityData, continuous_update),
            },
            FieldInfoData {
                name: "IndoorinessExponentiality",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AudioRaycastCalculationEntityData, indooriness_exponentiality),
            },
            FieldInfoData {
                name: "MaxIndoorinessModifierRayValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AudioRaycastCalculationEntityData, max_indooriness_modifier_ray_value),
            },
        ],
    }),
    array_type: Some(AUDIORAYCASTCALCULATIONENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AudioRaycastCalculationEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AUDIORAYCASTCALCULATIONENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static AUDIORAYCASTCALCULATIONENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioRaycastCalculationEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("AudioRaycastCalculationEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RayHitMaterials {
    pub sound_material_name: String,
    pub sound_material_i_d: u32,
}

pub trait RayHitMaterialsTrait: TypeObject {
    fn sound_material_name(&self) -> &String;
    fn sound_material_i_d(&self) -> &u32;
}

impl RayHitMaterialsTrait for RayHitMaterials {
    fn sound_material_name(&self) -> &String {
        &self.sound_material_name
    }
    fn sound_material_i_d(&self) -> &u32 {
        &self.sound_material_i_d
    }
}

pub static RAYHITMATERIALS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RayHitMaterials",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RayHitMaterials as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SoundMaterialName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(RayHitMaterials, sound_material_name),
            },
            FieldInfoData {
                name: "SoundMaterialID",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(RayHitMaterials, sound_material_i_d),
            },
        ],
    }),
    array_type: Some(RAYHITMATERIALS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RayHitMaterials {
    fn type_info(&self) -> &'static TypeInfo {
        RAYHITMATERIALS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static RAYHITMATERIALS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RayHitMaterials-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("RayHitMaterials"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RayCalculationProperties {
    pub ray_name: String,
    pub ray_weight: f32,
    pub ray_max_distance_limit_enabled: bool,
    pub ray_max_distance_limit: f32,
}

pub trait RayCalculationPropertiesTrait: TypeObject {
    fn ray_name(&self) -> &String;
    fn ray_weight(&self) -> &f32;
    fn ray_max_distance_limit_enabled(&self) -> &bool;
    fn ray_max_distance_limit(&self) -> &f32;
}

impl RayCalculationPropertiesTrait for RayCalculationProperties {
    fn ray_name(&self) -> &String {
        &self.ray_name
    }
    fn ray_weight(&self) -> &f32 {
        &self.ray_weight
    }
    fn ray_max_distance_limit_enabled(&self) -> &bool {
        &self.ray_max_distance_limit_enabled
    }
    fn ray_max_distance_limit(&self) -> &f32 {
        &self.ray_max_distance_limit
    }
}

pub static RAYCALCULATIONPROPERTIES_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RayCalculationProperties",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RayCalculationProperties as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "RayName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(RayCalculationProperties, ray_name),
            },
            FieldInfoData {
                name: "RayWeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RayCalculationProperties, ray_weight),
            },
            FieldInfoData {
                name: "RayMaxDistanceLimitEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RayCalculationProperties, ray_max_distance_limit_enabled),
            },
            FieldInfoData {
                name: "RayMaxDistanceLimit",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RayCalculationProperties, ray_max_distance_limit),
            },
        ],
    }),
    array_type: Some(RAYCALCULATIONPROPERTIES_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RayCalculationProperties {
    fn type_info(&self) -> &'static TypeInfo {
        RAYCALCULATIONPROPERTIES_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static RAYCALCULATIONPROPERTIES_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RayCalculationProperties-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("RayCalculationProperties"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct InformAnimationOfPhysicsStateEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub always_enabled: bool,
    pub per_animatable_binding: InformAnimationOfPhysicsPerAnimatableBinding,
    pub common_binding: InformAnimationOfPhysicsCommonBinding,
    pub use_spine_x_for1p: bool,
    pub animation_entity_space_priority: i32,
}

pub trait InformAnimationOfPhysicsStateEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn always_enabled(&self) -> &bool;
    fn per_animatable_binding(&self) -> &InformAnimationOfPhysicsPerAnimatableBinding;
    fn common_binding(&self) -> &InformAnimationOfPhysicsCommonBinding;
    fn use_spine_x_for1p(&self) -> &bool;
    fn animation_entity_space_priority(&self) -> &i32;
}

impl InformAnimationOfPhysicsStateEntityDataTrait for InformAnimationOfPhysicsStateEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn always_enabled(&self) -> &bool {
        &self.always_enabled
    }
    fn per_animatable_binding(&self) -> &InformAnimationOfPhysicsPerAnimatableBinding {
        &self.per_animatable_binding
    }
    fn common_binding(&self) -> &InformAnimationOfPhysicsCommonBinding {
        &self.common_binding
    }
    fn use_spine_x_for1p(&self) -> &bool {
        &self.use_spine_x_for1p
    }
    fn animation_entity_space_priority(&self) -> &i32 {
        &self.animation_entity_space_priority
    }
}

impl super::entity::EntityDataTrait for InformAnimationOfPhysicsStateEntityData {
}

impl super::entity::GameObjectDataTrait for InformAnimationOfPhysicsStateEntityData {
}

impl super::core::DataBusPeerTrait for InformAnimationOfPhysicsStateEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for InformAnimationOfPhysicsStateEntityData {
}

impl super::core::DataContainerTrait for InformAnimationOfPhysicsStateEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static INFORMANIMATIONOFPHYSICSSTATEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InformAnimationOfPhysicsStateEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<InformAnimationOfPhysicsStateEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(InformAnimationOfPhysicsStateEntityData, realm),
            },
            FieldInfoData {
                name: "AlwaysEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(InformAnimationOfPhysicsStateEntityData, always_enabled),
            },
            FieldInfoData {
                name: "PerAnimatableBinding",
                flags: MemberInfoFlags::new(0),
                field_type: "InformAnimationOfPhysicsPerAnimatableBinding",
                rust_offset: offset_of!(InformAnimationOfPhysicsStateEntityData, per_animatable_binding),
            },
            FieldInfoData {
                name: "CommonBinding",
                flags: MemberInfoFlags::new(0),
                field_type: "InformAnimationOfPhysicsCommonBinding",
                rust_offset: offset_of!(InformAnimationOfPhysicsStateEntityData, common_binding),
            },
            FieldInfoData {
                name: "UseSpineXFor1p",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(InformAnimationOfPhysicsStateEntityData, use_spine_x_for1p),
            },
            FieldInfoData {
                name: "AnimationEntitySpacePriority",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(InformAnimationOfPhysicsStateEntityData, animation_entity_space_priority),
            },
        ],
    }),
    array_type: Some(INFORMANIMATIONOFPHYSICSSTATEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for InformAnimationOfPhysicsStateEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        INFORMANIMATIONOFPHYSICSSTATEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static INFORMANIMATIONOFPHYSICSSTATEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InformAnimationOfPhysicsStateEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("InformAnimationOfPhysicsStateEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct InformAnimationOfPhysicsCommonBinding {
    pub aim_left_right: super::ant::AntRef,
    pub aim_up_down: super::ant::AntRef,
    pub crouch: super::ant::AntRef,
    pub in_air: super::ant::AntRef,
    pub skydive: super::ant::AntRef,
    pub parachute: super::ant::AntRef,
    pub swim: super::ant::AntRef,
    pub physics_state: super::ant::AntRef,
    pub input_backward: super::ant::AntRef,
    pub input_forward: super::ant::AntRef,
    pub input_left: super::ant::AntRef,
    pub input_right: super::ant::AntRef,
    pub input_exclusive_backward: super::ant::AntRef,
    pub input_exclusive_forward: super::ant::AntRef,
    pub input_exclusive_left: super::ant::AntRef,
    pub input_exclusive_right: super::ant::AntRef,
    pub is_enemy: super::ant::AntRef,
    pub jump: super::ant::AntRef,
    pub lean_left_right: super::ant::AntRef,
    pub prone: super::ant::AntRef,
    pub sprint: super::ant::AntRef,
    pub ground_supported: super::ant::AntRef,
    pub ground_normal: super::ant::AntRef,
    pub ground_distance: super::ant::AntRef,
    pub ground_angle_z: super::ant::AntRef,
    pub ground_angle_x: super::ant::AntRef,
    pub ground_angle_from_normal: super::ant::AntRef,
    pub ground_left_angle_from_normal: super::ant::AntRef,
    pub is_client_animatable: super::ant::AntRef,
    pub vertical_impact: super::ant::AntRef,
    pub vertical_impact_speed: super::ant::AntRef,
    pub false_signal: super::ant::AntRef,
    pub wind_direction: super::ant::AntRef,
    pub wind_strength: super::ant::AntRef,
    pub water_depth: super::ant::AntRef,
    pub eye_water_depth: super::ant::AntRef,
    pub desired_relative_movement_angle: super::ant::AntRef,
}

pub trait InformAnimationOfPhysicsCommonBindingTrait: TypeObject {
    fn aim_left_right(&self) -> &super::ant::AntRef;
    fn aim_up_down(&self) -> &super::ant::AntRef;
    fn crouch(&self) -> &super::ant::AntRef;
    fn in_air(&self) -> &super::ant::AntRef;
    fn skydive(&self) -> &super::ant::AntRef;
    fn parachute(&self) -> &super::ant::AntRef;
    fn swim(&self) -> &super::ant::AntRef;
    fn physics_state(&self) -> &super::ant::AntRef;
    fn input_backward(&self) -> &super::ant::AntRef;
    fn input_forward(&self) -> &super::ant::AntRef;
    fn input_left(&self) -> &super::ant::AntRef;
    fn input_right(&self) -> &super::ant::AntRef;
    fn input_exclusive_backward(&self) -> &super::ant::AntRef;
    fn input_exclusive_forward(&self) -> &super::ant::AntRef;
    fn input_exclusive_left(&self) -> &super::ant::AntRef;
    fn input_exclusive_right(&self) -> &super::ant::AntRef;
    fn is_enemy(&self) -> &super::ant::AntRef;
    fn jump(&self) -> &super::ant::AntRef;
    fn lean_left_right(&self) -> &super::ant::AntRef;
    fn prone(&self) -> &super::ant::AntRef;
    fn sprint(&self) -> &super::ant::AntRef;
    fn ground_supported(&self) -> &super::ant::AntRef;
    fn ground_normal(&self) -> &super::ant::AntRef;
    fn ground_distance(&self) -> &super::ant::AntRef;
    fn ground_angle_z(&self) -> &super::ant::AntRef;
    fn ground_angle_x(&self) -> &super::ant::AntRef;
    fn ground_angle_from_normal(&self) -> &super::ant::AntRef;
    fn ground_left_angle_from_normal(&self) -> &super::ant::AntRef;
    fn is_client_animatable(&self) -> &super::ant::AntRef;
    fn vertical_impact(&self) -> &super::ant::AntRef;
    fn vertical_impact_speed(&self) -> &super::ant::AntRef;
    fn false_signal(&self) -> &super::ant::AntRef;
    fn wind_direction(&self) -> &super::ant::AntRef;
    fn wind_strength(&self) -> &super::ant::AntRef;
    fn water_depth(&self) -> &super::ant::AntRef;
    fn eye_water_depth(&self) -> &super::ant::AntRef;
    fn desired_relative_movement_angle(&self) -> &super::ant::AntRef;
}

impl InformAnimationOfPhysicsCommonBindingTrait for InformAnimationOfPhysicsCommonBinding {
    fn aim_left_right(&self) -> &super::ant::AntRef {
        &self.aim_left_right
    }
    fn aim_up_down(&self) -> &super::ant::AntRef {
        &self.aim_up_down
    }
    fn crouch(&self) -> &super::ant::AntRef {
        &self.crouch
    }
    fn in_air(&self) -> &super::ant::AntRef {
        &self.in_air
    }
    fn skydive(&self) -> &super::ant::AntRef {
        &self.skydive
    }
    fn parachute(&self) -> &super::ant::AntRef {
        &self.parachute
    }
    fn swim(&self) -> &super::ant::AntRef {
        &self.swim
    }
    fn physics_state(&self) -> &super::ant::AntRef {
        &self.physics_state
    }
    fn input_backward(&self) -> &super::ant::AntRef {
        &self.input_backward
    }
    fn input_forward(&self) -> &super::ant::AntRef {
        &self.input_forward
    }
    fn input_left(&self) -> &super::ant::AntRef {
        &self.input_left
    }
    fn input_right(&self) -> &super::ant::AntRef {
        &self.input_right
    }
    fn input_exclusive_backward(&self) -> &super::ant::AntRef {
        &self.input_exclusive_backward
    }
    fn input_exclusive_forward(&self) -> &super::ant::AntRef {
        &self.input_exclusive_forward
    }
    fn input_exclusive_left(&self) -> &super::ant::AntRef {
        &self.input_exclusive_left
    }
    fn input_exclusive_right(&self) -> &super::ant::AntRef {
        &self.input_exclusive_right
    }
    fn is_enemy(&self) -> &super::ant::AntRef {
        &self.is_enemy
    }
    fn jump(&self) -> &super::ant::AntRef {
        &self.jump
    }
    fn lean_left_right(&self) -> &super::ant::AntRef {
        &self.lean_left_right
    }
    fn prone(&self) -> &super::ant::AntRef {
        &self.prone
    }
    fn sprint(&self) -> &super::ant::AntRef {
        &self.sprint
    }
    fn ground_supported(&self) -> &super::ant::AntRef {
        &self.ground_supported
    }
    fn ground_normal(&self) -> &super::ant::AntRef {
        &self.ground_normal
    }
    fn ground_distance(&self) -> &super::ant::AntRef {
        &self.ground_distance
    }
    fn ground_angle_z(&self) -> &super::ant::AntRef {
        &self.ground_angle_z
    }
    fn ground_angle_x(&self) -> &super::ant::AntRef {
        &self.ground_angle_x
    }
    fn ground_angle_from_normal(&self) -> &super::ant::AntRef {
        &self.ground_angle_from_normal
    }
    fn ground_left_angle_from_normal(&self) -> &super::ant::AntRef {
        &self.ground_left_angle_from_normal
    }
    fn is_client_animatable(&self) -> &super::ant::AntRef {
        &self.is_client_animatable
    }
    fn vertical_impact(&self) -> &super::ant::AntRef {
        &self.vertical_impact
    }
    fn vertical_impact_speed(&self) -> &super::ant::AntRef {
        &self.vertical_impact_speed
    }
    fn false_signal(&self) -> &super::ant::AntRef {
        &self.false_signal
    }
    fn wind_direction(&self) -> &super::ant::AntRef {
        &self.wind_direction
    }
    fn wind_strength(&self) -> &super::ant::AntRef {
        &self.wind_strength
    }
    fn water_depth(&self) -> &super::ant::AntRef {
        &self.water_depth
    }
    fn eye_water_depth(&self) -> &super::ant::AntRef {
        &self.eye_water_depth
    }
    fn desired_relative_movement_angle(&self) -> &super::ant::AntRef {
        &self.desired_relative_movement_angle
    }
}

pub static INFORMANIMATIONOFPHYSICSCOMMONBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InformAnimationOfPhysicsCommonBinding",
    flags: MemberInfoFlags::new(32841),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<InformAnimationOfPhysicsCommonBinding as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AimLeftRight",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(InformAnimationOfPhysicsCommonBinding, aim_left_right),
            },
            FieldInfoData {
                name: "AimUpDown",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(InformAnimationOfPhysicsCommonBinding, aim_up_down),
            },
            FieldInfoData {
                name: "Crouch",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(InformAnimationOfPhysicsCommonBinding, crouch),
            },
            FieldInfoData {
                name: "InAir",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(InformAnimationOfPhysicsCommonBinding, in_air),
            },
            FieldInfoData {
                name: "Skydive",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(InformAnimationOfPhysicsCommonBinding, skydive),
            },
            FieldInfoData {
                name: "Parachute",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(InformAnimationOfPhysicsCommonBinding, parachute),
            },
            FieldInfoData {
                name: "Swim",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(InformAnimationOfPhysicsCommonBinding, swim),
            },
            FieldInfoData {
                name: "PhysicsState",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(InformAnimationOfPhysicsCommonBinding, physics_state),
            },
            FieldInfoData {
                name: "InputBackward",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(InformAnimationOfPhysicsCommonBinding, input_backward),
            },
            FieldInfoData {
                name: "InputForward",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(InformAnimationOfPhysicsCommonBinding, input_forward),
            },
            FieldInfoData {
                name: "InputLeft",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(InformAnimationOfPhysicsCommonBinding, input_left),
            },
            FieldInfoData {
                name: "InputRight",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(InformAnimationOfPhysicsCommonBinding, input_right),
            },
            FieldInfoData {
                name: "InputExclusiveBackward",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(InformAnimationOfPhysicsCommonBinding, input_exclusive_backward),
            },
            FieldInfoData {
                name: "InputExclusiveForward",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(InformAnimationOfPhysicsCommonBinding, input_exclusive_forward),
            },
            FieldInfoData {
                name: "InputExclusiveLeft",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(InformAnimationOfPhysicsCommonBinding, input_exclusive_left),
            },
            FieldInfoData {
                name: "InputExclusiveRight",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(InformAnimationOfPhysicsCommonBinding, input_exclusive_right),
            },
            FieldInfoData {
                name: "IsEnemy",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(InformAnimationOfPhysicsCommonBinding, is_enemy),
            },
            FieldInfoData {
                name: "Jump",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(InformAnimationOfPhysicsCommonBinding, jump),
            },
            FieldInfoData {
                name: "LeanLeftRight",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(InformAnimationOfPhysicsCommonBinding, lean_left_right),
            },
            FieldInfoData {
                name: "Prone",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(InformAnimationOfPhysicsCommonBinding, prone),
            },
            FieldInfoData {
                name: "Sprint",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(InformAnimationOfPhysicsCommonBinding, sprint),
            },
            FieldInfoData {
                name: "GroundSupported",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(InformAnimationOfPhysicsCommonBinding, ground_supported),
            },
            FieldInfoData {
                name: "GroundNormal",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(InformAnimationOfPhysicsCommonBinding, ground_normal),
            },
            FieldInfoData {
                name: "GroundDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(InformAnimationOfPhysicsCommonBinding, ground_distance),
            },
            FieldInfoData {
                name: "GroundAngleZ",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(InformAnimationOfPhysicsCommonBinding, ground_angle_z),
            },
            FieldInfoData {
                name: "GroundAngleX",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(InformAnimationOfPhysicsCommonBinding, ground_angle_x),
            },
            FieldInfoData {
                name: "GroundAngleFromNormal",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(InformAnimationOfPhysicsCommonBinding, ground_angle_from_normal),
            },
            FieldInfoData {
                name: "GroundLeftAngleFromNormal",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(InformAnimationOfPhysicsCommonBinding, ground_left_angle_from_normal),
            },
            FieldInfoData {
                name: "IsClientAnimatable",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(InformAnimationOfPhysicsCommonBinding, is_client_animatable),
            },
            FieldInfoData {
                name: "VerticalImpact",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(InformAnimationOfPhysicsCommonBinding, vertical_impact),
            },
            FieldInfoData {
                name: "VerticalImpactSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(InformAnimationOfPhysicsCommonBinding, vertical_impact_speed),
            },
            FieldInfoData {
                name: "FalseSignal",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(InformAnimationOfPhysicsCommonBinding, false_signal),
            },
            FieldInfoData {
                name: "WindDirection",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(InformAnimationOfPhysicsCommonBinding, wind_direction),
            },
            FieldInfoData {
                name: "WindStrength",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(InformAnimationOfPhysicsCommonBinding, wind_strength),
            },
            FieldInfoData {
                name: "WaterDepth",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(InformAnimationOfPhysicsCommonBinding, water_depth),
            },
            FieldInfoData {
                name: "EyeWaterDepth",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(InformAnimationOfPhysicsCommonBinding, eye_water_depth),
            },
            FieldInfoData {
                name: "DesiredRelativeMovementAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(InformAnimationOfPhysicsCommonBinding, desired_relative_movement_angle),
            },
        ],
    }),
    array_type: Some(INFORMANIMATIONOFPHYSICSCOMMONBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for InformAnimationOfPhysicsCommonBinding {
    fn type_info(&self) -> &'static TypeInfo {
        INFORMANIMATIONOFPHYSICSCOMMONBINDING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static INFORMANIMATIONOFPHYSICSCOMMONBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InformAnimationOfPhysicsCommonBinding-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("InformAnimationOfPhysicsCommonBinding"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct InformAnimationOfPhysicsPerAnimatableBinding {
    pub physics_motion_target: super::ant::AntRef,
    pub force_set_trajectory: super::ant::AntRef,
    pub lock_arms_to_camera_weight: super::ant::AntRef,
    pub requested3_p: super::ant::AntRef,
}

pub trait InformAnimationOfPhysicsPerAnimatableBindingTrait: TypeObject {
    fn physics_motion_target(&self) -> &super::ant::AntRef;
    fn force_set_trajectory(&self) -> &super::ant::AntRef;
    fn lock_arms_to_camera_weight(&self) -> &super::ant::AntRef;
    fn requested3_p(&self) -> &super::ant::AntRef;
}

impl InformAnimationOfPhysicsPerAnimatableBindingTrait for InformAnimationOfPhysicsPerAnimatableBinding {
    fn physics_motion_target(&self) -> &super::ant::AntRef {
        &self.physics_motion_target
    }
    fn force_set_trajectory(&self) -> &super::ant::AntRef {
        &self.force_set_trajectory
    }
    fn lock_arms_to_camera_weight(&self) -> &super::ant::AntRef {
        &self.lock_arms_to_camera_weight
    }
    fn requested3_p(&self) -> &super::ant::AntRef {
        &self.requested3_p
    }
}

pub static INFORMANIMATIONOFPHYSICSPERANIMATABLEBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InformAnimationOfPhysicsPerAnimatableBinding",
    flags: MemberInfoFlags::new(32841),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<InformAnimationOfPhysicsPerAnimatableBinding as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PhysicsMotionTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(InformAnimationOfPhysicsPerAnimatableBinding, physics_motion_target),
            },
            FieldInfoData {
                name: "ForceSetTrajectory",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(InformAnimationOfPhysicsPerAnimatableBinding, force_set_trajectory),
            },
            FieldInfoData {
                name: "LockArmsToCameraWeight",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(InformAnimationOfPhysicsPerAnimatableBinding, lock_arms_to_camera_weight),
            },
            FieldInfoData {
                name: "Requested3P",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(InformAnimationOfPhysicsPerAnimatableBinding, requested3_p),
            },
        ],
    }),
    array_type: Some(INFORMANIMATIONOFPHYSICSPERANIMATABLEBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for InformAnimationOfPhysicsPerAnimatableBinding {
    fn type_info(&self) -> &'static TypeInfo {
        INFORMANIMATIONOFPHYSICSPERANIMATABLEBINDING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static INFORMANIMATIONOFPHYSICSPERANIMATABLEBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InformAnimationOfPhysicsPerAnimatableBinding-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("InformAnimationOfPhysicsPerAnimatableBinding"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AimingConstraintEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub enabled: bool,
    pub constraint_priority: i32,
    pub aiming_constraints: super::gameplay_sim::AimingConstraintsData,
    pub enable_relative_follow_transform_yaw: bool,
    pub enable_relative_follow_transform_pitch: bool,
    pub constraint_follow_transform: super::core::LinearTransform,
    pub min_yaw_in: f32,
    pub max_yaw_in: f32,
    pub min_pitch_in: f32,
    pub max_pitch_in: f32,
}

pub trait AimingConstraintEntityDataTrait: super::entity::EntityDataTrait {
    fn enabled(&self) -> &bool;
    fn constraint_priority(&self) -> &i32;
    fn aiming_constraints(&self) -> &super::gameplay_sim::AimingConstraintsData;
    fn enable_relative_follow_transform_yaw(&self) -> &bool;
    fn enable_relative_follow_transform_pitch(&self) -> &bool;
    fn constraint_follow_transform(&self) -> &super::core::LinearTransform;
    fn min_yaw_in(&self) -> &f32;
    fn max_yaw_in(&self) -> &f32;
    fn min_pitch_in(&self) -> &f32;
    fn max_pitch_in(&self) -> &f32;
}

impl AimingConstraintEntityDataTrait for AimingConstraintEntityData {
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn constraint_priority(&self) -> &i32 {
        &self.constraint_priority
    }
    fn aiming_constraints(&self) -> &super::gameplay_sim::AimingConstraintsData {
        &self.aiming_constraints
    }
    fn enable_relative_follow_transform_yaw(&self) -> &bool {
        &self.enable_relative_follow_transform_yaw
    }
    fn enable_relative_follow_transform_pitch(&self) -> &bool {
        &self.enable_relative_follow_transform_pitch
    }
    fn constraint_follow_transform(&self) -> &super::core::LinearTransform {
        &self.constraint_follow_transform
    }
    fn min_yaw_in(&self) -> &f32 {
        &self.min_yaw_in
    }
    fn max_yaw_in(&self) -> &f32 {
        &self.max_yaw_in
    }
    fn min_pitch_in(&self) -> &f32 {
        &self.min_pitch_in
    }
    fn max_pitch_in(&self) -> &f32 {
        &self.max_pitch_in
    }
}

impl super::entity::EntityDataTrait for AimingConstraintEntityData {
}

impl super::entity::GameObjectDataTrait for AimingConstraintEntityData {
}

impl super::core::DataBusPeerTrait for AimingConstraintEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for AimingConstraintEntityData {
}

impl super::core::DataContainerTrait for AimingConstraintEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static AIMINGCONSTRAINTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AimingConstraintEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AimingConstraintEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AimingConstraintEntityData, enabled),
            },
            FieldInfoData {
                name: "ConstraintPriority",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AimingConstraintEntityData, constraint_priority),
            },
            FieldInfoData {
                name: "AimingConstraints",
                flags: MemberInfoFlags::new(0),
                field_type: "AimingConstraintsData",
                rust_offset: offset_of!(AimingConstraintEntityData, aiming_constraints),
            },
            FieldInfoData {
                name: "EnableRelativeFollowTransformYaw",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AimingConstraintEntityData, enable_relative_follow_transform_yaw),
            },
            FieldInfoData {
                name: "EnableRelativeFollowTransformPitch",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AimingConstraintEntityData, enable_relative_follow_transform_pitch),
            },
            FieldInfoData {
                name: "ConstraintFollowTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(AimingConstraintEntityData, constraint_follow_transform),
            },
            FieldInfoData {
                name: "MinYawIn",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AimingConstraintEntityData, min_yaw_in),
            },
            FieldInfoData {
                name: "MaxYawIn",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AimingConstraintEntityData, max_yaw_in),
            },
            FieldInfoData {
                name: "MinPitchIn",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AimingConstraintEntityData, min_pitch_in),
            },
            FieldInfoData {
                name: "MaxPitchIn",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AimingConstraintEntityData, max_pitch_in),
            },
        ],
    }),
    array_type: Some(AIMINGCONSTRAINTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AimingConstraintEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AIMINGCONSTRAINTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static AIMINGCONSTRAINTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AimingConstraintEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("AimingConstraintEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum AffectorVariable {
    #[default]
    AffectorVariable_SoldierHealthRegeneration = 0,
    AffectorVariable_MaxHealth = 1,
    AffectorVariable_Count = 2,
    AffectorVariable_Invalid = 3,
}

pub static AFFECTORVARIABLE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AffectorVariable",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(AFFECTORVARIABLE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AffectorVariable {
    fn type_info(&self) -> &'static TypeInfo {
        AFFECTORVARIABLE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static AFFECTORVARIABLE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AffectorVariable-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("AffectorVariable"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AffectorStreamEntityData {
    pub _glacier_base: super::entity::LogicReferenceObjectData,
    pub enable_streaming: bool,
    pub ignore_networked_check: bool,
    pub stream_id_list: Vec<u32>,
}

pub trait AffectorStreamEntityDataTrait: super::entity::LogicReferenceObjectDataTrait {
    fn enable_streaming(&self) -> &bool;
    fn ignore_networked_check(&self) -> &bool;
    fn stream_id_list(&self) -> &Vec<u32>;
}

impl AffectorStreamEntityDataTrait for AffectorStreamEntityData {
    fn enable_streaming(&self) -> &bool {
        &self.enable_streaming
    }
    fn ignore_networked_check(&self) -> &bool {
        &self.ignore_networked_check
    }
    fn stream_id_list(&self) -> &Vec<u32> {
        &self.stream_id_list
    }
}

impl super::entity::LogicReferenceObjectDataTrait for AffectorStreamEntityData {
    fn local_player_id(&self) -> &super::core::LocalPlayerId {
        self._glacier_base.local_player_id()
    }
    fn sub_realm(&self) -> &super::entity::SubRealm {
        self._glacier_base.sub_realm()
    }
}

impl super::entity::ReferenceObjectDataTrait for AffectorStreamEntityData {
    fn blueprint_transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.blueprint_transform()
    }
    fn blueprint(&self) -> &Option<Arc<Mutex<dyn super::entity::BlueprintTrait>>> {
        self._glacier_base.blueprint()
    }
    fn object_variation(&self) -> &Option<Arc<Mutex<dyn super::entity::ObjectVariationTrait>>> {
        self._glacier_base.object_variation()
    }
    fn stream_realm(&self) -> &super::entity::StreamRealm {
        self._glacier_base.stream_realm()
    }
    fn radiosity_type_override(&self) -> &super::core::RadiosityTypeOverride {
        self._glacier_base.radiosity_type_override()
    }
    fn lightmap_resolution_scale(&self) -> &u32 {
        self._glacier_base.lightmap_resolution_scale()
    }
    fn lightmap_scale_with_size(&self) -> &bool {
        self._glacier_base.lightmap_scale_with_size()
    }
    fn rendering_overrides(&self) -> &super::core::RenderingOverrides {
        self._glacier_base.rendering_overrides()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn create_indestructible_entity(&self) -> &bool {
        self._glacier_base.create_indestructible_entity()
    }
}

impl super::entity::GameObjectDataTrait for AffectorStreamEntityData {
}

impl super::core::DataBusPeerTrait for AffectorStreamEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for AffectorStreamEntityData {
}

impl super::core::DataContainerTrait for AffectorStreamEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static AFFECTORSTREAMENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AffectorStreamEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::LOGICREFERENCEOBJECTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AffectorStreamEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "EnableStreaming",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AffectorStreamEntityData, enable_streaming),
            },
            FieldInfoData {
                name: "IgnoreNetworkedCheck",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AffectorStreamEntityData, ignore_networked_check),
            },
            FieldInfoData {
                name: "StreamIdList",
                flags: MemberInfoFlags::new(144),
                field_type: "Uint32-Array",
                rust_offset: offset_of!(AffectorStreamEntityData, stream_id_list),
            },
        ],
    }),
    array_type: Some(AFFECTORSTREAMENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AffectorStreamEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AFFECTORSTREAMENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static AFFECTORSTREAMENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AffectorStreamEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("AffectorStreamEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AffectorReceiveEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub listen_to_type: AffectorReceiveType,
    pub affector_listen_to_id: u32,
}

pub trait AffectorReceiveEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn listen_to_type(&self) -> &AffectorReceiveType;
    fn affector_listen_to_id(&self) -> &u32;
}

impl AffectorReceiveEntityDataTrait for AffectorReceiveEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn listen_to_type(&self) -> &AffectorReceiveType {
        &self.listen_to_type
    }
    fn affector_listen_to_id(&self) -> &u32 {
        &self.affector_listen_to_id
    }
}

impl super::entity::EntityDataTrait for AffectorReceiveEntityData {
}

impl super::entity::GameObjectDataTrait for AffectorReceiveEntityData {
}

impl super::core::DataBusPeerTrait for AffectorReceiveEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for AffectorReceiveEntityData {
}

impl super::core::DataContainerTrait for AffectorReceiveEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static AFFECTORRECEIVEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AffectorReceiveEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AffectorReceiveEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(AffectorReceiveEntityData, realm),
            },
            FieldInfoData {
                name: "ListenToType",
                flags: MemberInfoFlags::new(0),
                field_type: "AffectorReceiveType",
                rust_offset: offset_of!(AffectorReceiveEntityData, listen_to_type),
            },
            FieldInfoData {
                name: "AffectorListenToId",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(AffectorReceiveEntityData, affector_listen_to_id),
            },
        ],
    }),
    array_type: Some(AFFECTORRECEIVEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AffectorReceiveEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AFFECTORRECEIVEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static AFFECTORRECEIVEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AffectorReceiveEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("AffectorReceiveEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum AffectorReceiveType {
    #[default]
    AffectorReceiveType_None = 0,
    AffectorReceiveType_AffectorId = 1,
    AffectorReceiveType_TypeNameHash = 2,
    AffectorReceiveType_AffectorDescriptor = 3,
}

pub static AFFECTORRECEIVETYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AffectorReceiveType",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(AFFECTORRECEIVETYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AffectorReceiveType {
    fn type_info(&self) -> &'static TypeInfo {
        AFFECTORRECEIVETYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static AFFECTORRECEIVETYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AffectorReceiveType-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("AffectorReceiveType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AffectorQueryFilterEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub entities_to_filter: QueryEntityResult,
    pub descriptor_ids: Vec<u32>,
}

pub trait AffectorQueryFilterEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn entities_to_filter(&self) -> &QueryEntityResult;
    fn descriptor_ids(&self) -> &Vec<u32>;
}

impl AffectorQueryFilterEntityDataTrait for AffectorQueryFilterEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn entities_to_filter(&self) -> &QueryEntityResult {
        &self.entities_to_filter
    }
    fn descriptor_ids(&self) -> &Vec<u32> {
        &self.descriptor_ids
    }
}

impl super::entity::EntityDataTrait for AffectorQueryFilterEntityData {
}

impl super::entity::GameObjectDataTrait for AffectorQueryFilterEntityData {
}

impl super::core::DataBusPeerTrait for AffectorQueryFilterEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for AffectorQueryFilterEntityData {
}

impl super::core::DataContainerTrait for AffectorQueryFilterEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static AFFECTORQUERYFILTERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AffectorQueryFilterEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AffectorQueryFilterEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(AffectorQueryFilterEntityData, realm),
            },
            FieldInfoData {
                name: "EntitiesToFilter",
                flags: MemberInfoFlags::new(0),
                field_type: "QueryEntityResult",
                rust_offset: offset_of!(AffectorQueryFilterEntityData, entities_to_filter),
            },
            FieldInfoData {
                name: "DescriptorIds",
                flags: MemberInfoFlags::new(144),
                field_type: "Uint32-Array",
                rust_offset: offset_of!(AffectorQueryFilterEntityData, descriptor_ids),
            },
        ],
    }),
    array_type: Some(AFFECTORQUERYFILTERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AffectorQueryFilterEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AFFECTORQUERYFILTERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static AFFECTORQUERYFILTERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AffectorQueryFilterEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("AffectorQueryFilterEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum AffectorLimits {
    #[default]
    AffectorLimits_MaxRank = 31,
}

pub static AFFECTORLIMITS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AffectorLimits",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(AFFECTORLIMITS_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AffectorLimits {
    fn type_info(&self) -> &'static TypeInfo {
        AFFECTORLIMITS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static AFFECTORLIMITS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AffectorLimits-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("AffectorLimits"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AffectorAppliedMessage {
}

pub trait AffectorAppliedMessageTrait: TypeObject {
}

impl AffectorAppliedMessageTrait for AffectorAppliedMessage {
}

pub static AFFECTORAPPLIEDMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AffectorAppliedMessage",
    flags: MemberInfoFlags::new(36937),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AffectorAppliedMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 16,
};

impl TypeObject for AffectorAppliedMessage {
    fn type_info(&self) -> &'static TypeInfo {
        AFFECTORAPPLIEDMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}

#[derive(Clone, Debug, Default)]
pub struct AbilityInputMappingAffectorAsset {
    pub _glacier_base: AffectorAsset,
    pub entry_input_action_map: Vec<PlayerAbilityEntryInputContainer>,
}

pub trait AbilityInputMappingAffectorAssetTrait: AffectorAssetTrait {
    fn entry_input_action_map(&self) -> &Vec<PlayerAbilityEntryInputContainer>;
}

impl AbilityInputMappingAffectorAssetTrait for AbilityInputMappingAffectorAsset {
    fn entry_input_action_map(&self) -> &Vec<PlayerAbilityEntryInputContainer> {
        &self.entry_input_action_map
    }
}

impl AffectorAssetTrait for AbilityInputMappingAffectorAsset {
    fn identifier(&self) -> &u32 {
        self._glacier_base.identifier()
    }
    fn type_name_hash(&self) -> &u32 {
        self._glacier_base.type_name_hash()
    }
    fn descriptor_ids(&self) -> &Vec<u32> {
        self._glacier_base.descriptor_ids()
    }
    fn stacking_policy(&self) -> &AffectorStackingPolicy {
        self._glacier_base.stacking_policy()
    }
}

impl super::core::DataContainerPolicyAssetTrait for AbilityInputMappingAffectorAsset {
}

impl super::core::AssetTrait for AbilityInputMappingAffectorAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for AbilityInputMappingAffectorAsset {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static ABILITYINPUTMAPPINGAFFECTORASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AbilityInputMappingAffectorAsset",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AFFECTORASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AbilityInputMappingAffectorAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "EntryInputActionMap",
                flags: MemberInfoFlags::new(144),
                field_type: "PlayerAbilityEntryInputContainer-Array",
                rust_offset: offset_of!(AbilityInputMappingAffectorAsset, entry_input_action_map),
            },
        ],
    }),
    array_type: Some(ABILITYINPUTMAPPINGAFFECTORASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AbilityInputMappingAffectorAsset {
    fn type_info(&self) -> &'static TypeInfo {
        ABILITYINPUTMAPPINGAFFECTORASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ABILITYINPUTMAPPINGAFFECTORASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AbilityInputMappingAffectorAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("AbilityInputMappingAffectorAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateAffectorAsset {
    pub _glacier_base: AffectorAsset,
    pub rank_data: Vec<CharacterStateAffectorData>,
}

pub trait CharacterStateAffectorAssetTrait: AffectorAssetTrait {
    fn rank_data(&self) -> &Vec<CharacterStateAffectorData>;
}

impl CharacterStateAffectorAssetTrait for CharacterStateAffectorAsset {
    fn rank_data(&self) -> &Vec<CharacterStateAffectorData> {
        &self.rank_data
    }
}

impl AffectorAssetTrait for CharacterStateAffectorAsset {
    fn identifier(&self) -> &u32 {
        self._glacier_base.identifier()
    }
    fn type_name_hash(&self) -> &u32 {
        self._glacier_base.type_name_hash()
    }
    fn descriptor_ids(&self) -> &Vec<u32> {
        self._glacier_base.descriptor_ids()
    }
    fn stacking_policy(&self) -> &AffectorStackingPolicy {
        self._glacier_base.stacking_policy()
    }
}

impl super::core::DataContainerPolicyAssetTrait for CharacterStateAffectorAsset {
}

impl super::core::AssetTrait for CharacterStateAffectorAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for CharacterStateAffectorAsset {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHARACTERSTATEAFFECTORASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateAffectorAsset",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AFFECTORASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateAffectorAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "RankData",
                flags: MemberInfoFlags::new(144),
                field_type: "CharacterStateAffectorData-Array",
                rust_offset: offset_of!(CharacterStateAffectorAsset, rank_data),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEAFFECTORASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateAffectorAsset {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEAFFECTORASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEAFFECTORASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateAffectorAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateAffectorAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterStateAffectorData {
    pub request: Option<Arc<Mutex<dyn CharacterStateRequestDataBaseTrait>>>,
}

pub trait CharacterStateAffectorDataTrait: TypeObject {
    fn request(&self) -> &Option<Arc<Mutex<dyn CharacterStateRequestDataBaseTrait>>>;
}

impl CharacterStateAffectorDataTrait for CharacterStateAffectorData {
    fn request(&self) -> &Option<Arc<Mutex<dyn CharacterStateRequestDataBaseTrait>>> {
        &self.request
    }
}

pub static CHARACTERSTATEAFFECTORDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateAffectorData",
    flags: MemberInfoFlags::new(73),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterStateAffectorData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Request",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterStateRequestDataBase",
                rust_offset: offset_of!(CharacterStateAffectorData, request),
            },
        ],
    }),
    array_type: Some(CHARACTERSTATEAFFECTORDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterStateAffectorData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSTATEAFFECTORDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHARACTERSTATEAFFECTORDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterStateAffectorData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("CharacterStateAffectorData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AffectorImmunityAffectorAsset {
    pub _glacier_base: AffectorAsset,
    pub rank_data: Vec<AffectorImmunityAffectorData>,
}

pub trait AffectorImmunityAffectorAssetTrait: AffectorAssetTrait {
    fn rank_data(&self) -> &Vec<AffectorImmunityAffectorData>;
}

impl AffectorImmunityAffectorAssetTrait for AffectorImmunityAffectorAsset {
    fn rank_data(&self) -> &Vec<AffectorImmunityAffectorData> {
        &self.rank_data
    }
}

impl AffectorAssetTrait for AffectorImmunityAffectorAsset {
    fn identifier(&self) -> &u32 {
        self._glacier_base.identifier()
    }
    fn type_name_hash(&self) -> &u32 {
        self._glacier_base.type_name_hash()
    }
    fn descriptor_ids(&self) -> &Vec<u32> {
        self._glacier_base.descriptor_ids()
    }
    fn stacking_policy(&self) -> &AffectorStackingPolicy {
        self._glacier_base.stacking_policy()
    }
}

impl super::core::DataContainerPolicyAssetTrait for AffectorImmunityAffectorAsset {
}

impl super::core::AssetTrait for AffectorImmunityAffectorAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for AffectorImmunityAffectorAsset {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static AFFECTORIMMUNITYAFFECTORASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AffectorImmunityAffectorAsset",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AFFECTORASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AffectorImmunityAffectorAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "RankData",
                flags: MemberInfoFlags::new(144),
                field_type: "AffectorImmunityAffectorData-Array",
                rust_offset: offset_of!(AffectorImmunityAffectorAsset, rank_data),
            },
        ],
    }),
    array_type: Some(AFFECTORIMMUNITYAFFECTORASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AffectorImmunityAffectorAsset {
    fn type_info(&self) -> &'static TypeInfo {
        AFFECTORIMMUNITYAFFECTORASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static AFFECTORIMMUNITYAFFECTORASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AffectorImmunityAffectorAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("AffectorImmunityAffectorAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AffectorImmunityAffectorData {
    pub descriptor_to_add_immunity_to_id: u32,
}

pub trait AffectorImmunityAffectorDataTrait: TypeObject {
    fn descriptor_to_add_immunity_to_id(&self) -> &u32;
}

impl AffectorImmunityAffectorDataTrait for AffectorImmunityAffectorData {
    fn descriptor_to_add_immunity_to_id(&self) -> &u32 {
        &self.descriptor_to_add_immunity_to_id
    }
}

pub static AFFECTORIMMUNITYAFFECTORDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AffectorImmunityAffectorData",
    flags: MemberInfoFlags::new(32841),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AffectorImmunityAffectorData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DescriptorToAddImmunityToId",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(AffectorImmunityAffectorData, descriptor_to_add_immunity_to_id),
            },
        ],
    }),
    array_type: Some(AFFECTORIMMUNITYAFFECTORDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AffectorImmunityAffectorData {
    fn type_info(&self) -> &'static TypeInfo {
        AFFECTORIMMUNITYAFFECTORDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static AFFECTORIMMUNITYAFFECTORDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AffectorImmunityAffectorData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("AffectorImmunityAffectorData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RemoveAffectorAsset {
    pub _glacier_base: AffectorAsset,
    pub rank_data: Vec<RemoveAffectorData>,
}

pub trait RemoveAffectorAssetTrait: AffectorAssetTrait {
    fn rank_data(&self) -> &Vec<RemoveAffectorData>;
}

impl RemoveAffectorAssetTrait for RemoveAffectorAsset {
    fn rank_data(&self) -> &Vec<RemoveAffectorData> {
        &self.rank_data
    }
}

impl AffectorAssetTrait for RemoveAffectorAsset {
    fn identifier(&self) -> &u32 {
        self._glacier_base.identifier()
    }
    fn type_name_hash(&self) -> &u32 {
        self._glacier_base.type_name_hash()
    }
    fn descriptor_ids(&self) -> &Vec<u32> {
        self._glacier_base.descriptor_ids()
    }
    fn stacking_policy(&self) -> &AffectorStackingPolicy {
        self._glacier_base.stacking_policy()
    }
}

impl super::core::DataContainerPolicyAssetTrait for RemoveAffectorAsset {
}

impl super::core::AssetTrait for RemoveAffectorAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for RemoveAffectorAsset {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static REMOVEAFFECTORASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RemoveAffectorAsset",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AFFECTORASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RemoveAffectorAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "RankData",
                flags: MemberInfoFlags::new(144),
                field_type: "RemoveAffectorData-Array",
                rust_offset: offset_of!(RemoveAffectorAsset, rank_data),
            },
        ],
    }),
    array_type: Some(REMOVEAFFECTORASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RemoveAffectorAsset {
    fn type_info(&self) -> &'static TypeInfo {
        REMOVEAFFECTORASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static REMOVEAFFECTORASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RemoveAffectorAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("RemoveAffectorAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RemoveAffectorData {
    pub descriptor_to_remove_id: u32,
}

pub trait RemoveAffectorDataTrait: TypeObject {
    fn descriptor_to_remove_id(&self) -> &u32;
}

impl RemoveAffectorDataTrait for RemoveAffectorData {
    fn descriptor_to_remove_id(&self) -> &u32 {
        &self.descriptor_to_remove_id
    }
}

pub static REMOVEAFFECTORDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RemoveAffectorData",
    flags: MemberInfoFlags::new(32841),
    module: "DiceShooterShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RemoveAffectorData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DescriptorToRemoveId",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(RemoveAffectorData, descriptor_to_remove_id),
            },
        ],
    }),
    array_type: Some(REMOVEAFFECTORDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for RemoveAffectorData {
    fn type_info(&self) -> &'static TypeInfo {
        REMOVEAFFECTORDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static REMOVEAFFECTORDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RemoveAffectorData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("RemoveAffectorData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BasicAffectorAsset {
    pub _glacier_base: AffectorAsset,
}

pub trait BasicAffectorAssetTrait: AffectorAssetTrait {
}

impl BasicAffectorAssetTrait for BasicAffectorAsset {
}

impl AffectorAssetTrait for BasicAffectorAsset {
    fn identifier(&self) -> &u32 {
        self._glacier_base.identifier()
    }
    fn type_name_hash(&self) -> &u32 {
        self._glacier_base.type_name_hash()
    }
    fn descriptor_ids(&self) -> &Vec<u32> {
        self._glacier_base.descriptor_ids()
    }
    fn stacking_policy(&self) -> &AffectorStackingPolicy {
        self._glacier_base.stacking_policy()
    }
}

impl super::core::DataContainerPolicyAssetTrait for BasicAffectorAsset {
}

impl super::core::AssetTrait for BasicAffectorAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for BasicAffectorAsset {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static BASICAFFECTORASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BasicAffectorAsset",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AFFECTORASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BasicAffectorAsset as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(BASICAFFECTORASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BasicAffectorAsset {
    fn type_info(&self) -> &'static TypeInfo {
        BASICAFFECTORASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static BASICAFFECTORASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BasicAffectorAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("BasicAffectorAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VariableAffectorAsset {
    pub _glacier_base: AffectorAsset,
    pub variable: AffectorVariable,
}

pub trait VariableAffectorAssetTrait: AffectorAssetTrait {
    fn variable(&self) -> &AffectorVariable;
}

impl VariableAffectorAssetTrait for VariableAffectorAsset {
    fn variable(&self) -> &AffectorVariable {
        &self.variable
    }
}

impl AffectorAssetTrait for VariableAffectorAsset {
    fn identifier(&self) -> &u32 {
        self._glacier_base.identifier()
    }
    fn type_name_hash(&self) -> &u32 {
        self._glacier_base.type_name_hash()
    }
    fn descriptor_ids(&self) -> &Vec<u32> {
        self._glacier_base.descriptor_ids()
    }
    fn stacking_policy(&self) -> &AffectorStackingPolicy {
        self._glacier_base.stacking_policy()
    }
}

impl super::core::DataContainerPolicyAssetTrait for VariableAffectorAsset {
}

impl super::core::AssetTrait for VariableAffectorAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for VariableAffectorAsset {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static VARIABLEAFFECTORASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VariableAffectorAsset",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AFFECTORASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VariableAffectorAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Variable",
                flags: MemberInfoFlags::new(0),
                field_type: "AffectorVariable",
                rust_offset: offset_of!(VariableAffectorAsset, variable),
            },
        ],
    }),
    array_type: Some(VARIABLEAFFECTORASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VariableAffectorAsset {
    fn type_info(&self) -> &'static TypeInfo {
        VARIABLEAFFECTORASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VARIABLEAFFECTORASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VariableAffectorAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("VariableAffectorAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AffectorAsset {
    pub _glacier_base: super::core::DataContainerPolicyAsset,
    pub identifier: u32,
    pub type_name_hash: u32,
    pub descriptor_ids: Vec<u32>,
    pub stacking_policy: AffectorStackingPolicy,
}

pub trait AffectorAssetTrait: super::core::DataContainerPolicyAssetTrait {
    fn identifier(&self) -> &u32;
    fn type_name_hash(&self) -> &u32;
    fn descriptor_ids(&self) -> &Vec<u32>;
    fn stacking_policy(&self) -> &AffectorStackingPolicy;
}

impl AffectorAssetTrait for AffectorAsset {
    fn identifier(&self) -> &u32 {
        &self.identifier
    }
    fn type_name_hash(&self) -> &u32 {
        &self.type_name_hash
    }
    fn descriptor_ids(&self) -> &Vec<u32> {
        &self.descriptor_ids
    }
    fn stacking_policy(&self) -> &AffectorStackingPolicy {
        &self.stacking_policy
    }
}

impl super::core::DataContainerPolicyAssetTrait for AffectorAsset {
}

impl super::core::AssetTrait for AffectorAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for AffectorAsset {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static AFFECTORASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AffectorAsset",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINERPOLICYASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AffectorAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Identifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(AffectorAsset, identifier),
            },
            FieldInfoData {
                name: "TypeNameHash",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(AffectorAsset, type_name_hash),
            },
            FieldInfoData {
                name: "DescriptorIds",
                flags: MemberInfoFlags::new(144),
                field_type: "Uint32-Array",
                rust_offset: offset_of!(AffectorAsset, descriptor_ids),
            },
            FieldInfoData {
                name: "StackingPolicy",
                flags: MemberInfoFlags::new(0),
                field_type: "AffectorStackingPolicy",
                rust_offset: offset_of!(AffectorAsset, stacking_policy),
            },
        ],
    }),
    array_type: Some(AFFECTORASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AffectorAsset {
    fn type_info(&self) -> &'static TypeInfo {
        AFFECTORASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static AFFECTORASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AffectorAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("AffectorAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum AffectorStackingPolicy {
    #[default]
    AffectorStackingPolicy_AllowMultiple = 0,
    AffectorStackingPolicy_ReplaceOld = 1,
    AffectorStackingPolicy_IgnoreNew = 2,
    AffectorStackingPolicy_CombineResetDuration = 3,
    AffectorStackingPolicy_CombineAddDuration = 4,
    AffectorStackingPolicy_ReplaceLowerRank = 5,
}

pub static AFFECTORSTACKINGPOLICY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AffectorStackingPolicy",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(AFFECTORSTACKINGPOLICY_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AffectorStackingPolicy {
    fn type_info(&self) -> &'static TypeInfo {
        AFFECTORSTACKINGPOLICY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static AFFECTORSTACKINGPOLICY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AffectorStackingPolicy-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("AffectorStackingPolicy"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum AffectorConstants {
    #[default]
    AffectorNumSlots = 16,
}

pub static AFFECTORCONSTANTS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AffectorConstants",
    flags: MemberInfoFlags::new(49429),
    module: "DiceShooterShared",
    data: TypeInfoData::Enum,
    array_type: Some(AFFECTORCONSTANTS_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AffectorConstants {
    fn type_info(&self) -> &'static TypeInfo {
        AFFECTORCONSTANTS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static AFFECTORCONSTANTS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AffectorConstants-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("AffectorConstants"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AffectorComponentData {
    pub _glacier_base: super::entity::GameComponentData,
}

pub trait AffectorComponentDataTrait: super::entity::GameComponentDataTrait {
}

impl AffectorComponentDataTrait for AffectorComponentData {
}

impl super::entity::GameComponentDataTrait for AffectorComponentData {
}

impl super::entity::ComponentDataTrait for AffectorComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
}

impl super::entity::GameObjectDataTrait for AffectorComponentData {
}

impl super::core::DataBusPeerTrait for AffectorComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for AffectorComponentData {
}

impl super::core::DataContainerTrait for AffectorComponentData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static AFFECTORCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AffectorComponentData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AffectorComponentData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(AFFECTORCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AffectorComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        AFFECTORCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static AFFECTORCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AffectorComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("AffectorComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AffectorApplyEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub affector: Option<Arc<Mutex<dyn AffectorAssetTrait>>>,
    pub duration: f32,
    pub is_passive: bool,
    pub rank: i32,
    pub giver: QueryEntityResult,
    pub target_list: QueryEntityResult,
    pub apply_transform: super::core::LinearTransform,
}

pub trait AffectorApplyEntityDataTrait: super::entity::EntityDataTrait {
    fn affector(&self) -> &Option<Arc<Mutex<dyn AffectorAssetTrait>>>;
    fn duration(&self) -> &f32;
    fn is_passive(&self) -> &bool;
    fn rank(&self) -> &i32;
    fn giver(&self) -> &QueryEntityResult;
    fn target_list(&self) -> &QueryEntityResult;
    fn apply_transform(&self) -> &super::core::LinearTransform;
}

impl AffectorApplyEntityDataTrait for AffectorApplyEntityData {
    fn affector(&self) -> &Option<Arc<Mutex<dyn AffectorAssetTrait>>> {
        &self.affector
    }
    fn duration(&self) -> &f32 {
        &self.duration
    }
    fn is_passive(&self) -> &bool {
        &self.is_passive
    }
    fn rank(&self) -> &i32 {
        &self.rank
    }
    fn giver(&self) -> &QueryEntityResult {
        &self.giver
    }
    fn target_list(&self) -> &QueryEntityResult {
        &self.target_list
    }
    fn apply_transform(&self) -> &super::core::LinearTransform {
        &self.apply_transform
    }
}

impl super::entity::EntityDataTrait for AffectorApplyEntityData {
}

impl super::entity::GameObjectDataTrait for AffectorApplyEntityData {
}

impl super::core::DataBusPeerTrait for AffectorApplyEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for AffectorApplyEntityData {
}

impl super::core::DataContainerTrait for AffectorApplyEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static AFFECTORAPPLYENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AffectorApplyEntityData",
    flags: MemberInfoFlags::new(101),
    module: "DiceShooterShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AffectorApplyEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Affector",
                flags: MemberInfoFlags::new(0),
                field_type: "AffectorAsset",
                rust_offset: offset_of!(AffectorApplyEntityData, affector),
            },
            FieldInfoData {
                name: "Duration",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AffectorApplyEntityData, duration),
            },
            FieldInfoData {
                name: "IsPassive",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AffectorApplyEntityData, is_passive),
            },
            FieldInfoData {
                name: "Rank",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AffectorApplyEntityData, rank),
            },
            FieldInfoData {
                name: "Giver",
                flags: MemberInfoFlags::new(0),
                field_type: "QueryEntityResult",
                rust_offset: offset_of!(AffectorApplyEntityData, giver),
            },
            FieldInfoData {
                name: "TargetList",
                flags: MemberInfoFlags::new(0),
                field_type: "QueryEntityResult",
                rust_offset: offset_of!(AffectorApplyEntityData, target_list),
            },
            FieldInfoData {
                name: "ApplyTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(AffectorApplyEntityData, apply_transform),
            },
        ],
    }),
    array_type: Some(AFFECTORAPPLYENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AffectorApplyEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AFFECTORAPPLYENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static AFFECTORAPPLYENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AffectorApplyEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "DiceShooterShared",
    data: TypeInfoData::Array("AffectorApplyEntityData"),
    array_type: None,
    alignment: 8,
};


