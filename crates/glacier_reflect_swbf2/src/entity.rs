use std::{mem::offset_of, any::Any, option::Option, sync::Arc};
use tokio::sync::Mutex;

use glacier_reflect::{
    member::MemberInfoFlags,
    type_info::{
        ClassInfoData, ValueTypeInfoData, FieldInfoData, TypeInfo, TypeInfoData,
        TypeObject, TypeFunctions, LockedTypeObject, BoxedTypeObject,
    }, type_registry::TypeRegistry,
};

pub(crate) fn register_entity_types(registry: &mut TypeRegistry) {
    registry.register_type(WORLDPARTINCLUSION_TYPE_INFO);
    registry.register_type(WORLDPARTINCLUSION_ARRAY_TYPE_INFO);
    registry.register_type(WORLDPARTINCLUSIONCRITERION_TYPE_INFO);
    registry.register_type(WORLDPARTINCLUSIONCRITERION_ARRAY_TYPE_INFO);
    registry.register_type(WORLDPARTINCLUSIONSETTING_TYPE_INFO);
    registry.register_type(WORLDPARTINCLUSIONSETTING_ARRAY_TYPE_INFO);
    registry.register_type(WORLDPARTINCLUSIONSETTINGS_TYPE_INFO);
    registry.register_type(WORLDPARTINCLUSIONSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(ASSEMBLYDESCRIPTORDATA_TYPE_INFO);
    registry.register_type(ASSEMBLYDESCRIPTORDATA_ARRAY_TYPE_INFO);
    registry.register_type(WORLDOBJECTLISTDATA_TYPE_INFO);
    registry.register_type(WORLDOBJECTLISTDATA_ARRAY_TYPE_INFO);
    registry.register_type(WORLDPARTREFERENCEOBJECTDATA_TYPE_INFO);
    registry.register_type(WORLDPARTREFERENCEOBJECTDATA_ARRAY_TYPE_INFO);
    registry.register_type(READONLYLAYERREFERENCEOBJECTDATA_TYPE_INFO);
    registry.register_type(READONLYLAYERREFERENCEOBJECTDATA_ARRAY_TYPE_INFO);
    registry.register_type(LAYERREFERENCEOBJECTDATA_TYPE_INFO);
    registry.register_type(LAYERREFERENCEOBJECTDATA_ARRAY_TYPE_INFO);
    registry.register_type(SUBWORLDREFERENCEOBJECTDATA_TYPE_INFO);
    registry.register_type(SUBWORLDREFERENCEOBJECTDATA_ARRAY_TYPE_INFO);
    registry.register_type(DETACHEDSUBWORLDDATA_TYPE_INFO);
    registry.register_type(DETACHEDSUBWORLDDATA_ARRAY_TYPE_INFO);
    registry.register_type(WORLDDATA_TYPE_INFO);
    registry.register_type(WORLDDATA_ARRAY_TYPE_INFO);
    registry.register_type(SUBWORLDDATA_TYPE_INFO);
    registry.register_type(SUBWORLDDATA_ARRAY_TYPE_INFO);
    registry.register_type(SUBWORLDDATACOMPONENT_TYPE_INFO);
    registry.register_type(SUBWORLDDATACOMPONENT_ARRAY_TYPE_INFO);
    registry.register_type(WORLDPARTDATA_TYPE_INFO);
    registry.register_type(WORLDPARTDATA_ARRAY_TYPE_INFO);
    registry.register_type(LAYERDATA_TYPE_INFO);
    registry.register_type(LAYERDATA_ARRAY_TYPE_INFO);
    registry.register_type(SUBWORLDINCLUSIONSETTINGS_TYPE_INFO);
    registry.register_type(SUBWORLDINCLUSIONSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(SUBWORLDINCLUSIONSETTING_TYPE_INFO);
    registry.register_type(SUBWORLDINCLUSIONSETTING_ARRAY_TYPE_INFO);
    registry.register_type(SUBWORLDINCLUSION_TYPE_INFO);
    registry.register_type(SUBWORLDINCLUSION_ARRAY_TYPE_INFO);
    registry.register_type(SUBWORLDINCLUSIONCRITERION_TYPE_INFO);
    registry.register_type(SUBWORLDINCLUSIONCRITERION_ARRAY_TYPE_INFO);
    registry.register_type(LEVELSETUP_TYPE_INFO);
    registry.register_type(LEVELSETUP_ARRAY_TYPE_INFO);
    registry.register_type(LEVELSETUPOPTION_TYPE_INFO);
    registry.register_type(LEVELSETUPOPTION_ARRAY_TYPE_INFO);
    registry.register_type(CREATESCHEMATICSINSTANCEENTITY_TYPE_INFO);
    registry.register_type(CREATESCHEMATICSINSTANCEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(GETENTITYBUSENTITY_TYPE_INFO);
    registry.register_type(GETENTITYBUSENTITY_ARRAY_TYPE_INFO);
    registry.register_type(GETENTITYENTITY_TYPE_INFO);
    registry.register_type(GETENTITYENTITY_ARRAY_TYPE_INFO);
    registry.register_type(CALLFUNCTIONENTITY_TYPE_INFO);
    registry.register_type(CALLFUNCTIONENTITY_ARRAY_TYPE_INFO);
    registry.register_type(ENTITYTRANSFORMSPACE_TYPE_INFO);
    registry.register_type(ENTITYTRANSFORMSPACE_ARRAY_TYPE_INFO);
    registry.register_type(ENTITY_TYPE_INFO);
    registry.register_type(ENTITY_ARRAY_TYPE_INFO);
    registry.register_type(COMPONENTENTITY_TYPE_INFO);
    registry.register_type(COMPONENTENTITY_ARRAY_TYPE_INFO);
    registry.register_type(COMPONENT_TYPE_INFO);
    registry.register_type(COMPONENT_ARRAY_TYPE_INFO);
    registry.register_type(COMPAREAXISALIGNEDBOXENTITY_TYPE_INFO);
    registry.register_type(COMPAREAXISALIGNEDBOXENTITY_ARRAY_TYPE_INFO);
    registry.register_type(COMPAREUINTRANGEENTITY_TYPE_INFO);
    registry.register_type(COMPAREUINTRANGEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(COMPAREINTRANGEENTITY_TYPE_INFO);
    registry.register_type(COMPAREINTRANGEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(COMPAREVEC4ENTITY_TYPE_INFO);
    registry.register_type(COMPAREVEC4ENTITY_ARRAY_TYPE_INFO);
    registry.register_type(COMPAREVEC3ENTITY_TYPE_INFO);
    registry.register_type(COMPAREVEC3ENTITY_ARRAY_TYPE_INFO);
    registry.register_type(COMPAREFLOATRANGEENTITY_TYPE_INFO);
    registry.register_type(COMPAREFLOATRANGEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(COMPARESTRINGENTITY_TYPE_INFO);
    registry.register_type(COMPARESTRINGENTITY_ARRAY_TYPE_INFO);
    registry.register_type(COMPAREFLOATENTITY_TYPE_INFO);
    registry.register_type(COMPAREFLOATENTITY_ARRAY_TYPE_INFO);
    registry.register_type(COMPAREUINTENTITY_TYPE_INFO);
    registry.register_type(COMPAREUINTENTITY_ARRAY_TYPE_INFO);
    registry.register_type(COMPAREINTENTITY_TYPE_INFO);
    registry.register_type(COMPAREINTENTITY_ARRAY_TYPE_INFO);
    registry.register_type(COMPAREBOOLENTITY_TYPE_INFO);
    registry.register_type(COMPAREBOOLENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SERVERDILATIONENTITY_TYPE_INFO);
    registry.register_type(SERVERDILATIONENTITY_ARRAY_TYPE_INFO);
    registry.register_type(CLIENTBALANCEDDILATIONENTITY_TYPE_INFO);
    registry.register_type(CLIENTBALANCEDDILATIONENTITY_ARRAY_TYPE_INFO);
    registry.register_type(ANIMTRACKDATA_TYPE_INFO);
    registry.register_type(ANIMTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(SEQUENCEENTITY_TYPE_INFO);
    registry.register_type(SEQUENCEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(STRINGBUILDERENTITY_TYPE_INFO);
    registry.register_type(STRINGBUILDERENTITY_ARRAY_TYPE_INFO);
    registry.register_type(VEC4CHANGEDENTITY_TYPE_INFO);
    registry.register_type(VEC4CHANGEDENTITY_ARRAY_TYPE_INFO);
    registry.register_type(VEC3CHANGEDENTITY_TYPE_INFO);
    registry.register_type(VEC3CHANGEDENTITY_ARRAY_TYPE_INFO);
    registry.register_type(VEC2CHANGEDENTITY_TYPE_INFO);
    registry.register_type(VEC2CHANGEDENTITY_ARRAY_TYPE_INFO);
    registry.register_type(INTCHANGEDENTITY_TYPE_INFO);
    registry.register_type(INTCHANGEDENTITY_ARRAY_TYPE_INFO);
    registry.register_type(FLOATCHANGEDENTITY_TYPE_INFO);
    registry.register_type(FLOATCHANGEDENTITY_ARRAY_TYPE_INFO);
    registry.register_type(BOOLCHANGEDENTITY_TYPE_INFO);
    registry.register_type(BOOLCHANGEDENTITY_ARRAY_TYPE_INFO);
    registry.register_type(COMPARETRANSFORMENTITY_TYPE_INFO);
    registry.register_type(COMPARETRANSFORMENTITY_ARRAY_TYPE_INFO);
    registry.register_type(GETSCHEMATICSINSTANCE_SCHEMATICSINSTANCE_ENTITY__TYPE_INFO);
    registry.register_type(GETSCHEMATICSINSTANCE_SCHEMATICSINSTANCE_ENTITYBUS__TYPE_INFO);
    registry.register_type(DESTROYENTITY_ENTITY__TYPE_INFO);
    registry.register_type(CREATEENTITY_ENTITY_ENTITYBUS_OBJECTBLUEPRINT_LINEARTRANSFORM__TYPE_INFO);
    registry.register_type(CASTTOSPATIAL_SPATIALENTITY_ENTITY__TYPE_INFO);
    registry.register_type(GETTRANSFORM_SPATIALENTITY_LINEARTRANSFORM__TYPE_INFO);
    registry.register_type(SETTRANSFORM_SPATIALENTITY_LINEARTRANSFORM__TYPE_INFO);
    registry.register_type(UPDATEPASSMASK_TYPE_INFO);
    registry.register_type(UPDATEPASSMASK_ARRAY_TYPE_INFO);
    registry.register_type(UPDATEPASS_TYPE_INFO);
    registry.register_type(UPDATEPASS_ARRAY_TYPE_INFO);
    registry.register_type(GAMEDATACONTAINERASSET_TYPE_INFO);
    registry.register_type(GAMEDATACONTAINERASSET_ARRAY_TYPE_INFO);
    registry.register_type(DATACONTAINERASSET_TYPE_INFO);
    registry.register_type(DATACONTAINERASSET_ARRAY_TYPE_INFO);
    registry.register_type(STATICINSTANCINGDATA_TYPE_INFO);
    registry.register_type(STATICINSTANCINGDATA_ARRAY_TYPE_INFO);
    registry.register_type(PARTDATA_TYPE_INFO);
    registry.register_type(PARTDATA_ARRAY_TYPE_INFO);
    registry.register_type(PARTSTATE_TYPE_INFO);
    registry.register_type(PARTSTATE_ARRAY_TYPE_INFO);
    registry.register_type(BONECOMPONENTDATA_TYPE_INFO);
    registry.register_type(BONECOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(GAMECOMPONENTDATA_TYPE_INFO);
    registry.register_type(GAMECOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(COMPONENTDATA_TYPE_INFO);
    registry.register_type(COMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(GAMECOMPONENTENTITYDATA_TYPE_INFO);
    registry.register_type(GAMECOMPONENTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COMPONENTENTITYDATA_TYPE_INFO);
    registry.register_type(COMPONENTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SCRIPTENTITYDATA_TYPE_INFO);
    registry.register_type(SCRIPTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SPATIALENTITYDATA_TYPE_INFO);
    registry.register_type(SPATIALENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(ENTITYDATA_TYPE_INFO);
    registry.register_type(ENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(ENTITYCREATORTYPE_TYPE_INFO);
    registry.register_type(ENTITYCREATORTYPE_ARRAY_TYPE_INFO);
    registry.register_type(GAMEOBJECTDATA_TYPE_INFO);
    registry.register_type(GAMEOBJECTDATA_ARRAY_TYPE_INFO);
    registry.register_type(SUBREALM_TYPE_INFO);
    registry.register_type(SUBREALM_ARRAY_TYPE_INFO);
    registry.register_type(TIMESHAPE_TYPE_INFO);
    registry.register_type(TIMESHAPE_ARRAY_TYPE_INFO);
    registry.register_type(DILATIONPRIORITY_TYPE_INFO);
    registry.register_type(DILATIONPRIORITY_ARRAY_TYPE_INFO);
    registry.register_type(TIMEDELTATYPE_TYPE_INFO);
    registry.register_type(TIMEDELTATYPE_ARRAY_TYPE_INFO);
    registry.register_type(SCHEMATICCHANNELENTITYDATA_TYPE_INFO);
    registry.register_type(SCHEMATICCHANNELENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SCHEMATICCHANNELASSET_TYPE_INFO);
    registry.register_type(SCHEMATICCHANNELASSET_ARRAY_TYPE_INFO);
    registry.register_type(PROPERTYCHANNEL_TYPE_INFO);
    registry.register_type(PROPERTYCHANNEL_ARRAY_TYPE_INFO);
    registry.register_type(EVENTCHANNEL_TYPE_INFO);
    registry.register_type(EVENTCHANNEL_ARRAY_TYPE_INFO);
    registry.register_type(LINKCHANNEL_TYPE_INFO);
    registry.register_type(LINKCHANNEL_ARRAY_TYPE_INFO);
    registry.register_type(LOGICPREFABREFERENCEOBJECTDATA_TYPE_INFO);
    registry.register_type(LOGICPREFABREFERENCEOBJECTDATA_ARRAY_TYPE_INFO);
    registry.register_type(SPATIALPREFABREFERENCEOBJECTDATA_TYPE_INFO);
    registry.register_type(SPATIALPREFABREFERENCEOBJECTDATA_ARRAY_TYPE_INFO);
    registry.register_type(OBJECTREFERENCEOBJECTDATA_TYPE_INFO);
    registry.register_type(OBJECTREFERENCEOBJECTDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOGICREFERENCEOBJECTDATA_TYPE_INFO);
    registry.register_type(LOGICREFERENCEOBJECTDATA_ARRAY_TYPE_INFO);
    registry.register_type(SPATIALREFERENCEOBJECTDATA_TYPE_INFO);
    registry.register_type(SPATIALREFERENCEOBJECTDATA_ARRAY_TYPE_INFO);
    registry.register_type(REFERENCEOBJECTDATA_TYPE_INFO);
    registry.register_type(REFERENCEOBJECTDATA_ARRAY_TYPE_INFO);
    registry.register_type(STREAMREALM_TYPE_INFO);
    registry.register_type(STREAMREALM_ARRAY_TYPE_INFO);
    registry.register_type(OBJECTVARIATIONCOLLECTION_TYPE_INFO);
    registry.register_type(OBJECTVARIATIONCOLLECTION_ARRAY_TYPE_INFO);
    registry.register_type(OBJECTVARIATION_TYPE_INFO);
    registry.register_type(OBJECTVARIATION_ARRAY_TYPE_INFO);
    registry.register_type(DATACONTAINERCOLLECTIONBLUEPRINT_TYPE_INFO);
    registry.register_type(DATACONTAINERCOLLECTIONBLUEPRINT_ARRAY_TYPE_INFO);
    registry.register_type(LOGICPREFABBLUEPRINT_TYPE_INFO);
    registry.register_type(LOGICPREFABBLUEPRINT_ARRAY_TYPE_INFO);
    registry.register_type(SPATIALPREFABBLUEPRINT_TYPE_INFO);
    registry.register_type(SPATIALPREFABBLUEPRINT_ARRAY_TYPE_INFO);
    registry.register_type(PREFABBLUEPRINT_TYPE_INFO);
    registry.register_type(PREFABBLUEPRINT_ARRAY_TYPE_INFO);
    registry.register_type(OBJECTBLUEPRINT_TYPE_INFO);
    registry.register_type(OBJECTBLUEPRINT_ARRAY_TYPE_INFO);
    registry.register_type(BLUEPRINT_TYPE_INFO);
    registry.register_type(BLUEPRINT_ARRAY_TYPE_INFO);
    registry.register_type(BLUEPRINTPERSISTENCESETTING_TYPE_INFO);
    registry.register_type(BLUEPRINTPERSISTENCESETTING_ARRAY_TYPE_INFO);
    registry.register_type(ENTITYBUSDATA_TYPE_INFO);
    registry.register_type(ENTITYBUSDATA_ARRAY_TYPE_INFO);
    registry.register_type(INTERFACEDESCRIPTORDATA_TYPE_INFO);
    registry.register_type(INTERFACEDESCRIPTORDATA_ARRAY_TYPE_INFO);
    registry.register_type(DYNAMICLINK_TYPE_INFO);
    registry.register_type(DYNAMICLINK_ARRAY_TYPE_INFO);
    registry.register_type(DYNAMICEVENT_TYPE_INFO);
    registry.register_type(DYNAMICEVENT_ARRAY_TYPE_INFO);
    registry.register_type(EVENTCONNECTION_TYPE_INFO);
    registry.register_type(EVENTCONNECTION_ARRAY_TYPE_INFO);
    registry.register_type(EVENTCONNECTIONTARGETTYPE_TYPE_INFO);
    registry.register_type(EVENTCONNECTIONTARGETTYPE_ARRAY_TYPE_INFO);
    registry.register_type(EVENTSPEC_TYPE_INFO);
    registry.register_type(EVENTSPEC_ARRAY_TYPE_INFO);
    registry.register_type(COMPAREAXISALIGNEDBOXENTITYDATA_TYPE_INFO);
    registry.register_type(COMPAREAXISALIGNEDBOXENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COMPAREUINTRANGEENTITYDATA_TYPE_INFO);
    registry.register_type(COMPAREUINTRANGEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COMPAREINTRANGEENTITYDATA_TYPE_INFO);
    registry.register_type(COMPAREINTRANGEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COMPAREFLOATRANGEENTITYDATA_TYPE_INFO);
    registry.register_type(COMPAREFLOATRANGEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COMPARESTRINGENTITYDATA_TYPE_INFO);
    registry.register_type(COMPARESTRINGENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COMPAREVEC4ENTITYDATA_TYPE_INFO);
    registry.register_type(COMPAREVEC4ENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COMPAREVEC3ENTITYDATA_TYPE_INFO);
    registry.register_type(COMPAREVEC3ENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COMPAREFLOATENTITYDATA_TYPE_INFO);
    registry.register_type(COMPAREFLOATENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COMPAREUINTENTITYDATA_TYPE_INFO);
    registry.register_type(COMPAREUINTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COMPAREINTENTITYDATA_TYPE_INFO);
    registry.register_type(COMPAREINTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COMPAREBOOLENTITYDATA_TYPE_INFO);
    registry.register_type(COMPAREBOOLENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COMPAREENTITYBASEDATA_TYPE_INFO);
    registry.register_type(COMPAREENTITYBASEDATA_ARRAY_TYPE_INFO);
    registry.register_type(CLIENTPROFILERDATA_TYPE_INFO);
    registry.register_type(CLIENTPROFILERDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHILDEFFECTENTITYDATA_TYPE_INFO);
    registry.register_type(CHILDEFFECTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(BUNDLETYPE_TYPE_INFO);
    registry.register_type(BUNDLETYPE_ARRAY_TYPE_INFO);
    registry.register_type(AUTOASSETCOLLECTOR_TYPE_INFO);
    registry.register_type(AUTOASSETCOLLECTOR_ARRAY_TYPE_INFO);
    registry.register_type(NETWORKEDOBJECTSASSET_TYPE_INFO);
    registry.register_type(NETWORKEDOBJECTSASSET_ARRAY_TYPE_INFO);
    registry.register_type(NETWORKREGISTRYASSET_TYPE_INFO);
    registry.register_type(NETWORKREGISTRYASSET_ARRAY_TYPE_INFO);
    registry.register_type(BUNDLEHEAPINFO_TYPE_INFO);
    registry.register_type(BUNDLEHEAPINFO_ARRAY_TYPE_INFO);
    registry.register_type(BUNDLEHEAPTYPE_TYPE_INFO);
    registry.register_type(BUNDLEHEAPTYPE_ARRAY_TYPE_INFO);
    registry.register_type(BUNDLESETTINGSINFO_TYPE_INFO);
    registry.register_type(BUNDLESETTINGSINFO_ARRAY_TYPE_INFO);
    registry.register_type(MESHOPERATIONDATA_TYPE_INFO);
    registry.register_type(MESHOPERATIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(SKELETONBASEASSET_TYPE_INFO);
    registry.register_type(SKELETONBASEASSET_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMPARTPROPERTYTRACKDATA_TYPE_INFO);
    registry.register_type(TRANSFORMPARTPROPERTYTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMPARTPROPERTYKEY_TYPE_INFO);
    registry.register_type(TRANSFORMPARTPROPERTYKEY_ARRAY_TYPE_INFO);
    registry.register_type(ANIMTANGENTTYPE_TYPE_INFO);
    registry.register_type(ANIMTANGENTTYPE_ARRAY_TYPE_INFO);
    registry.register_type(CURVEINFINITYTYPE_TYPE_INFO);
    registry.register_type(CURVEINFINITYTYPE_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMPART_TYPE_INFO);
    registry.register_type(TRANSFORMPART_ARRAY_TYPE_INFO);
    registry.register_type(VEC4PROPERTYTRACKDATA_TYPE_INFO);
    registry.register_type(VEC4PROPERTYTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEC3PROPERTYTRACKDATA_TYPE_INFO);
    registry.register_type(VEC3PROPERTYTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEC2PROPERTYTRACKDATA_TYPE_INFO);
    registry.register_type(VEC2PROPERTYTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMPROPERTYTRACKDATA_TYPE_INFO);
    registry.register_type(TRANSFORMPROPERTYTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(INTPROPERTYTRACKDATA_TYPE_INFO);
    registry.register_type(INTPROPERTYTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(FLOATPROPERTYTRACKDATA_TYPE_INFO);
    registry.register_type(FLOATPROPERTYTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(BOOLPROPERTYTRACKDATA_TYPE_INFO);
    registry.register_type(BOOLPROPERTYTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(SIMPLEPROPERTYTRACKDATA_TYPE_INFO);
    registry.register_type(SIMPLEPROPERTYTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(SEQUENCEENTITYDATA_TYPE_INFO);
    registry.register_type(SEQUENCEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CUSTOMSEQUENCETRACKDATA_TYPE_INFO);
    registry.register_type(CUSTOMSEQUENCETRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(CUSTOMSEQUENCETRACKPROPERTYMAPPING_TYPE_INFO);
    registry.register_type(CUSTOMSEQUENCETRACKPROPERTYMAPPING_ARRAY_TYPE_INFO);
    registry.register_type(CUSTOMSEQUENCETRACKEVENTMAPPING_TYPE_INFO);
    registry.register_type(CUSTOMSEQUENCETRACKEVENTMAPPING_ARRAY_TYPE_INFO);
    registry.register_type(CUSTOMSEQUENCETRACKLINKMAPPING_TYPE_INFO);
    registry.register_type(CUSTOMSEQUENCETRACKLINKMAPPING_ARRAY_TYPE_INFO);
    registry.register_type(PROPERTYTRACKDATA_TYPE_INFO);
    registry.register_type(PROPERTYTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(INTERPOLATIONTYPE_TYPE_INFO);
    registry.register_type(INTERPOLATIONTYPE_ARRAY_TYPE_INFO);
    registry.register_type(SEQUENCEEVENTDATA_TYPE_INFO);
    registry.register_type(SEQUENCEEVENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(ENTITYCLASSINFOASSET_TYPE_INFO);
    registry.register_type(ENTITYCLASSINFOASSET_ARRAY_TYPE_INFO);
    registry.register_type(AUTOPAINTOUTPUTOVERRIDEBASE_TYPE_INFO);
    registry.register_type(AUTOPAINTOUTPUTOVERRIDEBASE_ARRAY_TYPE_INFO);
    registry.register_type(AUTOPAINTOUTPUTBASE_TYPE_INFO);
    registry.register_type(AUTOPAINTOUTPUTBASE_ARRAY_TYPE_INFO);
    registry.register_type(AUTOPAINTOUTPUTSBASE_TYPE_INFO);
    registry.register_type(AUTOPAINTOUTPUTSBASE_ARRAY_TYPE_INFO);
    registry.register_type(RASTERTYPE_TYPE_INFO);
    registry.register_type(RASTERTYPE_ARRAY_TYPE_INFO);
    registry.register_type(RASTERFORMAT_TYPE_INFO);
    registry.register_type(RASTERFORMAT_ARRAY_TYPE_INFO);
    registry.register_type(BASESHAPEDATABASE_TYPE_INFO);
    registry.register_type(BASESHAPEDATABASE_ARRAY_TYPE_INFO);
    registry.register_type(BASEMATERIALDATAPAIR_TYPE_INFO);
    registry.register_type(BASEMATERIALDATAPAIR_ARRAY_TYPE_INFO);
    registry.register_type(MATERIALGRIDDATA_TYPE_INFO);
    registry.register_type(MATERIALGRIDDATA_ARRAY_TYPE_INFO);
    registry.register_type(MATERIALINTERACTIONGRIDROW_TYPE_INFO);
    registry.register_type(MATERIALINTERACTIONGRIDROW_ARRAY_TYPE_INFO);
    registry.register_type(MATERIALRELATIONPROPERTYPAIR_TYPE_INFO);
    registry.register_type(MATERIALRELATIONPROPERTYPAIR_ARRAY_TYPE_INFO);
    registry.register_type(PHYSICSPROPERTYRELATIONPROPERTYDATA_TYPE_INFO);
    registry.register_type(PHYSICSPROPERTYRELATIONPROPERTYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PHYSICSMATERIALRELATIONPROPERTYDATA_TYPE_INFO);
    registry.register_type(PHYSICSMATERIALRELATIONPROPERTYDATA_ARRAY_TYPE_INFO);
    registry.register_type(MATERIALRELATIONPROPERTYDATA_TYPE_INFO);
    registry.register_type(MATERIALRELATIONPROPERTYDATA_ARRAY_TYPE_INFO);
    registry.register_type(MATERIALDECL_TYPE_INFO);
    registry.register_type(MATERIALDECL_ARRAY_TYPE_INFO);
    registry.register_type(STRINGBUILDERENTITYDATA_TYPE_INFO);
    registry.register_type(STRINGBUILDERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEC4CHANGEDENTITYDATA_TYPE_INFO);
    registry.register_type(VEC4CHANGEDENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEC3CHANGEDENTITYDATA_TYPE_INFO);
    registry.register_type(VEC3CHANGEDENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEC2CHANGEDENTITYDATA_TYPE_INFO);
    registry.register_type(VEC2CHANGEDENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(INTCHANGEDENTITYDATA_TYPE_INFO);
    registry.register_type(INTCHANGEDENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(FLOATCHANGEDENTITYDATA_TYPE_INFO);
    registry.register_type(FLOATCHANGEDENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(BOOLCHANGEDENTITYDATA_TYPE_INFO);
    registry.register_type(BOOLCHANGEDENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PROPERTYCHANGEDENTITYDATA_TYPE_INFO);
    registry.register_type(PROPERTYCHANGEDENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COMPARETRANSFORMENTITYDATA_TYPE_INFO);
    registry.register_type(COMPARETRANSFORMENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SWITCHENUMENTITYDATA_TYPE_INFO);
    registry.register_type(SWITCHENUMENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(EVENTNAME_TYPE_INFO);
    registry.register_type(EVENTNAME_ARRAY_TYPE_INFO);
    registry.register_type(SETENUMENTITYDATA_TYPE_INFO);
    registry.register_type(SETENUMENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SETENUMVALUECONTAINER_TYPE_INFO);
    registry.register_type(SETENUMVALUECONTAINER_ARRAY_TYPE_INFO);
    registry.register_type(INTTOENUMENTITYDATA_TYPE_INFO);
    registry.register_type(INTTOENUMENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(WRITEARRAYELEMENTENTITYDATA_TYPE_INFO);
    registry.register_type(WRITEARRAYELEMENTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(READARRAYSIZEENTITYDATA_TYPE_INFO);
    registry.register_type(READARRAYSIZEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(READARRAYELEMENTENTITYDATA_TYPE_INFO);
    registry.register_type(READARRAYELEMENTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(FOREACHVARIABLEENTITYDATA_TYPE_INFO);
    registry.register_type(FOREACHVARIABLEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CLEARARRAYVARIABLEENTITYDATA_TYPE_INFO);
    registry.register_type(CLEARARRAYVARIABLEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(ADDTOARRAYVARIABLEENTITYDATA_TYPE_INFO);
    registry.register_type(ADDTOARRAYVARIABLEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(WRITEVARIABLEENTITYDATA_TYPE_INFO);
    registry.register_type(WRITEVARIABLEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(READVARIABLEENTITYDATA_TYPE_INFO);
    registry.register_type(READVARIABLEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(WRITEVARIABLEBASEENTITYDATA_TYPE_INFO);
    registry.register_type(WRITEVARIABLEBASEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(READVARIABLEBASEENTITYDATA_TYPE_INFO);
    registry.register_type(READVARIABLEBASEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VARIABLEBASEENTITYDATA_TYPE_INFO);
    registry.register_type(VARIABLEBASEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(HIGHLIGHTENTITYDATA_TYPE_INFO);
    registry.register_type(HIGHLIGHTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TEXTSEQUENCEENTITYDATA_TYPE_INFO);
    registry.register_type(TEXTSEQUENCEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TEXTSEQUENCEITEM_TYPE_INFO);
    registry.register_type(TEXTSEQUENCEITEM_ARRAY_TYPE_INFO);
    registry.register_type(TREEBASE_TYPE_INFO);
    registry.register_type(TREEBASE_ARRAY_TYPE_INFO);
    registry.register_type(TREENODEBASE_TYPE_INFO);
    registry.register_type(TREENODEBASE_ARRAY_TYPE_INFO);
    registry.register_type(SUBLEVELDESTROYEDMESSAGE_TYPE_INFO);
    registry.register_type(SUBLEVELENTITIESCREATEDMESSAGE_TYPE_INFO);
    registry.register_type(REPORTINSTALLATIONPROGRESSENTITYDATA_TYPE_INFO);
    registry.register_type(REPORTINSTALLATIONPROGRESSENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOCALPLAYERIDENTITYDATA_TYPE_INFO);
    registry.register_type(LOCALPLAYERIDENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(FLOATCACHEENTITYDATA_TYPE_INFO);
    registry.register_type(FLOATCACHEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(MULTILINESTRINGENTITYDATA_TYPE_INFO);
    registry.register_type(MULTILINESTRINGENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(STRINGENTITYDATA_TYPE_INFO);
    registry.register_type(STRINGENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMENTITYDATA_TYPE_INFO);
    registry.register_type(TRANSFORMENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AXISALIGNEDBOXENTITYDATA_TYPE_INFO);
    registry.register_type(AXISALIGNEDBOXENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VECTOR4ENTITYDATA_TYPE_INFO);
    registry.register_type(VECTOR4ENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VECTOR3ENTITYDATA_TYPE_INFO);
    registry.register_type(VECTOR3ENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(FLOATENTITYDATA_TYPE_INFO);
    registry.register_type(FLOATENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(UINTENTITYDATA_TYPE_INFO);
    registry.register_type(UINTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(INTENTITYDATA_TYPE_INFO);
    registry.register_type(INTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(BOOLENTITYDATA_TYPE_INFO);
    registry.register_type(BOOLENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(MASTERSKELETONASSET_TYPE_INFO);
    registry.register_type(MASTERSKELETONASSET_ARRAY_TYPE_INFO);
    registry.register_type(SUBSKELETON_TYPE_INFO);
    registry.register_type(SUBSKELETON_ARRAY_TYPE_INFO);
    registry.register_type(SKELETONASSET_TYPE_INFO);
    registry.register_type(SKELETONASSET_ARRAY_TYPE_INFO);
    registry.register_type(BONESELECTION_TYPE_INFO);
    registry.register_type(BONESELECTION_ARRAY_TYPE_INFO);
    registry.register_type(GAMEPLAYBONE_TYPE_INFO);
    registry.register_type(GAMEPLAYBONE_ARRAY_TYPE_INFO);
    registry.register_type(GAMEPLAYBONES_TYPE_INFO);
    registry.register_type(GAMEPLAYBONES_ARRAY_TYPE_INFO);
    registry.register_type(SHAREDBUNDLEREFERENCE_TYPE_INFO);
    registry.register_type(SHAREDBUNDLEREFERENCE_ARRAY_TYPE_INFO);
    registry.register_type(SHAREDBUNDLEBASEASSET_TYPE_INFO);
    registry.register_type(SHAREDBUNDLEBASEASSET_ARRAY_TYPE_INFO);
    registry.register_type(SCANLINEVOLUMESHAPEDATA_TYPE_INFO);
    registry.register_type(SCANLINEVOLUMESHAPEDATA_ARRAY_TYPE_INFO);
    registry.register_type(ZONEVECTORSHAPEDATA_TYPE_INFO);
    registry.register_type(ZONEVECTORSHAPEDATA_ARRAY_TYPE_INFO);
    registry.register_type(VOLUMEVECTORSHAPEDATA_TYPE_INFO);
    registry.register_type(VOLUMEVECTORSHAPEDATA_ARRAY_TYPE_INFO);
    registry.register_type(CUSTOMSPLINEDATA_TYPE_INFO);
    registry.register_type(CUSTOMSPLINEDATA_ARRAY_TYPE_INFO);
    registry.register_type(VECTORSHAPEDATA_TYPE_INFO);
    registry.register_type(VECTORSHAPEDATA_ARRAY_TYPE_INFO);
    registry.register_type(OBBDATA_TYPE_INFO);
    registry.register_type(OBBDATA_ARRAY_TYPE_INFO);
    registry.register_type(AABBDATA_TYPE_INFO);
    registry.register_type(AABBDATA_ARRAY_TYPE_INFO);
    registry.register_type(SPHEREDATA_TYPE_INFO);
    registry.register_type(SPHEREDATA_ARRAY_TYPE_INFO);
    registry.register_type(BASESHAPEDATA_TYPE_INFO);
    registry.register_type(BASESHAPEDATA_ARRAY_TYPE_INFO);
    registry.register_type(SELECTVEC4ENTITYDATA_TYPE_INFO);
    registry.register_type(SELECTVEC4ENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SELECTVEC3ENTITYDATA_TYPE_INFO);
    registry.register_type(SELECTVEC3ENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SELECTVEC2ENTITYDATA_TYPE_INFO);
    registry.register_type(SELECTVEC2ENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SELECTTRANSFORMENTITYDATA_TYPE_INFO);
    registry.register_type(SELECTTRANSFORMENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SELECTBOOLENTITYDATA_TYPE_INFO);
    registry.register_type(SELECTBOOLENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SELECTSTRINGENTITYDATA_TYPE_INFO);
    registry.register_type(SELECTSTRINGENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SELECTINT64ENTITYDATA_TYPE_INFO);
    registry.register_type(SELECTINT64ENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SELECTINTENTITYDATA_TYPE_INFO);
    registry.register_type(SELECTINTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SELECTFLOATENTITYDATA_TYPE_INFO);
    registry.register_type(SELECTFLOATENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SELECTPROPERTYENTITYDATA_TYPE_INFO);
    registry.register_type(SELECTPROPERTYENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PATHFINDINGOBJECTCATEGORYASSET_TYPE_INFO);
    registry.register_type(PATHFINDINGOBJECTCATEGORYASSET_ARRAY_TYPE_INFO);
    registry.register_type(OBJECTAREATRIGGERENTITYDATA_TYPE_INFO);
    registry.register_type(OBJECTAREATRIGGERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(OBJECTVARIATIONTOINTENTITYDATA_TYPE_INFO);
    registry.register_type(OBJECTVARIATIONTOINTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMSPACEENTITYDATA_TYPE_INFO);
    registry.register_type(TRANSFORMSPACEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(BALANCEDDILATIONENTITYDATA_TYPE_INFO);
    registry.register_type(BALANCEDDILATIONENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(DILATIONENTITYDATA_TYPE_INFO);
    registry.register_type(DILATIONENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(FLOATSELECTENTITYDATA_TYPE_INFO);
    registry.register_type(FLOATSELECTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(FLOATCURVEENTITYDATA_TYPE_INFO);
    registry.register_type(FLOATCURVEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOCALPLAYERGATEENTITYDATA_TYPE_INFO);
    registry.register_type(LOCALPLAYERGATEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMSELECTORENTITYDATA_TYPE_INFO);
    registry.register_type(TRANSFORMSELECTORENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SETTINGENTITYDATA_TYPE_INFO);
    registry.register_type(SETTINGENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(INTEGRATORORDIFFERENTIATORENTITYDATA_TYPE_INFO);
    registry.register_type(INTEGRATORORDIFFERENTIATORENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PROFILEENTITYDATA_TYPE_INFO);
    registry.register_type(PROFILEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COMPAREENTITYDATA_TYPE_INFO);
    registry.register_type(COMPAREENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COMPAREOP_TYPE_INFO);
    registry.register_type(COMPAREOP_ARRAY_TYPE_INFO);
    registry.register_type(RUNNINGAVERAGEENTITYDATA_TYPE_INFO);
    registry.register_type(RUNNINGAVERAGEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(ABSENTITYDATA_TYPE_INFO);
    registry.register_type(ABSENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VECTORMATHOPENTITYDATA_TYPE_INFO);
    registry.register_type(VECTORMATHOPENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VECTORMATHOP_TYPE_INFO);
    registry.register_type(VECTORMATHOP_ARRAY_TYPE_INFO);
    registry.register_type(MATHOPENTITYDATA_TYPE_INFO);
    registry.register_type(MATHOPENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(MATHOP_TYPE_INFO);
    registry.register_type(MATHOP_ARRAY_TYPE_INFO);
    registry.register_type(PROPERTYCASTENTITYDATA_TYPE_INFO);
    registry.register_type(PROPERTYCASTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(BOOLTOEVENTENTITYDATA_TYPE_INFO);
    registry.register_type(BOOLTOEVENTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SWITCHPROPERTYSTRINGENTITYDATA_TYPE_INFO);
    registry.register_type(SWITCHPROPERTYSTRINGENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PROPERTYGATEENTITYDATA_TYPE_INFO);
    registry.register_type(PROPERTYGATEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(EVENTGATEENTITYDATA_TYPE_INFO);
    registry.register_type(EVENTGATEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(STOPWATCHENTITYDATA_TYPE_INFO);
    registry.register_type(STOPWATCHENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMTOROTATIONENTITYDATA_TYPE_INFO);
    registry.register_type(TRANSFORMTOROTATIONENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMMODIFIERENTITYDATA_TYPE_INFO);
    registry.register_type(TRANSFORMMODIFIERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(MODIFIERAXIS_TYPE_INFO);
    registry.register_type(MODIFIERAXIS_ARRAY_TYPE_INFO);
    registry.register_type(ROTATIONTRANSFORMBUILDERENTITYDATA_TYPE_INFO);
    registry.register_type(ROTATIONTRANSFORMBUILDERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SCALETRANSFORMBUILDERENTITYDATA_TYPE_INFO);
    registry.register_type(SCALETRANSFORMBUILDERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMBUILDERENTITYDATA_TYPE_INFO);
    registry.register_type(TRANSFORMBUILDERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(ORTHONORMALMODE_TYPE_INFO);
    registry.register_type(ORTHONORMALMODE_ARRAY_TYPE_INFO);
    registry.register_type(VECBUILDERENTITYDATA_TYPE_INFO);
    registry.register_type(VECBUILDERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEC4BUILDERENTITYDATA_TYPE_INFO);
    registry.register_type(VEC4BUILDERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEC3BUILDERENTITYDATA_TYPE_INFO);
    registry.register_type(VEC3BUILDERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEC2BUILDERENTITYDATA_TYPE_INFO);
    registry.register_type(VEC2BUILDERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VECSPLITTERENTITYDATA_TYPE_INFO);
    registry.register_type(VECSPLITTERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEC4SPLITTERENTITYDATA_TYPE_INFO);
    registry.register_type(VEC4SPLITTERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEC3SPLITTERENTITYDATA_TYPE_INFO);
    registry.register_type(VEC3SPLITTERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEC2SPLITTERENTITYDATA_TYPE_INFO);
    registry.register_type(VEC2SPLITTERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(EULERTRANSFORMENTITYDATA_TYPE_INFO);
    registry.register_type(EULERTRANSFORMENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(MODIFIEREULER_TYPE_INFO);
    registry.register_type(MODIFIEREULER_ARRAY_TYPE_INFO);
    registry.register_type(EULERTRANSFORMSPLITTERENTITYDATA_TYPE_INFO);
    registry.register_type(EULERTRANSFORMSPLITTERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMSPLITTERENTITYDATA_TYPE_INFO);
    registry.register_type(TRANSFORMSPLITTERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMBLENDENTITYDATA_TYPE_INFO);
    registry.register_type(TRANSFORMBLENDENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMMULTIPLIERENTITYDATA_TYPE_INFO);
    registry.register_type(TRANSFORMMULTIPLIERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMHUBENTITYDATA_TYPE_INFO);
    registry.register_type(TRANSFORMHUBENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(STRINGHUBENTITYDATA_TYPE_INFO);
    registry.register_type(STRINGHUBENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEC4HUBENTITYDATA_TYPE_INFO);
    registry.register_type(VEC4HUBENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEC3HUBENTITYDATA_TYPE_INFO);
    registry.register_type(VEC3HUBENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEC2HUBENTITYDATA_TYPE_INFO);
    registry.register_type(VEC2HUBENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(FLOATHUBENTITYDATA_TYPE_INFO);
    registry.register_type(FLOATHUBENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(INT64HUBENTITYDATA_TYPE_INFO);
    registry.register_type(INT64HUBENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(INTHUBENTITYDATA_TYPE_INFO);
    registry.register_type(INTHUBENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(BOOLHUBENTITYDATA_TYPE_INFO);
    registry.register_type(BOOLHUBENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SIMPLEDOFPARAMCONVERTERENTITYDATA_TYPE_INFO);
    registry.register_type(SIMPLEDOFPARAMCONVERTERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SPRITEDOFPARAMCONVERTERENTITYDATA_TYPE_INFO);
    registry.register_type(SPRITEDOFPARAMCONVERTERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(OBJECTVARIATIONMULTISWITCHENTITYDATA_TYPE_INFO);
    registry.register_type(OBJECTVARIATIONMULTISWITCHENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(OBJECTVARIATIONSWITCHENTITYDATA_TYPE_INFO);
    registry.register_type(OBJECTVARIATIONSWITCHENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(RANDOMDELAYENTITYDATA_TYPE_INFO);
    registry.register_type(RANDOMDELAYENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(DELAYENTITYDATA_TYPE_INFO);
    registry.register_type(DELAYENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(EVENTORDERGATEENTITYDATA_TYPE_INFO);
    registry.register_type(EVENTORDERGATEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(EVENTANDGATEENTITYDATA_TYPE_INFO);
    registry.register_type(EVENTANDGATEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SELECTEVENTENTITYDATA_TYPE_INFO);
    registry.register_type(SELECTEVENTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(EVENTSWITCHENTITYDATA_TYPE_INFO);
    registry.register_type(EVENTSWITCHENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(UNIQUEIDENTITYDATA_TYPE_INFO);
    registry.register_type(UNIQUEIDENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(RANDOMINTENTITYDATA_TYPE_INFO);
    registry.register_type(RANDOMINTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(RANDOMFLOATENTITYDATA_TYPE_INFO);
    registry.register_type(RANDOMFLOATENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(RANDOMMULTIEVENTENTITYDATA_TYPE_INFO);
    registry.register_type(RANDOMMULTIEVENTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(RANDOMEVENTENTITYDATA_TYPE_INFO);
    registry.register_type(RANDOMEVENTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOCATORENTITYDATA_TYPE_INFO);
    registry.register_type(LOCATORENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COUNTDOWNENTITYDATA_TYPE_INFO);
    registry.register_type(COUNTDOWNENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(MATHENTITYDATA_TYPE_INFO);
    registry.register_type(MATHENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(MATHENTITYASSEMBLY_TYPE_INFO);
    registry.register_type(MATHENTITYASSEMBLY_ARRAY_TYPE_INFO);
    registry.register_type(MATHENTITYTYPE_TYPE_INFO);
    registry.register_type(MATHENTITYTYPE_ARRAY_TYPE_INFO);
    registry.register_type(MATHENTITYFUNCTIONCALL_TYPE_INFO);
    registry.register_type(MATHENTITYFUNCTIONCALL_ARRAY_TYPE_INFO);
    registry.register_type(MATHENTITYINSTRUCTION_TYPE_INFO);
    registry.register_type(MATHENTITYINSTRUCTION_ARRAY_TYPE_INFO);
    registry.register_type(MATHOPCODE_TYPE_INFO);
    registry.register_type(MATHOPCODE_ARRAY_TYPE_INFO);
    registry.register_type(OR4ENTITYDATA_TYPE_INFO);
    registry.register_type(OR4ENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(XORENTITYDATA_TYPE_INFO);
    registry.register_type(XORENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(ORENTITYDATA_TYPE_INFO);
    registry.register_type(ORENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(BITWISEANDENTITYDATA_TYPE_INFO);
    registry.register_type(BITWISEANDENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANDENTITYDATA_TYPE_INFO);
    registry.register_type(ANDENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(NOTENTITYDATA_TYPE_INFO);
    registry.register_type(NOTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CREATESCHEMATICSINSTANCEENTITYDATA_TYPE_INFO);
    registry.register_type(CREATESCHEMATICSINSTANCEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(GETENTITYBUSENTITYDATA_TYPE_INFO);
    registry.register_type(GETENTITYBUSENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(GETENTITYENTITYDATA_TYPE_INFO);
    registry.register_type(GETENTITYENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CALLFUNCTIONENTITYDATA_TYPE_INFO);
    registry.register_type(CALLFUNCTIONENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(ENTITYOWNERUID_TYPE_INFO);
    registry.register_type(ENTITYOWNERUID_ARRAY_TYPE_INFO);
    registry.register_type(ENTITYUID_TYPE_INFO);
    registry.register_type(ENTITYUID_ARRAY_TYPE_INFO);
    registry.register_type(SETTRANSFORMSPACELOCALTRANSFORM_ENTITYTRANSFORMSPACE_LINEARTRANSFORM__TYPE_INFO);
    registry.register_type(GETTRANSFORMSPACE_ENTITYTRANSFORMSPACE_ENTITY__TYPE_INFO);
    registry.register_type(TRANSFORMSPACECHILDCONTROLSETTING_TYPE_INFO);
    registry.register_type(TRANSFORMSPACECHILDCONTROLSETTING_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMSPACESIMULATIONSETTING_TYPE_INFO);
    registry.register_type(TRANSFORMSPACESIMULATIONSETTING_ARRAY_TYPE_INFO);
    registry.register_type(ENTITYSETTINGS_TYPE_INFO);
    registry.register_type(ENTITYSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(EXECUTIONMODETYPE_TYPE_INFO);
    registry.register_type(EXECUTIONMODETYPE_ARRAY_TYPE_INFO);
    registry.register_type(SWITCHENUMENTITY_TYPE_INFO);
    registry.register_type(SWITCHENUMENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SETENUMENTITY_TYPE_INFO);
    registry.register_type(SETENUMENTITY_ARRAY_TYPE_INFO);
    registry.register_type(INTTOENUMENTITY_TYPE_INFO);
    registry.register_type(INTTOENUMENTITY_ARRAY_TYPE_INFO);
    registry.register_type(ENUMTOSTRINGENTITY_TYPE_INFO);
    registry.register_type(ENUMTOSTRINGENTITY_ARRAY_TYPE_INFO);
    registry.register_type(ENUMTOINTENTITY_TYPE_INFO);
    registry.register_type(ENUMTOINTENTITY_ARRAY_TYPE_INFO);
    registry.register_type(ENUMPROPERTYGATEENTITY_TYPE_INFO);
    registry.register_type(ENUMPROPERTYGATEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(ENUMLOGICENTITYWITHSINGLEINPUT_TYPE_INFO);
    registry.register_type(ENUMLOGICENTITYWITHSINGLEINPUT_ARRAY_TYPE_INFO);
    registry.register_type(ENUMINTSOURCEENTITY_TYPE_INFO);
    registry.register_type(ENUMINTSOURCEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(COMPAREENUMENTITY_TYPE_INFO);
    registry.register_type(COMPAREENUMENTITY_ARRAY_TYPE_INFO);
    registry.register_type(ENTITYBUSPEER_TYPE_INFO);
    registry.register_type(ENTITYBUSPEER_ARRAY_TYPE_INFO);
    registry.register_type(ENTITYEVENT_TYPE_INFO);
    registry.register_type(ENTITYEVENT_ARRAY_TYPE_INFO);
    registry.register_type(ENTITYBUS_TYPE_INFO);
    registry.register_type(ENTITYBUS_ARRAY_TYPE_INFO);
    registry.register_type(DATASOURCEQUERYENTITY_TYPE_INFO);
    registry.register_type(DATASOURCEQUERYENTITY_ARRAY_TYPE_INFO);
    registry.register_type(ENUMTOSTRINGDATA_TYPE_INFO);
    registry.register_type(ENUMTOSTRINGDATA_ARRAY_TYPE_INFO);
    registry.register_type(ENUMTOINTDATA_TYPE_INFO);
    registry.register_type(ENUMTOINTDATA_ARRAY_TYPE_INFO);
    registry.register_type(ENUMPROPERTYGATEENTITYDATA_TYPE_INFO);
    registry.register_type(ENUMPROPERTYGATEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(ENUMDEBUGENTITYDATA_TYPE_INFO);
    registry.register_type(ENUMDEBUGENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(IMPLIEDENUMTYPELOGICENTITYDATA_TYPE_INFO);
    registry.register_type(IMPLIEDENUMTYPELOGICENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(EXPLICITENUMTYPELOGICENTITYDATA_TYPE_INFO);
    registry.register_type(EXPLICITENUMTYPELOGICENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(ENUMLOGICENTITYBASEDATA_TYPE_INFO);
    registry.register_type(ENUMLOGICENTITYBASEDATA_ARRAY_TYPE_INFO);
    registry.register_type(ENUMINTSOURCEENTITYDATA_TYPE_INFO);
    registry.register_type(ENUMINTSOURCEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(ENUMINTSOURCEPROPERTY_TYPE_INFO);
    registry.register_type(ENUMINTSOURCEPROPERTY_ARRAY_TYPE_INFO);
    registry.register_type(COMPAREENUMENTITYDATA_TYPE_INFO);
    registry.register_type(COMPAREENUMENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(DATASOURCEQUERYENTITYDATA_TYPE_INFO);
    registry.register_type(DATASOURCEQUERYENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(DATASOURCEQUERYFIELDDEFINITION_TYPE_INFO);
    registry.register_type(DATASOURCEQUERYFIELDDEFINITION_ARRAY_TYPE_INFO);
    registry.register_type(PROPERTYWRAPPER_TYPE_INFO);
    registry.register_type(PROPERTYWRAPPER_ARRAY_TYPE_INFO);
    registry.register_type(BUNDLEMANAGERBUNDLEUNLOADMESSAGE_TYPE_INFO);
    registry.register_type(WRITEARRAYELEMENTENTITY_TYPE_INFO);
    registry.register_type(WRITEARRAYELEMENTENTITY_ARRAY_TYPE_INFO);
    registry.register_type(READARRAYSIZEENTITY_TYPE_INFO);
    registry.register_type(READARRAYSIZEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(READARRAYELEMENTENTITY_TYPE_INFO);
    registry.register_type(READARRAYELEMENTENTITY_ARRAY_TYPE_INFO);
    registry.register_type(FOREACHVARIABLEENTITY_TYPE_INFO);
    registry.register_type(FOREACHVARIABLEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(CLEARARRAYVARIABLEENTITY_TYPE_INFO);
    registry.register_type(CLEARARRAYVARIABLEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(ADDTOARRAYVARIABLEENTITY_TYPE_INFO);
    registry.register_type(ADDTOARRAYVARIABLEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(WRITEVARIABLEENTITY_TYPE_INFO);
    registry.register_type(WRITEVARIABLEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(READVARIABLEENTITY_TYPE_INFO);
    registry.register_type(READVARIABLEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(HIGHLIGHTENTITY_TYPE_INFO);
    registry.register_type(HIGHLIGHTENTITY_ARRAY_TYPE_INFO);
    registry.register_type(TEXTSEQUENCEENTITY_TYPE_INFO);
    registry.register_type(TEXTSEQUENCEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SUBLEVELENTITY_TYPE_INFO);
    registry.register_type(SUBLEVELENTITY_ARRAY_TYPE_INFO);
    registry.register_type(REPORTINSTALLATIONPROGRESSENTITY_TYPE_INFO);
    registry.register_type(REPORTINSTALLATIONPROGRESSENTITY_ARRAY_TYPE_INFO);
    registry.register_type(LOCALPLAYERIDENTITY_TYPE_INFO);
    registry.register_type(LOCALPLAYERIDENTITY_ARRAY_TYPE_INFO);
    registry.register_type(FLOATCACHEENTITY_TYPE_INFO);
    registry.register_type(FLOATCACHEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(MULTILINESTRINGENTITY_TYPE_INFO);
    registry.register_type(MULTILINESTRINGENTITY_ARRAY_TYPE_INFO);
    registry.register_type(STRINGENTITY_TYPE_INFO);
    registry.register_type(STRINGENTITY_ARRAY_TYPE_INFO);
    registry.register_type(AXISALIGNEDBOXENTITY_TYPE_INFO);
    registry.register_type(AXISALIGNEDBOXENTITY_ARRAY_TYPE_INFO);
    registry.register_type(VECTOR4ENTITY_TYPE_INFO);
    registry.register_type(VECTOR4ENTITY_ARRAY_TYPE_INFO);
    registry.register_type(VECTOR3ENTITY_TYPE_INFO);
    registry.register_type(VECTOR3ENTITY_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMENTITY_TYPE_INFO);
    registry.register_type(TRANSFORMENTITY_ARRAY_TYPE_INFO);
    registry.register_type(FLOATENTITY_TYPE_INFO);
    registry.register_type(FLOATENTITY_ARRAY_TYPE_INFO);
    registry.register_type(UINTENTITY_TYPE_INFO);
    registry.register_type(UINTENTITY_ARRAY_TYPE_INFO);
    registry.register_type(INTENTITY_TYPE_INFO);
    registry.register_type(INTENTITY_ARRAY_TYPE_INFO);
    registry.register_type(BOOLENTITY_TYPE_INFO);
    registry.register_type(BOOLENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SPATIALENTITY_TYPE_INFO);
    registry.register_type(SPATIALENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SELECTVEC4ENTITY_TYPE_INFO);
    registry.register_type(SELECTVEC4ENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SELECTVEC3ENTITY_TYPE_INFO);
    registry.register_type(SELECTVEC3ENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SELECTVEC2ENTITY_TYPE_INFO);
    registry.register_type(SELECTVEC2ENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SELECTTRANSFORMENTITY_TYPE_INFO);
    registry.register_type(SELECTTRANSFORMENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SELECTBOOLENTITY_TYPE_INFO);
    registry.register_type(SELECTBOOLENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SELECTSTRINGENTITY_TYPE_INFO);
    registry.register_type(SELECTSTRINGENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SELECTINT64ENTITY_TYPE_INFO);
    registry.register_type(SELECTINT64ENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SELECTINTENTITY_TYPE_INFO);
    registry.register_type(SELECTINTENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SELECTFLOATENTITY_TYPE_INFO);
    registry.register_type(SELECTFLOATENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SCRIPTENTITY_TYPE_INFO);
    registry.register_type(SCRIPTENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SCHEMATICCHANNELENTITY_TYPE_INFO);
    registry.register_type(SCHEMATICCHANNELENTITY_ARRAY_TYPE_INFO);
    registry.register_type(PART_TYPE_INFO);
    registry.register_type(PART_ARRAY_TYPE_INFO);
    registry.register_type(OBJECTAREATRIGGERENTITY_TYPE_INFO);
    registry.register_type(OBJECTAREATRIGGERENTITY_ARRAY_TYPE_INFO);
    registry.register_type(OBJECTVARIATIONTOINTENTITY_TYPE_INFO);
    registry.register_type(OBJECTVARIATIONTOINTENTITY_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMSPACEENTITY_TYPE_INFO);
    registry.register_type(TRANSFORMSPACEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(FLOATSELECTENTITY_TYPE_INFO);
    registry.register_type(FLOATSELECTENTITY_ARRAY_TYPE_INFO);
    registry.register_type(FLOATCURVEENTITY_TYPE_INFO);
    registry.register_type(FLOATCURVEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SETTINGENTITY_TYPE_INFO);
    registry.register_type(SETTINGENTITY_ARRAY_TYPE_INFO);
    registry.register_type(INTEGRATORORDIFFERENTIATORENTITY_TYPE_INFO);
    registry.register_type(INTEGRATORORDIFFERENTIATORENTITY_ARRAY_TYPE_INFO);
    registry.register_type(PROFILEENTITY_TYPE_INFO);
    registry.register_type(PROFILEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(COMPAREENTITY_TYPE_INFO);
    registry.register_type(COMPAREENTITY_ARRAY_TYPE_INFO);
    registry.register_type(RUNNINGAVERAGEENTITY_TYPE_INFO);
    registry.register_type(RUNNINGAVERAGEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(ABSENTITY_TYPE_INFO);
    registry.register_type(ABSENTITY_ARRAY_TYPE_INFO);
    registry.register_type(VECTORMATHOPENTITY_TYPE_INFO);
    registry.register_type(VECTORMATHOPENTITY_ARRAY_TYPE_INFO);
    registry.register_type(MATHOPENTITY_TYPE_INFO);
    registry.register_type(MATHOPENTITY_ARRAY_TYPE_INFO);
    registry.register_type(PROPERTYCASTENTITY_TYPE_INFO);
    registry.register_type(PROPERTYCASTENTITY_ARRAY_TYPE_INFO);
    registry.register_type(BOOLTOEVENTENTITY_TYPE_INFO);
    registry.register_type(BOOLTOEVENTENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SWITCHPROPERTYSTRINGENTITY_TYPE_INFO);
    registry.register_type(SWITCHPROPERTYSTRINGENTITY_ARRAY_TYPE_INFO);
    registry.register_type(PROPERTYGATEENTITY_TYPE_INFO);
    registry.register_type(PROPERTYGATEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(EVENTGATEENTITY_TYPE_INFO);
    registry.register_type(EVENTGATEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(STOPWATCHENTITY_TYPE_INFO);
    registry.register_type(STOPWATCHENTITY_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMTOROTATIONENTITY_TYPE_INFO);
    registry.register_type(TRANSFORMTOROTATIONENTITY_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMMODIFIERENTITY_TYPE_INFO);
    registry.register_type(TRANSFORMMODIFIERENTITY_ARRAY_TYPE_INFO);
    registry.register_type(ROTATIONTRANSFORMBUILDERENTITY_TYPE_INFO);
    registry.register_type(ROTATIONTRANSFORMBUILDERENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SCALETRANSFORMBUILDERENTITY_TYPE_INFO);
    registry.register_type(SCALETRANSFORMBUILDERENTITY_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMBUILDERENTITY_TYPE_INFO);
    registry.register_type(TRANSFORMBUILDERENTITY_ARRAY_TYPE_INFO);
    registry.register_type(VECBUILDERENTITY_TYPE_INFO);
    registry.register_type(VECBUILDERENTITY_ARRAY_TYPE_INFO);
    registry.register_type(VEC4BUILDERENTITY_TYPE_INFO);
    registry.register_type(VEC4BUILDERENTITY_ARRAY_TYPE_INFO);
    registry.register_type(VEC3BUILDERENTITY_TYPE_INFO);
    registry.register_type(VEC3BUILDERENTITY_ARRAY_TYPE_INFO);
    registry.register_type(VEC2BUILDERENTITY_TYPE_INFO);
    registry.register_type(VEC2BUILDERENTITY_ARRAY_TYPE_INFO);
    registry.register_type(VECSPLITTERENTITY_TYPE_INFO);
    registry.register_type(VECSPLITTERENTITY_ARRAY_TYPE_INFO);
    registry.register_type(VEC4SPLITTERENTITY_TYPE_INFO);
    registry.register_type(VEC4SPLITTERENTITY_ARRAY_TYPE_INFO);
    registry.register_type(VEC3SPLITTERENTITY_TYPE_INFO);
    registry.register_type(VEC3SPLITTERENTITY_ARRAY_TYPE_INFO);
    registry.register_type(VEC2SPLITTERENTITY_TYPE_INFO);
    registry.register_type(VEC2SPLITTERENTITY_ARRAY_TYPE_INFO);
    registry.register_type(EULERTRANSFORMENTITY_TYPE_INFO);
    registry.register_type(EULERTRANSFORMENTITY_ARRAY_TYPE_INFO);
    registry.register_type(EULERTRANSFORMSPLITTERENTITY_TYPE_INFO);
    registry.register_type(EULERTRANSFORMSPLITTERENTITY_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMSPLITTERENTITY_TYPE_INFO);
    registry.register_type(TRANSFORMSPLITTERENTITY_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMSELECTORENTITY_TYPE_INFO);
    registry.register_type(TRANSFORMSELECTORENTITY_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMBLENDENTITY_TYPE_INFO);
    registry.register_type(TRANSFORMBLENDENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SIMPLEDOFPARAMCONVERTERENTITY_TYPE_INFO);
    registry.register_type(SIMPLEDOFPARAMCONVERTERENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SPRITEDOFPARAMCONVERTERENTITY_TYPE_INFO);
    registry.register_type(SPRITEDOFPARAMCONVERTERENTITY_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMMULTIPLIERENTITY_TYPE_INFO);
    registry.register_type(TRANSFORMMULTIPLIERENTITY_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMHUBENTITY_TYPE_INFO);
    registry.register_type(TRANSFORMHUBENTITY_ARRAY_TYPE_INFO);
    registry.register_type(STRINGHUBENTITY_TYPE_INFO);
    registry.register_type(STRINGHUBENTITY_ARRAY_TYPE_INFO);
    registry.register_type(VEC4HUBENTITY_TYPE_INFO);
    registry.register_type(VEC4HUBENTITY_ARRAY_TYPE_INFO);
    registry.register_type(VEC3HUBENTITY_TYPE_INFO);
    registry.register_type(VEC3HUBENTITY_ARRAY_TYPE_INFO);
    registry.register_type(VEC2HUBENTITY_TYPE_INFO);
    registry.register_type(VEC2HUBENTITY_ARRAY_TYPE_INFO);
    registry.register_type(FLOATHUBENTITY_TYPE_INFO);
    registry.register_type(FLOATHUBENTITY_ARRAY_TYPE_INFO);
    registry.register_type(INT64HUBENTITY_TYPE_INFO);
    registry.register_type(INT64HUBENTITY_ARRAY_TYPE_INFO);
    registry.register_type(INTHUBENTITY_TYPE_INFO);
    registry.register_type(INTHUBENTITY_ARRAY_TYPE_INFO);
    registry.register_type(BOOLHUBENTITY_TYPE_INFO);
    registry.register_type(BOOLHUBENTITY_ARRAY_TYPE_INFO);
    registry.register_type(OBJECTVARIATIONSWITCHENTITY_TYPE_INFO);
    registry.register_type(OBJECTVARIATIONSWITCHENTITY_ARRAY_TYPE_INFO);
    registry.register_type(OBJECTVARIATIONMULTISWITCHENTITY_TYPE_INFO);
    registry.register_type(OBJECTVARIATIONMULTISWITCHENTITY_ARRAY_TYPE_INFO);
    registry.register_type(RANDOMDELAYENTITY_TYPE_INFO);
    registry.register_type(RANDOMDELAYENTITY_ARRAY_TYPE_INFO);
    registry.register_type(DELAYENTITY_TYPE_INFO);
    registry.register_type(DELAYENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SELECTEVENTENTITY_TYPE_INFO);
    registry.register_type(SELECTEVENTENTITY_ARRAY_TYPE_INFO);
    registry.register_type(EVENTORDERGATEENTITY_TYPE_INFO);
    registry.register_type(EVENTORDERGATEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(EVENTANDGATEENTITY_TYPE_INFO);
    registry.register_type(EVENTANDGATEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(EVENTSWITCHENTITY_TYPE_INFO);
    registry.register_type(EVENTSWITCHENTITY_ARRAY_TYPE_INFO);
    registry.register_type(UNIQUEIDENTITY_TYPE_INFO);
    registry.register_type(UNIQUEIDENTITY_ARRAY_TYPE_INFO);
    registry.register_type(RANDOMINTENTITY_TYPE_INFO);
    registry.register_type(RANDOMINTENTITY_ARRAY_TYPE_INFO);
    registry.register_type(RANDOMFLOATENTITY_TYPE_INFO);
    registry.register_type(RANDOMFLOATENTITY_ARRAY_TYPE_INFO);
    registry.register_type(RANDOMMULTIEVENTENTITY_TYPE_INFO);
    registry.register_type(RANDOMMULTIEVENTENTITY_ARRAY_TYPE_INFO);
    registry.register_type(RANDOMEVENTENTITY_TYPE_INFO);
    registry.register_type(RANDOMEVENTENTITY_ARRAY_TYPE_INFO);
    registry.register_type(LOCATORENTITY_TYPE_INFO);
    registry.register_type(LOCATORENTITY_ARRAY_TYPE_INFO);
    registry.register_type(COUNTDOWNENTITY_TYPE_INFO);
    registry.register_type(COUNTDOWNENTITY_ARRAY_TYPE_INFO);
    registry.register_type(MATHENTITY_TYPE_INFO);
    registry.register_type(MATHENTITY_ARRAY_TYPE_INFO);
    registry.register_type(OR4ENTITY_TYPE_INFO);
    registry.register_type(OR4ENTITY_ARRAY_TYPE_INFO);
    registry.register_type(XORENTITY_TYPE_INFO);
    registry.register_type(XORENTITY_ARRAY_TYPE_INFO);
    registry.register_type(ORENTITY_TYPE_INFO);
    registry.register_type(ORENTITY_ARRAY_TYPE_INFO);
    registry.register_type(BITWISEANDENTITY_TYPE_INFO);
    registry.register_type(BITWISEANDENTITY_ARRAY_TYPE_INFO);
    registry.register_type(ANDENTITY_TYPE_INFO);
    registry.register_type(ANDENTITY_ARRAY_TYPE_INFO);
    registry.register_type(NOTENTITY_TYPE_INFO);
    registry.register_type(NOTENTITY_ARRAY_TYPE_INFO);
}

#[derive(Debug, Default)]
#[repr(C)]
pub struct WorldPartInclusion {
    pub _glacier_base: SubWorldInclusion,
}

pub trait WorldPartInclusionTrait: SubWorldInclusionTrait {
}

impl WorldPartInclusionTrait for WorldPartInclusion {
}

impl SubWorldInclusionTrait for WorldPartInclusion {
    fn criteria(&self) -> &Vec<Option<LockedTypeObject /* SubWorldInclusionCriterion */>> {
        self._glacier_base.criteria()
    }
    fn criteria_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* SubWorldInclusionCriterion */>> {
        self._glacier_base.criteria_mut()
    }
}

impl super::core::AssetTrait for WorldPartInclusion {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for WorldPartInclusion {
}

pub static WORLDPARTINCLUSION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WorldPartInclusion",
    name_hash: 1055877366,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SUBWORLDINCLUSION_TYPE_INFO),
        super_class_offset: offset_of!(WorldPartInclusion, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WorldPartInclusion as Default>::default())),
            create_boxed: || Box::new(<WorldPartInclusion as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(WORLDPARTINCLUSION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WorldPartInclusion {
    fn type_info(&self) -> &'static TypeInfo {
        WORLDPARTINCLUSION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WORLDPARTINCLUSION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WorldPartInclusion-Array",
    name_hash: 3548622274,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("WorldPartInclusion"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct WorldPartInclusionCriterion {
    pub _glacier_base: SubWorldInclusionCriterion,
}

pub trait WorldPartInclusionCriterionTrait: SubWorldInclusionCriterionTrait {
}

impl WorldPartInclusionCriterionTrait for WorldPartInclusionCriterion {
}

impl SubWorldInclusionCriterionTrait for WorldPartInclusionCriterion {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
    fn options(&self) -> &Vec<String> {
        self._glacier_base.options()
    }
    fn options_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.options_mut()
    }
}

impl super::core::DataContainerTrait for WorldPartInclusionCriterion {
}

pub static WORLDPARTINCLUSIONCRITERION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WorldPartInclusionCriterion",
    name_hash: 3062116229,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SUBWORLDINCLUSIONCRITERION_TYPE_INFO),
        super_class_offset: offset_of!(WorldPartInclusionCriterion, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WorldPartInclusionCriterion as Default>::default())),
            create_boxed: || Box::new(<WorldPartInclusionCriterion as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(WORLDPARTINCLUSIONCRITERION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WorldPartInclusionCriterion {
    fn type_info(&self) -> &'static TypeInfo {
        WORLDPARTINCLUSIONCRITERION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WORLDPARTINCLUSIONCRITERION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WorldPartInclusionCriterion-Array",
    name_hash: 963835697,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("WorldPartInclusionCriterion"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct WorldPartInclusionSetting {
    pub _glacier_base: SubWorldInclusionSetting,
}

pub trait WorldPartInclusionSettingTrait: SubWorldInclusionSettingTrait {
}

impl WorldPartInclusionSettingTrait for WorldPartInclusionSetting {
}

impl SubWorldInclusionSettingTrait for WorldPartInclusionSetting {
    fn criterion(&self) -> &Option<LockedTypeObject /* SubWorldInclusionCriterion */> {
        self._glacier_base.criterion()
    }
    fn criterion_mut(&mut self) -> &mut Option<LockedTypeObject /* SubWorldInclusionCriterion */> {
        self._glacier_base.criterion_mut()
    }
    fn enabled_options(&self) -> &Vec<String> {
        self._glacier_base.enabled_options()
    }
    fn enabled_options_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.enabled_options_mut()
    }
}

impl super::core::DataContainerTrait for WorldPartInclusionSetting {
}

pub static WORLDPARTINCLUSIONSETTING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WorldPartInclusionSetting",
    name_hash: 4073490752,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SUBWORLDINCLUSIONSETTING_TYPE_INFO),
        super_class_offset: offset_of!(WorldPartInclusionSetting, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WorldPartInclusionSetting as Default>::default())),
            create_boxed: || Box::new(<WorldPartInclusionSetting as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(WORLDPARTINCLUSIONSETTING_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WorldPartInclusionSetting {
    fn type_info(&self) -> &'static TypeInfo {
        WORLDPARTINCLUSIONSETTING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WORLDPARTINCLUSIONSETTING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WorldPartInclusionSetting-Array",
    name_hash: 1916870644,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("WorldPartInclusionSetting"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct WorldPartInclusionSettings {
    pub _glacier_base: SubWorldInclusionSettings,
}

pub trait WorldPartInclusionSettingsTrait: SubWorldInclusionSettingsTrait {
}

impl WorldPartInclusionSettingsTrait for WorldPartInclusionSettings {
}

impl SubWorldInclusionSettingsTrait for WorldPartInclusionSettings {
    fn settings(&self) -> &Vec<Option<LockedTypeObject /* SubWorldInclusionSetting */>> {
        self._glacier_base.settings()
    }
    fn settings_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* SubWorldInclusionSetting */>> {
        self._glacier_base.settings_mut()
    }
}

impl super::core::DataContainerTrait for WorldPartInclusionSettings {
}

pub static WORLDPARTINCLUSIONSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WorldPartInclusionSettings",
    name_hash: 1281208627,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SUBWORLDINCLUSIONSETTINGS_TYPE_INFO),
        super_class_offset: offset_of!(WorldPartInclusionSettings, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WorldPartInclusionSettings as Default>::default())),
            create_boxed: || Box::new(<WorldPartInclusionSettings as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(WORLDPARTINCLUSIONSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WorldPartInclusionSettings {
    fn type_info(&self) -> &'static TypeInfo {
        WORLDPARTINCLUSIONSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WORLDPARTINCLUSIONSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WorldPartInclusionSettings-Array",
    name_hash: 402586759,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("WorldPartInclusionSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct AssemblyDescriptorData {
    pub _glacier_base: InterfaceDescriptorData,
}

pub trait AssemblyDescriptorDataTrait: InterfaceDescriptorDataTrait {
}

impl AssemblyDescriptorDataTrait for AssemblyDescriptorData {
}

impl InterfaceDescriptorDataTrait for AssemblyDescriptorData {
    fn input_events(&self) -> &Vec<BoxedTypeObject /* DynamicEvent */> {
        self._glacier_base.input_events()
    }
    fn input_events_mut(&mut self) -> &mut Vec<BoxedTypeObject /* DynamicEvent */> {
        self._glacier_base.input_events_mut()
    }
    fn output_events(&self) -> &Vec<BoxedTypeObject /* DynamicEvent */> {
        self._glacier_base.output_events()
    }
    fn output_events_mut(&mut self) -> &mut Vec<BoxedTypeObject /* DynamicEvent */> {
        self._glacier_base.output_events_mut()
    }
    fn input_links(&self) -> &Vec<BoxedTypeObject /* DynamicLink */> {
        self._glacier_base.input_links()
    }
    fn input_links_mut(&mut self) -> &mut Vec<BoxedTypeObject /* DynamicLink */> {
        self._glacier_base.input_links_mut()
    }
    fn output_links(&self) -> &Vec<BoxedTypeObject /* DynamicLink */> {
        self._glacier_base.output_links()
    }
    fn output_links_mut(&mut self) -> &mut Vec<BoxedTypeObject /* DynamicLink */> {
        self._glacier_base.output_links_mut()
    }
}

impl super::core::DynamicDataContainerTrait for AssemblyDescriptorData {
    fn fields(&self) -> &Vec<BoxedTypeObject /* super::core::DataField */> {
        self._glacier_base.fields()
    }
    fn fields_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::DataField */> {
        self._glacier_base.fields_mut()
    }
}

impl super::core::DataContainerTrait for AssemblyDescriptorData {
}

pub static ASSEMBLYDESCRIPTORDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AssemblyDescriptorData",
    name_hash: 536295064,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(INTERFACEDESCRIPTORDATA_TYPE_INFO),
        super_class_offset: offset_of!(AssemblyDescriptorData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AssemblyDescriptorData as Default>::default())),
            create_boxed: || Box::new(<AssemblyDescriptorData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(ASSEMBLYDESCRIPTORDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AssemblyDescriptorData {
    fn type_info(&self) -> &'static TypeInfo {
        ASSEMBLYDESCRIPTORDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ASSEMBLYDESCRIPTORDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AssemblyDescriptorData-Array",
    name_hash: 3117867180,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("AssemblyDescriptorData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct WorldObjectListData {
    pub _glacier_base: super::core::DataContainer,
}

pub trait WorldObjectListDataTrait: super::core::DataContainerTrait {
}

impl WorldObjectListDataTrait for WorldObjectListData {
}

impl super::core::DataContainerTrait for WorldObjectListData {
}

pub static WORLDOBJECTLISTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WorldObjectListData",
    name_hash: 3821418112,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(WorldObjectListData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WorldObjectListData as Default>::default())),
            create_boxed: || Box::new(<WorldObjectListData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(WORLDOBJECTLISTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WorldObjectListData {
    fn type_info(&self) -> &'static TypeInfo {
        WORLDOBJECTLISTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WORLDOBJECTLISTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WorldObjectListData-Array",
    name_hash: 3402874036,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("WorldObjectListData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct WorldPartReferenceObjectData {
    pub _glacier_base: LayerReferenceObjectData,
}

pub trait WorldPartReferenceObjectDataTrait: LayerReferenceObjectDataTrait {
}

impl WorldPartReferenceObjectDataTrait for WorldPartReferenceObjectData {
}

impl LayerReferenceObjectDataTrait for WorldPartReferenceObjectData {
}

impl ReferenceObjectDataTrait for WorldPartReferenceObjectData {
    fn blueprint_transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.blueprint_transform()
    }
    fn blueprint_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.blueprint_transform_mut()
    }
    fn blueprint(&self) -> &Option<LockedTypeObject /* Blueprint */> {
        self._glacier_base.blueprint()
    }
    fn blueprint_mut(&mut self) -> &mut Option<LockedTypeObject /* Blueprint */> {
        self._glacier_base.blueprint_mut()
    }
    fn object_variation(&self) -> &Option<LockedTypeObject /* ObjectVariation */> {
        self._glacier_base.object_variation()
    }
    fn object_variation_mut(&mut self) -> &mut Option<LockedTypeObject /* ObjectVariation */> {
        self._glacier_base.object_variation_mut()
    }
    fn stream_realm(&self) -> &StreamRealm {
        self._glacier_base.stream_realm()
    }
    fn stream_realm_mut(&mut self) -> &mut StreamRealm {
        self._glacier_base.stream_realm_mut()
    }
    fn radiosity_type_override(&self) -> &super::core::RadiosityTypeOverride {
        self._glacier_base.radiosity_type_override()
    }
    fn radiosity_type_override_mut(&mut self) -> &mut super::core::RadiosityTypeOverride {
        self._glacier_base.radiosity_type_override_mut()
    }
    fn lightmap_resolution_scale(&self) -> &u32 {
        self._glacier_base.lightmap_resolution_scale()
    }
    fn lightmap_resolution_scale_mut(&mut self) -> &mut u32 {
        self._glacier_base.lightmap_resolution_scale_mut()
    }
    fn lightmap_scale_with_size(&self) -> &bool {
        self._glacier_base.lightmap_scale_with_size()
    }
    fn lightmap_scale_with_size_mut(&mut self) -> &mut bool {
        self._glacier_base.lightmap_scale_with_size_mut()
    }
    fn rendering_overrides(&self) -> &super::core::RenderingOverrides {
        self._glacier_base.rendering_overrides()
    }
    fn rendering_overrides_mut(&mut self) -> &mut super::core::RenderingOverrides {
        self._glacier_base.rendering_overrides_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
    fn create_indestructible_entity(&self) -> &bool {
        self._glacier_base.create_indestructible_entity()
    }
    fn create_indestructible_entity_mut(&mut self) -> &mut bool {
        self._glacier_base.create_indestructible_entity_mut()
    }
}

impl GameObjectDataTrait for WorldPartReferenceObjectData {
}

impl super::core::DataBusPeerTrait for WorldPartReferenceObjectData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for WorldPartReferenceObjectData {
}

impl super::core::DataContainerTrait for WorldPartReferenceObjectData {
}

pub static WORLDPARTREFERENCEOBJECTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WorldPartReferenceObjectData",
    name_hash: 3578523902,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(LAYERREFERENCEOBJECTDATA_TYPE_INFO),
        super_class_offset: offset_of!(WorldPartReferenceObjectData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WorldPartReferenceObjectData as Default>::default())),
            create_boxed: || Box::new(<WorldPartReferenceObjectData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(WORLDPARTREFERENCEOBJECTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for WorldPartReferenceObjectData {
    fn type_info(&self) -> &'static TypeInfo {
        WORLDPARTREFERENCEOBJECTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WORLDPARTREFERENCEOBJECTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WorldPartReferenceObjectData-Array",
    name_hash: 4054159818,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("WorldPartReferenceObjectData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ReadOnlyLayerReferenceObjectData {
    pub _glacier_base: LayerReferenceObjectData,
}

pub trait ReadOnlyLayerReferenceObjectDataTrait: LayerReferenceObjectDataTrait {
}

impl ReadOnlyLayerReferenceObjectDataTrait for ReadOnlyLayerReferenceObjectData {
}

impl LayerReferenceObjectDataTrait for ReadOnlyLayerReferenceObjectData {
}

impl ReferenceObjectDataTrait for ReadOnlyLayerReferenceObjectData {
    fn blueprint_transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.blueprint_transform()
    }
    fn blueprint_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.blueprint_transform_mut()
    }
    fn blueprint(&self) -> &Option<LockedTypeObject /* Blueprint */> {
        self._glacier_base.blueprint()
    }
    fn blueprint_mut(&mut self) -> &mut Option<LockedTypeObject /* Blueprint */> {
        self._glacier_base.blueprint_mut()
    }
    fn object_variation(&self) -> &Option<LockedTypeObject /* ObjectVariation */> {
        self._glacier_base.object_variation()
    }
    fn object_variation_mut(&mut self) -> &mut Option<LockedTypeObject /* ObjectVariation */> {
        self._glacier_base.object_variation_mut()
    }
    fn stream_realm(&self) -> &StreamRealm {
        self._glacier_base.stream_realm()
    }
    fn stream_realm_mut(&mut self) -> &mut StreamRealm {
        self._glacier_base.stream_realm_mut()
    }
    fn radiosity_type_override(&self) -> &super::core::RadiosityTypeOverride {
        self._glacier_base.radiosity_type_override()
    }
    fn radiosity_type_override_mut(&mut self) -> &mut super::core::RadiosityTypeOverride {
        self._glacier_base.radiosity_type_override_mut()
    }
    fn lightmap_resolution_scale(&self) -> &u32 {
        self._glacier_base.lightmap_resolution_scale()
    }
    fn lightmap_resolution_scale_mut(&mut self) -> &mut u32 {
        self._glacier_base.lightmap_resolution_scale_mut()
    }
    fn lightmap_scale_with_size(&self) -> &bool {
        self._glacier_base.lightmap_scale_with_size()
    }
    fn lightmap_scale_with_size_mut(&mut self) -> &mut bool {
        self._glacier_base.lightmap_scale_with_size_mut()
    }
    fn rendering_overrides(&self) -> &super::core::RenderingOverrides {
        self._glacier_base.rendering_overrides()
    }
    fn rendering_overrides_mut(&mut self) -> &mut super::core::RenderingOverrides {
        self._glacier_base.rendering_overrides_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
    fn create_indestructible_entity(&self) -> &bool {
        self._glacier_base.create_indestructible_entity()
    }
    fn create_indestructible_entity_mut(&mut self) -> &mut bool {
        self._glacier_base.create_indestructible_entity_mut()
    }
}

impl GameObjectDataTrait for ReadOnlyLayerReferenceObjectData {
}

impl super::core::DataBusPeerTrait for ReadOnlyLayerReferenceObjectData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ReadOnlyLayerReferenceObjectData {
}

impl super::core::DataContainerTrait for ReadOnlyLayerReferenceObjectData {
}

pub static READONLYLAYERREFERENCEOBJECTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadOnlyLayerReferenceObjectData",
    name_hash: 2009364462,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(LAYERREFERENCEOBJECTDATA_TYPE_INFO),
        super_class_offset: offset_of!(ReadOnlyLayerReferenceObjectData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ReadOnlyLayerReferenceObjectData as Default>::default())),
            create_boxed: || Box::new(<ReadOnlyLayerReferenceObjectData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(READONLYLAYERREFERENCEOBJECTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ReadOnlyLayerReferenceObjectData {
    fn type_info(&self) -> &'static TypeInfo {
        READONLYLAYERREFERENCEOBJECTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static READONLYLAYERREFERENCEOBJECTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadOnlyLayerReferenceObjectData-Array",
    name_hash: 3029635290,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ReadOnlyLayerReferenceObjectData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct LayerReferenceObjectData {
    pub _glacier_base: ReferenceObjectData,
}

pub trait LayerReferenceObjectDataTrait: ReferenceObjectDataTrait {
}

impl LayerReferenceObjectDataTrait for LayerReferenceObjectData {
}

impl ReferenceObjectDataTrait for LayerReferenceObjectData {
    fn blueprint_transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.blueprint_transform()
    }
    fn blueprint_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.blueprint_transform_mut()
    }
    fn blueprint(&self) -> &Option<LockedTypeObject /* Blueprint */> {
        self._glacier_base.blueprint()
    }
    fn blueprint_mut(&mut self) -> &mut Option<LockedTypeObject /* Blueprint */> {
        self._glacier_base.blueprint_mut()
    }
    fn object_variation(&self) -> &Option<LockedTypeObject /* ObjectVariation */> {
        self._glacier_base.object_variation()
    }
    fn object_variation_mut(&mut self) -> &mut Option<LockedTypeObject /* ObjectVariation */> {
        self._glacier_base.object_variation_mut()
    }
    fn stream_realm(&self) -> &StreamRealm {
        self._glacier_base.stream_realm()
    }
    fn stream_realm_mut(&mut self) -> &mut StreamRealm {
        self._glacier_base.stream_realm_mut()
    }
    fn radiosity_type_override(&self) -> &super::core::RadiosityTypeOverride {
        self._glacier_base.radiosity_type_override()
    }
    fn radiosity_type_override_mut(&mut self) -> &mut super::core::RadiosityTypeOverride {
        self._glacier_base.radiosity_type_override_mut()
    }
    fn lightmap_resolution_scale(&self) -> &u32 {
        self._glacier_base.lightmap_resolution_scale()
    }
    fn lightmap_resolution_scale_mut(&mut self) -> &mut u32 {
        self._glacier_base.lightmap_resolution_scale_mut()
    }
    fn lightmap_scale_with_size(&self) -> &bool {
        self._glacier_base.lightmap_scale_with_size()
    }
    fn lightmap_scale_with_size_mut(&mut self) -> &mut bool {
        self._glacier_base.lightmap_scale_with_size_mut()
    }
    fn rendering_overrides(&self) -> &super::core::RenderingOverrides {
        self._glacier_base.rendering_overrides()
    }
    fn rendering_overrides_mut(&mut self) -> &mut super::core::RenderingOverrides {
        self._glacier_base.rendering_overrides_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
    fn create_indestructible_entity(&self) -> &bool {
        self._glacier_base.create_indestructible_entity()
    }
    fn create_indestructible_entity_mut(&mut self) -> &mut bool {
        self._glacier_base.create_indestructible_entity_mut()
    }
}

impl GameObjectDataTrait for LayerReferenceObjectData {
}

impl super::core::DataBusPeerTrait for LayerReferenceObjectData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for LayerReferenceObjectData {
}

impl super::core::DataContainerTrait for LayerReferenceObjectData {
}

pub static LAYERREFERENCEOBJECTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LayerReferenceObjectData",
    name_hash: 1838106280,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(REFERENCEOBJECTDATA_TYPE_INFO),
        super_class_offset: offset_of!(LayerReferenceObjectData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LayerReferenceObjectData as Default>::default())),
            create_boxed: || Box::new(<LayerReferenceObjectData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(LAYERREFERENCEOBJECTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for LayerReferenceObjectData {
    fn type_info(&self) -> &'static TypeInfo {
        LAYERREFERENCEOBJECTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LAYERREFERENCEOBJECTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LayerReferenceObjectData-Array",
    name_hash: 3225913372,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("LayerReferenceObjectData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SubWorldReferenceObjectData {
    pub _glacier_base: ReferenceObjectData,
    pub bundle_name: String,
    pub preloaded_bundle_names: Vec<String>,
    pub bundle_heap: BundleHeapInfo,
    pub inclusion_settings: Option<LockedTypeObject /* SubWorldInclusionSettings */>,
    pub auto_load: bool,
    pub is_detached_sub_level: bool,
    pub is_win32_sub_level: bool,
    pub is_gen4a_sub_level: bool,
    pub is_gen4b_sub_level: bool,
    pub is_i_o_s_sub_level: bool,
    pub is_android_sub_level: bool,
    pub is_o_s_x_sub_level: bool,
    pub is_linux_sub_level: bool,
    pub on_level_load_fire_on_stream_in: bool,
    pub use_peer_filtering: bool,
    pub parents: Vec<BoxedTypeObject /* SharedBundleReference */>,
}

pub trait SubWorldReferenceObjectDataTrait: ReferenceObjectDataTrait {
    fn bundle_name(&self) -> &String;
    fn bundle_name_mut(&mut self) -> &mut String;
    fn preloaded_bundle_names(&self) -> &Vec<String>;
    fn preloaded_bundle_names_mut(&mut self) -> &mut Vec<String>;
    fn bundle_heap(&self) -> &BundleHeapInfo;
    fn bundle_heap_mut(&mut self) -> &mut BundleHeapInfo;
    fn inclusion_settings(&self) -> &Option<LockedTypeObject /* SubWorldInclusionSettings */>;
    fn inclusion_settings_mut(&mut self) -> &mut Option<LockedTypeObject /* SubWorldInclusionSettings */>;
    fn auto_load(&self) -> &bool;
    fn auto_load_mut(&mut self) -> &mut bool;
    fn is_detached_sub_level(&self) -> &bool;
    fn is_detached_sub_level_mut(&mut self) -> &mut bool;
    fn is_win32_sub_level(&self) -> &bool;
    fn is_win32_sub_level_mut(&mut self) -> &mut bool;
    fn is_gen4a_sub_level(&self) -> &bool;
    fn is_gen4a_sub_level_mut(&mut self) -> &mut bool;
    fn is_gen4b_sub_level(&self) -> &bool;
    fn is_gen4b_sub_level_mut(&mut self) -> &mut bool;
    fn is_i_o_s_sub_level(&self) -> &bool;
    fn is_i_o_s_sub_level_mut(&mut self) -> &mut bool;
    fn is_android_sub_level(&self) -> &bool;
    fn is_android_sub_level_mut(&mut self) -> &mut bool;
    fn is_o_s_x_sub_level(&self) -> &bool;
    fn is_o_s_x_sub_level_mut(&mut self) -> &mut bool;
    fn is_linux_sub_level(&self) -> &bool;
    fn is_linux_sub_level_mut(&mut self) -> &mut bool;
    fn on_level_load_fire_on_stream_in(&self) -> &bool;
    fn on_level_load_fire_on_stream_in_mut(&mut self) -> &mut bool;
    fn use_peer_filtering(&self) -> &bool;
    fn use_peer_filtering_mut(&mut self) -> &mut bool;
    fn parents(&self) -> &Vec<BoxedTypeObject /* SharedBundleReference */>;
    fn parents_mut(&mut self) -> &mut Vec<BoxedTypeObject /* SharedBundleReference */>;
}

impl SubWorldReferenceObjectDataTrait for SubWorldReferenceObjectData {
    fn bundle_name(&self) -> &String {
        &self.bundle_name
    }
    fn bundle_name_mut(&mut self) -> &mut String {
        &mut self.bundle_name
    }
    fn preloaded_bundle_names(&self) -> &Vec<String> {
        &self.preloaded_bundle_names
    }
    fn preloaded_bundle_names_mut(&mut self) -> &mut Vec<String> {
        &mut self.preloaded_bundle_names
    }
    fn bundle_heap(&self) -> &BundleHeapInfo {
        &self.bundle_heap
    }
    fn bundle_heap_mut(&mut self) -> &mut BundleHeapInfo {
        &mut self.bundle_heap
    }
    fn inclusion_settings(&self) -> &Option<LockedTypeObject /* SubWorldInclusionSettings */> {
        &self.inclusion_settings
    }
    fn inclusion_settings_mut(&mut self) -> &mut Option<LockedTypeObject /* SubWorldInclusionSettings */> {
        &mut self.inclusion_settings
    }
    fn auto_load(&self) -> &bool {
        &self.auto_load
    }
    fn auto_load_mut(&mut self) -> &mut bool {
        &mut self.auto_load
    }
    fn is_detached_sub_level(&self) -> &bool {
        &self.is_detached_sub_level
    }
    fn is_detached_sub_level_mut(&mut self) -> &mut bool {
        &mut self.is_detached_sub_level
    }
    fn is_win32_sub_level(&self) -> &bool {
        &self.is_win32_sub_level
    }
    fn is_win32_sub_level_mut(&mut self) -> &mut bool {
        &mut self.is_win32_sub_level
    }
    fn is_gen4a_sub_level(&self) -> &bool {
        &self.is_gen4a_sub_level
    }
    fn is_gen4a_sub_level_mut(&mut self) -> &mut bool {
        &mut self.is_gen4a_sub_level
    }
    fn is_gen4b_sub_level(&self) -> &bool {
        &self.is_gen4b_sub_level
    }
    fn is_gen4b_sub_level_mut(&mut self) -> &mut bool {
        &mut self.is_gen4b_sub_level
    }
    fn is_i_o_s_sub_level(&self) -> &bool {
        &self.is_i_o_s_sub_level
    }
    fn is_i_o_s_sub_level_mut(&mut self) -> &mut bool {
        &mut self.is_i_o_s_sub_level
    }
    fn is_android_sub_level(&self) -> &bool {
        &self.is_android_sub_level
    }
    fn is_android_sub_level_mut(&mut self) -> &mut bool {
        &mut self.is_android_sub_level
    }
    fn is_o_s_x_sub_level(&self) -> &bool {
        &self.is_o_s_x_sub_level
    }
    fn is_o_s_x_sub_level_mut(&mut self) -> &mut bool {
        &mut self.is_o_s_x_sub_level
    }
    fn is_linux_sub_level(&self) -> &bool {
        &self.is_linux_sub_level
    }
    fn is_linux_sub_level_mut(&mut self) -> &mut bool {
        &mut self.is_linux_sub_level
    }
    fn on_level_load_fire_on_stream_in(&self) -> &bool {
        &self.on_level_load_fire_on_stream_in
    }
    fn on_level_load_fire_on_stream_in_mut(&mut self) -> &mut bool {
        &mut self.on_level_load_fire_on_stream_in
    }
    fn use_peer_filtering(&self) -> &bool {
        &self.use_peer_filtering
    }
    fn use_peer_filtering_mut(&mut self) -> &mut bool {
        &mut self.use_peer_filtering
    }
    fn parents(&self) -> &Vec<BoxedTypeObject /* SharedBundleReference */> {
        &self.parents
    }
    fn parents_mut(&mut self) -> &mut Vec<BoxedTypeObject /* SharedBundleReference */> {
        &mut self.parents
    }
}

impl ReferenceObjectDataTrait for SubWorldReferenceObjectData {
    fn blueprint_transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.blueprint_transform()
    }
    fn blueprint_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.blueprint_transform_mut()
    }
    fn blueprint(&self) -> &Option<LockedTypeObject /* Blueprint */> {
        self._glacier_base.blueprint()
    }
    fn blueprint_mut(&mut self) -> &mut Option<LockedTypeObject /* Blueprint */> {
        self._glacier_base.blueprint_mut()
    }
    fn object_variation(&self) -> &Option<LockedTypeObject /* ObjectVariation */> {
        self._glacier_base.object_variation()
    }
    fn object_variation_mut(&mut self) -> &mut Option<LockedTypeObject /* ObjectVariation */> {
        self._glacier_base.object_variation_mut()
    }
    fn stream_realm(&self) -> &StreamRealm {
        self._glacier_base.stream_realm()
    }
    fn stream_realm_mut(&mut self) -> &mut StreamRealm {
        self._glacier_base.stream_realm_mut()
    }
    fn radiosity_type_override(&self) -> &super::core::RadiosityTypeOverride {
        self._glacier_base.radiosity_type_override()
    }
    fn radiosity_type_override_mut(&mut self) -> &mut super::core::RadiosityTypeOverride {
        self._glacier_base.radiosity_type_override_mut()
    }
    fn lightmap_resolution_scale(&self) -> &u32 {
        self._glacier_base.lightmap_resolution_scale()
    }
    fn lightmap_resolution_scale_mut(&mut self) -> &mut u32 {
        self._glacier_base.lightmap_resolution_scale_mut()
    }
    fn lightmap_scale_with_size(&self) -> &bool {
        self._glacier_base.lightmap_scale_with_size()
    }
    fn lightmap_scale_with_size_mut(&mut self) -> &mut bool {
        self._glacier_base.lightmap_scale_with_size_mut()
    }
    fn rendering_overrides(&self) -> &super::core::RenderingOverrides {
        self._glacier_base.rendering_overrides()
    }
    fn rendering_overrides_mut(&mut self) -> &mut super::core::RenderingOverrides {
        self._glacier_base.rendering_overrides_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
    fn create_indestructible_entity(&self) -> &bool {
        self._glacier_base.create_indestructible_entity()
    }
    fn create_indestructible_entity_mut(&mut self) -> &mut bool {
        self._glacier_base.create_indestructible_entity_mut()
    }
}

impl GameObjectDataTrait for SubWorldReferenceObjectData {
}

impl super::core::DataBusPeerTrait for SubWorldReferenceObjectData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SubWorldReferenceObjectData {
}

impl super::core::DataContainerTrait for SubWorldReferenceObjectData {
}

pub static SUBWORLDREFERENCEOBJECTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubWorldReferenceObjectData",
    name_hash: 4042638957,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(REFERENCEOBJECTDATA_TYPE_INFO),
        super_class_offset: offset_of!(SubWorldReferenceObjectData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SubWorldReferenceObjectData as Default>::default())),
            create_boxed: || Box::new(<SubWorldReferenceObjectData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "BundleName",
                name_hash: 461157046,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(SubWorldReferenceObjectData, bundle_name),
            },
            FieldInfoData {
                name: "PreloadedBundleNames",
                name_hash: 198878053,
                flags: MemberInfoFlags::new(144),
                field_type: "CString-Array",
                rust_offset: offset_of!(SubWorldReferenceObjectData, preloaded_bundle_names),
            },
            FieldInfoData {
                name: "BundleHeap",
                name_hash: 460806893,
                flags: MemberInfoFlags::new(0),
                field_type: "BundleHeapInfo",
                rust_offset: offset_of!(SubWorldReferenceObjectData, bundle_heap),
            },
            FieldInfoData {
                name: "InclusionSettings",
                name_hash: 1787638950,
                flags: MemberInfoFlags::new(0),
                field_type: "SubWorldInclusionSettings",
                rust_offset: offset_of!(SubWorldReferenceObjectData, inclusion_settings),
            },
            FieldInfoData {
                name: "AutoLoad",
                name_hash: 3537348684,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SubWorldReferenceObjectData, auto_load),
            },
            FieldInfoData {
                name: "IsDetachedSubLevel",
                name_hash: 2388296915,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SubWorldReferenceObjectData, is_detached_sub_level),
            },
            FieldInfoData {
                name: "IsWin32SubLevel",
                name_hash: 2682003100,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SubWorldReferenceObjectData, is_win32_sub_level),
            },
            FieldInfoData {
                name: "IsGen4aSubLevel",
                name_hash: 4098771572,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SubWorldReferenceObjectData, is_gen4a_sub_level),
            },
            FieldInfoData {
                name: "IsGen4bSubLevel",
                name_hash: 139225463,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SubWorldReferenceObjectData, is_gen4b_sub_level),
            },
            FieldInfoData {
                name: "IsIOSSubLevel",
                name_hash: 4180944952,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SubWorldReferenceObjectData, is_i_o_s_sub_level),
            },
            FieldInfoData {
                name: "IsAndroidSubLevel",
                name_hash: 867634550,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SubWorldReferenceObjectData, is_android_sub_level),
            },
            FieldInfoData {
                name: "IsOSXSubLevel",
                name_hash: 2688156201,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SubWorldReferenceObjectData, is_o_s_x_sub_level),
            },
            FieldInfoData {
                name: "IsLinuxSubLevel",
                name_hash: 4067552587,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SubWorldReferenceObjectData, is_linux_sub_level),
            },
            FieldInfoData {
                name: "OnLevelLoadFireOnStreamIn",
                name_hash: 4149123414,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SubWorldReferenceObjectData, on_level_load_fire_on_stream_in),
            },
            FieldInfoData {
                name: "UsePeerFiltering",
                name_hash: 3192098660,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SubWorldReferenceObjectData, use_peer_filtering),
            },
            FieldInfoData {
                name: "Parents",
                name_hash: 3887384042,
                flags: MemberInfoFlags::new(144),
                field_type: "SharedBundleReference-Array",
                rust_offset: offset_of!(SubWorldReferenceObjectData, parents),
            },
        ],
    }),
    array_type: Some(SUBWORLDREFERENCEOBJECTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SubWorldReferenceObjectData {
    fn type_info(&self) -> &'static TypeInfo {
        SUBWORLDREFERENCEOBJECTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SUBWORLDREFERENCEOBJECTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubWorldReferenceObjectData-Array",
    name_hash: 2540047193,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SubWorldReferenceObjectData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct DetachedSubWorldData {
    pub _glacier_base: WorldData,
    pub reset_destruction_state: bool,
}

pub trait DetachedSubWorldDataTrait: WorldDataTrait {
    fn reset_destruction_state(&self) -> &bool;
    fn reset_destruction_state_mut(&mut self) -> &mut bool;
}

impl DetachedSubWorldDataTrait for DetachedSubWorldData {
    fn reset_destruction_state(&self) -> &bool {
        &self.reset_destruction_state
    }
    fn reset_destruction_state_mut(&mut self) -> &mut bool {
        &mut self.reset_destruction_state
    }
}

impl WorldDataTrait for DetachedSubWorldData {
    fn world_size_x_z(&self) -> &f32 {
        self._glacier_base.world_size_x_z()
    }
    fn world_size_x_z_mut(&mut self) -> &mut f32 {
        self._glacier_base.world_size_x_z_mut()
    }
    fn world_size_y(&self) -> &f32 {
        self._glacier_base.world_size_y()
    }
    fn world_size_y_mut(&mut self) -> &mut f32 {
        self._glacier_base.world_size_y_mut()
    }
    fn is_procedural_level(&self) -> &bool {
        self._glacier_base.is_procedural_level()
    }
    fn is_procedural_level_mut(&mut self) -> &mut bool {
        self._glacier_base.is_procedural_level_mut()
    }
    fn is_dedicated_server_level(&self) -> &bool {
        self._glacier_base.is_dedicated_server_level()
    }
    fn is_dedicated_server_level_mut(&mut self) -> &mut bool {
        self._glacier_base.is_dedicated_server_level_mut()
    }
}

impl SubWorldDataTrait for DetachedSubWorldData {
    fn runtime_material_grid(&self) -> &Option<LockedTypeObject /* MaterialGridData */> {
        self._glacier_base.runtime_material_grid()
    }
    fn runtime_material_grid_mut(&mut self) -> &mut Option<LockedTypeObject /* MaterialGridData */> {
        self._glacier_base.runtime_material_grid_mut()
    }
    fn is_win32_sub_level(&self) -> &bool {
        self._glacier_base.is_win32_sub_level()
    }
    fn is_win32_sub_level_mut(&mut self) -> &mut bool {
        self._glacier_base.is_win32_sub_level_mut()
    }
    fn is_gen4a_sub_level(&self) -> &bool {
        self._glacier_base.is_gen4a_sub_level()
    }
    fn is_gen4a_sub_level_mut(&mut self) -> &mut bool {
        self._glacier_base.is_gen4a_sub_level_mut()
    }
    fn is_gen4b_sub_level(&self) -> &bool {
        self._glacier_base.is_gen4b_sub_level()
    }
    fn is_gen4b_sub_level_mut(&mut self) -> &mut bool {
        self._glacier_base.is_gen4b_sub_level_mut()
    }
    fn is_android_sub_level(&self) -> &bool {
        self._glacier_base.is_android_sub_level()
    }
    fn is_android_sub_level_mut(&mut self) -> &mut bool {
        self._glacier_base.is_android_sub_level_mut()
    }
    fn is_i_o_s_sub_level(&self) -> &bool {
        self._glacier_base.is_i_o_s_sub_level()
    }
    fn is_i_o_s_sub_level_mut(&mut self) -> &mut bool {
        self._glacier_base.is_i_o_s_sub_level_mut()
    }
    fn is_o_s_x_sub_level(&self) -> &bool {
        self._glacier_base.is_o_s_x_sub_level()
    }
    fn is_o_s_x_sub_level_mut(&mut self) -> &mut bool {
        self._glacier_base.is_o_s_x_sub_level_mut()
    }
    fn is_linux_sub_level(&self) -> &bool {
        self._glacier_base.is_linux_sub_level()
    }
    fn is_linux_sub_level_mut(&mut self) -> &mut bool {
        self._glacier_base.is_linux_sub_level_mut()
    }
    fn persistence_setting(&self) -> &BlueprintPersistenceSetting {
        self._glacier_base.persistence_setting()
    }
    fn persistence_setting_mut(&mut self) -> &mut BlueprintPersistenceSetting {
        self._glacier_base.persistence_setting_mut()
    }
    fn auto_asset_collector(&self) -> &Option<LockedTypeObject /* AutoAssetCollector */> {
        self._glacier_base.auto_asset_collector()
    }
    fn auto_asset_collector_mut(&mut self) -> &mut Option<LockedTypeObject /* AutoAssetCollector */> {
        self._glacier_base.auto_asset_collector_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* SubWorldDataComponent */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* SubWorldDataComponent */>> {
        self._glacier_base.components_mut()
    }
}

impl SpatialPrefabBlueprintTrait for DetachedSubWorldData {
}

impl PrefabBlueprintTrait for DetachedSubWorldData {
    fn time_delta_type(&self) -> &TimeDeltaType {
        self._glacier_base.time_delta_type()
    }
    fn time_delta_type_mut(&mut self) -> &mut TimeDeltaType {
        self._glacier_base.time_delta_type_mut()
    }
}

impl BlueprintTrait for DetachedSubWorldData {
    fn objects(&self) -> &Vec<Option<LockedTypeObject /* GameObjectData */>> {
        self._glacier_base.objects()
    }
    fn objects_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* GameObjectData */>> {
        self._glacier_base.objects_mut()
    }
    fn schematics(&self) -> &Option<LockedTypeObject /* super::schematics::SchematicsBaseAsset */> {
        self._glacier_base.schematics()
    }
    fn schematics_mut(&mut self) -> &mut Option<LockedTypeObject /* super::schematics::SchematicsBaseAsset */> {
        self._glacier_base.schematics_mut()
    }
}

impl EntityBusDataTrait for DetachedSubWorldData {
    fn event_connections(&self) -> &Vec<BoxedTypeObject /* EventConnection */> {
        self._glacier_base.event_connections()
    }
    fn event_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* EventConnection */> {
        self._glacier_base.event_connections_mut()
    }
}

impl super::core::DataBusDataTrait for DetachedSubWorldData {
    fn flags(&self) -> &u16 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.flags_mut()
    }
    fn property_connections(&self) -> &Vec<BoxedTypeObject /* super::core::PropertyConnection */> {
        self._glacier_base.property_connections()
    }
    fn property_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::PropertyConnection */> {
        self._glacier_base.property_connections_mut()
    }
    fn link_connections(&self) -> &Vec<BoxedTypeObject /* super::core::LinkConnection */> {
        self._glacier_base.link_connections()
    }
    fn link_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::LinkConnection */> {
        self._glacier_base.link_connections_mut()
    }
    fn interface(&self) -> &Option<LockedTypeObject /* super::core::DynamicDataContainer */> {
        self._glacier_base.interface()
    }
    fn interface_mut(&mut self) -> &mut Option<LockedTypeObject /* super::core::DynamicDataContainer */> {
        self._glacier_base.interface_mut()
    }
}

impl super::core::AssetTrait for DetachedSubWorldData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for DetachedSubWorldData {
}

pub static DETACHEDSUBWORLDDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DetachedSubWorldData",
    name_hash: 1627283725,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(WORLDDATA_TYPE_INFO),
        super_class_offset: offset_of!(DetachedSubWorldData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DetachedSubWorldData as Default>::default())),
            create_boxed: || Box::new(<DetachedSubWorldData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "ResetDestructionState",
                name_hash: 1536730777,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DetachedSubWorldData, reset_destruction_state),
            },
        ],
    }),
    array_type: Some(DETACHEDSUBWORLDDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DetachedSubWorldData {
    fn type_info(&self) -> &'static TypeInfo {
        DETACHEDSUBWORLDDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DETACHEDSUBWORLDDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DetachedSubWorldData-Array",
    name_hash: 4239107257,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("DetachedSubWorldData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct WorldData {
    pub _glacier_base: SubWorldData,
    pub world_size_x_z: f32,
    pub world_size_y: f32,
    pub is_procedural_level: bool,
    pub is_dedicated_server_level: bool,
}

pub trait WorldDataTrait: SubWorldDataTrait {
    fn world_size_x_z(&self) -> &f32;
    fn world_size_x_z_mut(&mut self) -> &mut f32;
    fn world_size_y(&self) -> &f32;
    fn world_size_y_mut(&mut self) -> &mut f32;
    fn is_procedural_level(&self) -> &bool;
    fn is_procedural_level_mut(&mut self) -> &mut bool;
    fn is_dedicated_server_level(&self) -> &bool;
    fn is_dedicated_server_level_mut(&mut self) -> &mut bool;
}

impl WorldDataTrait for WorldData {
    fn world_size_x_z(&self) -> &f32 {
        &self.world_size_x_z
    }
    fn world_size_x_z_mut(&mut self) -> &mut f32 {
        &mut self.world_size_x_z
    }
    fn world_size_y(&self) -> &f32 {
        &self.world_size_y
    }
    fn world_size_y_mut(&mut self) -> &mut f32 {
        &mut self.world_size_y
    }
    fn is_procedural_level(&self) -> &bool {
        &self.is_procedural_level
    }
    fn is_procedural_level_mut(&mut self) -> &mut bool {
        &mut self.is_procedural_level
    }
    fn is_dedicated_server_level(&self) -> &bool {
        &self.is_dedicated_server_level
    }
    fn is_dedicated_server_level_mut(&mut self) -> &mut bool {
        &mut self.is_dedicated_server_level
    }
}

impl SubWorldDataTrait for WorldData {
    fn runtime_material_grid(&self) -> &Option<LockedTypeObject /* MaterialGridData */> {
        self._glacier_base.runtime_material_grid()
    }
    fn runtime_material_grid_mut(&mut self) -> &mut Option<LockedTypeObject /* MaterialGridData */> {
        self._glacier_base.runtime_material_grid_mut()
    }
    fn is_win32_sub_level(&self) -> &bool {
        self._glacier_base.is_win32_sub_level()
    }
    fn is_win32_sub_level_mut(&mut self) -> &mut bool {
        self._glacier_base.is_win32_sub_level_mut()
    }
    fn is_gen4a_sub_level(&self) -> &bool {
        self._glacier_base.is_gen4a_sub_level()
    }
    fn is_gen4a_sub_level_mut(&mut self) -> &mut bool {
        self._glacier_base.is_gen4a_sub_level_mut()
    }
    fn is_gen4b_sub_level(&self) -> &bool {
        self._glacier_base.is_gen4b_sub_level()
    }
    fn is_gen4b_sub_level_mut(&mut self) -> &mut bool {
        self._glacier_base.is_gen4b_sub_level_mut()
    }
    fn is_android_sub_level(&self) -> &bool {
        self._glacier_base.is_android_sub_level()
    }
    fn is_android_sub_level_mut(&mut self) -> &mut bool {
        self._glacier_base.is_android_sub_level_mut()
    }
    fn is_i_o_s_sub_level(&self) -> &bool {
        self._glacier_base.is_i_o_s_sub_level()
    }
    fn is_i_o_s_sub_level_mut(&mut self) -> &mut bool {
        self._glacier_base.is_i_o_s_sub_level_mut()
    }
    fn is_o_s_x_sub_level(&self) -> &bool {
        self._glacier_base.is_o_s_x_sub_level()
    }
    fn is_o_s_x_sub_level_mut(&mut self) -> &mut bool {
        self._glacier_base.is_o_s_x_sub_level_mut()
    }
    fn is_linux_sub_level(&self) -> &bool {
        self._glacier_base.is_linux_sub_level()
    }
    fn is_linux_sub_level_mut(&mut self) -> &mut bool {
        self._glacier_base.is_linux_sub_level_mut()
    }
    fn persistence_setting(&self) -> &BlueprintPersistenceSetting {
        self._glacier_base.persistence_setting()
    }
    fn persistence_setting_mut(&mut self) -> &mut BlueprintPersistenceSetting {
        self._glacier_base.persistence_setting_mut()
    }
    fn auto_asset_collector(&self) -> &Option<LockedTypeObject /* AutoAssetCollector */> {
        self._glacier_base.auto_asset_collector()
    }
    fn auto_asset_collector_mut(&mut self) -> &mut Option<LockedTypeObject /* AutoAssetCollector */> {
        self._glacier_base.auto_asset_collector_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* SubWorldDataComponent */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* SubWorldDataComponent */>> {
        self._glacier_base.components_mut()
    }
}

impl SpatialPrefabBlueprintTrait for WorldData {
}

impl PrefabBlueprintTrait for WorldData {
    fn time_delta_type(&self) -> &TimeDeltaType {
        self._glacier_base.time_delta_type()
    }
    fn time_delta_type_mut(&mut self) -> &mut TimeDeltaType {
        self._glacier_base.time_delta_type_mut()
    }
}

impl BlueprintTrait for WorldData {
    fn objects(&self) -> &Vec<Option<LockedTypeObject /* GameObjectData */>> {
        self._glacier_base.objects()
    }
    fn objects_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* GameObjectData */>> {
        self._glacier_base.objects_mut()
    }
    fn schematics(&self) -> &Option<LockedTypeObject /* super::schematics::SchematicsBaseAsset */> {
        self._glacier_base.schematics()
    }
    fn schematics_mut(&mut self) -> &mut Option<LockedTypeObject /* super::schematics::SchematicsBaseAsset */> {
        self._glacier_base.schematics_mut()
    }
}

impl EntityBusDataTrait for WorldData {
    fn event_connections(&self) -> &Vec<BoxedTypeObject /* EventConnection */> {
        self._glacier_base.event_connections()
    }
    fn event_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* EventConnection */> {
        self._glacier_base.event_connections_mut()
    }
}

impl super::core::DataBusDataTrait for WorldData {
    fn flags(&self) -> &u16 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.flags_mut()
    }
    fn property_connections(&self) -> &Vec<BoxedTypeObject /* super::core::PropertyConnection */> {
        self._glacier_base.property_connections()
    }
    fn property_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::PropertyConnection */> {
        self._glacier_base.property_connections_mut()
    }
    fn link_connections(&self) -> &Vec<BoxedTypeObject /* super::core::LinkConnection */> {
        self._glacier_base.link_connections()
    }
    fn link_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::LinkConnection */> {
        self._glacier_base.link_connections_mut()
    }
    fn interface(&self) -> &Option<LockedTypeObject /* super::core::DynamicDataContainer */> {
        self._glacier_base.interface()
    }
    fn interface_mut(&mut self) -> &mut Option<LockedTypeObject /* super::core::DynamicDataContainer */> {
        self._glacier_base.interface_mut()
    }
}

impl super::core::AssetTrait for WorldData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for WorldData {
}

pub static WORLDDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WorldData",
    name_hash: 2491518455,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SUBWORLDDATA_TYPE_INFO),
        super_class_offset: offset_of!(WorldData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WorldData as Default>::default())),
            create_boxed: || Box::new(<WorldData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "WorldSizeXZ",
                name_hash: 3734169344,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WorldData, world_size_x_z),
            },
            FieldInfoData {
                name: "WorldSizeY",
                name_hash: 633758747,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WorldData, world_size_y),
            },
            FieldInfoData {
                name: "IsProceduralLevel",
                name_hash: 4073676268,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WorldData, is_procedural_level),
            },
            FieldInfoData {
                name: "IsDedicatedServerLevel",
                name_hash: 3894583735,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WorldData, is_dedicated_server_level),
            },
        ],
    }),
    array_type: Some(WORLDDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WorldData {
    fn type_info(&self) -> &'static TypeInfo {
        WORLDDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WORLDDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WorldData-Array",
    name_hash: 2689144771,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("WorldData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SubWorldData {
    pub _glacier_base: SpatialPrefabBlueprint,
    pub runtime_material_grid: Option<LockedTypeObject /* MaterialGridData */>,
    pub is_win32_sub_level: bool,
    pub is_gen4a_sub_level: bool,
    pub is_gen4b_sub_level: bool,
    pub is_android_sub_level: bool,
    pub is_i_o_s_sub_level: bool,
    pub is_o_s_x_sub_level: bool,
    pub is_linux_sub_level: bool,
    pub persistence_setting: BlueprintPersistenceSetting,
    pub auto_asset_collector: Option<LockedTypeObject /* AutoAssetCollector */>,
    pub components: Vec<Option<LockedTypeObject /* SubWorldDataComponent */>>,
}

pub trait SubWorldDataTrait: SpatialPrefabBlueprintTrait {
    fn runtime_material_grid(&self) -> &Option<LockedTypeObject /* MaterialGridData */>;
    fn runtime_material_grid_mut(&mut self) -> &mut Option<LockedTypeObject /* MaterialGridData */>;
    fn is_win32_sub_level(&self) -> &bool;
    fn is_win32_sub_level_mut(&mut self) -> &mut bool;
    fn is_gen4a_sub_level(&self) -> &bool;
    fn is_gen4a_sub_level_mut(&mut self) -> &mut bool;
    fn is_gen4b_sub_level(&self) -> &bool;
    fn is_gen4b_sub_level_mut(&mut self) -> &mut bool;
    fn is_android_sub_level(&self) -> &bool;
    fn is_android_sub_level_mut(&mut self) -> &mut bool;
    fn is_i_o_s_sub_level(&self) -> &bool;
    fn is_i_o_s_sub_level_mut(&mut self) -> &mut bool;
    fn is_o_s_x_sub_level(&self) -> &bool;
    fn is_o_s_x_sub_level_mut(&mut self) -> &mut bool;
    fn is_linux_sub_level(&self) -> &bool;
    fn is_linux_sub_level_mut(&mut self) -> &mut bool;
    fn persistence_setting(&self) -> &BlueprintPersistenceSetting;
    fn persistence_setting_mut(&mut self) -> &mut BlueprintPersistenceSetting;
    fn auto_asset_collector(&self) -> &Option<LockedTypeObject /* AutoAssetCollector */>;
    fn auto_asset_collector_mut(&mut self) -> &mut Option<LockedTypeObject /* AutoAssetCollector */>;
    fn components(&self) -> &Vec<Option<LockedTypeObject /* SubWorldDataComponent */>>;
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* SubWorldDataComponent */>>;
}

impl SubWorldDataTrait for SubWorldData {
    fn runtime_material_grid(&self) -> &Option<LockedTypeObject /* MaterialGridData */> {
        &self.runtime_material_grid
    }
    fn runtime_material_grid_mut(&mut self) -> &mut Option<LockedTypeObject /* MaterialGridData */> {
        &mut self.runtime_material_grid
    }
    fn is_win32_sub_level(&self) -> &bool {
        &self.is_win32_sub_level
    }
    fn is_win32_sub_level_mut(&mut self) -> &mut bool {
        &mut self.is_win32_sub_level
    }
    fn is_gen4a_sub_level(&self) -> &bool {
        &self.is_gen4a_sub_level
    }
    fn is_gen4a_sub_level_mut(&mut self) -> &mut bool {
        &mut self.is_gen4a_sub_level
    }
    fn is_gen4b_sub_level(&self) -> &bool {
        &self.is_gen4b_sub_level
    }
    fn is_gen4b_sub_level_mut(&mut self) -> &mut bool {
        &mut self.is_gen4b_sub_level
    }
    fn is_android_sub_level(&self) -> &bool {
        &self.is_android_sub_level
    }
    fn is_android_sub_level_mut(&mut self) -> &mut bool {
        &mut self.is_android_sub_level
    }
    fn is_i_o_s_sub_level(&self) -> &bool {
        &self.is_i_o_s_sub_level
    }
    fn is_i_o_s_sub_level_mut(&mut self) -> &mut bool {
        &mut self.is_i_o_s_sub_level
    }
    fn is_o_s_x_sub_level(&self) -> &bool {
        &self.is_o_s_x_sub_level
    }
    fn is_o_s_x_sub_level_mut(&mut self) -> &mut bool {
        &mut self.is_o_s_x_sub_level
    }
    fn is_linux_sub_level(&self) -> &bool {
        &self.is_linux_sub_level
    }
    fn is_linux_sub_level_mut(&mut self) -> &mut bool {
        &mut self.is_linux_sub_level
    }
    fn persistence_setting(&self) -> &BlueprintPersistenceSetting {
        &self.persistence_setting
    }
    fn persistence_setting_mut(&mut self) -> &mut BlueprintPersistenceSetting {
        &mut self.persistence_setting
    }
    fn auto_asset_collector(&self) -> &Option<LockedTypeObject /* AutoAssetCollector */> {
        &self.auto_asset_collector
    }
    fn auto_asset_collector_mut(&mut self) -> &mut Option<LockedTypeObject /* AutoAssetCollector */> {
        &mut self.auto_asset_collector
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* SubWorldDataComponent */>> {
        &self.components
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* SubWorldDataComponent */>> {
        &mut self.components
    }
}

impl SpatialPrefabBlueprintTrait for SubWorldData {
}

impl PrefabBlueprintTrait for SubWorldData {
    fn time_delta_type(&self) -> &TimeDeltaType {
        self._glacier_base.time_delta_type()
    }
    fn time_delta_type_mut(&mut self) -> &mut TimeDeltaType {
        self._glacier_base.time_delta_type_mut()
    }
}

impl BlueprintTrait for SubWorldData {
    fn objects(&self) -> &Vec<Option<LockedTypeObject /* GameObjectData */>> {
        self._glacier_base.objects()
    }
    fn objects_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* GameObjectData */>> {
        self._glacier_base.objects_mut()
    }
    fn schematics(&self) -> &Option<LockedTypeObject /* super::schematics::SchematicsBaseAsset */> {
        self._glacier_base.schematics()
    }
    fn schematics_mut(&mut self) -> &mut Option<LockedTypeObject /* super::schematics::SchematicsBaseAsset */> {
        self._glacier_base.schematics_mut()
    }
}

impl EntityBusDataTrait for SubWorldData {
    fn event_connections(&self) -> &Vec<BoxedTypeObject /* EventConnection */> {
        self._glacier_base.event_connections()
    }
    fn event_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* EventConnection */> {
        self._glacier_base.event_connections_mut()
    }
}

impl super::core::DataBusDataTrait for SubWorldData {
    fn flags(&self) -> &u16 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.flags_mut()
    }
    fn property_connections(&self) -> &Vec<BoxedTypeObject /* super::core::PropertyConnection */> {
        self._glacier_base.property_connections()
    }
    fn property_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::PropertyConnection */> {
        self._glacier_base.property_connections_mut()
    }
    fn link_connections(&self) -> &Vec<BoxedTypeObject /* super::core::LinkConnection */> {
        self._glacier_base.link_connections()
    }
    fn link_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::LinkConnection */> {
        self._glacier_base.link_connections_mut()
    }
    fn interface(&self) -> &Option<LockedTypeObject /* super::core::DynamicDataContainer */> {
        self._glacier_base.interface()
    }
    fn interface_mut(&mut self) -> &mut Option<LockedTypeObject /* super::core::DynamicDataContainer */> {
        self._glacier_base.interface_mut()
    }
}

impl super::core::AssetTrait for SubWorldData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for SubWorldData {
}

pub static SUBWORLDDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubWorldData",
    name_hash: 1556892979,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SPATIALPREFABBLUEPRINT_TYPE_INFO),
        super_class_offset: offset_of!(SubWorldData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SubWorldData as Default>::default())),
            create_boxed: || Box::new(<SubWorldData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "RuntimeMaterialGrid",
                name_hash: 1453435306,
                flags: MemberInfoFlags::new(0),
                field_type: "MaterialGridData",
                rust_offset: offset_of!(SubWorldData, runtime_material_grid),
            },
            FieldInfoData {
                name: "IsWin32SubLevel",
                name_hash: 2682003100,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SubWorldData, is_win32_sub_level),
            },
            FieldInfoData {
                name: "IsGen4aSubLevel",
                name_hash: 4098771572,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SubWorldData, is_gen4a_sub_level),
            },
            FieldInfoData {
                name: "IsGen4bSubLevel",
                name_hash: 139225463,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SubWorldData, is_gen4b_sub_level),
            },
            FieldInfoData {
                name: "IsAndroidSubLevel",
                name_hash: 867634550,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SubWorldData, is_android_sub_level),
            },
            FieldInfoData {
                name: "IsIOSSubLevel",
                name_hash: 4180944952,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SubWorldData, is_i_o_s_sub_level),
            },
            FieldInfoData {
                name: "IsOSXSubLevel",
                name_hash: 2688156201,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SubWorldData, is_o_s_x_sub_level),
            },
            FieldInfoData {
                name: "IsLinuxSubLevel",
                name_hash: 4067552587,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SubWorldData, is_linux_sub_level),
            },
            FieldInfoData {
                name: "PersistenceSetting",
                name_hash: 3641697508,
                flags: MemberInfoFlags::new(0),
                field_type: "BlueprintPersistenceSetting",
                rust_offset: offset_of!(SubWorldData, persistence_setting),
            },
            FieldInfoData {
                name: "AutoAssetCollector",
                name_hash: 3958760185,
                flags: MemberInfoFlags::new(0),
                field_type: "AutoAssetCollector",
                rust_offset: offset_of!(SubWorldData, auto_asset_collector),
            },
            FieldInfoData {
                name: "Components",
                name_hash: 3391050425,
                flags: MemberInfoFlags::new(144),
                field_type: "SubWorldDataComponent-Array",
                rust_offset: offset_of!(SubWorldData, components),
            },
        ],
    }),
    array_type: Some(SUBWORLDDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SubWorldData {
    fn type_info(&self) -> &'static TypeInfo {
        SUBWORLDDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SUBWORLDDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubWorldData-Array",
    name_hash: 3220347015,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SubWorldData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SubWorldDataComponent {
    pub _glacier_base: super::core::DataContainer,
}

pub trait SubWorldDataComponentTrait: super::core::DataContainerTrait {
}

impl SubWorldDataComponentTrait for SubWorldDataComponent {
}

impl super::core::DataContainerTrait for SubWorldDataComponent {
}

pub static SUBWORLDDATACOMPONENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubWorldDataComponent",
    name_hash: 2978528508,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(SubWorldDataComponent, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SubWorldDataComponent as Default>::default())),
            create_boxed: || Box::new(<SubWorldDataComponent as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(SUBWORLDDATACOMPONENT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SubWorldDataComponent {
    fn type_info(&self) -> &'static TypeInfo {
        SUBWORLDDATACOMPONENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SUBWORLDDATACOMPONENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubWorldDataComponent-Array",
    name_hash: 3651085512,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SubWorldDataComponent"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct WorldPartData {
    pub _glacier_base: LayerData,
}

pub trait WorldPartDataTrait: LayerDataTrait {
}

impl WorldPartDataTrait for WorldPartData {
}

impl LayerDataTrait for WorldPartData {
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
    fn hack_to_solve_real_time_tweaking_issue(&self) -> &glacier_util::guid::Guid {
        self._glacier_base.hack_to_solve_real_time_tweaking_issue()
    }
    fn hack_to_solve_real_time_tweaking_issue_mut(&mut self) -> &mut glacier_util::guid::Guid {
        self._glacier_base.hack_to_solve_real_time_tweaking_issue_mut()
    }
}

impl PrefabBlueprintTrait for WorldPartData {
    fn time_delta_type(&self) -> &TimeDeltaType {
        self._glacier_base.time_delta_type()
    }
    fn time_delta_type_mut(&mut self) -> &mut TimeDeltaType {
        self._glacier_base.time_delta_type_mut()
    }
}

impl BlueprintTrait for WorldPartData {
    fn objects(&self) -> &Vec<Option<LockedTypeObject /* GameObjectData */>> {
        self._glacier_base.objects()
    }
    fn objects_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* GameObjectData */>> {
        self._glacier_base.objects_mut()
    }
    fn schematics(&self) -> &Option<LockedTypeObject /* super::schematics::SchematicsBaseAsset */> {
        self._glacier_base.schematics()
    }
    fn schematics_mut(&mut self) -> &mut Option<LockedTypeObject /* super::schematics::SchematicsBaseAsset */> {
        self._glacier_base.schematics_mut()
    }
}

impl EntityBusDataTrait for WorldPartData {
    fn event_connections(&self) -> &Vec<BoxedTypeObject /* EventConnection */> {
        self._glacier_base.event_connections()
    }
    fn event_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* EventConnection */> {
        self._glacier_base.event_connections_mut()
    }
}

impl super::core::DataBusDataTrait for WorldPartData {
    fn flags(&self) -> &u16 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.flags_mut()
    }
    fn property_connections(&self) -> &Vec<BoxedTypeObject /* super::core::PropertyConnection */> {
        self._glacier_base.property_connections()
    }
    fn property_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::PropertyConnection */> {
        self._glacier_base.property_connections_mut()
    }
    fn link_connections(&self) -> &Vec<BoxedTypeObject /* super::core::LinkConnection */> {
        self._glacier_base.link_connections()
    }
    fn link_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::LinkConnection */> {
        self._glacier_base.link_connections_mut()
    }
    fn interface(&self) -> &Option<LockedTypeObject /* super::core::DynamicDataContainer */> {
        self._glacier_base.interface()
    }
    fn interface_mut(&mut self) -> &mut Option<LockedTypeObject /* super::core::DynamicDataContainer */> {
        self._glacier_base.interface_mut()
    }
}

impl super::core::AssetTrait for WorldPartData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for WorldPartData {
}

pub static WORLDPARTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WorldPartData",
    name_hash: 173330176,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(LAYERDATA_TYPE_INFO),
        super_class_offset: offset_of!(WorldPartData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WorldPartData as Default>::default())),
            create_boxed: || Box::new(<WorldPartData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(WORLDPARTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WorldPartData {
    fn type_info(&self) -> &'static TypeInfo {
        WORLDPARTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WORLDPARTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WorldPartData-Array",
    name_hash: 890418484,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("WorldPartData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct LayerData {
    pub _glacier_base: PrefabBlueprint,
    pub enabled: bool,
    pub hack_to_solve_real_time_tweaking_issue: glacier_util::guid::Guid,
}

pub trait LayerDataTrait: PrefabBlueprintTrait {
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
    fn hack_to_solve_real_time_tweaking_issue(&self) -> &glacier_util::guid::Guid;
    fn hack_to_solve_real_time_tweaking_issue_mut(&mut self) -> &mut glacier_util::guid::Guid;
}

impl LayerDataTrait for LayerData {
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
    fn hack_to_solve_real_time_tweaking_issue(&self) -> &glacier_util::guid::Guid {
        &self.hack_to_solve_real_time_tweaking_issue
    }
    fn hack_to_solve_real_time_tweaking_issue_mut(&mut self) -> &mut glacier_util::guid::Guid {
        &mut self.hack_to_solve_real_time_tweaking_issue
    }
}

impl PrefabBlueprintTrait for LayerData {
    fn time_delta_type(&self) -> &TimeDeltaType {
        self._glacier_base.time_delta_type()
    }
    fn time_delta_type_mut(&mut self) -> &mut TimeDeltaType {
        self._glacier_base.time_delta_type_mut()
    }
}

impl BlueprintTrait for LayerData {
    fn objects(&self) -> &Vec<Option<LockedTypeObject /* GameObjectData */>> {
        self._glacier_base.objects()
    }
    fn objects_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* GameObjectData */>> {
        self._glacier_base.objects_mut()
    }
    fn schematics(&self) -> &Option<LockedTypeObject /* super::schematics::SchematicsBaseAsset */> {
        self._glacier_base.schematics()
    }
    fn schematics_mut(&mut self) -> &mut Option<LockedTypeObject /* super::schematics::SchematicsBaseAsset */> {
        self._glacier_base.schematics_mut()
    }
}

impl EntityBusDataTrait for LayerData {
    fn event_connections(&self) -> &Vec<BoxedTypeObject /* EventConnection */> {
        self._glacier_base.event_connections()
    }
    fn event_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* EventConnection */> {
        self._glacier_base.event_connections_mut()
    }
}

impl super::core::DataBusDataTrait for LayerData {
    fn flags(&self) -> &u16 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.flags_mut()
    }
    fn property_connections(&self) -> &Vec<BoxedTypeObject /* super::core::PropertyConnection */> {
        self._glacier_base.property_connections()
    }
    fn property_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::PropertyConnection */> {
        self._glacier_base.property_connections_mut()
    }
    fn link_connections(&self) -> &Vec<BoxedTypeObject /* super::core::LinkConnection */> {
        self._glacier_base.link_connections()
    }
    fn link_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::LinkConnection */> {
        self._glacier_base.link_connections_mut()
    }
    fn interface(&self) -> &Option<LockedTypeObject /* super::core::DynamicDataContainer */> {
        self._glacier_base.interface()
    }
    fn interface_mut(&mut self) -> &mut Option<LockedTypeObject /* super::core::DynamicDataContainer */> {
        self._glacier_base.interface_mut()
    }
}

impl super::core::AssetTrait for LayerData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for LayerData {
}

pub static LAYERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LayerData",
    name_hash: 3033212822,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PREFABBLUEPRINT_TYPE_INFO),
        super_class_offset: offset_of!(LayerData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LayerData as Default>::default())),
            create_boxed: || Box::new(<LayerData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Enabled",
                name_hash: 2662400,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LayerData, enabled),
            },
            FieldInfoData {
                name: "HackToSolveRealTimeTweakingIssue",
                name_hash: 1452521702,
                flags: MemberInfoFlags::new(0),
                field_type: "Guid",
                rust_offset: offset_of!(LayerData, hack_to_solve_real_time_tweaking_issue),
            },
        ],
    }),
    array_type: Some(LAYERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LayerData {
    fn type_info(&self) -> &'static TypeInfo {
        LAYERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LAYERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LayerData-Array",
    name_hash: 1820859554,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("LayerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SubWorldInclusionSettings {
    pub _glacier_base: super::core::DataContainer,
    pub settings: Vec<Option<LockedTypeObject /* SubWorldInclusionSetting */>>,
}

pub trait SubWorldInclusionSettingsTrait: super::core::DataContainerTrait {
    fn settings(&self) -> &Vec<Option<LockedTypeObject /* SubWorldInclusionSetting */>>;
    fn settings_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* SubWorldInclusionSetting */>>;
}

impl SubWorldInclusionSettingsTrait for SubWorldInclusionSettings {
    fn settings(&self) -> &Vec<Option<LockedTypeObject /* SubWorldInclusionSetting */>> {
        &self.settings
    }
    fn settings_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* SubWorldInclusionSetting */>> {
        &mut self.settings
    }
}

impl super::core::DataContainerTrait for SubWorldInclusionSettings {
}

pub static SUBWORLDINCLUSIONSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubWorldInclusionSettings",
    name_hash: 367586080,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(SubWorldInclusionSettings, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SubWorldInclusionSettings as Default>::default())),
            create_boxed: || Box::new(<SubWorldInclusionSettings as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Settings",
                name_hash: 649772672,
                flags: MemberInfoFlags::new(144),
                field_type: "SubWorldInclusionSetting-Array",
                rust_offset: offset_of!(SubWorldInclusionSettings, settings),
            },
        ],
    }),
    array_type: Some(SUBWORLDINCLUSIONSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SubWorldInclusionSettings {
    fn type_info(&self) -> &'static TypeInfo {
        SUBWORLDINCLUSIONSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SUBWORLDINCLUSIONSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubWorldInclusionSettings-Array",
    name_hash: 283848852,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SubWorldInclusionSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SubWorldInclusionSetting {
    pub _glacier_base: super::core::DataContainer,
    pub criterion: Option<LockedTypeObject /* SubWorldInclusionCriterion */>,
    pub enabled_options: Vec<String>,
}

pub trait SubWorldInclusionSettingTrait: super::core::DataContainerTrait {
    fn criterion(&self) -> &Option<LockedTypeObject /* SubWorldInclusionCriterion */>;
    fn criterion_mut(&mut self) -> &mut Option<LockedTypeObject /* SubWorldInclusionCriterion */>;
    fn enabled_options(&self) -> &Vec<String>;
    fn enabled_options_mut(&mut self) -> &mut Vec<String>;
}

impl SubWorldInclusionSettingTrait for SubWorldInclusionSetting {
    fn criterion(&self) -> &Option<LockedTypeObject /* SubWorldInclusionCriterion */> {
        &self.criterion
    }
    fn criterion_mut(&mut self) -> &mut Option<LockedTypeObject /* SubWorldInclusionCriterion */> {
        &mut self.criterion
    }
    fn enabled_options(&self) -> &Vec<String> {
        &self.enabled_options
    }
    fn enabled_options_mut(&mut self) -> &mut Vec<String> {
        &mut self.enabled_options
    }
}

impl super::core::DataContainerTrait for SubWorldInclusionSetting {
}

pub static SUBWORLDINCLUSIONSETTING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubWorldInclusionSetting",
    name_hash: 1442794739,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(SubWorldInclusionSetting, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SubWorldInclusionSetting as Default>::default())),
            create_boxed: || Box::new(<SubWorldInclusionSetting as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Criterion",
                name_hash: 2480005462,
                flags: MemberInfoFlags::new(0),
                field_type: "SubWorldInclusionCriterion",
                rust_offset: offset_of!(SubWorldInclusionSetting, criterion),
            },
            FieldInfoData {
                name: "EnabledOptions",
                name_hash: 2588709552,
                flags: MemberInfoFlags::new(144),
                field_type: "CString-Array",
                rust_offset: offset_of!(SubWorldInclusionSetting, enabled_options),
            },
        ],
    }),
    array_type: Some(SUBWORLDINCLUSIONSETTING_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SubWorldInclusionSetting {
    fn type_info(&self) -> &'static TypeInfo {
        SUBWORLDINCLUSIONSETTING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SUBWORLDINCLUSIONSETTING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubWorldInclusionSetting-Array",
    name_hash: 1570400455,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SubWorldInclusionSetting"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SubWorldInclusion {
    pub _glacier_base: super::core::Asset,
    pub criteria: Vec<Option<LockedTypeObject /* SubWorldInclusionCriterion */>>,
}

pub trait SubWorldInclusionTrait: super::core::AssetTrait {
    fn criteria(&self) -> &Vec<Option<LockedTypeObject /* SubWorldInclusionCriterion */>>;
    fn criteria_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* SubWorldInclusionCriterion */>>;
}

impl SubWorldInclusionTrait for SubWorldInclusion {
    fn criteria(&self) -> &Vec<Option<LockedTypeObject /* SubWorldInclusionCriterion */>> {
        &self.criteria
    }
    fn criteria_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* SubWorldInclusionCriterion */>> {
        &mut self.criteria
    }
}

impl super::core::AssetTrait for SubWorldInclusion {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for SubWorldInclusion {
}

pub static SUBWORLDINCLUSION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubWorldInclusion",
    name_hash: 3679119717,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        super_class_offset: offset_of!(SubWorldInclusion, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SubWorldInclusion as Default>::default())),
            create_boxed: || Box::new(<SubWorldInclusion as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Criteria",
                name_hash: 335452726,
                flags: MemberInfoFlags::new(144),
                field_type: "SubWorldInclusionCriterion-Array",
                rust_offset: offset_of!(SubWorldInclusion, criteria),
            },
        ],
    }),
    array_type: Some(SUBWORLDINCLUSION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SubWorldInclusion {
    fn type_info(&self) -> &'static TypeInfo {
        SUBWORLDINCLUSION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SUBWORLDINCLUSION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubWorldInclusion-Array",
    name_hash: 558502481,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SubWorldInclusion"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SubWorldInclusionCriterion {
    pub _glacier_base: super::core::DataContainer,
    pub name: String,
    pub options: Vec<String>,
}

pub trait SubWorldInclusionCriterionTrait: super::core::DataContainerTrait {
    fn name(&self) -> &String;
    fn name_mut(&mut self) -> &mut String;
    fn options(&self) -> &Vec<String>;
    fn options_mut(&mut self) -> &mut Vec<String>;
}

impl SubWorldInclusionCriterionTrait for SubWorldInclusionCriterion {
    fn name(&self) -> &String {
        &self.name
    }
    fn name_mut(&mut self) -> &mut String {
        &mut self.name
    }
    fn options(&self) -> &Vec<String> {
        &self.options
    }
    fn options_mut(&mut self) -> &mut Vec<String> {
        &mut self.options
    }
}

impl super::core::DataContainerTrait for SubWorldInclusionCriterion {
}

pub static SUBWORLDINCLUSIONCRITERION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubWorldInclusionCriterion",
    name_hash: 1766703542,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(SubWorldInclusionCriterion, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SubWorldInclusionCriterion as Default>::default())),
            create_boxed: || Box::new(<SubWorldInclusionCriterion as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Name",
                name_hash: 2088949890,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(SubWorldInclusionCriterion, name),
            },
            FieldInfoData {
                name: "Options",
                name_hash: 958915349,
                flags: MemberInfoFlags::new(144),
                field_type: "CString-Array",
                rust_offset: offset_of!(SubWorldInclusionCriterion, options),
            },
        ],
    }),
    array_type: Some(SUBWORLDINCLUSIONCRITERION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SubWorldInclusionCriterion {
    fn type_info(&self) -> &'static TypeInfo {
        SUBWORLDINCLUSIONCRITERION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SUBWORLDINCLUSIONCRITERION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubWorldInclusionCriterion-Array",
    name_hash: 2520897026,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SubWorldInclusionCriterion"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct LevelSetup {
    pub name: String,
    pub inclusion_options: Vec<BoxedTypeObject /* LevelSetupOption */>,
    pub difficulty_index: u32,
    pub start_point: String,
    pub is_save_game: bool,
    pub has_persistent_save: bool,
    pub force_reload_resources: bool,
    pub level_manager_initial_level: String,
    pub level_manager_start_point: String,
}

pub trait LevelSetupTrait: TypeObject {
    fn name(&self) -> &String;
    fn name_mut(&mut self) -> &mut String;
    fn inclusion_options(&self) -> &Vec<BoxedTypeObject /* LevelSetupOption */>;
    fn inclusion_options_mut(&mut self) -> &mut Vec<BoxedTypeObject /* LevelSetupOption */>;
    fn difficulty_index(&self) -> &u32;
    fn difficulty_index_mut(&mut self) -> &mut u32;
    fn start_point(&self) -> &String;
    fn start_point_mut(&mut self) -> &mut String;
    fn is_save_game(&self) -> &bool;
    fn is_save_game_mut(&mut self) -> &mut bool;
    fn has_persistent_save(&self) -> &bool;
    fn has_persistent_save_mut(&mut self) -> &mut bool;
    fn force_reload_resources(&self) -> &bool;
    fn force_reload_resources_mut(&mut self) -> &mut bool;
    fn level_manager_initial_level(&self) -> &String;
    fn level_manager_initial_level_mut(&mut self) -> &mut String;
    fn level_manager_start_point(&self) -> &String;
    fn level_manager_start_point_mut(&mut self) -> &mut String;
}

impl LevelSetupTrait for LevelSetup {
    fn name(&self) -> &String {
        &self.name
    }
    fn name_mut(&mut self) -> &mut String {
        &mut self.name
    }
    fn inclusion_options(&self) -> &Vec<BoxedTypeObject /* LevelSetupOption */> {
        &self.inclusion_options
    }
    fn inclusion_options_mut(&mut self) -> &mut Vec<BoxedTypeObject /* LevelSetupOption */> {
        &mut self.inclusion_options
    }
    fn difficulty_index(&self) -> &u32 {
        &self.difficulty_index
    }
    fn difficulty_index_mut(&mut self) -> &mut u32 {
        &mut self.difficulty_index
    }
    fn start_point(&self) -> &String {
        &self.start_point
    }
    fn start_point_mut(&mut self) -> &mut String {
        &mut self.start_point
    }
    fn is_save_game(&self) -> &bool {
        &self.is_save_game
    }
    fn is_save_game_mut(&mut self) -> &mut bool {
        &mut self.is_save_game
    }
    fn has_persistent_save(&self) -> &bool {
        &self.has_persistent_save
    }
    fn has_persistent_save_mut(&mut self) -> &mut bool {
        &mut self.has_persistent_save
    }
    fn force_reload_resources(&self) -> &bool {
        &self.force_reload_resources
    }
    fn force_reload_resources_mut(&mut self) -> &mut bool {
        &mut self.force_reload_resources
    }
    fn level_manager_initial_level(&self) -> &String {
        &self.level_manager_initial_level
    }
    fn level_manager_initial_level_mut(&mut self) -> &mut String {
        &mut self.level_manager_initial_level
    }
    fn level_manager_start_point(&self) -> &String {
        &self.level_manager_start_point
    }
    fn level_manager_start_point_mut(&mut self) -> &mut String {
        &mut self.level_manager_start_point
    }
}

pub static LEVELSETUP_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LevelSetup",
    name_hash: 1198400020,
    flags: MemberInfoFlags::new(73),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LevelSetup as Default>::default())),
            create_boxed: || Box::new(<LevelSetup as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Name",
                name_hash: 2088949890,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(LevelSetup, name),
            },
            FieldInfoData {
                name: "InclusionOptions",
                name_hash: 1857959091,
                flags: MemberInfoFlags::new(144),
                field_type: "LevelSetupOption-Array",
                rust_offset: offset_of!(LevelSetup, inclusion_options),
            },
            FieldInfoData {
                name: "DifficultyIndex",
                name_hash: 302070728,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(LevelSetup, difficulty_index),
            },
            FieldInfoData {
                name: "StartPoint",
                name_hash: 2755831849,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(LevelSetup, start_point),
            },
            FieldInfoData {
                name: "IsSaveGame",
                name_hash: 3625496752,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LevelSetup, is_save_game),
            },
            FieldInfoData {
                name: "HasPersistentSave",
                name_hash: 1104880027,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LevelSetup, has_persistent_save),
            },
            FieldInfoData {
                name: "ForceReloadResources",
                name_hash: 3211157744,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LevelSetup, force_reload_resources),
            },
            FieldInfoData {
                name: "LevelManagerInitialLevel",
                name_hash: 992374984,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(LevelSetup, level_manager_initial_level),
            },
            FieldInfoData {
                name: "LevelManagerStartPoint",
                name_hash: 4230321356,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(LevelSetup, level_manager_start_point),
            },
        ],
    }),
    array_type: Some(LEVELSETUP_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LevelSetup {
    fn type_info(&self) -> &'static TypeInfo {
        LEVELSETUP_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static LEVELSETUP_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LevelSetup-Array",
    name_hash: 863026720,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("LevelSetup"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct LevelSetupOption {
    pub criterion: String,
    pub value: String,
}

pub trait LevelSetupOptionTrait: TypeObject {
    fn criterion(&self) -> &String;
    fn criterion_mut(&mut self) -> &mut String;
    fn value(&self) -> &String;
    fn value_mut(&mut self) -> &mut String;
}

impl LevelSetupOptionTrait for LevelSetupOption {
    fn criterion(&self) -> &String {
        &self.criterion
    }
    fn criterion_mut(&mut self) -> &mut String {
        &mut self.criterion
    }
    fn value(&self) -> &String {
        &self.value
    }
    fn value_mut(&mut self) -> &mut String {
        &mut self.value
    }
}

pub static LEVELSETUPOPTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LevelSetupOption",
    name_hash: 2288590967,
    flags: MemberInfoFlags::new(73),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LevelSetupOption as Default>::default())),
            create_boxed: || Box::new(<LevelSetupOption as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Criterion",
                name_hash: 2480005462,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(LevelSetupOption, criterion),
            },
            FieldInfoData {
                name: "Value",
                name_hash: 225375086,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(LevelSetupOption, value),
            },
        ],
    }),
    array_type: Some(LEVELSETUPOPTION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LevelSetupOption {
    fn type_info(&self) -> &'static TypeInfo {
        LEVELSETUPOPTION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static LEVELSETUPOPTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LevelSetupOption-Array",
    name_hash: 3644099139,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("LevelSetupOption"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CreateSchematicsInstanceEntity {
    pub _glacier_base: Entity,
}

pub trait CreateSchematicsInstanceEntityTrait: EntityTrait {
}

impl CreateSchematicsInstanceEntityTrait for CreateSchematicsInstanceEntity {
}

impl EntityTrait for CreateSchematicsInstanceEntity {
}

impl EntityBusPeerTrait for CreateSchematicsInstanceEntity {
}

pub static CREATESCHEMATICSINSTANCEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CreateSchematicsInstanceEntity",
    name_hash: 3977093519,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(CreateSchematicsInstanceEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CreateSchematicsInstanceEntity as Default>::default())),
            create_boxed: || Box::new(<CreateSchematicsInstanceEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(CREATESCHEMATICSINSTANCEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for CreateSchematicsInstanceEntity {
    fn type_info(&self) -> &'static TypeInfo {
        CREATESCHEMATICSINSTANCEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CREATESCHEMATICSINSTANCEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CreateSchematicsInstanceEntity-Array",
    name_hash: 3196173883,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CreateSchematicsInstanceEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct GetEntityBusEntity {
    pub _glacier_base: Entity,
}

pub trait GetEntityBusEntityTrait: EntityTrait {
}

impl GetEntityBusEntityTrait for GetEntityBusEntity {
}

impl EntityTrait for GetEntityBusEntity {
}

impl EntityBusPeerTrait for GetEntityBusEntity {
}

pub static GETENTITYBUSENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GetEntityBusEntity",
    name_hash: 4036210743,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(GetEntityBusEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GetEntityBusEntity as Default>::default())),
            create_boxed: || Box::new(<GetEntityBusEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(GETENTITYBUSENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for GetEntityBusEntity {
    fn type_info(&self) -> &'static TypeInfo {
        GETENTITYBUSENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static GETENTITYBUSENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GetEntityBusEntity-Array",
    name_hash: 3015174531,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("GetEntityBusEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct GetEntityEntity {
    pub _glacier_base: Entity,
}

pub trait GetEntityEntityTrait: EntityTrait {
}

impl GetEntityEntityTrait for GetEntityEntity {
}

impl EntityTrait for GetEntityEntity {
}

impl EntityBusPeerTrait for GetEntityEntity {
}

pub static GETENTITYENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GetEntityEntity",
    name_hash: 3339482963,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(GetEntityEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GetEntityEntity as Default>::default())),
            create_boxed: || Box::new(<GetEntityEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(GETENTITYENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for GetEntityEntity {
    fn type_info(&self) -> &'static TypeInfo {
        GETENTITYENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static GETENTITYENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GetEntityEntity-Array",
    name_hash: 4055720551,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("GetEntityEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CallFunctionEntity {
    pub _glacier_base: Entity,
}

pub trait CallFunctionEntityTrait: EntityTrait {
}

impl CallFunctionEntityTrait for CallFunctionEntity {
}

impl EntityTrait for CallFunctionEntity {
}

impl EntityBusPeerTrait for CallFunctionEntity {
}

pub static CALLFUNCTIONENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CallFunctionEntity",
    name_hash: 3650895966,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(CallFunctionEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CallFunctionEntity as Default>::default())),
            create_boxed: || Box::new(<CallFunctionEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(CALLFUNCTIONENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for CallFunctionEntity {
    fn type_info(&self) -> &'static TypeInfo {
        CALLFUNCTIONENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CALLFUNCTIONENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CallFunctionEntity-Array",
    name_hash: 2806538730,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CallFunctionEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct EntityTransformSpace {
}

pub trait EntityTransformSpaceTrait: TypeObject {
}

impl EntityTransformSpaceTrait for EntityTransformSpace {
}

pub static ENTITYTRANSFORMSPACE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityTransformSpace",
    name_hash: 263248950,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: None,
        super_class_offset: 0,
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EntityTransformSpace as Default>::default())),
            create_boxed: || Box::new(<EntityTransformSpace as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(ENTITYTRANSFORMSPACE_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for EntityTransformSpace {
    fn type_info(&self) -> &'static TypeInfo {
        ENTITYTRANSFORMSPACE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ENTITYTRANSFORMSPACE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityTransformSpace-Array",
    name_hash: 573493378,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EntityTransformSpace"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct Entity {
    pub _glacier_base: EntityBusPeer,
}

pub trait EntityTrait: EntityBusPeerTrait {
}

impl EntityTrait for Entity {
}

impl EntityBusPeerTrait for Entity {
}

pub static ENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Entity",
    name_hash: 2342964382,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYBUSPEER_TYPE_INFO),
        super_class_offset: offset_of!(Entity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Entity as Default>::default())),
            create_boxed: || Box::new(<Entity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(ENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for Entity {
    fn type_info(&self) -> &'static TypeInfo {
        ENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Entity-Array",
    name_hash: 1196088746,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Entity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ComponentEntity {
    pub _glacier_base: SpatialEntity,
}

pub trait ComponentEntityTrait: SpatialEntityTrait {
}

impl ComponentEntityTrait for ComponentEntity {
}

impl SpatialEntityTrait for ComponentEntity {
}

impl EntityTrait for ComponentEntity {
}

impl EntityBusPeerTrait for ComponentEntity {
}

pub static COMPONENTENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ComponentEntity",
    name_hash: 2187906833,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SPATIALENTITY_TYPE_INFO),
        super_class_offset: offset_of!(ComponentEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ComponentEntity as Default>::default())),
            create_boxed: || Box::new(<ComponentEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(COMPONENTENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ComponentEntity {
    fn type_info(&self) -> &'static TypeInfo {
        COMPONENTENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COMPONENTENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ComponentEntity-Array",
    name_hash: 4152643749,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ComponentEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct Component {
    pub _glacier_base: EntityBusPeer,
}

pub trait ComponentTrait: EntityBusPeerTrait {
}

impl ComponentTrait for Component {
}

impl EntityBusPeerTrait for Component {
}

pub static COMPONENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Component",
    name_hash: 1924866442,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYBUSPEER_TYPE_INFO),
        super_class_offset: offset_of!(Component, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Component as Default>::default())),
            create_boxed: || Box::new(<Component as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(COMPONENT_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for Component {
    fn type_info(&self) -> &'static TypeInfo {
        COMPONENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COMPONENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Component-Array",
    name_hash: 1387822270,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Component"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CompareAxisAlignedBoxEntity {
    pub _glacier_base: Entity,
}

pub trait CompareAxisAlignedBoxEntityTrait: EntityTrait {
}

impl CompareAxisAlignedBoxEntityTrait for CompareAxisAlignedBoxEntity {
}

impl EntityTrait for CompareAxisAlignedBoxEntity {
}

impl EntityBusPeerTrait for CompareAxisAlignedBoxEntity {
}

pub static COMPAREAXISALIGNEDBOXENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareAxisAlignedBoxEntity",
    name_hash: 2836733251,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(CompareAxisAlignedBoxEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareAxisAlignedBoxEntity as Default>::default())),
            create_boxed: || Box::new(<CompareAxisAlignedBoxEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(COMPAREAXISALIGNEDBOXENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for CompareAxisAlignedBoxEntity {
    fn type_info(&self) -> &'static TypeInfo {
        COMPAREAXISALIGNEDBOXENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COMPAREAXISALIGNEDBOXENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareAxisAlignedBoxEntity-Array",
    name_hash: 2912403575,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareAxisAlignedBoxEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CompareUintRangeEntity {
    pub _glacier_base: Entity,
}

pub trait CompareUintRangeEntityTrait: EntityTrait {
}

impl CompareUintRangeEntityTrait for CompareUintRangeEntity {
}

impl EntityTrait for CompareUintRangeEntity {
}

impl EntityBusPeerTrait for CompareUintRangeEntity {
}

pub static COMPAREUINTRANGEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareUintRangeEntity",
    name_hash: 4012700160,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(CompareUintRangeEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareUintRangeEntity as Default>::default())),
            create_boxed: || Box::new(<CompareUintRangeEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(COMPAREUINTRANGEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for CompareUintRangeEntity {
    fn type_info(&self) -> &'static TypeInfo {
        COMPAREUINTRANGEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COMPAREUINTRANGEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareUintRangeEntity-Array",
    name_hash: 2453215284,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareUintRangeEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CompareIntRangeEntity {
    pub _glacier_base: Entity,
}

pub trait CompareIntRangeEntityTrait: EntityTrait {
}

impl CompareIntRangeEntityTrait for CompareIntRangeEntity {
}

impl EntityTrait for CompareIntRangeEntity {
}

impl EntityBusPeerTrait for CompareIntRangeEntity {
}

pub static COMPAREINTRANGEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareIntRangeEntity",
    name_hash: 2122647925,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(CompareIntRangeEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareIntRangeEntity as Default>::default())),
            create_boxed: || Box::new(<CompareIntRangeEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(COMPAREINTRANGEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for CompareIntRangeEntity {
    fn type_info(&self) -> &'static TypeInfo {
        COMPAREINTRANGEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COMPAREINTRANGEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareIntRangeEntity-Array",
    name_hash: 3744397889,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareIntRangeEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CompareVec4Entity {
    pub _glacier_base: Entity,
}

pub trait CompareVec4EntityTrait: EntityTrait {
}

impl CompareVec4EntityTrait for CompareVec4Entity {
}

impl EntityTrait for CompareVec4Entity {
}

impl EntityBusPeerTrait for CompareVec4Entity {
}

pub static COMPAREVEC4ENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareVec4Entity",
    name_hash: 315937245,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(CompareVec4Entity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareVec4Entity as Default>::default())),
            create_boxed: || Box::new(<CompareVec4Entity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(COMPAREVEC4ENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for CompareVec4Entity {
    fn type_info(&self) -> &'static TypeInfo {
        COMPAREVEC4ENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COMPAREVEC4ENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareVec4Entity-Array",
    name_hash: 873623017,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareVec4Entity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CompareVec3Entity {
    pub _glacier_base: Entity,
}

pub trait CompareVec3EntityTrait: EntityTrait {
}

impl CompareVec3EntityTrait for CompareVec3Entity {
}

impl EntityTrait for CompareVec3Entity {
}

impl EntityBusPeerTrait for CompareVec3Entity {
}

pub static COMPAREVEC3ENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareVec3Entity",
    name_hash: 1971429082,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(CompareVec3Entity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareVec3Entity as Default>::default())),
            create_boxed: || Box::new(<CompareVec3Entity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(COMPAREVEC3ENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for CompareVec3Entity {
    fn type_info(&self) -> &'static TypeInfo {
        COMPAREVEC3ENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COMPAREVEC3ENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareVec3Entity-Array",
    name_hash: 421196398,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareVec3Entity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CompareFloatRangeEntity {
    pub _glacier_base: Entity,
}

pub trait CompareFloatRangeEntityTrait: EntityTrait {
}

impl CompareFloatRangeEntityTrait for CompareFloatRangeEntity {
}

impl EntityTrait for CompareFloatRangeEntity {
}

impl EntityBusPeerTrait for CompareFloatRangeEntity {
}

pub static COMPAREFLOATRANGEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareFloatRangeEntity",
    name_hash: 499359606,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(CompareFloatRangeEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareFloatRangeEntity as Default>::default())),
            create_boxed: || Box::new(<CompareFloatRangeEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(COMPAREFLOATRANGEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for CompareFloatRangeEntity {
    fn type_info(&self) -> &'static TypeInfo {
        COMPAREFLOATRANGEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COMPAREFLOATRANGEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareFloatRangeEntity-Array",
    name_hash: 3343303746,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareFloatRangeEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CompareStringEntity {
    pub _glacier_base: Entity,
}

pub trait CompareStringEntityTrait: EntityTrait {
}

impl CompareStringEntityTrait for CompareStringEntity {
}

impl EntityTrait for CompareStringEntity {
}

impl EntityBusPeerTrait for CompareStringEntity {
}

pub static COMPARESTRINGENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareStringEntity",
    name_hash: 2778268044,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(CompareStringEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareStringEntity as Default>::default())),
            create_boxed: || Box::new(<CompareStringEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(COMPARESTRINGENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for CompareStringEntity {
    fn type_info(&self) -> &'static TypeInfo {
        COMPARESTRINGENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COMPARESTRINGENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareStringEntity-Array",
    name_hash: 4094808504,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareStringEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CompareFloatEntity {
    pub _glacier_base: Entity,
}

pub trait CompareFloatEntityTrait: EntityTrait {
}

impl CompareFloatEntityTrait for CompareFloatEntity {
}

impl EntityTrait for CompareFloatEntity {
}

impl EntityBusPeerTrait for CompareFloatEntity {
}

pub static COMPAREFLOATENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareFloatEntity",
    name_hash: 99833513,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(CompareFloatEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareFloatEntity as Default>::default())),
            create_boxed: || Box::new(<CompareFloatEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(COMPAREFLOATENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for CompareFloatEntity {
    fn type_info(&self) -> &'static TypeInfo {
        COMPAREFLOATENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COMPAREFLOATENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareFloatEntity-Array",
    name_hash: 2353978653,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareFloatEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CompareUintEntity {
    pub _glacier_base: Entity,
}

pub trait CompareUintEntityTrait: EntityTrait {
}

impl CompareUintEntityTrait for CompareUintEntity {
}

impl EntityTrait for CompareUintEntity {
}

impl EntityBusPeerTrait for CompareUintEntity {
}

pub static COMPAREUINTENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareUintEntity",
    name_hash: 3433494303,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(CompareUintEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareUintEntity as Default>::default())),
            create_boxed: || Box::new(<CompareUintEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(COMPAREUINTENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for CompareUintEntity {
    fn type_info(&self) -> &'static TypeInfo {
        COMPAREUINTENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COMPAREUINTENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareUintEntity-Array",
    name_hash: 2411199403,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareUintEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CompareIntEntity {
    pub _glacier_base: Entity,
}

pub trait CompareIntEntityTrait: EntityTrait {
}

impl CompareIntEntityTrait for CompareIntEntity {
}

impl EntityTrait for CompareIntEntity {
}

impl EntityBusPeerTrait for CompareIntEntity {
}

pub static COMPAREINTENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareIntEntity",
    name_hash: 2961243146,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(CompareIntEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareIntEntity as Default>::default())),
            create_boxed: || Box::new(<CompareIntEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(COMPAREINTENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for CompareIntEntity {
    fn type_info(&self) -> &'static TypeInfo {
        COMPAREINTENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COMPAREINTENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareIntEntity-Array",
    name_hash: 2769827646,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareIntEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CompareBoolEntity {
    pub _glacier_base: Entity,
}

pub trait CompareBoolEntityTrait: EntityTrait {
}

impl CompareBoolEntityTrait for CompareBoolEntity {
}

impl EntityTrait for CompareBoolEntity {
}

impl EntityBusPeerTrait for CompareBoolEntity {
}

pub static COMPAREBOOLENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareBoolEntity",
    name_hash: 1049480727,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(CompareBoolEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareBoolEntity as Default>::default())),
            create_boxed: || Box::new(<CompareBoolEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(COMPAREBOOLENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for CompareBoolEntity {
    fn type_info(&self) -> &'static TypeInfo {
        COMPAREBOOLENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COMPAREBOOLENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareBoolEntity-Array",
    name_hash: 1017427619,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareBoolEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ServerDilationEntity {
    pub _glacier_base: Entity,
}

pub trait ServerDilationEntityTrait: EntityTrait {
}

impl ServerDilationEntityTrait for ServerDilationEntity {
}

impl EntityTrait for ServerDilationEntity {
}

impl EntityBusPeerTrait for ServerDilationEntity {
}

pub static SERVERDILATIONENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ServerDilationEntity",
    name_hash: 333505703,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(ServerDilationEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ServerDilationEntity as Default>::default())),
            create_boxed: || Box::new(<ServerDilationEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(SERVERDILATIONENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ServerDilationEntity {
    fn type_info(&self) -> &'static TypeInfo {
        SERVERDILATIONENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SERVERDILATIONENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ServerDilationEntity-Array",
    name_hash: 3735533075,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ServerDilationEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ClientBalancedDilationEntity {
    pub _glacier_base: Entity,
}

pub trait ClientBalancedDilationEntityTrait: EntityTrait {
}

impl ClientBalancedDilationEntityTrait for ClientBalancedDilationEntity {
}

impl EntityTrait for ClientBalancedDilationEntity {
}

impl EntityBusPeerTrait for ClientBalancedDilationEntity {
}

pub static CLIENTBALANCEDDILATIONENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClientBalancedDilationEntity",
    name_hash: 783000185,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(ClientBalancedDilationEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ClientBalancedDilationEntity as Default>::default())),
            create_boxed: || Box::new(<ClientBalancedDilationEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(CLIENTBALANCEDDILATIONENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ClientBalancedDilationEntity {
    fn type_info(&self) -> &'static TypeInfo {
        CLIENTBALANCEDDILATIONENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CLIENTBALANCEDDILATIONENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClientBalancedDilationEntity-Array",
    name_hash: 1130627405,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ClientBalancedDilationEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct AnimTrackData {
}

pub trait AnimTrackDataTrait: TypeObject {
}

impl AnimTrackDataTrait for AnimTrackData {
}

pub static ANIMTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimTrackData",
    name_hash: 4257453041,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: None,
        super_class_offset: 0,
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AnimTrackData as Default>::default())),
            create_boxed: || Box::new(<AnimTrackData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(ANIMTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for AnimTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        ANIMTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ANIMTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimTrackData-Array",
    name_hash: 2508961477,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("AnimTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SequenceEntity {
    pub _glacier_base: Entity,
}

pub trait SequenceEntityTrait: EntityTrait {
}

impl SequenceEntityTrait for SequenceEntity {
}

impl EntityTrait for SequenceEntity {
}

impl EntityBusPeerTrait for SequenceEntity {
}

pub static SEQUENCEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SequenceEntity",
    name_hash: 2641259361,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(SequenceEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SequenceEntity as Default>::default())),
            create_boxed: || Box::new(<SequenceEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(SEQUENCEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SequenceEntity {
    fn type_info(&self) -> &'static TypeInfo {
        SEQUENCEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SEQUENCEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SequenceEntity-Array",
    name_hash: 2739365461,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SequenceEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct StringBuilderEntity {
    pub _glacier_base: Entity,
}

pub trait StringBuilderEntityTrait: EntityTrait {
}

impl StringBuilderEntityTrait for StringBuilderEntity {
}

impl EntityTrait for StringBuilderEntity {
}

impl EntityBusPeerTrait for StringBuilderEntity {
}

pub static STRINGBUILDERENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StringBuilderEntity",
    name_hash: 1170240458,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(StringBuilderEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StringBuilderEntity as Default>::default())),
            create_boxed: || Box::new(<StringBuilderEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(STRINGBUILDERENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for StringBuilderEntity {
    fn type_info(&self) -> &'static TypeInfo {
        STRINGBUILDERENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static STRINGBUILDERENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StringBuilderEntity-Array",
    name_hash: 80920446,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("StringBuilderEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct Vec4ChangedEntity {
    pub _glacier_base: Entity,
}

pub trait Vec4ChangedEntityTrait: EntityTrait {
}

impl Vec4ChangedEntityTrait for Vec4ChangedEntity {
}

impl EntityTrait for Vec4ChangedEntity {
}

impl EntityBusPeerTrait for Vec4ChangedEntity {
}

pub static VEC4CHANGEDENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec4ChangedEntity",
    name_hash: 425208088,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(Vec4ChangedEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec4ChangedEntity as Default>::default())),
            create_boxed: || Box::new(<Vec4ChangedEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(VEC4CHANGEDENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for Vec4ChangedEntity {
    fn type_info(&self) -> &'static TypeInfo {
        VEC4CHANGEDENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEC4CHANGEDENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec4ChangedEntity-Array",
    name_hash: 1170453292,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec4ChangedEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct Vec3ChangedEntity {
    pub _glacier_base: Entity,
}

pub trait Vec3ChangedEntityTrait: EntityTrait {
}

impl Vec3ChangedEntityTrait for Vec3ChangedEntity {
}

impl EntityTrait for Vec3ChangedEntity {
}

impl EntityBusPeerTrait for Vec3ChangedEntity {
}

pub static VEC3CHANGEDENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3ChangedEntity",
    name_hash: 2458147519,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(Vec3ChangedEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec3ChangedEntity as Default>::default())),
            create_boxed: || Box::new(<Vec3ChangedEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(VEC3CHANGEDENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for Vec3ChangedEntity {
    fn type_info(&self) -> &'static TypeInfo {
        VEC3CHANGEDENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEC3CHANGEDENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3ChangedEntity-Array",
    name_hash: 4120760331,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec3ChangedEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct Vec2ChangedEntity {
    pub _glacier_base: Entity,
}

pub trait Vec2ChangedEntityTrait: EntityTrait {
}

impl Vec2ChangedEntityTrait for Vec2ChangedEntity {
}

impl EntityTrait for Vec2ChangedEntity {
}

impl EntityBusPeerTrait for Vec2ChangedEntity {
}

pub static VEC2CHANGEDENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec2ChangedEntity",
    name_hash: 1536785374,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(Vec2ChangedEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec2ChangedEntity as Default>::default())),
            create_boxed: || Box::new(<Vec2ChangedEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(VEC2CHANGEDENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for Vec2ChangedEntity {
    fn type_info(&self) -> &'static TypeInfo {
        VEC2CHANGEDENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEC2CHANGEDENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec2ChangedEntity-Array",
    name_hash: 472137066,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec2ChangedEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct IntChangedEntity {
    pub _glacier_base: Entity,
}

pub trait IntChangedEntityTrait: EntityTrait {
}

impl IntChangedEntityTrait for IntChangedEntity {
}

impl EntityTrait for IntChangedEntity {
}

impl EntityBusPeerTrait for IntChangedEntity {
}

pub static INTCHANGEDENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntChangedEntity",
    name_hash: 231460367,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(IntChangedEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<IntChangedEntity as Default>::default())),
            create_boxed: || Box::new(<IntChangedEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(INTCHANGEDENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for IntChangedEntity {
    fn type_info(&self) -> &'static TypeInfo {
        INTCHANGEDENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static INTCHANGEDENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntChangedEntity-Array",
    name_hash: 1968130747,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("IntChangedEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct FloatChangedEntity {
    pub _glacier_base: Entity,
}

pub trait FloatChangedEntityTrait: EntityTrait {
}

impl FloatChangedEntityTrait for FloatChangedEntity {
}

impl EntityTrait for FloatChangedEntity {
}

impl EntityBusPeerTrait for FloatChangedEntity {
}

pub static FLOATCHANGEDENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatChangedEntity",
    name_hash: 3199237452,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(FloatChangedEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FloatChangedEntity as Default>::default())),
            create_boxed: || Box::new(<FloatChangedEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(FLOATCHANGEDENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for FloatChangedEntity {
    fn type_info(&self) -> &'static TypeInfo {
        FLOATCHANGEDENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FLOATCHANGEDENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatChangedEntity-Array",
    name_hash: 1108024824,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("FloatChangedEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct BoolChangedEntity {
    pub _glacier_base: Entity,
}

pub trait BoolChangedEntityTrait: EntityTrait {
}

impl BoolChangedEntityTrait for BoolChangedEntity {
}

impl EntityTrait for BoolChangedEntity {
}

impl EntityBusPeerTrait for BoolChangedEntity {
}

pub static BOOLCHANGEDENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolChangedEntity",
    name_hash: 682297746,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(BoolChangedEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BoolChangedEntity as Default>::default())),
            create_boxed: || Box::new(<BoolChangedEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(BOOLCHANGEDENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for BoolChangedEntity {
    fn type_info(&self) -> &'static TypeInfo {
        BOOLCHANGEDENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BOOLCHANGEDENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolChangedEntity-Array",
    name_hash: 3557413030,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("BoolChangedEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CompareTransformEntity {
    pub _glacier_base: Entity,
}

pub trait CompareTransformEntityTrait: EntityTrait {
}

impl CompareTransformEntityTrait for CompareTransformEntity {
}

impl EntityTrait for CompareTransformEntity {
}

impl EntityBusPeerTrait for CompareTransformEntity {
}

pub static COMPARETRANSFORMENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareTransformEntity",
    name_hash: 2468060117,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(CompareTransformEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareTransformEntity as Default>::default())),
            create_boxed: || Box::new(<CompareTransformEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(COMPARETRANSFORMENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for CompareTransformEntity {
    fn type_info(&self) -> &'static TypeInfo {
        COMPARETRANSFORMENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COMPARETRANSFORMENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareTransformEntity-Array",
    name_hash: 2185845729,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareTransformEntity"),
    array_type: None,
    alignment: 8,
};



pub static GETSCHEMATICSINSTANCE_SCHEMATICSINSTANCE_ENTITY__TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GetSchematicsInstance(SchematicsInstance,Entity)",
    name_hash: 1494489989,
    flags: MemberInfoFlags::new(793),
    module: "Entity",
    data: TypeInfoData::Unknown,
    array_type: None,
    alignment: 8,
};



pub static GETSCHEMATICSINSTANCE_SCHEMATICSINSTANCE_ENTITYBUS__TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GetSchematicsInstance(SchematicsInstance,EntityBus)",
    name_hash: 3219488353,
    flags: MemberInfoFlags::new(793),
    module: "Entity",
    data: TypeInfoData::Unknown,
    array_type: None,
    alignment: 8,
};



pub static DESTROYENTITY_ENTITY__TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DestroyEntity(Entity)",
    name_hash: 311302086,
    flags: MemberInfoFlags::new(793),
    module: "Entity",
    data: TypeInfoData::Unknown,
    array_type: None,
    alignment: 8,
};



pub static CREATEENTITY_ENTITY_ENTITYBUS_OBJECTBLUEPRINT_LINEARTRANSFORM__TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CreateEntity(Entity,EntityBus,ObjectBlueprint,LinearTransform)",
    name_hash: 2393638776,
    flags: MemberInfoFlags::new(793),
    module: "Entity",
    data: TypeInfoData::Unknown,
    array_type: None,
    alignment: 8,
};



pub static CASTTOSPATIAL_SPATIALENTITY_ENTITY__TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CastToSpatial(SpatialEntity,Entity)",
    name_hash: 4139245238,
    flags: MemberInfoFlags::new(793),
    module: "Entity",
    data: TypeInfoData::Unknown,
    array_type: None,
    alignment: 8,
};



pub static GETTRANSFORM_SPATIALENTITY_LINEARTRANSFORM__TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GetTransform(SpatialEntity,LinearTransform)",
    name_hash: 1614703274,
    flags: MemberInfoFlags::new(793),
    module: "Entity",
    data: TypeInfoData::Unknown,
    array_type: None,
    alignment: 8,
};



pub static SETTRANSFORM_SPATIALENTITY_LINEARTRANSFORM__TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SetTransform(SpatialEntity,LinearTransform)",
    name_hash: 54752446,
    flags: MemberInfoFlags::new(793),
    module: "Entity",
    data: TypeInfoData::Unknown,
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum UpdatePassMask {
    #[default]
    EmptyUpdateMask = 0,
    PrePhysicsUpdateMask = 1,
    PostPhysicsUpdateMask = 2,
    PreAnimationUpdateMask = 4,
    PostAnimationUpdateMask = 8,
    PostFrameUpdateMask = 16,
    UpdatePassMaskCount = 5,
}

pub static UPDATEPASSMASK_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UpdatePassMask",
    name_hash: 2149276401,
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(UPDATEPASSMASK_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for UpdatePassMask {
    fn type_info(&self) -> &'static TypeInfo {
        UPDATEPASSMASK_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static UPDATEPASSMASK_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UpdatePassMask-Array",
    name_hash: 3260857797,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("UpdatePassMask"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum UpdatePass {
    #[default]
    UpdatePass_PreSim = 0,
    UpdatePass_PostSim = 1,
    UpdatePass_PostFrame = 2,
    UpdatePass_PreInput = 3,
    UpdatePass_PreFrame = 4,
    UpdatePass_PreAnimation = 5,
    UpdatePass_PostAnimation = 6,
    UpdatePass_Count = 9,
}

pub static UPDATEPASS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UpdatePass",
    name_hash: 2270785669,
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(UPDATEPASS_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for UpdatePass {
    fn type_info(&self) -> &'static TypeInfo {
        UPDATEPASS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static UPDATEPASS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UpdatePass-Array",
    name_hash: 527759409,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("UpdatePass"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct GameDataContainerAsset {
    pub _glacier_base: super::core::Asset,
    pub data: Option<LockedTypeObject /* super::core::GameDataContainer */>,
}

pub trait GameDataContainerAssetTrait: super::core::AssetTrait {
    fn data(&self) -> &Option<LockedTypeObject /* super::core::GameDataContainer */>;
    fn data_mut(&mut self) -> &mut Option<LockedTypeObject /* super::core::GameDataContainer */>;
}

impl GameDataContainerAssetTrait for GameDataContainerAsset {
    fn data(&self) -> &Option<LockedTypeObject /* super::core::GameDataContainer */> {
        &self.data
    }
    fn data_mut(&mut self) -> &mut Option<LockedTypeObject /* super::core::GameDataContainer */> {
        &mut self.data
    }
}

impl super::core::AssetTrait for GameDataContainerAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for GameDataContainerAsset {
}

pub static GAMEDATACONTAINERASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameDataContainerAsset",
    name_hash: 3834009356,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        super_class_offset: offset_of!(GameDataContainerAsset, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GameDataContainerAsset as Default>::default())),
            create_boxed: || Box::new(<GameDataContainerAsset as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Data",
                name_hash: 2088730869,
                flags: MemberInfoFlags::new(0),
                field_type: "GameDataContainer",
                rust_offset: offset_of!(GameDataContainerAsset, data),
            },
        ],
    }),
    array_type: Some(GAMEDATACONTAINERASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for GameDataContainerAsset {
    fn type_info(&self) -> &'static TypeInfo {
        GAMEDATACONTAINERASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static GAMEDATACONTAINERASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameDataContainerAsset-Array",
    name_hash: 2215200568,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("GameDataContainerAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct DataContainerAsset {
    pub _glacier_base: super::core::Asset,
    pub data: Option<LockedTypeObject /* super::core::DataContainer */>,
}

pub trait DataContainerAssetTrait: super::core::AssetTrait {
    fn data(&self) -> &Option<LockedTypeObject /* super::core::DataContainer */>;
    fn data_mut(&mut self) -> &mut Option<LockedTypeObject /* super::core::DataContainer */>;
}

impl DataContainerAssetTrait for DataContainerAsset {
    fn data(&self) -> &Option<LockedTypeObject /* super::core::DataContainer */> {
        &self.data
    }
    fn data_mut(&mut self) -> &mut Option<LockedTypeObject /* super::core::DataContainer */> {
        &mut self.data
    }
}

impl super::core::AssetTrait for DataContainerAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for DataContainerAsset {
}

pub static DATACONTAINERASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DataContainerAsset",
    name_hash: 1590371042,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        super_class_offset: offset_of!(DataContainerAsset, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DataContainerAsset as Default>::default())),
            create_boxed: || Box::new(<DataContainerAsset as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Data",
                name_hash: 2088730869,
                flags: MemberInfoFlags::new(0),
                field_type: "DataContainer",
                rust_offset: offset_of!(DataContainerAsset, data),
            },
        ],
    }),
    array_type: Some(DATACONTAINERASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DataContainerAsset {
    fn type_info(&self) -> &'static TypeInfo {
        DATACONTAINERASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DATACONTAINERASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DataContainerAsset-Array",
    name_hash: 183529942,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("DataContainerAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct StaticInstancingData {
    pub transforms: Vec<BoxedTypeObject /* super::core::LinearTransform */>,
    pub mesh_ids: Vec<i32>,
}

pub trait StaticInstancingDataTrait: TypeObject {
    fn transforms(&self) -> &Vec<BoxedTypeObject /* super::core::LinearTransform */>;
    fn transforms_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::LinearTransform */>;
    fn mesh_ids(&self) -> &Vec<i32>;
    fn mesh_ids_mut(&mut self) -> &mut Vec<i32>;
}

impl StaticInstancingDataTrait for StaticInstancingData {
    fn transforms(&self) -> &Vec<BoxedTypeObject /* super::core::LinearTransform */> {
        &self.transforms
    }
    fn transforms_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::LinearTransform */> {
        &mut self.transforms
    }
    fn mesh_ids(&self) -> &Vec<i32> {
        &self.mesh_ids
    }
    fn mesh_ids_mut(&mut self) -> &mut Vec<i32> {
        &mut self.mesh_ids
    }
}

pub static STATICINSTANCINGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StaticInstancingData",
    name_hash: 2408684673,
    flags: MemberInfoFlags::new(73),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StaticInstancingData as Default>::default())),
            create_boxed: || Box::new(<StaticInstancingData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Transforms",
                name_hash: 1906106874,
                flags: MemberInfoFlags::new(144),
                field_type: "LinearTransform-Array",
                rust_offset: offset_of!(StaticInstancingData, transforms),
            },
            FieldInfoData {
                name: "MeshIds",
                name_hash: 1486894824,
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(StaticInstancingData, mesh_ids),
            },
        ],
    }),
    array_type: Some(STATICINSTANCINGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for StaticInstancingData {
    fn type_info(&self) -> &'static TypeInfo {
        STATICINSTANCINGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static STATICINSTANCINGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StaticInstancingData-Array",
    name_hash: 1390310965,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("StaticInstancingData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct PartData {
    pub _glacier_base: ComponentData,
    pub part_states: Vec<Option<LockedTypeObject /* PartState */>>,
}

pub trait PartDataTrait: ComponentDataTrait {
    fn part_states(&self) -> &Vec<Option<LockedTypeObject /* PartState */>>;
    fn part_states_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* PartState */>>;
}

impl PartDataTrait for PartData {
    fn part_states(&self) -> &Vec<Option<LockedTypeObject /* PartState */>> {
        &self.part_states
    }
    fn part_states_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* PartState */>> {
        &mut self.part_states
    }
}

impl ComponentDataTrait for PartData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl GameObjectDataTrait for PartData {
}

impl super::core::DataBusPeerTrait for PartData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PartData {
}

impl super::core::DataContainerTrait for PartData {
}

pub static PARTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PartData",
    name_hash: 3741217410,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(COMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(PartData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PartData as Default>::default())),
            create_boxed: || Box::new(<PartData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "PartStates",
                name_hash: 1836451638,
                flags: MemberInfoFlags::new(144),
                field_type: "PartState-Array",
                rust_offset: offset_of!(PartData, part_states),
            },
        ],
    }),
    array_type: Some(PARTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PartData {
    fn type_info(&self) -> &'static TypeInfo {
        PARTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PARTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PartData-Array",
    name_hash: 2415210934,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("PartData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct PartState {
    pub _glacier_base: GameObjectData,
    pub part_index: u32,
    pub objects: Vec<Option<LockedTypeObject /* GameObjectData */>>,
}

pub trait PartStateTrait: GameObjectDataTrait {
    fn part_index(&self) -> &u32;
    fn part_index_mut(&mut self) -> &mut u32;
    fn objects(&self) -> &Vec<Option<LockedTypeObject /* GameObjectData */>>;
    fn objects_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* GameObjectData */>>;
}

impl PartStateTrait for PartState {
    fn part_index(&self) -> &u32 {
        &self.part_index
    }
    fn part_index_mut(&mut self) -> &mut u32 {
        &mut self.part_index
    }
    fn objects(&self) -> &Vec<Option<LockedTypeObject /* GameObjectData */>> {
        &self.objects
    }
    fn objects_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* GameObjectData */>> {
        &mut self.objects
    }
}

impl GameObjectDataTrait for PartState {
}

impl super::core::DataBusPeerTrait for PartState {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PartState {
}

impl super::core::DataContainerTrait for PartState {
}

pub static PARTSTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PartState",
    name_hash: 3179262629,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(GAMEOBJECTDATA_TYPE_INFO),
        super_class_offset: offset_of!(PartState, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PartState as Default>::default())),
            create_boxed: || Box::new(<PartState as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "PartIndex",
                name_hash: 3213901068,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(PartState, part_index),
            },
            FieldInfoData {
                name: "Objects",
                name_hash: 105488131,
                flags: MemberInfoFlags::new(144),
                field_type: "GameObjectData-Array",
                rust_offset: offset_of!(PartState, objects),
            },
        ],
    }),
    array_type: Some(PARTSTATE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PartState {
    fn type_info(&self) -> &'static TypeInfo {
        PARTSTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PARTSTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PartState-Array",
    name_hash: 2305854225,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("PartState"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct BoneComponentData {
    pub _glacier_base: GameComponentData,
}

pub trait BoneComponentDataTrait: GameComponentDataTrait {
}

impl BoneComponentDataTrait for BoneComponentData {
}

impl GameComponentDataTrait for BoneComponentData {
}

impl ComponentDataTrait for BoneComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl GameObjectDataTrait for BoneComponentData {
}

impl super::core::DataBusPeerTrait for BoneComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for BoneComponentData {
}

impl super::core::DataContainerTrait for BoneComponentData {
}

pub static BONECOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoneComponentData",
    name_hash: 13531164,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(GAMECOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(BoneComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BoneComponentData as Default>::default())),
            create_boxed: || Box::new(<BoneComponentData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(BONECOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for BoneComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        BONECOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BONECOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoneComponentData-Array",
    name_hash: 3350786088,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("BoneComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct GameComponentData {
    pub _glacier_base: ComponentData,
}

pub trait GameComponentDataTrait: ComponentDataTrait {
}

impl GameComponentDataTrait for GameComponentData {
}

impl ComponentDataTrait for GameComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl GameObjectDataTrait for GameComponentData {
}

impl super::core::DataBusPeerTrait for GameComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for GameComponentData {
}

impl super::core::DataContainerTrait for GameComponentData {
}

pub static GAMECOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameComponentData",
    name_hash: 403720980,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(COMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(GameComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GameComponentData as Default>::default())),
            create_boxed: || Box::new(<GameComponentData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(GAMECOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for GameComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        GAMECOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static GAMECOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameComponentData-Array",
    name_hash: 2303567648,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("GameComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ComponentData {
    pub _glacier_base: GameObjectData,
    pub transform: super::core::LinearTransform,
    pub components: Vec<Option<LockedTypeObject /* GameObjectData */>>,
    pub client_index: u8,
    pub server_index: u8,
    pub excluded: bool,
}

pub trait ComponentDataTrait: GameObjectDataTrait {
    fn transform(&self) -> &super::core::LinearTransform;
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform;
    fn components(&self) -> &Vec<Option<LockedTypeObject /* GameObjectData */>>;
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* GameObjectData */>>;
    fn client_index(&self) -> &u8;
    fn client_index_mut(&mut self) -> &mut u8;
    fn server_index(&self) -> &u8;
    fn server_index_mut(&mut self) -> &mut u8;
    fn excluded(&self) -> &bool;
    fn excluded_mut(&mut self) -> &mut bool;
}

impl ComponentDataTrait for ComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        &self.transform
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.transform
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* GameObjectData */>> {
        &self.components
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* GameObjectData */>> {
        &mut self.components
    }
    fn client_index(&self) -> &u8 {
        &self.client_index
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        &mut self.client_index
    }
    fn server_index(&self) -> &u8 {
        &self.server_index
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        &mut self.server_index
    }
    fn excluded(&self) -> &bool {
        &self.excluded
    }
    fn excluded_mut(&mut self) -> &mut bool {
        &mut self.excluded
    }
}

impl GameObjectDataTrait for ComponentData {
}

impl super::core::DataBusPeerTrait for ComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ComponentData {
}

impl super::core::DataContainerTrait for ComponentData {
}

pub static COMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ComponentData",
    name_hash: 3070458298,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(GAMEOBJECTDATA_TYPE_INFO),
        super_class_offset: offset_of!(ComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ComponentData as Default>::default())),
            create_boxed: || Box::new(<ComponentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Transform",
                name_hash: 2270319721,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(ComponentData, transform),
            },
            FieldInfoData {
                name: "Components",
                name_hash: 3391050425,
                flags: MemberInfoFlags::new(144),
                field_type: "GameObjectData-Array",
                rust_offset: offset_of!(ComponentData, components),
            },
            FieldInfoData {
                name: "ClientIndex",
                name_hash: 3672183426,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(ComponentData, client_index),
            },
            FieldInfoData {
                name: "ServerIndex",
                name_hash: 3635956702,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(ComponentData, server_index),
            },
            FieldInfoData {
                name: "Excluded",
                name_hash: 755715367,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ComponentData, excluded),
            },
        ],
    }),
    array_type: Some(COMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        COMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ComponentData-Array",
    name_hash: 2493594638,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct GameComponentEntityData {
    pub _glacier_base: ComponentEntityData,
    pub enabled: bool,
}

pub trait GameComponentEntityDataTrait: ComponentEntityDataTrait {
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
}

impl GameComponentEntityDataTrait for GameComponentEntityData {
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
}

impl ComponentEntityDataTrait for GameComponentEntityData {
    fn components(&self) -> &Vec<Option<LockedTypeObject /* GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn part_bounding_boxes(&self) -> &Vec<BoxedTypeObject /* super::core::AxisAlignedBox */> {
        self._glacier_base.part_bounding_boxes()
    }
    fn part_bounding_boxes_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::AxisAlignedBox */> {
        self._glacier_base.part_bounding_boxes_mut()
    }
    fn client_runtime_component_count(&self) -> &u8 {
        self._glacier_base.client_runtime_component_count()
    }
    fn client_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_component_count_mut()
    }
    fn server_runtime_component_count(&self) -> &u8 {
        self._glacier_base.server_runtime_component_count()
    }
    fn server_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_component_count_mut()
    }
    fn client_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.client_runtime_transformation_count()
    }
    fn client_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_transformation_count_mut()
    }
    fn server_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.server_runtime_transformation_count()
    }
    fn server_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_transformation_count_mut()
    }
}

impl SpatialEntityDataTrait for GameComponentEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl EntityDataTrait for GameComponentEntityData {
}

impl GameObjectDataTrait for GameComponentEntityData {
}

impl super::core::DataBusPeerTrait for GameComponentEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for GameComponentEntityData {
}

impl super::core::DataContainerTrait for GameComponentEntityData {
}

pub static GAMECOMPONENTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameComponentEntityData",
    name_hash: 2608855439,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(COMPONENTENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(GameComponentEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GameComponentEntityData as Default>::default())),
            create_boxed: || Box::new(<GameComponentEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Enabled",
                name_hash: 2662400,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(GameComponentEntityData, enabled),
            },
        ],
    }),
    array_type: Some(GAMECOMPONENTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for GameComponentEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        GAMECOMPONENTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static GAMECOMPONENTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameComponentEntityData-Array",
    name_hash: 4283831867,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("GameComponentEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ComponentEntityData {
    pub _glacier_base: SpatialEntityData,
    pub components: Vec<Option<LockedTypeObject /* GameObjectData */>>,
    pub part_bounding_boxes: Vec<BoxedTypeObject /* super::core::AxisAlignedBox */>,
    pub client_runtime_component_count: u8,
    pub server_runtime_component_count: u8,
    pub client_runtime_transformation_count: u8,
    pub server_runtime_transformation_count: u8,
}

pub trait ComponentEntityDataTrait: SpatialEntityDataTrait {
    fn components(&self) -> &Vec<Option<LockedTypeObject /* GameObjectData */>>;
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* GameObjectData */>>;
    fn part_bounding_boxes(&self) -> &Vec<BoxedTypeObject /* super::core::AxisAlignedBox */>;
    fn part_bounding_boxes_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::AxisAlignedBox */>;
    fn client_runtime_component_count(&self) -> &u8;
    fn client_runtime_component_count_mut(&mut self) -> &mut u8;
    fn server_runtime_component_count(&self) -> &u8;
    fn server_runtime_component_count_mut(&mut self) -> &mut u8;
    fn client_runtime_transformation_count(&self) -> &u8;
    fn client_runtime_transformation_count_mut(&mut self) -> &mut u8;
    fn server_runtime_transformation_count(&self) -> &u8;
    fn server_runtime_transformation_count_mut(&mut self) -> &mut u8;
}

impl ComponentEntityDataTrait for ComponentEntityData {
    fn components(&self) -> &Vec<Option<LockedTypeObject /* GameObjectData */>> {
        &self.components
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* GameObjectData */>> {
        &mut self.components
    }
    fn part_bounding_boxes(&self) -> &Vec<BoxedTypeObject /* super::core::AxisAlignedBox */> {
        &self.part_bounding_boxes
    }
    fn part_bounding_boxes_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::AxisAlignedBox */> {
        &mut self.part_bounding_boxes
    }
    fn client_runtime_component_count(&self) -> &u8 {
        &self.client_runtime_component_count
    }
    fn client_runtime_component_count_mut(&mut self) -> &mut u8 {
        &mut self.client_runtime_component_count
    }
    fn server_runtime_component_count(&self) -> &u8 {
        &self.server_runtime_component_count
    }
    fn server_runtime_component_count_mut(&mut self) -> &mut u8 {
        &mut self.server_runtime_component_count
    }
    fn client_runtime_transformation_count(&self) -> &u8 {
        &self.client_runtime_transformation_count
    }
    fn client_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        &mut self.client_runtime_transformation_count
    }
    fn server_runtime_transformation_count(&self) -> &u8 {
        &self.server_runtime_transformation_count
    }
    fn server_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        &mut self.server_runtime_transformation_count
    }
}

impl SpatialEntityDataTrait for ComponentEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl EntityDataTrait for ComponentEntityData {
}

impl GameObjectDataTrait for ComponentEntityData {
}

impl super::core::DataBusPeerTrait for ComponentEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ComponentEntityData {
}

impl super::core::DataContainerTrait for ComponentEntityData {
}

pub static COMPONENTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ComponentEntityData",
    name_hash: 429047521,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SPATIALENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(ComponentEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ComponentEntityData as Default>::default())),
            create_boxed: || Box::new(<ComponentEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Components",
                name_hash: 3391050425,
                flags: MemberInfoFlags::new(144),
                field_type: "GameObjectData-Array",
                rust_offset: offset_of!(ComponentEntityData, components),
            },
            FieldInfoData {
                name: "PartBoundingBoxes",
                name_hash: 440640163,
                flags: MemberInfoFlags::new(144),
                field_type: "AxisAlignedBox-Array",
                rust_offset: offset_of!(ComponentEntityData, part_bounding_boxes),
            },
            FieldInfoData {
                name: "ClientRuntimeComponentCount",
                name_hash: 3486435084,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(ComponentEntityData, client_runtime_component_count),
            },
            FieldInfoData {
                name: "ServerRuntimeComponentCount",
                name_hash: 3516027216,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(ComponentEntityData, server_runtime_component_count),
            },
            FieldInfoData {
                name: "ClientRuntimeTransformationCount",
                name_hash: 1176130482,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(ComponentEntityData, client_runtime_transformation_count),
            },
            FieldInfoData {
                name: "ServerRuntimeTransformationCount",
                name_hash: 2987418094,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(ComponentEntityData, server_runtime_transformation_count),
            },
        ],
    }),
    array_type: Some(COMPONENTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ComponentEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        COMPONENTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COMPONENTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ComponentEntityData-Array",
    name_hash: 1228691925,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ComponentEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ScriptEntityData {
    pub _glacier_base: EntityData,
    pub code: String,
    pub realm: super::core::Realm,
}

pub trait ScriptEntityDataTrait: EntityDataTrait {
    fn code(&self) -> &String;
    fn code_mut(&mut self) -> &mut String;
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
}

impl ScriptEntityDataTrait for ScriptEntityData {
    fn code(&self) -> &String {
        &self.code
    }
    fn code_mut(&mut self) -> &mut String {
        &mut self.code
    }
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
}

impl EntityDataTrait for ScriptEntityData {
}

impl GameObjectDataTrait for ScriptEntityData {
}

impl super::core::DataBusPeerTrait for ScriptEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ScriptEntityData {
}

impl super::core::DataContainerTrait for ScriptEntityData {
}

pub static SCRIPTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScriptEntityData",
    name_hash: 3207095777,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(ScriptEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ScriptEntityData as Default>::default())),
            create_boxed: || Box::new(<ScriptEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Code",
                name_hash: 2088844616,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ScriptEntityData, code),
            },
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(ScriptEntityData, realm),
            },
        ],
    }),
    array_type: Some(SCRIPTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ScriptEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SCRIPTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SCRIPTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScriptEntityData-Array",
    name_hash: 1211318485,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ScriptEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SpatialEntityData {
    pub _glacier_base: EntityData,
    pub transform: super::core::LinearTransform,
}

pub trait SpatialEntityDataTrait: EntityDataTrait {
    fn transform(&self) -> &super::core::LinearTransform;
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform;
}

impl SpatialEntityDataTrait for SpatialEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        &self.transform
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.transform
    }
}

impl EntityDataTrait for SpatialEntityData {
}

impl GameObjectDataTrait for SpatialEntityData {
}

impl super::core::DataBusPeerTrait for SpatialEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SpatialEntityData {
}

impl super::core::DataContainerTrait for SpatialEntityData {
}

pub static SPATIALENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpatialEntityData",
    name_hash: 2775136508,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(SpatialEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SpatialEntityData as Default>::default())),
            create_boxed: || Box::new(<SpatialEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Transform",
                name_hash: 2270319721,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(SpatialEntityData, transform),
            },
        ],
    }),
    array_type: Some(SPATIALENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SpatialEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SPATIALENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SPATIALENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpatialEntityData-Array",
    name_hash: 1793892552,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SpatialEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct EntityData {
    pub _glacier_base: GameObjectData,
}

pub trait EntityDataTrait: GameObjectDataTrait {
}

impl EntityDataTrait for EntityData {
}

impl GameObjectDataTrait for EntityData {
}

impl super::core::DataBusPeerTrait for EntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for EntityData {
}

impl super::core::DataContainerTrait for EntityData {
}

pub static ENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityData",
    name_hash: 1697786030,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(GAMEOBJECTDATA_TYPE_INFO),
        super_class_offset: offset_of!(EntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EntityData as Default>::default())),
            create_boxed: || Box::new(<EntityData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(ENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EntityData {
    fn type_info(&self) -> &'static TypeInfo {
        ENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityData-Array",
    name_hash: 243536154,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum EntityCreatorType {
    #[default]
    EntityCreatorType_Unknown = 0,
    EntityCreatorType_Level = 1,
    EntityCreatorType_Spawner = 2,
    EntityCreatorType_Owner = 3,
    EntityCreatorType_Ghost = 4,
}

pub static ENTITYCREATORTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityCreatorType",
    name_hash: 2954916666,
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(ENTITYCREATORTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for EntityCreatorType {
    fn type_info(&self) -> &'static TypeInfo {
        ENTITYCREATORTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ENTITYCREATORTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityCreatorType-Array",
    name_hash: 3572716942,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EntityCreatorType"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct GameObjectData {
    pub _glacier_base: super::core::DataBusPeer,
}

pub trait GameObjectDataTrait: super::core::DataBusPeerTrait {
}

impl GameObjectDataTrait for GameObjectData {
}

impl super::core::DataBusPeerTrait for GameObjectData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for GameObjectData {
}

impl super::core::DataContainerTrait for GameObjectData {
}

pub static GAMEOBJECTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameObjectData",
    name_hash: 3354513198,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATABUSPEER_TYPE_INFO),
        super_class_offset: offset_of!(GameObjectData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GameObjectData as Default>::default())),
            create_boxed: || Box::new(<GameObjectData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(GAMEOBJECTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for GameObjectData {
    fn type_info(&self) -> &'static TypeInfo {
        GAMEOBJECTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static GAMEOBJECTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameObjectData-Array",
    name_hash: 84318106,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("GameObjectData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum SubRealm {
    #[default]
    SubRealm_All = 0,
    SubRealm_LocalPlayer = 1,
    SubRealm_RemotePlayer = 2,
}

pub static SUBREALM_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubRealm",
    name_hash: 1747841366,
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(SUBREALM_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SubRealm {
    fn type_info(&self) -> &'static TypeInfo {
        SUBREALM_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SUBREALM_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubRealm-Array",
    name_hash: 3759896290,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SubRealm"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum TimeShape {
    #[default]
    TimeShape_Step = 0,
    TimeShape_Sine = 1,
    TimeShape_SemiCircle = 2,
    TimeShape_Triangle = 3,
    TimeShape_Ramps = 4,
}

pub static TIMESHAPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TimeShape",
    name_hash: 169691295,
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(TIMESHAPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for TimeShape {
    fn type_info(&self) -> &'static TypeInfo {
        TIMESHAPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static TIMESHAPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TimeShape-Array",
    name_hash: 939879723,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TimeShape"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum DilationPriority {
    #[default]
    DilationPriority_Highest = 0,
    DilationPriority_High = 1,
    DilationPriority_Normal = 2,
    DilationPriority_Low = 3,
    DilationPriority_Lowest = 4,
}

pub static DILATIONPRIORITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DilationPriority",
    name_hash: 1767577547,
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(DILATIONPRIORITY_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for DilationPriority {
    fn type_info(&self) -> &'static TypeInfo {
        DILATIONPRIORITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static DILATIONPRIORITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DilationPriority-Array",
    name_hash: 3968792319,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("DilationPriority"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum TimeDeltaType {
    #[default]
    TimeDeltaType_None = 0,
    TimeDeltaType_Player = 1,
    TimeDeltaType_World = 2,
    TimeDeltaType_Extra1 = 3,
    TimeDeltaType_Extra2 = 4,
    TimeDeltaType_Extra3 = 5,
    TimeDeltaType_Extra4 = 6,
    TimeDeltaType_Extra5 = 7,
    TimeDeltaType_Count = 8,
}

pub static TIMEDELTATYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TimeDeltaType",
    name_hash: 1100516816,
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(TIMEDELTATYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for TimeDeltaType {
    fn type_info(&self) -> &'static TypeInfo {
        TIMEDELTATYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static TIMEDELTATYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TimeDeltaType-Array",
    name_hash: 3752938596,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TimeDeltaType"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SchematicChannelEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub channel: Option<LockedTypeObject /* SchematicChannelAsset */>,
    pub input_properties: Vec<i32>,
    pub input_ref_properties: Vec<i32>,
    pub output_properties: Vec<i32>,
    pub output_ref_properties: Vec<i32>,
}

pub trait SchematicChannelEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn channel(&self) -> &Option<LockedTypeObject /* SchematicChannelAsset */>;
    fn channel_mut(&mut self) -> &mut Option<LockedTypeObject /* SchematicChannelAsset */>;
    fn input_properties(&self) -> &Vec<i32>;
    fn input_properties_mut(&mut self) -> &mut Vec<i32>;
    fn input_ref_properties(&self) -> &Vec<i32>;
    fn input_ref_properties_mut(&mut self) -> &mut Vec<i32>;
    fn output_properties(&self) -> &Vec<i32>;
    fn output_properties_mut(&mut self) -> &mut Vec<i32>;
    fn output_ref_properties(&self) -> &Vec<i32>;
    fn output_ref_properties_mut(&mut self) -> &mut Vec<i32>;
}

impl SchematicChannelEntityDataTrait for SchematicChannelEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn channel(&self) -> &Option<LockedTypeObject /* SchematicChannelAsset */> {
        &self.channel
    }
    fn channel_mut(&mut self) -> &mut Option<LockedTypeObject /* SchematicChannelAsset */> {
        &mut self.channel
    }
    fn input_properties(&self) -> &Vec<i32> {
        &self.input_properties
    }
    fn input_properties_mut(&mut self) -> &mut Vec<i32> {
        &mut self.input_properties
    }
    fn input_ref_properties(&self) -> &Vec<i32> {
        &self.input_ref_properties
    }
    fn input_ref_properties_mut(&mut self) -> &mut Vec<i32> {
        &mut self.input_ref_properties
    }
    fn output_properties(&self) -> &Vec<i32> {
        &self.output_properties
    }
    fn output_properties_mut(&mut self) -> &mut Vec<i32> {
        &mut self.output_properties
    }
    fn output_ref_properties(&self) -> &Vec<i32> {
        &self.output_ref_properties
    }
    fn output_ref_properties_mut(&mut self) -> &mut Vec<i32> {
        &mut self.output_ref_properties
    }
}

impl EntityDataTrait for SchematicChannelEntityData {
}

impl GameObjectDataTrait for SchematicChannelEntityData {
}

impl super::core::DataBusPeerTrait for SchematicChannelEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SchematicChannelEntityData {
}

impl super::core::DataContainerTrait for SchematicChannelEntityData {
}

pub static SCHEMATICCHANNELENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SchematicChannelEntityData",
    name_hash: 2207306978,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(SchematicChannelEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SchematicChannelEntityData as Default>::default())),
            create_boxed: || Box::new(<SchematicChannelEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(SchematicChannelEntityData, realm),
            },
            FieldInfoData {
                name: "Channel",
                name_hash: 4082709062,
                flags: MemberInfoFlags::new(0),
                field_type: "SchematicChannelAsset",
                rust_offset: offset_of!(SchematicChannelEntityData, channel),
            },
            FieldInfoData {
                name: "InputProperties",
                name_hash: 883986194,
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(SchematicChannelEntityData, input_properties),
            },
            FieldInfoData {
                name: "InputRefProperties",
                name_hash: 3512215619,
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(SchematicChannelEntityData, input_ref_properties),
            },
            FieldInfoData {
                name: "OutputProperties",
                name_hash: 1376339771,
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(SchematicChannelEntityData, output_properties),
            },
            FieldInfoData {
                name: "OutputRefProperties",
                name_hash: 3421685194,
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(SchematicChannelEntityData, output_ref_properties),
            },
        ],
    }),
    array_type: Some(SCHEMATICCHANNELENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SchematicChannelEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SCHEMATICCHANNELENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SCHEMATICCHANNELENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SchematicChannelEntityData-Array",
    name_hash: 3987973078,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SchematicChannelEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SchematicChannelAsset {
    pub _glacier_base: super::core::Asset,
    pub events: Vec<BoxedTypeObject /* EventChannel */>,
    pub links: Vec<BoxedTypeObject /* LinkChannel */>,
    pub properties: Vec<BoxedTypeObject /* PropertyChannel */>,
}

pub trait SchematicChannelAssetTrait: super::core::AssetTrait {
    fn events(&self) -> &Vec<BoxedTypeObject /* EventChannel */>;
    fn events_mut(&mut self) -> &mut Vec<BoxedTypeObject /* EventChannel */>;
    fn links(&self) -> &Vec<BoxedTypeObject /* LinkChannel */>;
    fn links_mut(&mut self) -> &mut Vec<BoxedTypeObject /* LinkChannel */>;
    fn properties(&self) -> &Vec<BoxedTypeObject /* PropertyChannel */>;
    fn properties_mut(&mut self) -> &mut Vec<BoxedTypeObject /* PropertyChannel */>;
}

impl SchematicChannelAssetTrait for SchematicChannelAsset {
    fn events(&self) -> &Vec<BoxedTypeObject /* EventChannel */> {
        &self.events
    }
    fn events_mut(&mut self) -> &mut Vec<BoxedTypeObject /* EventChannel */> {
        &mut self.events
    }
    fn links(&self) -> &Vec<BoxedTypeObject /* LinkChannel */> {
        &self.links
    }
    fn links_mut(&mut self) -> &mut Vec<BoxedTypeObject /* LinkChannel */> {
        &mut self.links
    }
    fn properties(&self) -> &Vec<BoxedTypeObject /* PropertyChannel */> {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut Vec<BoxedTypeObject /* PropertyChannel */> {
        &mut self.properties
    }
}

impl super::core::AssetTrait for SchematicChannelAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for SchematicChannelAsset {
}

pub static SCHEMATICCHANNELASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SchematicChannelAsset",
    name_hash: 3831486521,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        super_class_offset: offset_of!(SchematicChannelAsset, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SchematicChannelAsset as Default>::default())),
            create_boxed: || Box::new(<SchematicChannelAsset as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Events",
                name_hash: 2352146554,
                flags: MemberInfoFlags::new(144),
                field_type: "EventChannel-Array",
                rust_offset: offset_of!(SchematicChannelAsset, events),
            },
            FieldInfoData {
                name: "Links",
                name_hash: 217830710,
                flags: MemberInfoFlags::new(144),
                field_type: "LinkChannel-Array",
                rust_offset: offset_of!(SchematicChannelAsset, links),
            },
            FieldInfoData {
                name: "Properties",
                name_hash: 1506334468,
                flags: MemberInfoFlags::new(144),
                field_type: "PropertyChannel-Array",
                rust_offset: offset_of!(SchematicChannelAsset, properties),
            },
        ],
    }),
    array_type: Some(SCHEMATICCHANNELASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SchematicChannelAsset {
    fn type_info(&self) -> &'static TypeInfo {
        SCHEMATICCHANNELASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SCHEMATICCHANNELASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SchematicChannelAsset-Array",
    name_hash: 4043916941,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SchematicChannelAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct PropertyChannel {
    pub realm: super::core::Realm,
    pub id: i32,
    pub field_type_hash: i32,
}

pub trait PropertyChannelTrait: TypeObject {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn id(&self) -> &i32;
    fn id_mut(&mut self) -> &mut i32;
    fn field_type_hash(&self) -> &i32;
    fn field_type_hash_mut(&mut self) -> &mut i32;
}

impl PropertyChannelTrait for PropertyChannel {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn id(&self) -> &i32 {
        &self.id
    }
    fn id_mut(&mut self) -> &mut i32 {
        &mut self.id
    }
    fn field_type_hash(&self) -> &i32 {
        &self.field_type_hash
    }
    fn field_type_hash_mut(&mut self) -> &mut i32 {
        &mut self.field_type_hash
    }
}

pub static PROPERTYCHANNEL_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PropertyChannel",
    name_hash: 613091393,
    flags: MemberInfoFlags::new(32841),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PropertyChannel as Default>::default())),
            create_boxed: || Box::new(<PropertyChannel as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(PropertyChannel, realm),
            },
            FieldInfoData {
                name: "Id",
                name_hash: 5862152,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(PropertyChannel, id),
            },
            FieldInfoData {
                name: "FieldTypeHash",
                name_hash: 2276905517,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(PropertyChannel, field_type_hash),
            },
        ],
    }),
    array_type: Some(PROPERTYCHANNEL_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for PropertyChannel {
    fn type_info(&self) -> &'static TypeInfo {
        PROPERTYCHANNEL_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static PROPERTYCHANNEL_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PropertyChannel-Array",
    name_hash: 1223012981,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("PropertyChannel"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct EventChannel {
    pub realm: super::core::Realm,
}

pub trait EventChannelTrait: TypeObject {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
}

impl EventChannelTrait for EventChannel {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
}

pub static EVENTCHANNEL_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventChannel",
    name_hash: 1086771370,
    flags: MemberInfoFlags::new(32841),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EventChannel as Default>::default())),
            create_boxed: || Box::new(<EventChannel as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(EventChannel, realm),
            },
        ],
    }),
    array_type: Some(EVENTCHANNEL_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for EventChannel {
    fn type_info(&self) -> &'static TypeInfo {
        EVENTCHANNEL_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static EVENTCHANNEL_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventChannel-Array",
    name_hash: 1605831454,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EventChannel"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct LinkChannel {
    pub realm: super::core::Realm,
    pub id: i32,
    pub link_type_hash: i32,
}

pub trait LinkChannelTrait: TypeObject {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn id(&self) -> &i32;
    fn id_mut(&mut self) -> &mut i32;
    fn link_type_hash(&self) -> &i32;
    fn link_type_hash_mut(&mut self) -> &mut i32;
}

impl LinkChannelTrait for LinkChannel {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn id(&self) -> &i32 {
        &self.id
    }
    fn id_mut(&mut self) -> &mut i32 {
        &mut self.id
    }
    fn link_type_hash(&self) -> &i32 {
        &self.link_type_hash
    }
    fn link_type_hash_mut(&mut self) -> &mut i32 {
        &mut self.link_type_hash
    }
}

pub static LINKCHANNEL_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkChannel",
    name_hash: 1622577254,
    flags: MemberInfoFlags::new(32841),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LinkChannel as Default>::default())),
            create_boxed: || Box::new(<LinkChannel as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(LinkChannel, realm),
            },
            FieldInfoData {
                name: "Id",
                name_hash: 5862152,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(LinkChannel, id),
            },
            FieldInfoData {
                name: "LinkTypeHash",
                name_hash: 2193082575,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(LinkChannel, link_type_hash),
            },
        ],
    }),
    array_type: Some(LINKCHANNEL_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for LinkChannel {
    fn type_info(&self) -> &'static TypeInfo {
        LINKCHANNEL_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static LINKCHANNEL_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkChannel-Array",
    name_hash: 3143085394,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("LinkChannel"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct LogicPrefabReferenceObjectData {
    pub _glacier_base: LogicReferenceObjectData,
}

pub trait LogicPrefabReferenceObjectDataTrait: LogicReferenceObjectDataTrait {
}

impl LogicPrefabReferenceObjectDataTrait for LogicPrefabReferenceObjectData {
}

impl LogicReferenceObjectDataTrait for LogicPrefabReferenceObjectData {
    fn local_player_id(&self) -> &super::core::LocalPlayerId {
        self._glacier_base.local_player_id()
    }
    fn local_player_id_mut(&mut self) -> &mut super::core::LocalPlayerId {
        self._glacier_base.local_player_id_mut()
    }
    fn sub_realm(&self) -> &SubRealm {
        self._glacier_base.sub_realm()
    }
    fn sub_realm_mut(&mut self) -> &mut SubRealm {
        self._glacier_base.sub_realm_mut()
    }
}

impl ReferenceObjectDataTrait for LogicPrefabReferenceObjectData {
    fn blueprint_transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.blueprint_transform()
    }
    fn blueprint_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.blueprint_transform_mut()
    }
    fn blueprint(&self) -> &Option<LockedTypeObject /* Blueprint */> {
        self._glacier_base.blueprint()
    }
    fn blueprint_mut(&mut self) -> &mut Option<LockedTypeObject /* Blueprint */> {
        self._glacier_base.blueprint_mut()
    }
    fn object_variation(&self) -> &Option<LockedTypeObject /* ObjectVariation */> {
        self._glacier_base.object_variation()
    }
    fn object_variation_mut(&mut self) -> &mut Option<LockedTypeObject /* ObjectVariation */> {
        self._glacier_base.object_variation_mut()
    }
    fn stream_realm(&self) -> &StreamRealm {
        self._glacier_base.stream_realm()
    }
    fn stream_realm_mut(&mut self) -> &mut StreamRealm {
        self._glacier_base.stream_realm_mut()
    }
    fn radiosity_type_override(&self) -> &super::core::RadiosityTypeOverride {
        self._glacier_base.radiosity_type_override()
    }
    fn radiosity_type_override_mut(&mut self) -> &mut super::core::RadiosityTypeOverride {
        self._glacier_base.radiosity_type_override_mut()
    }
    fn lightmap_resolution_scale(&self) -> &u32 {
        self._glacier_base.lightmap_resolution_scale()
    }
    fn lightmap_resolution_scale_mut(&mut self) -> &mut u32 {
        self._glacier_base.lightmap_resolution_scale_mut()
    }
    fn lightmap_scale_with_size(&self) -> &bool {
        self._glacier_base.lightmap_scale_with_size()
    }
    fn lightmap_scale_with_size_mut(&mut self) -> &mut bool {
        self._glacier_base.lightmap_scale_with_size_mut()
    }
    fn rendering_overrides(&self) -> &super::core::RenderingOverrides {
        self._glacier_base.rendering_overrides()
    }
    fn rendering_overrides_mut(&mut self) -> &mut super::core::RenderingOverrides {
        self._glacier_base.rendering_overrides_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
    fn create_indestructible_entity(&self) -> &bool {
        self._glacier_base.create_indestructible_entity()
    }
    fn create_indestructible_entity_mut(&mut self) -> &mut bool {
        self._glacier_base.create_indestructible_entity_mut()
    }
}

impl GameObjectDataTrait for LogicPrefabReferenceObjectData {
}

impl super::core::DataBusPeerTrait for LogicPrefabReferenceObjectData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for LogicPrefabReferenceObjectData {
}

impl super::core::DataContainerTrait for LogicPrefabReferenceObjectData {
}

pub static LOGICPREFABREFERENCEOBJECTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LogicPrefabReferenceObjectData",
    name_hash: 2525712103,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(LOGICREFERENCEOBJECTDATA_TYPE_INFO),
        super_class_offset: offset_of!(LogicPrefabReferenceObjectData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LogicPrefabReferenceObjectData as Default>::default())),
            create_boxed: || Box::new(<LogicPrefabReferenceObjectData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(LOGICPREFABREFERENCEOBJECTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for LogicPrefabReferenceObjectData {
    fn type_info(&self) -> &'static TypeInfo {
        LOGICPREFABREFERENCEOBJECTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LOGICPREFABREFERENCEOBJECTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LogicPrefabReferenceObjectData-Array",
    name_hash: 491573459,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("LogicPrefabReferenceObjectData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SpatialPrefabReferenceObjectData {
    pub _glacier_base: SpatialReferenceObjectData,
    pub persistence_setting: BlueprintPersistenceSetting,
}

pub trait SpatialPrefabReferenceObjectDataTrait: SpatialReferenceObjectDataTrait {
    fn persistence_setting(&self) -> &BlueprintPersistenceSetting;
    fn persistence_setting_mut(&mut self) -> &mut BlueprintPersistenceSetting;
}

impl SpatialPrefabReferenceObjectDataTrait for SpatialPrefabReferenceObjectData {
    fn persistence_setting(&self) -> &BlueprintPersistenceSetting {
        &self.persistence_setting
    }
    fn persistence_setting_mut(&mut self) -> &mut BlueprintPersistenceSetting {
        &mut self.persistence_setting
    }
}

impl SpatialReferenceObjectDataTrait for SpatialPrefabReferenceObjectData {
    fn local_player_id(&self) -> &super::core::LocalPlayerId {
        self._glacier_base.local_player_id()
    }
    fn local_player_id_mut(&mut self) -> &mut super::core::LocalPlayerId {
        self._glacier_base.local_player_id_mut()
    }
}

impl ReferenceObjectDataTrait for SpatialPrefabReferenceObjectData {
    fn blueprint_transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.blueprint_transform()
    }
    fn blueprint_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.blueprint_transform_mut()
    }
    fn blueprint(&self) -> &Option<LockedTypeObject /* Blueprint */> {
        self._glacier_base.blueprint()
    }
    fn blueprint_mut(&mut self) -> &mut Option<LockedTypeObject /* Blueprint */> {
        self._glacier_base.blueprint_mut()
    }
    fn object_variation(&self) -> &Option<LockedTypeObject /* ObjectVariation */> {
        self._glacier_base.object_variation()
    }
    fn object_variation_mut(&mut self) -> &mut Option<LockedTypeObject /* ObjectVariation */> {
        self._glacier_base.object_variation_mut()
    }
    fn stream_realm(&self) -> &StreamRealm {
        self._glacier_base.stream_realm()
    }
    fn stream_realm_mut(&mut self) -> &mut StreamRealm {
        self._glacier_base.stream_realm_mut()
    }
    fn radiosity_type_override(&self) -> &super::core::RadiosityTypeOverride {
        self._glacier_base.radiosity_type_override()
    }
    fn radiosity_type_override_mut(&mut self) -> &mut super::core::RadiosityTypeOverride {
        self._glacier_base.radiosity_type_override_mut()
    }
    fn lightmap_resolution_scale(&self) -> &u32 {
        self._glacier_base.lightmap_resolution_scale()
    }
    fn lightmap_resolution_scale_mut(&mut self) -> &mut u32 {
        self._glacier_base.lightmap_resolution_scale_mut()
    }
    fn lightmap_scale_with_size(&self) -> &bool {
        self._glacier_base.lightmap_scale_with_size()
    }
    fn lightmap_scale_with_size_mut(&mut self) -> &mut bool {
        self._glacier_base.lightmap_scale_with_size_mut()
    }
    fn rendering_overrides(&self) -> &super::core::RenderingOverrides {
        self._glacier_base.rendering_overrides()
    }
    fn rendering_overrides_mut(&mut self) -> &mut super::core::RenderingOverrides {
        self._glacier_base.rendering_overrides_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
    fn create_indestructible_entity(&self) -> &bool {
        self._glacier_base.create_indestructible_entity()
    }
    fn create_indestructible_entity_mut(&mut self) -> &mut bool {
        self._glacier_base.create_indestructible_entity_mut()
    }
}

impl GameObjectDataTrait for SpatialPrefabReferenceObjectData {
}

impl super::core::DataBusPeerTrait for SpatialPrefabReferenceObjectData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SpatialPrefabReferenceObjectData {
}

impl super::core::DataContainerTrait for SpatialPrefabReferenceObjectData {
}

pub static SPATIALPREFABREFERENCEOBJECTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpatialPrefabReferenceObjectData",
    name_hash: 3577490203,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SPATIALREFERENCEOBJECTDATA_TYPE_INFO),
        super_class_offset: offset_of!(SpatialPrefabReferenceObjectData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SpatialPrefabReferenceObjectData as Default>::default())),
            create_boxed: || Box::new(<SpatialPrefabReferenceObjectData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "PersistenceSetting",
                name_hash: 3641697508,
                flags: MemberInfoFlags::new(0),
                field_type: "BlueprintPersistenceSetting",
                rust_offset: offset_of!(SpatialPrefabReferenceObjectData, persistence_setting),
            },
        ],
    }),
    array_type: Some(SPATIALPREFABREFERENCEOBJECTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SpatialPrefabReferenceObjectData {
    fn type_info(&self) -> &'static TypeInfo {
        SPATIALPREFABREFERENCEOBJECTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SPATIALPREFABREFERENCEOBJECTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpatialPrefabReferenceObjectData-Array",
    name_hash: 2804187567,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SpatialPrefabReferenceObjectData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ObjectReferenceObjectData {
    pub _glacier_base: SpatialReferenceObjectData,
}

pub trait ObjectReferenceObjectDataTrait: SpatialReferenceObjectDataTrait {
}

impl ObjectReferenceObjectDataTrait for ObjectReferenceObjectData {
}

impl SpatialReferenceObjectDataTrait for ObjectReferenceObjectData {
    fn local_player_id(&self) -> &super::core::LocalPlayerId {
        self._glacier_base.local_player_id()
    }
    fn local_player_id_mut(&mut self) -> &mut super::core::LocalPlayerId {
        self._glacier_base.local_player_id_mut()
    }
}

impl ReferenceObjectDataTrait for ObjectReferenceObjectData {
    fn blueprint_transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.blueprint_transform()
    }
    fn blueprint_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.blueprint_transform_mut()
    }
    fn blueprint(&self) -> &Option<LockedTypeObject /* Blueprint */> {
        self._glacier_base.blueprint()
    }
    fn blueprint_mut(&mut self) -> &mut Option<LockedTypeObject /* Blueprint */> {
        self._glacier_base.blueprint_mut()
    }
    fn object_variation(&self) -> &Option<LockedTypeObject /* ObjectVariation */> {
        self._glacier_base.object_variation()
    }
    fn object_variation_mut(&mut self) -> &mut Option<LockedTypeObject /* ObjectVariation */> {
        self._glacier_base.object_variation_mut()
    }
    fn stream_realm(&self) -> &StreamRealm {
        self._glacier_base.stream_realm()
    }
    fn stream_realm_mut(&mut self) -> &mut StreamRealm {
        self._glacier_base.stream_realm_mut()
    }
    fn radiosity_type_override(&self) -> &super::core::RadiosityTypeOverride {
        self._glacier_base.radiosity_type_override()
    }
    fn radiosity_type_override_mut(&mut self) -> &mut super::core::RadiosityTypeOverride {
        self._glacier_base.radiosity_type_override_mut()
    }
    fn lightmap_resolution_scale(&self) -> &u32 {
        self._glacier_base.lightmap_resolution_scale()
    }
    fn lightmap_resolution_scale_mut(&mut self) -> &mut u32 {
        self._glacier_base.lightmap_resolution_scale_mut()
    }
    fn lightmap_scale_with_size(&self) -> &bool {
        self._glacier_base.lightmap_scale_with_size()
    }
    fn lightmap_scale_with_size_mut(&mut self) -> &mut bool {
        self._glacier_base.lightmap_scale_with_size_mut()
    }
    fn rendering_overrides(&self) -> &super::core::RenderingOverrides {
        self._glacier_base.rendering_overrides()
    }
    fn rendering_overrides_mut(&mut self) -> &mut super::core::RenderingOverrides {
        self._glacier_base.rendering_overrides_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
    fn create_indestructible_entity(&self) -> &bool {
        self._glacier_base.create_indestructible_entity()
    }
    fn create_indestructible_entity_mut(&mut self) -> &mut bool {
        self._glacier_base.create_indestructible_entity_mut()
    }
}

impl GameObjectDataTrait for ObjectReferenceObjectData {
}

impl super::core::DataBusPeerTrait for ObjectReferenceObjectData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ObjectReferenceObjectData {
}

impl super::core::DataContainerTrait for ObjectReferenceObjectData {
}

pub static OBJECTREFERENCEOBJECTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectReferenceObjectData",
    name_hash: 1278256830,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SPATIALREFERENCEOBJECTDATA_TYPE_INFO),
        super_class_offset: offset_of!(ObjectReferenceObjectData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ObjectReferenceObjectData as Default>::default())),
            create_boxed: || Box::new(<ObjectReferenceObjectData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(OBJECTREFERENCEOBJECTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ObjectReferenceObjectData {
    fn type_info(&self) -> &'static TypeInfo {
        OBJECTREFERENCEOBJECTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static OBJECTREFERENCEOBJECTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectReferenceObjectData-Array",
    name_hash: 3044792074,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ObjectReferenceObjectData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct LogicReferenceObjectData {
    pub _glacier_base: ReferenceObjectData,
    pub local_player_id: super::core::LocalPlayerId,
    pub sub_realm: SubRealm,
}

pub trait LogicReferenceObjectDataTrait: ReferenceObjectDataTrait {
    fn local_player_id(&self) -> &super::core::LocalPlayerId;
    fn local_player_id_mut(&mut self) -> &mut super::core::LocalPlayerId;
    fn sub_realm(&self) -> &SubRealm;
    fn sub_realm_mut(&mut self) -> &mut SubRealm;
}

impl LogicReferenceObjectDataTrait for LogicReferenceObjectData {
    fn local_player_id(&self) -> &super::core::LocalPlayerId {
        &self.local_player_id
    }
    fn local_player_id_mut(&mut self) -> &mut super::core::LocalPlayerId {
        &mut self.local_player_id
    }
    fn sub_realm(&self) -> &SubRealm {
        &self.sub_realm
    }
    fn sub_realm_mut(&mut self) -> &mut SubRealm {
        &mut self.sub_realm
    }
}

impl ReferenceObjectDataTrait for LogicReferenceObjectData {
    fn blueprint_transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.blueprint_transform()
    }
    fn blueprint_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.blueprint_transform_mut()
    }
    fn blueprint(&self) -> &Option<LockedTypeObject /* Blueprint */> {
        self._glacier_base.blueprint()
    }
    fn blueprint_mut(&mut self) -> &mut Option<LockedTypeObject /* Blueprint */> {
        self._glacier_base.blueprint_mut()
    }
    fn object_variation(&self) -> &Option<LockedTypeObject /* ObjectVariation */> {
        self._glacier_base.object_variation()
    }
    fn object_variation_mut(&mut self) -> &mut Option<LockedTypeObject /* ObjectVariation */> {
        self._glacier_base.object_variation_mut()
    }
    fn stream_realm(&self) -> &StreamRealm {
        self._glacier_base.stream_realm()
    }
    fn stream_realm_mut(&mut self) -> &mut StreamRealm {
        self._glacier_base.stream_realm_mut()
    }
    fn radiosity_type_override(&self) -> &super::core::RadiosityTypeOverride {
        self._glacier_base.radiosity_type_override()
    }
    fn radiosity_type_override_mut(&mut self) -> &mut super::core::RadiosityTypeOverride {
        self._glacier_base.radiosity_type_override_mut()
    }
    fn lightmap_resolution_scale(&self) -> &u32 {
        self._glacier_base.lightmap_resolution_scale()
    }
    fn lightmap_resolution_scale_mut(&mut self) -> &mut u32 {
        self._glacier_base.lightmap_resolution_scale_mut()
    }
    fn lightmap_scale_with_size(&self) -> &bool {
        self._glacier_base.lightmap_scale_with_size()
    }
    fn lightmap_scale_with_size_mut(&mut self) -> &mut bool {
        self._glacier_base.lightmap_scale_with_size_mut()
    }
    fn rendering_overrides(&self) -> &super::core::RenderingOverrides {
        self._glacier_base.rendering_overrides()
    }
    fn rendering_overrides_mut(&mut self) -> &mut super::core::RenderingOverrides {
        self._glacier_base.rendering_overrides_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
    fn create_indestructible_entity(&self) -> &bool {
        self._glacier_base.create_indestructible_entity()
    }
    fn create_indestructible_entity_mut(&mut self) -> &mut bool {
        self._glacier_base.create_indestructible_entity_mut()
    }
}

impl GameObjectDataTrait for LogicReferenceObjectData {
}

impl super::core::DataBusPeerTrait for LogicReferenceObjectData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for LogicReferenceObjectData {
}

impl super::core::DataContainerTrait for LogicReferenceObjectData {
}

pub static LOGICREFERENCEOBJECTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LogicReferenceObjectData",
    name_hash: 1046548357,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(REFERENCEOBJECTDATA_TYPE_INFO),
        super_class_offset: offset_of!(LogicReferenceObjectData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LogicReferenceObjectData as Default>::default())),
            create_boxed: || Box::new(<LogicReferenceObjectData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "LocalPlayerId",
                name_hash: 1029133718,
                flags: MemberInfoFlags::new(0),
                field_type: "LocalPlayerId",
                rust_offset: offset_of!(LogicReferenceObjectData, local_player_id),
            },
            FieldInfoData {
                name: "SubRealm",
                name_hash: 1747841366,
                flags: MemberInfoFlags::new(0),
                field_type: "SubRealm",
                rust_offset: offset_of!(LogicReferenceObjectData, sub_realm),
            },
        ],
    }),
    array_type: Some(LOGICREFERENCEOBJECTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for LogicReferenceObjectData {
    fn type_info(&self) -> &'static TypeInfo {
        LOGICREFERENCEOBJECTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LOGICREFERENCEOBJECTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LogicReferenceObjectData-Array",
    name_hash: 729274161,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("LogicReferenceObjectData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SpatialReferenceObjectData {
    pub _glacier_base: ReferenceObjectData,
    pub local_player_id: super::core::LocalPlayerId,
}

pub trait SpatialReferenceObjectDataTrait: ReferenceObjectDataTrait {
    fn local_player_id(&self) -> &super::core::LocalPlayerId;
    fn local_player_id_mut(&mut self) -> &mut super::core::LocalPlayerId;
}

impl SpatialReferenceObjectDataTrait for SpatialReferenceObjectData {
    fn local_player_id(&self) -> &super::core::LocalPlayerId {
        &self.local_player_id
    }
    fn local_player_id_mut(&mut self) -> &mut super::core::LocalPlayerId {
        &mut self.local_player_id
    }
}

impl ReferenceObjectDataTrait for SpatialReferenceObjectData {
    fn blueprint_transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.blueprint_transform()
    }
    fn blueprint_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.blueprint_transform_mut()
    }
    fn blueprint(&self) -> &Option<LockedTypeObject /* Blueprint */> {
        self._glacier_base.blueprint()
    }
    fn blueprint_mut(&mut self) -> &mut Option<LockedTypeObject /* Blueprint */> {
        self._glacier_base.blueprint_mut()
    }
    fn object_variation(&self) -> &Option<LockedTypeObject /* ObjectVariation */> {
        self._glacier_base.object_variation()
    }
    fn object_variation_mut(&mut self) -> &mut Option<LockedTypeObject /* ObjectVariation */> {
        self._glacier_base.object_variation_mut()
    }
    fn stream_realm(&self) -> &StreamRealm {
        self._glacier_base.stream_realm()
    }
    fn stream_realm_mut(&mut self) -> &mut StreamRealm {
        self._glacier_base.stream_realm_mut()
    }
    fn radiosity_type_override(&self) -> &super::core::RadiosityTypeOverride {
        self._glacier_base.radiosity_type_override()
    }
    fn radiosity_type_override_mut(&mut self) -> &mut super::core::RadiosityTypeOverride {
        self._glacier_base.radiosity_type_override_mut()
    }
    fn lightmap_resolution_scale(&self) -> &u32 {
        self._glacier_base.lightmap_resolution_scale()
    }
    fn lightmap_resolution_scale_mut(&mut self) -> &mut u32 {
        self._glacier_base.lightmap_resolution_scale_mut()
    }
    fn lightmap_scale_with_size(&self) -> &bool {
        self._glacier_base.lightmap_scale_with_size()
    }
    fn lightmap_scale_with_size_mut(&mut self) -> &mut bool {
        self._glacier_base.lightmap_scale_with_size_mut()
    }
    fn rendering_overrides(&self) -> &super::core::RenderingOverrides {
        self._glacier_base.rendering_overrides()
    }
    fn rendering_overrides_mut(&mut self) -> &mut super::core::RenderingOverrides {
        self._glacier_base.rendering_overrides_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
    fn create_indestructible_entity(&self) -> &bool {
        self._glacier_base.create_indestructible_entity()
    }
    fn create_indestructible_entity_mut(&mut self) -> &mut bool {
        self._glacier_base.create_indestructible_entity_mut()
    }
}

impl GameObjectDataTrait for SpatialReferenceObjectData {
}

impl super::core::DataBusPeerTrait for SpatialReferenceObjectData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SpatialReferenceObjectData {
}

impl super::core::DataContainerTrait for SpatialReferenceObjectData {
}

pub static SPATIALREFERENCEOBJECTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpatialReferenceObjectData",
    name_hash: 2733579001,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(REFERENCEOBJECTDATA_TYPE_INFO),
        super_class_offset: offset_of!(SpatialReferenceObjectData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SpatialReferenceObjectData as Default>::default())),
            create_boxed: || Box::new(<SpatialReferenceObjectData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "LocalPlayerId",
                name_hash: 1029133718,
                flags: MemberInfoFlags::new(0),
                field_type: "LocalPlayerId",
                rust_offset: offset_of!(SpatialReferenceObjectData, local_player_id),
            },
        ],
    }),
    array_type: Some(SPATIALREFERENCEOBJECTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SpatialReferenceObjectData {
    fn type_info(&self) -> &'static TypeInfo {
        SPATIALREFERENCEOBJECTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SPATIALREFERENCEOBJECTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpatialReferenceObjectData-Array",
    name_hash: 1736432077,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SpatialReferenceObjectData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ReferenceObjectData {
    pub _glacier_base: GameObjectData,
    pub blueprint_transform: super::core::LinearTransform,
    pub blueprint: Option<LockedTypeObject /* Blueprint */>,
    pub object_variation: Option<LockedTypeObject /* ObjectVariation */>,
    pub stream_realm: StreamRealm,
    pub radiosity_type_override: super::core::RadiosityTypeOverride,
    pub lightmap_resolution_scale: u32,
    pub lightmap_scale_with_size: bool,
    pub rendering_overrides: super::core::RenderingOverrides,
    pub excluded: bool,
    pub create_indestructible_entity: bool,
}

pub trait ReferenceObjectDataTrait: GameObjectDataTrait {
    fn blueprint_transform(&self) -> &super::core::LinearTransform;
    fn blueprint_transform_mut(&mut self) -> &mut super::core::LinearTransform;
    fn blueprint(&self) -> &Option<LockedTypeObject /* Blueprint */>;
    fn blueprint_mut(&mut self) -> &mut Option<LockedTypeObject /* Blueprint */>;
    fn object_variation(&self) -> &Option<LockedTypeObject /* ObjectVariation */>;
    fn object_variation_mut(&mut self) -> &mut Option<LockedTypeObject /* ObjectVariation */>;
    fn stream_realm(&self) -> &StreamRealm;
    fn stream_realm_mut(&mut self) -> &mut StreamRealm;
    fn radiosity_type_override(&self) -> &super::core::RadiosityTypeOverride;
    fn radiosity_type_override_mut(&mut self) -> &mut super::core::RadiosityTypeOverride;
    fn lightmap_resolution_scale(&self) -> &u32;
    fn lightmap_resolution_scale_mut(&mut self) -> &mut u32;
    fn lightmap_scale_with_size(&self) -> &bool;
    fn lightmap_scale_with_size_mut(&mut self) -> &mut bool;
    fn rendering_overrides(&self) -> &super::core::RenderingOverrides;
    fn rendering_overrides_mut(&mut self) -> &mut super::core::RenderingOverrides;
    fn excluded(&self) -> &bool;
    fn excluded_mut(&mut self) -> &mut bool;
    fn create_indestructible_entity(&self) -> &bool;
    fn create_indestructible_entity_mut(&mut self) -> &mut bool;
}

impl ReferenceObjectDataTrait for ReferenceObjectData {
    fn blueprint_transform(&self) -> &super::core::LinearTransform {
        &self.blueprint_transform
    }
    fn blueprint_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.blueprint_transform
    }
    fn blueprint(&self) -> &Option<LockedTypeObject /* Blueprint */> {
        &self.blueprint
    }
    fn blueprint_mut(&mut self) -> &mut Option<LockedTypeObject /* Blueprint */> {
        &mut self.blueprint
    }
    fn object_variation(&self) -> &Option<LockedTypeObject /* ObjectVariation */> {
        &self.object_variation
    }
    fn object_variation_mut(&mut self) -> &mut Option<LockedTypeObject /* ObjectVariation */> {
        &mut self.object_variation
    }
    fn stream_realm(&self) -> &StreamRealm {
        &self.stream_realm
    }
    fn stream_realm_mut(&mut self) -> &mut StreamRealm {
        &mut self.stream_realm
    }
    fn radiosity_type_override(&self) -> &super::core::RadiosityTypeOverride {
        &self.radiosity_type_override
    }
    fn radiosity_type_override_mut(&mut self) -> &mut super::core::RadiosityTypeOverride {
        &mut self.radiosity_type_override
    }
    fn lightmap_resolution_scale(&self) -> &u32 {
        &self.lightmap_resolution_scale
    }
    fn lightmap_resolution_scale_mut(&mut self) -> &mut u32 {
        &mut self.lightmap_resolution_scale
    }
    fn lightmap_scale_with_size(&self) -> &bool {
        &self.lightmap_scale_with_size
    }
    fn lightmap_scale_with_size_mut(&mut self) -> &mut bool {
        &mut self.lightmap_scale_with_size
    }
    fn rendering_overrides(&self) -> &super::core::RenderingOverrides {
        &self.rendering_overrides
    }
    fn rendering_overrides_mut(&mut self) -> &mut super::core::RenderingOverrides {
        &mut self.rendering_overrides
    }
    fn excluded(&self) -> &bool {
        &self.excluded
    }
    fn excluded_mut(&mut self) -> &mut bool {
        &mut self.excluded
    }
    fn create_indestructible_entity(&self) -> &bool {
        &self.create_indestructible_entity
    }
    fn create_indestructible_entity_mut(&mut self) -> &mut bool {
        &mut self.create_indestructible_entity
    }
}

impl GameObjectDataTrait for ReferenceObjectData {
}

impl super::core::DataBusPeerTrait for ReferenceObjectData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ReferenceObjectData {
}

impl super::core::DataContainerTrait for ReferenceObjectData {
}

pub static REFERENCEOBJECTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReferenceObjectData",
    name_hash: 1647409771,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(GAMEOBJECTDATA_TYPE_INFO),
        super_class_offset: offset_of!(ReferenceObjectData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ReferenceObjectData as Default>::default())),
            create_boxed: || Box::new(<ReferenceObjectData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "BlueprintTransform",
                name_hash: 3885036614,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(ReferenceObjectData, blueprint_transform),
            },
            FieldInfoData {
                name: "Blueprint",
                name_hash: 4232469066,
                flags: MemberInfoFlags::new(0),
                field_type: "Blueprint",
                rust_offset: offset_of!(ReferenceObjectData, blueprint),
            },
            FieldInfoData {
                name: "ObjectVariation",
                name_hash: 3624336577,
                flags: MemberInfoFlags::new(0),
                field_type: "ObjectVariation",
                rust_offset: offset_of!(ReferenceObjectData, object_variation),
            },
            FieldInfoData {
                name: "StreamRealm",
                name_hash: 1844114478,
                flags: MemberInfoFlags::new(0),
                field_type: "StreamRealm",
                rust_offset: offset_of!(ReferenceObjectData, stream_realm),
            },
            FieldInfoData {
                name: "RadiosityTypeOverride",
                name_hash: 1603143183,
                flags: MemberInfoFlags::new(0),
                field_type: "RadiosityTypeOverride",
                rust_offset: offset_of!(ReferenceObjectData, radiosity_type_override),
            },
            FieldInfoData {
                name: "LightmapResolutionScale",
                name_hash: 3283963665,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(ReferenceObjectData, lightmap_resolution_scale),
            },
            FieldInfoData {
                name: "LightmapScaleWithSize",
                name_hash: 3783970680,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ReferenceObjectData, lightmap_scale_with_size),
            },
            FieldInfoData {
                name: "RenderingOverrides",
                name_hash: 4053255464,
                flags: MemberInfoFlags::new(0),
                field_type: "RenderingOverrides",
                rust_offset: offset_of!(ReferenceObjectData, rendering_overrides),
            },
            FieldInfoData {
                name: "Excluded",
                name_hash: 755715367,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ReferenceObjectData, excluded),
            },
            FieldInfoData {
                name: "CreateIndestructibleEntity",
                name_hash: 3455809225,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ReferenceObjectData, create_indestructible_entity),
            },
        ],
    }),
    array_type: Some(REFERENCEOBJECTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ReferenceObjectData {
    fn type_info(&self) -> &'static TypeInfo {
        REFERENCEOBJECTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static REFERENCEOBJECTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReferenceObjectData-Array",
    name_hash: 872761951,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ReferenceObjectData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum StreamRealm {
    #[default]
    StreamRealm_None = 0,
    StreamRealm_Client = 1,
    StreamRealm_Both = 2,
}

pub static STREAMREALM_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StreamRealm",
    name_hash: 1844114478,
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(STREAMREALM_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for StreamRealm {
    fn type_info(&self) -> &'static TypeInfo {
        STREAMREALM_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static STREAMREALM_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StreamRealm-Array",
    name_hash: 2894560410,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("StreamRealm"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ObjectVariationCollection {
    pub _glacier_base: super::core::DataContainer,
    pub variations: Vec<Option<LockedTypeObject /* ObjectVariation */>>,
}

pub trait ObjectVariationCollectionTrait: super::core::DataContainerTrait {
    fn variations(&self) -> &Vec<Option<LockedTypeObject /* ObjectVariation */>>;
    fn variations_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* ObjectVariation */>>;
}

impl ObjectVariationCollectionTrait for ObjectVariationCollection {
    fn variations(&self) -> &Vec<Option<LockedTypeObject /* ObjectVariation */>> {
        &self.variations
    }
    fn variations_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* ObjectVariation */>> {
        &mut self.variations
    }
}

impl super::core::DataContainerTrait for ObjectVariationCollection {
}

pub static OBJECTVARIATIONCOLLECTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectVariationCollection",
    name_hash: 2837543895,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(ObjectVariationCollection, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ObjectVariationCollection as Default>::default())),
            create_boxed: || Box::new(<ObjectVariationCollection as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Variations",
                name_hash: 2728063271,
                flags: MemberInfoFlags::new(144),
                field_type: "ObjectVariation-Array",
                rust_offset: offset_of!(ObjectVariationCollection, variations),
            },
        ],
    }),
    array_type: Some(OBJECTVARIATIONCOLLECTION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ObjectVariationCollection {
    fn type_info(&self) -> &'static TypeInfo {
        OBJECTVARIATIONCOLLECTION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static OBJECTVARIATIONCOLLECTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectVariationCollection-Array",
    name_hash: 3605230819,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ObjectVariationCollection"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ObjectVariation {
    pub _glacier_base: super::core::Asset,
    pub name_hash: u32,
}

pub trait ObjectVariationTrait: super::core::AssetTrait {
    fn name_hash(&self) -> &u32;
    fn name_hash_mut(&mut self) -> &mut u32;
}

impl ObjectVariationTrait for ObjectVariation {
    fn name_hash(&self) -> &u32 {
        &self.name_hash
    }
    fn name_hash_mut(&mut self) -> &mut u32 {
        &mut self.name_hash
    }
}

impl super::core::AssetTrait for ObjectVariation {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for ObjectVariation {
}

pub static OBJECTVARIATION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectVariation",
    name_hash: 3624336577,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        super_class_offset: offset_of!(ObjectVariation, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ObjectVariation as Default>::default())),
            create_boxed: || Box::new(<ObjectVariation as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "NameHash",
                name_hash: 994057744,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(ObjectVariation, name_hash),
            },
        ],
    }),
    array_type: Some(OBJECTVARIATION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ObjectVariation {
    fn type_info(&self) -> &'static TypeInfo {
        OBJECTVARIATION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static OBJECTVARIATION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectVariation-Array",
    name_hash: 1806108405,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ObjectVariation"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct DataContainerCollectionBlueprint {
    pub _glacier_base: Blueprint,
    pub data_containers: Vec<Option<LockedTypeObject /* super::core::DataContainer */>>,
}

pub trait DataContainerCollectionBlueprintTrait: BlueprintTrait {
    fn data_containers(&self) -> &Vec<Option<LockedTypeObject /* super::core::DataContainer */>>;
    fn data_containers_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::core::DataContainer */>>;
}

impl DataContainerCollectionBlueprintTrait for DataContainerCollectionBlueprint {
    fn data_containers(&self) -> &Vec<Option<LockedTypeObject /* super::core::DataContainer */>> {
        &self.data_containers
    }
    fn data_containers_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::core::DataContainer */>> {
        &mut self.data_containers
    }
}

impl BlueprintTrait for DataContainerCollectionBlueprint {
    fn objects(&self) -> &Vec<Option<LockedTypeObject /* GameObjectData */>> {
        self._glacier_base.objects()
    }
    fn objects_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* GameObjectData */>> {
        self._glacier_base.objects_mut()
    }
    fn schematics(&self) -> &Option<LockedTypeObject /* super::schematics::SchematicsBaseAsset */> {
        self._glacier_base.schematics()
    }
    fn schematics_mut(&mut self) -> &mut Option<LockedTypeObject /* super::schematics::SchematicsBaseAsset */> {
        self._glacier_base.schematics_mut()
    }
}

impl EntityBusDataTrait for DataContainerCollectionBlueprint {
    fn event_connections(&self) -> &Vec<BoxedTypeObject /* EventConnection */> {
        self._glacier_base.event_connections()
    }
    fn event_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* EventConnection */> {
        self._glacier_base.event_connections_mut()
    }
}

impl super::core::DataBusDataTrait for DataContainerCollectionBlueprint {
    fn flags(&self) -> &u16 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.flags_mut()
    }
    fn property_connections(&self) -> &Vec<BoxedTypeObject /* super::core::PropertyConnection */> {
        self._glacier_base.property_connections()
    }
    fn property_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::PropertyConnection */> {
        self._glacier_base.property_connections_mut()
    }
    fn link_connections(&self) -> &Vec<BoxedTypeObject /* super::core::LinkConnection */> {
        self._glacier_base.link_connections()
    }
    fn link_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::LinkConnection */> {
        self._glacier_base.link_connections_mut()
    }
    fn interface(&self) -> &Option<LockedTypeObject /* super::core::DynamicDataContainer */> {
        self._glacier_base.interface()
    }
    fn interface_mut(&mut self) -> &mut Option<LockedTypeObject /* super::core::DynamicDataContainer */> {
        self._glacier_base.interface_mut()
    }
}

impl super::core::AssetTrait for DataContainerCollectionBlueprint {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for DataContainerCollectionBlueprint {
}

pub static DATACONTAINERCOLLECTIONBLUEPRINT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DataContainerCollectionBlueprint",
    name_hash: 2518098059,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(BLUEPRINT_TYPE_INFO),
        super_class_offset: offset_of!(DataContainerCollectionBlueprint, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DataContainerCollectionBlueprint as Default>::default())),
            create_boxed: || Box::new(<DataContainerCollectionBlueprint as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "DataContainers",
                name_hash: 1951136449,
                flags: MemberInfoFlags::new(144),
                field_type: "DataContainer-Array",
                rust_offset: offset_of!(DataContainerCollectionBlueprint, data_containers),
            },
        ],
    }),
    array_type: Some(DATACONTAINERCOLLECTIONBLUEPRINT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DataContainerCollectionBlueprint {
    fn type_info(&self) -> &'static TypeInfo {
        DATACONTAINERCOLLECTIONBLUEPRINT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DATACONTAINERCOLLECTIONBLUEPRINT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DataContainerCollectionBlueprint-Array",
    name_hash: 1294913343,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("DataContainerCollectionBlueprint"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct LogicPrefabBlueprint {
    pub _glacier_base: PrefabBlueprint,
}

pub trait LogicPrefabBlueprintTrait: PrefabBlueprintTrait {
}

impl LogicPrefabBlueprintTrait for LogicPrefabBlueprint {
}

impl PrefabBlueprintTrait for LogicPrefabBlueprint {
    fn time_delta_type(&self) -> &TimeDeltaType {
        self._glacier_base.time_delta_type()
    }
    fn time_delta_type_mut(&mut self) -> &mut TimeDeltaType {
        self._glacier_base.time_delta_type_mut()
    }
}

impl BlueprintTrait for LogicPrefabBlueprint {
    fn objects(&self) -> &Vec<Option<LockedTypeObject /* GameObjectData */>> {
        self._glacier_base.objects()
    }
    fn objects_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* GameObjectData */>> {
        self._glacier_base.objects_mut()
    }
    fn schematics(&self) -> &Option<LockedTypeObject /* super::schematics::SchematicsBaseAsset */> {
        self._glacier_base.schematics()
    }
    fn schematics_mut(&mut self) -> &mut Option<LockedTypeObject /* super::schematics::SchematicsBaseAsset */> {
        self._glacier_base.schematics_mut()
    }
}

impl EntityBusDataTrait for LogicPrefabBlueprint {
    fn event_connections(&self) -> &Vec<BoxedTypeObject /* EventConnection */> {
        self._glacier_base.event_connections()
    }
    fn event_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* EventConnection */> {
        self._glacier_base.event_connections_mut()
    }
}

impl super::core::DataBusDataTrait for LogicPrefabBlueprint {
    fn flags(&self) -> &u16 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.flags_mut()
    }
    fn property_connections(&self) -> &Vec<BoxedTypeObject /* super::core::PropertyConnection */> {
        self._glacier_base.property_connections()
    }
    fn property_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::PropertyConnection */> {
        self._glacier_base.property_connections_mut()
    }
    fn link_connections(&self) -> &Vec<BoxedTypeObject /* super::core::LinkConnection */> {
        self._glacier_base.link_connections()
    }
    fn link_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::LinkConnection */> {
        self._glacier_base.link_connections_mut()
    }
    fn interface(&self) -> &Option<LockedTypeObject /* super::core::DynamicDataContainer */> {
        self._glacier_base.interface()
    }
    fn interface_mut(&mut self) -> &mut Option<LockedTypeObject /* super::core::DynamicDataContainer */> {
        self._glacier_base.interface_mut()
    }
}

impl super::core::AssetTrait for LogicPrefabBlueprint {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for LogicPrefabBlueprint {
}

pub static LOGICPREFABBLUEPRINT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LogicPrefabBlueprint",
    name_hash: 2313043142,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PREFABBLUEPRINT_TYPE_INFO),
        super_class_offset: offset_of!(LogicPrefabBlueprint, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LogicPrefabBlueprint as Default>::default())),
            create_boxed: || Box::new(<LogicPrefabBlueprint as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(LOGICPREFABBLUEPRINT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LogicPrefabBlueprint {
    fn type_info(&self) -> &'static TypeInfo {
        LOGICPREFABBLUEPRINT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LOGICPREFABBLUEPRINT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LogicPrefabBlueprint-Array",
    name_hash: 2200148594,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("LogicPrefabBlueprint"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SpatialPrefabBlueprint {
    pub _glacier_base: PrefabBlueprint,
}

pub trait SpatialPrefabBlueprintTrait: PrefabBlueprintTrait {
}

impl SpatialPrefabBlueprintTrait for SpatialPrefabBlueprint {
}

impl PrefabBlueprintTrait for SpatialPrefabBlueprint {
    fn time_delta_type(&self) -> &TimeDeltaType {
        self._glacier_base.time_delta_type()
    }
    fn time_delta_type_mut(&mut self) -> &mut TimeDeltaType {
        self._glacier_base.time_delta_type_mut()
    }
}

impl BlueprintTrait for SpatialPrefabBlueprint {
    fn objects(&self) -> &Vec<Option<LockedTypeObject /* GameObjectData */>> {
        self._glacier_base.objects()
    }
    fn objects_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* GameObjectData */>> {
        self._glacier_base.objects_mut()
    }
    fn schematics(&self) -> &Option<LockedTypeObject /* super::schematics::SchematicsBaseAsset */> {
        self._glacier_base.schematics()
    }
    fn schematics_mut(&mut self) -> &mut Option<LockedTypeObject /* super::schematics::SchematicsBaseAsset */> {
        self._glacier_base.schematics_mut()
    }
}

impl EntityBusDataTrait for SpatialPrefabBlueprint {
    fn event_connections(&self) -> &Vec<BoxedTypeObject /* EventConnection */> {
        self._glacier_base.event_connections()
    }
    fn event_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* EventConnection */> {
        self._glacier_base.event_connections_mut()
    }
}

impl super::core::DataBusDataTrait for SpatialPrefabBlueprint {
    fn flags(&self) -> &u16 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.flags_mut()
    }
    fn property_connections(&self) -> &Vec<BoxedTypeObject /* super::core::PropertyConnection */> {
        self._glacier_base.property_connections()
    }
    fn property_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::PropertyConnection */> {
        self._glacier_base.property_connections_mut()
    }
    fn link_connections(&self) -> &Vec<BoxedTypeObject /* super::core::LinkConnection */> {
        self._glacier_base.link_connections()
    }
    fn link_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::LinkConnection */> {
        self._glacier_base.link_connections_mut()
    }
    fn interface(&self) -> &Option<LockedTypeObject /* super::core::DynamicDataContainer */> {
        self._glacier_base.interface()
    }
    fn interface_mut(&mut self) -> &mut Option<LockedTypeObject /* super::core::DynamicDataContainer */> {
        self._glacier_base.interface_mut()
    }
}

impl super::core::AssetTrait for SpatialPrefabBlueprint {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for SpatialPrefabBlueprint {
}

pub static SPATIALPREFABBLUEPRINT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpatialPrefabBlueprint",
    name_hash: 1338740858,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PREFABBLUEPRINT_TYPE_INFO),
        super_class_offset: offset_of!(SpatialPrefabBlueprint, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SpatialPrefabBlueprint as Default>::default())),
            create_boxed: || Box::new(<SpatialPrefabBlueprint as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(SPATIALPREFABBLUEPRINT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SpatialPrefabBlueprint {
    fn type_info(&self) -> &'static TypeInfo {
        SPATIALPREFABBLUEPRINT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SPATIALPREFABBLUEPRINT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpatialPrefabBlueprint-Array",
    name_hash: 3607044942,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SpatialPrefabBlueprint"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct PrefabBlueprint {
    pub _glacier_base: Blueprint,
    pub time_delta_type: TimeDeltaType,
}

pub trait PrefabBlueprintTrait: BlueprintTrait {
    fn time_delta_type(&self) -> &TimeDeltaType;
    fn time_delta_type_mut(&mut self) -> &mut TimeDeltaType;
}

impl PrefabBlueprintTrait for PrefabBlueprint {
    fn time_delta_type(&self) -> &TimeDeltaType {
        &self.time_delta_type
    }
    fn time_delta_type_mut(&mut self) -> &mut TimeDeltaType {
        &mut self.time_delta_type
    }
}

impl BlueprintTrait for PrefabBlueprint {
    fn objects(&self) -> &Vec<Option<LockedTypeObject /* GameObjectData */>> {
        self._glacier_base.objects()
    }
    fn objects_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* GameObjectData */>> {
        self._glacier_base.objects_mut()
    }
    fn schematics(&self) -> &Option<LockedTypeObject /* super::schematics::SchematicsBaseAsset */> {
        self._glacier_base.schematics()
    }
    fn schematics_mut(&mut self) -> &mut Option<LockedTypeObject /* super::schematics::SchematicsBaseAsset */> {
        self._glacier_base.schematics_mut()
    }
}

impl EntityBusDataTrait for PrefabBlueprint {
    fn event_connections(&self) -> &Vec<BoxedTypeObject /* EventConnection */> {
        self._glacier_base.event_connections()
    }
    fn event_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* EventConnection */> {
        self._glacier_base.event_connections_mut()
    }
}

impl super::core::DataBusDataTrait for PrefabBlueprint {
    fn flags(&self) -> &u16 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.flags_mut()
    }
    fn property_connections(&self) -> &Vec<BoxedTypeObject /* super::core::PropertyConnection */> {
        self._glacier_base.property_connections()
    }
    fn property_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::PropertyConnection */> {
        self._glacier_base.property_connections_mut()
    }
    fn link_connections(&self) -> &Vec<BoxedTypeObject /* super::core::LinkConnection */> {
        self._glacier_base.link_connections()
    }
    fn link_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::LinkConnection */> {
        self._glacier_base.link_connections_mut()
    }
    fn interface(&self) -> &Option<LockedTypeObject /* super::core::DynamicDataContainer */> {
        self._glacier_base.interface()
    }
    fn interface_mut(&mut self) -> &mut Option<LockedTypeObject /* super::core::DynamicDataContainer */> {
        self._glacier_base.interface_mut()
    }
}

impl super::core::AssetTrait for PrefabBlueprint {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for PrefabBlueprint {
}

pub static PREFABBLUEPRINT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PrefabBlueprint",
    name_hash: 618349416,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(BLUEPRINT_TYPE_INFO),
        super_class_offset: offset_of!(PrefabBlueprint, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PrefabBlueprint as Default>::default())),
            create_boxed: || Box::new(<PrefabBlueprint as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "TimeDeltaType",
                name_hash: 1100516816,
                flags: MemberInfoFlags::new(0),
                field_type: "TimeDeltaType",
                rust_offset: offset_of!(PrefabBlueprint, time_delta_type),
            },
        ],
    }),
    array_type: Some(PREFABBLUEPRINT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PrefabBlueprint {
    fn type_info(&self) -> &'static TypeInfo {
        PREFABBLUEPRINT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PREFABBLUEPRINT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PrefabBlueprint-Array",
    name_hash: 2324305244,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("PrefabBlueprint"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ObjectBlueprint {
    pub _glacier_base: Blueprint,
    pub object: Option<LockedTypeObject /* EntityData */>,
}

pub trait ObjectBlueprintTrait: BlueprintTrait {
    fn object(&self) -> &Option<LockedTypeObject /* EntityData */>;
    fn object_mut(&mut self) -> &mut Option<LockedTypeObject /* EntityData */>;
}

impl ObjectBlueprintTrait for ObjectBlueprint {
    fn object(&self) -> &Option<LockedTypeObject /* EntityData */> {
        &self.object
    }
    fn object_mut(&mut self) -> &mut Option<LockedTypeObject /* EntityData */> {
        &mut self.object
    }
}

impl BlueprintTrait for ObjectBlueprint {
    fn objects(&self) -> &Vec<Option<LockedTypeObject /* GameObjectData */>> {
        self._glacier_base.objects()
    }
    fn objects_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* GameObjectData */>> {
        self._glacier_base.objects_mut()
    }
    fn schematics(&self) -> &Option<LockedTypeObject /* super::schematics::SchematicsBaseAsset */> {
        self._glacier_base.schematics()
    }
    fn schematics_mut(&mut self) -> &mut Option<LockedTypeObject /* super::schematics::SchematicsBaseAsset */> {
        self._glacier_base.schematics_mut()
    }
}

impl EntityBusDataTrait for ObjectBlueprint {
    fn event_connections(&self) -> &Vec<BoxedTypeObject /* EventConnection */> {
        self._glacier_base.event_connections()
    }
    fn event_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* EventConnection */> {
        self._glacier_base.event_connections_mut()
    }
}

impl super::core::DataBusDataTrait for ObjectBlueprint {
    fn flags(&self) -> &u16 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.flags_mut()
    }
    fn property_connections(&self) -> &Vec<BoxedTypeObject /* super::core::PropertyConnection */> {
        self._glacier_base.property_connections()
    }
    fn property_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::PropertyConnection */> {
        self._glacier_base.property_connections_mut()
    }
    fn link_connections(&self) -> &Vec<BoxedTypeObject /* super::core::LinkConnection */> {
        self._glacier_base.link_connections()
    }
    fn link_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::LinkConnection */> {
        self._glacier_base.link_connections_mut()
    }
    fn interface(&self) -> &Option<LockedTypeObject /* super::core::DynamicDataContainer */> {
        self._glacier_base.interface()
    }
    fn interface_mut(&mut self) -> &mut Option<LockedTypeObject /* super::core::DynamicDataContainer */> {
        self._glacier_base.interface_mut()
    }
}

impl super::core::AssetTrait for ObjectBlueprint {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for ObjectBlueprint {
}

pub static OBJECTBLUEPRINT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectBlueprint",
    name_hash: 1489969119,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(BLUEPRINT_TYPE_INFO),
        super_class_offset: offset_of!(ObjectBlueprint, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ObjectBlueprint as Default>::default())),
            create_boxed: || Box::new(<ObjectBlueprint as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Object",
                name_hash: 2866508144,
                flags: MemberInfoFlags::new(0),
                field_type: "EntityData",
                rust_offset: offset_of!(ObjectBlueprint, object),
            },
        ],
    }),
    array_type: Some(OBJECTBLUEPRINT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ObjectBlueprint {
    fn type_info(&self) -> &'static TypeInfo {
        OBJECTBLUEPRINT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static OBJECTBLUEPRINT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectBlueprint-Array",
    name_hash: 1706783979,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ObjectBlueprint"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct Blueprint {
    pub _glacier_base: EntityBusData,
    pub objects: Vec<Option<LockedTypeObject /* GameObjectData */>>,
    pub schematics: Option<LockedTypeObject /* super::schematics::SchematicsBaseAsset */>,
}

pub trait BlueprintTrait: EntityBusDataTrait {
    fn objects(&self) -> &Vec<Option<LockedTypeObject /* GameObjectData */>>;
    fn objects_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* GameObjectData */>>;
    fn schematics(&self) -> &Option<LockedTypeObject /* super::schematics::SchematicsBaseAsset */>;
    fn schematics_mut(&mut self) -> &mut Option<LockedTypeObject /* super::schematics::SchematicsBaseAsset */>;
}

impl BlueprintTrait for Blueprint {
    fn objects(&self) -> &Vec<Option<LockedTypeObject /* GameObjectData */>> {
        &self.objects
    }
    fn objects_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* GameObjectData */>> {
        &mut self.objects
    }
    fn schematics(&self) -> &Option<LockedTypeObject /* super::schematics::SchematicsBaseAsset */> {
        &self.schematics
    }
    fn schematics_mut(&mut self) -> &mut Option<LockedTypeObject /* super::schematics::SchematicsBaseAsset */> {
        &mut self.schematics
    }
}

impl EntityBusDataTrait for Blueprint {
    fn event_connections(&self) -> &Vec<BoxedTypeObject /* EventConnection */> {
        self._glacier_base.event_connections()
    }
    fn event_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* EventConnection */> {
        self._glacier_base.event_connections_mut()
    }
}

impl super::core::DataBusDataTrait for Blueprint {
    fn flags(&self) -> &u16 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.flags_mut()
    }
    fn property_connections(&self) -> &Vec<BoxedTypeObject /* super::core::PropertyConnection */> {
        self._glacier_base.property_connections()
    }
    fn property_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::PropertyConnection */> {
        self._glacier_base.property_connections_mut()
    }
    fn link_connections(&self) -> &Vec<BoxedTypeObject /* super::core::LinkConnection */> {
        self._glacier_base.link_connections()
    }
    fn link_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::LinkConnection */> {
        self._glacier_base.link_connections_mut()
    }
    fn interface(&self) -> &Option<LockedTypeObject /* super::core::DynamicDataContainer */> {
        self._glacier_base.interface()
    }
    fn interface_mut(&mut self) -> &mut Option<LockedTypeObject /* super::core::DynamicDataContainer */> {
        self._glacier_base.interface_mut()
    }
}

impl super::core::AssetTrait for Blueprint {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for Blueprint {
}

pub static BLUEPRINT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Blueprint",
    name_hash: 4232469066,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYBUSDATA_TYPE_INFO),
        super_class_offset: offset_of!(Blueprint, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Blueprint as Default>::default())),
            create_boxed: || Box::new(<Blueprint as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Objects",
                name_hash: 105488131,
                flags: MemberInfoFlags::new(144),
                field_type: "GameObjectData-Array",
                rust_offset: offset_of!(Blueprint, objects),
            },
            FieldInfoData {
                name: "Schematics",
                name_hash: 736570521,
                flags: MemberInfoFlags::new(0),
                field_type: "SchematicsBaseAsset",
                rust_offset: offset_of!(Blueprint, schematics),
            },
        ],
    }),
    array_type: Some(BLUEPRINT_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for Blueprint {
    fn type_info(&self) -> &'static TypeInfo {
        BLUEPRINT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BLUEPRINT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Blueprint-Array",
    name_hash: 449545726,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Blueprint"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum BlueprintPersistenceSetting {
    #[default]
    BlueprintPersistenceSetting_InheritFromParent = 0,
    BlueprintPersistenceSetting_SavedWhenInMemory = 1,
    BlueprintPersistenceSetting_AlwaysSaved = 2,
    BlueprintPersistenceSetting_NeverSaved = 3,
}

pub static BLUEPRINTPERSISTENCESETTING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BlueprintPersistenceSetting",
    name_hash: 3528233003,
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(BLUEPRINTPERSISTENCESETTING_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for BlueprintPersistenceSetting {
    fn type_info(&self) -> &'static TypeInfo {
        BLUEPRINTPERSISTENCESETTING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static BLUEPRINTPERSISTENCESETTING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BlueprintPersistenceSetting-Array",
    name_hash: 1178972063,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("BlueprintPersistenceSetting"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct EntityBusData {
    pub _glacier_base: super::core::DataBusData,
    pub event_connections: Vec<BoxedTypeObject /* EventConnection */>,
}

pub trait EntityBusDataTrait: super::core::DataBusDataTrait {
    fn event_connections(&self) -> &Vec<BoxedTypeObject /* EventConnection */>;
    fn event_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* EventConnection */>;
}

impl EntityBusDataTrait for EntityBusData {
    fn event_connections(&self) -> &Vec<BoxedTypeObject /* EventConnection */> {
        &self.event_connections
    }
    fn event_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* EventConnection */> {
        &mut self.event_connections
    }
}

impl super::core::DataBusDataTrait for EntityBusData {
    fn flags(&self) -> &u16 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.flags_mut()
    }
    fn property_connections(&self) -> &Vec<BoxedTypeObject /* super::core::PropertyConnection */> {
        self._glacier_base.property_connections()
    }
    fn property_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::PropertyConnection */> {
        self._glacier_base.property_connections_mut()
    }
    fn link_connections(&self) -> &Vec<BoxedTypeObject /* super::core::LinkConnection */> {
        self._glacier_base.link_connections()
    }
    fn link_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::LinkConnection */> {
        self._glacier_base.link_connections_mut()
    }
    fn interface(&self) -> &Option<LockedTypeObject /* super::core::DynamicDataContainer */> {
        self._glacier_base.interface()
    }
    fn interface_mut(&mut self) -> &mut Option<LockedTypeObject /* super::core::DynamicDataContainer */> {
        self._glacier_base.interface_mut()
    }
}

impl super::core::AssetTrait for EntityBusData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for EntityBusData {
}

pub static ENTITYBUSDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityBusData",
    name_hash: 1583801930,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATABUSDATA_TYPE_INFO),
        super_class_offset: offset_of!(EntityBusData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EntityBusData as Default>::default())),
            create_boxed: || Box::new(<EntityBusData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "EventConnections",
                name_hash: 2156913324,
                flags: MemberInfoFlags::new(144),
                field_type: "EventConnection-Array",
                rust_offset: offset_of!(EntityBusData, event_connections),
            },
        ],
    }),
    array_type: Some(ENTITYBUSDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for EntityBusData {
    fn type_info(&self) -> &'static TypeInfo {
        ENTITYBUSDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ENTITYBUSDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityBusData-Array",
    name_hash: 1847923198,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EntityBusData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct InterfaceDescriptorData {
    pub _glacier_base: super::core::DynamicDataContainer,
    pub input_events: Vec<BoxedTypeObject /* DynamicEvent */>,
    pub output_events: Vec<BoxedTypeObject /* DynamicEvent */>,
    pub input_links: Vec<BoxedTypeObject /* DynamicLink */>,
    pub output_links: Vec<BoxedTypeObject /* DynamicLink */>,
}

pub trait InterfaceDescriptorDataTrait: super::core::DynamicDataContainerTrait {
    fn input_events(&self) -> &Vec<BoxedTypeObject /* DynamicEvent */>;
    fn input_events_mut(&mut self) -> &mut Vec<BoxedTypeObject /* DynamicEvent */>;
    fn output_events(&self) -> &Vec<BoxedTypeObject /* DynamicEvent */>;
    fn output_events_mut(&mut self) -> &mut Vec<BoxedTypeObject /* DynamicEvent */>;
    fn input_links(&self) -> &Vec<BoxedTypeObject /* DynamicLink */>;
    fn input_links_mut(&mut self) -> &mut Vec<BoxedTypeObject /* DynamicLink */>;
    fn output_links(&self) -> &Vec<BoxedTypeObject /* DynamicLink */>;
    fn output_links_mut(&mut self) -> &mut Vec<BoxedTypeObject /* DynamicLink */>;
}

impl InterfaceDescriptorDataTrait for InterfaceDescriptorData {
    fn input_events(&self) -> &Vec<BoxedTypeObject /* DynamicEvent */> {
        &self.input_events
    }
    fn input_events_mut(&mut self) -> &mut Vec<BoxedTypeObject /* DynamicEvent */> {
        &mut self.input_events
    }
    fn output_events(&self) -> &Vec<BoxedTypeObject /* DynamicEvent */> {
        &self.output_events
    }
    fn output_events_mut(&mut self) -> &mut Vec<BoxedTypeObject /* DynamicEvent */> {
        &mut self.output_events
    }
    fn input_links(&self) -> &Vec<BoxedTypeObject /* DynamicLink */> {
        &self.input_links
    }
    fn input_links_mut(&mut self) -> &mut Vec<BoxedTypeObject /* DynamicLink */> {
        &mut self.input_links
    }
    fn output_links(&self) -> &Vec<BoxedTypeObject /* DynamicLink */> {
        &self.output_links
    }
    fn output_links_mut(&mut self) -> &mut Vec<BoxedTypeObject /* DynamicLink */> {
        &mut self.output_links
    }
}

impl super::core::DynamicDataContainerTrait for InterfaceDescriptorData {
    fn fields(&self) -> &Vec<BoxedTypeObject /* super::core::DataField */> {
        self._glacier_base.fields()
    }
    fn fields_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::DataField */> {
        self._glacier_base.fields_mut()
    }
}

impl super::core::DataContainerTrait for InterfaceDescriptorData {
}

pub static INTERFACEDESCRIPTORDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InterfaceDescriptorData",
    name_hash: 362024803,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DYNAMICDATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(InterfaceDescriptorData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<InterfaceDescriptorData as Default>::default())),
            create_boxed: || Box::new(<InterfaceDescriptorData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "InputEvents",
                name_hash: 1542460652,
                flags: MemberInfoFlags::new(144),
                field_type: "DynamicEvent-Array",
                rust_offset: offset_of!(InterfaceDescriptorData, input_events),
            },
            FieldInfoData {
                name: "OutputEvents",
                name_hash: 3452448709,
                flags: MemberInfoFlags::new(144),
                field_type: "DynamicEvent-Array",
                rust_offset: offset_of!(InterfaceDescriptorData, output_events),
            },
            FieldInfoData {
                name: "InputLinks",
                name_hash: 1626510432,
                flags: MemberInfoFlags::new(144),
                field_type: "DynamicLink-Array",
                rust_offset: offset_of!(InterfaceDescriptorData, input_links),
            },
            FieldInfoData {
                name: "OutputLinks",
                name_hash: 748160425,
                flags: MemberInfoFlags::new(144),
                field_type: "DynamicLink-Array",
                rust_offset: offset_of!(InterfaceDescriptorData, output_links),
            },
        ],
    }),
    array_type: Some(INTERFACEDESCRIPTORDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for InterfaceDescriptorData {
    fn type_info(&self) -> &'static TypeInfo {
        INTERFACEDESCRIPTORDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static INTERFACEDESCRIPTORDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InterfaceDescriptorData-Array",
    name_hash: 3418637143,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("InterfaceDescriptorData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct DynamicLink {
    pub id: i32,
}

pub trait DynamicLinkTrait: TypeObject {
    fn id(&self) -> &i32;
    fn id_mut(&mut self) -> &mut i32;
}

impl DynamicLinkTrait for DynamicLink {
    fn id(&self) -> &i32 {
        &self.id
    }
    fn id_mut(&mut self) -> &mut i32 {
        &mut self.id
    }
}

pub static DYNAMICLINK_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicLink",
    name_hash: 3682201776,
    flags: MemberInfoFlags::new(32841),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DynamicLink as Default>::default())),
            create_boxed: || Box::new(<DynamicLink as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Id",
                name_hash: 5862152,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(DynamicLink, id),
            },
        ],
    }),
    array_type: Some(DYNAMICLINK_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for DynamicLink {
    fn type_info(&self) -> &'static TypeInfo {
        DYNAMICLINK_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static DYNAMICLINK_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicLink-Array",
    name_hash: 790437380,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("DynamicLink"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct DynamicEvent {
    pub id: i32,
}

pub trait DynamicEventTrait: TypeObject {
    fn id(&self) -> &i32;
    fn id_mut(&mut self) -> &mut i32;
}

impl DynamicEventTrait for DynamicEvent {
    fn id(&self) -> &i32 {
        &self.id
    }
    fn id_mut(&mut self) -> &mut i32 {
        &mut self.id
    }
}

pub static DYNAMICEVENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicEvent",
    name_hash: 1242509212,
    flags: MemberInfoFlags::new(32841),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DynamicEvent as Default>::default())),
            create_boxed: || Box::new(<DynamicEvent as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Id",
                name_hash: 5862152,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(DynamicEvent, id),
            },
        ],
    }),
    array_type: Some(DYNAMICEVENT_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for DynamicEvent {
    fn type_info(&self) -> &'static TypeInfo {
        DYNAMICEVENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static DYNAMICEVENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicEvent-Array",
    name_hash: 1602570152,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("DynamicEvent"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct EventConnection {
    pub source: Option<LockedTypeObject /* super::core::DataContainer */>,
    pub target: Option<LockedTypeObject /* super::core::DataContainer */>,
    pub source_event: EventSpec,
    pub target_event: EventSpec,
    pub target_type: EventConnectionTargetType,
}

pub trait EventConnectionTrait: TypeObject {
    fn source(&self) -> &Option<LockedTypeObject /* super::core::DataContainer */>;
    fn source_mut(&mut self) -> &mut Option<LockedTypeObject /* super::core::DataContainer */>;
    fn target(&self) -> &Option<LockedTypeObject /* super::core::DataContainer */>;
    fn target_mut(&mut self) -> &mut Option<LockedTypeObject /* super::core::DataContainer */>;
    fn source_event(&self) -> &EventSpec;
    fn source_event_mut(&mut self) -> &mut EventSpec;
    fn target_event(&self) -> &EventSpec;
    fn target_event_mut(&mut self) -> &mut EventSpec;
    fn target_type(&self) -> &EventConnectionTargetType;
    fn target_type_mut(&mut self) -> &mut EventConnectionTargetType;
}

impl EventConnectionTrait for EventConnection {
    fn source(&self) -> &Option<LockedTypeObject /* super::core::DataContainer */> {
        &self.source
    }
    fn source_mut(&mut self) -> &mut Option<LockedTypeObject /* super::core::DataContainer */> {
        &mut self.source
    }
    fn target(&self) -> &Option<LockedTypeObject /* super::core::DataContainer */> {
        &self.target
    }
    fn target_mut(&mut self) -> &mut Option<LockedTypeObject /* super::core::DataContainer */> {
        &mut self.target
    }
    fn source_event(&self) -> &EventSpec {
        &self.source_event
    }
    fn source_event_mut(&mut self) -> &mut EventSpec {
        &mut self.source_event
    }
    fn target_event(&self) -> &EventSpec {
        &self.target_event
    }
    fn target_event_mut(&mut self) -> &mut EventSpec {
        &mut self.target_event
    }
    fn target_type(&self) -> &EventConnectionTargetType {
        &self.target_type
    }
    fn target_type_mut(&mut self) -> &mut EventConnectionTargetType {
        &mut self.target_type
    }
}

pub static EVENTCONNECTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventConnection",
    name_hash: 3969876735,
    flags: MemberInfoFlags::new(73),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EventConnection as Default>::default())),
            create_boxed: || Box::new(<EventConnection as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Source",
                name_hash: 3339738264,
                flags: MemberInfoFlags::new(0),
                field_type: "DataContainer",
                rust_offset: offset_of!(EventConnection, source),
            },
            FieldInfoData {
                name: "Target",
                name_hash: 3215022804,
                flags: MemberInfoFlags::new(0),
                field_type: "DataContainer",
                rust_offset: offset_of!(EventConnection, target),
            },
            FieldInfoData {
                name: "SourceEvent",
                name_hash: 3000664532,
                flags: MemberInfoFlags::new(0),
                field_type: "EventSpec",
                rust_offset: offset_of!(EventConnection, source_event),
            },
            FieldInfoData {
                name: "TargetEvent",
                name_hash: 2254399000,
                flags: MemberInfoFlags::new(0),
                field_type: "EventSpec",
                rust_offset: offset_of!(EventConnection, target_event),
            },
            FieldInfoData {
                name: "TargetType",
                name_hash: 328114796,
                flags: MemberInfoFlags::new(0),
                field_type: "EventConnectionTargetType",
                rust_offset: offset_of!(EventConnection, target_type),
            },
        ],
    }),
    array_type: Some(EVENTCONNECTION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EventConnection {
    fn type_info(&self) -> &'static TypeInfo {
        EVENTCONNECTION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static EVENTCONNECTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventConnection-Array",
    name_hash: 2563385547,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EventConnection"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum EventConnectionTargetType {
    #[default]
    EventConnectionTargetType_Invalid = 0,
    EventConnectionTargetType_ClientAndServer = 1,
    EventConnectionTargetType_Client = 2,
    EventConnectionTargetType_Server = 3,
    EventConnectionTargetType_NetworkedClient = 4,
    EventConnectionTargetType_NetworkedClientAndServer = 5,
}

pub static EVENTCONNECTIONTARGETTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventConnectionTargetType",
    name_hash: 1454871510,
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(EVENTCONNECTIONTARGETTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for EventConnectionTargetType {
    fn type_info(&self) -> &'static TypeInfo {
        EVENTCONNECTIONTARGETTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static EVENTCONNECTIONTARGETTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventConnectionTargetType-Array",
    name_hash: 2834626914,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EventConnectionTargetType"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct EventSpec {
    pub id: i32,
}

pub trait EventSpecTrait: TypeObject {
    fn id(&self) -> &i32;
    fn id_mut(&mut self) -> &mut i32;
}

impl EventSpecTrait for EventSpec {
    fn id(&self) -> &i32 {
        &self.id
    }
    fn id_mut(&mut self) -> &mut i32 {
        &mut self.id
    }
}

pub static EVENTSPEC_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventSpec",
    name_hash: 4133264204,
    flags: MemberInfoFlags::new(32841),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EventSpec as Default>::default())),
            create_boxed: || Box::new(<EventSpec as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Id",
                name_hash: 5862152,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(EventSpec, id),
            },
        ],
    }),
    array_type: Some(EVENTSPEC_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for EventSpec {
    fn type_info(&self) -> &'static TypeInfo {
        EVENTSPEC_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static EVENTSPEC_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventSpec-Array",
    name_hash: 3721772024,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EventSpec"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CompareAxisAlignedBoxEntityData {
    pub _glacier_base: CompareEntityBaseData,
    pub a: super::core::AxisAlignedBox,
    pub b: super::core::AxisAlignedBox,
}

pub trait CompareAxisAlignedBoxEntityDataTrait: CompareEntityBaseDataTrait {
    fn a(&self) -> &super::core::AxisAlignedBox;
    fn a_mut(&mut self) -> &mut super::core::AxisAlignedBox;
    fn b(&self) -> &super::core::AxisAlignedBox;
    fn b_mut(&mut self) -> &mut super::core::AxisAlignedBox;
}

impl CompareAxisAlignedBoxEntityDataTrait for CompareAxisAlignedBoxEntityData {
    fn a(&self) -> &super::core::AxisAlignedBox {
        &self.a
    }
    fn a_mut(&mut self) -> &mut super::core::AxisAlignedBox {
        &mut self.a
    }
    fn b(&self) -> &super::core::AxisAlignedBox {
        &self.b
    }
    fn b_mut(&mut self) -> &mut super::core::AxisAlignedBox {
        &mut self.b
    }
}

impl CompareEntityBaseDataTrait for CompareAxisAlignedBoxEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn trigger_on_property_change(&self) -> &bool {
        self._glacier_base.trigger_on_property_change()
    }
    fn trigger_on_property_change_mut(&mut self) -> &mut bool {
        self._glacier_base.trigger_on_property_change_mut()
    }
    fn trigger_on_start(&self) -> &bool {
        self._glacier_base.trigger_on_start()
    }
    fn trigger_on_start_mut(&mut self) -> &mut bool {
        self._glacier_base.trigger_on_start_mut()
    }
    fn always_send(&self) -> &bool {
        self._glacier_base.always_send()
    }
    fn always_send_mut(&mut self) -> &mut bool {
        self._glacier_base.always_send_mut()
    }
}

impl EntityDataTrait for CompareAxisAlignedBoxEntityData {
}

impl GameObjectDataTrait for CompareAxisAlignedBoxEntityData {
}

impl super::core::DataBusPeerTrait for CompareAxisAlignedBoxEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CompareAxisAlignedBoxEntityData {
}

impl super::core::DataContainerTrait for CompareAxisAlignedBoxEntityData {
}

pub static COMPAREAXISALIGNEDBOXENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareAxisAlignedBoxEntityData",
    name_hash: 1027389747,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(COMPAREENTITYBASEDATA_TYPE_INFO),
        super_class_offset: offset_of!(CompareAxisAlignedBoxEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareAxisAlignedBoxEntityData as Default>::default())),
            create_boxed: || Box::new(<CompareAxisAlignedBoxEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "A",
                name_hash: 177636,
                flags: MemberInfoFlags::new(0),
                field_type: "AxisAlignedBox",
                rust_offset: offset_of!(CompareAxisAlignedBoxEntityData, a),
            },
            FieldInfoData {
                name: "B",
                name_hash: 177639,
                flags: MemberInfoFlags::new(0),
                field_type: "AxisAlignedBox",
                rust_offset: offset_of!(CompareAxisAlignedBoxEntityData, b),
            },
        ],
    }),
    array_type: Some(COMPAREAXISALIGNEDBOXENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CompareAxisAlignedBoxEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        COMPAREAXISALIGNEDBOXENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COMPAREAXISALIGNEDBOXENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareAxisAlignedBoxEntityData-Array",
    name_hash: 3322152071,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareAxisAlignedBoxEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CompareUintRangeEntityData {
    pub _glacier_base: CompareEntityBaseData,
    pub value: u32,
    pub min: u32,
    pub max: u32,
}

pub trait CompareUintRangeEntityDataTrait: CompareEntityBaseDataTrait {
    fn value(&self) -> &u32;
    fn value_mut(&mut self) -> &mut u32;
    fn min(&self) -> &u32;
    fn min_mut(&mut self) -> &mut u32;
    fn max(&self) -> &u32;
    fn max_mut(&mut self) -> &mut u32;
}

impl CompareUintRangeEntityDataTrait for CompareUintRangeEntityData {
    fn value(&self) -> &u32 {
        &self.value
    }
    fn value_mut(&mut self) -> &mut u32 {
        &mut self.value
    }
    fn min(&self) -> &u32 {
        &self.min
    }
    fn min_mut(&mut self) -> &mut u32 {
        &mut self.min
    }
    fn max(&self) -> &u32 {
        &self.max
    }
    fn max_mut(&mut self) -> &mut u32 {
        &mut self.max
    }
}

impl CompareEntityBaseDataTrait for CompareUintRangeEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn trigger_on_property_change(&self) -> &bool {
        self._glacier_base.trigger_on_property_change()
    }
    fn trigger_on_property_change_mut(&mut self) -> &mut bool {
        self._glacier_base.trigger_on_property_change_mut()
    }
    fn trigger_on_start(&self) -> &bool {
        self._glacier_base.trigger_on_start()
    }
    fn trigger_on_start_mut(&mut self) -> &mut bool {
        self._glacier_base.trigger_on_start_mut()
    }
    fn always_send(&self) -> &bool {
        self._glacier_base.always_send()
    }
    fn always_send_mut(&mut self) -> &mut bool {
        self._glacier_base.always_send_mut()
    }
}

impl EntityDataTrait for CompareUintRangeEntityData {
}

impl GameObjectDataTrait for CompareUintRangeEntityData {
}

impl super::core::DataBusPeerTrait for CompareUintRangeEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CompareUintRangeEntityData {
}

impl super::core::DataContainerTrait for CompareUintRangeEntityData {
}

pub static COMPAREUINTRANGEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareUintRangeEntityData",
    name_hash: 3229267248,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(COMPAREENTITYBASEDATA_TYPE_INFO),
        super_class_offset: offset_of!(CompareUintRangeEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareUintRangeEntityData as Default>::default())),
            create_boxed: || Box::new(<CompareUintRangeEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Value",
                name_hash: 225375086,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(CompareUintRangeEntityData, value),
            },
            FieldInfoData {
                name: "Min",
                name_hash: 193446607,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(CompareUintRangeEntityData, min),
            },
            FieldInfoData {
                name: "Max",
                name_hash: 193446865,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(CompareUintRangeEntityData, max),
            },
        ],
    }),
    array_type: Some(COMPAREUINTRANGEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CompareUintRangeEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        COMPAREUINTRANGEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COMPAREUINTRANGEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareUintRangeEntityData-Array",
    name_hash: 3888071300,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareUintRangeEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CompareIntRangeEntityData {
    pub _glacier_base: CompareEntityBaseData,
    pub value: i32,
    pub min: i32,
    pub max: i32,
}

pub trait CompareIntRangeEntityDataTrait: CompareEntityBaseDataTrait {
    fn value(&self) -> &i32;
    fn value_mut(&mut self) -> &mut i32;
    fn min(&self) -> &i32;
    fn min_mut(&mut self) -> &mut i32;
    fn max(&self) -> &i32;
    fn max_mut(&mut self) -> &mut i32;
}

impl CompareIntRangeEntityDataTrait for CompareIntRangeEntityData {
    fn value(&self) -> &i32 {
        &self.value
    }
    fn value_mut(&mut self) -> &mut i32 {
        &mut self.value
    }
    fn min(&self) -> &i32 {
        &self.min
    }
    fn min_mut(&mut self) -> &mut i32 {
        &mut self.min
    }
    fn max(&self) -> &i32 {
        &self.max
    }
    fn max_mut(&mut self) -> &mut i32 {
        &mut self.max
    }
}

impl CompareEntityBaseDataTrait for CompareIntRangeEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn trigger_on_property_change(&self) -> &bool {
        self._glacier_base.trigger_on_property_change()
    }
    fn trigger_on_property_change_mut(&mut self) -> &mut bool {
        self._glacier_base.trigger_on_property_change_mut()
    }
    fn trigger_on_start(&self) -> &bool {
        self._glacier_base.trigger_on_start()
    }
    fn trigger_on_start_mut(&mut self) -> &mut bool {
        self._glacier_base.trigger_on_start_mut()
    }
    fn always_send(&self) -> &bool {
        self._glacier_base.always_send()
    }
    fn always_send_mut(&mut self) -> &mut bool {
        self._glacier_base.always_send_mut()
    }
}

impl EntityDataTrait for CompareIntRangeEntityData {
}

impl GameObjectDataTrait for CompareIntRangeEntityData {
}

impl super::core::DataBusPeerTrait for CompareIntRangeEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CompareIntRangeEntityData {
}

impl super::core::DataContainerTrait for CompareIntRangeEntityData {
}

pub static COMPAREINTRANGEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareIntRangeEntityData",
    name_hash: 3829796997,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(COMPAREENTITYBASEDATA_TYPE_INFO),
        super_class_offset: offset_of!(CompareIntRangeEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareIntRangeEntityData as Default>::default())),
            create_boxed: || Box::new(<CompareIntRangeEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Value",
                name_hash: 225375086,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CompareIntRangeEntityData, value),
            },
            FieldInfoData {
                name: "Min",
                name_hash: 193446607,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CompareIntRangeEntityData, min),
            },
            FieldInfoData {
                name: "Max",
                name_hash: 193446865,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CompareIntRangeEntityData, max),
            },
        ],
    }),
    array_type: Some(COMPAREINTRANGEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CompareIntRangeEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        COMPAREINTRANGEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COMPAREINTRANGEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareIntRangeEntityData-Array",
    name_hash: 3814299697,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareIntRangeEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CompareFloatRangeEntityData {
    pub _glacier_base: CompareEntityBaseData,
    pub value: f32,
    pub min: f32,
    pub max: f32,
}

pub trait CompareFloatRangeEntityDataTrait: CompareEntityBaseDataTrait {
    fn value(&self) -> &f32;
    fn value_mut(&mut self) -> &mut f32;
    fn min(&self) -> &f32;
    fn min_mut(&mut self) -> &mut f32;
    fn max(&self) -> &f32;
    fn max_mut(&mut self) -> &mut f32;
}

impl CompareFloatRangeEntityDataTrait for CompareFloatRangeEntityData {
    fn value(&self) -> &f32 {
        &self.value
    }
    fn value_mut(&mut self) -> &mut f32 {
        &mut self.value
    }
    fn min(&self) -> &f32 {
        &self.min
    }
    fn min_mut(&mut self) -> &mut f32 {
        &mut self.min
    }
    fn max(&self) -> &f32 {
        &self.max
    }
    fn max_mut(&mut self) -> &mut f32 {
        &mut self.max
    }
}

impl CompareEntityBaseDataTrait for CompareFloatRangeEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn trigger_on_property_change(&self) -> &bool {
        self._glacier_base.trigger_on_property_change()
    }
    fn trigger_on_property_change_mut(&mut self) -> &mut bool {
        self._glacier_base.trigger_on_property_change_mut()
    }
    fn trigger_on_start(&self) -> &bool {
        self._glacier_base.trigger_on_start()
    }
    fn trigger_on_start_mut(&mut self) -> &mut bool {
        self._glacier_base.trigger_on_start_mut()
    }
    fn always_send(&self) -> &bool {
        self._glacier_base.always_send()
    }
    fn always_send_mut(&mut self) -> &mut bool {
        self._glacier_base.always_send_mut()
    }
}

impl EntityDataTrait for CompareFloatRangeEntityData {
}

impl GameObjectDataTrait for CompareFloatRangeEntityData {
}

impl super::core::DataBusPeerTrait for CompareFloatRangeEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CompareFloatRangeEntityData {
}

impl super::core::DataContainerTrait for CompareFloatRangeEntityData {
}

pub static COMPAREFLOATRANGEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareFloatRangeEntityData",
    name_hash: 2364792902,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(COMPAREENTITYBASEDATA_TYPE_INFO),
        super_class_offset: offset_of!(CompareFloatRangeEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareFloatRangeEntityData as Default>::default())),
            create_boxed: || Box::new(<CompareFloatRangeEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Value",
                name_hash: 225375086,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CompareFloatRangeEntityData, value),
            },
            FieldInfoData {
                name: "Min",
                name_hash: 193446607,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CompareFloatRangeEntityData, min),
            },
            FieldInfoData {
                name: "Max",
                name_hash: 193446865,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CompareFloatRangeEntityData, max),
            },
        ],
    }),
    array_type: Some(COMPAREFLOATRANGEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CompareFloatRangeEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        COMPAREFLOATRANGEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COMPAREFLOATRANGEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareFloatRangeEntityData-Array",
    name_hash: 2479218162,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareFloatRangeEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CompareStringEntityData {
    pub _glacier_base: CompareEntityBaseData,
    pub a: String,
    pub b: String,
}

pub trait CompareStringEntityDataTrait: CompareEntityBaseDataTrait {
    fn a(&self) -> &String;
    fn a_mut(&mut self) -> &mut String;
    fn b(&self) -> &String;
    fn b_mut(&mut self) -> &mut String;
}

impl CompareStringEntityDataTrait for CompareStringEntityData {
    fn a(&self) -> &String {
        &self.a
    }
    fn a_mut(&mut self) -> &mut String {
        &mut self.a
    }
    fn b(&self) -> &String {
        &self.b
    }
    fn b_mut(&mut self) -> &mut String {
        &mut self.b
    }
}

impl CompareEntityBaseDataTrait for CompareStringEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn trigger_on_property_change(&self) -> &bool {
        self._glacier_base.trigger_on_property_change()
    }
    fn trigger_on_property_change_mut(&mut self) -> &mut bool {
        self._glacier_base.trigger_on_property_change_mut()
    }
    fn trigger_on_start(&self) -> &bool {
        self._glacier_base.trigger_on_start()
    }
    fn trigger_on_start_mut(&mut self) -> &mut bool {
        self._glacier_base.trigger_on_start_mut()
    }
    fn always_send(&self) -> &bool {
        self._glacier_base.always_send()
    }
    fn always_send_mut(&mut self) -> &mut bool {
        self._glacier_base.always_send_mut()
    }
}

impl EntityDataTrait for CompareStringEntityData {
}

impl GameObjectDataTrait for CompareStringEntityData {
}

impl super::core::DataBusPeerTrait for CompareStringEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CompareStringEntityData {
}

impl super::core::DataContainerTrait for CompareStringEntityData {
}

pub static COMPARESTRINGENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareStringEntityData",
    name_hash: 3862382780,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(COMPAREENTITYBASEDATA_TYPE_INFO),
        super_class_offset: offset_of!(CompareStringEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareStringEntityData as Default>::default())),
            create_boxed: || Box::new(<CompareStringEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "A",
                name_hash: 177636,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(CompareStringEntityData, a),
            },
            FieldInfoData {
                name: "B",
                name_hash: 177639,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(CompareStringEntityData, b),
            },
        ],
    }),
    array_type: Some(COMPARESTRINGENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CompareStringEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        COMPARESTRINGENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COMPARESTRINGENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareStringEntityData-Array",
    name_hash: 4231757832,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareStringEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CompareVec4EntityData {
    pub _glacier_base: CompareEntityBaseData,
    pub value_a: super::core::Vec4,
    pub value_b: super::core::Vec4,
    pub tolerance: f32,
}

pub trait CompareVec4EntityDataTrait: CompareEntityBaseDataTrait {
    fn value_a(&self) -> &super::core::Vec4;
    fn value_a_mut(&mut self) -> &mut super::core::Vec4;
    fn value_b(&self) -> &super::core::Vec4;
    fn value_b_mut(&mut self) -> &mut super::core::Vec4;
    fn tolerance(&self) -> &f32;
    fn tolerance_mut(&mut self) -> &mut f32;
}

impl CompareVec4EntityDataTrait for CompareVec4EntityData {
    fn value_a(&self) -> &super::core::Vec4 {
        &self.value_a
    }
    fn value_a_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.value_a
    }
    fn value_b(&self) -> &super::core::Vec4 {
        &self.value_b
    }
    fn value_b_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.value_b
    }
    fn tolerance(&self) -> &f32 {
        &self.tolerance
    }
    fn tolerance_mut(&mut self) -> &mut f32 {
        &mut self.tolerance
    }
}

impl CompareEntityBaseDataTrait for CompareVec4EntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn trigger_on_property_change(&self) -> &bool {
        self._glacier_base.trigger_on_property_change()
    }
    fn trigger_on_property_change_mut(&mut self) -> &mut bool {
        self._glacier_base.trigger_on_property_change_mut()
    }
    fn trigger_on_start(&self) -> &bool {
        self._glacier_base.trigger_on_start()
    }
    fn trigger_on_start_mut(&mut self) -> &mut bool {
        self._glacier_base.trigger_on_start_mut()
    }
    fn always_send(&self) -> &bool {
        self._glacier_base.always_send()
    }
    fn always_send_mut(&mut self) -> &mut bool {
        self._glacier_base.always_send_mut()
    }
}

impl EntityDataTrait for CompareVec4EntityData {
}

impl GameObjectDataTrait for CompareVec4EntityData {
}

impl super::core::DataBusPeerTrait for CompareVec4EntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CompareVec4EntityData {
}

impl super::core::DataContainerTrait for CompareVec4EntityData {
}

pub static COMPAREVEC4ENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareVec4EntityData",
    name_hash: 844014765,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(COMPAREENTITYBASEDATA_TYPE_INFO),
        super_class_offset: offset_of!(CompareVec4EntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareVec4EntityData as Default>::default())),
            create_boxed: || Box::new(<CompareVec4EntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "ValueA",
                name_hash: 3142410607,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(CompareVec4EntityData, value_a),
            },
            FieldInfoData {
                name: "ValueB",
                name_hash: 3142410604,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(CompareVec4EntityData, value_b),
            },
            FieldInfoData {
                name: "Tolerance",
                name_hash: 178343404,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CompareVec4EntityData, tolerance),
            },
        ],
    }),
    array_type: Some(COMPAREVEC4ENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CompareVec4EntityData {
    fn type_info(&self) -> &'static TypeInfo {
        COMPAREVEC4ENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COMPAREVEC4ENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareVec4EntityData-Array",
    name_hash: 2964085017,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareVec4EntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CompareVec3EntityData {
    pub _glacier_base: CompareEntityBaseData,
    pub value_a: super::core::Vec3,
    pub value_b: super::core::Vec3,
    pub tolerance: f32,
}

pub trait CompareVec3EntityDataTrait: CompareEntityBaseDataTrait {
    fn value_a(&self) -> &super::core::Vec3;
    fn value_a_mut(&mut self) -> &mut super::core::Vec3;
    fn value_b(&self) -> &super::core::Vec3;
    fn value_b_mut(&mut self) -> &mut super::core::Vec3;
    fn tolerance(&self) -> &f32;
    fn tolerance_mut(&mut self) -> &mut f32;
}

impl CompareVec3EntityDataTrait for CompareVec3EntityData {
    fn value_a(&self) -> &super::core::Vec3 {
        &self.value_a
    }
    fn value_a_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.value_a
    }
    fn value_b(&self) -> &super::core::Vec3 {
        &self.value_b
    }
    fn value_b_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.value_b
    }
    fn tolerance(&self) -> &f32 {
        &self.tolerance
    }
    fn tolerance_mut(&mut self) -> &mut f32 {
        &mut self.tolerance
    }
}

impl CompareEntityBaseDataTrait for CompareVec3EntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn trigger_on_property_change(&self) -> &bool {
        self._glacier_base.trigger_on_property_change()
    }
    fn trigger_on_property_change_mut(&mut self) -> &mut bool {
        self._glacier_base.trigger_on_property_change_mut()
    }
    fn trigger_on_start(&self) -> &bool {
        self._glacier_base.trigger_on_start()
    }
    fn trigger_on_start_mut(&mut self) -> &mut bool {
        self._glacier_base.trigger_on_start_mut()
    }
    fn always_send(&self) -> &bool {
        self._glacier_base.always_send()
    }
    fn always_send_mut(&mut self) -> &mut bool {
        self._glacier_base.always_send_mut()
    }
}

impl EntityDataTrait for CompareVec3EntityData {
}

impl GameObjectDataTrait for CompareVec3EntityData {
}

impl super::core::DataBusPeerTrait for CompareVec3EntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CompareVec3EntityData {
}

impl super::core::DataContainerTrait for CompareVec3EntityData {
}

pub static COMPAREVEC3ENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareVec3EntityData",
    name_hash: 2293259242,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(COMPAREENTITYBASEDATA_TYPE_INFO),
        super_class_offset: offset_of!(CompareVec3EntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareVec3EntityData as Default>::default())),
            create_boxed: || Box::new(<CompareVec3EntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "ValueA",
                name_hash: 3142410607,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(CompareVec3EntityData, value_a),
            },
            FieldInfoData {
                name: "ValueB",
                name_hash: 3142410604,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(CompareVec3EntityData, value_b),
            },
            FieldInfoData {
                name: "Tolerance",
                name_hash: 178343404,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CompareVec3EntityData, tolerance),
            },
        ],
    }),
    array_type: Some(COMPAREVEC3ENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CompareVec3EntityData {
    fn type_info(&self) -> &'static TypeInfo {
        COMPAREVEC3ENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COMPAREVEC3ENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareVec3EntityData-Array",
    name_hash: 1184614110,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareVec3EntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CompareFloatEntityData {
    pub _glacier_base: CompareEntityBaseData,
    pub a: f32,
    pub b: f32,
}

pub trait CompareFloatEntityDataTrait: CompareEntityBaseDataTrait {
    fn a(&self) -> &f32;
    fn a_mut(&mut self) -> &mut f32;
    fn b(&self) -> &f32;
    fn b_mut(&mut self) -> &mut f32;
}

impl CompareFloatEntityDataTrait for CompareFloatEntityData {
    fn a(&self) -> &f32 {
        &self.a
    }
    fn a_mut(&mut self) -> &mut f32 {
        &mut self.a
    }
    fn b(&self) -> &f32 {
        &self.b
    }
    fn b_mut(&mut self) -> &mut f32 {
        &mut self.b
    }
}

impl CompareEntityBaseDataTrait for CompareFloatEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn trigger_on_property_change(&self) -> &bool {
        self._glacier_base.trigger_on_property_change()
    }
    fn trigger_on_property_change_mut(&mut self) -> &mut bool {
        self._glacier_base.trigger_on_property_change_mut()
    }
    fn trigger_on_start(&self) -> &bool {
        self._glacier_base.trigger_on_start()
    }
    fn trigger_on_start_mut(&mut self) -> &mut bool {
        self._glacier_base.trigger_on_start_mut()
    }
    fn always_send(&self) -> &bool {
        self._glacier_base.always_send()
    }
    fn always_send_mut(&mut self) -> &mut bool {
        self._glacier_base.always_send_mut()
    }
}

impl EntityDataTrait for CompareFloatEntityData {
}

impl GameObjectDataTrait for CompareFloatEntityData {
}

impl super::core::DataBusPeerTrait for CompareFloatEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CompareFloatEntityData {
}

impl super::core::DataContainerTrait for CompareFloatEntityData {
}

pub static COMPAREFLOATENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareFloatEntityData",
    name_hash: 3883933145,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(COMPAREENTITYBASEDATA_TYPE_INFO),
        super_class_offset: offset_of!(CompareFloatEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareFloatEntityData as Default>::default())),
            create_boxed: || Box::new(<CompareFloatEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "A",
                name_hash: 177636,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CompareFloatEntityData, a),
            },
            FieldInfoData {
                name: "B",
                name_hash: 177639,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CompareFloatEntityData, b),
            },
        ],
    }),
    array_type: Some(COMPAREFLOATENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CompareFloatEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        COMPAREFLOATENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COMPAREFLOATENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareFloatEntityData-Array",
    name_hash: 3318156269,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareFloatEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CompareUintEntityData {
    pub _glacier_base: CompareEntityBaseData,
    pub a: u32,
    pub b: u32,
}

pub trait CompareUintEntityDataTrait: CompareEntityBaseDataTrait {
    fn a(&self) -> &u32;
    fn a_mut(&mut self) -> &mut u32;
    fn b(&self) -> &u32;
    fn b_mut(&mut self) -> &mut u32;
}

impl CompareUintEntityDataTrait for CompareUintEntityData {
    fn a(&self) -> &u32 {
        &self.a
    }
    fn a_mut(&mut self) -> &mut u32 {
        &mut self.a
    }
    fn b(&self) -> &u32 {
        &self.b
    }
    fn b_mut(&mut self) -> &mut u32 {
        &mut self.b
    }
}

impl CompareEntityBaseDataTrait for CompareUintEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn trigger_on_property_change(&self) -> &bool {
        self._glacier_base.trigger_on_property_change()
    }
    fn trigger_on_property_change_mut(&mut self) -> &mut bool {
        self._glacier_base.trigger_on_property_change_mut()
    }
    fn trigger_on_start(&self) -> &bool {
        self._glacier_base.trigger_on_start()
    }
    fn trigger_on_start_mut(&mut self) -> &mut bool {
        self._glacier_base.trigger_on_start_mut()
    }
    fn always_send(&self) -> &bool {
        self._glacier_base.always_send()
    }
    fn always_send_mut(&mut self) -> &mut bool {
        self._glacier_base.always_send_mut()
    }
}

impl EntityDataTrait for CompareUintEntityData {
}

impl GameObjectDataTrait for CompareUintEntityData {
}

impl super::core::DataBusPeerTrait for CompareUintEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CompareUintEntityData {
}

impl super::core::DataContainerTrait for CompareUintEntityData {
}

pub static COMPAREUINTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareUintEntityData",
    name_hash: 660061167,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(COMPAREENTITYBASEDATA_TYPE_INFO),
        super_class_offset: offset_of!(CompareUintEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareUintEntityData as Default>::default())),
            create_boxed: || Box::new(<CompareUintEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "A",
                name_hash: 177636,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(CompareUintEntityData, a),
            },
            FieldInfoData {
                name: "B",
                name_hash: 177639,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(CompareUintEntityData, b),
            },
        ],
    }),
    array_type: Some(COMPAREUINTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CompareUintEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        COMPAREUINTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COMPAREUINTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareUintEntityData-Array",
    name_hash: 3849738715,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareUintEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CompareIntEntityData {
    pub _glacier_base: CompareEntityBaseData,
    pub a: i32,
    pub b: i32,
}

pub trait CompareIntEntityDataTrait: CompareEntityBaseDataTrait {
    fn a(&self) -> &i32;
    fn a_mut(&mut self) -> &mut i32;
    fn b(&self) -> &i32;
    fn b_mut(&mut self) -> &mut i32;
}

impl CompareIntEntityDataTrait for CompareIntEntityData {
    fn a(&self) -> &i32 {
        &self.a
    }
    fn a_mut(&mut self) -> &mut i32 {
        &mut self.a
    }
    fn b(&self) -> &i32 {
        &self.b
    }
    fn b_mut(&mut self) -> &mut i32 {
        &mut self.b
    }
}

impl CompareEntityBaseDataTrait for CompareIntEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn trigger_on_property_change(&self) -> &bool {
        self._glacier_base.trigger_on_property_change()
    }
    fn trigger_on_property_change_mut(&mut self) -> &mut bool {
        self._glacier_base.trigger_on_property_change_mut()
    }
    fn trigger_on_start(&self) -> &bool {
        self._glacier_base.trigger_on_start()
    }
    fn trigger_on_start_mut(&mut self) -> &mut bool {
        self._glacier_base.trigger_on_start_mut()
    }
    fn always_send(&self) -> &bool {
        self._glacier_base.always_send()
    }
    fn always_send_mut(&mut self) -> &mut bool {
        self._glacier_base.always_send_mut()
    }
}

impl EntityDataTrait for CompareIntEntityData {
}

impl GameObjectDataTrait for CompareIntEntityData {
}

impl super::core::DataBusPeerTrait for CompareIntEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CompareIntEntityData {
}

impl super::core::DataContainerTrait for CompareIntEntityData {
}

pub static COMPAREINTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareIntEntityData",
    name_hash: 3241317434,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(COMPAREENTITYBASEDATA_TYPE_INFO),
        super_class_offset: offset_of!(CompareIntEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareIntEntityData as Default>::default())),
            create_boxed: || Box::new(<CompareIntEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "A",
                name_hash: 177636,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CompareIntEntityData, a),
            },
            FieldInfoData {
                name: "B",
                name_hash: 177639,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CompareIntEntityData, b),
            },
        ],
    }),
    array_type: Some(COMPAREINTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CompareIntEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        COMPAREINTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COMPAREINTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareIntEntityData-Array",
    name_hash: 760886926,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareIntEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CompareBoolEntityData {
    pub _glacier_base: CompareEntityBaseData,
    pub bool: bool,
}

pub trait CompareBoolEntityDataTrait: CompareEntityBaseDataTrait {
    fn bool(&self) -> &bool;
    fn bool_mut(&mut self) -> &mut bool;
}

impl CompareBoolEntityDataTrait for CompareBoolEntityData {
    fn bool(&self) -> &bool {
        &self.bool
    }
    fn bool_mut(&mut self) -> &mut bool {
        &mut self.bool
    }
}

impl CompareEntityBaseDataTrait for CompareBoolEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn trigger_on_property_change(&self) -> &bool {
        self._glacier_base.trigger_on_property_change()
    }
    fn trigger_on_property_change_mut(&mut self) -> &mut bool {
        self._glacier_base.trigger_on_property_change_mut()
    }
    fn trigger_on_start(&self) -> &bool {
        self._glacier_base.trigger_on_start()
    }
    fn trigger_on_start_mut(&mut self) -> &mut bool {
        self._glacier_base.trigger_on_start_mut()
    }
    fn always_send(&self) -> &bool {
        self._glacier_base.always_send()
    }
    fn always_send_mut(&mut self) -> &mut bool {
        self._glacier_base.always_send_mut()
    }
}

impl EntityDataTrait for CompareBoolEntityData {
}

impl GameObjectDataTrait for CompareBoolEntityData {
}

impl super::core::DataBusPeerTrait for CompareBoolEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CompareBoolEntityData {
}

impl super::core::DataContainerTrait for CompareBoolEntityData {
}

pub static COMPAREBOOLENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareBoolEntityData",
    name_hash: 1312902887,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(COMPAREENTITYBASEDATA_TYPE_INFO),
        super_class_offset: offset_of!(CompareBoolEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareBoolEntityData as Default>::default())),
            create_boxed: || Box::new(<CompareBoolEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Bool",
                name_hash: 2088812747,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CompareBoolEntityData, bool),
            },
        ],
    }),
    array_type: Some(COMPAREBOOLENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CompareBoolEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        COMPAREBOOLENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COMPAREBOOLENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareBoolEntityData-Array",
    name_hash: 1166201043,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareBoolEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CompareEntityBaseData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub trigger_on_property_change: bool,
    pub trigger_on_start: bool,
    pub always_send: bool,
}

pub trait CompareEntityBaseDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn trigger_on_property_change(&self) -> &bool;
    fn trigger_on_property_change_mut(&mut self) -> &mut bool;
    fn trigger_on_start(&self) -> &bool;
    fn trigger_on_start_mut(&mut self) -> &mut bool;
    fn always_send(&self) -> &bool;
    fn always_send_mut(&mut self) -> &mut bool;
}

impl CompareEntityBaseDataTrait for CompareEntityBaseData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn trigger_on_property_change(&self) -> &bool {
        &self.trigger_on_property_change
    }
    fn trigger_on_property_change_mut(&mut self) -> &mut bool {
        &mut self.trigger_on_property_change
    }
    fn trigger_on_start(&self) -> &bool {
        &self.trigger_on_start
    }
    fn trigger_on_start_mut(&mut self) -> &mut bool {
        &mut self.trigger_on_start
    }
    fn always_send(&self) -> &bool {
        &self.always_send
    }
    fn always_send_mut(&mut self) -> &mut bool {
        &mut self.always_send
    }
}

impl EntityDataTrait for CompareEntityBaseData {
}

impl GameObjectDataTrait for CompareEntityBaseData {
}

impl super::core::DataBusPeerTrait for CompareEntityBaseData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CompareEntityBaseData {
}

impl super::core::DataContainerTrait for CompareEntityBaseData {
}

pub static COMPAREENTITYBASEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareEntityBaseData",
    name_hash: 1595634876,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(CompareEntityBaseData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareEntityBaseData as Default>::default())),
            create_boxed: || Box::new(<CompareEntityBaseData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(CompareEntityBaseData, realm),
            },
            FieldInfoData {
                name: "TriggerOnPropertyChange",
                name_hash: 3134109917,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CompareEntityBaseData, trigger_on_property_change),
            },
            FieldInfoData {
                name: "TriggerOnStart",
                name_hash: 3859836348,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CompareEntityBaseData, trigger_on_start),
            },
            FieldInfoData {
                name: "AlwaysSend",
                name_hash: 579845256,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CompareEntityBaseData, always_send),
            },
        ],
    }),
    array_type: Some(COMPAREENTITYBASEDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for CompareEntityBaseData {
    fn type_info(&self) -> &'static TypeInfo {
        COMPAREENTITYBASEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COMPAREENTITYBASEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareEntityBaseData-Array",
    name_hash: 2458954760,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareEntityBaseData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ClientProfilerData {
    pub _glacier_base: EntityData,
    pub profiler_name: String,
}

pub trait ClientProfilerDataTrait: EntityDataTrait {
    fn profiler_name(&self) -> &String;
    fn profiler_name_mut(&mut self) -> &mut String;
}

impl ClientProfilerDataTrait for ClientProfilerData {
    fn profiler_name(&self) -> &String {
        &self.profiler_name
    }
    fn profiler_name_mut(&mut self) -> &mut String {
        &mut self.profiler_name
    }
}

impl EntityDataTrait for ClientProfilerData {
}

impl GameObjectDataTrait for ClientProfilerData {
}

impl super::core::DataBusPeerTrait for ClientProfilerData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ClientProfilerData {
}

impl super::core::DataContainerTrait for ClientProfilerData {
}

pub static CLIENTPROFILERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClientProfilerData",
    name_hash: 562040981,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(ClientProfilerData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ClientProfilerData as Default>::default())),
            create_boxed: || Box::new(<ClientProfilerData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "ProfilerName",
                name_hash: 3407717723,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ClientProfilerData, profiler_name),
            },
        ],
    }),
    array_type: Some(CLIENTPROFILERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ClientProfilerData {
    fn type_info(&self) -> &'static TypeInfo {
        CLIENTPROFILERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CLIENTPROFILERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClientProfilerData-Array",
    name_hash: 1940283425,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ClientProfilerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ChildEffectEntityData {
    pub _glacier_base: SpatialEntityData,
    pub components: Vec<Option<LockedTypeObject /* GameObjectData */>>,
    pub start_delay: f32,
    pub attach_to_spawn_surface: bool,
    pub enable: super::core::QualityScalableBool,
    pub override_draw_order: bool,
    pub keep_alive: bool,
}

pub trait ChildEffectEntityDataTrait: SpatialEntityDataTrait {
    fn components(&self) -> &Vec<Option<LockedTypeObject /* GameObjectData */>>;
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* GameObjectData */>>;
    fn start_delay(&self) -> &f32;
    fn start_delay_mut(&mut self) -> &mut f32;
    fn attach_to_spawn_surface(&self) -> &bool;
    fn attach_to_spawn_surface_mut(&mut self) -> &mut bool;
    fn enable(&self) -> &super::core::QualityScalableBool;
    fn enable_mut(&mut self) -> &mut super::core::QualityScalableBool;
    fn override_draw_order(&self) -> &bool;
    fn override_draw_order_mut(&mut self) -> &mut bool;
    fn keep_alive(&self) -> &bool;
    fn keep_alive_mut(&mut self) -> &mut bool;
}

impl ChildEffectEntityDataTrait for ChildEffectEntityData {
    fn components(&self) -> &Vec<Option<LockedTypeObject /* GameObjectData */>> {
        &self.components
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* GameObjectData */>> {
        &mut self.components
    }
    fn start_delay(&self) -> &f32 {
        &self.start_delay
    }
    fn start_delay_mut(&mut self) -> &mut f32 {
        &mut self.start_delay
    }
    fn attach_to_spawn_surface(&self) -> &bool {
        &self.attach_to_spawn_surface
    }
    fn attach_to_spawn_surface_mut(&mut self) -> &mut bool {
        &mut self.attach_to_spawn_surface
    }
    fn enable(&self) -> &super::core::QualityScalableBool {
        &self.enable
    }
    fn enable_mut(&mut self) -> &mut super::core::QualityScalableBool {
        &mut self.enable
    }
    fn override_draw_order(&self) -> &bool {
        &self.override_draw_order
    }
    fn override_draw_order_mut(&mut self) -> &mut bool {
        &mut self.override_draw_order
    }
    fn keep_alive(&self) -> &bool {
        &self.keep_alive
    }
    fn keep_alive_mut(&mut self) -> &mut bool {
        &mut self.keep_alive
    }
}

impl SpatialEntityDataTrait for ChildEffectEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl EntityDataTrait for ChildEffectEntityData {
}

impl GameObjectDataTrait for ChildEffectEntityData {
}

impl super::core::DataBusPeerTrait for ChildEffectEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ChildEffectEntityData {
}

impl super::core::DataContainerTrait for ChildEffectEntityData {
}

pub static CHILDEFFECTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ChildEffectEntityData",
    name_hash: 4173154355,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SPATIALENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(ChildEffectEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ChildEffectEntityData as Default>::default())),
            create_boxed: || Box::new(<ChildEffectEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Components",
                name_hash: 3391050425,
                flags: MemberInfoFlags::new(144),
                field_type: "GameObjectData-Array",
                rust_offset: offset_of!(ChildEffectEntityData, components),
            },
            FieldInfoData {
                name: "StartDelay",
                name_hash: 2731915920,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChildEffectEntityData, start_delay),
            },
            FieldInfoData {
                name: "AttachToSpawnSurface",
                name_hash: 4224066779,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ChildEffectEntityData, attach_to_spawn_surface),
            },
            FieldInfoData {
                name: "Enable",
                name_hash: 2342790116,
                flags: MemberInfoFlags::new(0),
                field_type: "QualityScalableBool",
                rust_offset: offset_of!(ChildEffectEntityData, enable),
            },
            FieldInfoData {
                name: "OverrideDrawOrder",
                name_hash: 3411677887,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ChildEffectEntityData, override_draw_order),
            },
            FieldInfoData {
                name: "KeepAlive",
                name_hash: 2097661609,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ChildEffectEntityData, keep_alive),
            },
        ],
    }),
    array_type: Some(CHILDEFFECTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ChildEffectEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CHILDEFFECTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHILDEFFECTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ChildEffectEntityData-Array",
    name_hash: 3916682119,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ChildEffectEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum BundleType {
    #[default]
    BundleType_SubLevel = 0,
    BundleType_BlueprintBundle = 1,
    BundleType_SharedBundle = 2,
}

pub static BUNDLETYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BundleType",
    name_hash: 460109193,
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(BUNDLETYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for BundleType {
    fn type_info(&self) -> &'static TypeInfo {
        BUNDLETYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static BUNDLETYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BundleType-Array",
    name_hash: 3379014461,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("BundleType"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct AutoAssetCollector {
    pub _glacier_base: super::core::DataContainer,
    pub assets: Vec<Option<LockedTypeObject /* super::core::Asset */>>,
    pub auto_collect_minimum_usage_percentage: f32,
}

pub trait AutoAssetCollectorTrait: super::core::DataContainerTrait {
    fn assets(&self) -> &Vec<Option<LockedTypeObject /* super::core::Asset */>>;
    fn assets_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::core::Asset */>>;
    fn auto_collect_minimum_usage_percentage(&self) -> &f32;
    fn auto_collect_minimum_usage_percentage_mut(&mut self) -> &mut f32;
}

impl AutoAssetCollectorTrait for AutoAssetCollector {
    fn assets(&self) -> &Vec<Option<LockedTypeObject /* super::core::Asset */>> {
        &self.assets
    }
    fn assets_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::core::Asset */>> {
        &mut self.assets
    }
    fn auto_collect_minimum_usage_percentage(&self) -> &f32 {
        &self.auto_collect_minimum_usage_percentage
    }
    fn auto_collect_minimum_usage_percentage_mut(&mut self) -> &mut f32 {
        &mut self.auto_collect_minimum_usage_percentage
    }
}

impl super::core::DataContainerTrait for AutoAssetCollector {
}

pub static AUTOASSETCOLLECTOR_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AutoAssetCollector",
    name_hash: 3958760185,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(AutoAssetCollector, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AutoAssetCollector as Default>::default())),
            create_boxed: || Box::new(<AutoAssetCollector as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Assets",
                name_hash: 2502242534,
                flags: MemberInfoFlags::new(144),
                field_type: "Asset-Array",
                rust_offset: offset_of!(AutoAssetCollector, assets),
            },
            FieldInfoData {
                name: "AutoCollectMinimumUsagePercentage",
                name_hash: 1798719391,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AutoAssetCollector, auto_collect_minimum_usage_percentage),
            },
        ],
    }),
    array_type: Some(AUTOASSETCOLLECTOR_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AutoAssetCollector {
    fn type_info(&self) -> &'static TypeInfo {
        AUTOASSETCOLLECTOR_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AUTOASSETCOLLECTOR_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AutoAssetCollector-Array",
    name_hash: 1551671757,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("AutoAssetCollector"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct NetworkedObjectsAsset {
    pub _glacier_base: super::core::Asset,
    pub objects: Vec<Option<LockedTypeObject /* super::core::DataContainer */>>,
}

pub trait NetworkedObjectsAssetTrait: super::core::AssetTrait {
    fn objects(&self) -> &Vec<Option<LockedTypeObject /* super::core::DataContainer */>>;
    fn objects_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::core::DataContainer */>>;
}

impl NetworkedObjectsAssetTrait for NetworkedObjectsAsset {
    fn objects(&self) -> &Vec<Option<LockedTypeObject /* super::core::DataContainer */>> {
        &self.objects
    }
    fn objects_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::core::DataContainer */>> {
        &mut self.objects
    }
}

impl super::core::AssetTrait for NetworkedObjectsAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for NetworkedObjectsAsset {
}

pub static NETWORKEDOBJECTSASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NetworkedObjectsAsset",
    name_hash: 3224882604,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        super_class_offset: offset_of!(NetworkedObjectsAsset, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<NetworkedObjectsAsset as Default>::default())),
            create_boxed: || Box::new(<NetworkedObjectsAsset as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Objects",
                name_hash: 105488131,
                flags: MemberInfoFlags::new(144),
                field_type: "DataContainer-Array",
                rust_offset: offset_of!(NetworkedObjectsAsset, objects),
            },
        ],
    }),
    array_type: Some(NETWORKEDOBJECTSASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for NetworkedObjectsAsset {
    fn type_info(&self) -> &'static TypeInfo {
        NETWORKEDOBJECTSASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static NETWORKEDOBJECTSASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NetworkedObjectsAsset-Array",
    name_hash: 2285436184,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("NetworkedObjectsAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct NetworkRegistryAsset {
    pub _glacier_base: super::core::Asset,
    pub objects: Vec<Option<LockedTypeObject /* super::core::DataContainer */>>,
    pub checksum: u32,
}

pub trait NetworkRegistryAssetTrait: super::core::AssetTrait {
    fn objects(&self) -> &Vec<Option<LockedTypeObject /* super::core::DataContainer */>>;
    fn objects_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::core::DataContainer */>>;
    fn checksum(&self) -> &u32;
    fn checksum_mut(&mut self) -> &mut u32;
}

impl NetworkRegistryAssetTrait for NetworkRegistryAsset {
    fn objects(&self) -> &Vec<Option<LockedTypeObject /* super::core::DataContainer */>> {
        &self.objects
    }
    fn objects_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::core::DataContainer */>> {
        &mut self.objects
    }
    fn checksum(&self) -> &u32 {
        &self.checksum
    }
    fn checksum_mut(&mut self) -> &mut u32 {
        &mut self.checksum
    }
}

impl super::core::AssetTrait for NetworkRegistryAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for NetworkRegistryAsset {
}

pub static NETWORKREGISTRYASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NetworkRegistryAsset",
    name_hash: 1476561886,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        super_class_offset: offset_of!(NetworkRegistryAsset, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<NetworkRegistryAsset as Default>::default())),
            create_boxed: || Box::new(<NetworkRegistryAsset as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Objects",
                name_hash: 105488131,
                flags: MemberInfoFlags::new(144),
                field_type: "DataContainer-Array",
                rust_offset: offset_of!(NetworkRegistryAsset, objects),
            },
            FieldInfoData {
                name: "Checksum",
                name_hash: 1443481128,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(NetworkRegistryAsset, checksum),
            },
        ],
    }),
    array_type: Some(NETWORKREGISTRYASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for NetworkRegistryAsset {
    fn type_info(&self) -> &'static TypeInfo {
        NETWORKREGISTRYASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static NETWORKREGISTRYASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NetworkRegistryAsset-Array",
    name_hash: 2803453290,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("NetworkRegistryAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct BundleHeapInfo {
    pub heap_type: BundleHeapType,
    pub initial_size: u32,
    pub allow_grow: bool,
}

pub trait BundleHeapInfoTrait: TypeObject {
    fn heap_type(&self) -> &BundleHeapType;
    fn heap_type_mut(&mut self) -> &mut BundleHeapType;
    fn initial_size(&self) -> &u32;
    fn initial_size_mut(&mut self) -> &mut u32;
    fn allow_grow(&self) -> &bool;
    fn allow_grow_mut(&mut self) -> &mut bool;
}

impl BundleHeapInfoTrait for BundleHeapInfo {
    fn heap_type(&self) -> &BundleHeapType {
        &self.heap_type
    }
    fn heap_type_mut(&mut self) -> &mut BundleHeapType {
        &mut self.heap_type
    }
    fn initial_size(&self) -> &u32 {
        &self.initial_size
    }
    fn initial_size_mut(&mut self) -> &mut u32 {
        &mut self.initial_size
    }
    fn allow_grow(&self) -> &bool {
        &self.allow_grow
    }
    fn allow_grow_mut(&mut self) -> &mut bool {
        &mut self.allow_grow
    }
}

pub static BUNDLEHEAPINFO_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BundleHeapInfo",
    name_hash: 1819457507,
    flags: MemberInfoFlags::new(36937),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BundleHeapInfo as Default>::default())),
            create_boxed: || Box::new(<BundleHeapInfo as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "HeapType",
                name_hash: 1892364577,
                flags: MemberInfoFlags::new(0),
                field_type: "BundleHeapType",
                rust_offset: offset_of!(BundleHeapInfo, heap_type),
            },
            FieldInfoData {
                name: "InitialSize",
                name_hash: 2584380574,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(BundleHeapInfo, initial_size),
            },
            FieldInfoData {
                name: "AllowGrow",
                name_hash: 2314451249,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BundleHeapInfo, allow_grow),
            },
        ],
    }),
    array_type: Some(BUNDLEHEAPINFO_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for BundleHeapInfo {
    fn type_info(&self) -> &'static TypeInfo {
        BUNDLEHEAPINFO_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static BUNDLEHEAPINFO_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BundleHeapInfo-Array",
    name_hash: 102714327,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("BundleHeapInfo"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum BundleHeapType {
    #[default]
    BundleHeapType_OwnWithParentSmallblock = 0,
    BundleHeapType_OwnWithSmallblock = 1,
    BundleHeapType_OwnWithoutSmallblock = 2,
    BundleHeapType_Parent = 3,
    BundleHeapType_Level = 4,
    BundleHeapType_Global = 5,
    BundleHeapType_Null = 6,
}

pub static BUNDLEHEAPTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BundleHeapType",
    name_hash: 1820115349,
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(BUNDLEHEAPTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for BundleHeapType {
    fn type_info(&self) -> &'static TypeInfo {
        BUNDLEHEAPTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static BUNDLEHEAPTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BundleHeapType-Array",
    name_hash: 262394145,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("BundleHeapType"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct BundleSettingsInfo {
    pub group_identifier: u32,
    pub group_name: String,
}

pub trait BundleSettingsInfoTrait: TypeObject {
    fn group_identifier(&self) -> &u32;
    fn group_identifier_mut(&mut self) -> &mut u32;
    fn group_name(&self) -> &String;
    fn group_name_mut(&mut self) -> &mut String;
}

impl BundleSettingsInfoTrait for BundleSettingsInfo {
    fn group_identifier(&self) -> &u32 {
        &self.group_identifier
    }
    fn group_identifier_mut(&mut self) -> &mut u32 {
        &mut self.group_identifier
    }
    fn group_name(&self) -> &String {
        &self.group_name
    }
    fn group_name_mut(&mut self) -> &mut String {
        &mut self.group_name
    }
}

pub static BUNDLESETTINGSINFO_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BundleSettingsInfo",
    name_hash: 2785571642,
    flags: MemberInfoFlags::new(73),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BundleSettingsInfo as Default>::default())),
            create_boxed: || Box::new(<BundleSettingsInfo as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "GroupIdentifier",
                name_hash: 1147653529,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(BundleSettingsInfo, group_identifier),
            },
            FieldInfoData {
                name: "GroupName",
                name_hash: 3178263901,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(BundleSettingsInfo, group_name),
            },
        ],
    }),
    array_type: Some(BUNDLESETTINGSINFO_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BundleSettingsInfo {
    fn type_info(&self) -> &'static TypeInfo {
        BUNDLESETTINGSINFO_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static BUNDLESETTINGSINFO_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BundleSettingsInfo-Array",
    name_hash: 2564511118,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("BundleSettingsInfo"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct MeshOperationData {
    pub _glacier_base: super::core::DataContainer,
}

pub trait MeshOperationDataTrait: super::core::DataContainerTrait {
}

impl MeshOperationDataTrait for MeshOperationData {
}

impl super::core::DataContainerTrait for MeshOperationData {
}

pub static MESHOPERATIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MeshOperationData",
    name_hash: 2273150003,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(MeshOperationData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MeshOperationData as Default>::default())),
            create_boxed: || Box::new(<MeshOperationData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(MESHOPERATIONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MeshOperationData {
    fn type_info(&self) -> &'static TypeInfo {
        MESHOPERATIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MESHOPERATIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MeshOperationData-Array",
    name_hash: 779161479,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("MeshOperationData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SkeletonBaseAsset {
    pub _glacier_base: super::core::Asset,
}

pub trait SkeletonBaseAssetTrait: super::core::AssetTrait {
}

impl SkeletonBaseAssetTrait for SkeletonBaseAsset {
}

impl super::core::AssetTrait for SkeletonBaseAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for SkeletonBaseAsset {
}

pub static SKELETONBASEASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SkeletonBaseAsset",
    name_hash: 2019976961,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        super_class_offset: offset_of!(SkeletonBaseAsset, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SkeletonBaseAsset as Default>::default())),
            create_boxed: || Box::new(<SkeletonBaseAsset as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(SKELETONBASEASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SkeletonBaseAsset {
    fn type_info(&self) -> &'static TypeInfo {
        SKELETONBASEASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SKELETONBASEASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SkeletonBaseAsset-Array",
    name_hash: 2076254389,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SkeletonBaseAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TransformPartPropertyTrackData {
    pub _glacier_base: PropertyTrackData,
    pub transform_part: TransformPart,
    pub pre_infinity: CurveInfinityType,
    pub post_infinity: CurveInfinityType,
    pub values: Vec<BoxedTypeObject /* TransformPartPropertyKey */>,
    pub evaluator_fps: f32,
    pub weighted: bool,
    pub key_start_index: u32,
    pub key_count: u32,
    pub is_static: bool,
    pub resource: glacier_reflect::builtin::ResourceRef,
}

pub trait TransformPartPropertyTrackDataTrait: PropertyTrackDataTrait {
    fn transform_part(&self) -> &TransformPart;
    fn transform_part_mut(&mut self) -> &mut TransformPart;
    fn pre_infinity(&self) -> &CurveInfinityType;
    fn pre_infinity_mut(&mut self) -> &mut CurveInfinityType;
    fn post_infinity(&self) -> &CurveInfinityType;
    fn post_infinity_mut(&mut self) -> &mut CurveInfinityType;
    fn values(&self) -> &Vec<BoxedTypeObject /* TransformPartPropertyKey */>;
    fn values_mut(&mut self) -> &mut Vec<BoxedTypeObject /* TransformPartPropertyKey */>;
    fn evaluator_fps(&self) -> &f32;
    fn evaluator_fps_mut(&mut self) -> &mut f32;
    fn weighted(&self) -> &bool;
    fn weighted_mut(&mut self) -> &mut bool;
    fn key_start_index(&self) -> &u32;
    fn key_start_index_mut(&mut self) -> &mut u32;
    fn key_count(&self) -> &u32;
    fn key_count_mut(&mut self) -> &mut u32;
    fn is_static(&self) -> &bool;
    fn is_static_mut(&mut self) -> &mut bool;
    fn resource(&self) -> &glacier_reflect::builtin::ResourceRef;
    fn resource_mut(&mut self) -> &mut glacier_reflect::builtin::ResourceRef;
}

impl TransformPartPropertyTrackDataTrait for TransformPartPropertyTrackData {
    fn transform_part(&self) -> &TransformPart {
        &self.transform_part
    }
    fn transform_part_mut(&mut self) -> &mut TransformPart {
        &mut self.transform_part
    }
    fn pre_infinity(&self) -> &CurveInfinityType {
        &self.pre_infinity
    }
    fn pre_infinity_mut(&mut self) -> &mut CurveInfinityType {
        &mut self.pre_infinity
    }
    fn post_infinity(&self) -> &CurveInfinityType {
        &self.post_infinity
    }
    fn post_infinity_mut(&mut self) -> &mut CurveInfinityType {
        &mut self.post_infinity
    }
    fn values(&self) -> &Vec<BoxedTypeObject /* TransformPartPropertyKey */> {
        &self.values
    }
    fn values_mut(&mut self) -> &mut Vec<BoxedTypeObject /* TransformPartPropertyKey */> {
        &mut self.values
    }
    fn evaluator_fps(&self) -> &f32 {
        &self.evaluator_fps
    }
    fn evaluator_fps_mut(&mut self) -> &mut f32 {
        &mut self.evaluator_fps
    }
    fn weighted(&self) -> &bool {
        &self.weighted
    }
    fn weighted_mut(&mut self) -> &mut bool {
        &mut self.weighted
    }
    fn key_start_index(&self) -> &u32 {
        &self.key_start_index
    }
    fn key_start_index_mut(&mut self) -> &mut u32 {
        &mut self.key_start_index
    }
    fn key_count(&self) -> &u32 {
        &self.key_count
    }
    fn key_count_mut(&mut self) -> &mut u32 {
        &mut self.key_count
    }
    fn is_static(&self) -> &bool {
        &self.is_static
    }
    fn is_static_mut(&mut self) -> &mut bool {
        &mut self.is_static
    }
    fn resource(&self) -> &glacier_reflect::builtin::ResourceRef {
        &self.resource
    }
    fn resource_mut(&mut self) -> &mut glacier_reflect::builtin::ResourceRef {
        &mut self.resource
    }
}

impl PropertyTrackDataTrait for TransformPartPropertyTrackData {
    fn id(&self) -> &i32 {
        self._glacier_base.id()
    }
    fn id_mut(&mut self) -> &mut i32 {
        self._glacier_base.id_mut()
    }
    fn times(&self) -> &Vec<i32> {
        self._glacier_base.times()
    }
    fn times_mut(&mut self) -> &mut Vec<i32> {
        self._glacier_base.times_mut()
    }
}

impl super::core::DataContainerTrait for TransformPartPropertyTrackData {
}

pub static TRANSFORMPARTPROPERTYTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformPartPropertyTrackData",
    name_hash: 3797366086,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PROPERTYTRACKDATA_TYPE_INFO),
        super_class_offset: offset_of!(TransformPartPropertyTrackData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformPartPropertyTrackData as Default>::default())),
            create_boxed: || Box::new(<TransformPartPropertyTrackData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "TransformPart",
                name_hash: 3623005534,
                flags: MemberInfoFlags::new(0),
                field_type: "TransformPart",
                rust_offset: offset_of!(TransformPartPropertyTrackData, transform_part),
            },
            FieldInfoData {
                name: "PreInfinity",
                name_hash: 887592928,
                flags: MemberInfoFlags::new(0),
                field_type: "CurveInfinityType",
                rust_offset: offset_of!(TransformPartPropertyTrackData, pre_infinity),
            },
            FieldInfoData {
                name: "PostInfinity",
                name_hash: 1471303071,
                flags: MemberInfoFlags::new(0),
                field_type: "CurveInfinityType",
                rust_offset: offset_of!(TransformPartPropertyTrackData, post_infinity),
            },
            FieldInfoData {
                name: "Values",
                name_hash: 3142410589,
                flags: MemberInfoFlags::new(144),
                field_type: "TransformPartPropertyKey-Array",
                rust_offset: offset_of!(TransformPartPropertyTrackData, values),
            },
            FieldInfoData {
                name: "EvaluatorFps",
                name_hash: 868692579,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TransformPartPropertyTrackData, evaluator_fps),
            },
            FieldInfoData {
                name: "Weighted",
                name_hash: 222605828,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TransformPartPropertyTrackData, weighted),
            },
            FieldInfoData {
                name: "KeyStartIndex",
                name_hash: 331027820,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(TransformPartPropertyTrackData, key_start_index),
            },
            FieldInfoData {
                name: "KeyCount",
                name_hash: 4061186033,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(TransformPartPropertyTrackData, key_count),
            },
            FieldInfoData {
                name: "IsStatic",
                name_hash: 471816263,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TransformPartPropertyTrackData, is_static),
            },
            FieldInfoData {
                name: "Resource",
                name_hash: 74513935,
                flags: MemberInfoFlags::new(0),
                field_type: "ResourceRef",
                rust_offset: offset_of!(TransformPartPropertyTrackData, resource),
            },
        ],
    }),
    array_type: Some(TRANSFORMPARTPROPERTYTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TransformPartPropertyTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMPARTPROPERTYTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TRANSFORMPARTPROPERTYTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformPartPropertyTrackData-Array",
    name_hash: 1033171698,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TransformPartPropertyTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TransformPartPropertyKey {
    pub value: f32,
    pub in_anim_tangent_type: AnimTangentType,
    pub in_angle: f32,
    pub in_weight: f32,
    pub out_anim_tangent_type: AnimTangentType,
    pub out_angle: f32,
    pub out_weight: f32,
}

pub trait TransformPartPropertyKeyTrait: TypeObject {
    fn value(&self) -> &f32;
    fn value_mut(&mut self) -> &mut f32;
    fn in_anim_tangent_type(&self) -> &AnimTangentType;
    fn in_anim_tangent_type_mut(&mut self) -> &mut AnimTangentType;
    fn in_angle(&self) -> &f32;
    fn in_angle_mut(&mut self) -> &mut f32;
    fn in_weight(&self) -> &f32;
    fn in_weight_mut(&mut self) -> &mut f32;
    fn out_anim_tangent_type(&self) -> &AnimTangentType;
    fn out_anim_tangent_type_mut(&mut self) -> &mut AnimTangentType;
    fn out_angle(&self) -> &f32;
    fn out_angle_mut(&mut self) -> &mut f32;
    fn out_weight(&self) -> &f32;
    fn out_weight_mut(&mut self) -> &mut f32;
}

impl TransformPartPropertyKeyTrait for TransformPartPropertyKey {
    fn value(&self) -> &f32 {
        &self.value
    }
    fn value_mut(&mut self) -> &mut f32 {
        &mut self.value
    }
    fn in_anim_tangent_type(&self) -> &AnimTangentType {
        &self.in_anim_tangent_type
    }
    fn in_anim_tangent_type_mut(&mut self) -> &mut AnimTangentType {
        &mut self.in_anim_tangent_type
    }
    fn in_angle(&self) -> &f32 {
        &self.in_angle
    }
    fn in_angle_mut(&mut self) -> &mut f32 {
        &mut self.in_angle
    }
    fn in_weight(&self) -> &f32 {
        &self.in_weight
    }
    fn in_weight_mut(&mut self) -> &mut f32 {
        &mut self.in_weight
    }
    fn out_anim_tangent_type(&self) -> &AnimTangentType {
        &self.out_anim_tangent_type
    }
    fn out_anim_tangent_type_mut(&mut self) -> &mut AnimTangentType {
        &mut self.out_anim_tangent_type
    }
    fn out_angle(&self) -> &f32 {
        &self.out_angle
    }
    fn out_angle_mut(&mut self) -> &mut f32 {
        &mut self.out_angle
    }
    fn out_weight(&self) -> &f32 {
        &self.out_weight
    }
    fn out_weight_mut(&mut self) -> &mut f32 {
        &mut self.out_weight
    }
}

pub static TRANSFORMPARTPROPERTYKEY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformPartPropertyKey",
    name_hash: 2787959790,
    flags: MemberInfoFlags::new(36937),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformPartPropertyKey as Default>::default())),
            create_boxed: || Box::new(<TransformPartPropertyKey as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Value",
                name_hash: 225375086,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TransformPartPropertyKey, value),
            },
            FieldInfoData {
                name: "InAnimTangentType",
                name_hash: 2457732018,
                flags: MemberInfoFlags::new(0),
                field_type: "AnimTangentType",
                rust_offset: offset_of!(TransformPartPropertyKey, in_anim_tangent_type),
            },
            FieldInfoData {
                name: "InAngle",
                name_hash: 1631648579,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TransformPartPropertyKey, in_angle),
            },
            FieldInfoData {
                name: "InWeight",
                name_hash: 3141238946,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TransformPartPropertyKey, in_weight),
            },
            FieldInfoData {
                name: "OutAnimTangentType",
                name_hash: 741684763,
                flags: MemberInfoFlags::new(0),
                field_type: "AnimTangentType",
                rust_offset: offset_of!(TransformPartPropertyKey, out_anim_tangent_type),
            },
            FieldInfoData {
                name: "OutAngle",
                name_hash: 968880426,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TransformPartPropertyKey, out_angle),
            },
            FieldInfoData {
                name: "OutWeight",
                name_hash: 2466352171,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TransformPartPropertyKey, out_weight),
            },
        ],
    }),
    array_type: Some(TRANSFORMPARTPROPERTYKEY_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for TransformPartPropertyKey {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMPARTPROPERTYKEY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static TRANSFORMPARTPROPERTYKEY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformPartPropertyKey-Array",
    name_hash: 2728262874,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TransformPartPropertyKey"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum AnimTangentType {
    #[default]
    kTangentFixed = 0,
    kTangentLinear = 1,
    kTangentFlat = 2,
    kTangentStep = 3,
    kTangentStepNext = 4,
    kTangentSlow = 5,
    kTangentFast = 6,
    kTangentSmooth = 7,
    kTangentClamped = 8,
}

pub static ANIMTANGENTTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimTangentType",
    name_hash: 2982156949,
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(ANIMTANGENTTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AnimTangentType {
    fn type_info(&self) -> &'static TypeInfo {
        ANIMTANGENTTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ANIMTANGENTTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimTangentType-Array",
    name_hash: 4198885921,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("AnimTangentType"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CurveInfinityType {
    #[default]
    CurveInfinityType_Constant = 0,
    CurveInfinityType_Linear = 1,
    CurveInfinityType_Cycle = 2,
    CurveInfinityType_CycleWithOffset = 3,
    CurveInfinityType_Oscillate = 4,
}

pub static CURVEINFINITYTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CurveInfinityType",
    name_hash: 4020299688,
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(CURVEINFINITYTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CurveInfinityType {
    fn type_info(&self) -> &'static TypeInfo {
        CURVEINFINITYTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CURVEINFINITYTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CurveInfinityType-Array",
    name_hash: 726526236,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CurveInfinityType"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum TransformPart {
    #[default]
    TransformPart_TranslationX = 0,
    TransformPart_TranslationY = 1,
    TransformPart_TranslationZ = 2,
    TransformPart_RotationX = 3,
    TransformPart_RotationY = 4,
    TransformPart_RotationZ = 5,
}

pub static TRANSFORMPART_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformPart",
    name_hash: 3623005534,
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(TRANSFORMPART_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for TransformPart {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMPART_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static TRANSFORMPART_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformPart-Array",
    name_hash: 435982058,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TransformPart"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct Vec4PropertyTrackData {
    pub _glacier_base: SimplePropertyTrackData,
    pub values: Vec<BoxedTypeObject /* super::core::Vec4 */>,
}

pub trait Vec4PropertyTrackDataTrait: SimplePropertyTrackDataTrait {
    fn values(&self) -> &Vec<BoxedTypeObject /* super::core::Vec4 */>;
    fn values_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::Vec4 */>;
}

impl Vec4PropertyTrackDataTrait for Vec4PropertyTrackData {
    fn values(&self) -> &Vec<BoxedTypeObject /* super::core::Vec4 */> {
        &self.values
    }
    fn values_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::Vec4 */> {
        &mut self.values
    }
}

impl SimplePropertyTrackDataTrait for Vec4PropertyTrackData {
    fn interpolation_type(&self) -> &InterpolationType {
        self._glacier_base.interpolation_type()
    }
    fn interpolation_type_mut(&mut self) -> &mut InterpolationType {
        self._glacier_base.interpolation_type_mut()
    }
}

impl PropertyTrackDataTrait for Vec4PropertyTrackData {
    fn id(&self) -> &i32 {
        self._glacier_base.id()
    }
    fn id_mut(&mut self) -> &mut i32 {
        self._glacier_base.id_mut()
    }
    fn times(&self) -> &Vec<i32> {
        self._glacier_base.times()
    }
    fn times_mut(&mut self) -> &mut Vec<i32> {
        self._glacier_base.times_mut()
    }
}

impl super::core::DataContainerTrait for Vec4PropertyTrackData {
}

pub static VEC4PROPERTYTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec4PropertyTrackData",
    name_hash: 3800725561,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SIMPLEPROPERTYTRACKDATA_TYPE_INFO),
        super_class_offset: offset_of!(Vec4PropertyTrackData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec4PropertyTrackData as Default>::default())),
            create_boxed: || Box::new(<Vec4PropertyTrackData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Values",
                name_hash: 3142410589,
                flags: MemberInfoFlags::new(144),
                field_type: "Vec4-Array",
                rust_offset: offset_of!(Vec4PropertyTrackData, values),
            },
        ],
    }),
    array_type: Some(VEC4PROPERTYTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for Vec4PropertyTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        VEC4PROPERTYTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEC4PROPERTYTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec4PropertyTrackData-Array",
    name_hash: 3433817741,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec4PropertyTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct Vec3PropertyTrackData {
    pub _glacier_base: SimplePropertyTrackData,
    pub values: Vec<BoxedTypeObject /* super::core::Vec3 */>,
}

pub trait Vec3PropertyTrackDataTrait: SimplePropertyTrackDataTrait {
    fn values(&self) -> &Vec<BoxedTypeObject /* super::core::Vec3 */>;
    fn values_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::Vec3 */>;
}

impl Vec3PropertyTrackDataTrait for Vec3PropertyTrackData {
    fn values(&self) -> &Vec<BoxedTypeObject /* super::core::Vec3 */> {
        &self.values
    }
    fn values_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::Vec3 */> {
        &mut self.values
    }
}

impl SimplePropertyTrackDataTrait for Vec3PropertyTrackData {
    fn interpolation_type(&self) -> &InterpolationType {
        self._glacier_base.interpolation_type()
    }
    fn interpolation_type_mut(&mut self) -> &mut InterpolationType {
        self._glacier_base.interpolation_type_mut()
    }
}

impl PropertyTrackDataTrait for Vec3PropertyTrackData {
    fn id(&self) -> &i32 {
        self._glacier_base.id()
    }
    fn id_mut(&mut self) -> &mut i32 {
        self._glacier_base.id_mut()
    }
    fn times(&self) -> &Vec<i32> {
        self._glacier_base.times()
    }
    fn times_mut(&mut self) -> &mut Vec<i32> {
        self._glacier_base.times_mut()
    }
}

impl super::core::DataContainerTrait for Vec3PropertyTrackData {
}

pub static VEC3PROPERTYTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3PropertyTrackData",
    name_hash: 2895536542,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SIMPLEPROPERTYTRACKDATA_TYPE_INFO),
        super_class_offset: offset_of!(Vec3PropertyTrackData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec3PropertyTrackData as Default>::default())),
            create_boxed: || Box::new(<Vec3PropertyTrackData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Values",
                name_hash: 3142410589,
                flags: MemberInfoFlags::new(144),
                field_type: "Vec3-Array",
                rust_offset: offset_of!(Vec3PropertyTrackData, values),
            },
        ],
    }),
    array_type: Some(VEC3PROPERTYTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for Vec3PropertyTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        VEC3PROPERTYTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEC3PROPERTYTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3PropertyTrackData-Array",
    name_hash: 3302372010,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec3PropertyTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct Vec2PropertyTrackData {
    pub _glacier_base: SimplePropertyTrackData,
    pub values: Vec<BoxedTypeObject /* super::core::Vec2 */>,
}

pub trait Vec2PropertyTrackDataTrait: SimplePropertyTrackDataTrait {
    fn values(&self) -> &Vec<BoxedTypeObject /* super::core::Vec2 */>;
    fn values_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::Vec2 */>;
}

impl Vec2PropertyTrackDataTrait for Vec2PropertyTrackData {
    fn values(&self) -> &Vec<BoxedTypeObject /* super::core::Vec2 */> {
        &self.values
    }
    fn values_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::Vec2 */> {
        &mut self.values
    }
}

impl SimplePropertyTrackDataTrait for Vec2PropertyTrackData {
    fn interpolation_type(&self) -> &InterpolationType {
        self._glacier_base.interpolation_type()
    }
    fn interpolation_type_mut(&mut self) -> &mut InterpolationType {
        self._glacier_base.interpolation_type_mut()
    }
}

impl PropertyTrackDataTrait for Vec2PropertyTrackData {
    fn id(&self) -> &i32 {
        self._glacier_base.id()
    }
    fn id_mut(&mut self) -> &mut i32 {
        self._glacier_base.id_mut()
    }
    fn times(&self) -> &Vec<i32> {
        self._glacier_base.times()
    }
    fn times_mut(&mut self) -> &mut Vec<i32> {
        self._glacier_base.times_mut()
    }
}

impl super::core::DataContainerTrait for Vec2PropertyTrackData {
}

pub static VEC2PROPERTYTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec2PropertyTrackData",
    name_hash: 2168216703,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SIMPLEPROPERTYTRACKDATA_TYPE_INFO),
        super_class_offset: offset_of!(Vec2PropertyTrackData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec2PropertyTrackData as Default>::default())),
            create_boxed: || Box::new(<Vec2PropertyTrackData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Values",
                name_hash: 3142410589,
                flags: MemberInfoFlags::new(144),
                field_type: "Vec2-Array",
                rust_offset: offset_of!(Vec2PropertyTrackData, values),
            },
        ],
    }),
    array_type: Some(VEC2PROPERTYTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for Vec2PropertyTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        VEC2PROPERTYTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEC2PROPERTYTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec2PropertyTrackData-Array",
    name_hash: 3439600203,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec2PropertyTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TransformPropertyTrackData {
    pub _glacier_base: SimplePropertyTrackData,
    pub values: Vec<BoxedTypeObject /* super::core::LinearTransform */>,
}

pub trait TransformPropertyTrackDataTrait: SimplePropertyTrackDataTrait {
    fn values(&self) -> &Vec<BoxedTypeObject /* super::core::LinearTransform */>;
    fn values_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::LinearTransform */>;
}

impl TransformPropertyTrackDataTrait for TransformPropertyTrackData {
    fn values(&self) -> &Vec<BoxedTypeObject /* super::core::LinearTransform */> {
        &self.values
    }
    fn values_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::LinearTransform */> {
        &mut self.values
    }
}

impl SimplePropertyTrackDataTrait for TransformPropertyTrackData {
    fn interpolation_type(&self) -> &InterpolationType {
        self._glacier_base.interpolation_type()
    }
    fn interpolation_type_mut(&mut self) -> &mut InterpolationType {
        self._glacier_base.interpolation_type_mut()
    }
}

impl PropertyTrackDataTrait for TransformPropertyTrackData {
    fn id(&self) -> &i32 {
        self._glacier_base.id()
    }
    fn id_mut(&mut self) -> &mut i32 {
        self._glacier_base.id_mut()
    }
    fn times(&self) -> &Vec<i32> {
        self._glacier_base.times()
    }
    fn times_mut(&mut self) -> &mut Vec<i32> {
        self._glacier_base.times_mut()
    }
}

impl super::core::DataContainerTrait for TransformPropertyTrackData {
}

pub static TRANSFORMPROPERTYTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformPropertyTrackData",
    name_hash: 2785092241,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SIMPLEPROPERTYTRACKDATA_TYPE_INFO),
        super_class_offset: offset_of!(TransformPropertyTrackData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformPropertyTrackData as Default>::default())),
            create_boxed: || Box::new(<TransformPropertyTrackData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Values",
                name_hash: 3142410589,
                flags: MemberInfoFlags::new(144),
                field_type: "LinearTransform-Array",
                rust_offset: offset_of!(TransformPropertyTrackData, values),
            },
        ],
    }),
    array_type: Some(TRANSFORMPROPERTYTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TransformPropertyTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMPROPERTYTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TRANSFORMPROPERTYTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformPropertyTrackData-Array",
    name_hash: 200098853,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TransformPropertyTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct IntPropertyTrackData {
    pub _glacier_base: SimplePropertyTrackData,
    pub values: Vec<i32>,
}

pub trait IntPropertyTrackDataTrait: SimplePropertyTrackDataTrait {
    fn values(&self) -> &Vec<i32>;
    fn values_mut(&mut self) -> &mut Vec<i32>;
}

impl IntPropertyTrackDataTrait for IntPropertyTrackData {
    fn values(&self) -> &Vec<i32> {
        &self.values
    }
    fn values_mut(&mut self) -> &mut Vec<i32> {
        &mut self.values
    }
}

impl SimplePropertyTrackDataTrait for IntPropertyTrackData {
    fn interpolation_type(&self) -> &InterpolationType {
        self._glacier_base.interpolation_type()
    }
    fn interpolation_type_mut(&mut self) -> &mut InterpolationType {
        self._glacier_base.interpolation_type_mut()
    }
}

impl PropertyTrackDataTrait for IntPropertyTrackData {
    fn id(&self) -> &i32 {
        self._glacier_base.id()
    }
    fn id_mut(&mut self) -> &mut i32 {
        self._glacier_base.id_mut()
    }
    fn times(&self) -> &Vec<i32> {
        self._glacier_base.times()
    }
    fn times_mut(&mut self) -> &mut Vec<i32> {
        self._glacier_base.times_mut()
    }
}

impl super::core::DataContainerTrait for IntPropertyTrackData {
}

pub static INTPROPERTYTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntPropertyTrackData",
    name_hash: 141954862,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SIMPLEPROPERTYTRACKDATA_TYPE_INFO),
        super_class_offset: offset_of!(IntPropertyTrackData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<IntPropertyTrackData as Default>::default())),
            create_boxed: || Box::new(<IntPropertyTrackData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Values",
                name_hash: 3142410589,
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(IntPropertyTrackData, values),
            },
        ],
    }),
    array_type: Some(INTPROPERTYTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for IntPropertyTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        INTPROPERTYTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static INTPROPERTYTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntPropertyTrackData-Array",
    name_hash: 666556314,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("IntPropertyTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct FloatPropertyTrackData {
    pub _glacier_base: SimplePropertyTrackData,
    pub values: Vec<f32>,
}

pub trait FloatPropertyTrackDataTrait: SimplePropertyTrackDataTrait {
    fn values(&self) -> &Vec<f32>;
    fn values_mut(&mut self) -> &mut Vec<f32>;
}

impl FloatPropertyTrackDataTrait for FloatPropertyTrackData {
    fn values(&self) -> &Vec<f32> {
        &self.values
    }
    fn values_mut(&mut self) -> &mut Vec<f32> {
        &mut self.values
    }
}

impl SimplePropertyTrackDataTrait for FloatPropertyTrackData {
    fn interpolation_type(&self) -> &InterpolationType {
        self._glacier_base.interpolation_type()
    }
    fn interpolation_type_mut(&mut self) -> &mut InterpolationType {
        self._glacier_base.interpolation_type_mut()
    }
}

impl PropertyTrackDataTrait for FloatPropertyTrackData {
    fn id(&self) -> &i32 {
        self._glacier_base.id()
    }
    fn id_mut(&mut self) -> &mut i32 {
        self._glacier_base.id_mut()
    }
    fn times(&self) -> &Vec<i32> {
        self._glacier_base.times()
    }
    fn times_mut(&mut self) -> &mut Vec<i32> {
        self._glacier_base.times_mut()
    }
}

impl super::core::DataContainerTrait for FloatPropertyTrackData {
}

pub static FLOATPROPERTYTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatPropertyTrackData",
    name_hash: 2570683501,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SIMPLEPROPERTYTRACKDATA_TYPE_INFO),
        super_class_offset: offset_of!(FloatPropertyTrackData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FloatPropertyTrackData as Default>::default())),
            create_boxed: || Box::new(<FloatPropertyTrackData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Values",
                name_hash: 3142410589,
                flags: MemberInfoFlags::new(144),
                field_type: "Float32-Array",
                rust_offset: offset_of!(FloatPropertyTrackData, values),
            },
        ],
    }),
    array_type: Some(FLOATPROPERTYTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FloatPropertyTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        FLOATPROPERTYTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FLOATPROPERTYTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatPropertyTrackData-Array",
    name_hash: 3741337945,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("FloatPropertyTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct BoolPropertyTrackData {
    pub _glacier_base: SimplePropertyTrackData,
    pub values: Vec<bool>,
}

pub trait BoolPropertyTrackDataTrait: SimplePropertyTrackDataTrait {
    fn values(&self) -> &Vec<bool>;
    fn values_mut(&mut self) -> &mut Vec<bool>;
}

impl BoolPropertyTrackDataTrait for BoolPropertyTrackData {
    fn values(&self) -> &Vec<bool> {
        &self.values
    }
    fn values_mut(&mut self) -> &mut Vec<bool> {
        &mut self.values
    }
}

impl SimplePropertyTrackDataTrait for BoolPropertyTrackData {
    fn interpolation_type(&self) -> &InterpolationType {
        self._glacier_base.interpolation_type()
    }
    fn interpolation_type_mut(&mut self) -> &mut InterpolationType {
        self._glacier_base.interpolation_type_mut()
    }
}

impl PropertyTrackDataTrait for BoolPropertyTrackData {
    fn id(&self) -> &i32 {
        self._glacier_base.id()
    }
    fn id_mut(&mut self) -> &mut i32 {
        self._glacier_base.id_mut()
    }
    fn times(&self) -> &Vec<i32> {
        self._glacier_base.times()
    }
    fn times_mut(&mut self) -> &mut Vec<i32> {
        self._glacier_base.times_mut()
    }
}

impl super::core::DataContainerTrait for BoolPropertyTrackData {
}

pub static BOOLPROPERTYTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolPropertyTrackData",
    name_hash: 3369755699,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SIMPLEPROPERTYTRACKDATA_TYPE_INFO),
        super_class_offset: offset_of!(BoolPropertyTrackData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BoolPropertyTrackData as Default>::default())),
            create_boxed: || Box::new(<BoolPropertyTrackData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Values",
                name_hash: 3142410589,
                flags: MemberInfoFlags::new(144),
                field_type: "Boolean-Array",
                rust_offset: offset_of!(BoolPropertyTrackData, values),
            },
        ],
    }),
    array_type: Some(BOOLPROPERTYTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BoolPropertyTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        BOOLPROPERTYTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BOOLPROPERTYTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolPropertyTrackData-Array",
    name_hash: 4193644423,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("BoolPropertyTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SimplePropertyTrackData {
    pub _glacier_base: PropertyTrackData,
    pub interpolation_type: InterpolationType,
}

pub trait SimplePropertyTrackDataTrait: PropertyTrackDataTrait {
    fn interpolation_type(&self) -> &InterpolationType;
    fn interpolation_type_mut(&mut self) -> &mut InterpolationType;
}

impl SimplePropertyTrackDataTrait for SimplePropertyTrackData {
    fn interpolation_type(&self) -> &InterpolationType {
        &self.interpolation_type
    }
    fn interpolation_type_mut(&mut self) -> &mut InterpolationType {
        &mut self.interpolation_type
    }
}

impl PropertyTrackDataTrait for SimplePropertyTrackData {
    fn id(&self) -> &i32 {
        self._glacier_base.id()
    }
    fn id_mut(&mut self) -> &mut i32 {
        self._glacier_base.id_mut()
    }
    fn times(&self) -> &Vec<i32> {
        self._glacier_base.times()
    }
    fn times_mut(&mut self) -> &mut Vec<i32> {
        self._glacier_base.times_mut()
    }
}

impl super::core::DataContainerTrait for SimplePropertyTrackData {
}

pub static SIMPLEPROPERTYTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimplePropertyTrackData",
    name_hash: 2954023379,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PROPERTYTRACKDATA_TYPE_INFO),
        super_class_offset: offset_of!(SimplePropertyTrackData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SimplePropertyTrackData as Default>::default())),
            create_boxed: || Box::new(<SimplePropertyTrackData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "InterpolationType",
                name_hash: 1709219799,
                flags: MemberInfoFlags::new(0),
                field_type: "InterpolationType",
                rust_offset: offset_of!(SimplePropertyTrackData, interpolation_type),
            },
        ],
    }),
    array_type: Some(SIMPLEPROPERTYTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SimplePropertyTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        SIMPLEPROPERTYTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SIMPLEPROPERTYTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimplePropertyTrackData-Array",
    name_hash: 2109578471,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SimplePropertyTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SequenceEntityData {
    pub _glacier_base: EntityData,
    pub events: Vec<BoxedTypeObject /* SequenceEventData */>,
    pub sequence_start_time: i32,
    pub sequence_length: i32,
    pub looping: bool,
    pub auto_start: bool,
    pub auto_play_first_frame: bool,
    pub play_in_reverse: bool,
    pub realm: super::core::Realm,
    pub property_tracks: Vec<Option<LockedTypeObject /* PropertyTrackData */>>,
    pub custom_sequence_tracks: Vec<Option<LockedTypeObject /* CustomSequenceTrackData */>>,
    pub client_update_pass: UpdatePass,
    pub server_update_pass: UpdatePass,
    pub external_time: f32,
    pub playback_speed: f32,
}

pub trait SequenceEntityDataTrait: EntityDataTrait {
    fn events(&self) -> &Vec<BoxedTypeObject /* SequenceEventData */>;
    fn events_mut(&mut self) -> &mut Vec<BoxedTypeObject /* SequenceEventData */>;
    fn sequence_start_time(&self) -> &i32;
    fn sequence_start_time_mut(&mut self) -> &mut i32;
    fn sequence_length(&self) -> &i32;
    fn sequence_length_mut(&mut self) -> &mut i32;
    fn looping(&self) -> &bool;
    fn looping_mut(&mut self) -> &mut bool;
    fn auto_start(&self) -> &bool;
    fn auto_start_mut(&mut self) -> &mut bool;
    fn auto_play_first_frame(&self) -> &bool;
    fn auto_play_first_frame_mut(&mut self) -> &mut bool;
    fn play_in_reverse(&self) -> &bool;
    fn play_in_reverse_mut(&mut self) -> &mut bool;
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn property_tracks(&self) -> &Vec<Option<LockedTypeObject /* PropertyTrackData */>>;
    fn property_tracks_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* PropertyTrackData */>>;
    fn custom_sequence_tracks(&self) -> &Vec<Option<LockedTypeObject /* CustomSequenceTrackData */>>;
    fn custom_sequence_tracks_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* CustomSequenceTrackData */>>;
    fn client_update_pass(&self) -> &UpdatePass;
    fn client_update_pass_mut(&mut self) -> &mut UpdatePass;
    fn server_update_pass(&self) -> &UpdatePass;
    fn server_update_pass_mut(&mut self) -> &mut UpdatePass;
    fn external_time(&self) -> &f32;
    fn external_time_mut(&mut self) -> &mut f32;
    fn playback_speed(&self) -> &f32;
    fn playback_speed_mut(&mut self) -> &mut f32;
}

impl SequenceEntityDataTrait for SequenceEntityData {
    fn events(&self) -> &Vec<BoxedTypeObject /* SequenceEventData */> {
        &self.events
    }
    fn events_mut(&mut self) -> &mut Vec<BoxedTypeObject /* SequenceEventData */> {
        &mut self.events
    }
    fn sequence_start_time(&self) -> &i32 {
        &self.sequence_start_time
    }
    fn sequence_start_time_mut(&mut self) -> &mut i32 {
        &mut self.sequence_start_time
    }
    fn sequence_length(&self) -> &i32 {
        &self.sequence_length
    }
    fn sequence_length_mut(&mut self) -> &mut i32 {
        &mut self.sequence_length
    }
    fn looping(&self) -> &bool {
        &self.looping
    }
    fn looping_mut(&mut self) -> &mut bool {
        &mut self.looping
    }
    fn auto_start(&self) -> &bool {
        &self.auto_start
    }
    fn auto_start_mut(&mut self) -> &mut bool {
        &mut self.auto_start
    }
    fn auto_play_first_frame(&self) -> &bool {
        &self.auto_play_first_frame
    }
    fn auto_play_first_frame_mut(&mut self) -> &mut bool {
        &mut self.auto_play_first_frame
    }
    fn play_in_reverse(&self) -> &bool {
        &self.play_in_reverse
    }
    fn play_in_reverse_mut(&mut self) -> &mut bool {
        &mut self.play_in_reverse
    }
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn property_tracks(&self) -> &Vec<Option<LockedTypeObject /* PropertyTrackData */>> {
        &self.property_tracks
    }
    fn property_tracks_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* PropertyTrackData */>> {
        &mut self.property_tracks
    }
    fn custom_sequence_tracks(&self) -> &Vec<Option<LockedTypeObject /* CustomSequenceTrackData */>> {
        &self.custom_sequence_tracks
    }
    fn custom_sequence_tracks_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* CustomSequenceTrackData */>> {
        &mut self.custom_sequence_tracks
    }
    fn client_update_pass(&self) -> &UpdatePass {
        &self.client_update_pass
    }
    fn client_update_pass_mut(&mut self) -> &mut UpdatePass {
        &mut self.client_update_pass
    }
    fn server_update_pass(&self) -> &UpdatePass {
        &self.server_update_pass
    }
    fn server_update_pass_mut(&mut self) -> &mut UpdatePass {
        &mut self.server_update_pass
    }
    fn external_time(&self) -> &f32 {
        &self.external_time
    }
    fn external_time_mut(&mut self) -> &mut f32 {
        &mut self.external_time
    }
    fn playback_speed(&self) -> &f32 {
        &self.playback_speed
    }
    fn playback_speed_mut(&mut self) -> &mut f32 {
        &mut self.playback_speed
    }
}

impl EntityDataTrait for SequenceEntityData {
}

impl GameObjectDataTrait for SequenceEntityData {
}

impl super::core::DataBusPeerTrait for SequenceEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SequenceEntityData {
}

impl super::core::DataContainerTrait for SequenceEntityData {
}

pub static SEQUENCEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SequenceEntityData",
    name_hash: 1001057937,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(SequenceEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SequenceEntityData as Default>::default())),
            create_boxed: || Box::new(<SequenceEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Events",
                name_hash: 2352146554,
                flags: MemberInfoFlags::new(144),
                field_type: "SequenceEventData-Array",
                rust_offset: offset_of!(SequenceEntityData, events),
            },
            FieldInfoData {
                name: "SequenceStartTime",
                name_hash: 1603593583,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SequenceEntityData, sequence_start_time),
            },
            FieldInfoData {
                name: "SequenceLength",
                name_hash: 2068204742,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SequenceEntityData, sequence_length),
            },
            FieldInfoData {
                name: "Looping",
                name_hash: 1366646169,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SequenceEntityData, looping),
            },
            FieldInfoData {
                name: "AutoStart",
                name_hash: 792615882,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SequenceEntityData, auto_start),
            },
            FieldInfoData {
                name: "AutoPlayFirstFrame",
                name_hash: 3638007145,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SequenceEntityData, auto_play_first_frame),
            },
            FieldInfoData {
                name: "PlayInReverse",
                name_hash: 2845503782,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SequenceEntityData, play_in_reverse),
            },
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(SequenceEntityData, realm),
            },
            FieldInfoData {
                name: "PropertyTracks",
                name_hash: 3471592734,
                flags: MemberInfoFlags::new(144),
                field_type: "PropertyTrackData-Array",
                rust_offset: offset_of!(SequenceEntityData, property_tracks),
            },
            FieldInfoData {
                name: "CustomSequenceTracks",
                name_hash: 2058346709,
                flags: MemberInfoFlags::new(144),
                field_type: "CustomSequenceTrackData-Array",
                rust_offset: offset_of!(SequenceEntityData, custom_sequence_tracks),
            },
            FieldInfoData {
                name: "ClientUpdatePass",
                name_hash: 2631769212,
                flags: MemberInfoFlags::new(0),
                field_type: "UpdatePass",
                rust_offset: offset_of!(SequenceEntityData, client_update_pass),
            },
            FieldInfoData {
                name: "ServerUpdatePass",
                name_hash: 2515352480,
                flags: MemberInfoFlags::new(0),
                field_type: "UpdatePass",
                rust_offset: offset_of!(SequenceEntityData, server_update_pass),
            },
            FieldInfoData {
                name: "ExternalTime",
                name_hash: 2162678253,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SequenceEntityData, external_time),
            },
            FieldInfoData {
                name: "PlaybackSpeed",
                name_hash: 2521405901,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SequenceEntityData, playback_speed),
            },
        ],
    }),
    array_type: Some(SEQUENCEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SequenceEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SEQUENCEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SEQUENCEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SequenceEntityData-Array",
    name_hash: 3837792293,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SequenceEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CustomSequenceTrackData {
    pub _glacier_base: EntityData,
    pub track_name: String,
    pub input_link_map: Vec<Option<LockedTypeObject /* CustomSequenceTrackLinkMapping */>>,
    pub output_link_map: Vec<Option<LockedTypeObject /* CustomSequenceTrackLinkMapping */>>,
    pub event_map: Vec<Option<LockedTypeObject /* CustomSequenceTrackEventMapping */>>,
    pub source_property_map: Vec<Option<LockedTypeObject /* CustomSequenceTrackPropertyMapping */>>,
    pub target_property_map: Vec<Option<LockedTypeObject /* CustomSequenceTrackPropertyMapping */>>,
    pub source_and_target_property_map: Vec<Option<LockedTypeObject /* CustomSequenceTrackPropertyMapping */>>,
}

pub trait CustomSequenceTrackDataTrait: EntityDataTrait {
    fn track_name(&self) -> &String;
    fn track_name_mut(&mut self) -> &mut String;
    fn input_link_map(&self) -> &Vec<Option<LockedTypeObject /* CustomSequenceTrackLinkMapping */>>;
    fn input_link_map_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* CustomSequenceTrackLinkMapping */>>;
    fn output_link_map(&self) -> &Vec<Option<LockedTypeObject /* CustomSequenceTrackLinkMapping */>>;
    fn output_link_map_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* CustomSequenceTrackLinkMapping */>>;
    fn event_map(&self) -> &Vec<Option<LockedTypeObject /* CustomSequenceTrackEventMapping */>>;
    fn event_map_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* CustomSequenceTrackEventMapping */>>;
    fn source_property_map(&self) -> &Vec<Option<LockedTypeObject /* CustomSequenceTrackPropertyMapping */>>;
    fn source_property_map_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* CustomSequenceTrackPropertyMapping */>>;
    fn target_property_map(&self) -> &Vec<Option<LockedTypeObject /* CustomSequenceTrackPropertyMapping */>>;
    fn target_property_map_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* CustomSequenceTrackPropertyMapping */>>;
    fn source_and_target_property_map(&self) -> &Vec<Option<LockedTypeObject /* CustomSequenceTrackPropertyMapping */>>;
    fn source_and_target_property_map_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* CustomSequenceTrackPropertyMapping */>>;
}

impl CustomSequenceTrackDataTrait for CustomSequenceTrackData {
    fn track_name(&self) -> &String {
        &self.track_name
    }
    fn track_name_mut(&mut self) -> &mut String {
        &mut self.track_name
    }
    fn input_link_map(&self) -> &Vec<Option<LockedTypeObject /* CustomSequenceTrackLinkMapping */>> {
        &self.input_link_map
    }
    fn input_link_map_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* CustomSequenceTrackLinkMapping */>> {
        &mut self.input_link_map
    }
    fn output_link_map(&self) -> &Vec<Option<LockedTypeObject /* CustomSequenceTrackLinkMapping */>> {
        &self.output_link_map
    }
    fn output_link_map_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* CustomSequenceTrackLinkMapping */>> {
        &mut self.output_link_map
    }
    fn event_map(&self) -> &Vec<Option<LockedTypeObject /* CustomSequenceTrackEventMapping */>> {
        &self.event_map
    }
    fn event_map_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* CustomSequenceTrackEventMapping */>> {
        &mut self.event_map
    }
    fn source_property_map(&self) -> &Vec<Option<LockedTypeObject /* CustomSequenceTrackPropertyMapping */>> {
        &self.source_property_map
    }
    fn source_property_map_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* CustomSequenceTrackPropertyMapping */>> {
        &mut self.source_property_map
    }
    fn target_property_map(&self) -> &Vec<Option<LockedTypeObject /* CustomSequenceTrackPropertyMapping */>> {
        &self.target_property_map
    }
    fn target_property_map_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* CustomSequenceTrackPropertyMapping */>> {
        &mut self.target_property_map
    }
    fn source_and_target_property_map(&self) -> &Vec<Option<LockedTypeObject /* CustomSequenceTrackPropertyMapping */>> {
        &self.source_and_target_property_map
    }
    fn source_and_target_property_map_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* CustomSequenceTrackPropertyMapping */>> {
        &mut self.source_and_target_property_map
    }
}

impl EntityDataTrait for CustomSequenceTrackData {
}

impl GameObjectDataTrait for CustomSequenceTrackData {
}

impl super::core::DataBusPeerTrait for CustomSequenceTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CustomSequenceTrackData {
}

impl super::core::DataContainerTrait for CustomSequenceTrackData {
}

pub static CUSTOMSEQUENCETRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomSequenceTrackData",
    name_hash: 2879414486,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(CustomSequenceTrackData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CustomSequenceTrackData as Default>::default())),
            create_boxed: || Box::new(<CustomSequenceTrackData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "TrackName",
                name_hash: 1755529293,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(CustomSequenceTrackData, track_name),
            },
            FieldInfoData {
                name: "InputLinkMap",
                name_hash: 1743335471,
                flags: MemberInfoFlags::new(144),
                field_type: "CustomSequenceTrackLinkMapping-Array",
                rust_offset: offset_of!(CustomSequenceTrackData, input_link_map),
            },
            FieldInfoData {
                name: "OutputLinkMap",
                name_hash: 2997861030,
                flags: MemberInfoFlags::new(144),
                field_type: "CustomSequenceTrackLinkMapping-Array",
                rust_offset: offset_of!(CustomSequenceTrackData, output_link_map),
            },
            FieldInfoData {
                name: "EventMap",
                name_hash: 1687029045,
                flags: MemberInfoFlags::new(144),
                field_type: "CustomSequenceTrackEventMapping-Array",
                rust_offset: offset_of!(CustomSequenceTrackData, event_map),
            },
            FieldInfoData {
                name: "SourcePropertyMap",
                name_hash: 130951907,
                flags: MemberInfoFlags::new(144),
                field_type: "CustomSequenceTrackPropertyMapping-Array",
                rust_offset: offset_of!(CustomSequenceTrackData, source_property_map),
            },
            FieldInfoData {
                name: "TargetPropertyMap",
                name_hash: 1050699055,
                flags: MemberInfoFlags::new(144),
                field_type: "CustomSequenceTrackPropertyMapping-Array",
                rust_offset: offset_of!(CustomSequenceTrackData, target_property_map),
            },
            FieldInfoData {
                name: "SourceAndTargetPropertyMap",
                name_hash: 3803134969,
                flags: MemberInfoFlags::new(144),
                field_type: "CustomSequenceTrackPropertyMapping-Array",
                rust_offset: offset_of!(CustomSequenceTrackData, source_and_target_property_map),
            },
        ],
    }),
    array_type: Some(CUSTOMSEQUENCETRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CustomSequenceTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        CUSTOMSEQUENCETRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CUSTOMSEQUENCETRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomSequenceTrackData-Array",
    name_hash: 1854113378,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CustomSequenceTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CustomSequenceTrackPropertyMapping {
    pub _glacier_base: super::core::DataContainer,
    pub track_property_i_d: i32,
    pub sequence_property_i_d: i32,
}

pub trait CustomSequenceTrackPropertyMappingTrait: super::core::DataContainerTrait {
    fn track_property_i_d(&self) -> &i32;
    fn track_property_i_d_mut(&mut self) -> &mut i32;
    fn sequence_property_i_d(&self) -> &i32;
    fn sequence_property_i_d_mut(&mut self) -> &mut i32;
}

impl CustomSequenceTrackPropertyMappingTrait for CustomSequenceTrackPropertyMapping {
    fn track_property_i_d(&self) -> &i32 {
        &self.track_property_i_d
    }
    fn track_property_i_d_mut(&mut self) -> &mut i32 {
        &mut self.track_property_i_d
    }
    fn sequence_property_i_d(&self) -> &i32 {
        &self.sequence_property_i_d
    }
    fn sequence_property_i_d_mut(&mut self) -> &mut i32 {
        &mut self.sequence_property_i_d
    }
}

impl super::core::DataContainerTrait for CustomSequenceTrackPropertyMapping {
}

pub static CUSTOMSEQUENCETRACKPROPERTYMAPPING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomSequenceTrackPropertyMapping",
    name_hash: 1809661581,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(CustomSequenceTrackPropertyMapping, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CustomSequenceTrackPropertyMapping as Default>::default())),
            create_boxed: || Box::new(<CustomSequenceTrackPropertyMapping as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "TrackPropertyID",
                name_hash: 3764113472,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CustomSequenceTrackPropertyMapping, track_property_i_d),
            },
            FieldInfoData {
                name: "SequencePropertyID",
                name_hash: 2623680624,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CustomSequenceTrackPropertyMapping, sequence_property_i_d),
            },
        ],
    }),
    array_type: Some(CUSTOMSEQUENCETRACKPROPERTYMAPPING_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CustomSequenceTrackPropertyMapping {
    fn type_info(&self) -> &'static TypeInfo {
        CUSTOMSEQUENCETRACKPROPERTYMAPPING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CUSTOMSEQUENCETRACKPROPERTYMAPPING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomSequenceTrackPropertyMapping-Array",
    name_hash: 3113919033,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CustomSequenceTrackPropertyMapping"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CustomSequenceTrackEventMapping {
    pub _glacier_base: super::core::DataContainer,
    pub track_event_i_d: i32,
    pub sequence_event_i_d: i32,
}

pub trait CustomSequenceTrackEventMappingTrait: super::core::DataContainerTrait {
    fn track_event_i_d(&self) -> &i32;
    fn track_event_i_d_mut(&mut self) -> &mut i32;
    fn sequence_event_i_d(&self) -> &i32;
    fn sequence_event_i_d_mut(&mut self) -> &mut i32;
}

impl CustomSequenceTrackEventMappingTrait for CustomSequenceTrackEventMapping {
    fn track_event_i_d(&self) -> &i32 {
        &self.track_event_i_d
    }
    fn track_event_i_d_mut(&mut self) -> &mut i32 {
        &mut self.track_event_i_d
    }
    fn sequence_event_i_d(&self) -> &i32 {
        &self.sequence_event_i_d
    }
    fn sequence_event_i_d_mut(&mut self) -> &mut i32 {
        &mut self.sequence_event_i_d
    }
}

impl super::core::DataContainerTrait for CustomSequenceTrackEventMapping {
}

pub static CUSTOMSEQUENCETRACKEVENTMAPPING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomSequenceTrackEventMapping",
    name_hash: 2667646278,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(CustomSequenceTrackEventMapping, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CustomSequenceTrackEventMapping as Default>::default())),
            create_boxed: || Box::new(<CustomSequenceTrackEventMapping as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "TrackEventID",
                name_hash: 3785607275,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CustomSequenceTrackEventMapping, track_event_i_d),
            },
            FieldInfoData {
                name: "SequenceEventID",
                name_hash: 959482075,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CustomSequenceTrackEventMapping, sequence_event_i_d),
            },
        ],
    }),
    array_type: Some(CUSTOMSEQUENCETRACKEVENTMAPPING_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CustomSequenceTrackEventMapping {
    fn type_info(&self) -> &'static TypeInfo {
        CUSTOMSEQUENCETRACKEVENTMAPPING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CUSTOMSEQUENCETRACKEVENTMAPPING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomSequenceTrackEventMapping-Array",
    name_hash: 943770354,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CustomSequenceTrackEventMapping"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CustomSequenceTrackLinkMapping {
    pub _glacier_base: super::core::DataContainer,
    pub track_link_i_d: i32,
    pub sequence_link_i_d: i32,
}

pub trait CustomSequenceTrackLinkMappingTrait: super::core::DataContainerTrait {
    fn track_link_i_d(&self) -> &i32;
    fn track_link_i_d_mut(&mut self) -> &mut i32;
    fn sequence_link_i_d(&self) -> &i32;
    fn sequence_link_i_d_mut(&mut self) -> &mut i32;
}

impl CustomSequenceTrackLinkMappingTrait for CustomSequenceTrackLinkMapping {
    fn track_link_i_d(&self) -> &i32 {
        &self.track_link_i_d
    }
    fn track_link_i_d_mut(&mut self) -> &mut i32 {
        &mut self.track_link_i_d
    }
    fn sequence_link_i_d(&self) -> &i32 {
        &self.sequence_link_i_d
    }
    fn sequence_link_i_d_mut(&mut self) -> &mut i32 {
        &mut self.sequence_link_i_d
    }
}

impl super::core::DataContainerTrait for CustomSequenceTrackLinkMapping {
}

pub static CUSTOMSEQUENCETRACKLINKMAPPING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomSequenceTrackLinkMapping",
    name_hash: 3094064490,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(CustomSequenceTrackLinkMapping, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CustomSequenceTrackLinkMapping as Default>::default())),
            create_boxed: || Box::new(<CustomSequenceTrackLinkMapping as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "TrackLinkID",
                name_hash: 749830855,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CustomSequenceTrackLinkMapping, track_link_i_d),
            },
            FieldInfoData {
                name: "SequenceLinkID",
                name_hash: 2081585527,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CustomSequenceTrackLinkMapping, sequence_link_i_d),
            },
        ],
    }),
    array_type: Some(CUSTOMSEQUENCETRACKLINKMAPPING_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CustomSequenceTrackLinkMapping {
    fn type_info(&self) -> &'static TypeInfo {
        CUSTOMSEQUENCETRACKLINKMAPPING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CUSTOMSEQUENCETRACKLINKMAPPING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomSequenceTrackLinkMapping-Array",
    name_hash: 3236837470,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CustomSequenceTrackLinkMapping"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct PropertyTrackData {
    pub _glacier_base: super::core::DataContainer,
    pub id: i32,
    pub times: Vec<i32>,
}

pub trait PropertyTrackDataTrait: super::core::DataContainerTrait {
    fn id(&self) -> &i32;
    fn id_mut(&mut self) -> &mut i32;
    fn times(&self) -> &Vec<i32>;
    fn times_mut(&mut self) -> &mut Vec<i32>;
}

impl PropertyTrackDataTrait for PropertyTrackData {
    fn id(&self) -> &i32 {
        &self.id
    }
    fn id_mut(&mut self) -> &mut i32 {
        &mut self.id
    }
    fn times(&self) -> &Vec<i32> {
        &self.times
    }
    fn times_mut(&mut self) -> &mut Vec<i32> {
        &mut self.times
    }
}

impl super::core::DataContainerTrait for PropertyTrackData {
}

pub static PROPERTYTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PropertyTrackData",
    name_hash: 2713395901,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(PropertyTrackData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PropertyTrackData as Default>::default())),
            create_boxed: || Box::new(<PropertyTrackData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Id",
                name_hash: 5862152,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(PropertyTrackData, id),
            },
            FieldInfoData {
                name: "Times",
                name_hash: 227876771,
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(PropertyTrackData, times),
            },
        ],
    }),
    array_type: Some(PROPERTYTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PropertyTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        PROPERTYTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PROPERTYTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PropertyTrackData-Array",
    name_hash: 4203880201,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("PropertyTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum InterpolationType {
    #[default]
    InterpolationType_None = 0,
    InterpolationType_Linear = 1,
    InterpolationType_CatmullRom = 2,
    InterpolationType_Curves = 3,
}

pub static INTERPOLATIONTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InterpolationType",
    name_hash: 1709219799,
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(INTERPOLATIONTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for InterpolationType {
    fn type_info(&self) -> &'static TypeInfo {
        INTERPOLATIONTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static INTERPOLATIONTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InterpolationType-Array",
    name_hash: 393058531,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("InterpolationType"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SequenceEventData {
    pub event: EventSpec,
    pub time: i32,
}

pub trait SequenceEventDataTrait: TypeObject {
    fn event(&self) -> &EventSpec;
    fn event_mut(&mut self) -> &mut EventSpec;
    fn time(&self) -> &i32;
    fn time_mut(&mut self) -> &mut i32;
}

impl SequenceEventDataTrait for SequenceEventData {
    fn event(&self) -> &EventSpec {
        &self.event
    }
    fn event_mut(&mut self) -> &mut EventSpec {
        &mut self.event
    }
    fn time(&self) -> &i32 {
        &self.time
    }
    fn time_mut(&mut self) -> &mut i32 {
        &mut self.time
    }
}

pub static SEQUENCEEVENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SequenceEventData",
    name_hash: 1198287110,
    flags: MemberInfoFlags::new(32841),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SequenceEventData as Default>::default())),
            create_boxed: || Box::new(<SequenceEventData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Event",
                name_hash: 201427689,
                flags: MemberInfoFlags::new(0),
                field_type: "EventSpec",
                rust_offset: offset_of!(SequenceEventData, event),
            },
            FieldInfoData {
                name: "Time",
                name_hash: 2089313744,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SequenceEventData, time),
            },
        ],
    }),
    array_type: Some(SEQUENCEEVENTDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for SequenceEventData {
    fn type_info(&self) -> &'static TypeInfo {
        SEQUENCEEVENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SEQUENCEEVENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SequenceEventData-Array",
    name_hash: 3940660786,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SequenceEventData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct EntityClassInfoAsset {
    pub _glacier_base: super::core::ClassInfoAsset,
}

pub trait EntityClassInfoAssetTrait: super::core::ClassInfoAssetTrait {
}

impl EntityClassInfoAssetTrait for EntityClassInfoAsset {
}

impl super::core::ClassInfoAssetTrait for EntityClassInfoAsset {
    fn super_class_ref(&self) -> &super::core::ClassInfoRef {
        self._glacier_base.super_class_ref()
    }
    fn super_class_ref_mut(&mut self) -> &mut super::core::ClassInfoRef {
        self._glacier_base.super_class_ref_mut()
    }
    fn is_abstract(&self) -> &bool {
        self._glacier_base.is_abstract()
    }
    fn is_abstract_mut(&mut self) -> &mut bool {
        self._glacier_base.is_abstract_mut()
    }
    fn is_sealed(&self) -> &bool {
        self._glacier_base.is_sealed()
    }
    fn is_sealed_mut(&mut self) -> &mut bool {
        self._glacier_base.is_sealed_mut()
    }
}

impl super::core::ComplexTypeInfoAssetTrait for EntityClassInfoAsset {
    fn field_collections(&self) -> &Vec<BoxedTypeObject /* super::core::TypeInfoFieldCollectionRef */> {
        self._glacier_base.field_collections()
    }
    fn field_collections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::TypeInfoFieldCollectionRef */> {
        self._glacier_base.field_collections_mut()
    }
    fn alignment(&self) -> &u32 {
        self._glacier_base.alignment()
    }
    fn alignment_mut(&mut self) -> &mut u32 {
        self._glacier_base.alignment_mut()
    }
}

impl super::core::TypeInfoAssetTrait for EntityClassInfoAsset {
    fn module_name(&self) -> &String {
        self._glacier_base.module_name()
    }
    fn module_name_mut(&mut self) -> &mut String {
        self._glacier_base.module_name_mut()
    }
    fn type_name(&self) -> &String {
        self._glacier_base.type_name()
    }
    fn type_name_mut(&mut self) -> &mut String {
        self._glacier_base.type_name_mut()
    }
    fn is_meta(&self) -> &bool {
        self._glacier_base.is_meta()
    }
    fn is_meta_mut(&mut self) -> &mut bool {
        self._glacier_base.is_meta_mut()
    }
    fn attributes(&self) -> &Vec<Option<LockedTypeObject /* super::core::TypeInfoAttribute */>> {
        self._glacier_base.attributes()
    }
    fn attributes_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::core::TypeInfoAttribute */>> {
        self._glacier_base.attributes_mut()
    }
    fn is_native(&self) -> &bool {
        self._glacier_base.is_native()
    }
    fn is_native_mut(&mut self) -> &mut bool {
        self._glacier_base.is_native_mut()
    }
}

impl super::core::AssetTrait for EntityClassInfoAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for EntityClassInfoAsset {
}

pub static ENTITYCLASSINFOASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityClassInfoAsset",
    name_hash: 2378529326,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::CLASSINFOASSET_TYPE_INFO),
        super_class_offset: offset_of!(EntityClassInfoAsset, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EntityClassInfoAsset as Default>::default())),
            create_boxed: || Box::new(<EntityClassInfoAsset as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(ENTITYCLASSINFOASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EntityClassInfoAsset {
    fn type_info(&self) -> &'static TypeInfo {
        ENTITYCLASSINFOASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ENTITYCLASSINFOASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityClassInfoAsset-Array",
    name_hash: 3282993818,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EntityClassInfoAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct AutopaintOutputOverrideBase {
    pub _glacier_base: super::core::DataContainer,
}

pub trait AutopaintOutputOverrideBaseTrait: super::core::DataContainerTrait {
}

impl AutopaintOutputOverrideBaseTrait for AutopaintOutputOverrideBase {
}

impl super::core::DataContainerTrait for AutopaintOutputOverrideBase {
}

pub static AUTOPAINTOUTPUTOVERRIDEBASE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AutopaintOutputOverrideBase",
    name_hash: 3372168406,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(AutopaintOutputOverrideBase, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AutopaintOutputOverrideBase as Default>::default())),
            create_boxed: || Box::new(<AutopaintOutputOverrideBase as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(AUTOPAINTOUTPUTOVERRIDEBASE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AutopaintOutputOverrideBase {
    fn type_info(&self) -> &'static TypeInfo {
        AUTOPAINTOUTPUTOVERRIDEBASE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AUTOPAINTOUTPUTOVERRIDEBASE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AutopaintOutputOverrideBase-Array",
    name_hash: 3568392802,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("AutopaintOutputOverrideBase"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct AutopaintOutputBase {
    pub _glacier_base: super::core::Asset,
}

pub trait AutopaintOutputBaseTrait: super::core::AssetTrait {
}

impl AutopaintOutputBaseTrait for AutopaintOutputBase {
}

impl super::core::AssetTrait for AutopaintOutputBase {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for AutopaintOutputBase {
}

pub static AUTOPAINTOUTPUTBASE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AutopaintOutputBase",
    name_hash: 704698722,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        super_class_offset: offset_of!(AutopaintOutputBase, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AutopaintOutputBase as Default>::default())),
            create_boxed: || Box::new(<AutopaintOutputBase as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(AUTOPAINTOUTPUTBASE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AutopaintOutputBase {
    fn type_info(&self) -> &'static TypeInfo {
        AUTOPAINTOUTPUTBASE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AUTOPAINTOUTPUTBASE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AutopaintOutputBase-Array",
    name_hash: 238356566,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("AutopaintOutputBase"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct AutopaintOutputsBase {
    pub _glacier_base: super::core::Asset,
    pub outputs: Vec<Option<LockedTypeObject /* AutopaintOutputBase */>>,
}

pub trait AutopaintOutputsBaseTrait: super::core::AssetTrait {
    fn outputs(&self) -> &Vec<Option<LockedTypeObject /* AutopaintOutputBase */>>;
    fn outputs_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* AutopaintOutputBase */>>;
}

impl AutopaintOutputsBaseTrait for AutopaintOutputsBase {
    fn outputs(&self) -> &Vec<Option<LockedTypeObject /* AutopaintOutputBase */>> {
        &self.outputs
    }
    fn outputs_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* AutopaintOutputBase */>> {
        &mut self.outputs
    }
}

impl super::core::AssetTrait for AutopaintOutputsBase {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for AutopaintOutputsBase {
}

pub static AUTOPAINTOUTPUTSBASE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AutopaintOutputsBase",
    name_hash: 1799351345,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        super_class_offset: offset_of!(AutopaintOutputsBase, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AutopaintOutputsBase as Default>::default())),
            create_boxed: || Box::new(<AutopaintOutputsBase as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Outputs",
                name_hash: 1070022089,
                flags: MemberInfoFlags::new(144),
                field_type: "AutopaintOutputBase-Array",
                rust_offset: offset_of!(AutopaintOutputsBase, outputs),
            },
        ],
    }),
    array_type: Some(AUTOPAINTOUTPUTSBASE_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for AutopaintOutputsBase {
    fn type_info(&self) -> &'static TypeInfo {
        AUTOPAINTOUTPUTSBASE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AUTOPAINTOUTPUTSBASE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AutopaintOutputsBase-Array",
    name_hash: 1781071493,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("AutopaintOutputsBase"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum RasterType {
    #[default]
    RasterType_Null = 0,
    RasterType_ColorMap = 1,
    RasterType_DestructionDepth = 2,
    RasterType_Density = 3,
    RasterType_EnlightenAlbedo = 4,
    RasterType_Heightfield = 5,
    RasterType_NonPhysic = 6,
    RasterType_PhysicsMaterials = 7,
    RasterType_ResolutionLayout = 8,
    RasterType_LayerMask = 9,
    RasterType_FlowMap = 10,
    RasterType_Biome = 11,
    RasterType_Count = 12,
}

pub static RASTERTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RasterType",
    name_hash: 2617211102,
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(RASTERTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for RasterType {
    fn type_info(&self) -> &'static TypeInfo {
        RASTERTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static RASTERTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RasterType-Array",
    name_hash: 2723412586,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("RasterType"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum RasterFormat {
    #[default]
    RasterFormat_Null = 0,
    RasterFormat_R8_UNORM = 1,
    RasterFormat_R8_UINT = 2,
    RasterFormat_R8G8B8A8_UNORM = 3,
    RasterFormat_R32_FLOAT = 4,
    RasterFormat_Count = 5,
}

pub static RASTERFORMAT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RasterFormat",
    name_hash: 1744737829,
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(RASTERFORMAT_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for RasterFormat {
    fn type_info(&self) -> &'static TypeInfo {
        RASTERFORMAT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static RASTERFORMAT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RasterFormat-Array",
    name_hash: 4218162833,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("RasterFormat"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct BaseShapeDataBase {
    pub _glacier_base: GameObjectData,
}

pub trait BaseShapeDataBaseTrait: GameObjectDataTrait {
}

impl BaseShapeDataBaseTrait for BaseShapeDataBase {
}

impl GameObjectDataTrait for BaseShapeDataBase {
}

impl super::core::DataBusPeerTrait for BaseShapeDataBase {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for BaseShapeDataBase {
}

impl super::core::DataContainerTrait for BaseShapeDataBase {
}

pub static BASESHAPEDATABASE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BaseShapeDataBase",
    name_hash: 1999962746,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(GAMEOBJECTDATA_TYPE_INFO),
        super_class_offset: offset_of!(BaseShapeDataBase, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BaseShapeDataBase as Default>::default())),
            create_boxed: || Box::new(<BaseShapeDataBase as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(BASESHAPEDATABASE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BaseShapeDataBase {
    fn type_info(&self) -> &'static TypeInfo {
        BASESHAPEDATABASE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BASESHAPEDATABASE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BaseShapeDataBase-Array",
    name_hash: 2553681230,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("BaseShapeDataBase"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct BaseMaterialDataPair {
    pub _glacier_base: super::core::DataContainer,
}

pub trait BaseMaterialDataPairTrait: super::core::DataContainerTrait {
}

impl BaseMaterialDataPairTrait for BaseMaterialDataPair {
}

impl super::core::DataContainerTrait for BaseMaterialDataPair {
}

pub static BASEMATERIALDATAPAIR_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BaseMaterialDataPair",
    name_hash: 3326573633,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(BaseMaterialDataPair, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BaseMaterialDataPair as Default>::default())),
            create_boxed: || Box::new(<BaseMaterialDataPair as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(BASEMATERIALDATAPAIR_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BaseMaterialDataPair {
    fn type_info(&self) -> &'static TypeInfo {
        BASEMATERIALDATAPAIR_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BASEMATERIALDATAPAIR_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BaseMaterialDataPair-Array",
    name_hash: 2871600757,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("BaseMaterialDataPair"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct MaterialGridData {
    pub _glacier_base: super::core::Asset,
    pub default_material: MaterialDecl,
    pub material_pairs: Vec<BoxedTypeObject /* MaterialDecl */>,
    pub material_index_map: Vec<u32>,
    pub default_material_index: u32,
    pub material_properties: Vec<BoxedTypeObject /* MaterialRelationPropertyPair */>,
    pub interaction_grid: Vec<BoxedTypeObject /* MaterialInteractionGridRow */>,
}

pub trait MaterialGridDataTrait: super::core::AssetTrait {
    fn default_material(&self) -> &MaterialDecl;
    fn default_material_mut(&mut self) -> &mut MaterialDecl;
    fn material_pairs(&self) -> &Vec<BoxedTypeObject /* MaterialDecl */>;
    fn material_pairs_mut(&mut self) -> &mut Vec<BoxedTypeObject /* MaterialDecl */>;
    fn material_index_map(&self) -> &Vec<u32>;
    fn material_index_map_mut(&mut self) -> &mut Vec<u32>;
    fn default_material_index(&self) -> &u32;
    fn default_material_index_mut(&mut self) -> &mut u32;
    fn material_properties(&self) -> &Vec<BoxedTypeObject /* MaterialRelationPropertyPair */>;
    fn material_properties_mut(&mut self) -> &mut Vec<BoxedTypeObject /* MaterialRelationPropertyPair */>;
    fn interaction_grid(&self) -> &Vec<BoxedTypeObject /* MaterialInteractionGridRow */>;
    fn interaction_grid_mut(&mut self) -> &mut Vec<BoxedTypeObject /* MaterialInteractionGridRow */>;
}

impl MaterialGridDataTrait for MaterialGridData {
    fn default_material(&self) -> &MaterialDecl {
        &self.default_material
    }
    fn default_material_mut(&mut self) -> &mut MaterialDecl {
        &mut self.default_material
    }
    fn material_pairs(&self) -> &Vec<BoxedTypeObject /* MaterialDecl */> {
        &self.material_pairs
    }
    fn material_pairs_mut(&mut self) -> &mut Vec<BoxedTypeObject /* MaterialDecl */> {
        &mut self.material_pairs
    }
    fn material_index_map(&self) -> &Vec<u32> {
        &self.material_index_map
    }
    fn material_index_map_mut(&mut self) -> &mut Vec<u32> {
        &mut self.material_index_map
    }
    fn default_material_index(&self) -> &u32 {
        &self.default_material_index
    }
    fn default_material_index_mut(&mut self) -> &mut u32 {
        &mut self.default_material_index
    }
    fn material_properties(&self) -> &Vec<BoxedTypeObject /* MaterialRelationPropertyPair */> {
        &self.material_properties
    }
    fn material_properties_mut(&mut self) -> &mut Vec<BoxedTypeObject /* MaterialRelationPropertyPair */> {
        &mut self.material_properties
    }
    fn interaction_grid(&self) -> &Vec<BoxedTypeObject /* MaterialInteractionGridRow */> {
        &self.interaction_grid
    }
    fn interaction_grid_mut(&mut self) -> &mut Vec<BoxedTypeObject /* MaterialInteractionGridRow */> {
        &mut self.interaction_grid
    }
}

impl super::core::AssetTrait for MaterialGridData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for MaterialGridData {
}

pub static MATERIALGRIDDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MaterialGridData",
    name_hash: 3134818726,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        super_class_offset: offset_of!(MaterialGridData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MaterialGridData as Default>::default())),
            create_boxed: || Box::new(<MaterialGridData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "DefaultMaterial",
                name_hash: 1956671429,
                flags: MemberInfoFlags::new(0),
                field_type: "MaterialDecl",
                rust_offset: offset_of!(MaterialGridData, default_material),
            },
            FieldInfoData {
                name: "MaterialPairs",
                name_hash: 1030971927,
                flags: MemberInfoFlags::new(144),
                field_type: "MaterialDecl-Array",
                rust_offset: offset_of!(MaterialGridData, material_pairs),
            },
            FieldInfoData {
                name: "MaterialIndexMap",
                name_hash: 3087328300,
                flags: MemberInfoFlags::new(144),
                field_type: "Uint32-Array",
                rust_offset: offset_of!(MaterialGridData, material_index_map),
            },
            FieldInfoData {
                name: "DefaultMaterialIndex",
                name_hash: 214719451,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(MaterialGridData, default_material_index),
            },
            FieldInfoData {
                name: "MaterialProperties",
                name_hash: 1479818927,
                flags: MemberInfoFlags::new(144),
                field_type: "MaterialRelationPropertyPair-Array",
                rust_offset: offset_of!(MaterialGridData, material_properties),
            },
            FieldInfoData {
                name: "InteractionGrid",
                name_hash: 691097959,
                flags: MemberInfoFlags::new(144),
                field_type: "MaterialInteractionGridRow-Array",
                rust_offset: offset_of!(MaterialGridData, interaction_grid),
            },
        ],
    }),
    array_type: Some(MATERIALGRIDDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MaterialGridData {
    fn type_info(&self) -> &'static TypeInfo {
        MATERIALGRIDDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MATERIALGRIDDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MaterialGridData-Array",
    name_hash: 1408292370,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("MaterialGridData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct MaterialInteractionGridRow {
    pub items: Vec<BoxedTypeObject /* MaterialRelationPropertyPair */>,
}

pub trait MaterialInteractionGridRowTrait: TypeObject {
    fn items(&self) -> &Vec<BoxedTypeObject /* MaterialRelationPropertyPair */>;
    fn items_mut(&mut self) -> &mut Vec<BoxedTypeObject /* MaterialRelationPropertyPair */>;
}

impl MaterialInteractionGridRowTrait for MaterialInteractionGridRow {
    fn items(&self) -> &Vec<BoxedTypeObject /* MaterialRelationPropertyPair */> {
        &self.items
    }
    fn items_mut(&mut self) -> &mut Vec<BoxedTypeObject /* MaterialRelationPropertyPair */> {
        &mut self.items
    }
}

pub static MATERIALINTERACTIONGRIDROW_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MaterialInteractionGridRow",
    name_hash: 365592902,
    flags: MemberInfoFlags::new(73),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MaterialInteractionGridRow as Default>::default())),
            create_boxed: || Box::new(<MaterialInteractionGridRow as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Items",
                name_hash: 215446531,
                flags: MemberInfoFlags::new(144),
                field_type: "MaterialRelationPropertyPair-Array",
                rust_offset: offset_of!(MaterialInteractionGridRow, items),
            },
        ],
    }),
    array_type: Some(MATERIALINTERACTIONGRIDROW_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MaterialInteractionGridRow {
    fn type_info(&self) -> &'static TypeInfo {
        MATERIALINTERACTIONGRIDROW_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MATERIALINTERACTIONGRIDROW_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MaterialInteractionGridRow-Array",
    name_hash: 1162952434,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("MaterialInteractionGridRow"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct MaterialRelationPropertyPair {
    pub physics_material_properties: Vec<Option<LockedTypeObject /* PhysicsMaterialRelationPropertyData */>>,
    pub physics_property_properties: Vec<Option<LockedTypeObject /* PhysicsPropertyRelationPropertyData */>>,
}

pub trait MaterialRelationPropertyPairTrait: TypeObject {
    fn physics_material_properties(&self) -> &Vec<Option<LockedTypeObject /* PhysicsMaterialRelationPropertyData */>>;
    fn physics_material_properties_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* PhysicsMaterialRelationPropertyData */>>;
    fn physics_property_properties(&self) -> &Vec<Option<LockedTypeObject /* PhysicsPropertyRelationPropertyData */>>;
    fn physics_property_properties_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* PhysicsPropertyRelationPropertyData */>>;
}

impl MaterialRelationPropertyPairTrait for MaterialRelationPropertyPair {
    fn physics_material_properties(&self) -> &Vec<Option<LockedTypeObject /* PhysicsMaterialRelationPropertyData */>> {
        &self.physics_material_properties
    }
    fn physics_material_properties_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* PhysicsMaterialRelationPropertyData */>> {
        &mut self.physics_material_properties
    }
    fn physics_property_properties(&self) -> &Vec<Option<LockedTypeObject /* PhysicsPropertyRelationPropertyData */>> {
        &self.physics_property_properties
    }
    fn physics_property_properties_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* PhysicsPropertyRelationPropertyData */>> {
        &mut self.physics_property_properties
    }
}

pub static MATERIALRELATIONPROPERTYPAIR_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MaterialRelationPropertyPair",
    name_hash: 3517544133,
    flags: MemberInfoFlags::new(73),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MaterialRelationPropertyPair as Default>::default())),
            create_boxed: || Box::new(<MaterialRelationPropertyPair as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "PhysicsMaterialProperties",
                name_hash: 1069720196,
                flags: MemberInfoFlags::new(144),
                field_type: "PhysicsMaterialRelationPropertyData-Array",
                rust_offset: offset_of!(MaterialRelationPropertyPair, physics_material_properties),
            },
            FieldInfoData {
                name: "PhysicsPropertyProperties",
                name_hash: 1287888840,
                flags: MemberInfoFlags::new(144),
                field_type: "PhysicsPropertyRelationPropertyData-Array",
                rust_offset: offset_of!(MaterialRelationPropertyPair, physics_property_properties),
            },
        ],
    }),
    array_type: Some(MATERIALRELATIONPROPERTYPAIR_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MaterialRelationPropertyPair {
    fn type_info(&self) -> &'static TypeInfo {
        MATERIALRELATIONPROPERTYPAIR_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MATERIALRELATIONPROPERTYPAIR_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MaterialRelationPropertyPair-Array",
    name_hash: 4177309425,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("MaterialRelationPropertyPair"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct PhysicsPropertyRelationPropertyData {
    pub _glacier_base: MaterialRelationPropertyData,
}

pub trait PhysicsPropertyRelationPropertyDataTrait: MaterialRelationPropertyDataTrait {
}

impl PhysicsPropertyRelationPropertyDataTrait for PhysicsPropertyRelationPropertyData {
}

impl MaterialRelationPropertyDataTrait for PhysicsPropertyRelationPropertyData {
}

impl super::core::DataContainerTrait for PhysicsPropertyRelationPropertyData {
}

pub static PHYSICSPROPERTYRELATIONPROPERTYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsPropertyRelationPropertyData",
    name_hash: 1033255192,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(MATERIALRELATIONPROPERTYDATA_TYPE_INFO),
        super_class_offset: offset_of!(PhysicsPropertyRelationPropertyData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PhysicsPropertyRelationPropertyData as Default>::default())),
            create_boxed: || Box::new(<PhysicsPropertyRelationPropertyData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(PHYSICSPROPERTYRELATIONPROPERTYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PhysicsPropertyRelationPropertyData {
    fn type_info(&self) -> &'static TypeInfo {
        PHYSICSPROPERTYRELATIONPROPERTYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PHYSICSPROPERTYRELATIONPROPERTYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsPropertyRelationPropertyData-Array",
    name_hash: 3293430572,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("PhysicsPropertyRelationPropertyData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct PhysicsMaterialRelationPropertyData {
    pub _glacier_base: MaterialRelationPropertyData,
}

pub trait PhysicsMaterialRelationPropertyDataTrait: MaterialRelationPropertyDataTrait {
}

impl PhysicsMaterialRelationPropertyDataTrait for PhysicsMaterialRelationPropertyData {
}

impl MaterialRelationPropertyDataTrait for PhysicsMaterialRelationPropertyData {
}

impl super::core::DataContainerTrait for PhysicsMaterialRelationPropertyData {
}

pub static PHYSICSMATERIALRELATIONPROPERTYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsMaterialRelationPropertyData",
    name_hash: 2627406036,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(MATERIALRELATIONPROPERTYDATA_TYPE_INFO),
        super_class_offset: offset_of!(PhysicsMaterialRelationPropertyData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PhysicsMaterialRelationPropertyData as Default>::default())),
            create_boxed: || Box::new(<PhysicsMaterialRelationPropertyData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(PHYSICSMATERIALRELATIONPROPERTYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PhysicsMaterialRelationPropertyData {
    fn type_info(&self) -> &'static TypeInfo {
        PHYSICSMATERIALRELATIONPROPERTYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PHYSICSMATERIALRELATIONPROPERTYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsMaterialRelationPropertyData-Array",
    name_hash: 1352906080,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("PhysicsMaterialRelationPropertyData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct MaterialRelationPropertyData {
    pub _glacier_base: super::core::DataContainer,
}

pub trait MaterialRelationPropertyDataTrait: super::core::DataContainerTrait {
}

impl MaterialRelationPropertyDataTrait for MaterialRelationPropertyData {
}

impl super::core::DataContainerTrait for MaterialRelationPropertyData {
}

pub static MATERIALRELATIONPROPERTYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MaterialRelationPropertyData",
    name_hash: 3516826367,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(MaterialRelationPropertyData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MaterialRelationPropertyData as Default>::default())),
            create_boxed: || Box::new(<MaterialRelationPropertyData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(MATERIALRELATIONPROPERTYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MaterialRelationPropertyData {
    fn type_info(&self) -> &'static TypeInfo {
        MATERIALRELATIONPROPERTYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MATERIALRELATIONPROPERTYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MaterialRelationPropertyData-Array",
    name_hash: 17377483,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("MaterialRelationPropertyData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct MaterialDecl {
    pub packed: u32,
}

pub trait MaterialDeclTrait: TypeObject {
    fn packed(&self) -> &u32;
    fn packed_mut(&mut self) -> &mut u32;
}

impl MaterialDeclTrait for MaterialDecl {
    fn packed(&self) -> &u32 {
        &self.packed
    }
    fn packed_mut(&mut self) -> &mut u32 {
        &mut self.packed
    }
}

pub static MATERIALDECL_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MaterialDecl",
    name_hash: 160677792,
    flags: MemberInfoFlags::new(32841),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MaterialDecl as Default>::default())),
            create_boxed: || Box::new(<MaterialDecl as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Packed",
                name_hash: 3372112125,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(MaterialDecl, packed),
            },
        ],
    }),
    array_type: Some(MATERIALDECL_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for MaterialDecl {
    fn type_info(&self) -> &'static TypeInfo {
        MATERIALDECL_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MATERIALDECL_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MaterialDecl-Array",
    name_hash: 1401120020,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("MaterialDecl"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct StringBuilderEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub num_strings: i32,
}

pub trait StringBuilderEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn num_strings(&self) -> &i32;
    fn num_strings_mut(&mut self) -> &mut i32;
}

impl StringBuilderEntityDataTrait for StringBuilderEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn num_strings(&self) -> &i32 {
        &self.num_strings
    }
    fn num_strings_mut(&mut self) -> &mut i32 {
        &mut self.num_strings
    }
}

impl EntityDataTrait for StringBuilderEntityData {
}

impl GameObjectDataTrait for StringBuilderEntityData {
}

impl super::core::DataBusPeerTrait for StringBuilderEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for StringBuilderEntityData {
}

impl super::core::DataContainerTrait for StringBuilderEntityData {
}

pub static STRINGBUILDERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StringBuilderEntityData",
    name_hash: 1429220602,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(StringBuilderEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StringBuilderEntityData as Default>::default())),
            create_boxed: || Box::new(<StringBuilderEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(StringBuilderEntityData, realm),
            },
            FieldInfoData {
                name: "NumStrings",
                name_hash: 661944949,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(StringBuilderEntityData, num_strings),
            },
        ],
    }),
    array_type: Some(STRINGBUILDERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for StringBuilderEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        STRINGBUILDERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static STRINGBUILDERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StringBuilderEntityData-Array",
    name_hash: 1367809998,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("StringBuilderEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct Vec4ChangedEntityData {
    pub _glacier_base: PropertyChangedEntityData,
    pub realm: super::core::Realm,
    pub value: super::core::Vec4,
    pub always_send: bool,
}

pub trait Vec4ChangedEntityDataTrait: PropertyChangedEntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn value(&self) -> &super::core::Vec4;
    fn value_mut(&mut self) -> &mut super::core::Vec4;
    fn always_send(&self) -> &bool;
    fn always_send_mut(&mut self) -> &mut bool;
}

impl Vec4ChangedEntityDataTrait for Vec4ChangedEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn value(&self) -> &super::core::Vec4 {
        &self.value
    }
    fn value_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.value
    }
    fn always_send(&self) -> &bool {
        &self.always_send
    }
    fn always_send_mut(&mut self) -> &mut bool {
        &mut self.always_send
    }
}

impl PropertyChangedEntityDataTrait for Vec4ChangedEntityData {
}

impl EntityDataTrait for Vec4ChangedEntityData {
}

impl GameObjectDataTrait for Vec4ChangedEntityData {
}

impl super::core::DataBusPeerTrait for Vec4ChangedEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for Vec4ChangedEntityData {
}

impl super::core::DataContainerTrait for Vec4ChangedEntityData {
}

pub static VEC4CHANGEDENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec4ChangedEntityData",
    name_hash: 3978015784,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PROPERTYCHANGEDENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(Vec4ChangedEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec4ChangedEntityData as Default>::default())),
            create_boxed: || Box::new(<Vec4ChangedEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(Vec4ChangedEntityData, realm),
            },
            FieldInfoData {
                name: "Value",
                name_hash: 225375086,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(Vec4ChangedEntityData, value),
            },
            FieldInfoData {
                name: "AlwaysSend",
                name_hash: 579845256,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(Vec4ChangedEntityData, always_send),
            },
        ],
    }),
    array_type: Some(VEC4CHANGEDENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for Vec4ChangedEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VEC4CHANGEDENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEC4CHANGEDENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec4ChangedEntityData-Array",
    name_hash: 3251639708,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec4ChangedEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct Vec3ChangedEntityData {
    pub _glacier_base: PropertyChangedEntityData,
    pub realm: super::core::Realm,
    pub value: super::core::Vec3,
    pub always_send: bool,
}

pub trait Vec3ChangedEntityDataTrait: PropertyChangedEntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn value(&self) -> &super::core::Vec3;
    fn value_mut(&mut self) -> &mut super::core::Vec3;
    fn always_send(&self) -> &bool;
    fn always_send_mut(&mut self) -> &mut bool;
}

impl Vec3ChangedEntityDataTrait for Vec3ChangedEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn value(&self) -> &super::core::Vec3 {
        &self.value
    }
    fn value_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.value
    }
    fn always_send(&self) -> &bool {
        &self.always_send
    }
    fn always_send_mut(&mut self) -> &mut bool {
        &mut self.always_send
    }
}

impl PropertyChangedEntityDataTrait for Vec3ChangedEntityData {
}

impl EntityDataTrait for Vec3ChangedEntityData {
}

impl GameObjectDataTrait for Vec3ChangedEntityData {
}

impl super::core::DataBusPeerTrait for Vec3ChangedEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for Vec3ChangedEntityData {
}

impl super::core::DataContainerTrait for Vec3ChangedEntityData {
}

pub static VEC3CHANGEDENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3ChangedEntityData",
    name_hash: 2663585743,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PROPERTYCHANGEDENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(Vec3ChangedEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec3ChangedEntityData as Default>::default())),
            create_boxed: || Box::new(<Vec3ChangedEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(Vec3ChangedEntityData, realm),
            },
            FieldInfoData {
                name: "Value",
                name_hash: 225375086,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(Vec3ChangedEntityData, value),
            },
            FieldInfoData {
                name: "AlwaysSend",
                name_hash: 579845256,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(Vec3ChangedEntityData, always_send),
            },
        ],
    }),
    array_type: Some(VEC3CHANGEDENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for Vec3ChangedEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VEC3CHANGEDENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEC3CHANGEDENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3ChangedEntityData-Array",
    name_hash: 2973148411,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec3ChangedEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct Vec2ChangedEntityData {
    pub _glacier_base: PropertyChangedEntityData,
    pub realm: super::core::Realm,
    pub value: super::core::Vec2,
    pub always_send: bool,
}

pub trait Vec2ChangedEntityDataTrait: PropertyChangedEntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn value(&self) -> &super::core::Vec2;
    fn value_mut(&mut self) -> &mut super::core::Vec2;
    fn always_send(&self) -> &bool;
    fn always_send_mut(&mut self) -> &mut bool;
}

impl Vec2ChangedEntityDataTrait for Vec2ChangedEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn value(&self) -> &super::core::Vec2 {
        &self.value
    }
    fn value_mut(&mut self) -> &mut super::core::Vec2 {
        &mut self.value
    }
    fn always_send(&self) -> &bool {
        &self.always_send
    }
    fn always_send_mut(&mut self) -> &mut bool {
        &mut self.always_send
    }
}

impl PropertyChangedEntityDataTrait for Vec2ChangedEntityData {
}

impl EntityDataTrait for Vec2ChangedEntityData {
}

impl GameObjectDataTrait for Vec2ChangedEntityData {
}

impl super::core::DataBusPeerTrait for Vec2ChangedEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for Vec2ChangedEntityData {
}

impl super::core::DataContainerTrait for Vec2ChangedEntityData {
}

pub static VEC2CHANGEDENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec2ChangedEntityData",
    name_hash: 1102231790,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PROPERTYCHANGEDENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(Vec2ChangedEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec2ChangedEntityData as Default>::default())),
            create_boxed: || Box::new(<Vec2ChangedEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(Vec2ChangedEntityData, realm),
            },
            FieldInfoData {
                name: "Value",
                name_hash: 225375086,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(Vec2ChangedEntityData, value),
            },
            FieldInfoData {
                name: "AlwaysSend",
                name_hash: 579845256,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(Vec2ChangedEntityData, always_send),
            },
        ],
    }),
    array_type: Some(VEC2CHANGEDENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for Vec2ChangedEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VEC2CHANGEDENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEC2CHANGEDENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec2ChangedEntityData-Array",
    name_hash: 1114608090,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec2ChangedEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct IntChangedEntityData {
    pub _glacier_base: PropertyChangedEntityData,
    pub realm: super::core::Realm,
    pub value: i32,
    pub always_send: bool,
}

pub trait IntChangedEntityDataTrait: PropertyChangedEntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn value(&self) -> &i32;
    fn value_mut(&mut self) -> &mut i32;
    fn always_send(&self) -> &bool;
    fn always_send_mut(&mut self) -> &mut bool;
}

impl IntChangedEntityDataTrait for IntChangedEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn value(&self) -> &i32 {
        &self.value
    }
    fn value_mut(&mut self) -> &mut i32 {
        &mut self.value
    }
    fn always_send(&self) -> &bool {
        &self.always_send
    }
    fn always_send_mut(&mut self) -> &mut bool {
        &mut self.always_send
    }
}

impl PropertyChangedEntityDataTrait for IntChangedEntityData {
}

impl EntityDataTrait for IntChangedEntityData {
}

impl GameObjectDataTrait for IntChangedEntityData {
}

impl super::core::DataBusPeerTrait for IntChangedEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for IntChangedEntityData {
}

impl super::core::DataContainerTrait for IntChangedEntityData {
}

pub static INTCHANGEDENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntChangedEntityData",
    name_hash: 2347667199,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PROPERTYCHANGEDENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(IntChangedEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<IntChangedEntityData as Default>::default())),
            create_boxed: || Box::new(<IntChangedEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(IntChangedEntityData, realm),
            },
            FieldInfoData {
                name: "Value",
                name_hash: 225375086,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(IntChangedEntityData, value),
            },
            FieldInfoData {
                name: "AlwaysSend",
                name_hash: 579845256,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(IntChangedEntityData, always_send),
            },
        ],
    }),
    array_type: Some(INTCHANGEDENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for IntChangedEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        INTCHANGEDENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static INTCHANGEDENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntChangedEntityData-Array",
    name_hash: 4063376587,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("IntChangedEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct FloatChangedEntityData {
    pub _glacier_base: PropertyChangedEntityData,
    pub realm: super::core::Realm,
    pub value: f32,
    pub always_send: bool,
}

pub trait FloatChangedEntityDataTrait: PropertyChangedEntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn value(&self) -> &f32;
    fn value_mut(&mut self) -> &mut f32;
    fn always_send(&self) -> &bool;
    fn always_send_mut(&mut self) -> &mut bool;
}

impl FloatChangedEntityDataTrait for FloatChangedEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn value(&self) -> &f32 {
        &self.value
    }
    fn value_mut(&mut self) -> &mut f32 {
        &mut self.value
    }
    fn always_send(&self) -> &bool {
        &self.always_send
    }
    fn always_send_mut(&mut self) -> &mut bool {
        &mut self.always_send
    }
}

impl PropertyChangedEntityDataTrait for FloatChangedEntityData {
}

impl EntityDataTrait for FloatChangedEntityData {
}

impl GameObjectDataTrait for FloatChangedEntityData {
}

impl super::core::DataBusPeerTrait for FloatChangedEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for FloatChangedEntityData {
}

impl super::core::DataContainerTrait for FloatChangedEntityData {
}

pub static FLOATCHANGEDENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatChangedEntityData",
    name_hash: 1910678908,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PROPERTYCHANGEDENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(FloatChangedEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FloatChangedEntityData as Default>::default())),
            create_boxed: || Box::new(<FloatChangedEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(FloatChangedEntityData, realm),
            },
            FieldInfoData {
                name: "Value",
                name_hash: 225375086,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FloatChangedEntityData, value),
            },
            FieldInfoData {
                name: "AlwaysSend",
                name_hash: 579845256,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FloatChangedEntityData, always_send),
            },
        ],
    }),
    array_type: Some(FLOATCHANGEDENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FloatChangedEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        FLOATCHANGEDENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FLOATCHANGEDENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatChangedEntityData-Array",
    name_hash: 4242894152,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("FloatChangedEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct BoolChangedEntityData {
    pub _glacier_base: PropertyChangedEntityData,
    pub realm: super::core::Realm,
    pub value: bool,
    pub always_send: bool,
}

pub trait BoolChangedEntityDataTrait: PropertyChangedEntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn value(&self) -> &bool;
    fn value_mut(&mut self) -> &mut bool;
    fn always_send(&self) -> &bool;
    fn always_send_mut(&mut self) -> &mut bool;
}

impl BoolChangedEntityDataTrait for BoolChangedEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn value(&self) -> &bool {
        &self.value
    }
    fn value_mut(&mut self) -> &mut bool {
        &mut self.value
    }
    fn always_send(&self) -> &bool {
        &self.always_send
    }
    fn always_send_mut(&mut self) -> &mut bool {
        &mut self.always_send
    }
}

impl PropertyChangedEntityDataTrait for BoolChangedEntityData {
}

impl EntityDataTrait for BoolChangedEntityData {
}

impl GameObjectDataTrait for BoolChangedEntityData {
}

impl super::core::DataBusPeerTrait for BoolChangedEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for BoolChangedEntityData {
}

impl super::core::DataContainerTrait for BoolChangedEntityData {
}

pub static BOOLCHANGEDENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolChangedEntityData",
    name_hash: 859316642,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PROPERTYCHANGEDENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(BoolChangedEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BoolChangedEntityData as Default>::default())),
            create_boxed: || Box::new(<BoolChangedEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(BoolChangedEntityData, realm),
            },
            FieldInfoData {
                name: "Value",
                name_hash: 225375086,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BoolChangedEntityData, value),
            },
            FieldInfoData {
                name: "AlwaysSend",
                name_hash: 579845256,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BoolChangedEntityData, always_send),
            },
        ],
    }),
    array_type: Some(BOOLCHANGEDENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BoolChangedEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        BOOLCHANGEDENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BOOLCHANGEDENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolChangedEntityData-Array",
    name_hash: 2376187926,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("BoolChangedEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct PropertyChangedEntityData {
    pub _glacier_base: EntityData,
}

pub trait PropertyChangedEntityDataTrait: EntityDataTrait {
}

impl PropertyChangedEntityDataTrait for PropertyChangedEntityData {
}

impl EntityDataTrait for PropertyChangedEntityData {
}

impl GameObjectDataTrait for PropertyChangedEntityData {
}

impl super::core::DataBusPeerTrait for PropertyChangedEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PropertyChangedEntityData {
}

impl super::core::DataContainerTrait for PropertyChangedEntityData {
}

pub static PROPERTYCHANGEDENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PropertyChangedEntityData",
    name_hash: 3834317547,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(PropertyChangedEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PropertyChangedEntityData as Default>::default())),
            create_boxed: || Box::new(<PropertyChangedEntityData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(PROPERTYCHANGEDENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PropertyChangedEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PROPERTYCHANGEDENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PROPERTYCHANGEDENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PropertyChangedEntityData-Array",
    name_hash: 2489924319,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("PropertyChangedEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CompareTransformEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub a: super::core::LinearTransform,
    pub b: super::core::LinearTransform,
    pub trigger_on_property_change: bool,
    pub trigger_on_start: bool,
}

pub trait CompareTransformEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn a(&self) -> &super::core::LinearTransform;
    fn a_mut(&mut self) -> &mut super::core::LinearTransform;
    fn b(&self) -> &super::core::LinearTransform;
    fn b_mut(&mut self) -> &mut super::core::LinearTransform;
    fn trigger_on_property_change(&self) -> &bool;
    fn trigger_on_property_change_mut(&mut self) -> &mut bool;
    fn trigger_on_start(&self) -> &bool;
    fn trigger_on_start_mut(&mut self) -> &mut bool;
}

impl CompareTransformEntityDataTrait for CompareTransformEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn a(&self) -> &super::core::LinearTransform {
        &self.a
    }
    fn a_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.a
    }
    fn b(&self) -> &super::core::LinearTransform {
        &self.b
    }
    fn b_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.b
    }
    fn trigger_on_property_change(&self) -> &bool {
        &self.trigger_on_property_change
    }
    fn trigger_on_property_change_mut(&mut self) -> &mut bool {
        &mut self.trigger_on_property_change
    }
    fn trigger_on_start(&self) -> &bool {
        &self.trigger_on_start
    }
    fn trigger_on_start_mut(&mut self) -> &mut bool {
        &mut self.trigger_on_start
    }
}

impl EntityDataTrait for CompareTransformEntityData {
}

impl GameObjectDataTrait for CompareTransformEntityData {
}

impl super::core::DataBusPeerTrait for CompareTransformEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CompareTransformEntityData {
}

impl super::core::DataContainerTrait for CompareTransformEntityData {
}

pub static COMPARETRANSFORMENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareTransformEntityData",
    name_hash: 2891557541,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(CompareTransformEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareTransformEntityData as Default>::default())),
            create_boxed: || Box::new(<CompareTransformEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(CompareTransformEntityData, realm),
            },
            FieldInfoData {
                name: "A",
                name_hash: 177636,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(CompareTransformEntityData, a),
            },
            FieldInfoData {
                name: "B",
                name_hash: 177639,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(CompareTransformEntityData, b),
            },
            FieldInfoData {
                name: "TriggerOnPropertyChange",
                name_hash: 3134109917,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CompareTransformEntityData, trigger_on_property_change),
            },
            FieldInfoData {
                name: "TriggerOnStart",
                name_hash: 3859836348,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CompareTransformEntityData, trigger_on_start),
            },
        ],
    }),
    array_type: Some(COMPARETRANSFORMENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CompareTransformEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        COMPARETRANSFORMENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COMPARETRANSFORMENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareTransformEntityData-Array",
    name_hash: 3789849361,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareTransformEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SwitchEnumEntityData {
    pub _glacier_base: ImpliedEnumTypeLogicEntityData,
    pub fire_on_property_changed: bool,
    pub output_events: Vec<BoxedTypeObject /* EventName */>,
}

pub trait SwitchEnumEntityDataTrait: ImpliedEnumTypeLogicEntityDataTrait {
    fn fire_on_property_changed(&self) -> &bool;
    fn fire_on_property_changed_mut(&mut self) -> &mut bool;
    fn output_events(&self) -> &Vec<BoxedTypeObject /* EventName */>;
    fn output_events_mut(&mut self) -> &mut Vec<BoxedTypeObject /* EventName */>;
}

impl SwitchEnumEntityDataTrait for SwitchEnumEntityData {
    fn fire_on_property_changed(&self) -> &bool {
        &self.fire_on_property_changed
    }
    fn fire_on_property_changed_mut(&mut self) -> &mut bool {
        &mut self.fire_on_property_changed
    }
    fn output_events(&self) -> &Vec<BoxedTypeObject /* EventName */> {
        &self.output_events
    }
    fn output_events_mut(&mut self) -> &mut Vec<BoxedTypeObject /* EventName */> {
        &mut self.output_events
    }
}

impl ImpliedEnumTypeLogicEntityDataTrait for SwitchEnumEntityData {
}

impl EnumLogicEntityBaseDataTrait for SwitchEnumEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn type_name_hash(&self) -> &u32 {
        self._glacier_base.type_name_hash()
    }
    fn type_name_hash_mut(&mut self) -> &mut u32 {
        self._glacier_base.type_name_hash_mut()
    }
}

impl EntityDataTrait for SwitchEnumEntityData {
}

impl GameObjectDataTrait for SwitchEnumEntityData {
}

impl super::core::DataBusPeerTrait for SwitchEnumEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SwitchEnumEntityData {
}

impl super::core::DataContainerTrait for SwitchEnumEntityData {
}

pub static SWITCHENUMENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SwitchEnumEntityData",
    name_hash: 1931039695,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(IMPLIEDENUMTYPELOGICENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(SwitchEnumEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SwitchEnumEntityData as Default>::default())),
            create_boxed: || Box::new(<SwitchEnumEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "FireOnPropertyChanged",
                name_hash: 2602932313,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SwitchEnumEntityData, fire_on_property_changed),
            },
            FieldInfoData {
                name: "OutputEvents",
                name_hash: 3452448709,
                flags: MemberInfoFlags::new(144),
                field_type: "EventName-Array",
                rust_offset: offset_of!(SwitchEnumEntityData, output_events),
            },
        ],
    }),
    array_type: Some(SWITCHENUMENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SwitchEnumEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SWITCHENUMENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SWITCHENUMENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SwitchEnumEntityData-Array",
    name_hash: 2487869691,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SwitchEnumEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct EventName {
    pub enum_value: i32,
    pub hash: u32,
    pub is_connected: bool,
}

pub trait EventNameTrait: TypeObject {
    fn enum_value(&self) -> &i32;
    fn enum_value_mut(&mut self) -> &mut i32;
    fn hash(&self) -> &u32;
    fn hash_mut(&mut self) -> &mut u32;
    fn is_connected(&self) -> &bool;
    fn is_connected_mut(&mut self) -> &mut bool;
}

impl EventNameTrait for EventName {
    fn enum_value(&self) -> &i32 {
        &self.enum_value
    }
    fn enum_value_mut(&mut self) -> &mut i32 {
        &mut self.enum_value
    }
    fn hash(&self) -> &u32 {
        &self.hash
    }
    fn hash_mut(&mut self) -> &mut u32 {
        &mut self.hash
    }
    fn is_connected(&self) -> &bool {
        &self.is_connected
    }
    fn is_connected_mut(&mut self) -> &mut bool {
        &mut self.is_connected
    }
}

pub static EVENTNAME_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventName",
    name_hash: 4132530094,
    flags: MemberInfoFlags::new(36937),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EventName as Default>::default())),
            create_boxed: || Box::new(<EventName as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "EnumValue",
                name_hash: 1043067517,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(EventName, enum_value),
            },
            FieldInfoData {
                name: "Hash",
                name_hash: 2089161879,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(EventName, hash),
            },
            FieldInfoData {
                name: "IsConnected",
                name_hash: 292566976,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EventName, is_connected),
            },
        ],
    }),
    array_type: Some(EVENTNAME_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for EventName {
    fn type_info(&self) -> &'static TypeInfo {
        EVENTNAME_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static EVENTNAME_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventName-Array",
    name_hash: 1339461658,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EventName"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SetEnumEntityData {
    pub _glacier_base: ExplicitEnumTypeLogicEntityData,
    pub input_events: Vec<BoxedTypeObject /* SetEnumValueContainer */>,
}

pub trait SetEnumEntityDataTrait: ExplicitEnumTypeLogicEntityDataTrait {
    fn input_events(&self) -> &Vec<BoxedTypeObject /* SetEnumValueContainer */>;
    fn input_events_mut(&mut self) -> &mut Vec<BoxedTypeObject /* SetEnumValueContainer */>;
}

impl SetEnumEntityDataTrait for SetEnumEntityData {
    fn input_events(&self) -> &Vec<BoxedTypeObject /* SetEnumValueContainer */> {
        &self.input_events
    }
    fn input_events_mut(&mut self) -> &mut Vec<BoxedTypeObject /* SetEnumValueContainer */> {
        &mut self.input_events
    }
}

impl ExplicitEnumTypeLogicEntityDataTrait for SetEnumEntityData {
}

impl EnumLogicEntityBaseDataTrait for SetEnumEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn type_name_hash(&self) -> &u32 {
        self._glacier_base.type_name_hash()
    }
    fn type_name_hash_mut(&mut self) -> &mut u32 {
        self._glacier_base.type_name_hash_mut()
    }
}

impl EntityDataTrait for SetEnumEntityData {
}

impl GameObjectDataTrait for SetEnumEntityData {
}

impl super::core::DataBusPeerTrait for SetEnumEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SetEnumEntityData {
}

impl super::core::DataContainerTrait for SetEnumEntityData {
}

pub static SETENUMENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SetEnumEntityData",
    name_hash: 2244796063,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(EXPLICITENUMTYPELOGICENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(SetEnumEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SetEnumEntityData as Default>::default())),
            create_boxed: || Box::new(<SetEnumEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "InputEvents",
                name_hash: 1542460652,
                flags: MemberInfoFlags::new(144),
                field_type: "SetEnumValueContainer-Array",
                rust_offset: offset_of!(SetEnumEntityData, input_events),
            },
        ],
    }),
    array_type: Some(SETENUMENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SetEnumEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SETENUMENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SETENUMENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SetEnumEntityData-Array",
    name_hash: 445481771,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SetEnumEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SetEnumValueContainer {
    pub value: i32,
    pub input_event_hash: u32,
}

pub trait SetEnumValueContainerTrait: TypeObject {
    fn value(&self) -> &i32;
    fn value_mut(&mut self) -> &mut i32;
    fn input_event_hash(&self) -> &u32;
    fn input_event_hash_mut(&mut self) -> &mut u32;
}

impl SetEnumValueContainerTrait for SetEnumValueContainer {
    fn value(&self) -> &i32 {
        &self.value
    }
    fn value_mut(&mut self) -> &mut i32 {
        &mut self.value
    }
    fn input_event_hash(&self) -> &u32 {
        &self.input_event_hash
    }
    fn input_event_hash_mut(&mut self) -> &mut u32 {
        &mut self.input_event_hash
    }
}

pub static SETENUMVALUECONTAINER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SetEnumValueContainer",
    name_hash: 1774203960,
    flags: MemberInfoFlags::new(36937),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SetEnumValueContainer as Default>::default())),
            create_boxed: || Box::new(<SetEnumValueContainer as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Value",
                name_hash: 225375086,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SetEnumValueContainer, value),
            },
            FieldInfoData {
                name: "InputEventHash",
                name_hash: 559810541,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(SetEnumValueContainer, input_event_hash),
            },
        ],
    }),
    array_type: Some(SETENUMVALUECONTAINER_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for SetEnumValueContainer {
    fn type_info(&self) -> &'static TypeInfo {
        SETENUMVALUECONTAINER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SETENUMVALUECONTAINER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SetEnumValueContainer-Array",
    name_hash: 392650124,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SetEnumValueContainer"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct IntToEnumEntityData {
    pub _glacier_base: ExplicitEnumTypeLogicEntityData,
    pub r#in: i32,
}

pub trait IntToEnumEntityDataTrait: ExplicitEnumTypeLogicEntityDataTrait {
    fn r#in(&self) -> &i32;
    fn r#in_mut(&mut self) -> &mut i32;
}

impl IntToEnumEntityDataTrait for IntToEnumEntityData {
    fn r#in(&self) -> &i32 {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut i32 {
        &mut self.r#in
    }
}

impl ExplicitEnumTypeLogicEntityDataTrait for IntToEnumEntityData {
}

impl EnumLogicEntityBaseDataTrait for IntToEnumEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn type_name_hash(&self) -> &u32 {
        self._glacier_base.type_name_hash()
    }
    fn type_name_hash_mut(&mut self) -> &mut u32 {
        self._glacier_base.type_name_hash_mut()
    }
}

impl EntityDataTrait for IntToEnumEntityData {
}

impl GameObjectDataTrait for IntToEnumEntityData {
}

impl super::core::DataBusPeerTrait for IntToEnumEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for IntToEnumEntityData {
}

impl super::core::DataContainerTrait for IntToEnumEntityData {
}

pub static INTTOENUMENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntToEnumEntityData",
    name_hash: 2436362453,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(EXPLICITENUMTYPELOGICENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(IntToEnumEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<IntToEnumEntityData as Default>::default())),
            create_boxed: || Box::new(<IntToEnumEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                name_hash: 5862146,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(IntToEnumEntityData, r#in),
            },
        ],
    }),
    array_type: Some(INTTOENUMENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for IntToEnumEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        INTTOENUMENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static INTTOENUMENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntToEnumEntityData-Array",
    name_hash: 3146871009,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("IntToEnumEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct WriteArrayElementEntityData {
    pub _glacier_base: WriteVariableBaseEntityData,
    pub element_index: i32,
}

pub trait WriteArrayElementEntityDataTrait: WriteVariableBaseEntityDataTrait {
    fn element_index(&self) -> &i32;
    fn element_index_mut(&mut self) -> &mut i32;
}

impl WriteArrayElementEntityDataTrait for WriteArrayElementEntityData {
    fn element_index(&self) -> &i32 {
        &self.element_index
    }
    fn element_index_mut(&mut self) -> &mut i32 {
        &mut self.element_index
    }
}

impl WriteVariableBaseEntityDataTrait for WriteArrayElementEntityData {
}

impl VariableBaseEntityDataTrait for WriteArrayElementEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn field_name_hash(&self) -> &u32 {
        self._glacier_base.field_name_hash()
    }
    fn field_name_hash_mut(&mut self) -> &mut u32 {
        self._glacier_base.field_name_hash_mut()
    }
    fn field_type(&self) -> &glacier_reflect::builtin::TypeRef {
        self._glacier_base.field_type()
    }
    fn field_type_mut(&mut self) -> &mut glacier_reflect::builtin::TypeRef {
        self._glacier_base.field_type_mut()
    }
    fn field_offset(&self) -> &u32 {
        self._glacier_base.field_offset()
    }
    fn field_offset_mut(&mut self) -> &mut u32 {
        self._glacier_base.field_offset_mut()
    }
    fn use_data(&self) -> &bool {
        self._glacier_base.use_data()
    }
    fn use_data_mut(&mut self) -> &mut bool {
        self._glacier_base.use_data_mut()
    }
}

impl EntityDataTrait for WriteArrayElementEntityData {
}

impl GameObjectDataTrait for WriteArrayElementEntityData {
}

impl super::core::DataBusPeerTrait for WriteArrayElementEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for WriteArrayElementEntityData {
}

impl super::core::DataContainerTrait for WriteArrayElementEntityData {
}

pub static WRITEARRAYELEMENTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteArrayElementEntityData",
    name_hash: 2827660212,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(WRITEVARIABLEBASEENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(WriteArrayElementEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WriteArrayElementEntityData as Default>::default())),
            create_boxed: || Box::new(<WriteArrayElementEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "ElementIndex",
                name_hash: 2692677381,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(WriteArrayElementEntityData, element_index),
            },
        ],
    }),
    array_type: Some(WRITEARRAYELEMENTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WriteArrayElementEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        WRITEARRAYELEMENTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WRITEARRAYELEMENTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteArrayElementEntityData-Array",
    name_hash: 1942865664,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("WriteArrayElementEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ReadArraySizeEntityData {
    pub _glacier_base: ReadVariableBaseEntityData,
}

pub trait ReadArraySizeEntityDataTrait: ReadVariableBaseEntityDataTrait {
}

impl ReadArraySizeEntityDataTrait for ReadArraySizeEntityData {
}

impl ReadVariableBaseEntityDataTrait for ReadArraySizeEntityData {
}

impl VariableBaseEntityDataTrait for ReadArraySizeEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn field_name_hash(&self) -> &u32 {
        self._glacier_base.field_name_hash()
    }
    fn field_name_hash_mut(&mut self) -> &mut u32 {
        self._glacier_base.field_name_hash_mut()
    }
    fn field_type(&self) -> &glacier_reflect::builtin::TypeRef {
        self._glacier_base.field_type()
    }
    fn field_type_mut(&mut self) -> &mut glacier_reflect::builtin::TypeRef {
        self._glacier_base.field_type_mut()
    }
    fn field_offset(&self) -> &u32 {
        self._glacier_base.field_offset()
    }
    fn field_offset_mut(&mut self) -> &mut u32 {
        self._glacier_base.field_offset_mut()
    }
    fn use_data(&self) -> &bool {
        self._glacier_base.use_data()
    }
    fn use_data_mut(&mut self) -> &mut bool {
        self._glacier_base.use_data_mut()
    }
}

impl EntityDataTrait for ReadArraySizeEntityData {
}

impl GameObjectDataTrait for ReadArraySizeEntityData {
}

impl super::core::DataBusPeerTrait for ReadArraySizeEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ReadArraySizeEntityData {
}

impl super::core::DataContainerTrait for ReadArraySizeEntityData {
}

pub static READARRAYSIZEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadArraySizeEntityData",
    name_hash: 2216718560,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(READVARIABLEBASEENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(ReadArraySizeEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ReadArraySizeEntityData as Default>::default())),
            create_boxed: || Box::new(<ReadArraySizeEntityData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(READARRAYSIZEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ReadArraySizeEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        READARRAYSIZEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static READARRAYSIZEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadArraySizeEntityData-Array",
    name_hash: 3235645140,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ReadArraySizeEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ReadArrayElementEntityData {
    pub _glacier_base: ReadVariableBaseEntityData,
    pub element_index: i32,
}

pub trait ReadArrayElementEntityDataTrait: ReadVariableBaseEntityDataTrait {
    fn element_index(&self) -> &i32;
    fn element_index_mut(&mut self) -> &mut i32;
}

impl ReadArrayElementEntityDataTrait for ReadArrayElementEntityData {
    fn element_index(&self) -> &i32 {
        &self.element_index
    }
    fn element_index_mut(&mut self) -> &mut i32 {
        &mut self.element_index
    }
}

impl ReadVariableBaseEntityDataTrait for ReadArrayElementEntityData {
}

impl VariableBaseEntityDataTrait for ReadArrayElementEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn field_name_hash(&self) -> &u32 {
        self._glacier_base.field_name_hash()
    }
    fn field_name_hash_mut(&mut self) -> &mut u32 {
        self._glacier_base.field_name_hash_mut()
    }
    fn field_type(&self) -> &glacier_reflect::builtin::TypeRef {
        self._glacier_base.field_type()
    }
    fn field_type_mut(&mut self) -> &mut glacier_reflect::builtin::TypeRef {
        self._glacier_base.field_type_mut()
    }
    fn field_offset(&self) -> &u32 {
        self._glacier_base.field_offset()
    }
    fn field_offset_mut(&mut self) -> &mut u32 {
        self._glacier_base.field_offset_mut()
    }
    fn use_data(&self) -> &bool {
        self._glacier_base.use_data()
    }
    fn use_data_mut(&mut self) -> &mut bool {
        self._glacier_base.use_data_mut()
    }
}

impl EntityDataTrait for ReadArrayElementEntityData {
}

impl GameObjectDataTrait for ReadArrayElementEntityData {
}

impl super::core::DataBusPeerTrait for ReadArrayElementEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ReadArrayElementEntityData {
}

impl super::core::DataContainerTrait for ReadArrayElementEntityData {
}

pub static READARRAYELEMENTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadArrayElementEntityData",
    name_hash: 1777492571,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(READVARIABLEBASEENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(ReadArrayElementEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ReadArrayElementEntityData as Default>::default())),
            create_boxed: || Box::new(<ReadArrayElementEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "ElementIndex",
                name_hash: 2692677381,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ReadArrayElementEntityData, element_index),
            },
        ],
    }),
    array_type: Some(READARRAYELEMENTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ReadArrayElementEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        READARRAYELEMENTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static READARRAYELEMENTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadArrayElementEntityData-Array",
    name_hash: 1688660335,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ReadArrayElementEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ForEachVariableEntityData {
    pub _glacier_base: ReadVariableBaseEntityData,
}

pub trait ForEachVariableEntityDataTrait: ReadVariableBaseEntityDataTrait {
}

impl ForEachVariableEntityDataTrait for ForEachVariableEntityData {
}

impl ReadVariableBaseEntityDataTrait for ForEachVariableEntityData {
}

impl VariableBaseEntityDataTrait for ForEachVariableEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn field_name_hash(&self) -> &u32 {
        self._glacier_base.field_name_hash()
    }
    fn field_name_hash_mut(&mut self) -> &mut u32 {
        self._glacier_base.field_name_hash_mut()
    }
    fn field_type(&self) -> &glacier_reflect::builtin::TypeRef {
        self._glacier_base.field_type()
    }
    fn field_type_mut(&mut self) -> &mut glacier_reflect::builtin::TypeRef {
        self._glacier_base.field_type_mut()
    }
    fn field_offset(&self) -> &u32 {
        self._glacier_base.field_offset()
    }
    fn field_offset_mut(&mut self) -> &mut u32 {
        self._glacier_base.field_offset_mut()
    }
    fn use_data(&self) -> &bool {
        self._glacier_base.use_data()
    }
    fn use_data_mut(&mut self) -> &mut bool {
        self._glacier_base.use_data_mut()
    }
}

impl EntityDataTrait for ForEachVariableEntityData {
}

impl GameObjectDataTrait for ForEachVariableEntityData {
}

impl super::core::DataBusPeerTrait for ForEachVariableEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ForEachVariableEntityData {
}

impl super::core::DataContainerTrait for ForEachVariableEntityData {
}

pub static FOREACHVARIABLEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ForEachVariableEntityData",
    name_hash: 2240274012,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(READVARIABLEBASEENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(ForEachVariableEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ForEachVariableEntityData as Default>::default())),
            create_boxed: || Box::new(<ForEachVariableEntityData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(FOREACHVARIABLEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ForEachVariableEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        FOREACHVARIABLEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FOREACHVARIABLEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ForEachVariableEntityData-Array",
    name_hash: 783943400,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ForEachVariableEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ClearArrayVariableEntityData {
    pub _glacier_base: WriteVariableBaseEntityData,
}

pub trait ClearArrayVariableEntityDataTrait: WriteVariableBaseEntityDataTrait {
}

impl ClearArrayVariableEntityDataTrait for ClearArrayVariableEntityData {
}

impl WriteVariableBaseEntityDataTrait for ClearArrayVariableEntityData {
}

impl VariableBaseEntityDataTrait for ClearArrayVariableEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn field_name_hash(&self) -> &u32 {
        self._glacier_base.field_name_hash()
    }
    fn field_name_hash_mut(&mut self) -> &mut u32 {
        self._glacier_base.field_name_hash_mut()
    }
    fn field_type(&self) -> &glacier_reflect::builtin::TypeRef {
        self._glacier_base.field_type()
    }
    fn field_type_mut(&mut self) -> &mut glacier_reflect::builtin::TypeRef {
        self._glacier_base.field_type_mut()
    }
    fn field_offset(&self) -> &u32 {
        self._glacier_base.field_offset()
    }
    fn field_offset_mut(&mut self) -> &mut u32 {
        self._glacier_base.field_offset_mut()
    }
    fn use_data(&self) -> &bool {
        self._glacier_base.use_data()
    }
    fn use_data_mut(&mut self) -> &mut bool {
        self._glacier_base.use_data_mut()
    }
}

impl EntityDataTrait for ClearArrayVariableEntityData {
}

impl GameObjectDataTrait for ClearArrayVariableEntityData {
}

impl super::core::DataBusPeerTrait for ClearArrayVariableEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ClearArrayVariableEntityData {
}

impl super::core::DataContainerTrait for ClearArrayVariableEntityData {
}

pub static CLEARARRAYVARIABLEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClearArrayVariableEntityData",
    name_hash: 1566988040,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(WRITEVARIABLEBASEENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(ClearArrayVariableEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ClearArrayVariableEntityData as Default>::default())),
            create_boxed: || Box::new(<ClearArrayVariableEntityData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(CLEARARRAYVARIABLEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ClearArrayVariableEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CLEARARRAYVARIABLEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CLEARARRAYVARIABLEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClearArrayVariableEntityData-Array",
    name_hash: 61446460,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ClearArrayVariableEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct AddToArrayVariableEntityData {
    pub _glacier_base: WriteVariableBaseEntityData,
}

pub trait AddToArrayVariableEntityDataTrait: WriteVariableBaseEntityDataTrait {
}

impl AddToArrayVariableEntityDataTrait for AddToArrayVariableEntityData {
}

impl WriteVariableBaseEntityDataTrait for AddToArrayVariableEntityData {
}

impl VariableBaseEntityDataTrait for AddToArrayVariableEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn field_name_hash(&self) -> &u32 {
        self._glacier_base.field_name_hash()
    }
    fn field_name_hash_mut(&mut self) -> &mut u32 {
        self._glacier_base.field_name_hash_mut()
    }
    fn field_type(&self) -> &glacier_reflect::builtin::TypeRef {
        self._glacier_base.field_type()
    }
    fn field_type_mut(&mut self) -> &mut glacier_reflect::builtin::TypeRef {
        self._glacier_base.field_type_mut()
    }
    fn field_offset(&self) -> &u32 {
        self._glacier_base.field_offset()
    }
    fn field_offset_mut(&mut self) -> &mut u32 {
        self._glacier_base.field_offset_mut()
    }
    fn use_data(&self) -> &bool {
        self._glacier_base.use_data()
    }
    fn use_data_mut(&mut self) -> &mut bool {
        self._glacier_base.use_data_mut()
    }
}

impl EntityDataTrait for AddToArrayVariableEntityData {
}

impl GameObjectDataTrait for AddToArrayVariableEntityData {
}

impl super::core::DataBusPeerTrait for AddToArrayVariableEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AddToArrayVariableEntityData {
}

impl super::core::DataContainerTrait for AddToArrayVariableEntityData {
}

pub static ADDTOARRAYVARIABLEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AddToArrayVariableEntityData",
    name_hash: 3838851691,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(WRITEVARIABLEBASEENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(AddToArrayVariableEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AddToArrayVariableEntityData as Default>::default())),
            create_boxed: || Box::new(<AddToArrayVariableEntityData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(ADDTOARRAYVARIABLEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AddToArrayVariableEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        ADDTOARRAYVARIABLEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ADDTOARRAYVARIABLEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AddToArrayVariableEntityData-Array",
    name_hash: 1655966303,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("AddToArrayVariableEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct WriteVariableEntityData {
    pub _glacier_base: WriteVariableBaseEntityData,
}

pub trait WriteVariableEntityDataTrait: WriteVariableBaseEntityDataTrait {
}

impl WriteVariableEntityDataTrait for WriteVariableEntityData {
}

impl WriteVariableBaseEntityDataTrait for WriteVariableEntityData {
}

impl VariableBaseEntityDataTrait for WriteVariableEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn field_name_hash(&self) -> &u32 {
        self._glacier_base.field_name_hash()
    }
    fn field_name_hash_mut(&mut self) -> &mut u32 {
        self._glacier_base.field_name_hash_mut()
    }
    fn field_type(&self) -> &glacier_reflect::builtin::TypeRef {
        self._glacier_base.field_type()
    }
    fn field_type_mut(&mut self) -> &mut glacier_reflect::builtin::TypeRef {
        self._glacier_base.field_type_mut()
    }
    fn field_offset(&self) -> &u32 {
        self._glacier_base.field_offset()
    }
    fn field_offset_mut(&mut self) -> &mut u32 {
        self._glacier_base.field_offset_mut()
    }
    fn use_data(&self) -> &bool {
        self._glacier_base.use_data()
    }
    fn use_data_mut(&mut self) -> &mut bool {
        self._glacier_base.use_data_mut()
    }
}

impl EntityDataTrait for WriteVariableEntityData {
}

impl GameObjectDataTrait for WriteVariableEntityData {
}

impl super::core::DataBusPeerTrait for WriteVariableEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for WriteVariableEntityData {
}

impl super::core::DataContainerTrait for WriteVariableEntityData {
}

pub static WRITEVARIABLEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteVariableEntityData",
    name_hash: 1388411093,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(WRITEVARIABLEBASEENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(WriteVariableEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WriteVariableEntityData as Default>::default())),
            create_boxed: || Box::new(<WriteVariableEntityData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(WRITEVARIABLEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WriteVariableEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        WRITEVARIABLEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WRITEVARIABLEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteVariableEntityData-Array",
    name_hash: 2954950881,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("WriteVariableEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ReadVariableEntityData {
    pub _glacier_base: ReadVariableBaseEntityData,
}

pub trait ReadVariableEntityDataTrait: ReadVariableBaseEntityDataTrait {
}

impl ReadVariableEntityDataTrait for ReadVariableEntityData {
}

impl ReadVariableBaseEntityDataTrait for ReadVariableEntityData {
}

impl VariableBaseEntityDataTrait for ReadVariableEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn field_name_hash(&self) -> &u32 {
        self._glacier_base.field_name_hash()
    }
    fn field_name_hash_mut(&mut self) -> &mut u32 {
        self._glacier_base.field_name_hash_mut()
    }
    fn field_type(&self) -> &glacier_reflect::builtin::TypeRef {
        self._glacier_base.field_type()
    }
    fn field_type_mut(&mut self) -> &mut glacier_reflect::builtin::TypeRef {
        self._glacier_base.field_type_mut()
    }
    fn field_offset(&self) -> &u32 {
        self._glacier_base.field_offset()
    }
    fn field_offset_mut(&mut self) -> &mut u32 {
        self._glacier_base.field_offset_mut()
    }
    fn use_data(&self) -> &bool {
        self._glacier_base.use_data()
    }
    fn use_data_mut(&mut self) -> &mut bool {
        self._glacier_base.use_data_mut()
    }
}

impl EntityDataTrait for ReadVariableEntityData {
}

impl GameObjectDataTrait for ReadVariableEntityData {
}

impl super::core::DataBusPeerTrait for ReadVariableEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ReadVariableEntityData {
}

impl super::core::DataContainerTrait for ReadVariableEntityData {
}

pub static READVARIABLEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadVariableEntityData",
    name_hash: 771448122,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(READVARIABLEBASEENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(ReadVariableEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ReadVariableEntityData as Default>::default())),
            create_boxed: || Box::new(<ReadVariableEntityData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(READVARIABLEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ReadVariableEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        READVARIABLEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static READVARIABLEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadVariableEntityData-Array",
    name_hash: 2312486798,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ReadVariableEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct WriteVariableBaseEntityData {
    pub _glacier_base: VariableBaseEntityData,
}

pub trait WriteVariableBaseEntityDataTrait: VariableBaseEntityDataTrait {
}

impl WriteVariableBaseEntityDataTrait for WriteVariableBaseEntityData {
}

impl VariableBaseEntityDataTrait for WriteVariableBaseEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn field_name_hash(&self) -> &u32 {
        self._glacier_base.field_name_hash()
    }
    fn field_name_hash_mut(&mut self) -> &mut u32 {
        self._glacier_base.field_name_hash_mut()
    }
    fn field_type(&self) -> &glacier_reflect::builtin::TypeRef {
        self._glacier_base.field_type()
    }
    fn field_type_mut(&mut self) -> &mut glacier_reflect::builtin::TypeRef {
        self._glacier_base.field_type_mut()
    }
    fn field_offset(&self) -> &u32 {
        self._glacier_base.field_offset()
    }
    fn field_offset_mut(&mut self) -> &mut u32 {
        self._glacier_base.field_offset_mut()
    }
    fn use_data(&self) -> &bool {
        self._glacier_base.use_data()
    }
    fn use_data_mut(&mut self) -> &mut bool {
        self._glacier_base.use_data_mut()
    }
}

impl EntityDataTrait for WriteVariableBaseEntityData {
}

impl GameObjectDataTrait for WriteVariableBaseEntityData {
}

impl super::core::DataBusPeerTrait for WriteVariableBaseEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for WriteVariableBaseEntityData {
}

impl super::core::DataContainerTrait for WriteVariableBaseEntityData {
}

pub static WRITEVARIABLEBASEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteVariableBaseEntityData",
    name_hash: 4290470144,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VARIABLEBASEENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(WriteVariableBaseEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WriteVariableBaseEntityData as Default>::default())),
            create_boxed: || Box::new(<WriteVariableBaseEntityData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(WRITEVARIABLEBASEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WriteVariableBaseEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        WRITEVARIABLEBASEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WRITEVARIABLEBASEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteVariableBaseEntityData-Array",
    name_hash: 3583952692,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("WriteVariableBaseEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ReadVariableBaseEntityData {
    pub _glacier_base: VariableBaseEntityData,
}

pub trait ReadVariableBaseEntityDataTrait: VariableBaseEntityDataTrait {
}

impl ReadVariableBaseEntityDataTrait for ReadVariableBaseEntityData {
}

impl VariableBaseEntityDataTrait for ReadVariableBaseEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn field_name_hash(&self) -> &u32 {
        self._glacier_base.field_name_hash()
    }
    fn field_name_hash_mut(&mut self) -> &mut u32 {
        self._glacier_base.field_name_hash_mut()
    }
    fn field_type(&self) -> &glacier_reflect::builtin::TypeRef {
        self._glacier_base.field_type()
    }
    fn field_type_mut(&mut self) -> &mut glacier_reflect::builtin::TypeRef {
        self._glacier_base.field_type_mut()
    }
    fn field_offset(&self) -> &u32 {
        self._glacier_base.field_offset()
    }
    fn field_offset_mut(&mut self) -> &mut u32 {
        self._glacier_base.field_offset_mut()
    }
    fn use_data(&self) -> &bool {
        self._glacier_base.use_data()
    }
    fn use_data_mut(&mut self) -> &mut bool {
        self._glacier_base.use_data_mut()
    }
}

impl EntityDataTrait for ReadVariableBaseEntityData {
}

impl GameObjectDataTrait for ReadVariableBaseEntityData {
}

impl super::core::DataBusPeerTrait for ReadVariableBaseEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ReadVariableBaseEntityData {
}

impl super::core::DataContainerTrait for ReadVariableBaseEntityData {
}

pub static READVARIABLEBASEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadVariableBaseEntityData",
    name_hash: 1843956143,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VARIABLEBASEENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(ReadVariableBaseEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ReadVariableBaseEntityData as Default>::default())),
            create_boxed: || Box::new(<ReadVariableBaseEntityData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(READVARIABLEBASEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ReadVariableBaseEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        READVARIABLEBASEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static READVARIABLEBASEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadVariableBaseEntityData-Array",
    name_hash: 3986061083,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ReadVariableBaseEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct VariableBaseEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub field_name_hash: u32,
    pub field_type: glacier_reflect::builtin::TypeRef,
    pub field_offset: u32,
    pub use_data: bool,
}

pub trait VariableBaseEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn field_name_hash(&self) -> &u32;
    fn field_name_hash_mut(&mut self) -> &mut u32;
    fn field_type(&self) -> &glacier_reflect::builtin::TypeRef;
    fn field_type_mut(&mut self) -> &mut glacier_reflect::builtin::TypeRef;
    fn field_offset(&self) -> &u32;
    fn field_offset_mut(&mut self) -> &mut u32;
    fn use_data(&self) -> &bool;
    fn use_data_mut(&mut self) -> &mut bool;
}

impl VariableBaseEntityDataTrait for VariableBaseEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn field_name_hash(&self) -> &u32 {
        &self.field_name_hash
    }
    fn field_name_hash_mut(&mut self) -> &mut u32 {
        &mut self.field_name_hash
    }
    fn field_type(&self) -> &glacier_reflect::builtin::TypeRef {
        &self.field_type
    }
    fn field_type_mut(&mut self) -> &mut glacier_reflect::builtin::TypeRef {
        &mut self.field_type
    }
    fn field_offset(&self) -> &u32 {
        &self.field_offset
    }
    fn field_offset_mut(&mut self) -> &mut u32 {
        &mut self.field_offset
    }
    fn use_data(&self) -> &bool {
        &self.use_data
    }
    fn use_data_mut(&mut self) -> &mut bool {
        &mut self.use_data
    }
}

impl EntityDataTrait for VariableBaseEntityData {
}

impl GameObjectDataTrait for VariableBaseEntityData {
}

impl super::core::DataBusPeerTrait for VariableBaseEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for VariableBaseEntityData {
}

impl super::core::DataContainerTrait for VariableBaseEntityData {
}

pub static VARIABLEBASEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VariableBaseEntityData",
    name_hash: 1320332349,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(VariableBaseEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VariableBaseEntityData as Default>::default())),
            create_boxed: || Box::new(<VariableBaseEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(VariableBaseEntityData, realm),
            },
            FieldInfoData {
                name: "FieldNameHash",
                name_hash: 4253991058,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(VariableBaseEntityData, field_name_hash),
            },
            FieldInfoData {
                name: "FieldType",
                name_hash: 3059058943,
                flags: MemberInfoFlags::new(0),
                field_type: "TypeRef",
                rust_offset: offset_of!(VariableBaseEntityData, field_type),
            },
            FieldInfoData {
                name: "FieldOffset",
                name_hash: 2228247466,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(VariableBaseEntityData, field_offset),
            },
            FieldInfoData {
                name: "UseData",
                name_hash: 2350151606,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VariableBaseEntityData, use_data),
            },
        ],
    }),
    array_type: Some(VARIABLEBASEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for VariableBaseEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VARIABLEBASEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VARIABLEBASEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VariableBaseEntityData-Array",
    name_hash: 2892679305,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("VariableBaseEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct HighlightEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub color: super::core::Vec3,
    pub alpha: u8,
    pub top_left: super::core::Vec2,
    pub bottom_right: super::core::Vec2,
}

pub trait HighlightEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn color(&self) -> &super::core::Vec3;
    fn color_mut(&mut self) -> &mut super::core::Vec3;
    fn alpha(&self) -> &u8;
    fn alpha_mut(&mut self) -> &mut u8;
    fn top_left(&self) -> &super::core::Vec2;
    fn top_left_mut(&mut self) -> &mut super::core::Vec2;
    fn bottom_right(&self) -> &super::core::Vec2;
    fn bottom_right_mut(&mut self) -> &mut super::core::Vec2;
}

impl HighlightEntityDataTrait for HighlightEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn color(&self) -> &super::core::Vec3 {
        &self.color
    }
    fn color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.color
    }
    fn alpha(&self) -> &u8 {
        &self.alpha
    }
    fn alpha_mut(&mut self) -> &mut u8 {
        &mut self.alpha
    }
    fn top_left(&self) -> &super::core::Vec2 {
        &self.top_left
    }
    fn top_left_mut(&mut self) -> &mut super::core::Vec2 {
        &mut self.top_left
    }
    fn bottom_right(&self) -> &super::core::Vec2 {
        &self.bottom_right
    }
    fn bottom_right_mut(&mut self) -> &mut super::core::Vec2 {
        &mut self.bottom_right
    }
}

impl EntityDataTrait for HighlightEntityData {
}

impl GameObjectDataTrait for HighlightEntityData {
}

impl super::core::DataBusPeerTrait for HighlightEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for HighlightEntityData {
}

impl super::core::DataContainerTrait for HighlightEntityData {
}

pub static HIGHLIGHTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HighlightEntityData",
    name_hash: 4200112862,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(HighlightEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<HighlightEntityData as Default>::default())),
            create_boxed: || Box::new(<HighlightEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(HighlightEntityData, realm),
            },
            FieldInfoData {
                name: "Color",
                name_hash: 212387320,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(HighlightEntityData, color),
            },
            FieldInfoData {
                name: "Alpha",
                name_hash: 205677681,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(HighlightEntityData, alpha),
            },
            FieldInfoData {
                name: "TopLeft",
                name_hash: 3716917173,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(HighlightEntityData, top_left),
            },
            FieldInfoData {
                name: "BottomRight",
                name_hash: 626009514,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(HighlightEntityData, bottom_right),
            },
        ],
    }),
    array_type: Some(HIGHLIGHTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for HighlightEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        HIGHLIGHTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static HIGHLIGHTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HighlightEntityData-Array",
    name_hash: 2909054058,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("HighlightEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TextSequenceEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub events: Vec<String>,
    pub items: Vec<Option<LockedTypeObject /* TextSequenceItem */>>,
    pub screen_position: super::core::Vec2,
}

pub trait TextSequenceEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn events(&self) -> &Vec<String>;
    fn events_mut(&mut self) -> &mut Vec<String>;
    fn items(&self) -> &Vec<Option<LockedTypeObject /* TextSequenceItem */>>;
    fn items_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* TextSequenceItem */>>;
    fn screen_position(&self) -> &super::core::Vec2;
    fn screen_position_mut(&mut self) -> &mut super::core::Vec2;
}

impl TextSequenceEntityDataTrait for TextSequenceEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn events(&self) -> &Vec<String> {
        &self.events
    }
    fn events_mut(&mut self) -> &mut Vec<String> {
        &mut self.events
    }
    fn items(&self) -> &Vec<Option<LockedTypeObject /* TextSequenceItem */>> {
        &self.items
    }
    fn items_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* TextSequenceItem */>> {
        &mut self.items
    }
    fn screen_position(&self) -> &super::core::Vec2 {
        &self.screen_position
    }
    fn screen_position_mut(&mut self) -> &mut super::core::Vec2 {
        &mut self.screen_position
    }
}

impl EntityDataTrait for TextSequenceEntityData {
}

impl GameObjectDataTrait for TextSequenceEntityData {
}

impl super::core::DataBusPeerTrait for TextSequenceEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TextSequenceEntityData {
}

impl super::core::DataContainerTrait for TextSequenceEntityData {
}

pub static TEXTSEQUENCEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TextSequenceEntityData",
    name_hash: 1379040428,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(TextSequenceEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TextSequenceEntityData as Default>::default())),
            create_boxed: || Box::new(<TextSequenceEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(TextSequenceEntityData, realm),
            },
            FieldInfoData {
                name: "Events",
                name_hash: 2352146554,
                flags: MemberInfoFlags::new(144),
                field_type: "CString-Array",
                rust_offset: offset_of!(TextSequenceEntityData, events),
            },
            FieldInfoData {
                name: "Items",
                name_hash: 215446531,
                flags: MemberInfoFlags::new(144),
                field_type: "TextSequenceItem-Array",
                rust_offset: offset_of!(TextSequenceEntityData, items),
            },
            FieldInfoData {
                name: "ScreenPosition",
                name_hash: 2288910864,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(TextSequenceEntityData, screen_position),
            },
        ],
    }),
    array_type: Some(TEXTSEQUENCEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TextSequenceEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TEXTSEQUENCEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TEXTSEQUENCEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TextSequenceEntityData-Array",
    name_hash: 1027271704,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TextSequenceEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TextSequenceItem {
    pub _glacier_base: super::core::DataContainer,
    pub text: String,
    pub text_color: super::core::Vec3,
    pub screen_position: super::core::Vec2,
    pub use_entity_screen_position: bool,
    pub time_to_show: f32,
    pub trigger_event: String,
}

pub trait TextSequenceItemTrait: super::core::DataContainerTrait {
    fn text(&self) -> &String;
    fn text_mut(&mut self) -> &mut String;
    fn text_color(&self) -> &super::core::Vec3;
    fn text_color_mut(&mut self) -> &mut super::core::Vec3;
    fn screen_position(&self) -> &super::core::Vec2;
    fn screen_position_mut(&mut self) -> &mut super::core::Vec2;
    fn use_entity_screen_position(&self) -> &bool;
    fn use_entity_screen_position_mut(&mut self) -> &mut bool;
    fn time_to_show(&self) -> &f32;
    fn time_to_show_mut(&mut self) -> &mut f32;
    fn trigger_event(&self) -> &String;
    fn trigger_event_mut(&mut self) -> &mut String;
}

impl TextSequenceItemTrait for TextSequenceItem {
    fn text(&self) -> &String {
        &self.text
    }
    fn text_mut(&mut self) -> &mut String {
        &mut self.text
    }
    fn text_color(&self) -> &super::core::Vec3 {
        &self.text_color
    }
    fn text_color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.text_color
    }
    fn screen_position(&self) -> &super::core::Vec2 {
        &self.screen_position
    }
    fn screen_position_mut(&mut self) -> &mut super::core::Vec2 {
        &mut self.screen_position
    }
    fn use_entity_screen_position(&self) -> &bool {
        &self.use_entity_screen_position
    }
    fn use_entity_screen_position_mut(&mut self) -> &mut bool {
        &mut self.use_entity_screen_position
    }
    fn time_to_show(&self) -> &f32 {
        &self.time_to_show
    }
    fn time_to_show_mut(&mut self) -> &mut f32 {
        &mut self.time_to_show
    }
    fn trigger_event(&self) -> &String {
        &self.trigger_event
    }
    fn trigger_event_mut(&mut self) -> &mut String {
        &mut self.trigger_event
    }
}

impl super::core::DataContainerTrait for TextSequenceItem {
}

pub static TEXTSEQUENCEITEM_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TextSequenceItem",
    name_hash: 2673554290,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(TextSequenceItem, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TextSequenceItem as Default>::default())),
            create_boxed: || Box::new(<TextSequenceItem as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Text",
                name_hash: 2089309304,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(TextSequenceItem, text),
            },
            FieldInfoData {
                name: "TextColor",
                name_hash: 2527550245,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(TextSequenceItem, text_color),
            },
            FieldInfoData {
                name: "ScreenPosition",
                name_hash: 2288910864,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(TextSequenceItem, screen_position),
            },
            FieldInfoData {
                name: "UseEntityScreenPosition",
                name_hash: 2699366408,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TextSequenceItem, use_entity_screen_position),
            },
            FieldInfoData {
                name: "TimeToShow",
                name_hash: 1572258312,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TextSequenceItem, time_to_show),
            },
            FieldInfoData {
                name: "TriggerEvent",
                name_hash: 3587741969,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(TextSequenceItem, trigger_event),
            },
        ],
    }),
    array_type: Some(TEXTSEQUENCEITEM_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for TextSequenceItem {
    fn type_info(&self) -> &'static TypeInfo {
        TEXTSEQUENCEITEM_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TEXTSEQUENCEITEM_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TextSequenceItem-Array",
    name_hash: 1744677446,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TextSequenceItem"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TreeBase {
    pub _glacier_base: super::core::Asset,
}

pub trait TreeBaseTrait: super::core::AssetTrait {
}

impl TreeBaseTrait for TreeBase {
}

impl super::core::AssetTrait for TreeBase {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for TreeBase {
}

pub static TREEBASE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TreeBase",
    name_hash: 4238092246,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        super_class_offset: offset_of!(TreeBase, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TreeBase as Default>::default())),
            create_boxed: || Box::new(<TreeBase as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(TREEBASE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TreeBase {
    fn type_info(&self) -> &'static TypeInfo {
        TREEBASE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TREEBASE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TreeBase-Array",
    name_hash: 3573058914,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TreeBase"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TreeNodeBase {
    pub _glacier_base: super::core::DataContainer,
}

pub trait TreeNodeBaseTrait: super::core::DataContainerTrait {
}

impl TreeNodeBaseTrait for TreeNodeBase {
}

impl super::core::DataContainerTrait for TreeNodeBase {
}

pub static TREENODEBASE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TreeNodeBase",
    name_hash: 2053360182,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(TreeNodeBase, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TreeNodeBase as Default>::default())),
            create_boxed: || Box::new(<TreeNodeBase as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(TREENODEBASE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TreeNodeBase {
    fn type_info(&self) -> &'static TypeInfo {
        TREENODEBASE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TREENODEBASE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TreeNodeBase-Array",
    name_hash: 4007411330,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TreeNodeBase"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SubLevelDestroyedMessage {
}

pub trait SubLevelDestroyedMessageTrait: TypeObject {
}

impl SubLevelDestroyedMessageTrait for SubLevelDestroyedMessage {
}

pub static SUBLEVELDESTROYEDMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubLevelDestroyedMessage",
    name_hash: 1013789343,
    flags: MemberInfoFlags::new(36937),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SubLevelDestroyedMessage as Default>::default())),
            create_boxed: || Box::new(<SubLevelDestroyedMessage as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for SubLevelDestroyedMessage {
    fn type_info(&self) -> &'static TypeInfo {
        SUBLEVELDESTROYEDMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Debug, Default)]
#[repr(C)]
pub struct SubLevelEntitiesCreatedMessage {
}

pub trait SubLevelEntitiesCreatedMessageTrait: TypeObject {
}

impl SubLevelEntitiesCreatedMessageTrait for SubLevelEntitiesCreatedMessage {
}

pub static SUBLEVELENTITIESCREATEDMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubLevelEntitiesCreatedMessage",
    name_hash: 2720897889,
    flags: MemberInfoFlags::new(36937),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SubLevelEntitiesCreatedMessage as Default>::default())),
            create_boxed: || Box::new(<SubLevelEntitiesCreatedMessage as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for SubLevelEntitiesCreatedMessage {
    fn type_info(&self) -> &'static TypeInfo {
        SUBLEVELENTITIESCREATEDMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Debug, Default)]
#[repr(C)]
pub struct ReportInstallationProgressEntityData {
    pub _glacier_base: EntityData,
    pub install_group_name: String,
}

pub trait ReportInstallationProgressEntityDataTrait: EntityDataTrait {
    fn install_group_name(&self) -> &String;
    fn install_group_name_mut(&mut self) -> &mut String;
}

impl ReportInstallationProgressEntityDataTrait for ReportInstallationProgressEntityData {
    fn install_group_name(&self) -> &String {
        &self.install_group_name
    }
    fn install_group_name_mut(&mut self) -> &mut String {
        &mut self.install_group_name
    }
}

impl EntityDataTrait for ReportInstallationProgressEntityData {
}

impl GameObjectDataTrait for ReportInstallationProgressEntityData {
}

impl super::core::DataBusPeerTrait for ReportInstallationProgressEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ReportInstallationProgressEntityData {
}

impl super::core::DataContainerTrait for ReportInstallationProgressEntityData {
}

pub static REPORTINSTALLATIONPROGRESSENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReportInstallationProgressEntityData",
    name_hash: 843041153,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(ReportInstallationProgressEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ReportInstallationProgressEntityData as Default>::default())),
            create_boxed: || Box::new(<ReportInstallationProgressEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "InstallGroupName",
                name_hash: 384214428,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ReportInstallationProgressEntityData, install_group_name),
            },
        ],
    }),
    array_type: Some(REPORTINSTALLATIONPROGRESSENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ReportInstallationProgressEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        REPORTINSTALLATIONPROGRESSENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static REPORTINSTALLATIONPROGRESSENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReportInstallationProgressEntityData-Array",
    name_hash: 3166331701,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ReportInstallationProgressEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct LocalPlayerIdEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub default_value: super::core::LocalPlayerId,
    pub r#in: super::core::LocalPlayerId,
}

pub trait LocalPlayerIdEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn default_value(&self) -> &super::core::LocalPlayerId;
    fn default_value_mut(&mut self) -> &mut super::core::LocalPlayerId;
    fn r#in(&self) -> &super::core::LocalPlayerId;
    fn r#in_mut(&mut self) -> &mut super::core::LocalPlayerId;
}

impl LocalPlayerIdEntityDataTrait for LocalPlayerIdEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn default_value(&self) -> &super::core::LocalPlayerId {
        &self.default_value
    }
    fn default_value_mut(&mut self) -> &mut super::core::LocalPlayerId {
        &mut self.default_value
    }
    fn r#in(&self) -> &super::core::LocalPlayerId {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut super::core::LocalPlayerId {
        &mut self.r#in
    }
}

impl EntityDataTrait for LocalPlayerIdEntityData {
}

impl GameObjectDataTrait for LocalPlayerIdEntityData {
}

impl super::core::DataBusPeerTrait for LocalPlayerIdEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for LocalPlayerIdEntityData {
}

impl super::core::DataContainerTrait for LocalPlayerIdEntityData {
}

pub static LOCALPLAYERIDENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalPlayerIdEntityData",
    name_hash: 1508500733,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(LocalPlayerIdEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LocalPlayerIdEntityData as Default>::default())),
            create_boxed: || Box::new(<LocalPlayerIdEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(LocalPlayerIdEntityData, realm),
            },
            FieldInfoData {
                name: "DefaultValue",
                name_hash: 2066049125,
                flags: MemberInfoFlags::new(0),
                field_type: "LocalPlayerId",
                rust_offset: offset_of!(LocalPlayerIdEntityData, default_value),
            },
            FieldInfoData {
                name: "In",
                name_hash: 5862146,
                flags: MemberInfoFlags::new(0),
                field_type: "LocalPlayerId",
                rust_offset: offset_of!(LocalPlayerIdEntityData, r#in),
            },
        ],
    }),
    array_type: Some(LOCALPLAYERIDENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LocalPlayerIdEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        LOCALPLAYERIDENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LOCALPLAYERIDENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalPlayerIdEntityData-Array",
    name_hash: 2267664841,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("LocalPlayerIdEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct FloatCacheEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub load_on_create: bool,
    pub in_value: f32,
}

pub trait FloatCacheEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn load_on_create(&self) -> &bool;
    fn load_on_create_mut(&mut self) -> &mut bool;
    fn in_value(&self) -> &f32;
    fn in_value_mut(&mut self) -> &mut f32;
}

impl FloatCacheEntityDataTrait for FloatCacheEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn load_on_create(&self) -> &bool {
        &self.load_on_create
    }
    fn load_on_create_mut(&mut self) -> &mut bool {
        &mut self.load_on_create
    }
    fn in_value(&self) -> &f32 {
        &self.in_value
    }
    fn in_value_mut(&mut self) -> &mut f32 {
        &mut self.in_value
    }
}

impl EntityDataTrait for FloatCacheEntityData {
}

impl GameObjectDataTrait for FloatCacheEntityData {
}

impl super::core::DataBusPeerTrait for FloatCacheEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for FloatCacheEntityData {
}

impl super::core::DataContainerTrait for FloatCacheEntityData {
}

pub static FLOATCACHEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatCacheEntityData",
    name_hash: 1279773490,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(FloatCacheEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FloatCacheEntityData as Default>::default())),
            create_boxed: || Box::new(<FloatCacheEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(FloatCacheEntityData, realm),
            },
            FieldInfoData {
                name: "LoadOnCreate",
                name_hash: 4195698790,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FloatCacheEntityData, load_on_create),
            },
            FieldInfoData {
                name: "InValue",
                name_hash: 1658462601,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FloatCacheEntityData, in_value),
            },
        ],
    }),
    array_type: Some(FLOATCACHEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FloatCacheEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        FLOATCACHEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FLOATCACHEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatCacheEntityData-Array",
    name_hash: 1958564230,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("FloatCacheEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct MultilineStringEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub value: String,
}

pub trait MultilineStringEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn value(&self) -> &String;
    fn value_mut(&mut self) -> &mut String;
}

impl MultilineStringEntityDataTrait for MultilineStringEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn value(&self) -> &String {
        &self.value
    }
    fn value_mut(&mut self) -> &mut String {
        &mut self.value
    }
}

impl EntityDataTrait for MultilineStringEntityData {
}

impl GameObjectDataTrait for MultilineStringEntityData {
}

impl super::core::DataBusPeerTrait for MultilineStringEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for MultilineStringEntityData {
}

impl super::core::DataContainerTrait for MultilineStringEntityData {
}

pub static MULTILINESTRINGENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultilineStringEntityData",
    name_hash: 569498364,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(MultilineStringEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MultilineStringEntityData as Default>::default())),
            create_boxed: || Box::new(<MultilineStringEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(MultilineStringEntityData, realm),
            },
            FieldInfoData {
                name: "Value",
                name_hash: 225375086,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(MultilineStringEntityData, value),
            },
        ],
    }),
    array_type: Some(MULTILINESTRINGENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MultilineStringEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        MULTILINESTRINGENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MULTILINESTRINGENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultilineStringEntityData-Array",
    name_hash: 2280047304,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("MultilineStringEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct StringEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub default_string: String,
}

pub trait StringEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn default_string(&self) -> &String;
    fn default_string_mut(&mut self) -> &mut String;
}

impl StringEntityDataTrait for StringEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn default_string(&self) -> &String {
        &self.default_string
    }
    fn default_string_mut(&mut self) -> &mut String {
        &mut self.default_string
    }
}

impl EntityDataTrait for StringEntityData {
}

impl GameObjectDataTrait for StringEntityData {
}

impl super::core::DataBusPeerTrait for StringEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for StringEntityData {
}

impl super::core::DataContainerTrait for StringEntityData {
}

pub static STRINGENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StringEntityData",
    name_hash: 978612923,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(StringEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StringEntityData as Default>::default())),
            create_boxed: || Box::new(<StringEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(StringEntityData, realm),
            },
            FieldInfoData {
                name: "DefaultString",
                name_hash: 4156748411,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(StringEntityData, default_string),
            },
        ],
    }),
    array_type: Some(STRINGENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for StringEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        STRINGENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static STRINGENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StringEntityData-Array",
    name_hash: 2380282383,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("StringEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TransformEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub default_transform: super::core::LinearTransform,
}

pub trait TransformEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn default_transform(&self) -> &super::core::LinearTransform;
    fn default_transform_mut(&mut self) -> &mut super::core::LinearTransform;
}

impl TransformEntityDataTrait for TransformEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn default_transform(&self) -> &super::core::LinearTransform {
        &self.default_transform
    }
    fn default_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.default_transform
    }
}

impl EntityDataTrait for TransformEntityData {
}

impl GameObjectDataTrait for TransformEntityData {
}

impl super::core::DataBusPeerTrait for TransformEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TransformEntityData {
}

impl super::core::DataContainerTrait for TransformEntityData {
}

pub static TRANSFORMENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformEntityData",
    name_hash: 134583810,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(TransformEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformEntityData as Default>::default())),
            create_boxed: || Box::new(<TransformEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(TransformEntityData, realm),
            },
            FieldInfoData {
                name: "DefaultTransform",
                name_hash: 1812491362,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(TransformEntityData, default_transform),
            },
        ],
    }),
    array_type: Some(TRANSFORMENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for TransformEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TRANSFORMENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformEntityData-Array",
    name_hash: 3584619830,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TransformEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct AxisAlignedBoxEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub aabb_min: super::core::Vec3,
    pub aabb_max: super::core::Vec3,
}

pub trait AxisAlignedBoxEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn aabb_min(&self) -> &super::core::Vec3;
    fn aabb_min_mut(&mut self) -> &mut super::core::Vec3;
    fn aabb_max(&self) -> &super::core::Vec3;
    fn aabb_max_mut(&mut self) -> &mut super::core::Vec3;
}

impl AxisAlignedBoxEntityDataTrait for AxisAlignedBoxEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn aabb_min(&self) -> &super::core::Vec3 {
        &self.aabb_min
    }
    fn aabb_min_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.aabb_min
    }
    fn aabb_max(&self) -> &super::core::Vec3 {
        &self.aabb_max
    }
    fn aabb_max_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.aabb_max
    }
}

impl EntityDataTrait for AxisAlignedBoxEntityData {
}

impl GameObjectDataTrait for AxisAlignedBoxEntityData {
}

impl super::core::DataBusPeerTrait for AxisAlignedBoxEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AxisAlignedBoxEntityData {
}

impl super::core::DataContainerTrait for AxisAlignedBoxEntityData {
}

pub static AXISALIGNEDBOXENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AxisAlignedBoxEntityData",
    name_hash: 293091700,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(AxisAlignedBoxEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AxisAlignedBoxEntityData as Default>::default())),
            create_boxed: || Box::new(<AxisAlignedBoxEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(AxisAlignedBoxEntityData, realm),
            },
            FieldInfoData {
                name: "AabbMin",
                name_hash: 439431439,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(AxisAlignedBoxEntityData, aabb_min),
            },
            FieldInfoData {
                name: "AabbMax",
                name_hash: 439431697,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(AxisAlignedBoxEntityData, aabb_max),
            },
        ],
    }),
    array_type: Some(AXISALIGNEDBOXENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AxisAlignedBoxEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AXISALIGNEDBOXENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AXISALIGNEDBOXENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AxisAlignedBoxEntityData-Array",
    name_hash: 2698683712,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("AxisAlignedBoxEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct Vector4EntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub default_vec4: super::core::Vec4,
}

pub trait Vector4EntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn default_vec4(&self) -> &super::core::Vec4;
    fn default_vec4_mut(&mut self) -> &mut super::core::Vec4;
}

impl Vector4EntityDataTrait for Vector4EntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn default_vec4(&self) -> &super::core::Vec4 {
        &self.default_vec4
    }
    fn default_vec4_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.default_vec4
    }
}

impl EntityDataTrait for Vector4EntityData {
}

impl GameObjectDataTrait for Vector4EntityData {
}

impl super::core::DataBusPeerTrait for Vector4EntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for Vector4EntityData {
}

impl super::core::DataContainerTrait for Vector4EntityData {
}

pub static VECTOR4ENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vector4EntityData",
    name_hash: 3992958051,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(Vector4EntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vector4EntityData as Default>::default())),
            create_boxed: || Box::new(<Vector4EntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(Vector4EntityData, realm),
            },
            FieldInfoData {
                name: "DefaultVec4",
                name_hash: 2014870058,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(Vector4EntityData, default_vec4),
            },
        ],
    }),
    array_type: Some(VECTOR4ENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for Vector4EntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VECTOR4ENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VECTOR4ENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vector4EntityData-Array",
    name_hash: 1368893527,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vector4EntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct Vector3EntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub default_vec3: super::core::Vec3,
}

pub trait Vector3EntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn default_vec3(&self) -> &super::core::Vec3;
    fn default_vec3_mut(&mut self) -> &mut super::core::Vec3;
}

impl Vector3EntityDataTrait for Vector3EntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn default_vec3(&self) -> &super::core::Vec3 {
        &self.default_vec3
    }
    fn default_vec3_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.default_vec3
    }
}

impl EntityDataTrait for Vector3EntityData {
}

impl GameObjectDataTrait for Vector3EntityData {
}

impl super::core::DataBusPeerTrait for Vector3EntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for Vector3EntityData {
}

impl super::core::DataContainerTrait for Vector3EntityData {
}

pub static VECTOR3ENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vector3EntityData",
    name_hash: 1226610340,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(Vector3EntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vector3EntityData as Default>::default())),
            create_boxed: || Box::new(<Vector3EntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(Vector3EntityData, realm),
            },
            FieldInfoData {
                name: "DefaultVec3",
                name_hash: 2014870061,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(Vector3EntityData, default_vec3),
            },
        ],
    }),
    array_type: Some(VECTOR3ENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for Vector3EntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VECTOR3ENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VECTOR3ENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vector3EntityData-Array",
    name_hash: 1666263568,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vector3EntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct FloatEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub default_value: f32,
    pub inc_dec_value: f32,
}

pub trait FloatEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn default_value(&self) -> &f32;
    fn default_value_mut(&mut self) -> &mut f32;
    fn inc_dec_value(&self) -> &f32;
    fn inc_dec_value_mut(&mut self) -> &mut f32;
}

impl FloatEntityDataTrait for FloatEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn default_value(&self) -> &f32 {
        &self.default_value
    }
    fn default_value_mut(&mut self) -> &mut f32 {
        &mut self.default_value
    }
    fn inc_dec_value(&self) -> &f32 {
        &self.inc_dec_value
    }
    fn inc_dec_value_mut(&mut self) -> &mut f32 {
        &mut self.inc_dec_value
    }
}

impl EntityDataTrait for FloatEntityData {
}

impl GameObjectDataTrait for FloatEntityData {
}

impl super::core::DataBusPeerTrait for FloatEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for FloatEntityData {
}

impl super::core::DataContainerTrait for FloatEntityData {
}

pub static FLOATENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatEntityData",
    name_hash: 2274474750,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(FloatEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FloatEntityData as Default>::default())),
            create_boxed: || Box::new(<FloatEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(FloatEntityData, realm),
            },
            FieldInfoData {
                name: "DefaultValue",
                name_hash: 2066049125,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FloatEntityData, default_value),
            },
            FieldInfoData {
                name: "IncDecValue",
                name_hash: 3097399752,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FloatEntityData, inc_dec_value),
            },
        ],
    }),
    array_type: Some(FLOATENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FloatEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        FLOATENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FLOATENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatEntityData-Array",
    name_hash: 4154121162,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("FloatEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct UIntEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub default_value: u32,
    pub inc_dec_value: u32,
}

pub trait UIntEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn default_value(&self) -> &u32;
    fn default_value_mut(&mut self) -> &mut u32;
    fn inc_dec_value(&self) -> &u32;
    fn inc_dec_value_mut(&mut self) -> &mut u32;
}

impl UIntEntityDataTrait for UIntEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn default_value(&self) -> &u32 {
        &self.default_value
    }
    fn default_value_mut(&mut self) -> &mut u32 {
        &mut self.default_value
    }
    fn inc_dec_value(&self) -> &u32 {
        &self.inc_dec_value
    }
    fn inc_dec_value_mut(&mut self) -> &mut u32 {
        &mut self.inc_dec_value
    }
}

impl EntityDataTrait for UIntEntityData {
}

impl GameObjectDataTrait for UIntEntityData {
}

impl super::core::DataBusPeerTrait for UIntEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for UIntEntityData {
}

impl super::core::DataContainerTrait for UIntEntityData {
}

pub static UINTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UIntEntityData",
    name_hash: 2656697480,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(UIntEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<UIntEntityData as Default>::default())),
            create_boxed: || Box::new(<UIntEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(UIntEntityData, realm),
            },
            FieldInfoData {
                name: "DefaultValue",
                name_hash: 2066049125,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(UIntEntityData, default_value),
            },
            FieldInfoData {
                name: "IncDecValue",
                name_hash: 3097399752,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(UIntEntityData, inc_dec_value),
            },
        ],
    }),
    array_type: Some(UINTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for UIntEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        UINTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static UINTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UIntEntityData-Array",
    name_hash: 3038994108,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("UIntEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct IntEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub default_value: i32,
    pub inc_dec_value: i32,
}

pub trait IntEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn default_value(&self) -> &i32;
    fn default_value_mut(&mut self) -> &mut i32;
    fn inc_dec_value(&self) -> &i32;
    fn inc_dec_value_mut(&mut self) -> &mut i32;
}

impl IntEntityDataTrait for IntEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn default_value(&self) -> &i32 {
        &self.default_value
    }
    fn default_value_mut(&mut self) -> &mut i32 {
        &mut self.default_value
    }
    fn inc_dec_value(&self) -> &i32 {
        &self.inc_dec_value
    }
    fn inc_dec_value_mut(&mut self) -> &mut i32 {
        &mut self.inc_dec_value
    }
}

impl EntityDataTrait for IntEntityData {
}

impl GameObjectDataTrait for IntEntityData {
}

impl super::core::DataBusPeerTrait for IntEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for IntEntityData {
}

impl super::core::DataContainerTrait for IntEntityData {
}

pub static INTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntEntityData",
    name_hash: 3115598749,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(IntEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<IntEntityData as Default>::default())),
            create_boxed: || Box::new(<IntEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(IntEntityData, realm),
            },
            FieldInfoData {
                name: "DefaultValue",
                name_hash: 2066049125,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(IntEntityData, default_value),
            },
            FieldInfoData {
                name: "IncDecValue",
                name_hash: 3097399752,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(IntEntityData, inc_dec_value),
            },
        ],
    }),
    array_type: Some(INTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for IntEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        INTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static INTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntEntityData-Array",
    name_hash: 2138320681,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("IntEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct BoolEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub default_value: bool,
}

pub trait BoolEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn default_value(&self) -> &bool;
    fn default_value_mut(&mut self) -> &mut bool;
}

impl BoolEntityDataTrait for BoolEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn default_value(&self) -> &bool {
        &self.default_value
    }
    fn default_value_mut(&mut self) -> &mut bool {
        &mut self.default_value
    }
}

impl EntityDataTrait for BoolEntityData {
}

impl GameObjectDataTrait for BoolEntityData {
}

impl super::core::DataBusPeerTrait for BoolEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for BoolEntityData {
}

impl super::core::DataContainerTrait for BoolEntityData {
}

pub static BOOLENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolEntityData",
    name_hash: 3649190752,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(BoolEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BoolEntityData as Default>::default())),
            create_boxed: || Box::new(<BoolEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(BoolEntityData, realm),
            },
            FieldInfoData {
                name: "DefaultValue",
                name_hash: 2066049125,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BoolEntityData, default_value),
            },
        ],
    }),
    array_type: Some(BOOLENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BoolEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        BOOLENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BOOLENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolEntityData-Array",
    name_hash: 3423318356,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("BoolEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct MasterSkeletonAsset {
    pub _glacier_base: super::core::Asset,
    pub master_skeleton: Option<LockedTypeObject /* SkeletonAsset */>,
    pub sub_skeletons: Vec<BoxedTypeObject /* SubSkeleton */>,
}

pub trait MasterSkeletonAssetTrait: super::core::AssetTrait {
    fn master_skeleton(&self) -> &Option<LockedTypeObject /* SkeletonAsset */>;
    fn master_skeleton_mut(&mut self) -> &mut Option<LockedTypeObject /* SkeletonAsset */>;
    fn sub_skeletons(&self) -> &Vec<BoxedTypeObject /* SubSkeleton */>;
    fn sub_skeletons_mut(&mut self) -> &mut Vec<BoxedTypeObject /* SubSkeleton */>;
}

impl MasterSkeletonAssetTrait for MasterSkeletonAsset {
    fn master_skeleton(&self) -> &Option<LockedTypeObject /* SkeletonAsset */> {
        &self.master_skeleton
    }
    fn master_skeleton_mut(&mut self) -> &mut Option<LockedTypeObject /* SkeletonAsset */> {
        &mut self.master_skeleton
    }
    fn sub_skeletons(&self) -> &Vec<BoxedTypeObject /* SubSkeleton */> {
        &self.sub_skeletons
    }
    fn sub_skeletons_mut(&mut self) -> &mut Vec<BoxedTypeObject /* SubSkeleton */> {
        &mut self.sub_skeletons
    }
}

impl super::core::AssetTrait for MasterSkeletonAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for MasterSkeletonAsset {
}

pub static MASTERSKELETONASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MasterSkeletonAsset",
    name_hash: 2238702888,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        super_class_offset: offset_of!(MasterSkeletonAsset, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MasterSkeletonAsset as Default>::default())),
            create_boxed: || Box::new(<MasterSkeletonAsset as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "MasterSkeleton",
                name_hash: 1934150648,
                flags: MemberInfoFlags::new(0),
                field_type: "SkeletonAsset",
                rust_offset: offset_of!(MasterSkeletonAsset, master_skeleton),
            },
            FieldInfoData {
                name: "SubSkeletons",
                name_hash: 2966147091,
                flags: MemberInfoFlags::new(144),
                field_type: "SubSkeleton-Array",
                rust_offset: offset_of!(MasterSkeletonAsset, sub_skeletons),
            },
        ],
    }),
    array_type: Some(MASTERSKELETONASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MasterSkeletonAsset {
    fn type_info(&self) -> &'static TypeInfo {
        MASTERSKELETONASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MASTERSKELETONASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MasterSkeletonAsset-Array",
    name_hash: 784664220,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("MasterSkeletonAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SubSkeleton {
    pub skeleton: Option<LockedTypeObject /* SkeletonAsset */>,
    pub bone_map: Vec<i32>,
    pub transform_map: Vec<BoxedTypeObject /* super::core::LinearTransform */>,
}

pub trait SubSkeletonTrait: TypeObject {
    fn skeleton(&self) -> &Option<LockedTypeObject /* SkeletonAsset */>;
    fn skeleton_mut(&mut self) -> &mut Option<LockedTypeObject /* SkeletonAsset */>;
    fn bone_map(&self) -> &Vec<i32>;
    fn bone_map_mut(&mut self) -> &mut Vec<i32>;
    fn transform_map(&self) -> &Vec<BoxedTypeObject /* super::core::LinearTransform */>;
    fn transform_map_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::LinearTransform */>;
}

impl SubSkeletonTrait for SubSkeleton {
    fn skeleton(&self) -> &Option<LockedTypeObject /* SkeletonAsset */> {
        &self.skeleton
    }
    fn skeleton_mut(&mut self) -> &mut Option<LockedTypeObject /* SkeletonAsset */> {
        &mut self.skeleton
    }
    fn bone_map(&self) -> &Vec<i32> {
        &self.bone_map
    }
    fn bone_map_mut(&mut self) -> &mut Vec<i32> {
        &mut self.bone_map
    }
    fn transform_map(&self) -> &Vec<BoxedTypeObject /* super::core::LinearTransform */> {
        &self.transform_map
    }
    fn transform_map_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::LinearTransform */> {
        &mut self.transform_map
    }
}

pub static SUBSKELETON_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubSkeleton",
    name_hash: 610485344,
    flags: MemberInfoFlags::new(73),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SubSkeleton as Default>::default())),
            create_boxed: || Box::new(<SubSkeleton as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Skeleton",
                name_hash: 291024164,
                flags: MemberInfoFlags::new(0),
                field_type: "SkeletonAsset",
                rust_offset: offset_of!(SubSkeleton, skeleton),
            },
            FieldInfoData {
                name: "BoneMap",
                name_hash: 2521060607,
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(SubSkeleton, bone_map),
            },
            FieldInfoData {
                name: "TransformMap",
                name_hash: 1281121973,
                flags: MemberInfoFlags::new(144),
                field_type: "LinearTransform-Array",
                rust_offset: offset_of!(SubSkeleton, transform_map),
            },
        ],
    }),
    array_type: Some(SUBSKELETON_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SubSkeleton {
    fn type_info(&self) -> &'static TypeInfo {
        SUBSKELETON_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SUBSKELETON_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubSkeleton-Array",
    name_hash: 3352263252,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SubSkeleton"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SkeletonAsset {
    pub _glacier_base: SkeletonBaseAsset,
    pub bone_names: Vec<String>,
    pub bone_name_hashes: Vec<u32>,
    pub hierarchy: Vec<i32>,
    pub local_pose: Vec<BoxedTypeObject /* super::core::LinearTransform */>,
    pub model_pose: Vec<BoxedTypeObject /* super::core::LinearTransform */>,
    pub inverse_model_pose: Vec<BoxedTypeObject /* super::core::LinearTransform */>,
    pub server_skeleton_to_skeleton_map: Vec<i32>,
    pub skeleton_to_server_skeleton_map: Vec<i32>,
    pub server_hierarchy: Vec<i32>,
    pub gameplay_bones_to_skeleton: Vec<i32>,
    pub gameplay_bones_to_server_skeleton: Vec<i32>,
}

pub trait SkeletonAssetTrait: SkeletonBaseAssetTrait {
    fn bone_names(&self) -> &Vec<String>;
    fn bone_names_mut(&mut self) -> &mut Vec<String>;
    fn bone_name_hashes(&self) -> &Vec<u32>;
    fn bone_name_hashes_mut(&mut self) -> &mut Vec<u32>;
    fn hierarchy(&self) -> &Vec<i32>;
    fn hierarchy_mut(&mut self) -> &mut Vec<i32>;
    fn local_pose(&self) -> &Vec<BoxedTypeObject /* super::core::LinearTransform */>;
    fn local_pose_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::LinearTransform */>;
    fn model_pose(&self) -> &Vec<BoxedTypeObject /* super::core::LinearTransform */>;
    fn model_pose_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::LinearTransform */>;
    fn inverse_model_pose(&self) -> &Vec<BoxedTypeObject /* super::core::LinearTransform */>;
    fn inverse_model_pose_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::LinearTransform */>;
    fn server_skeleton_to_skeleton_map(&self) -> &Vec<i32>;
    fn server_skeleton_to_skeleton_map_mut(&mut self) -> &mut Vec<i32>;
    fn skeleton_to_server_skeleton_map(&self) -> &Vec<i32>;
    fn skeleton_to_server_skeleton_map_mut(&mut self) -> &mut Vec<i32>;
    fn server_hierarchy(&self) -> &Vec<i32>;
    fn server_hierarchy_mut(&mut self) -> &mut Vec<i32>;
    fn gameplay_bones_to_skeleton(&self) -> &Vec<i32>;
    fn gameplay_bones_to_skeleton_mut(&mut self) -> &mut Vec<i32>;
    fn gameplay_bones_to_server_skeleton(&self) -> &Vec<i32>;
    fn gameplay_bones_to_server_skeleton_mut(&mut self) -> &mut Vec<i32>;
}

impl SkeletonAssetTrait for SkeletonAsset {
    fn bone_names(&self) -> &Vec<String> {
        &self.bone_names
    }
    fn bone_names_mut(&mut self) -> &mut Vec<String> {
        &mut self.bone_names
    }
    fn bone_name_hashes(&self) -> &Vec<u32> {
        &self.bone_name_hashes
    }
    fn bone_name_hashes_mut(&mut self) -> &mut Vec<u32> {
        &mut self.bone_name_hashes
    }
    fn hierarchy(&self) -> &Vec<i32> {
        &self.hierarchy
    }
    fn hierarchy_mut(&mut self) -> &mut Vec<i32> {
        &mut self.hierarchy
    }
    fn local_pose(&self) -> &Vec<BoxedTypeObject /* super::core::LinearTransform */> {
        &self.local_pose
    }
    fn local_pose_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::LinearTransform */> {
        &mut self.local_pose
    }
    fn model_pose(&self) -> &Vec<BoxedTypeObject /* super::core::LinearTransform */> {
        &self.model_pose
    }
    fn model_pose_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::LinearTransform */> {
        &mut self.model_pose
    }
    fn inverse_model_pose(&self) -> &Vec<BoxedTypeObject /* super::core::LinearTransform */> {
        &self.inverse_model_pose
    }
    fn inverse_model_pose_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::LinearTransform */> {
        &mut self.inverse_model_pose
    }
    fn server_skeleton_to_skeleton_map(&self) -> &Vec<i32> {
        &self.server_skeleton_to_skeleton_map
    }
    fn server_skeleton_to_skeleton_map_mut(&mut self) -> &mut Vec<i32> {
        &mut self.server_skeleton_to_skeleton_map
    }
    fn skeleton_to_server_skeleton_map(&self) -> &Vec<i32> {
        &self.skeleton_to_server_skeleton_map
    }
    fn skeleton_to_server_skeleton_map_mut(&mut self) -> &mut Vec<i32> {
        &mut self.skeleton_to_server_skeleton_map
    }
    fn server_hierarchy(&self) -> &Vec<i32> {
        &self.server_hierarchy
    }
    fn server_hierarchy_mut(&mut self) -> &mut Vec<i32> {
        &mut self.server_hierarchy
    }
    fn gameplay_bones_to_skeleton(&self) -> &Vec<i32> {
        &self.gameplay_bones_to_skeleton
    }
    fn gameplay_bones_to_skeleton_mut(&mut self) -> &mut Vec<i32> {
        &mut self.gameplay_bones_to_skeleton
    }
    fn gameplay_bones_to_server_skeleton(&self) -> &Vec<i32> {
        &self.gameplay_bones_to_server_skeleton
    }
    fn gameplay_bones_to_server_skeleton_mut(&mut self) -> &mut Vec<i32> {
        &mut self.gameplay_bones_to_server_skeleton
    }
}

impl SkeletonBaseAssetTrait for SkeletonAsset {
}

impl super::core::AssetTrait for SkeletonAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for SkeletonAsset {
}

pub static SKELETONASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SkeletonAsset",
    name_hash: 2375870068,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SKELETONBASEASSET_TYPE_INFO),
        super_class_offset: offset_of!(SkeletonAsset, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SkeletonAsset as Default>::default())),
            create_boxed: || Box::new(<SkeletonAsset as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "BoneNames",
                name_hash: 951771351,
                flags: MemberInfoFlags::new(144),
                field_type: "CString-Array",
                rust_offset: offset_of!(SkeletonAsset, bone_names),
            },
            FieldInfoData {
                name: "BoneNameHashes",
                name_hash: 1617794368,
                flags: MemberInfoFlags::new(144),
                field_type: "Uint32-Array",
                rust_offset: offset_of!(SkeletonAsset, bone_name_hashes),
            },
            FieldInfoData {
                name: "Hierarchy",
                name_hash: 2981249554,
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(SkeletonAsset, hierarchy),
            },
            FieldInfoData {
                name: "LocalPose",
                name_hash: 773169313,
                flags: MemberInfoFlags::new(144),
                field_type: "LinearTransform-Array",
                rust_offset: offset_of!(SkeletonAsset, local_pose),
            },
            FieldInfoData {
                name: "ModelPose",
                name_hash: 4243999587,
                flags: MemberInfoFlags::new(144),
                field_type: "LinearTransform-Array",
                rust_offset: offset_of!(SkeletonAsset, model_pose),
            },
            FieldInfoData {
                name: "InverseModelPose",
                name_hash: 4285590163,
                flags: MemberInfoFlags::new(144),
                field_type: "LinearTransform-Array",
                rust_offset: offset_of!(SkeletonAsset, inverse_model_pose),
            },
            FieldInfoData {
                name: "ServerSkeletonToSkeletonMap",
                name_hash: 2428566471,
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(SkeletonAsset, server_skeleton_to_skeleton_map),
            },
            FieldInfoData {
                name: "SkeletonToServerSkeletonMap",
                name_hash: 3008373063,
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(SkeletonAsset, skeleton_to_server_skeleton_map),
            },
            FieldInfoData {
                name: "ServerHierarchy",
                name_hash: 3579270615,
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(SkeletonAsset, server_hierarchy),
            },
            FieldInfoData {
                name: "GameplayBonesToSkeleton",
                name_hash: 3014053344,
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(SkeletonAsset, gameplay_bones_to_skeleton),
            },
            FieldInfoData {
                name: "GameplayBonesToServerSkeleton",
                name_hash: 3698466053,
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(SkeletonAsset, gameplay_bones_to_server_skeleton),
            },
        ],
    }),
    array_type: Some(SKELETONASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SkeletonAsset {
    fn type_info(&self) -> &'static TypeInfo {
        SKELETONASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SKELETONASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SkeletonAsset-Array",
    name_hash: 3272413760,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SkeletonAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct BoneSelection {
    pub bone_name_hashes: Vec<u32>,
}

pub trait BoneSelectionTrait: TypeObject {
    fn bone_name_hashes(&self) -> &Vec<u32>;
    fn bone_name_hashes_mut(&mut self) -> &mut Vec<u32>;
}

impl BoneSelectionTrait for BoneSelection {
    fn bone_name_hashes(&self) -> &Vec<u32> {
        &self.bone_name_hashes
    }
    fn bone_name_hashes_mut(&mut self) -> &mut Vec<u32> {
        &mut self.bone_name_hashes
    }
}

pub static BONESELECTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoneSelection",
    name_hash: 29366051,
    flags: MemberInfoFlags::new(73),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BoneSelection as Default>::default())),
            create_boxed: || Box::new(<BoneSelection as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "BoneNameHashes",
                name_hash: 1617794368,
                flags: MemberInfoFlags::new(144),
                field_type: "Uint32-Array",
                rust_offset: offset_of!(BoneSelection, bone_name_hashes),
            },
        ],
    }),
    array_type: Some(BONESELECTION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BoneSelection {
    fn type_info(&self) -> &'static TypeInfo {
        BONESELECTION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static BONESELECTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoneSelection-Array",
    name_hash: 3011713687,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("BoneSelection"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct GameplayBone {
    pub name: String,
    pub bone: GameplayBones,
}

pub trait GameplayBoneTrait: TypeObject {
    fn name(&self) -> &String;
    fn name_mut(&mut self) -> &mut String;
    fn bone(&self) -> &GameplayBones;
    fn bone_mut(&mut self) -> &mut GameplayBones;
}

impl GameplayBoneTrait for GameplayBone {
    fn name(&self) -> &String {
        &self.name
    }
    fn name_mut(&mut self) -> &mut String {
        &mut self.name
    }
    fn bone(&self) -> &GameplayBones {
        &self.bone
    }
    fn bone_mut(&mut self) -> &mut GameplayBones {
        &mut self.bone
    }
}

pub static GAMEPLAYBONE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameplayBone",
    name_hash: 3287829481,
    flags: MemberInfoFlags::new(73),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GameplayBone as Default>::default())),
            create_boxed: || Box::new(<GameplayBone as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Name",
                name_hash: 2088949890,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(GameplayBone, name),
            },
            FieldInfoData {
                name: "Bone",
                name_hash: 2088812771,
                flags: MemberInfoFlags::new(0),
                field_type: "GameplayBones",
                rust_offset: offset_of!(GameplayBone, bone),
            },
        ],
    }),
    array_type: Some(GAMEPLAYBONE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for GameplayBone {
    fn type_info(&self) -> &'static TypeInfo {
        GAMEPLAYBONE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static GAMEPLAYBONE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameplayBone-Array",
    name_hash: 2169963229,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("GameplayBone"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum GameplayBones {
    #[default]
    GameplayBones_UndefinedBone = 4294967295,
    GameplayBones_RootBone = 0,
    GameplayBones_RootMeshBone = 1,
    GameplayBones_ConnectBone = 2,
    GameplayBones_HeadBone = 3,
    GameplayBones_CameraBone = 4,
    GameplayBones_AimBone = 5,
    GameplayBones_WeaponBone = 6,
    GameplayBones_WeaponBone2 = 7,
    GameplayBones_WeaponAux1Bone = 8,
    GameplayBones_LeftArmBone = 9,
    GameplayBones_RightArmBone = 10,
    GameplayBones_SpineBone = 11,
    GameplayBones_WeaponMuzzleBone = 12,
    GameplayBones_WeaponShellEjectBone = 13,
    GameplayBones_LeftHandBone = 14,
    GameplayBones_RightHandBone = 15,
    GameplayBones_LeftFootBone = 16,
    GameplayBones_RightFootBone = 17,
    GameplayBones_BackPack = 18,
    GameplayBones_PleaseDeleteMeHackDroidBone = 19,
    GameplayBones_WeaponMuzzleBone2 = 20,
    GameplayBones_WeaponMuzzleBone3 = 21,
    GameplayBones_WeaponMuzzleBone4 = 22,
    GameplayBones_WeaponMuzzleBone5 = 23,
    GameplayBones_Count = 24,
}

pub static GAMEPLAYBONES_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameplayBones",
    name_hash: 1124190586,
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(GAMEPLAYBONES_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for GameplayBones {
    fn type_info(&self) -> &'static TypeInfo {
        GAMEPLAYBONES_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static GAMEPLAYBONES_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameplayBones-Array",
    name_hash: 2453412942,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("GameplayBones"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SharedBundleReference {
    pub name: String,
    pub heap: BundleHeapInfo,
}

pub trait SharedBundleReferenceTrait: TypeObject {
    fn name(&self) -> &String;
    fn name_mut(&mut self) -> &mut String;
    fn heap(&self) -> &BundleHeapInfo;
    fn heap_mut(&mut self) -> &mut BundleHeapInfo;
}

impl SharedBundleReferenceTrait for SharedBundleReference {
    fn name(&self) -> &String {
        &self.name
    }
    fn name_mut(&mut self) -> &mut String {
        &mut self.name
    }
    fn heap(&self) -> &BundleHeapInfo {
        &self.heap
    }
    fn heap_mut(&mut self) -> &mut BundleHeapInfo {
        &mut self.heap
    }
}

pub static SHAREDBUNDLEREFERENCE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SharedBundleReference",
    name_hash: 1463219059,
    flags: MemberInfoFlags::new(73),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SharedBundleReference as Default>::default())),
            create_boxed: || Box::new(<SharedBundleReference as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Name",
                name_hash: 2088949890,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(SharedBundleReference, name),
            },
            FieldInfoData {
                name: "Heap",
                name_hash: 2089157081,
                flags: MemberInfoFlags::new(0),
                field_type: "BundleHeapInfo",
                rust_offset: offset_of!(SharedBundleReference, heap),
            },
        ],
    }),
    array_type: Some(SHAREDBUNDLEREFERENCE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SharedBundleReference {
    fn type_info(&self) -> &'static TypeInfo {
        SHAREDBUNDLEREFERENCE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SHAREDBUNDLEREFERENCE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SharedBundleReference-Array",
    name_hash: 3969183559,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SharedBundleReference"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SharedBundleBaseAsset {
    pub _glacier_base: super::core::Asset,
}

pub trait SharedBundleBaseAssetTrait: super::core::AssetTrait {
}

impl SharedBundleBaseAssetTrait for SharedBundleBaseAsset {
}

impl super::core::AssetTrait for SharedBundleBaseAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for SharedBundleBaseAsset {
}

pub static SHAREDBUNDLEBASEASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SharedBundleBaseAsset",
    name_hash: 2765718365,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        super_class_offset: offset_of!(SharedBundleBaseAsset, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SharedBundleBaseAsset as Default>::default())),
            create_boxed: || Box::new(<SharedBundleBaseAsset as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(SHAREDBUNDLEBASEASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SharedBundleBaseAsset {
    fn type_info(&self) -> &'static TypeInfo {
        SHAREDBUNDLEBASEASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SHAREDBUNDLEBASEASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SharedBundleBaseAsset-Array",
    name_hash: 3124117353,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SharedBundleBaseAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ScanlineVolumeShapeData {
    pub _glacier_base: VolumeVectorShapeData,
    pub x_step: f32,
    pub y_step: f32,
    pub z_step: f32,
}

pub trait ScanlineVolumeShapeDataTrait: VolumeVectorShapeDataTrait {
    fn x_step(&self) -> &f32;
    fn x_step_mut(&mut self) -> &mut f32;
    fn y_step(&self) -> &f32;
    fn y_step_mut(&mut self) -> &mut f32;
    fn z_step(&self) -> &f32;
    fn z_step_mut(&mut self) -> &mut f32;
}

impl ScanlineVolumeShapeDataTrait for ScanlineVolumeShapeData {
    fn x_step(&self) -> &f32 {
        &self.x_step
    }
    fn x_step_mut(&mut self) -> &mut f32 {
        &mut self.x_step
    }
    fn y_step(&self) -> &f32 {
        &self.y_step
    }
    fn y_step_mut(&mut self) -> &mut f32 {
        &mut self.y_step
    }
    fn z_step(&self) -> &f32 {
        &self.z_step
    }
    fn z_step_mut(&mut self) -> &mut f32 {
        &mut self.z_step
    }
}

impl VolumeVectorShapeDataTrait for ScanlineVolumeShapeData {
    fn height(&self) -> &f32 {
        self._glacier_base.height()
    }
    fn height_mut(&mut self) -> &mut f32 {
        self._glacier_base.height_mut()
    }
}

impl VectorShapeDataTrait for ScanlineVolumeShapeData {
    fn points(&self) -> &Vec<BoxedTypeObject /* super::core::Vec3 */> {
        self._glacier_base.points()
    }
    fn points_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::Vec3 */> {
        self._glacier_base.points_mut()
    }
    fn tension(&self) -> &f32 {
        self._glacier_base.tension()
    }
    fn tension_mut(&mut self) -> &mut f32 {
        self._glacier_base.tension_mut()
    }
    fn is_closed(&self) -> &bool {
        self._glacier_base.is_closed()
    }
    fn is_closed_mut(&mut self) -> &mut bool {
        self._glacier_base.is_closed_mut()
    }
    fn allow_roll(&self) -> &bool {
        self._glacier_base.allow_roll()
    }
    fn allow_roll_mut(&mut self) -> &mut bool {
        self._glacier_base.allow_roll_mut()
    }
    fn allow_yaw_pitch(&self) -> &bool {
        self._glacier_base.allow_yaw_pitch()
    }
    fn allow_yaw_pitch_mut(&mut self) -> &mut bool {
        self._glacier_base.allow_yaw_pitch_mut()
    }
}

impl BaseShapeDataTrait for ScanlineVolumeShapeData {
}

impl BaseShapeDataBaseTrait for ScanlineVolumeShapeData {
}

impl GameObjectDataTrait for ScanlineVolumeShapeData {
}

impl super::core::DataBusPeerTrait for ScanlineVolumeShapeData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ScanlineVolumeShapeData {
}

impl super::core::DataContainerTrait for ScanlineVolumeShapeData {
}

pub static SCANLINEVOLUMESHAPEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScanlineVolumeShapeData",
    name_hash: 2742032899,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOLUMEVECTORSHAPEDATA_TYPE_INFO),
        super_class_offset: offset_of!(ScanlineVolumeShapeData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ScanlineVolumeShapeData as Default>::default())),
            create_boxed: || Box::new(<ScanlineVolumeShapeData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "xStep",
                name_hash: 197632495,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ScanlineVolumeShapeData, x_step),
            },
            FieldInfoData {
                name: "yStep",
                name_hash: 196516142,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ScanlineVolumeShapeData, y_step),
            },
            FieldInfoData {
                name: "zStep",
                name_hash: 204464749,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ScanlineVolumeShapeData, z_step),
            },
        ],
    }),
    array_type: Some(SCANLINEVOLUMESHAPEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ScanlineVolumeShapeData {
    fn type_info(&self) -> &'static TypeInfo {
        SCANLINEVOLUMESHAPEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SCANLINEVOLUMESHAPEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScanlineVolumeShapeData-Array",
    name_hash: 2621279415,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ScanlineVolumeShapeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ZoneVectorShapeData {
    pub _glacier_base: VectorShapeData,
}

pub trait ZoneVectorShapeDataTrait: VectorShapeDataTrait {
}

impl ZoneVectorShapeDataTrait for ZoneVectorShapeData {
}

impl VectorShapeDataTrait for ZoneVectorShapeData {
    fn points(&self) -> &Vec<BoxedTypeObject /* super::core::Vec3 */> {
        self._glacier_base.points()
    }
    fn points_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::Vec3 */> {
        self._glacier_base.points_mut()
    }
    fn tension(&self) -> &f32 {
        self._glacier_base.tension()
    }
    fn tension_mut(&mut self) -> &mut f32 {
        self._glacier_base.tension_mut()
    }
    fn is_closed(&self) -> &bool {
        self._glacier_base.is_closed()
    }
    fn is_closed_mut(&mut self) -> &mut bool {
        self._glacier_base.is_closed_mut()
    }
    fn allow_roll(&self) -> &bool {
        self._glacier_base.allow_roll()
    }
    fn allow_roll_mut(&mut self) -> &mut bool {
        self._glacier_base.allow_roll_mut()
    }
    fn allow_yaw_pitch(&self) -> &bool {
        self._glacier_base.allow_yaw_pitch()
    }
    fn allow_yaw_pitch_mut(&mut self) -> &mut bool {
        self._glacier_base.allow_yaw_pitch_mut()
    }
}

impl BaseShapeDataTrait for ZoneVectorShapeData {
}

impl BaseShapeDataBaseTrait for ZoneVectorShapeData {
}

impl GameObjectDataTrait for ZoneVectorShapeData {
}

impl super::core::DataBusPeerTrait for ZoneVectorShapeData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ZoneVectorShapeData {
}

impl super::core::DataContainerTrait for ZoneVectorShapeData {
}

pub static ZONEVECTORSHAPEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ZoneVectorShapeData",
    name_hash: 2593120701,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VECTORSHAPEDATA_TYPE_INFO),
        super_class_offset: offset_of!(ZoneVectorShapeData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ZoneVectorShapeData as Default>::default())),
            create_boxed: || Box::new(<ZoneVectorShapeData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(ZONEVECTORSHAPEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ZoneVectorShapeData {
    fn type_info(&self) -> &'static TypeInfo {
        ZONEVECTORSHAPEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ZONEVECTORSHAPEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ZoneVectorShapeData-Array",
    name_hash: 4122615305,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ZoneVectorShapeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct VolumeVectorShapeData {
    pub _glacier_base: VectorShapeData,
    pub height: f32,
}

pub trait VolumeVectorShapeDataTrait: VectorShapeDataTrait {
    fn height(&self) -> &f32;
    fn height_mut(&mut self) -> &mut f32;
}

impl VolumeVectorShapeDataTrait for VolumeVectorShapeData {
    fn height(&self) -> &f32 {
        &self.height
    }
    fn height_mut(&mut self) -> &mut f32 {
        &mut self.height
    }
}

impl VectorShapeDataTrait for VolumeVectorShapeData {
    fn points(&self) -> &Vec<BoxedTypeObject /* super::core::Vec3 */> {
        self._glacier_base.points()
    }
    fn points_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::Vec3 */> {
        self._glacier_base.points_mut()
    }
    fn tension(&self) -> &f32 {
        self._glacier_base.tension()
    }
    fn tension_mut(&mut self) -> &mut f32 {
        self._glacier_base.tension_mut()
    }
    fn is_closed(&self) -> &bool {
        self._glacier_base.is_closed()
    }
    fn is_closed_mut(&mut self) -> &mut bool {
        self._glacier_base.is_closed_mut()
    }
    fn allow_roll(&self) -> &bool {
        self._glacier_base.allow_roll()
    }
    fn allow_roll_mut(&mut self) -> &mut bool {
        self._glacier_base.allow_roll_mut()
    }
    fn allow_yaw_pitch(&self) -> &bool {
        self._glacier_base.allow_yaw_pitch()
    }
    fn allow_yaw_pitch_mut(&mut self) -> &mut bool {
        self._glacier_base.allow_yaw_pitch_mut()
    }
}

impl BaseShapeDataTrait for VolumeVectorShapeData {
}

impl BaseShapeDataBaseTrait for VolumeVectorShapeData {
}

impl GameObjectDataTrait for VolumeVectorShapeData {
}

impl super::core::DataBusPeerTrait for VolumeVectorShapeData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for VolumeVectorShapeData {
}

impl super::core::DataContainerTrait for VolumeVectorShapeData {
}

pub static VOLUMEVECTORSHAPEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VolumeVectorShapeData",
    name_hash: 1116470603,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VECTORSHAPEDATA_TYPE_INFO),
        super_class_offset: offset_of!(VolumeVectorShapeData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VolumeVectorShapeData as Default>::default())),
            create_boxed: || Box::new(<VolumeVectorShapeData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Height",
                name_hash: 3054065626,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VolumeVectorShapeData, height),
            },
        ],
    }),
    array_type: Some(VOLUMEVECTORSHAPEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VolumeVectorShapeData {
    fn type_info(&self) -> &'static TypeInfo {
        VOLUMEVECTORSHAPEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOLUMEVECTORSHAPEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VolumeVectorShapeData-Array",
    name_hash: 1060502655,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("VolumeVectorShapeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CustomSplineData {
    pub _glacier_base: VectorShapeData,
}

pub trait CustomSplineDataTrait: VectorShapeDataTrait {
}

impl CustomSplineDataTrait for CustomSplineData {
}

impl VectorShapeDataTrait for CustomSplineData {
    fn points(&self) -> &Vec<BoxedTypeObject /* super::core::Vec3 */> {
        self._glacier_base.points()
    }
    fn points_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::Vec3 */> {
        self._glacier_base.points_mut()
    }
    fn tension(&self) -> &f32 {
        self._glacier_base.tension()
    }
    fn tension_mut(&mut self) -> &mut f32 {
        self._glacier_base.tension_mut()
    }
    fn is_closed(&self) -> &bool {
        self._glacier_base.is_closed()
    }
    fn is_closed_mut(&mut self) -> &mut bool {
        self._glacier_base.is_closed_mut()
    }
    fn allow_roll(&self) -> &bool {
        self._glacier_base.allow_roll()
    }
    fn allow_roll_mut(&mut self) -> &mut bool {
        self._glacier_base.allow_roll_mut()
    }
    fn allow_yaw_pitch(&self) -> &bool {
        self._glacier_base.allow_yaw_pitch()
    }
    fn allow_yaw_pitch_mut(&mut self) -> &mut bool {
        self._glacier_base.allow_yaw_pitch_mut()
    }
}

impl BaseShapeDataTrait for CustomSplineData {
}

impl BaseShapeDataBaseTrait for CustomSplineData {
}

impl GameObjectDataTrait for CustomSplineData {
}

impl super::core::DataBusPeerTrait for CustomSplineData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CustomSplineData {
}

impl super::core::DataContainerTrait for CustomSplineData {
}

pub static CUSTOMSPLINEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomSplineData",
    name_hash: 1526103595,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VECTORSHAPEDATA_TYPE_INFO),
        super_class_offset: offset_of!(CustomSplineData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CustomSplineData as Default>::default())),
            create_boxed: || Box::new(<CustomSplineData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(CUSTOMSPLINEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CustomSplineData {
    fn type_info(&self) -> &'static TypeInfo {
        CUSTOMSPLINEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CUSTOMSPLINEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomSplineData-Array",
    name_hash: 2385124767,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CustomSplineData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct VectorShapeData {
    pub _glacier_base: BaseShapeData,
    pub points: Vec<BoxedTypeObject /* super::core::Vec3 */>,
    pub tension: f32,
    pub is_closed: bool,
    pub allow_roll: bool,
    pub allow_yaw_pitch: bool,
}

pub trait VectorShapeDataTrait: BaseShapeDataTrait {
    fn points(&self) -> &Vec<BoxedTypeObject /* super::core::Vec3 */>;
    fn points_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::Vec3 */>;
    fn tension(&self) -> &f32;
    fn tension_mut(&mut self) -> &mut f32;
    fn is_closed(&self) -> &bool;
    fn is_closed_mut(&mut self) -> &mut bool;
    fn allow_roll(&self) -> &bool;
    fn allow_roll_mut(&mut self) -> &mut bool;
    fn allow_yaw_pitch(&self) -> &bool;
    fn allow_yaw_pitch_mut(&mut self) -> &mut bool;
}

impl VectorShapeDataTrait for VectorShapeData {
    fn points(&self) -> &Vec<BoxedTypeObject /* super::core::Vec3 */> {
        &self.points
    }
    fn points_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::Vec3 */> {
        &mut self.points
    }
    fn tension(&self) -> &f32 {
        &self.tension
    }
    fn tension_mut(&mut self) -> &mut f32 {
        &mut self.tension
    }
    fn is_closed(&self) -> &bool {
        &self.is_closed
    }
    fn is_closed_mut(&mut self) -> &mut bool {
        &mut self.is_closed
    }
    fn allow_roll(&self) -> &bool {
        &self.allow_roll
    }
    fn allow_roll_mut(&mut self) -> &mut bool {
        &mut self.allow_roll
    }
    fn allow_yaw_pitch(&self) -> &bool {
        &self.allow_yaw_pitch
    }
    fn allow_yaw_pitch_mut(&mut self) -> &mut bool {
        &mut self.allow_yaw_pitch
    }
}

impl BaseShapeDataTrait for VectorShapeData {
}

impl BaseShapeDataBaseTrait for VectorShapeData {
}

impl GameObjectDataTrait for VectorShapeData {
}

impl super::core::DataBusPeerTrait for VectorShapeData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for VectorShapeData {
}

impl super::core::DataContainerTrait for VectorShapeData {
}

pub static VECTORSHAPEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VectorShapeData",
    name_hash: 2801840259,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(BASESHAPEDATA_TYPE_INFO),
        super_class_offset: offset_of!(VectorShapeData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VectorShapeData as Default>::default())),
            create_boxed: || Box::new(<VectorShapeData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Points",
                name_hash: 3383606106,
                flags: MemberInfoFlags::new(144),
                field_type: "Vec3-Array",
                rust_offset: offset_of!(VectorShapeData, points),
            },
            FieldInfoData {
                name: "Tension",
                name_hash: 3196074177,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VectorShapeData, tension),
            },
            FieldInfoData {
                name: "IsClosed",
                name_hash: 1070153421,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VectorShapeData, is_closed),
            },
            FieldInfoData {
                name: "AllowRoll",
                name_hash: 2314066145,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VectorShapeData, allow_roll),
            },
            FieldInfoData {
                name: "AllowYawPitch",
                name_hash: 2582964181,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VectorShapeData, allow_yaw_pitch),
            },
        ],
    }),
    array_type: Some(VECTORSHAPEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VectorShapeData {
    fn type_info(&self) -> &'static TypeInfo {
        VECTORSHAPEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VECTORSHAPEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VectorShapeData-Array",
    name_hash: 679805751,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("VectorShapeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct OBBData {
    pub _glacier_base: BaseShapeData,
    pub transform: super::core::LinearTransform,
    pub half_extents: super::core::Vec3,
}

pub trait OBBDataTrait: BaseShapeDataTrait {
    fn transform(&self) -> &super::core::LinearTransform;
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform;
    fn half_extents(&self) -> &super::core::Vec3;
    fn half_extents_mut(&mut self) -> &mut super::core::Vec3;
}

impl OBBDataTrait for OBBData {
    fn transform(&self) -> &super::core::LinearTransform {
        &self.transform
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.transform
    }
    fn half_extents(&self) -> &super::core::Vec3 {
        &self.half_extents
    }
    fn half_extents_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.half_extents
    }
}

impl BaseShapeDataTrait for OBBData {
}

impl BaseShapeDataBaseTrait for OBBData {
}

impl GameObjectDataTrait for OBBData {
}

impl super::core::DataBusPeerTrait for OBBData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for OBBData {
}

impl super::core::DataContainerTrait for OBBData {
}

pub static OBBDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OBBData",
    name_hash: 1330470682,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(BASESHAPEDATA_TYPE_INFO),
        super_class_offset: offset_of!(OBBData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<OBBData as Default>::default())),
            create_boxed: || Box::new(<OBBData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Transform",
                name_hash: 2270319721,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(OBBData, transform),
            },
            FieldInfoData {
                name: "HalfExtents",
                name_hash: 905253763,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(OBBData, half_extents),
            },
        ],
    }),
    array_type: Some(OBBDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for OBBData {
    fn type_info(&self) -> &'static TypeInfo {
        OBBDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static OBBDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OBBData-Array",
    name_hash: 3254100526,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("OBBData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct AABBData {
    pub _glacier_base: BaseShapeData,
    pub position: super::core::Vec3,
    pub half_extents: super::core::Vec3,
}

pub trait AABBDataTrait: BaseShapeDataTrait {
    fn position(&self) -> &super::core::Vec3;
    fn position_mut(&mut self) -> &mut super::core::Vec3;
    fn half_extents(&self) -> &super::core::Vec3;
    fn half_extents_mut(&mut self) -> &mut super::core::Vec3;
}

impl AABBDataTrait for AABBData {
    fn position(&self) -> &super::core::Vec3 {
        &self.position
    }
    fn position_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.position
    }
    fn half_extents(&self) -> &super::core::Vec3 {
        &self.half_extents
    }
    fn half_extents_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.half_extents
    }
}

impl BaseShapeDataTrait for AABBData {
}

impl BaseShapeDataBaseTrait for AABBData {
}

impl GameObjectDataTrait for AABBData {
}

impl super::core::DataBusPeerTrait for AABBData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AABBData {
}

impl super::core::DataContainerTrait for AABBData {
}

pub static AABBDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AABBData",
    name_hash: 417516117,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(BASESHAPEDATA_TYPE_INFO),
        super_class_offset: offset_of!(AABBData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AABBData as Default>::default())),
            create_boxed: || Box::new(<AABBData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Position",
                name_hash: 3402582524,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(AABBData, position),
            },
            FieldInfoData {
                name: "HalfExtents",
                name_hash: 905253763,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(AABBData, half_extents),
            },
        ],
    }),
    array_type: Some(AABBDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AABBData {
    fn type_info(&self) -> &'static TypeInfo {
        AABBDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AABBDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AABBData-Array",
    name_hash: 1968794209,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("AABBData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SphereData {
    pub _glacier_base: BaseShapeData,
    pub position: super::core::Vec3,
    pub radius: f32,
}

pub trait SphereDataTrait: BaseShapeDataTrait {
    fn position(&self) -> &super::core::Vec3;
    fn position_mut(&mut self) -> &mut super::core::Vec3;
    fn radius(&self) -> &f32;
    fn radius_mut(&mut self) -> &mut f32;
}

impl SphereDataTrait for SphereData {
    fn position(&self) -> &super::core::Vec3 {
        &self.position
    }
    fn position_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.position
    }
    fn radius(&self) -> &f32 {
        &self.radius
    }
    fn radius_mut(&mut self) -> &mut f32 {
        &mut self.radius
    }
}

impl BaseShapeDataTrait for SphereData {
}

impl BaseShapeDataBaseTrait for SphereData {
}

impl GameObjectDataTrait for SphereData {
}

impl super::core::DataBusPeerTrait for SphereData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SphereData {
}

impl super::core::DataContainerTrait for SphereData {
}

pub static SPHEREDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SphereData",
    name_hash: 3703503660,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(BASESHAPEDATA_TYPE_INFO),
        super_class_offset: offset_of!(SphereData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SphereData as Default>::default())),
            create_boxed: || Box::new(<SphereData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Position",
                name_hash: 3402582524,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SphereData, position),
            },
            FieldInfoData {
                name: "Radius",
                name_hash: 3298407133,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SphereData, radius),
            },
        ],
    }),
    array_type: Some(SPHEREDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SphereData {
    fn type_info(&self) -> &'static TypeInfo {
        SPHEREDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SPHEREDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SphereData-Array",
    name_hash: 667699864,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SphereData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct BaseShapeData {
    pub _glacier_base: BaseShapeDataBase,
}

pub trait BaseShapeDataTrait: BaseShapeDataBaseTrait {
}

impl BaseShapeDataTrait for BaseShapeData {
}

impl BaseShapeDataBaseTrait for BaseShapeData {
}

impl GameObjectDataTrait for BaseShapeData {
}

impl super::core::DataBusPeerTrait for BaseShapeData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for BaseShapeData {
}

impl super::core::DataContainerTrait for BaseShapeData {
}

pub static BASESHAPEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BaseShapeData",
    name_hash: 941592943,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(BASESHAPEDATABASE_TYPE_INFO),
        super_class_offset: offset_of!(BaseShapeData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BaseShapeData as Default>::default())),
            create_boxed: || Box::new(<BaseShapeData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(BASESHAPEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BaseShapeData {
    fn type_info(&self) -> &'static TypeInfo {
        BASESHAPEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BASESHAPEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BaseShapeData-Array",
    name_hash: 3777515355,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("BaseShapeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SelectVec4EntityData {
    pub _glacier_base: SelectPropertyEntityData,
}

pub trait SelectVec4EntityDataTrait: SelectPropertyEntityDataTrait {
}

impl SelectVec4EntityDataTrait for SelectVec4EntityData {
}

impl SelectPropertyEntityDataTrait for SelectVec4EntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn inputs(&self) -> &Vec<String> {
        self._glacier_base.inputs()
    }
    fn inputs_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.inputs_mut()
    }
    fn input_select(&self) -> &i32 {
        self._glacier_base.input_select()
    }
    fn input_select_mut(&mut self) -> &mut i32 {
        self._glacier_base.input_select_mut()
    }
}

impl EntityDataTrait for SelectVec4EntityData {
}

impl GameObjectDataTrait for SelectVec4EntityData {
}

impl super::core::DataBusPeerTrait for SelectVec4EntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SelectVec4EntityData {
}

impl super::core::DataContainerTrait for SelectVec4EntityData {
}

pub static SELECTVEC4ENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectVec4EntityData",
    name_hash: 1720156226,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SELECTPROPERTYENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(SelectVec4EntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SelectVec4EntityData as Default>::default())),
            create_boxed: || Box::new(<SelectVec4EntityData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(SELECTVEC4ENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SelectVec4EntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SELECTVEC4ENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SELECTVEC4ENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectVec4EntityData-Array",
    name_hash: 1414647798,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SelectVec4EntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SelectVec3EntityData {
    pub _glacier_base: SelectPropertyEntityData,
}

pub trait SelectVec3EntityDataTrait: SelectPropertyEntityDataTrait {
}

impl SelectVec3EntityDataTrait for SelectVec3EntityData {
}

impl SelectPropertyEntityDataTrait for SelectVec3EntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn inputs(&self) -> &Vec<String> {
        self._glacier_base.inputs()
    }
    fn inputs_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.inputs_mut()
    }
    fn input_select(&self) -> &i32 {
        self._glacier_base.input_select()
    }
    fn input_select_mut(&mut self) -> &mut i32 {
        self._glacier_base.input_select_mut()
    }
}

impl EntityDataTrait for SelectVec3EntityData {
}

impl GameObjectDataTrait for SelectVec3EntityData {
}

impl super::core::DataBusPeerTrait for SelectVec3EntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SelectVec3EntityData {
}

impl super::core::DataContainerTrait for SelectVec3EntityData {
}

pub static SELECTVEC3ENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectVec3EntityData",
    name_hash: 1291340293,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SELECTPROPERTYENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(SelectVec3EntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SelectVec3EntityData as Default>::default())),
            create_boxed: || Box::new(<SelectVec3EntityData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(SELECTVEC3ENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SelectVec3EntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SELECTVEC3ENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SELECTVEC3ENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectVec3EntityData-Array",
    name_hash: 3190878641,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SelectVec3EntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SelectVec2EntityData {
    pub _glacier_base: SelectPropertyEntityData,
}

pub trait SelectVec2EntityDataTrait: SelectPropertyEntityDataTrait {
}

impl SelectVec2EntityDataTrait for SelectVec2EntityData {
}

impl SelectPropertyEntityDataTrait for SelectVec2EntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn inputs(&self) -> &Vec<String> {
        self._glacier_base.inputs()
    }
    fn inputs_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.inputs_mut()
    }
    fn input_select(&self) -> &i32 {
        self._glacier_base.input_select()
    }
    fn input_select_mut(&mut self) -> &mut i32 {
        self._glacier_base.input_select_mut()
    }
}

impl EntityDataTrait for SelectVec2EntityData {
}

impl GameObjectDataTrait for SelectVec2EntityData {
}

impl super::core::DataBusPeerTrait for SelectVec2EntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SelectVec2EntityData {
}

impl super::core::DataContainerTrait for SelectVec2EntityData {
}

pub static SELECTVEC2ENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectVec2EntityData",
    name_hash: 4153632324,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SELECTPROPERTYENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(SelectVec2EntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SelectVec2EntityData as Default>::default())),
            create_boxed: || Box::new(<SelectVec2EntityData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(SELECTVEC2ENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SelectVec2EntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SELECTVEC2ENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SELECTVEC2ENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectVec2EntityData-Array",
    name_hash: 2604231408,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SelectVec2EntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SelectTransformEntityData {
    pub _glacier_base: SelectPropertyEntityData,
}

pub trait SelectTransformEntityDataTrait: SelectPropertyEntityDataTrait {
}

impl SelectTransformEntityDataTrait for SelectTransformEntityData {
}

impl SelectPropertyEntityDataTrait for SelectTransformEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn inputs(&self) -> &Vec<String> {
        self._glacier_base.inputs()
    }
    fn inputs_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.inputs_mut()
    }
    fn input_select(&self) -> &i32 {
        self._glacier_base.input_select()
    }
    fn input_select_mut(&mut self) -> &mut i32 {
        self._glacier_base.input_select_mut()
    }
}

impl EntityDataTrait for SelectTransformEntityData {
}

impl GameObjectDataTrait for SelectTransformEntityData {
}

impl super::core::DataBusPeerTrait for SelectTransformEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SelectTransformEntityData {
}

impl super::core::DataContainerTrait for SelectTransformEntityData {
}

pub static SELECTTRANSFORMENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectTransformEntityData",
    name_hash: 817404522,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SELECTPROPERTYENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(SelectTransformEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SelectTransformEntityData as Default>::default())),
            create_boxed: || Box::new(<SelectTransformEntityData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(SELECTTRANSFORMENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SelectTransformEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SELECTTRANSFORMENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SELECTTRANSFORMENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectTransformEntityData-Array",
    name_hash: 3967346014,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SelectTransformEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SelectBoolEntityData {
    pub _glacier_base: SelectPropertyEntityData,
}

pub trait SelectBoolEntityDataTrait: SelectPropertyEntityDataTrait {
}

impl SelectBoolEntityDataTrait for SelectBoolEntityData {
}

impl SelectPropertyEntityDataTrait for SelectBoolEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn inputs(&self) -> &Vec<String> {
        self._glacier_base.inputs()
    }
    fn inputs_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.inputs_mut()
    }
    fn input_select(&self) -> &i32 {
        self._glacier_base.input_select()
    }
    fn input_select_mut(&mut self) -> &mut i32 {
        self._glacier_base.input_select_mut()
    }
}

impl EntityDataTrait for SelectBoolEntityData {
}

impl GameObjectDataTrait for SelectBoolEntityData {
}

impl super::core::DataBusPeerTrait for SelectBoolEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SelectBoolEntityData {
}

impl super::core::DataContainerTrait for SelectBoolEntityData {
}

pub static SELECTBOOLENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectBoolEntityData",
    name_hash: 90048264,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SELECTPROPERTYENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(SelectBoolEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SelectBoolEntityData as Default>::default())),
            create_boxed: || Box::new(<SelectBoolEntityData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(SELECTBOOLENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SelectBoolEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SELECTBOOLENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SELECTBOOLENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectBoolEntityData-Array",
    name_hash: 2460305724,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SelectBoolEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SelectStringEntityData {
    pub _glacier_base: SelectPropertyEntityData,
}

pub trait SelectStringEntityDataTrait: SelectPropertyEntityDataTrait {
}

impl SelectStringEntityDataTrait for SelectStringEntityData {
}

impl SelectPropertyEntityDataTrait for SelectStringEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn inputs(&self) -> &Vec<String> {
        self._glacier_base.inputs()
    }
    fn inputs_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.inputs_mut()
    }
    fn input_select(&self) -> &i32 {
        self._glacier_base.input_select()
    }
    fn input_select_mut(&mut self) -> &mut i32 {
        self._glacier_base.input_select_mut()
    }
}

impl EntityDataTrait for SelectStringEntityData {
}

impl GameObjectDataTrait for SelectStringEntityData {
}

impl super::core::DataBusPeerTrait for SelectStringEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SelectStringEntityData {
}

impl super::core::DataContainerTrait for SelectStringEntityData {
}

pub static SELECTSTRINGENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectStringEntityData",
    name_hash: 207396435,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SELECTPROPERTYENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(SelectStringEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SelectStringEntityData as Default>::default())),
            create_boxed: || Box::new(<SelectStringEntityData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(SELECTSTRINGENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SelectStringEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SELECTSTRINGENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SELECTSTRINGENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectStringEntityData-Array",
    name_hash: 307153255,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SelectStringEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SelectInt64EntityData {
    pub _glacier_base: SelectPropertyEntityData,
}

pub trait SelectInt64EntityDataTrait: SelectPropertyEntityDataTrait {
}

impl SelectInt64EntityDataTrait for SelectInt64EntityData {
}

impl SelectPropertyEntityDataTrait for SelectInt64EntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn inputs(&self) -> &Vec<String> {
        self._glacier_base.inputs()
    }
    fn inputs_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.inputs_mut()
    }
    fn input_select(&self) -> &i32 {
        self._glacier_base.input_select()
    }
    fn input_select_mut(&mut self) -> &mut i32 {
        self._glacier_base.input_select_mut()
    }
}

impl EntityDataTrait for SelectInt64EntityData {
}

impl GameObjectDataTrait for SelectInt64EntityData {
}

impl super::core::DataBusPeerTrait for SelectInt64EntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SelectInt64EntityData {
}

impl super::core::DataContainerTrait for SelectInt64EntityData {
}

pub static SELECTINT64ENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectInt64EntityData",
    name_hash: 3294087607,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SELECTPROPERTYENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(SelectInt64EntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SelectInt64EntityData as Default>::default())),
            create_boxed: || Box::new(<SelectInt64EntityData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(SELECTINT64ENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SelectInt64EntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SELECTINT64ENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SELECTINT64ENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectInt64EntityData-Array",
    name_hash: 931734275,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SelectInt64EntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SelectIntEntityData {
    pub _glacier_base: SelectPropertyEntityData,
}

pub trait SelectIntEntityDataTrait: SelectPropertyEntityDataTrait {
}

impl SelectIntEntityDataTrait for SelectIntEntityData {
}

impl SelectPropertyEntityDataTrait for SelectIntEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn inputs(&self) -> &Vec<String> {
        self._glacier_base.inputs()
    }
    fn inputs_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.inputs_mut()
    }
    fn input_select(&self) -> &i32 {
        self._glacier_base.input_select()
    }
    fn input_select_mut(&mut self) -> &mut i32 {
        self._glacier_base.input_select_mut()
    }
}

impl EntityDataTrait for SelectIntEntityData {
}

impl GameObjectDataTrait for SelectIntEntityData {
}

impl super::core::DataBusPeerTrait for SelectIntEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SelectIntEntityData {
}

impl super::core::DataContainerTrait for SelectIntEntityData {
}

pub static SELECTINTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectIntEntityData",
    name_hash: 202088181,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SELECTPROPERTYENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(SelectIntEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SelectIntEntityData as Default>::default())),
            create_boxed: || Box::new(<SelectIntEntityData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(SELECTINTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SelectIntEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SELECTINTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SELECTINTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectIntEntityData-Array",
    name_hash: 464498625,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SelectIntEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SelectFloatEntityData {
    pub _glacier_base: SelectPropertyEntityData,
}

pub trait SelectFloatEntityDataTrait: SelectPropertyEntityDataTrait {
}

impl SelectFloatEntityDataTrait for SelectFloatEntityData {
}

impl SelectPropertyEntityDataTrait for SelectFloatEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn inputs(&self) -> &Vec<String> {
        self._glacier_base.inputs()
    }
    fn inputs_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.inputs_mut()
    }
    fn input_select(&self) -> &i32 {
        self._glacier_base.input_select()
    }
    fn input_select_mut(&mut self) -> &mut i32 {
        self._glacier_base.input_select_mut()
    }
}

impl EntityDataTrait for SelectFloatEntityData {
}

impl GameObjectDataTrait for SelectFloatEntityData {
}

impl super::core::DataBusPeerTrait for SelectFloatEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SelectFloatEntityData {
}

impl super::core::DataContainerTrait for SelectFloatEntityData {
}

pub static SELECTFLOATENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectFloatEntityData",
    name_hash: 2024708438,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SELECTPROPERTYENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(SelectFloatEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SelectFloatEntityData as Default>::default())),
            create_boxed: || Box::new(<SelectFloatEntityData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(SELECTFLOATENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SelectFloatEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SELECTFLOATENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SELECTFLOATENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectFloatEntityData-Array",
    name_hash: 2289704674,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SelectFloatEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SelectPropertyEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub inputs: Vec<String>,
    pub input_select: i32,
}

pub trait SelectPropertyEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn inputs(&self) -> &Vec<String>;
    fn inputs_mut(&mut self) -> &mut Vec<String>;
    fn input_select(&self) -> &i32;
    fn input_select_mut(&mut self) -> &mut i32;
}

impl SelectPropertyEntityDataTrait for SelectPropertyEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn inputs(&self) -> &Vec<String> {
        &self.inputs
    }
    fn inputs_mut(&mut self) -> &mut Vec<String> {
        &mut self.inputs
    }
    fn input_select(&self) -> &i32 {
        &self.input_select
    }
    fn input_select_mut(&mut self) -> &mut i32 {
        &mut self.input_select
    }
}

impl EntityDataTrait for SelectPropertyEntityData {
}

impl GameObjectDataTrait for SelectPropertyEntityData {
}

impl super::core::DataBusPeerTrait for SelectPropertyEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SelectPropertyEntityData {
}

impl super::core::DataContainerTrait for SelectPropertyEntityData {
}

pub static SELECTPROPERTYENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectPropertyEntityData",
    name_hash: 1351701153,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(SelectPropertyEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SelectPropertyEntityData as Default>::default())),
            create_boxed: || Box::new(<SelectPropertyEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(SelectPropertyEntityData, realm),
            },
            FieldInfoData {
                name: "Inputs",
                name_hash: 2784267136,
                flags: MemberInfoFlags::new(144),
                field_type: "CString-Array",
                rust_offset: offset_of!(SelectPropertyEntityData, inputs),
            },
            FieldInfoData {
                name: "InputSelect",
                name_hash: 858290427,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SelectPropertyEntityData, input_select),
            },
        ],
    }),
    array_type: Some(SELECTPROPERTYENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SelectPropertyEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SELECTPROPERTYENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SELECTPROPERTYENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectPropertyEntityData-Array",
    name_hash: 2851765525,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SelectPropertyEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct PathfindingObjectCategoryAsset {
    pub _glacier_base: super::core::Asset,
}

pub trait PathfindingObjectCategoryAssetTrait: super::core::AssetTrait {
}

impl PathfindingObjectCategoryAssetTrait for PathfindingObjectCategoryAsset {
}

impl super::core::AssetTrait for PathfindingObjectCategoryAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for PathfindingObjectCategoryAsset {
}

pub static PATHFINDINGOBJECTCATEGORYASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PathfindingObjectCategoryAsset",
    name_hash: 4255129208,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        super_class_offset: offset_of!(PathfindingObjectCategoryAsset, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PathfindingObjectCategoryAsset as Default>::default())),
            create_boxed: || Box::new(<PathfindingObjectCategoryAsset as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(PATHFINDINGOBJECTCATEGORYASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PathfindingObjectCategoryAsset {
    fn type_info(&self) -> &'static TypeInfo {
        PATHFINDINGOBJECTCATEGORYASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PATHFINDINGOBJECTCATEGORYASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PathfindingObjectCategoryAsset-Array",
    name_hash: 3352950860,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("PathfindingObjectCategoryAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ObjectAreaTriggerEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub time_out: f32,
}

pub trait ObjectAreaTriggerEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn time_out(&self) -> &f32;
    fn time_out_mut(&mut self) -> &mut f32;
}

impl ObjectAreaTriggerEntityDataTrait for ObjectAreaTriggerEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn time_out(&self) -> &f32 {
        &self.time_out
    }
    fn time_out_mut(&mut self) -> &mut f32 {
        &mut self.time_out
    }
}

impl EntityDataTrait for ObjectAreaTriggerEntityData {
}

impl GameObjectDataTrait for ObjectAreaTriggerEntityData {
}

impl super::core::DataBusPeerTrait for ObjectAreaTriggerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ObjectAreaTriggerEntityData {
}

impl super::core::DataContainerTrait for ObjectAreaTriggerEntityData {
}

pub static OBJECTAREATRIGGERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectAreaTriggerEntityData",
    name_hash: 2134682196,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(ObjectAreaTriggerEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ObjectAreaTriggerEntityData as Default>::default())),
            create_boxed: || Box::new(<ObjectAreaTriggerEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(ObjectAreaTriggerEntityData, realm),
            },
            FieldInfoData {
                name: "TimeOut",
                name_hash: 3344659518,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ObjectAreaTriggerEntityData, time_out),
            },
        ],
    }),
    array_type: Some(OBJECTAREATRIGGERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ObjectAreaTriggerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        OBJECTAREATRIGGERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static OBJECTAREATRIGGERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectAreaTriggerEntityData-Array",
    name_hash: 3310909152,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ObjectAreaTriggerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ObjectVariationToIntEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
}

pub trait ObjectVariationToIntEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
}

impl ObjectVariationToIntEntityDataTrait for ObjectVariationToIntEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
}

impl EntityDataTrait for ObjectVariationToIntEntityData {
}

impl GameObjectDataTrait for ObjectVariationToIntEntityData {
}

impl super::core::DataBusPeerTrait for ObjectVariationToIntEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ObjectVariationToIntEntityData {
}

impl super::core::DataContainerTrait for ObjectVariationToIntEntityData {
}

pub static OBJECTVARIATIONTOINTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectVariationToIntEntityData",
    name_hash: 1563875970,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(ObjectVariationToIntEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ObjectVariationToIntEntityData as Default>::default())),
            create_boxed: || Box::new(<ObjectVariationToIntEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(ObjectVariationToIntEntityData, realm),
            },
        ],
    }),
    array_type: Some(OBJECTVARIATIONTOINTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ObjectVariationToIntEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        OBJECTVARIATIONTOINTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static OBJECTVARIATIONTOINTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectVariationToIntEntityData-Array",
    name_hash: 2161875382,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ObjectVariationToIntEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TransformSpaceEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
}

pub trait TransformSpaceEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
}

impl TransformSpaceEntityDataTrait for TransformSpaceEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
}

impl EntityDataTrait for TransformSpaceEntityData {
}

impl GameObjectDataTrait for TransformSpaceEntityData {
}

impl super::core::DataBusPeerTrait for TransformSpaceEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TransformSpaceEntityData {
}

impl super::core::DataContainerTrait for TransformSpaceEntityData {
}

pub static TRANSFORMSPACEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformSpaceEntityData",
    name_hash: 2627011014,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(TransformSpaceEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformSpaceEntityData as Default>::default())),
            create_boxed: || Box::new(<TransformSpaceEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(TransformSpaceEntityData, realm),
            },
        ],
    }),
    array_type: Some(TRANSFORMSPACEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TransformSpaceEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMSPACEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TRANSFORMSPACEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformSpaceEntityData-Array",
    name_hash: 3608813426,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TransformSpaceEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct BalancedDilationEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub dilation_value: f32,
    pub real_time_duration: f32,
    pub recovery_time: f32,
    pub dilation_shape: TimeShape,
    pub recovery_shape: TimeShape,
}

pub trait BalancedDilationEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn dilation_value(&self) -> &f32;
    fn dilation_value_mut(&mut self) -> &mut f32;
    fn real_time_duration(&self) -> &f32;
    fn real_time_duration_mut(&mut self) -> &mut f32;
    fn recovery_time(&self) -> &f32;
    fn recovery_time_mut(&mut self) -> &mut f32;
    fn dilation_shape(&self) -> &TimeShape;
    fn dilation_shape_mut(&mut self) -> &mut TimeShape;
    fn recovery_shape(&self) -> &TimeShape;
    fn recovery_shape_mut(&mut self) -> &mut TimeShape;
}

impl BalancedDilationEntityDataTrait for BalancedDilationEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn dilation_value(&self) -> &f32 {
        &self.dilation_value
    }
    fn dilation_value_mut(&mut self) -> &mut f32 {
        &mut self.dilation_value
    }
    fn real_time_duration(&self) -> &f32 {
        &self.real_time_duration
    }
    fn real_time_duration_mut(&mut self) -> &mut f32 {
        &mut self.real_time_duration
    }
    fn recovery_time(&self) -> &f32 {
        &self.recovery_time
    }
    fn recovery_time_mut(&mut self) -> &mut f32 {
        &mut self.recovery_time
    }
    fn dilation_shape(&self) -> &TimeShape {
        &self.dilation_shape
    }
    fn dilation_shape_mut(&mut self) -> &mut TimeShape {
        &mut self.dilation_shape
    }
    fn recovery_shape(&self) -> &TimeShape {
        &self.recovery_shape
    }
    fn recovery_shape_mut(&mut self) -> &mut TimeShape {
        &mut self.recovery_shape
    }
}

impl EntityDataTrait for BalancedDilationEntityData {
}

impl GameObjectDataTrait for BalancedDilationEntityData {
}

impl super::core::DataBusPeerTrait for BalancedDilationEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for BalancedDilationEntityData {
}

impl super::core::DataContainerTrait for BalancedDilationEntityData {
}

pub static BALANCEDDILATIONENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BalancedDilationEntityData",
    name_hash: 2383975152,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(BalancedDilationEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BalancedDilationEntityData as Default>::default())),
            create_boxed: || Box::new(<BalancedDilationEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(BalancedDilationEntityData, realm),
            },
            FieldInfoData {
                name: "DilationValue",
                name_hash: 1503263346,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BalancedDilationEntityData, dilation_value),
            },
            FieldInfoData {
                name: "RealTimeDuration",
                name_hash: 1481232916,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BalancedDilationEntityData, real_time_duration),
            },
            FieldInfoData {
                name: "RecoveryTime",
                name_hash: 359615635,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BalancedDilationEntityData, recovery_time),
            },
            FieldInfoData {
                name: "DilationShape",
                name_hash: 1499605238,
                flags: MemberInfoFlags::new(0),
                field_type: "TimeShape",
                rust_offset: offset_of!(BalancedDilationEntityData, dilation_shape),
            },
            FieldInfoData {
                name: "RecoveryShape",
                name_hash: 3274079049,
                flags: MemberInfoFlags::new(0),
                field_type: "TimeShape",
                rust_offset: offset_of!(BalancedDilationEntityData, recovery_shape),
            },
        ],
    }),
    array_type: Some(BALANCEDDILATIONENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BalancedDilationEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        BALANCEDDILATIONENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BALANCEDDILATIONENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BalancedDilationEntityData-Array",
    name_hash: 1886941380,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("BalancedDilationEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct DilationEntityData {
    pub _glacier_base: EntityData,
    pub fade_in_time: f32,
    pub fade_out_time: f32,
    pub real_time_duration: f32,
    pub priority: DilationPriority,
    pub dilation_value: f32,
    pub time_delta_type: TimeDeltaType,
}

pub trait DilationEntityDataTrait: EntityDataTrait {
    fn fade_in_time(&self) -> &f32;
    fn fade_in_time_mut(&mut self) -> &mut f32;
    fn fade_out_time(&self) -> &f32;
    fn fade_out_time_mut(&mut self) -> &mut f32;
    fn real_time_duration(&self) -> &f32;
    fn real_time_duration_mut(&mut self) -> &mut f32;
    fn priority(&self) -> &DilationPriority;
    fn priority_mut(&mut self) -> &mut DilationPriority;
    fn dilation_value(&self) -> &f32;
    fn dilation_value_mut(&mut self) -> &mut f32;
    fn time_delta_type(&self) -> &TimeDeltaType;
    fn time_delta_type_mut(&mut self) -> &mut TimeDeltaType;
}

impl DilationEntityDataTrait for DilationEntityData {
    fn fade_in_time(&self) -> &f32 {
        &self.fade_in_time
    }
    fn fade_in_time_mut(&mut self) -> &mut f32 {
        &mut self.fade_in_time
    }
    fn fade_out_time(&self) -> &f32 {
        &self.fade_out_time
    }
    fn fade_out_time_mut(&mut self) -> &mut f32 {
        &mut self.fade_out_time
    }
    fn real_time_duration(&self) -> &f32 {
        &self.real_time_duration
    }
    fn real_time_duration_mut(&mut self) -> &mut f32 {
        &mut self.real_time_duration
    }
    fn priority(&self) -> &DilationPriority {
        &self.priority
    }
    fn priority_mut(&mut self) -> &mut DilationPriority {
        &mut self.priority
    }
    fn dilation_value(&self) -> &f32 {
        &self.dilation_value
    }
    fn dilation_value_mut(&mut self) -> &mut f32 {
        &mut self.dilation_value
    }
    fn time_delta_type(&self) -> &TimeDeltaType {
        &self.time_delta_type
    }
    fn time_delta_type_mut(&mut self) -> &mut TimeDeltaType {
        &mut self.time_delta_type
    }
}

impl EntityDataTrait for DilationEntityData {
}

impl GameObjectDataTrait for DilationEntityData {
}

impl super::core::DataBusPeerTrait for DilationEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for DilationEntityData {
}

impl super::core::DataContainerTrait for DilationEntityData {
}

pub static DILATIONENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DilationEntityData",
    name_hash: 119860786,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(DilationEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DilationEntityData as Default>::default())),
            create_boxed: || Box::new(<DilationEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "FadeInTime",
                name_hash: 1781703921,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DilationEntityData, fade_in_time),
            },
            FieldInfoData {
                name: "FadeOutTime",
                name_hash: 1285109176,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DilationEntityData, fade_out_time),
            },
            FieldInfoData {
                name: "RealTimeDuration",
                name_hash: 1481232916,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DilationEntityData, real_time_duration),
            },
            FieldInfoData {
                name: "Priority",
                name_hash: 3062102871,
                flags: MemberInfoFlags::new(0),
                field_type: "DilationPriority",
                rust_offset: offset_of!(DilationEntityData, priority),
            },
            FieldInfoData {
                name: "DilationValue",
                name_hash: 1503263346,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DilationEntityData, dilation_value),
            },
            FieldInfoData {
                name: "TimeDeltaType",
                name_hash: 1100516816,
                flags: MemberInfoFlags::new(0),
                field_type: "TimeDeltaType",
                rust_offset: offset_of!(DilationEntityData, time_delta_type),
            },
        ],
    }),
    array_type: Some(DILATIONENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DilationEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        DILATIONENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DILATIONENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DilationEntityData-Array",
    name_hash: 1470674054,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("DilationEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct FloatSelectEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub in_pos_or_zero: f32,
    pub in_neg: f32,
    pub select: f32,
}

pub trait FloatSelectEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn in_pos_or_zero(&self) -> &f32;
    fn in_pos_or_zero_mut(&mut self) -> &mut f32;
    fn in_neg(&self) -> &f32;
    fn in_neg_mut(&mut self) -> &mut f32;
    fn select(&self) -> &f32;
    fn select_mut(&mut self) -> &mut f32;
}

impl FloatSelectEntityDataTrait for FloatSelectEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn in_pos_or_zero(&self) -> &f32 {
        &self.in_pos_or_zero
    }
    fn in_pos_or_zero_mut(&mut self) -> &mut f32 {
        &mut self.in_pos_or_zero
    }
    fn in_neg(&self) -> &f32 {
        &self.in_neg
    }
    fn in_neg_mut(&mut self) -> &mut f32 {
        &mut self.in_neg
    }
    fn select(&self) -> &f32 {
        &self.select
    }
    fn select_mut(&mut self) -> &mut f32 {
        &mut self.select
    }
}

impl EntityDataTrait for FloatSelectEntityData {
}

impl GameObjectDataTrait for FloatSelectEntityData {
}

impl super::core::DataBusPeerTrait for FloatSelectEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for FloatSelectEntityData {
}

impl super::core::DataContainerTrait for FloatSelectEntityData {
}

pub static FLOATSELECTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatSelectEntityData",
    name_hash: 2149687126,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(FloatSelectEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FloatSelectEntityData as Default>::default())),
            create_boxed: || Box::new(<FloatSelectEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(FloatSelectEntityData, realm),
            },
            FieldInfoData {
                name: "InPosOrZero",
                name_hash: 747943761,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FloatSelectEntityData, in_pos_or_zero),
            },
            FieldInfoData {
                name: "InNeg",
                name_hash: 214487662,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FloatSelectEntityData, in_neg),
            },
            FieldInfoData {
                name: "Select",
                name_hash: 3338028653,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FloatSelectEntityData, select),
            },
        ],
    }),
    array_type: Some(FLOATSELECTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FloatSelectEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        FLOATSELECTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FLOATSELECTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatSelectEntityData-Array",
    name_hash: 4154041570,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("FloatSelectEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct FloatCurveEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub r#in: f32,
    pub output_integral: bool,
    pub curve: Option<LockedTypeObject /* super::core::FloatCurve */>,
}

pub trait FloatCurveEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn r#in(&self) -> &f32;
    fn r#in_mut(&mut self) -> &mut f32;
    fn output_integral(&self) -> &bool;
    fn output_integral_mut(&mut self) -> &mut bool;
    fn curve(&self) -> &Option<LockedTypeObject /* super::core::FloatCurve */>;
    fn curve_mut(&mut self) -> &mut Option<LockedTypeObject /* super::core::FloatCurve */>;
}

impl FloatCurveEntityDataTrait for FloatCurveEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn r#in(&self) -> &f32 {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut f32 {
        &mut self.r#in
    }
    fn output_integral(&self) -> &bool {
        &self.output_integral
    }
    fn output_integral_mut(&mut self) -> &mut bool {
        &mut self.output_integral
    }
    fn curve(&self) -> &Option<LockedTypeObject /* super::core::FloatCurve */> {
        &self.curve
    }
    fn curve_mut(&mut self) -> &mut Option<LockedTypeObject /* super::core::FloatCurve */> {
        &mut self.curve
    }
}

impl EntityDataTrait for FloatCurveEntityData {
}

impl GameObjectDataTrait for FloatCurveEntityData {
}

impl super::core::DataBusPeerTrait for FloatCurveEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for FloatCurveEntityData {
}

impl super::core::DataContainerTrait for FloatCurveEntityData {
}

pub static FLOATCURVEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatCurveEntityData",
    name_hash: 2229841833,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(FloatCurveEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FloatCurveEntityData as Default>::default())),
            create_boxed: || Box::new(<FloatCurveEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(FloatCurveEntityData, realm),
            },
            FieldInfoData {
                name: "In",
                name_hash: 5862146,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FloatCurveEntityData, r#in),
            },
            FieldInfoData {
                name: "OutputIntegral",
                name_hash: 3008701940,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FloatCurveEntityData, output_integral),
            },
            FieldInfoData {
                name: "Curve",
                name_hash: 212866962,
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(FloatCurveEntityData, curve),
            },
        ],
    }),
    array_type: Some(FLOATCURVEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FloatCurveEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        FLOATCURVEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FLOATCURVEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatCurveEntityData-Array",
    name_hash: 2921526813,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("FloatCurveEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct LocalPlayerGateEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
}

pub trait LocalPlayerGateEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
}

impl LocalPlayerGateEntityDataTrait for LocalPlayerGateEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
}

impl EntityDataTrait for LocalPlayerGateEntityData {
}

impl GameObjectDataTrait for LocalPlayerGateEntityData {
}

impl super::core::DataBusPeerTrait for LocalPlayerGateEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for LocalPlayerGateEntityData {
}

impl super::core::DataContainerTrait for LocalPlayerGateEntityData {
}

pub static LOCALPLAYERGATEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalPlayerGateEntityData",
    name_hash: 3677842215,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(LocalPlayerGateEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LocalPlayerGateEntityData as Default>::default())),
            create_boxed: || Box::new(<LocalPlayerGateEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(LocalPlayerGateEntityData, realm),
            },
        ],
    }),
    array_type: Some(LOCALPLAYERGATEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LocalPlayerGateEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        LOCALPLAYERGATEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LOCALPLAYERGATEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalPlayerGateEntityData-Array",
    name_hash: 3345554579,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("LocalPlayerGateEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TransformSelectorEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub in1: super::core::LinearTransform,
    pub in2: super::core::LinearTransform,
    pub selection: bool,
}

pub trait TransformSelectorEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn in1(&self) -> &super::core::LinearTransform;
    fn in1_mut(&mut self) -> &mut super::core::LinearTransform;
    fn in2(&self) -> &super::core::LinearTransform;
    fn in2_mut(&mut self) -> &mut super::core::LinearTransform;
    fn selection(&self) -> &bool;
    fn selection_mut(&mut self) -> &mut bool;
}

impl TransformSelectorEntityDataTrait for TransformSelectorEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn in1(&self) -> &super::core::LinearTransform {
        &self.in1
    }
    fn in1_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.in1
    }
    fn in2(&self) -> &super::core::LinearTransform {
        &self.in2
    }
    fn in2_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.in2
    }
    fn selection(&self) -> &bool {
        &self.selection
    }
    fn selection_mut(&mut self) -> &mut bool {
        &mut self.selection
    }
}

impl EntityDataTrait for TransformSelectorEntityData {
}

impl GameObjectDataTrait for TransformSelectorEntityData {
}

impl super::core::DataBusPeerTrait for TransformSelectorEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TransformSelectorEntityData {
}

impl super::core::DataContainerTrait for TransformSelectorEntityData {
}

pub static TRANSFORMSELECTORENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformSelectorEntityData",
    name_hash: 209817303,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(TransformSelectorEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformSelectorEntityData as Default>::default())),
            create_boxed: || Box::new(<TransformSelectorEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(TransformSelectorEntityData, realm),
            },
            FieldInfoData {
                name: "In1",
                name_hash: 193450867,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(TransformSelectorEntityData, in1),
            },
            FieldInfoData {
                name: "In2",
                name_hash: 193450864,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(TransformSelectorEntityData, in2),
            },
            FieldInfoData {
                name: "Selection",
                name_hash: 299217285,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TransformSelectorEntityData, selection),
            },
        ],
    }),
    array_type: Some(TRANSFORMSELECTORENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for TransformSelectorEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMSELECTORENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TRANSFORMSELECTORENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformSelectorEntityData-Array",
    name_hash: 3569731555,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TransformSelectorEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SettingEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub bool_setting_name: String,
    pub int_setting_name: String,
    pub float_setting_name: String,
    pub uint_setting_name: String,
}

pub trait SettingEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn bool_setting_name(&self) -> &String;
    fn bool_setting_name_mut(&mut self) -> &mut String;
    fn int_setting_name(&self) -> &String;
    fn int_setting_name_mut(&mut self) -> &mut String;
    fn float_setting_name(&self) -> &String;
    fn float_setting_name_mut(&mut self) -> &mut String;
    fn uint_setting_name(&self) -> &String;
    fn uint_setting_name_mut(&mut self) -> &mut String;
}

impl SettingEntityDataTrait for SettingEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn bool_setting_name(&self) -> &String {
        &self.bool_setting_name
    }
    fn bool_setting_name_mut(&mut self) -> &mut String {
        &mut self.bool_setting_name
    }
    fn int_setting_name(&self) -> &String {
        &self.int_setting_name
    }
    fn int_setting_name_mut(&mut self) -> &mut String {
        &mut self.int_setting_name
    }
    fn float_setting_name(&self) -> &String {
        &self.float_setting_name
    }
    fn float_setting_name_mut(&mut self) -> &mut String {
        &mut self.float_setting_name
    }
    fn uint_setting_name(&self) -> &String {
        &self.uint_setting_name
    }
    fn uint_setting_name_mut(&mut self) -> &mut String {
        &mut self.uint_setting_name
    }
}

impl EntityDataTrait for SettingEntityData {
}

impl GameObjectDataTrait for SettingEntityData {
}

impl super::core::DataBusPeerTrait for SettingEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SettingEntityData {
}

impl super::core::DataContainerTrait for SettingEntityData {
}

pub static SETTINGENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SettingEntityData",
    name_hash: 902383416,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(SettingEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SettingEntityData as Default>::default())),
            create_boxed: || Box::new(<SettingEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(SettingEntityData, realm),
            },
            FieldInfoData {
                name: "BoolSettingName",
                name_hash: 2857256474,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(SettingEntityData, bool_setting_name),
            },
            FieldInfoData {
                name: "IntSettingName",
                name_hash: 2665330183,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(SettingEntityData, int_setting_name),
            },
            FieldInfoData {
                name: "FloatSettingName",
                name_hash: 3117588292,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(SettingEntityData, float_setting_name),
            },
            FieldInfoData {
                name: "UintSettingName",
                name_hash: 904839698,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(SettingEntityData, uint_setting_name),
            },
        ],
    }),
    array_type: Some(SETTINGENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SettingEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SETTINGENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SETTINGENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SettingEntityData-Array",
    name_hash: 2561847436,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SettingEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct IntegratorOrDifferentiatorEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub start_value: f32,
    pub input: f32,
    pub bounded: bool,
    pub max_value: f32,
    pub min_value: f32,
}

pub trait IntegratorOrDifferentiatorEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn start_value(&self) -> &f32;
    fn start_value_mut(&mut self) -> &mut f32;
    fn input(&self) -> &f32;
    fn input_mut(&mut self) -> &mut f32;
    fn bounded(&self) -> &bool;
    fn bounded_mut(&mut self) -> &mut bool;
    fn max_value(&self) -> &f32;
    fn max_value_mut(&mut self) -> &mut f32;
    fn min_value(&self) -> &f32;
    fn min_value_mut(&mut self) -> &mut f32;
}

impl IntegratorOrDifferentiatorEntityDataTrait for IntegratorOrDifferentiatorEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn start_value(&self) -> &f32 {
        &self.start_value
    }
    fn start_value_mut(&mut self) -> &mut f32 {
        &mut self.start_value
    }
    fn input(&self) -> &f32 {
        &self.input
    }
    fn input_mut(&mut self) -> &mut f32 {
        &mut self.input
    }
    fn bounded(&self) -> &bool {
        &self.bounded
    }
    fn bounded_mut(&mut self) -> &mut bool {
        &mut self.bounded
    }
    fn max_value(&self) -> &f32 {
        &self.max_value
    }
    fn max_value_mut(&mut self) -> &mut f32 {
        &mut self.max_value
    }
    fn min_value(&self) -> &f32 {
        &self.min_value
    }
    fn min_value_mut(&mut self) -> &mut f32 {
        &mut self.min_value
    }
}

impl EntityDataTrait for IntegratorOrDifferentiatorEntityData {
}

impl GameObjectDataTrait for IntegratorOrDifferentiatorEntityData {
}

impl super::core::DataBusPeerTrait for IntegratorOrDifferentiatorEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for IntegratorOrDifferentiatorEntityData {
}

impl super::core::DataContainerTrait for IntegratorOrDifferentiatorEntityData {
}

pub static INTEGRATORORDIFFERENTIATORENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntegratorOrDifferentiatorEntityData",
    name_hash: 983041532,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(IntegratorOrDifferentiatorEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<IntegratorOrDifferentiatorEntityData as Default>::default())),
            create_boxed: || Box::new(<IntegratorOrDifferentiatorEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(IntegratorOrDifferentiatorEntityData, realm),
            },
            FieldInfoData {
                name: "StartValue",
                name_hash: 2748522638,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(IntegratorOrDifferentiatorEntityData, start_value),
            },
            FieldInfoData {
                name: "Input",
                name_hash: 214522259,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(IntegratorOrDifferentiatorEntityData, input),
            },
            FieldInfoData {
                name: "Bounded",
                name_hash: 2541140406,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(IntegratorOrDifferentiatorEntityData, bounded),
            },
            FieldInfoData {
                name: "MaxValue",
                name_hash: 408516922,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(IntegratorOrDifferentiatorEntityData, max_value),
            },
            FieldInfoData {
                name: "MinValue",
                name_hash: 3371854436,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(IntegratorOrDifferentiatorEntityData, min_value),
            },
        ],
    }),
    array_type: Some(INTEGRATORORDIFFERENTIATORENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for IntegratorOrDifferentiatorEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        INTEGRATORORDIFFERENTIATORENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static INTEGRATORORDIFFERENTIATORENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntegratorOrDifferentiatorEntityData-Array",
    name_hash: 222375368,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("IntegratorOrDifferentiatorEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ProfileEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub profile_name: String,
}

pub trait ProfileEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn profile_name(&self) -> &String;
    fn profile_name_mut(&mut self) -> &mut String;
}

impl ProfileEntityDataTrait for ProfileEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn profile_name(&self) -> &String {
        &self.profile_name
    }
    fn profile_name_mut(&mut self) -> &mut String {
        &mut self.profile_name
    }
}

impl EntityDataTrait for ProfileEntityData {
}

impl GameObjectDataTrait for ProfileEntityData {
}

impl super::core::DataBusPeerTrait for ProfileEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ProfileEntityData {
}

impl super::core::DataContainerTrait for ProfileEntityData {
}

pub static PROFILEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ProfileEntityData",
    name_hash: 4191813829,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(ProfileEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ProfileEntityData as Default>::default())),
            create_boxed: || Box::new(<ProfileEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(ProfileEntityData, realm),
            },
            FieldInfoData {
                name: "ProfileName",
                name_hash: 1665193641,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ProfileEntityData, profile_name),
            },
        ],
    }),
    array_type: Some(PROFILEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ProfileEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PROFILEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PROFILEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ProfileEntityData-Array",
    name_hash: 1777121521,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ProfileEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CompareEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub operator: CompareOp,
    pub float_in0: f32,
    pub float_in1: f32,
    pub int_in0: i32,
    pub int_in1: i32,
}

pub trait CompareEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn operator(&self) -> &CompareOp;
    fn operator_mut(&mut self) -> &mut CompareOp;
    fn float_in0(&self) -> &f32;
    fn float_in0_mut(&mut self) -> &mut f32;
    fn float_in1(&self) -> &f32;
    fn float_in1_mut(&mut self) -> &mut f32;
    fn int_in0(&self) -> &i32;
    fn int_in0_mut(&mut self) -> &mut i32;
    fn int_in1(&self) -> &i32;
    fn int_in1_mut(&mut self) -> &mut i32;
}

impl CompareEntityDataTrait for CompareEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn operator(&self) -> &CompareOp {
        &self.operator
    }
    fn operator_mut(&mut self) -> &mut CompareOp {
        &mut self.operator
    }
    fn float_in0(&self) -> &f32 {
        &self.float_in0
    }
    fn float_in0_mut(&mut self) -> &mut f32 {
        &mut self.float_in0
    }
    fn float_in1(&self) -> &f32 {
        &self.float_in1
    }
    fn float_in1_mut(&mut self) -> &mut f32 {
        &mut self.float_in1
    }
    fn int_in0(&self) -> &i32 {
        &self.int_in0
    }
    fn int_in0_mut(&mut self) -> &mut i32 {
        &mut self.int_in0
    }
    fn int_in1(&self) -> &i32 {
        &self.int_in1
    }
    fn int_in1_mut(&mut self) -> &mut i32 {
        &mut self.int_in1
    }
}

impl EntityDataTrait for CompareEntityData {
}

impl GameObjectDataTrait for CompareEntityData {
}

impl super::core::DataBusPeerTrait for CompareEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CompareEntityData {
}

impl super::core::DataContainerTrait for CompareEntityData {
}

pub static COMPAREENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareEntityData",
    name_hash: 3678807465,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(CompareEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareEntityData as Default>::default())),
            create_boxed: || Box::new(<CompareEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(CompareEntityData, realm),
            },
            FieldInfoData {
                name: "Operator",
                name_hash: 2153507813,
                flags: MemberInfoFlags::new(0),
                field_type: "CompareOp",
                rust_offset: offset_of!(CompareEntityData, operator),
            },
            FieldInfoData {
                name: "FloatIn0",
                name_hash: 1718513826,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CompareEntityData, float_in0),
            },
            FieldInfoData {
                name: "FloatIn1",
                name_hash: 1718513827,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CompareEntityData, float_in1),
            },
            FieldInfoData {
                name: "IntIn0",
                name_hash: 2784473121,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CompareEntityData, int_in0),
            },
            FieldInfoData {
                name: "IntIn1",
                name_hash: 2784473120,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CompareEntityData, int_in1),
            },
        ],
    }),
    array_type: Some(COMPAREENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CompareEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        COMPAREENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COMPAREENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareEntityData-Array",
    name_hash: 3997232157,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CompareOp {
    #[default]
    CompareOp_Equal = 0,
    CompareOp_NotEqual = 1,
    CompareOp_Greater = 2,
    CompareOp_Less = 3,
    CompareOp_GreaterOrEqual = 4,
    CompareOp_LessOrEqual = 5,
}

pub static COMPAREOP_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareOp",
    name_hash: 1922066461,
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(COMPAREOP_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CompareOp {
    fn type_info(&self) -> &'static TypeInfo {
        COMPAREOP_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static COMPAREOP_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareOp-Array",
    name_hash: 452572073,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareOp"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct RunningAverageEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub number_of_values: u32,
    pub r#in: f32,
}

pub trait RunningAverageEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn number_of_values(&self) -> &u32;
    fn number_of_values_mut(&mut self) -> &mut u32;
    fn r#in(&self) -> &f32;
    fn r#in_mut(&mut self) -> &mut f32;
}

impl RunningAverageEntityDataTrait for RunningAverageEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn number_of_values(&self) -> &u32 {
        &self.number_of_values
    }
    fn number_of_values_mut(&mut self) -> &mut u32 {
        &mut self.number_of_values
    }
    fn r#in(&self) -> &f32 {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut f32 {
        &mut self.r#in
    }
}

impl EntityDataTrait for RunningAverageEntityData {
}

impl GameObjectDataTrait for RunningAverageEntityData {
}

impl super::core::DataBusPeerTrait for RunningAverageEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for RunningAverageEntityData {
}

impl super::core::DataContainerTrait for RunningAverageEntityData {
}

pub static RUNNINGAVERAGEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RunningAverageEntityData",
    name_hash: 295177610,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(RunningAverageEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RunningAverageEntityData as Default>::default())),
            create_boxed: || Box::new(<RunningAverageEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(RunningAverageEntityData, realm),
            },
            FieldInfoData {
                name: "NumberOfValues",
                name_hash: 3705372087,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(RunningAverageEntityData, number_of_values),
            },
            FieldInfoData {
                name: "In",
                name_hash: 5862146,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RunningAverageEntityData, r#in),
            },
        ],
    }),
    array_type: Some(RUNNINGAVERAGEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RunningAverageEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        RUNNINGAVERAGEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RUNNINGAVERAGEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RunningAverageEntityData-Array",
    name_hash: 1452697790,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("RunningAverageEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct AbsEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub r#in: f32,
}

pub trait AbsEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn r#in(&self) -> &f32;
    fn r#in_mut(&mut self) -> &mut f32;
}

impl AbsEntityDataTrait for AbsEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn r#in(&self) -> &f32 {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut f32 {
        &mut self.r#in
    }
}

impl EntityDataTrait for AbsEntityData {
}

impl GameObjectDataTrait for AbsEntityData {
}

impl super::core::DataBusPeerTrait for AbsEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AbsEntityData {
}

impl super::core::DataContainerTrait for AbsEntityData {
}

pub static ABSENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AbsEntityData",
    name_hash: 3621308766,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(AbsEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AbsEntityData as Default>::default())),
            create_boxed: || Box::new(<AbsEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(AbsEntityData, realm),
            },
            FieldInfoData {
                name: "In",
                name_hash: 5862146,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AbsEntityData, r#in),
            },
        ],
    }),
    array_type: Some(ABSENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AbsEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        ABSENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ABSENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AbsEntityData-Array",
    name_hash: 1292348138,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("AbsEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct VectorMathOpEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub math_operator: VectorMathOp,
}

pub trait VectorMathOpEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn math_operator(&self) -> &VectorMathOp;
    fn math_operator_mut(&mut self) -> &mut VectorMathOp;
}

impl VectorMathOpEntityDataTrait for VectorMathOpEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn math_operator(&self) -> &VectorMathOp {
        &self.math_operator
    }
    fn math_operator_mut(&mut self) -> &mut VectorMathOp {
        &mut self.math_operator
    }
}

impl EntityDataTrait for VectorMathOpEntityData {
}

impl GameObjectDataTrait for VectorMathOpEntityData {
}

impl super::core::DataBusPeerTrait for VectorMathOpEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for VectorMathOpEntityData {
}

impl super::core::DataContainerTrait for VectorMathOpEntityData {
}

pub static VECTORMATHOPENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VectorMathOpEntityData",
    name_hash: 699369496,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(VectorMathOpEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VectorMathOpEntityData as Default>::default())),
            create_boxed: || Box::new(<VectorMathOpEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(VectorMathOpEntityData, realm),
            },
            FieldInfoData {
                name: "MathOperator",
                name_hash: 2452100597,
                flags: MemberInfoFlags::new(0),
                field_type: "VectorMathOp",
                rust_offset: offset_of!(VectorMathOpEntityData, math_operator),
            },
        ],
    }),
    array_type: Some(VECTORMATHOPENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VectorMathOpEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VECTORMATHOPENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VECTORMATHOPENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VectorMathOpEntityData-Array",
    name_hash: 3622195756,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("VectorMathOpEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum VectorMathOp {
    #[default]
    VectorMathOp_Add = 0,
    VectorMathOp_Subtract = 1,
    VectorMathOp_MultiplyByFloat = 2,
    VectorMathOp_DivideByFloat = 3,
    VectorMathOp_Cross = 4,
    VectorMathOp_Dot = 5,
    VectorMathOp_Length = 6,
}

pub static VECTORMATHOP_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VectorMathOp",
    name_hash: 2487987571,
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(VECTORMATHOP_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for VectorMathOp {
    fn type_info(&self) -> &'static TypeInfo {
        VECTORMATHOP_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VECTORMATHOP_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VectorMathOp-Array",
    name_hash: 2026711367,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("VectorMathOp"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct MathOpEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub operators: Vec<MathOp>,
}

pub trait MathOpEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn operators(&self) -> &Vec<MathOp>;
    fn operators_mut(&mut self) -> &mut Vec<MathOp>;
}

impl MathOpEntityDataTrait for MathOpEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn operators(&self) -> &Vec<MathOp> {
        &self.operators
    }
    fn operators_mut(&mut self) -> &mut Vec<MathOp> {
        &mut self.operators
    }
}

impl EntityDataTrait for MathOpEntityData {
}

impl GameObjectDataTrait for MathOpEntityData {
}

impl super::core::DataBusPeerTrait for MathOpEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for MathOpEntityData {
}

impl super::core::DataContainerTrait for MathOpEntityData {
}

pub static MATHOPENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MathOpEntityData",
    name_hash: 296443553,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(MathOpEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MathOpEntityData as Default>::default())),
            create_boxed: || Box::new(<MathOpEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(MathOpEntityData, realm),
            },
            FieldInfoData {
                name: "Operators",
                name_hash: 2346281206,
                flags: MemberInfoFlags::new(144),
                field_type: "MathOp-Array",
                rust_offset: offset_of!(MathOpEntityData, operators),
            },
        ],
    }),
    array_type: Some(MATHOPENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MathOpEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        MATHOPENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MATHOPENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MathOpEntityData-Array",
    name_hash: 292391189,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("MathOpEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum MathOp {
    #[default]
    MathOp_Add = 0,
    MathOp_Subtract = 1,
    MathOp_Multiply = 2,
    MathOp_Divide = 3,
    MathOp_Min = 4,
    MathOp_Max = 5,
    MathOp_Modulo = 6,
    MathOp_Exponent = 7,
}

pub static MATHOP_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MathOp",
    name_hash: 2643222858,
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(MATHOP_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for MathOp {
    fn type_info(&self) -> &'static TypeInfo {
        MATHOP_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MATHOP_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MathOp-Array",
    name_hash: 4030385406,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("MathOp"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct PropertyCastEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub precision: i32,
    pub bool_value: bool,
    pub float_value: f32,
    pub int_value: i32,
    pub uint_value: u32,
    pub string_value: String,
}

pub trait PropertyCastEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn precision(&self) -> &i32;
    fn precision_mut(&mut self) -> &mut i32;
    fn bool_value(&self) -> &bool;
    fn bool_value_mut(&mut self) -> &mut bool;
    fn float_value(&self) -> &f32;
    fn float_value_mut(&mut self) -> &mut f32;
    fn int_value(&self) -> &i32;
    fn int_value_mut(&mut self) -> &mut i32;
    fn uint_value(&self) -> &u32;
    fn uint_value_mut(&mut self) -> &mut u32;
    fn string_value(&self) -> &String;
    fn string_value_mut(&mut self) -> &mut String;
}

impl PropertyCastEntityDataTrait for PropertyCastEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn precision(&self) -> &i32 {
        &self.precision
    }
    fn precision_mut(&mut self) -> &mut i32 {
        &mut self.precision
    }
    fn bool_value(&self) -> &bool {
        &self.bool_value
    }
    fn bool_value_mut(&mut self) -> &mut bool {
        &mut self.bool_value
    }
    fn float_value(&self) -> &f32 {
        &self.float_value
    }
    fn float_value_mut(&mut self) -> &mut f32 {
        &mut self.float_value
    }
    fn int_value(&self) -> &i32 {
        &self.int_value
    }
    fn int_value_mut(&mut self) -> &mut i32 {
        &mut self.int_value
    }
    fn uint_value(&self) -> &u32 {
        &self.uint_value
    }
    fn uint_value_mut(&mut self) -> &mut u32 {
        &mut self.uint_value
    }
    fn string_value(&self) -> &String {
        &self.string_value
    }
    fn string_value_mut(&mut self) -> &mut String {
        &mut self.string_value
    }
}

impl EntityDataTrait for PropertyCastEntityData {
}

impl GameObjectDataTrait for PropertyCastEntityData {
}

impl super::core::DataBusPeerTrait for PropertyCastEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PropertyCastEntityData {
}

impl super::core::DataContainerTrait for PropertyCastEntityData {
}

pub static PROPERTYCASTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PropertyCastEntityData",
    name_hash: 3731952108,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(PropertyCastEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PropertyCastEntityData as Default>::default())),
            create_boxed: || Box::new(<PropertyCastEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(PropertyCastEntityData, realm),
            },
            FieldInfoData {
                name: "Precision",
                name_hash: 107147283,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(PropertyCastEntityData, precision),
            },
            FieldInfoData {
                name: "BoolValue",
                name_hash: 176040160,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PropertyCastEntityData, bool_value),
            },
            FieldInfoData {
                name: "FloatValue",
                name_hash: 3123792190,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PropertyCastEntityData, float_value),
            },
            FieldInfoData {
                name: "IntValue",
                name_hash: 5685821,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(PropertyCastEntityData, int_value),
            },
            FieldInfoData {
                name: "UintValue",
                name_hash: 4018260200,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(PropertyCastEntityData, uint_value),
            },
            FieldInfoData {
                name: "StringValue",
                name_hash: 1269878171,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(PropertyCastEntityData, string_value),
            },
        ],
    }),
    array_type: Some(PROPERTYCASTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PropertyCastEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PROPERTYCASTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PROPERTYCASTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PropertyCastEntityData-Array",
    name_hash: 1528852952,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("PropertyCastEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct BoolToEventEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub value: bool,
    pub inital_event: bool,
}

pub trait BoolToEventEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn value(&self) -> &bool;
    fn value_mut(&mut self) -> &mut bool;
    fn inital_event(&self) -> &bool;
    fn inital_event_mut(&mut self) -> &mut bool;
}

impl BoolToEventEntityDataTrait for BoolToEventEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn value(&self) -> &bool {
        &self.value
    }
    fn value_mut(&mut self) -> &mut bool {
        &mut self.value
    }
    fn inital_event(&self) -> &bool {
        &self.inital_event
    }
    fn inital_event_mut(&mut self) -> &mut bool {
        &mut self.inital_event
    }
}

impl EntityDataTrait for BoolToEventEntityData {
}

impl GameObjectDataTrait for BoolToEventEntityData {
}

impl super::core::DataBusPeerTrait for BoolToEventEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for BoolToEventEntityData {
}

impl super::core::DataContainerTrait for BoolToEventEntityData {
}

pub static BOOLTOEVENTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolToEventEntityData",
    name_hash: 1289509079,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(BoolToEventEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BoolToEventEntityData as Default>::default())),
            create_boxed: || Box::new(<BoolToEventEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(BoolToEventEntityData, realm),
            },
            FieldInfoData {
                name: "Value",
                name_hash: 225375086,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BoolToEventEntityData, value),
            },
            FieldInfoData {
                name: "InitalEvent",
                name_hash: 3855319582,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BoolToEventEntityData, inital_event),
            },
        ],
    }),
    array_type: Some(BOOLTOEVENTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BoolToEventEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        BOOLTOEVENTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BOOLTOEVENTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolToEventEntityData-Array",
    name_hash: 3834647011,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("BoolToEventEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SwitchPropertyStringEntityData {
    pub _glacier_base: EntityData,
    pub string_properties: Vec<String>,
    pub realm: super::core::Realm,
}

pub trait SwitchPropertyStringEntityDataTrait: EntityDataTrait {
    fn string_properties(&self) -> &Vec<String>;
    fn string_properties_mut(&mut self) -> &mut Vec<String>;
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
}

impl SwitchPropertyStringEntityDataTrait for SwitchPropertyStringEntityData {
    fn string_properties(&self) -> &Vec<String> {
        &self.string_properties
    }
    fn string_properties_mut(&mut self) -> &mut Vec<String> {
        &mut self.string_properties
    }
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
}

impl EntityDataTrait for SwitchPropertyStringEntityData {
}

impl GameObjectDataTrait for SwitchPropertyStringEntityData {
}

impl super::core::DataBusPeerTrait for SwitchPropertyStringEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SwitchPropertyStringEntityData {
}

impl super::core::DataContainerTrait for SwitchPropertyStringEntityData {
}

pub static SWITCHPROPERTYSTRINGENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SwitchPropertyStringEntityData",
    name_hash: 3264337230,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(SwitchPropertyStringEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SwitchPropertyStringEntityData as Default>::default())),
            create_boxed: || Box::new(<SwitchPropertyStringEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "StringProperties",
                name_hash: 1548227025,
                flags: MemberInfoFlags::new(144),
                field_type: "CString-Array",
                rust_offset: offset_of!(SwitchPropertyStringEntityData, string_properties),
            },
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(SwitchPropertyStringEntityData, realm),
            },
        ],
    }),
    array_type: Some(SWITCHPROPERTYSTRINGENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SwitchPropertyStringEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SWITCHPROPERTYSTRINGENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SWITCHPROPERTYSTRINGENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SwitchPropertyStringEntityData-Array",
    name_hash: 2311515898,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SwitchPropertyStringEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct PropertyGateEntityData {
    pub _glacier_base: EntityData,
    pub default: bool,
    pub write_property_on_open_gate: bool,
    pub realm: super::core::Realm,
    pub bool_in: bool,
    pub int_in: i32,
    pub float_in: f32,
    pub vec3_in: super::core::Vec3,
    pub vec4_in: super::core::Vec4,
    pub transform_in: super::core::LinearTransform,
}

pub trait PropertyGateEntityDataTrait: EntityDataTrait {
    fn default(&self) -> &bool;
    fn default_mut(&mut self) -> &mut bool;
    fn write_property_on_open_gate(&self) -> &bool;
    fn write_property_on_open_gate_mut(&mut self) -> &mut bool;
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn bool_in(&self) -> &bool;
    fn bool_in_mut(&mut self) -> &mut bool;
    fn int_in(&self) -> &i32;
    fn int_in_mut(&mut self) -> &mut i32;
    fn float_in(&self) -> &f32;
    fn float_in_mut(&mut self) -> &mut f32;
    fn vec3_in(&self) -> &super::core::Vec3;
    fn vec3_in_mut(&mut self) -> &mut super::core::Vec3;
    fn vec4_in(&self) -> &super::core::Vec4;
    fn vec4_in_mut(&mut self) -> &mut super::core::Vec4;
    fn transform_in(&self) -> &super::core::LinearTransform;
    fn transform_in_mut(&mut self) -> &mut super::core::LinearTransform;
}

impl PropertyGateEntityDataTrait for PropertyGateEntityData {
    fn default(&self) -> &bool {
        &self.default
    }
    fn default_mut(&mut self) -> &mut bool {
        &mut self.default
    }
    fn write_property_on_open_gate(&self) -> &bool {
        &self.write_property_on_open_gate
    }
    fn write_property_on_open_gate_mut(&mut self) -> &mut bool {
        &mut self.write_property_on_open_gate
    }
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn bool_in(&self) -> &bool {
        &self.bool_in
    }
    fn bool_in_mut(&mut self) -> &mut bool {
        &mut self.bool_in
    }
    fn int_in(&self) -> &i32 {
        &self.int_in
    }
    fn int_in_mut(&mut self) -> &mut i32 {
        &mut self.int_in
    }
    fn float_in(&self) -> &f32 {
        &self.float_in
    }
    fn float_in_mut(&mut self) -> &mut f32 {
        &mut self.float_in
    }
    fn vec3_in(&self) -> &super::core::Vec3 {
        &self.vec3_in
    }
    fn vec3_in_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.vec3_in
    }
    fn vec4_in(&self) -> &super::core::Vec4 {
        &self.vec4_in
    }
    fn vec4_in_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.vec4_in
    }
    fn transform_in(&self) -> &super::core::LinearTransform {
        &self.transform_in
    }
    fn transform_in_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.transform_in
    }
}

impl EntityDataTrait for PropertyGateEntityData {
}

impl GameObjectDataTrait for PropertyGateEntityData {
}

impl super::core::DataBusPeerTrait for PropertyGateEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PropertyGateEntityData {
}

impl super::core::DataContainerTrait for PropertyGateEntityData {
}

pub static PROPERTYGATEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PropertyGateEntityData",
    name_hash: 2378943582,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(PropertyGateEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PropertyGateEntityData as Default>::default())),
            create_boxed: || Box::new(<PropertyGateEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Default",
                name_hash: 3998752238,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PropertyGateEntityData, default),
            },
            FieldInfoData {
                name: "WritePropertyOnOpenGate",
                name_hash: 3761162877,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PropertyGateEntityData, write_property_on_open_gate),
            },
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(PropertyGateEntityData, realm),
            },
            FieldInfoData {
                name: "BoolIn",
                name_hash: 2679383756,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PropertyGateEntityData, bool_in),
            },
            FieldInfoData {
                name: "IntIn",
                name_hash: 214528497,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(PropertyGateEntityData, int_in),
            },
            FieldInfoData {
                name: "FloatIn",
                name_hash: 2134484562,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PropertyGateEntityData, float_in),
            },
            FieldInfoData {
                name: "Vec3In",
                name_hash: 3146686209,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(PropertyGateEntityData, vec3_in),
            },
            FieldInfoData {
                name: "Vec4In",
                name_hash: 3146684934,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(PropertyGateEntityData, vec4_in),
            },
            FieldInfoData {
                name: "TransformIn",
                name_hash: 2771982766,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(PropertyGateEntityData, transform_in),
            },
        ],
    }),
    array_type: Some(PROPERTYGATEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PropertyGateEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PROPERTYGATEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PROPERTYGATEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PropertyGateEntityData-Array",
    name_hash: 1542516202,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("PropertyGateEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct EventGateEntityData {
    pub _glacier_base: EntityData,
    pub default: bool,
    pub realm: super::core::Realm,
}

pub trait EventGateEntityDataTrait: EntityDataTrait {
    fn default(&self) -> &bool;
    fn default_mut(&mut self) -> &mut bool;
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
}

impl EventGateEntityDataTrait for EventGateEntityData {
    fn default(&self) -> &bool {
        &self.default
    }
    fn default_mut(&mut self) -> &mut bool {
        &mut self.default
    }
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
}

impl EntityDataTrait for EventGateEntityData {
}

impl GameObjectDataTrait for EventGateEntityData {
}

impl super::core::DataBusPeerTrait for EventGateEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for EventGateEntityData {
}

impl super::core::DataContainerTrait for EventGateEntityData {
}

pub static EVENTGATEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventGateEntityData",
    name_hash: 26719573,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(EventGateEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EventGateEntityData as Default>::default())),
            create_boxed: || Box::new(<EventGateEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Default",
                name_hash: 3998752238,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EventGateEntityData, default),
            },
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(EventGateEntityData, realm),
            },
        ],
    }),
    array_type: Some(EVENTGATEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EventGateEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        EVENTGATEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EVENTGATEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventGateEntityData-Array",
    name_hash: 3402798433,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EventGateEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct StopWatchEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub update_pass: UpdatePass,
    pub multiplier: f32,
    pub trigger_on_time: f32,
    pub use_real_delta_time: bool,
}

pub trait StopWatchEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn update_pass(&self) -> &UpdatePass;
    fn update_pass_mut(&mut self) -> &mut UpdatePass;
    fn multiplier(&self) -> &f32;
    fn multiplier_mut(&mut self) -> &mut f32;
    fn trigger_on_time(&self) -> &f32;
    fn trigger_on_time_mut(&mut self) -> &mut f32;
    fn use_real_delta_time(&self) -> &bool;
    fn use_real_delta_time_mut(&mut self) -> &mut bool;
}

impl StopWatchEntityDataTrait for StopWatchEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn update_pass(&self) -> &UpdatePass {
        &self.update_pass
    }
    fn update_pass_mut(&mut self) -> &mut UpdatePass {
        &mut self.update_pass
    }
    fn multiplier(&self) -> &f32 {
        &self.multiplier
    }
    fn multiplier_mut(&mut self) -> &mut f32 {
        &mut self.multiplier
    }
    fn trigger_on_time(&self) -> &f32 {
        &self.trigger_on_time
    }
    fn trigger_on_time_mut(&mut self) -> &mut f32 {
        &mut self.trigger_on_time
    }
    fn use_real_delta_time(&self) -> &bool {
        &self.use_real_delta_time
    }
    fn use_real_delta_time_mut(&mut self) -> &mut bool {
        &mut self.use_real_delta_time
    }
}

impl EntityDataTrait for StopWatchEntityData {
}

impl GameObjectDataTrait for StopWatchEntityData {
}

impl super::core::DataBusPeerTrait for StopWatchEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for StopWatchEntityData {
}

impl super::core::DataContainerTrait for StopWatchEntityData {
}

pub static STOPWATCHENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StopWatchEntityData",
    name_hash: 4127089151,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(StopWatchEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StopWatchEntityData as Default>::default())),
            create_boxed: || Box::new(<StopWatchEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(StopWatchEntityData, realm),
            },
            FieldInfoData {
                name: "UpdatePass",
                name_hash: 2270785669,
                flags: MemberInfoFlags::new(0),
                field_type: "UpdatePass",
                rust_offset: offset_of!(StopWatchEntityData, update_pass),
            },
            FieldInfoData {
                name: "Multiplier",
                name_hash: 2037512782,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StopWatchEntityData, multiplier),
            },
            FieldInfoData {
                name: "TriggerOnTime",
                name_hash: 2068878889,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StopWatchEntityData, trigger_on_time),
            },
            FieldInfoData {
                name: "UseRealDeltaTime",
                name_hash: 1976456113,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(StopWatchEntityData, use_real_delta_time),
            },
        ],
    }),
    array_type: Some(STOPWATCHENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for StopWatchEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        STOPWATCHENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static STOPWATCHENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StopWatchEntityData-Array",
    name_hash: 2878621643,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("StopWatchEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TransformToRotationEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub r#in: super::core::LinearTransform,
    pub degrees: bool,
}

pub trait TransformToRotationEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn r#in(&self) -> &super::core::LinearTransform;
    fn r#in_mut(&mut self) -> &mut super::core::LinearTransform;
    fn degrees(&self) -> &bool;
    fn degrees_mut(&mut self) -> &mut bool;
}

impl TransformToRotationEntityDataTrait for TransformToRotationEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn r#in(&self) -> &super::core::LinearTransform {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.r#in
    }
    fn degrees(&self) -> &bool {
        &self.degrees
    }
    fn degrees_mut(&mut self) -> &mut bool {
        &mut self.degrees
    }
}

impl EntityDataTrait for TransformToRotationEntityData {
}

impl GameObjectDataTrait for TransformToRotationEntityData {
}

impl super::core::DataBusPeerTrait for TransformToRotationEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TransformToRotationEntityData {
}

impl super::core::DataContainerTrait for TransformToRotationEntityData {
}

pub static TRANSFORMTOROTATIONENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformToRotationEntityData",
    name_hash: 3836313517,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(TransformToRotationEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformToRotationEntityData as Default>::default())),
            create_boxed: || Box::new(<TransformToRotationEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(TransformToRotationEntityData, realm),
            },
            FieldInfoData {
                name: "In",
                name_hash: 5862146,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(TransformToRotationEntityData, r#in),
            },
            FieldInfoData {
                name: "Degrees",
                name_hash: 3998015778,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TransformToRotationEntityData, degrees),
            },
        ],
    }),
    array_type: Some(TRANSFORMTOROTATIONENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for TransformToRotationEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMTOROTATIONENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TRANSFORMTOROTATIONENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformToRotationEntityData-Array",
    name_hash: 1350530073,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TransformToRotationEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TransformModifierEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub r#in: super::core::LinearTransform,
    pub left: ModifierAxis,
    pub up: ModifierAxis,
    pub forward: ModifierAxis,
    pub invert_full_transform: bool,
    pub invert_left: bool,
    pub invert_up: bool,
    pub invert_forward: bool,
    pub invert_translation: bool,
}

pub trait TransformModifierEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn r#in(&self) -> &super::core::LinearTransform;
    fn r#in_mut(&mut self) -> &mut super::core::LinearTransform;
    fn left(&self) -> &ModifierAxis;
    fn left_mut(&mut self) -> &mut ModifierAxis;
    fn up(&self) -> &ModifierAxis;
    fn up_mut(&mut self) -> &mut ModifierAxis;
    fn forward(&self) -> &ModifierAxis;
    fn forward_mut(&mut self) -> &mut ModifierAxis;
    fn invert_full_transform(&self) -> &bool;
    fn invert_full_transform_mut(&mut self) -> &mut bool;
    fn invert_left(&self) -> &bool;
    fn invert_left_mut(&mut self) -> &mut bool;
    fn invert_up(&self) -> &bool;
    fn invert_up_mut(&mut self) -> &mut bool;
    fn invert_forward(&self) -> &bool;
    fn invert_forward_mut(&mut self) -> &mut bool;
    fn invert_translation(&self) -> &bool;
    fn invert_translation_mut(&mut self) -> &mut bool;
}

impl TransformModifierEntityDataTrait for TransformModifierEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn r#in(&self) -> &super::core::LinearTransform {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.r#in
    }
    fn left(&self) -> &ModifierAxis {
        &self.left
    }
    fn left_mut(&mut self) -> &mut ModifierAxis {
        &mut self.left
    }
    fn up(&self) -> &ModifierAxis {
        &self.up
    }
    fn up_mut(&mut self) -> &mut ModifierAxis {
        &mut self.up
    }
    fn forward(&self) -> &ModifierAxis {
        &self.forward
    }
    fn forward_mut(&mut self) -> &mut ModifierAxis {
        &mut self.forward
    }
    fn invert_full_transform(&self) -> &bool {
        &self.invert_full_transform
    }
    fn invert_full_transform_mut(&mut self) -> &mut bool {
        &mut self.invert_full_transform
    }
    fn invert_left(&self) -> &bool {
        &self.invert_left
    }
    fn invert_left_mut(&mut self) -> &mut bool {
        &mut self.invert_left
    }
    fn invert_up(&self) -> &bool {
        &self.invert_up
    }
    fn invert_up_mut(&mut self) -> &mut bool {
        &mut self.invert_up
    }
    fn invert_forward(&self) -> &bool {
        &self.invert_forward
    }
    fn invert_forward_mut(&mut self) -> &mut bool {
        &mut self.invert_forward
    }
    fn invert_translation(&self) -> &bool {
        &self.invert_translation
    }
    fn invert_translation_mut(&mut self) -> &mut bool {
        &mut self.invert_translation
    }
}

impl EntityDataTrait for TransformModifierEntityData {
}

impl GameObjectDataTrait for TransformModifierEntityData {
}

impl super::core::DataBusPeerTrait for TransformModifierEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TransformModifierEntityData {
}

impl super::core::DataContainerTrait for TransformModifierEntityData {
}

pub static TRANSFORMMODIFIERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformModifierEntityData",
    name_hash: 2103929461,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(TransformModifierEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformModifierEntityData as Default>::default())),
            create_boxed: || Box::new(<TransformModifierEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(TransformModifierEntityData, realm),
            },
            FieldInfoData {
                name: "In",
                name_hash: 5862146,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(TransformModifierEntityData, r#in),
            },
            FieldInfoData {
                name: "Left",
                name_hash: 2089021886,
                flags: MemberInfoFlags::new(0),
                field_type: "ModifierAxis",
                rust_offset: offset_of!(TransformModifierEntityData, left),
            },
            FieldInfoData {
                name: "Up",
                name_hash: 5862272,
                flags: MemberInfoFlags::new(0),
                field_type: "ModifierAxis",
                rust_offset: offset_of!(TransformModifierEntityData, up),
            },
            FieldInfoData {
                name: "Forward",
                name_hash: 1986470206,
                flags: MemberInfoFlags::new(0),
                field_type: "ModifierAxis",
                rust_offset: offset_of!(TransformModifierEntityData, forward),
            },
            FieldInfoData {
                name: "InvertFullTransform",
                name_hash: 3821268456,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TransformModifierEntityData, invert_full_transform),
            },
            FieldInfoData {
                name: "InvertLeft",
                name_hash: 3753810092,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TransformModifierEntityData, invert_left),
            },
            FieldInfoData {
                name: "InvertUp",
                name_hash: 58661394,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TransformModifierEntityData, invert_up),
            },
            FieldInfoData {
                name: "InvertForward",
                name_hash: 3827158252,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TransformModifierEntityData, invert_forward),
            },
            FieldInfoData {
                name: "InvertTranslation",
                name_hash: 2875527196,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TransformModifierEntityData, invert_translation),
            },
        ],
    }),
    array_type: Some(TRANSFORMMODIFIERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for TransformModifierEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMMODIFIERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TRANSFORMMODIFIERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformModifierEntityData-Array",
    name_hash: 3499498305,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TransformModifierEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum ModifierAxis {
    #[default]
    maLeft = 0,
    maUp = 1,
    maForward = 2,
}

pub static MODIFIERAXIS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ModifierAxis",
    name_hash: 2116120913,
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(MODIFIERAXIS_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for ModifierAxis {
    fn type_info(&self) -> &'static TypeInfo {
        MODIFIERAXIS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MODIFIERAXIS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ModifierAxis-Array",
    name_hash: 1836688229,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ModifierAxis"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct RotationTransformBuilderEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub rotation: super::core::Vec3,
}

pub trait RotationTransformBuilderEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn rotation(&self) -> &super::core::Vec3;
    fn rotation_mut(&mut self) -> &mut super::core::Vec3;
}

impl RotationTransformBuilderEntityDataTrait for RotationTransformBuilderEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn rotation(&self) -> &super::core::Vec3 {
        &self.rotation
    }
    fn rotation_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.rotation
    }
}

impl EntityDataTrait for RotationTransformBuilderEntityData {
}

impl GameObjectDataTrait for RotationTransformBuilderEntityData {
}

impl super::core::DataBusPeerTrait for RotationTransformBuilderEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for RotationTransformBuilderEntityData {
}

impl super::core::DataContainerTrait for RotationTransformBuilderEntityData {
}

pub static ROTATIONTRANSFORMBUILDERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RotationTransformBuilderEntityData",
    name_hash: 3705661111,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(RotationTransformBuilderEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RotationTransformBuilderEntityData as Default>::default())),
            create_boxed: || Box::new(<RotationTransformBuilderEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(RotationTransformBuilderEntityData, realm),
            },
            FieldInfoData {
                name: "Rotation",
                name_hash: 48673745,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(RotationTransformBuilderEntityData, rotation),
            },
        ],
    }),
    array_type: Some(ROTATIONTRANSFORMBUILDERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for RotationTransformBuilderEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        ROTATIONTRANSFORMBUILDERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ROTATIONTRANSFORMBUILDERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RotationTransformBuilderEntityData-Array",
    name_hash: 4008902659,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("RotationTransformBuilderEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ScaleTransformBuilderEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub scale: super::core::Vec3,
}

pub trait ScaleTransformBuilderEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn scale(&self) -> &super::core::Vec3;
    fn scale_mut(&mut self) -> &mut super::core::Vec3;
}

impl ScaleTransformBuilderEntityDataTrait for ScaleTransformBuilderEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn scale(&self) -> &super::core::Vec3 {
        &self.scale
    }
    fn scale_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.scale
    }
}

impl EntityDataTrait for ScaleTransformBuilderEntityData {
}

impl GameObjectDataTrait for ScaleTransformBuilderEntityData {
}

impl super::core::DataBusPeerTrait for ScaleTransformBuilderEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ScaleTransformBuilderEntityData {
}

impl super::core::DataContainerTrait for ScaleTransformBuilderEntityData {
}

pub static SCALETRANSFORMBUILDERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScaleTransformBuilderEntityData",
    name_hash: 1097626235,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(ScaleTransformBuilderEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ScaleTransformBuilderEntityData as Default>::default())),
            create_boxed: || Box::new(<ScaleTransformBuilderEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(ScaleTransformBuilderEntityData, realm),
            },
            FieldInfoData {
                name: "Scale",
                name_hash: 231223453,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(ScaleTransformBuilderEntityData, scale),
            },
        ],
    }),
    array_type: Some(SCALETRANSFORMBUILDERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ScaleTransformBuilderEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SCALETRANSFORMBUILDERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SCALETRANSFORMBUILDERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScaleTransformBuilderEntityData-Array",
    name_hash: 1361906255,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ScaleTransformBuilderEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TransformBuilderEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub ortho_normal_mode: OrthoNormalMode,
    pub left: super::core::Vec3,
    pub up: super::core::Vec3,
    pub forward: super::core::Vec3,
    pub trans: super::core::Vec3,
    pub is_world_space: bool,
}

pub trait TransformBuilderEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn ortho_normal_mode(&self) -> &OrthoNormalMode;
    fn ortho_normal_mode_mut(&mut self) -> &mut OrthoNormalMode;
    fn left(&self) -> &super::core::Vec3;
    fn left_mut(&mut self) -> &mut super::core::Vec3;
    fn up(&self) -> &super::core::Vec3;
    fn up_mut(&mut self) -> &mut super::core::Vec3;
    fn forward(&self) -> &super::core::Vec3;
    fn forward_mut(&mut self) -> &mut super::core::Vec3;
    fn trans(&self) -> &super::core::Vec3;
    fn trans_mut(&mut self) -> &mut super::core::Vec3;
    fn is_world_space(&self) -> &bool;
    fn is_world_space_mut(&mut self) -> &mut bool;
}

impl TransformBuilderEntityDataTrait for TransformBuilderEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn ortho_normal_mode(&self) -> &OrthoNormalMode {
        &self.ortho_normal_mode
    }
    fn ortho_normal_mode_mut(&mut self) -> &mut OrthoNormalMode {
        &mut self.ortho_normal_mode
    }
    fn left(&self) -> &super::core::Vec3 {
        &self.left
    }
    fn left_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.left
    }
    fn up(&self) -> &super::core::Vec3 {
        &self.up
    }
    fn up_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.up
    }
    fn forward(&self) -> &super::core::Vec3 {
        &self.forward
    }
    fn forward_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.forward
    }
    fn trans(&self) -> &super::core::Vec3 {
        &self.trans
    }
    fn trans_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.trans
    }
    fn is_world_space(&self) -> &bool {
        &self.is_world_space
    }
    fn is_world_space_mut(&mut self) -> &mut bool {
        &mut self.is_world_space
    }
}

impl EntityDataTrait for TransformBuilderEntityData {
}

impl GameObjectDataTrait for TransformBuilderEntityData {
}

impl super::core::DataBusPeerTrait for TransformBuilderEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TransformBuilderEntityData {
}

impl super::core::DataContainerTrait for TransformBuilderEntityData {
}

pub static TRANSFORMBUILDERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformBuilderEntityData",
    name_hash: 3544914659,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(TransformBuilderEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformBuilderEntityData as Default>::default())),
            create_boxed: || Box::new(<TransformBuilderEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(TransformBuilderEntityData, realm),
            },
            FieldInfoData {
                name: "OrthoNormalMode",
                name_hash: 4024835899,
                flags: MemberInfoFlags::new(0),
                field_type: "OrthoNormalMode",
                rust_offset: offset_of!(TransformBuilderEntityData, ortho_normal_mode),
            },
            FieldInfoData {
                name: "Left",
                name_hash: 2089021886,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(TransformBuilderEntityData, left),
            },
            FieldInfoData {
                name: "Up",
                name_hash: 5862272,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(TransformBuilderEntityData, up),
            },
            FieldInfoData {
                name: "Forward",
                name_hash: 1986470206,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(TransformBuilderEntityData, forward),
            },
            FieldInfoData {
                name: "Trans",
                name_hash: 227190399,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(TransformBuilderEntityData, trans),
            },
            FieldInfoData {
                name: "IsWorldSpace",
                name_hash: 2732047897,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TransformBuilderEntityData, is_world_space),
            },
        ],
    }),
    array_type: Some(TRANSFORMBUILDERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for TransformBuilderEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMBUILDERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TRANSFORMBUILDERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformBuilderEntityData-Array",
    name_hash: 4101369559,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TransformBuilderEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum OrthoNormalMode {
    #[default]
    OrthoNormalMode_LeftHanded = 0,
    OrthoNormalMode_RightHanded = 1,
    OrthoNormalMode_None = 2,
}

pub static ORTHONORMALMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OrthoNormalMode",
    name_hash: 4024835899,
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(ORTHONORMALMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for OrthoNormalMode {
    fn type_info(&self) -> &'static TypeInfo {
        ORTHONORMALMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ORTHONORMALMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OrthoNormalMode-Array",
    name_hash: 169952911,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("OrthoNormalMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct VecBuilderEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}

pub trait VecBuilderEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn x(&self) -> &f32;
    fn x_mut(&mut self) -> &mut f32;
    fn y(&self) -> &f32;
    fn y_mut(&mut self) -> &mut f32;
    fn z(&self) -> &f32;
    fn z_mut(&mut self) -> &mut f32;
    fn w(&self) -> &f32;
    fn w_mut(&mut self) -> &mut f32;
}

impl VecBuilderEntityDataTrait for VecBuilderEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn x(&self) -> &f32 {
        &self.x
    }
    fn x_mut(&mut self) -> &mut f32 {
        &mut self.x
    }
    fn y(&self) -> &f32 {
        &self.y
    }
    fn y_mut(&mut self) -> &mut f32 {
        &mut self.y
    }
    fn z(&self) -> &f32 {
        &self.z
    }
    fn z_mut(&mut self) -> &mut f32 {
        &mut self.z
    }
    fn w(&self) -> &f32 {
        &self.w
    }
    fn w_mut(&mut self) -> &mut f32 {
        &mut self.w
    }
}

impl EntityDataTrait for VecBuilderEntityData {
}

impl GameObjectDataTrait for VecBuilderEntityData {
}

impl super::core::DataBusPeerTrait for VecBuilderEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for VecBuilderEntityData {
}

impl super::core::DataContainerTrait for VecBuilderEntityData {
}

pub static VECBUILDERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VecBuilderEntityData",
    name_hash: 3530996639,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(VecBuilderEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VecBuilderEntityData as Default>::default())),
            create_boxed: || Box::new(<VecBuilderEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(VecBuilderEntityData, realm),
            },
            FieldInfoData {
                name: "X",
                name_hash: 177661,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VecBuilderEntityData, x),
            },
            FieldInfoData {
                name: "Y",
                name_hash: 177660,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VecBuilderEntityData, y),
            },
            FieldInfoData {
                name: "Z",
                name_hash: 177663,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VecBuilderEntityData, z),
            },
            FieldInfoData {
                name: "W",
                name_hash: 177650,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VecBuilderEntityData, w),
            },
        ],
    }),
    array_type: Some(VECBUILDERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VecBuilderEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VECBUILDERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VECBUILDERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VecBuilderEntityData-Array",
    name_hash: 2288590891,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("VecBuilderEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct Vec4BuilderEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
}

pub trait Vec4BuilderEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
}

impl Vec4BuilderEntityDataTrait for Vec4BuilderEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
}

impl EntityDataTrait for Vec4BuilderEntityData {
}

impl GameObjectDataTrait for Vec4BuilderEntityData {
}

impl super::core::DataBusPeerTrait for Vec4BuilderEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for Vec4BuilderEntityData {
}

impl super::core::DataContainerTrait for Vec4BuilderEntityData {
}

pub static VEC4BUILDERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec4BuilderEntityData",
    name_hash: 727769995,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(Vec4BuilderEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec4BuilderEntityData as Default>::default())),
            create_boxed: || Box::new(<Vec4BuilderEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(Vec4BuilderEntityData, realm),
            },
        ],
    }),
    array_type: Some(VEC4BUILDERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for Vec4BuilderEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VEC4BUILDERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEC4BUILDERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec4BuilderEntityData-Array",
    name_hash: 2441007679,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec4BuilderEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct Vec3BuilderEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
}

pub trait Vec3BuilderEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
}

impl Vec3BuilderEntityDataTrait for Vec3BuilderEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
}

impl EntityDataTrait for Vec3BuilderEntityData {
}

impl GameObjectDataTrait for Vec3BuilderEntityData {
}

impl super::core::DataBusPeerTrait for Vec3BuilderEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for Vec3BuilderEntityData {
}

impl super::core::DataContainerTrait for Vec3BuilderEntityData {
}

pub static VEC3BUILDERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3BuilderEntityData",
    name_hash: 3178036076,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(Vec3BuilderEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec3BuilderEntityData as Default>::default())),
            create_boxed: || Box::new(<Vec3BuilderEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(Vec3BuilderEntityData, realm),
            },
        ],
    }),
    array_type: Some(VEC3BUILDERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for Vec3BuilderEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VEC3BUILDERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEC3BUILDERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3BuilderEntityData-Array",
    name_hash: 2294643544,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec3BuilderEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct Vec2BuilderEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
}

pub trait Vec2BuilderEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
}

impl Vec2BuilderEntityDataTrait for Vec2BuilderEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
}

impl EntityDataTrait for Vec2BuilderEntityData {
}

impl GameObjectDataTrait for Vec2BuilderEntityData {
}

impl super::core::DataBusPeerTrait for Vec2BuilderEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for Vec2BuilderEntityData {
}

impl super::core::DataContainerTrait for Vec2BuilderEntityData {
}

pub static VEC2BUILDERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec2BuilderEntityData",
    name_hash: 1097069005,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(Vec2BuilderEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec2BuilderEntityData as Default>::default())),
            create_boxed: || Box::new(<Vec2BuilderEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(Vec2BuilderEntityData, realm),
            },
        ],
    }),
    array_type: Some(VEC2BUILDERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for Vec2BuilderEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VEC2BUILDERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEC2BUILDERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec2BuilderEntityData-Array",
    name_hash: 1239860729,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec2BuilderEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct VecSplitterEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub vec2: super::core::Vec2,
    pub vec3: super::core::Vec3,
    pub vec4: super::core::Vec4,
}

pub trait VecSplitterEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn vec2(&self) -> &super::core::Vec2;
    fn vec2_mut(&mut self) -> &mut super::core::Vec2;
    fn vec3(&self) -> &super::core::Vec3;
    fn vec3_mut(&mut self) -> &mut super::core::Vec3;
    fn vec4(&self) -> &super::core::Vec4;
    fn vec4_mut(&mut self) -> &mut super::core::Vec4;
}

impl VecSplitterEntityDataTrait for VecSplitterEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn vec2(&self) -> &super::core::Vec2 {
        &self.vec2
    }
    fn vec2_mut(&mut self) -> &mut super::core::Vec2 {
        &mut self.vec2
    }
    fn vec3(&self) -> &super::core::Vec3 {
        &self.vec3
    }
    fn vec3_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.vec3
    }
    fn vec4(&self) -> &super::core::Vec4 {
        &self.vec4
    }
    fn vec4_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.vec4
    }
}

impl EntityDataTrait for VecSplitterEntityData {
}

impl GameObjectDataTrait for VecSplitterEntityData {
}

impl super::core::DataBusPeerTrait for VecSplitterEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for VecSplitterEntityData {
}

impl super::core::DataContainerTrait for VecSplitterEntityData {
}

pub static VECSPLITTERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VecSplitterEntityData",
    name_hash: 1960204111,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(VecSplitterEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VecSplitterEntityData as Default>::default())),
            create_boxed: || Box::new(<VecSplitterEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(VecSplitterEntityData, realm),
            },
            FieldInfoData {
                name: "Vec2",
                name_hash: 2089241863,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(VecSplitterEntityData, vec2),
            },
            FieldInfoData {
                name: "Vec3",
                name_hash: 2089241862,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(VecSplitterEntityData, vec3),
            },
            FieldInfoData {
                name: "Vec4",
                name_hash: 2089241857,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(VecSplitterEntityData, vec4),
            },
        ],
    }),
    array_type: Some(VECSPLITTERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VecSplitterEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VECSPLITTERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VECSPLITTERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VecSplitterEntityData-Array",
    name_hash: 2610660475,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("VecSplitterEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct Vec4SplitterEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
}

pub trait Vec4SplitterEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
}

impl Vec4SplitterEntityDataTrait for Vec4SplitterEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
}

impl EntityDataTrait for Vec4SplitterEntityData {
}

impl GameObjectDataTrait for Vec4SplitterEntityData {
}

impl super::core::DataBusPeerTrait for Vec4SplitterEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for Vec4SplitterEntityData {
}

impl super::core::DataContainerTrait for Vec4SplitterEntityData {
}

pub static VEC4SPLITTERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec4SplitterEntityData",
    name_hash: 3871666395,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(Vec4SplitterEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec4SplitterEntityData as Default>::default())),
            create_boxed: || Box::new(<Vec4SplitterEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(Vec4SplitterEntityData, realm),
            },
        ],
    }),
    array_type: Some(VEC4SPLITTERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for Vec4SplitterEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VEC4SPLITTERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEC4SPLITTERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec4SplitterEntityData-Array",
    name_hash: 30037999,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec4SplitterEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct Vec3SplitterEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
}

pub trait Vec3SplitterEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
}

impl Vec3SplitterEntityDataTrait for Vec3SplitterEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
}

impl EntityDataTrait for Vec3SplitterEntityData {
}

impl GameObjectDataTrait for Vec3SplitterEntityData {
}

impl super::core::DataBusPeerTrait for Vec3SplitterEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for Vec3SplitterEntityData {
}

impl super::core::DataContainerTrait for Vec3SplitterEntityData {
}

pub static VEC3SPLITTERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3SplitterEntityData",
    name_hash: 2454167900,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(Vec3SplitterEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec3SplitterEntityData as Default>::default())),
            create_boxed: || Box::new(<Vec3SplitterEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(Vec3SplitterEntityData, realm),
            },
        ],
    }),
    array_type: Some(VEC3SPLITTERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for Vec3SplitterEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VEC3SPLITTERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEC3SPLITTERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3SplitterEntityData-Array",
    name_hash: 721422824,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec3SplitterEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct Vec2SplitterEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
}

pub trait Vec2SplitterEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
}

impl Vec2SplitterEntityDataTrait for Vec2SplitterEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
}

impl EntityDataTrait for Vec2SplitterEntityData {
}

impl GameObjectDataTrait for Vec2SplitterEntityData {
}

impl super::core::DataBusPeerTrait for Vec2SplitterEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for Vec2SplitterEntityData {
}

impl super::core::DataContainerTrait for Vec2SplitterEntityData {
}

pub static VEC2SPLITTERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec2SplitterEntityData",
    name_hash: 526976093,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(Vec2SplitterEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec2SplitterEntityData as Default>::default())),
            create_boxed: || Box::new(<Vec2SplitterEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(Vec2SplitterEntityData, realm),
            },
        ],
    }),
    array_type: Some(VEC2SPLITTERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for Vec2SplitterEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VEC2SPLITTERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEC2SPLITTERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec2SplitterEntityData-Array",
    name_hash: 3164766313,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec2SplitterEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct EulerTransformEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub rotation: f32,
    pub trans: super::core::Vec3,
    pub euler: ModifierEuler,
}

pub trait EulerTransformEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn rotation(&self) -> &f32;
    fn rotation_mut(&mut self) -> &mut f32;
    fn trans(&self) -> &super::core::Vec3;
    fn trans_mut(&mut self) -> &mut super::core::Vec3;
    fn euler(&self) -> &ModifierEuler;
    fn euler_mut(&mut self) -> &mut ModifierEuler;
}

impl EulerTransformEntityDataTrait for EulerTransformEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn rotation(&self) -> &f32 {
        &self.rotation
    }
    fn rotation_mut(&mut self) -> &mut f32 {
        &mut self.rotation
    }
    fn trans(&self) -> &super::core::Vec3 {
        &self.trans
    }
    fn trans_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.trans
    }
    fn euler(&self) -> &ModifierEuler {
        &self.euler
    }
    fn euler_mut(&mut self) -> &mut ModifierEuler {
        &mut self.euler
    }
}

impl EntityDataTrait for EulerTransformEntityData {
}

impl GameObjectDataTrait for EulerTransformEntityData {
}

impl super::core::DataBusPeerTrait for EulerTransformEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for EulerTransformEntityData {
}

impl super::core::DataContainerTrait for EulerTransformEntityData {
}

pub static EULERTRANSFORMENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EulerTransformEntityData",
    name_hash: 2128715977,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(EulerTransformEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EulerTransformEntityData as Default>::default())),
            create_boxed: || Box::new(<EulerTransformEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(EulerTransformEntityData, realm),
            },
            FieldInfoData {
                name: "Rotation",
                name_hash: 48673745,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EulerTransformEntityData, rotation),
            },
            FieldInfoData {
                name: "Trans",
                name_hash: 227190399,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(EulerTransformEntityData, trans),
            },
            FieldInfoData {
                name: "Euler",
                name_hash: 201462510,
                flags: MemberInfoFlags::new(0),
                field_type: "ModifierEuler",
                rust_offset: offset_of!(EulerTransformEntityData, euler),
            },
        ],
    }),
    array_type: Some(EULERTRANSFORMENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for EulerTransformEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        EULERTRANSFORMENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EULERTRANSFORMENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EulerTransformEntityData-Array",
    name_hash: 3748398845,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EulerTransformEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum ModifierEuler {
    #[default]
    Roll = 0,
    Pitch = 1,
    Yaw = 2,
    Trans = 3,
}

pub static MODIFIEREULER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ModifierEuler",
    name_hash: 1116601081,
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(MODIFIEREULER_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for ModifierEuler {
    fn type_info(&self) -> &'static TypeInfo {
        MODIFIEREULER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MODIFIEREULER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ModifierEuler-Array",
    name_hash: 3133585869,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ModifierEuler"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct EulerTransformSplitterEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub transform: super::core::LinearTransform,
}

pub trait EulerTransformSplitterEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn transform(&self) -> &super::core::LinearTransform;
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform;
}

impl EulerTransformSplitterEntityDataTrait for EulerTransformSplitterEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn transform(&self) -> &super::core::LinearTransform {
        &self.transform
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.transform
    }
}

impl EntityDataTrait for EulerTransformSplitterEntityData {
}

impl GameObjectDataTrait for EulerTransformSplitterEntityData {
}

impl super::core::DataBusPeerTrait for EulerTransformSplitterEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for EulerTransformSplitterEntityData {
}

impl super::core::DataContainerTrait for EulerTransformSplitterEntityData {
}

pub static EULERTRANSFORMSPLITTERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EulerTransformSplitterEntityData",
    name_hash: 3135852152,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(EulerTransformSplitterEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EulerTransformSplitterEntityData as Default>::default())),
            create_boxed: || Box::new(<EulerTransformSplitterEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(EulerTransformSplitterEntityData, realm),
            },
            FieldInfoData {
                name: "Transform",
                name_hash: 2270319721,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(EulerTransformSplitterEntityData, transform),
            },
        ],
    }),
    array_type: Some(EULERTRANSFORMSPLITTERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for EulerTransformSplitterEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        EULERTRANSFORMSPLITTERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EULERTRANSFORMSPLITTERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EulerTransformSplitterEntityData-Array",
    name_hash: 2202478668,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EulerTransformSplitterEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TransformSplitterEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub transform: super::core::LinearTransform,
}

pub trait TransformSplitterEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn transform(&self) -> &super::core::LinearTransform;
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform;
}

impl TransformSplitterEntityDataTrait for TransformSplitterEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn transform(&self) -> &super::core::LinearTransform {
        &self.transform
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.transform
    }
}

impl EntityDataTrait for TransformSplitterEntityData {
}

impl GameObjectDataTrait for TransformSplitterEntityData {
}

impl super::core::DataBusPeerTrait for TransformSplitterEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TransformSplitterEntityData {
}

impl super::core::DataContainerTrait for TransformSplitterEntityData {
}

pub static TRANSFORMSPLITTERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformSplitterEntityData",
    name_hash: 2530243187,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(TransformSplitterEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformSplitterEntityData as Default>::default())),
            create_boxed: || Box::new(<TransformSplitterEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(TransformSplitterEntityData, realm),
            },
            FieldInfoData {
                name: "Transform",
                name_hash: 2270319721,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(TransformSplitterEntityData, transform),
            },
        ],
    }),
    array_type: Some(TRANSFORMSPLITTERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for TransformSplitterEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMSPLITTERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TRANSFORMSPLITTERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformSplitterEntityData-Array",
    name_hash: 3742477895,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TransformSplitterEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TransformBlendEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub blend_value: f32,
    pub blend_value2: f32,
    pub in1: super::core::LinearTransform,
    pub in2: super::core::LinearTransform,
}

pub trait TransformBlendEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn blend_value(&self) -> &f32;
    fn blend_value_mut(&mut self) -> &mut f32;
    fn blend_value2(&self) -> &f32;
    fn blend_value2_mut(&mut self) -> &mut f32;
    fn in1(&self) -> &super::core::LinearTransform;
    fn in1_mut(&mut self) -> &mut super::core::LinearTransform;
    fn in2(&self) -> &super::core::LinearTransform;
    fn in2_mut(&mut self) -> &mut super::core::LinearTransform;
}

impl TransformBlendEntityDataTrait for TransformBlendEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn blend_value(&self) -> &f32 {
        &self.blend_value
    }
    fn blend_value_mut(&mut self) -> &mut f32 {
        &mut self.blend_value
    }
    fn blend_value2(&self) -> &f32 {
        &self.blend_value2
    }
    fn blend_value2_mut(&mut self) -> &mut f32 {
        &mut self.blend_value2
    }
    fn in1(&self) -> &super::core::LinearTransform {
        &self.in1
    }
    fn in1_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.in1
    }
    fn in2(&self) -> &super::core::LinearTransform {
        &self.in2
    }
    fn in2_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.in2
    }
}

impl EntityDataTrait for TransformBlendEntityData {
}

impl GameObjectDataTrait for TransformBlendEntityData {
}

impl super::core::DataBusPeerTrait for TransformBlendEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TransformBlendEntityData {
}

impl super::core::DataContainerTrait for TransformBlendEntityData {
}

pub static TRANSFORMBLENDENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformBlendEntityData",
    name_hash: 3481727075,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(TransformBlendEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformBlendEntityData as Default>::default())),
            create_boxed: || Box::new(<TransformBlendEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(TransformBlendEntityData, realm),
            },
            FieldInfoData {
                name: "BlendValue",
                name_hash: 236872047,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TransformBlendEntityData, blend_value),
            },
            FieldInfoData {
                name: "BlendValue2",
                name_hash: 3521810301,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TransformBlendEntityData, blend_value2),
            },
            FieldInfoData {
                name: "In1",
                name_hash: 193450867,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(TransformBlendEntityData, in1),
            },
            FieldInfoData {
                name: "In2",
                name_hash: 193450864,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(TransformBlendEntityData, in2),
            },
        ],
    }),
    array_type: Some(TRANSFORMBLENDENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for TransformBlendEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMBLENDENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TRANSFORMBLENDENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformBlendEntityData-Array",
    name_hash: 2728125527,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TransformBlendEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TransformMultiplierEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub in1: super::core::LinearTransform,
    pub in2: super::core::LinearTransform,
}

pub trait TransformMultiplierEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn in1(&self) -> &super::core::LinearTransform;
    fn in1_mut(&mut self) -> &mut super::core::LinearTransform;
    fn in2(&self) -> &super::core::LinearTransform;
    fn in2_mut(&mut self) -> &mut super::core::LinearTransform;
}

impl TransformMultiplierEntityDataTrait for TransformMultiplierEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn in1(&self) -> &super::core::LinearTransform {
        &self.in1
    }
    fn in1_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.in1
    }
    fn in2(&self) -> &super::core::LinearTransform {
        &self.in2
    }
    fn in2_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.in2
    }
}

impl EntityDataTrait for TransformMultiplierEntityData {
}

impl GameObjectDataTrait for TransformMultiplierEntityData {
}

impl super::core::DataBusPeerTrait for TransformMultiplierEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TransformMultiplierEntityData {
}

impl super::core::DataContainerTrait for TransformMultiplierEntityData {
}

pub static TRANSFORMMULTIPLIERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformMultiplierEntityData",
    name_hash: 2549661257,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(TransformMultiplierEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformMultiplierEntityData as Default>::default())),
            create_boxed: || Box::new(<TransformMultiplierEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(TransformMultiplierEntityData, realm),
            },
            FieldInfoData {
                name: "In1",
                name_hash: 193450867,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(TransformMultiplierEntityData, in1),
            },
            FieldInfoData {
                name: "In2",
                name_hash: 193450864,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(TransformMultiplierEntityData, in2),
            },
        ],
    }),
    array_type: Some(TRANSFORMMULTIPLIERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for TransformMultiplierEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMMULTIPLIERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TRANSFORMMULTIPLIERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformMultiplierEntityData-Array",
    name_hash: 63128701,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TransformMultiplierEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TransformHubEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub input_count: i32,
    pub input_select: i32,
    pub hashed_input: Vec<u32>,
}

pub trait TransformHubEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn input_count(&self) -> &i32;
    fn input_count_mut(&mut self) -> &mut i32;
    fn input_select(&self) -> &i32;
    fn input_select_mut(&mut self) -> &mut i32;
    fn hashed_input(&self) -> &Vec<u32>;
    fn hashed_input_mut(&mut self) -> &mut Vec<u32>;
}

impl TransformHubEntityDataTrait for TransformHubEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn input_count(&self) -> &i32 {
        &self.input_count
    }
    fn input_count_mut(&mut self) -> &mut i32 {
        &mut self.input_count
    }
    fn input_select(&self) -> &i32 {
        &self.input_select
    }
    fn input_select_mut(&mut self) -> &mut i32 {
        &mut self.input_select
    }
    fn hashed_input(&self) -> &Vec<u32> {
        &self.hashed_input
    }
    fn hashed_input_mut(&mut self) -> &mut Vec<u32> {
        &mut self.hashed_input
    }
}

impl EntityDataTrait for TransformHubEntityData {
}

impl GameObjectDataTrait for TransformHubEntityData {
}

impl super::core::DataBusPeerTrait for TransformHubEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TransformHubEntityData {
}

impl super::core::DataContainerTrait for TransformHubEntityData {
}

pub static TRANSFORMHUBENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformHubEntityData",
    name_hash: 2259450845,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(TransformHubEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformHubEntityData as Default>::default())),
            create_boxed: || Box::new(<TransformHubEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(TransformHubEntityData, realm),
            },
            FieldInfoData {
                name: "InputCount",
                name_hash: 1607263120,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(TransformHubEntityData, input_count),
            },
            FieldInfoData {
                name: "InputSelect",
                name_hash: 858290427,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(TransformHubEntityData, input_select),
            },
            FieldInfoData {
                name: "HashedInput",
                name_hash: 1165807872,
                flags: MemberInfoFlags::new(144),
                field_type: "Uint32-Array",
                rust_offset: offset_of!(TransformHubEntityData, hashed_input),
            },
        ],
    }),
    array_type: Some(TRANSFORMHUBENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TransformHubEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMHUBENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TRANSFORMHUBENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformHubEntityData-Array",
    name_hash: 427923433,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TransformHubEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct StringHubEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub input_count: i32,
    pub input_select: i32,
    pub hashed_input: Vec<u32>,
}

pub trait StringHubEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn input_count(&self) -> &i32;
    fn input_count_mut(&mut self) -> &mut i32;
    fn input_select(&self) -> &i32;
    fn input_select_mut(&mut self) -> &mut i32;
    fn hashed_input(&self) -> &Vec<u32>;
    fn hashed_input_mut(&mut self) -> &mut Vec<u32>;
}

impl StringHubEntityDataTrait for StringHubEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn input_count(&self) -> &i32 {
        &self.input_count
    }
    fn input_count_mut(&mut self) -> &mut i32 {
        &mut self.input_count
    }
    fn input_select(&self) -> &i32 {
        &self.input_select
    }
    fn input_select_mut(&mut self) -> &mut i32 {
        &mut self.input_select
    }
    fn hashed_input(&self) -> &Vec<u32> {
        &self.hashed_input
    }
    fn hashed_input_mut(&mut self) -> &mut Vec<u32> {
        &mut self.hashed_input
    }
}

impl EntityDataTrait for StringHubEntityData {
}

impl GameObjectDataTrait for StringHubEntityData {
}

impl super::core::DataBusPeerTrait for StringHubEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for StringHubEntityData {
}

impl super::core::DataContainerTrait for StringHubEntityData {
}

pub static STRINGHUBENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StringHubEntityData",
    name_hash: 161877252,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(StringHubEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StringHubEntityData as Default>::default())),
            create_boxed: || Box::new(<StringHubEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(StringHubEntityData, realm),
            },
            FieldInfoData {
                name: "InputCount",
                name_hash: 1607263120,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(StringHubEntityData, input_count),
            },
            FieldInfoData {
                name: "InputSelect",
                name_hash: 858290427,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(StringHubEntityData, input_select),
            },
            FieldInfoData {
                name: "HashedInput",
                name_hash: 1165807872,
                flags: MemberInfoFlags::new(144),
                field_type: "Uint32-Array",
                rust_offset: offset_of!(StringHubEntityData, hashed_input),
            },
        ],
    }),
    array_type: Some(STRINGHUBENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for StringHubEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        STRINGHUBENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static STRINGHUBENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StringHubEntityData-Array",
    name_hash: 1763320112,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("StringHubEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct Vec4HubEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub input_count: i32,
    pub input_select: i32,
    pub hashed_input: Vec<u32>,
}

pub trait Vec4HubEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn input_count(&self) -> &i32;
    fn input_count_mut(&mut self) -> &mut i32;
    fn input_select(&self) -> &i32;
    fn input_select_mut(&mut self) -> &mut i32;
    fn hashed_input(&self) -> &Vec<u32>;
    fn hashed_input_mut(&mut self) -> &mut Vec<u32>;
}

impl Vec4HubEntityDataTrait for Vec4HubEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn input_count(&self) -> &i32 {
        &self.input_count
    }
    fn input_count_mut(&mut self) -> &mut i32 {
        &mut self.input_count
    }
    fn input_select(&self) -> &i32 {
        &self.input_select
    }
    fn input_select_mut(&mut self) -> &mut i32 {
        &mut self.input_select
    }
    fn hashed_input(&self) -> &Vec<u32> {
        &self.hashed_input
    }
    fn hashed_input_mut(&mut self) -> &mut Vec<u32> {
        &mut self.hashed_input
    }
}

impl EntityDataTrait for Vec4HubEntityData {
}

impl GameObjectDataTrait for Vec4HubEntityData {
}

impl super::core::DataBusPeerTrait for Vec4HubEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for Vec4HubEntityData {
}

impl super::core::DataContainerTrait for Vec4HubEntityData {
}

pub static VEC4HUBENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec4HubEntityData",
    name_hash: 579667829,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(Vec4HubEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec4HubEntityData as Default>::default())),
            create_boxed: || Box::new(<Vec4HubEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(Vec4HubEntityData, realm),
            },
            FieldInfoData {
                name: "InputCount",
                name_hash: 1607263120,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(Vec4HubEntityData, input_count),
            },
            FieldInfoData {
                name: "InputSelect",
                name_hash: 858290427,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(Vec4HubEntityData, input_select),
            },
            FieldInfoData {
                name: "HashedInput",
                name_hash: 1165807872,
                flags: MemberInfoFlags::new(144),
                field_type: "Uint32-Array",
                rust_offset: offset_of!(Vec4HubEntityData, hashed_input),
            },
        ],
    }),
    array_type: Some(VEC4HUBENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for Vec4HubEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VEC4HUBENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEC4HUBENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec4HubEntityData-Array",
    name_hash: 1958574145,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec4HubEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct Vec3HubEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub input_count: i32,
    pub input_select: i32,
    pub hashed_input: Vec<u32>,
}

pub trait Vec3HubEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn input_count(&self) -> &i32;
    fn input_count_mut(&mut self) -> &mut i32;
    fn input_select(&self) -> &i32;
    fn input_select_mut(&mut self) -> &mut i32;
    fn hashed_input(&self) -> &Vec<u32>;
    fn hashed_input_mut(&mut self) -> &mut Vec<u32>;
}

impl Vec3HubEntityDataTrait for Vec3HubEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn input_count(&self) -> &i32 {
        &self.input_count
    }
    fn input_count_mut(&mut self) -> &mut i32 {
        &mut self.input_count
    }
    fn input_select(&self) -> &i32 {
        &self.input_select
    }
    fn input_select_mut(&mut self) -> &mut i32 {
        &mut self.input_select
    }
    fn hashed_input(&self) -> &Vec<u32> {
        &self.hashed_input
    }
    fn hashed_input_mut(&mut self) -> &mut Vec<u32> {
        &mut self.hashed_input
    }
}

impl EntityDataTrait for Vec3HubEntityData {
}

impl GameObjectDataTrait for Vec3HubEntityData {
}

impl super::core::DataBusPeerTrait for Vec3HubEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for Vec3HubEntityData {
}

impl super::core::DataContainerTrait for Vec3HubEntityData {
}

pub static VEC3HUBENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3HubEntityData",
    name_hash: 1640605842,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(Vec3HubEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec3HubEntityData as Default>::default())),
            create_boxed: || Box::new(<Vec3HubEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(Vec3HubEntityData, realm),
            },
            FieldInfoData {
                name: "InputCount",
                name_hash: 1607263120,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(Vec3HubEntityData, input_count),
            },
            FieldInfoData {
                name: "InputSelect",
                name_hash: 858290427,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(Vec3HubEntityData, input_select),
            },
            FieldInfoData {
                name: "HashedInput",
                name_hash: 1165807872,
                flags: MemberInfoFlags::new(144),
                field_type: "Uint32-Array",
                rust_offset: offset_of!(Vec3HubEntityData, hashed_input),
            },
        ],
    }),
    array_type: Some(VEC3HUBENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for Vec3HubEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VEC3HUBENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEC3HUBENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3HubEntityData-Array",
    name_hash: 1466150822,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec3HubEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct Vec2HubEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub input_count: i32,
    pub input_select: i32,
    pub hashed_input: Vec<u32>,
}

pub trait Vec2HubEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn input_count(&self) -> &i32;
    fn input_count_mut(&mut self) -> &mut i32;
    fn input_select(&self) -> &i32;
    fn input_select_mut(&mut self) -> &mut i32;
    fn hashed_input(&self) -> &Vec<u32>;
    fn hashed_input_mut(&mut self) -> &mut Vec<u32>;
}

impl Vec2HubEntityDataTrait for Vec2HubEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn input_count(&self) -> &i32 {
        &self.input_count
    }
    fn input_count_mut(&mut self) -> &mut i32 {
        &mut self.input_count
    }
    fn input_select(&self) -> &i32 {
        &self.input_select
    }
    fn input_select_mut(&mut self) -> &mut i32 {
        &mut self.input_select
    }
    fn hashed_input(&self) -> &Vec<u32> {
        &self.hashed_input
    }
    fn hashed_input_mut(&mut self) -> &mut Vec<u32> {
        &mut self.hashed_input
    }
}

impl EntityDataTrait for Vec2HubEntityData {
}

impl GameObjectDataTrait for Vec2HubEntityData {
}

impl super::core::DataBusPeerTrait for Vec2HubEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for Vec2HubEntityData {
}

impl super::core::DataContainerTrait for Vec2HubEntityData {
}

pub static VEC2HUBENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec2HubEntityData",
    name_hash: 1241778867,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(Vec2HubEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec2HubEntityData as Default>::default())),
            create_boxed: || Box::new(<Vec2HubEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(Vec2HubEntityData, realm),
            },
            FieldInfoData {
                name: "InputCount",
                name_hash: 1607263120,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(Vec2HubEntityData, input_count),
            },
            FieldInfoData {
                name: "InputSelect",
                name_hash: 858290427,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(Vec2HubEntityData, input_select),
            },
            FieldInfoData {
                name: "HashedInput",
                name_hash: 1165807872,
                flags: MemberInfoFlags::new(144),
                field_type: "Uint32-Array",
                rust_offset: offset_of!(Vec2HubEntityData, hashed_input),
            },
        ],
    }),
    array_type: Some(VEC2HUBENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for Vec2HubEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VEC2HUBENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEC2HUBENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec2HubEntityData-Array",
    name_hash: 3059906055,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec2HubEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct FloatHubEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub input_count: i32,
    pub input_select: i32,
    pub hashed_input: Vec<u32>,
}

pub trait FloatHubEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn input_count(&self) -> &i32;
    fn input_count_mut(&mut self) -> &mut i32;
    fn input_select(&self) -> &i32;
    fn input_select_mut(&mut self) -> &mut i32;
    fn hashed_input(&self) -> &Vec<u32>;
    fn hashed_input_mut(&mut self) -> &mut Vec<u32>;
}

impl FloatHubEntityDataTrait for FloatHubEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn input_count(&self) -> &i32 {
        &self.input_count
    }
    fn input_count_mut(&mut self) -> &mut i32 {
        &mut self.input_count
    }
    fn input_select(&self) -> &i32 {
        &self.input_select
    }
    fn input_select_mut(&mut self) -> &mut i32 {
        &mut self.input_select
    }
    fn hashed_input(&self) -> &Vec<u32> {
        &self.hashed_input
    }
    fn hashed_input_mut(&mut self) -> &mut Vec<u32> {
        &mut self.hashed_input
    }
}

impl EntityDataTrait for FloatHubEntityData {
}

impl GameObjectDataTrait for FloatHubEntityData {
}

impl super::core::DataBusPeerTrait for FloatHubEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for FloatHubEntityData {
}

impl super::core::DataContainerTrait for FloatHubEntityData {
}

pub static FLOATHUBENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatHubEntityData",
    name_hash: 2082597025,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(FloatHubEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FloatHubEntityData as Default>::default())),
            create_boxed: || Box::new(<FloatHubEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(FloatHubEntityData, realm),
            },
            FieldInfoData {
                name: "InputCount",
                name_hash: 1607263120,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(FloatHubEntityData, input_count),
            },
            FieldInfoData {
                name: "InputSelect",
                name_hash: 858290427,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(FloatHubEntityData, input_select),
            },
            FieldInfoData {
                name: "HashedInput",
                name_hash: 1165807872,
                flags: MemberInfoFlags::new(144),
                field_type: "Uint32-Array",
                rust_offset: offset_of!(FloatHubEntityData, hashed_input),
            },
        ],
    }),
    array_type: Some(FLOATHUBENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FloatHubEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        FLOATHUBENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FLOATHUBENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatHubEntityData-Array",
    name_hash: 3777205013,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("FloatHubEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct Int64HubEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub input_count: i32,
    pub input_select: i32,
    pub hashed_input: Vec<u32>,
}

pub trait Int64HubEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn input_count(&self) -> &i32;
    fn input_count_mut(&mut self) -> &mut i32;
    fn input_select(&self) -> &i32;
    fn input_select_mut(&mut self) -> &mut i32;
    fn hashed_input(&self) -> &Vec<u32>;
    fn hashed_input_mut(&mut self) -> &mut Vec<u32>;
}

impl Int64HubEntityDataTrait for Int64HubEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn input_count(&self) -> &i32 {
        &self.input_count
    }
    fn input_count_mut(&mut self) -> &mut i32 {
        &mut self.input_count
    }
    fn input_select(&self) -> &i32 {
        &self.input_select
    }
    fn input_select_mut(&mut self) -> &mut i32 {
        &mut self.input_select
    }
    fn hashed_input(&self) -> &Vec<u32> {
        &self.hashed_input
    }
    fn hashed_input_mut(&mut self) -> &mut Vec<u32> {
        &mut self.hashed_input
    }
}

impl EntityDataTrait for Int64HubEntityData {
}

impl GameObjectDataTrait for Int64HubEntityData {
}

impl super::core::DataBusPeerTrait for Int64HubEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for Int64HubEntityData {
}

impl super::core::DataContainerTrait for Int64HubEntityData {
}

pub static INT64HUBENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Int64HubEntityData",
    name_hash: 3158042912,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(Int64HubEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Int64HubEntityData as Default>::default())),
            create_boxed: || Box::new(<Int64HubEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(Int64HubEntityData, realm),
            },
            FieldInfoData {
                name: "InputCount",
                name_hash: 1607263120,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(Int64HubEntityData, input_count),
            },
            FieldInfoData {
                name: "InputSelect",
                name_hash: 858290427,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(Int64HubEntityData, input_select),
            },
            FieldInfoData {
                name: "HashedInput",
                name_hash: 1165807872,
                flags: MemberInfoFlags::new(144),
                field_type: "Uint32-Array",
                rust_offset: offset_of!(Int64HubEntityData, hashed_input),
            },
        ],
    }),
    array_type: Some(INT64HUBENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for Int64HubEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        INT64HUBENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static INT64HUBENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Int64HubEntityData-Array",
    name_hash: 4110724756,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Int64HubEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct IntHubEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub input_count: i32,
    pub input_select: i32,
    pub hashed_input: Vec<u32>,
}

pub trait IntHubEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn input_count(&self) -> &i32;
    fn input_count_mut(&mut self) -> &mut i32;
    fn input_select(&self) -> &i32;
    fn input_select_mut(&mut self) -> &mut i32;
    fn hashed_input(&self) -> &Vec<u32>;
    fn hashed_input_mut(&mut self) -> &mut Vec<u32>;
}

impl IntHubEntityDataTrait for IntHubEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn input_count(&self) -> &i32 {
        &self.input_count
    }
    fn input_count_mut(&mut self) -> &mut i32 {
        &mut self.input_count
    }
    fn input_select(&self) -> &i32 {
        &self.input_select
    }
    fn input_select_mut(&mut self) -> &mut i32 {
        &mut self.input_select
    }
    fn hashed_input(&self) -> &Vec<u32> {
        &self.hashed_input
    }
    fn hashed_input_mut(&mut self) -> &mut Vec<u32> {
        &mut self.hashed_input
    }
}

impl EntityDataTrait for IntHubEntityData {
}

impl GameObjectDataTrait for IntHubEntityData {
}

impl super::core::DataBusPeerTrait for IntHubEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for IntHubEntityData {
}

impl super::core::DataContainerTrait for IntHubEntityData {
}

pub static INTHUBENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntHubEntityData",
    name_hash: 3631395746,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(IntHubEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<IntHubEntityData as Default>::default())),
            create_boxed: || Box::new(<IntHubEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(IntHubEntityData, realm),
            },
            FieldInfoData {
                name: "InputCount",
                name_hash: 1607263120,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(IntHubEntityData, input_count),
            },
            FieldInfoData {
                name: "InputSelect",
                name_hash: 858290427,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(IntHubEntityData, input_select),
            },
            FieldInfoData {
                name: "HashedInput",
                name_hash: 1165807872,
                flags: MemberInfoFlags::new(144),
                field_type: "Uint32-Array",
                rust_offset: offset_of!(IntHubEntityData, hashed_input),
            },
        ],
    }),
    array_type: Some(INTHUBENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for IntHubEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        INTHUBENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static INTHUBENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntHubEntityData-Array",
    name_hash: 1828835862,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("IntHubEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct BoolHubEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub input_select: i32,
    pub hashed_input: Vec<u32>,
}

pub trait BoolHubEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn input_select(&self) -> &i32;
    fn input_select_mut(&mut self) -> &mut i32;
    fn hashed_input(&self) -> &Vec<u32>;
    fn hashed_input_mut(&mut self) -> &mut Vec<u32>;
}

impl BoolHubEntityDataTrait for BoolHubEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn input_select(&self) -> &i32 {
        &self.input_select
    }
    fn input_select_mut(&mut self) -> &mut i32 {
        &mut self.input_select
    }
    fn hashed_input(&self) -> &Vec<u32> {
        &self.hashed_input
    }
    fn hashed_input_mut(&mut self) -> &mut Vec<u32> {
        &mut self.hashed_input
    }
}

impl EntityDataTrait for BoolHubEntityData {
}

impl GameObjectDataTrait for BoolHubEntityData {
}

impl super::core::DataBusPeerTrait for BoolHubEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for BoolHubEntityData {
}

impl super::core::DataContainerTrait for BoolHubEntityData {
}

pub static BOOLHUBENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolHubEntityData",
    name_hash: 2841572735,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(BoolHubEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BoolHubEntityData as Default>::default())),
            create_boxed: || Box::new(<BoolHubEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(BoolHubEntityData, realm),
            },
            FieldInfoData {
                name: "InputSelect",
                name_hash: 858290427,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(BoolHubEntityData, input_select),
            },
            FieldInfoData {
                name: "HashedInput",
                name_hash: 1165807872,
                flags: MemberInfoFlags::new(144),
                field_type: "Uint32-Array",
                rust_offset: offset_of!(BoolHubEntityData, hashed_input),
            },
        ],
    }),
    array_type: Some(BOOLHUBENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BoolHubEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        BOOLHUBENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BOOLHUBENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolHubEntityData-Array",
    name_hash: 2499115851,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("BoolHubEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SimpleDofParamConverterEntityData {
    pub _glacier_base: EntityData,
    pub focus_distance: f32,
    pub blur_filter_deviation: f32,
    pub near_distance_scale: f32,
    pub far_distance_scale: f32,
    pub scale: f32,
}

pub trait SimpleDofParamConverterEntityDataTrait: EntityDataTrait {
    fn focus_distance(&self) -> &f32;
    fn focus_distance_mut(&mut self) -> &mut f32;
    fn blur_filter_deviation(&self) -> &f32;
    fn blur_filter_deviation_mut(&mut self) -> &mut f32;
    fn near_distance_scale(&self) -> &f32;
    fn near_distance_scale_mut(&mut self) -> &mut f32;
    fn far_distance_scale(&self) -> &f32;
    fn far_distance_scale_mut(&mut self) -> &mut f32;
    fn scale(&self) -> &f32;
    fn scale_mut(&mut self) -> &mut f32;
}

impl SimpleDofParamConverterEntityDataTrait for SimpleDofParamConverterEntityData {
    fn focus_distance(&self) -> &f32 {
        &self.focus_distance
    }
    fn focus_distance_mut(&mut self) -> &mut f32 {
        &mut self.focus_distance
    }
    fn blur_filter_deviation(&self) -> &f32 {
        &self.blur_filter_deviation
    }
    fn blur_filter_deviation_mut(&mut self) -> &mut f32 {
        &mut self.blur_filter_deviation
    }
    fn near_distance_scale(&self) -> &f32 {
        &self.near_distance_scale
    }
    fn near_distance_scale_mut(&mut self) -> &mut f32 {
        &mut self.near_distance_scale
    }
    fn far_distance_scale(&self) -> &f32 {
        &self.far_distance_scale
    }
    fn far_distance_scale_mut(&mut self) -> &mut f32 {
        &mut self.far_distance_scale
    }
    fn scale(&self) -> &f32 {
        &self.scale
    }
    fn scale_mut(&mut self) -> &mut f32 {
        &mut self.scale
    }
}

impl EntityDataTrait for SimpleDofParamConverterEntityData {
}

impl GameObjectDataTrait for SimpleDofParamConverterEntityData {
}

impl super::core::DataBusPeerTrait for SimpleDofParamConverterEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SimpleDofParamConverterEntityData {
}

impl super::core::DataContainerTrait for SimpleDofParamConverterEntityData {
}

pub static SIMPLEDOFPARAMCONVERTERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleDofParamConverterEntityData",
    name_hash: 2693745250,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(SimpleDofParamConverterEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SimpleDofParamConverterEntityData as Default>::default())),
            create_boxed: || Box::new(<SimpleDofParamConverterEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "FocusDistance",
                name_hash: 1402926186,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SimpleDofParamConverterEntityData, focus_distance),
            },
            FieldInfoData {
                name: "BlurFilterDeviation",
                name_hash: 2875622063,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SimpleDofParamConverterEntityData, blur_filter_deviation),
            },
            FieldInfoData {
                name: "NearDistanceScale",
                name_hash: 4096748582,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SimpleDofParamConverterEntityData, near_distance_scale),
            },
            FieldInfoData {
                name: "FarDistanceScale",
                name_hash: 4048208907,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SimpleDofParamConverterEntityData, far_distance_scale),
            },
            FieldInfoData {
                name: "Scale",
                name_hash: 231223453,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SimpleDofParamConverterEntityData, scale),
            },
        ],
    }),
    array_type: Some(SIMPLEDOFPARAMCONVERTERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SimpleDofParamConverterEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SIMPLEDOFPARAMCONVERTERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SIMPLEDOFPARAMCONVERTERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleDofParamConverterEntityData-Array",
    name_hash: 739522902,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SimpleDofParamConverterEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SpriteDofParamConverterEntityData {
    pub _glacier_base: EntityData,
    pub sprite_dof_out_focus_start: f32,
    pub sprite_dof_out_focus_end: f32,
    pub sprite_dof_max_blur_factor: f32,
}

pub trait SpriteDofParamConverterEntityDataTrait: EntityDataTrait {
    fn sprite_dof_out_focus_start(&self) -> &f32;
    fn sprite_dof_out_focus_start_mut(&mut self) -> &mut f32;
    fn sprite_dof_out_focus_end(&self) -> &f32;
    fn sprite_dof_out_focus_end_mut(&mut self) -> &mut f32;
    fn sprite_dof_max_blur_factor(&self) -> &f32;
    fn sprite_dof_max_blur_factor_mut(&mut self) -> &mut f32;
}

impl SpriteDofParamConverterEntityDataTrait for SpriteDofParamConverterEntityData {
    fn sprite_dof_out_focus_start(&self) -> &f32 {
        &self.sprite_dof_out_focus_start
    }
    fn sprite_dof_out_focus_start_mut(&mut self) -> &mut f32 {
        &mut self.sprite_dof_out_focus_start
    }
    fn sprite_dof_out_focus_end(&self) -> &f32 {
        &self.sprite_dof_out_focus_end
    }
    fn sprite_dof_out_focus_end_mut(&mut self) -> &mut f32 {
        &mut self.sprite_dof_out_focus_end
    }
    fn sprite_dof_max_blur_factor(&self) -> &f32 {
        &self.sprite_dof_max_blur_factor
    }
    fn sprite_dof_max_blur_factor_mut(&mut self) -> &mut f32 {
        &mut self.sprite_dof_max_blur_factor
    }
}

impl EntityDataTrait for SpriteDofParamConverterEntityData {
}

impl GameObjectDataTrait for SpriteDofParamConverterEntityData {
}

impl super::core::DataBusPeerTrait for SpriteDofParamConverterEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SpriteDofParamConverterEntityData {
}

impl super::core::DataContainerTrait for SpriteDofParamConverterEntityData {
}

pub static SPRITEDOFPARAMCONVERTERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpriteDofParamConverterEntityData",
    name_hash: 620809125,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(SpriteDofParamConverterEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SpriteDofParamConverterEntityData as Default>::default())),
            create_boxed: || Box::new(<SpriteDofParamConverterEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "SpriteDofOutFocusStart",
                name_hash: 3519671075,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpriteDofParamConverterEntityData, sprite_dof_out_focus_start),
            },
            FieldInfoData {
                name: "SpriteDofOutFocusEnd",
                name_hash: 334517932,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpriteDofParamConverterEntityData, sprite_dof_out_focus_end),
            },
            FieldInfoData {
                name: "SpriteDofMaxBlurFactor",
                name_hash: 1216601297,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpriteDofParamConverterEntityData, sprite_dof_max_blur_factor),
            },
        ],
    }),
    array_type: Some(SPRITEDOFPARAMCONVERTERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SpriteDofParamConverterEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SPRITEDOFPARAMCONVERTERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SPRITEDOFPARAMCONVERTERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpriteDofParamConverterEntityData-Array",
    name_hash: 1033921553,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SpriteDofParamConverterEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ObjectVariationMultiSwitchEntityData {
    pub _glacier_base: EntityData,
    pub variations: Vec<Option<LockedTypeObject /* ObjectVariation */>>,
    pub current_index: i32,
    pub set_on_init: bool,
}

pub trait ObjectVariationMultiSwitchEntityDataTrait: EntityDataTrait {
    fn variations(&self) -> &Vec<Option<LockedTypeObject /* ObjectVariation */>>;
    fn variations_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* ObjectVariation */>>;
    fn current_index(&self) -> &i32;
    fn current_index_mut(&mut self) -> &mut i32;
    fn set_on_init(&self) -> &bool;
    fn set_on_init_mut(&mut self) -> &mut bool;
}

impl ObjectVariationMultiSwitchEntityDataTrait for ObjectVariationMultiSwitchEntityData {
    fn variations(&self) -> &Vec<Option<LockedTypeObject /* ObjectVariation */>> {
        &self.variations
    }
    fn variations_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* ObjectVariation */>> {
        &mut self.variations
    }
    fn current_index(&self) -> &i32 {
        &self.current_index
    }
    fn current_index_mut(&mut self) -> &mut i32 {
        &mut self.current_index
    }
    fn set_on_init(&self) -> &bool {
        &self.set_on_init
    }
    fn set_on_init_mut(&mut self) -> &mut bool {
        &mut self.set_on_init
    }
}

impl EntityDataTrait for ObjectVariationMultiSwitchEntityData {
}

impl GameObjectDataTrait for ObjectVariationMultiSwitchEntityData {
}

impl super::core::DataBusPeerTrait for ObjectVariationMultiSwitchEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ObjectVariationMultiSwitchEntityData {
}

impl super::core::DataContainerTrait for ObjectVariationMultiSwitchEntityData {
}

pub static OBJECTVARIATIONMULTISWITCHENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectVariationMultiSwitchEntityData",
    name_hash: 1034134385,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(ObjectVariationMultiSwitchEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ObjectVariationMultiSwitchEntityData as Default>::default())),
            create_boxed: || Box::new(<ObjectVariationMultiSwitchEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Variations",
                name_hash: 2728063271,
                flags: MemberInfoFlags::new(144),
                field_type: "ObjectVariation-Array",
                rust_offset: offset_of!(ObjectVariationMultiSwitchEntityData, variations),
            },
            FieldInfoData {
                name: "CurrentIndex",
                name_hash: 1121794034,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ObjectVariationMultiSwitchEntityData, current_index),
            },
            FieldInfoData {
                name: "SetOnInit",
                name_hash: 621813820,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ObjectVariationMultiSwitchEntityData, set_on_init),
            },
        ],
    }),
    array_type: Some(OBJECTVARIATIONMULTISWITCHENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ObjectVariationMultiSwitchEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        OBJECTVARIATIONMULTISWITCHENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static OBJECTVARIATIONMULTISWITCHENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectVariationMultiSwitchEntityData-Array",
    name_hash: 1679386181,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ObjectVariationMultiSwitchEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ObjectVariationSwitchEntityData {
    pub _glacier_base: EntityData,
    pub variation1: Option<LockedTypeObject /* ObjectVariation */>,
    pub variation2: Option<LockedTypeObject /* ObjectVariation */>,
}

pub trait ObjectVariationSwitchEntityDataTrait: EntityDataTrait {
    fn variation1(&self) -> &Option<LockedTypeObject /* ObjectVariation */>;
    fn variation1_mut(&mut self) -> &mut Option<LockedTypeObject /* ObjectVariation */>;
    fn variation2(&self) -> &Option<LockedTypeObject /* ObjectVariation */>;
    fn variation2_mut(&mut self) -> &mut Option<LockedTypeObject /* ObjectVariation */>;
}

impl ObjectVariationSwitchEntityDataTrait for ObjectVariationSwitchEntityData {
    fn variation1(&self) -> &Option<LockedTypeObject /* ObjectVariation */> {
        &self.variation1
    }
    fn variation1_mut(&mut self) -> &mut Option<LockedTypeObject /* ObjectVariation */> {
        &mut self.variation1
    }
    fn variation2(&self) -> &Option<LockedTypeObject /* ObjectVariation */> {
        &self.variation2
    }
    fn variation2_mut(&mut self) -> &mut Option<LockedTypeObject /* ObjectVariation */> {
        &mut self.variation2
    }
}

impl EntityDataTrait for ObjectVariationSwitchEntityData {
}

impl GameObjectDataTrait for ObjectVariationSwitchEntityData {
}

impl super::core::DataBusPeerTrait for ObjectVariationSwitchEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ObjectVariationSwitchEntityData {
}

impl super::core::DataContainerTrait for ObjectVariationSwitchEntityData {
}

pub static OBJECTVARIATIONSWITCHENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectVariationSwitchEntityData",
    name_hash: 1155757048,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(ObjectVariationSwitchEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ObjectVariationSwitchEntityData as Default>::default())),
            create_boxed: || Box::new(<ObjectVariationSwitchEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Variation1",
                name_hash: 2728063333,
                flags: MemberInfoFlags::new(0),
                field_type: "ObjectVariation",
                rust_offset: offset_of!(ObjectVariationSwitchEntityData, variation1),
            },
            FieldInfoData {
                name: "Variation2",
                name_hash: 2728063334,
                flags: MemberInfoFlags::new(0),
                field_type: "ObjectVariation",
                rust_offset: offset_of!(ObjectVariationSwitchEntityData, variation2),
            },
        ],
    }),
    array_type: Some(OBJECTVARIATIONSWITCHENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ObjectVariationSwitchEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        OBJECTVARIATIONSWITCHENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static OBJECTVARIATIONSWITCHENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectVariationSwitchEntityData-Array",
    name_hash: 3366415820,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ObjectVariationSwitchEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct RandomDelayEntityData {
    pub _glacier_base: EntityData,
    pub min_delay: f32,
    pub max_delay: f32,
    pub realm: super::core::Realm,
    pub auto_start: bool,
    pub run_once: bool,
    pub true_random: bool,
    pub time_delta_type: TimeDeltaType,
}

pub trait RandomDelayEntityDataTrait: EntityDataTrait {
    fn min_delay(&self) -> &f32;
    fn min_delay_mut(&mut self) -> &mut f32;
    fn max_delay(&self) -> &f32;
    fn max_delay_mut(&mut self) -> &mut f32;
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn auto_start(&self) -> &bool;
    fn auto_start_mut(&mut self) -> &mut bool;
    fn run_once(&self) -> &bool;
    fn run_once_mut(&mut self) -> &mut bool;
    fn true_random(&self) -> &bool;
    fn true_random_mut(&mut self) -> &mut bool;
    fn time_delta_type(&self) -> &TimeDeltaType;
    fn time_delta_type_mut(&mut self) -> &mut TimeDeltaType;
}

impl RandomDelayEntityDataTrait for RandomDelayEntityData {
    fn min_delay(&self) -> &f32 {
        &self.min_delay
    }
    fn min_delay_mut(&mut self) -> &mut f32 {
        &mut self.min_delay
    }
    fn max_delay(&self) -> &f32 {
        &self.max_delay
    }
    fn max_delay_mut(&mut self) -> &mut f32 {
        &mut self.max_delay
    }
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn auto_start(&self) -> &bool {
        &self.auto_start
    }
    fn auto_start_mut(&mut self) -> &mut bool {
        &mut self.auto_start
    }
    fn run_once(&self) -> &bool {
        &self.run_once
    }
    fn run_once_mut(&mut self) -> &mut bool {
        &mut self.run_once
    }
    fn true_random(&self) -> &bool {
        &self.true_random
    }
    fn true_random_mut(&mut self) -> &mut bool {
        &mut self.true_random
    }
    fn time_delta_type(&self) -> &TimeDeltaType {
        &self.time_delta_type
    }
    fn time_delta_type_mut(&mut self) -> &mut TimeDeltaType {
        &mut self.time_delta_type
    }
}

impl EntityDataTrait for RandomDelayEntityData {
}

impl GameObjectDataTrait for RandomDelayEntityData {
}

impl super::core::DataBusPeerTrait for RandomDelayEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for RandomDelayEntityData {
}

impl super::core::DataContainerTrait for RandomDelayEntityData {
}

pub static RANDOMDELAYENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RandomDelayEntityData",
    name_hash: 930163488,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(RandomDelayEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RandomDelayEntityData as Default>::default())),
            create_boxed: || Box::new(<RandomDelayEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "MinDelay",
                name_hash: 3350783098,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RandomDelayEntityData, min_delay),
            },
            FieldInfoData {
                name: "MaxDelay",
                name_hash: 420379940,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RandomDelayEntityData, max_delay),
            },
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(RandomDelayEntityData, realm),
            },
            FieldInfoData {
                name: "AutoStart",
                name_hash: 792615882,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RandomDelayEntityData, auto_start),
            },
            FieldInfoData {
                name: "RunOnce",
                name_hash: 709901739,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RandomDelayEntityData, run_once),
            },
            FieldInfoData {
                name: "TrueRandom",
                name_hash: 856584456,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RandomDelayEntityData, true_random),
            },
            FieldInfoData {
                name: "TimeDeltaType",
                name_hash: 1100516816,
                flags: MemberInfoFlags::new(0),
                field_type: "TimeDeltaType",
                rust_offset: offset_of!(RandomDelayEntityData, time_delta_type),
            },
        ],
    }),
    array_type: Some(RANDOMDELAYENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RandomDelayEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        RANDOMDELAYENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RANDOMDELAYENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RandomDelayEntityData-Array",
    name_hash: 3349377172,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("RandomDelayEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct DelayEntityData {
    pub _glacier_base: EntityData,
    pub delay: f32,
    pub realm: super::core::Realm,
    pub auto_start: bool,
    pub run_once: bool,
    pub remove_duplicate_events: bool,
    pub time_delta_type: TimeDeltaType,
}

pub trait DelayEntityDataTrait: EntityDataTrait {
    fn delay(&self) -> &f32;
    fn delay_mut(&mut self) -> &mut f32;
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn auto_start(&self) -> &bool;
    fn auto_start_mut(&mut self) -> &mut bool;
    fn run_once(&self) -> &bool;
    fn run_once_mut(&mut self) -> &mut bool;
    fn remove_duplicate_events(&self) -> &bool;
    fn remove_duplicate_events_mut(&mut self) -> &mut bool;
    fn time_delta_type(&self) -> &TimeDeltaType;
    fn time_delta_type_mut(&mut self) -> &mut TimeDeltaType;
}

impl DelayEntityDataTrait for DelayEntityData {
    fn delay(&self) -> &f32 {
        &self.delay
    }
    fn delay_mut(&mut self) -> &mut f32 {
        &mut self.delay
    }
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn auto_start(&self) -> &bool {
        &self.auto_start
    }
    fn auto_start_mut(&mut self) -> &mut bool {
        &mut self.auto_start
    }
    fn run_once(&self) -> &bool {
        &self.run_once
    }
    fn run_once_mut(&mut self) -> &mut bool {
        &mut self.run_once
    }
    fn remove_duplicate_events(&self) -> &bool {
        &self.remove_duplicate_events
    }
    fn remove_duplicate_events_mut(&mut self) -> &mut bool {
        &mut self.remove_duplicate_events
    }
    fn time_delta_type(&self) -> &TimeDeltaType {
        &self.time_delta_type
    }
    fn time_delta_type_mut(&mut self) -> &mut TimeDeltaType {
        &mut self.time_delta_type
    }
}

impl EntityDataTrait for DelayEntityData {
}

impl GameObjectDataTrait for DelayEntityData {
}

impl super::core::DataBusPeerTrait for DelayEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for DelayEntityData {
}

impl super::core::DataContainerTrait for DelayEntityData {
}

pub static DELAYENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DelayEntityData",
    name_hash: 502994651,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(DelayEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DelayEntityData as Default>::default())),
            create_boxed: || Box::new(<DelayEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Delay",
                name_hash: 208768368,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DelayEntityData, delay),
            },
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(DelayEntityData, realm),
            },
            FieldInfoData {
                name: "AutoStart",
                name_hash: 792615882,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DelayEntityData, auto_start),
            },
            FieldInfoData {
                name: "RunOnce",
                name_hash: 709901739,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DelayEntityData, run_once),
            },
            FieldInfoData {
                name: "RemoveDuplicateEvents",
                name_hash: 2871488843,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DelayEntityData, remove_duplicate_events),
            },
            FieldInfoData {
                name: "TimeDeltaType",
                name_hash: 1100516816,
                flags: MemberInfoFlags::new(0),
                field_type: "TimeDeltaType",
                rust_offset: offset_of!(DelayEntityData, time_delta_type),
            },
        ],
    }),
    array_type: Some(DELAYENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DelayEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        DELAYENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DELAYENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DelayEntityData-Array",
    name_hash: 1854209519,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("DelayEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct EventOrderGateEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub event_count: u32,
    pub enabled: bool,
    pub disable_on_open: bool,
    pub event_countdowns: Vec<u32>,
    pub source_hashes: Vec<i32>,
}

pub trait EventOrderGateEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn event_count(&self) -> &u32;
    fn event_count_mut(&mut self) -> &mut u32;
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
    fn disable_on_open(&self) -> &bool;
    fn disable_on_open_mut(&mut self) -> &mut bool;
    fn event_countdowns(&self) -> &Vec<u32>;
    fn event_countdowns_mut(&mut self) -> &mut Vec<u32>;
    fn source_hashes(&self) -> &Vec<i32>;
    fn source_hashes_mut(&mut self) -> &mut Vec<i32>;
}

impl EventOrderGateEntityDataTrait for EventOrderGateEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn event_count(&self) -> &u32 {
        &self.event_count
    }
    fn event_count_mut(&mut self) -> &mut u32 {
        &mut self.event_count
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
    fn disable_on_open(&self) -> &bool {
        &self.disable_on_open
    }
    fn disable_on_open_mut(&mut self) -> &mut bool {
        &mut self.disable_on_open
    }
    fn event_countdowns(&self) -> &Vec<u32> {
        &self.event_countdowns
    }
    fn event_countdowns_mut(&mut self) -> &mut Vec<u32> {
        &mut self.event_countdowns
    }
    fn source_hashes(&self) -> &Vec<i32> {
        &self.source_hashes
    }
    fn source_hashes_mut(&mut self) -> &mut Vec<i32> {
        &mut self.source_hashes
    }
}

impl EntityDataTrait for EventOrderGateEntityData {
}

impl GameObjectDataTrait for EventOrderGateEntityData {
}

impl super::core::DataBusPeerTrait for EventOrderGateEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for EventOrderGateEntityData {
}

impl super::core::DataContainerTrait for EventOrderGateEntityData {
}

pub static EVENTORDERGATEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventOrderGateEntityData",
    name_hash: 3181884123,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(EventOrderGateEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EventOrderGateEntityData as Default>::default())),
            create_boxed: || Box::new(<EventOrderGateEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(EventOrderGateEntityData, realm),
            },
            FieldInfoData {
                name: "EventCount",
                name_hash: 3235225642,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(EventOrderGateEntityData, event_count),
            },
            FieldInfoData {
                name: "Enabled",
                name_hash: 2662400,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EventOrderGateEntityData, enabled),
            },
            FieldInfoData {
                name: "DisableOnOpen",
                name_hash: 1924245956,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EventOrderGateEntityData, disable_on_open),
            },
            FieldInfoData {
                name: "EventCountdowns",
                name_hash: 582521963,
                flags: MemberInfoFlags::new(144),
                field_type: "Uint32-Array",
                rust_offset: offset_of!(EventOrderGateEntityData, event_countdowns),
            },
            FieldInfoData {
                name: "SourceHashes",
                name_hash: 4123925244,
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(EventOrderGateEntityData, source_hashes),
            },
        ],
    }),
    array_type: Some(EVENTORDERGATEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EventOrderGateEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        EVENTORDERGATEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EVENTORDERGATEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventOrderGateEntityData-Array",
    name_hash: 2620824047,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EventOrderGateEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct EventAndGateEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub event_count: u32,
}

pub trait EventAndGateEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn event_count(&self) -> &u32;
    fn event_count_mut(&mut self) -> &mut u32;
}

impl EventAndGateEntityDataTrait for EventAndGateEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn event_count(&self) -> &u32 {
        &self.event_count
    }
    fn event_count_mut(&mut self) -> &mut u32 {
        &mut self.event_count
    }
}

impl EntityDataTrait for EventAndGateEntityData {
}

impl GameObjectDataTrait for EventAndGateEntityData {
}

impl super::core::DataBusPeerTrait for EventAndGateEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for EventAndGateEntityData {
}

impl super::core::DataContainerTrait for EventAndGateEntityData {
}

pub static EVENTANDGATEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventAndGateEntityData",
    name_hash: 4151913342,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(EventAndGateEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EventAndGateEntityData as Default>::default())),
            create_boxed: || Box::new(<EventAndGateEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(EventAndGateEntityData, realm),
            },
            FieldInfoData {
                name: "EventCount",
                name_hash: 3235225642,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(EventAndGateEntityData, event_count),
            },
        ],
    }),
    array_type: Some(EVENTANDGATEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EventAndGateEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        EVENTANDGATEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EVENTANDGATEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventAndGateEntityData-Array",
    name_hash: 1886694474,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EventAndGateEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SelectEventEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub selected: i32,
    pub events: Vec<String>,
}

pub trait SelectEventEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn selected(&self) -> &i32;
    fn selected_mut(&mut self) -> &mut i32;
    fn events(&self) -> &Vec<String>;
    fn events_mut(&mut self) -> &mut Vec<String>;
}

impl SelectEventEntityDataTrait for SelectEventEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn selected(&self) -> &i32 {
        &self.selected
    }
    fn selected_mut(&mut self) -> &mut i32 {
        &mut self.selected
    }
    fn events(&self) -> &Vec<String> {
        &self.events
    }
    fn events_mut(&mut self) -> &mut Vec<String> {
        &mut self.events
    }
}

impl EntityDataTrait for SelectEventEntityData {
}

impl GameObjectDataTrait for SelectEventEntityData {
}

impl super::core::DataBusPeerTrait for SelectEventEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SelectEventEntityData {
}

impl super::core::DataContainerTrait for SelectEventEntityData {
}

pub static SELECTEVENTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectEventEntityData",
    name_hash: 2349330666,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(SelectEventEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SelectEventEntityData as Default>::default())),
            create_boxed: || Box::new(<SelectEventEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(SelectEventEntityData, realm),
            },
            FieldInfoData {
                name: "Selected",
                name_hash: 1570873612,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SelectEventEntityData, selected),
            },
            FieldInfoData {
                name: "Events",
                name_hash: 2352146554,
                flags: MemberInfoFlags::new(144),
                field_type: "CString-Array",
                rust_offset: offset_of!(SelectEventEntityData, events),
            },
        ],
    }),
    array_type: Some(SELECTEVENTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SelectEventEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SELECTEVENTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SELECTEVENTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectEventEntityData-Array",
    name_hash: 3566148574,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SelectEventEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct EventSwitchEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub out_events: u32,
    pub auto_increment: bool,
}

pub trait EventSwitchEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn out_events(&self) -> &u32;
    fn out_events_mut(&mut self) -> &mut u32;
    fn auto_increment(&self) -> &bool;
    fn auto_increment_mut(&mut self) -> &mut bool;
}

impl EventSwitchEntityDataTrait for EventSwitchEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn out_events(&self) -> &u32 {
        &self.out_events
    }
    fn out_events_mut(&mut self) -> &mut u32 {
        &mut self.out_events
    }
    fn auto_increment(&self) -> &bool {
        &self.auto_increment
    }
    fn auto_increment_mut(&mut self) -> &mut bool {
        &mut self.auto_increment
    }
}

impl EntityDataTrait for EventSwitchEntityData {
}

impl GameObjectDataTrait for EventSwitchEntityData {
}

impl super::core::DataBusPeerTrait for EventSwitchEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for EventSwitchEntityData {
}

impl super::core::DataContainerTrait for EventSwitchEntityData {
}

pub static EVENTSWITCHENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventSwitchEntityData",
    name_hash: 2726115664,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(EventSwitchEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EventSwitchEntityData as Default>::default())),
            create_boxed: || Box::new(<EventSwitchEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(EventSwitchEntityData, realm),
            },
            FieldInfoData {
                name: "OutEvents",
                name_hash: 2083855540,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(EventSwitchEntityData, out_events),
            },
            FieldInfoData {
                name: "AutoIncrement",
                name_hash: 1262167147,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EventSwitchEntityData, auto_increment),
            },
        ],
    }),
    array_type: Some(EVENTSWITCHENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EventSwitchEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        EVENTSWITCHENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EVENTSWITCHENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventSwitchEntityData-Array",
    name_hash: 4282947556,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EventSwitchEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct UniqueIdEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
}

pub trait UniqueIdEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
}

impl UniqueIdEntityDataTrait for UniqueIdEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
}

impl EntityDataTrait for UniqueIdEntityData {
}

impl GameObjectDataTrait for UniqueIdEntityData {
}

impl super::core::DataBusPeerTrait for UniqueIdEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for UniqueIdEntityData {
}

impl super::core::DataContainerTrait for UniqueIdEntityData {
}

pub static UNIQUEIDENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UniqueIdEntityData",
    name_hash: 2698123120,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(UniqueIdEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<UniqueIdEntityData as Default>::default())),
            create_boxed: || Box::new(<UniqueIdEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(UniqueIdEntityData, realm),
            },
        ],
    }),
    array_type: Some(UNIQUEIDENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for UniqueIdEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        UNIQUEIDENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static UNIQUEIDENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UniqueIdEntityData-Array",
    name_hash: 1852003652,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("UniqueIdEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct RandomIntEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub start: i32,
    pub count: i32,
    pub true_random: bool,
}

pub trait RandomIntEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn start(&self) -> &i32;
    fn start_mut(&mut self) -> &mut i32;
    fn count(&self) -> &i32;
    fn count_mut(&mut self) -> &mut i32;
    fn true_random(&self) -> &bool;
    fn true_random_mut(&mut self) -> &mut bool;
}

impl RandomIntEntityDataTrait for RandomIntEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn start(&self) -> &i32 {
        &self.start
    }
    fn start_mut(&mut self) -> &mut i32 {
        &mut self.start
    }
    fn count(&self) -> &i32 {
        &self.count
    }
    fn count_mut(&mut self) -> &mut i32 {
        &mut self.count
    }
    fn true_random(&self) -> &bool {
        &self.true_random
    }
    fn true_random_mut(&mut self) -> &mut bool {
        &mut self.true_random
    }
}

impl EntityDataTrait for RandomIntEntityData {
}

impl GameObjectDataTrait for RandomIntEntityData {
}

impl super::core::DataBusPeerTrait for RandomIntEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for RandomIntEntityData {
}

impl super::core::DataContainerTrait for RandomIntEntityData {
}

pub static RANDOMINTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RandomIntEntityData",
    name_hash: 2356555110,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(RandomIntEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RandomIntEntityData as Default>::default())),
            create_boxed: || Box::new(<RandomIntEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(RandomIntEntityData, realm),
            },
            FieldInfoData {
                name: "Start",
                name_hash: 230748069,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(RandomIntEntityData, start),
            },
            FieldInfoData {
                name: "Count",
                name_hash: 212413894,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(RandomIntEntityData, count),
            },
            FieldInfoData {
                name: "TrueRandom",
                name_hash: 856584456,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RandomIntEntityData, true_random),
            },
        ],
    }),
    array_type: Some(RANDOMINTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RandomIntEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        RANDOMINTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RANDOMINTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RandomIntEntityData-Array",
    name_hash: 4053338706,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("RandomIntEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct RandomFloatEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub min: f32,
    pub max: f32,
    pub true_random: bool,
}

pub trait RandomFloatEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn min(&self) -> &f32;
    fn min_mut(&mut self) -> &mut f32;
    fn max(&self) -> &f32;
    fn max_mut(&mut self) -> &mut f32;
    fn true_random(&self) -> &bool;
    fn true_random_mut(&mut self) -> &mut bool;
}

impl RandomFloatEntityDataTrait for RandomFloatEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn min(&self) -> &f32 {
        &self.min
    }
    fn min_mut(&mut self) -> &mut f32 {
        &mut self.min
    }
    fn max(&self) -> &f32 {
        &self.max
    }
    fn max_mut(&mut self) -> &mut f32 {
        &mut self.max
    }
    fn true_random(&self) -> &bool {
        &self.true_random
    }
    fn true_random_mut(&mut self) -> &mut bool {
        &mut self.true_random
    }
}

impl EntityDataTrait for RandomFloatEntityData {
}

impl GameObjectDataTrait for RandomFloatEntityData {
}

impl super::core::DataBusPeerTrait for RandomFloatEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for RandomFloatEntityData {
}

impl super::core::DataContainerTrait for RandomFloatEntityData {
}

pub static RANDOMFLOATENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RandomFloatEntityData",
    name_hash: 4134766853,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(RandomFloatEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RandomFloatEntityData as Default>::default())),
            create_boxed: || Box::new(<RandomFloatEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(RandomFloatEntityData, realm),
            },
            FieldInfoData {
                name: "Min",
                name_hash: 193446607,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RandomFloatEntityData, min),
            },
            FieldInfoData {
                name: "Max",
                name_hash: 193446865,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RandomFloatEntityData, max),
            },
            FieldInfoData {
                name: "TrueRandom",
                name_hash: 856584456,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RandomFloatEntityData, true_random),
            },
        ],
    }),
    array_type: Some(RANDOMFLOATENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RandomFloatEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        RANDOMFLOATENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RANDOMFLOATENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RandomFloatEntityData-Array",
    name_hash: 3974066353,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("RandomFloatEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct RandomMultiEventEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub uniform_distribution: bool,
    pub disable_output_on_trigger: bool,
    pub reset_outputs_when_all_has_triggered: bool,
    pub random_event_weight: Vec<f32>,
    pub true_random: bool,
}

pub trait RandomMultiEventEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn uniform_distribution(&self) -> &bool;
    fn uniform_distribution_mut(&mut self) -> &mut bool;
    fn disable_output_on_trigger(&self) -> &bool;
    fn disable_output_on_trigger_mut(&mut self) -> &mut bool;
    fn reset_outputs_when_all_has_triggered(&self) -> &bool;
    fn reset_outputs_when_all_has_triggered_mut(&mut self) -> &mut bool;
    fn random_event_weight(&self) -> &Vec<f32>;
    fn random_event_weight_mut(&mut self) -> &mut Vec<f32>;
    fn true_random(&self) -> &bool;
    fn true_random_mut(&mut self) -> &mut bool;
}

impl RandomMultiEventEntityDataTrait for RandomMultiEventEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn uniform_distribution(&self) -> &bool {
        &self.uniform_distribution
    }
    fn uniform_distribution_mut(&mut self) -> &mut bool {
        &mut self.uniform_distribution
    }
    fn disable_output_on_trigger(&self) -> &bool {
        &self.disable_output_on_trigger
    }
    fn disable_output_on_trigger_mut(&mut self) -> &mut bool {
        &mut self.disable_output_on_trigger
    }
    fn reset_outputs_when_all_has_triggered(&self) -> &bool {
        &self.reset_outputs_when_all_has_triggered
    }
    fn reset_outputs_when_all_has_triggered_mut(&mut self) -> &mut bool {
        &mut self.reset_outputs_when_all_has_triggered
    }
    fn random_event_weight(&self) -> &Vec<f32> {
        &self.random_event_weight
    }
    fn random_event_weight_mut(&mut self) -> &mut Vec<f32> {
        &mut self.random_event_weight
    }
    fn true_random(&self) -> &bool {
        &self.true_random
    }
    fn true_random_mut(&mut self) -> &mut bool {
        &mut self.true_random
    }
}

impl EntityDataTrait for RandomMultiEventEntityData {
}

impl GameObjectDataTrait for RandomMultiEventEntityData {
}

impl super::core::DataBusPeerTrait for RandomMultiEventEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for RandomMultiEventEntityData {
}

impl super::core::DataContainerTrait for RandomMultiEventEntityData {
}

pub static RANDOMMULTIEVENTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RandomMultiEventEntityData",
    name_hash: 3195699440,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(RandomMultiEventEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RandomMultiEventEntityData as Default>::default())),
            create_boxed: || Box::new(<RandomMultiEventEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(RandomMultiEventEntityData, realm),
            },
            FieldInfoData {
                name: "UniformDistribution",
                name_hash: 3070004891,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RandomMultiEventEntityData, uniform_distribution),
            },
            FieldInfoData {
                name: "DisableOutputOnTrigger",
                name_hash: 1250184567,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RandomMultiEventEntityData, disable_output_on_trigger),
            },
            FieldInfoData {
                name: "ResetOutputsWhenAllHasTriggered",
                name_hash: 386838442,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RandomMultiEventEntityData, reset_outputs_when_all_has_triggered),
            },
            FieldInfoData {
                name: "RandomEventWeight",
                name_hash: 2700434098,
                flags: MemberInfoFlags::new(144),
                field_type: "Float32-Array",
                rust_offset: offset_of!(RandomMultiEventEntityData, random_event_weight),
            },
            FieldInfoData {
                name: "TrueRandom",
                name_hash: 856584456,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RandomMultiEventEntityData, true_random),
            },
        ],
    }),
    array_type: Some(RANDOMMULTIEVENTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RandomMultiEventEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        RANDOMMULTIEVENTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RANDOMMULTIEVENTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RandomMultiEventEntityData-Array",
    name_hash: 1242881732,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("RandomMultiEventEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct RandomEventEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub probability: i32,
    pub randomize_first_only: bool,
    pub auto_start: bool,
}

pub trait RandomEventEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn probability(&self) -> &i32;
    fn probability_mut(&mut self) -> &mut i32;
    fn randomize_first_only(&self) -> &bool;
    fn randomize_first_only_mut(&mut self) -> &mut bool;
    fn auto_start(&self) -> &bool;
    fn auto_start_mut(&mut self) -> &mut bool;
}

impl RandomEventEntityDataTrait for RandomEventEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn probability(&self) -> &i32 {
        &self.probability
    }
    fn probability_mut(&mut self) -> &mut i32 {
        &mut self.probability
    }
    fn randomize_first_only(&self) -> &bool {
        &self.randomize_first_only
    }
    fn randomize_first_only_mut(&mut self) -> &mut bool {
        &mut self.randomize_first_only
    }
    fn auto_start(&self) -> &bool {
        &self.auto_start
    }
    fn auto_start_mut(&mut self) -> &mut bool {
        &mut self.auto_start
    }
}

impl EntityDataTrait for RandomEventEntityData {
}

impl GameObjectDataTrait for RandomEventEntityData {
}

impl super::core::DataBusPeerTrait for RandomEventEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for RandomEventEntityData {
}

impl super::core::DataContainerTrait for RandomEventEntityData {
}

pub static RANDOMEVENTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RandomEventEntityData",
    name_hash: 3660772473,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(RandomEventEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RandomEventEntityData as Default>::default())),
            create_boxed: || Box::new(<RandomEventEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(RandomEventEntityData, realm),
            },
            FieldInfoData {
                name: "Probability",
                name_hash: 35957416,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(RandomEventEntityData, probability),
            },
            FieldInfoData {
                name: "RandomizeFirstOnly",
                name_hash: 882338790,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RandomEventEntityData, randomize_first_only),
            },
            FieldInfoData {
                name: "AutoStart",
                name_hash: 792615882,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RandomEventEntityData, auto_start),
            },
        ],
    }),
    array_type: Some(RANDOMEVENTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RandomEventEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        RANDOMEVENTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RANDOMEVENTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RandomEventEntityData-Array",
    name_hash: 1604375373,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("RandomEventEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct LocatorEntityData {
    pub _glacier_base: SpatialEntityData,
    pub realm: super::core::Realm,
}

pub trait LocatorEntityDataTrait: SpatialEntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
}

impl LocatorEntityDataTrait for LocatorEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
}

impl SpatialEntityDataTrait for LocatorEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl EntityDataTrait for LocatorEntityData {
}

impl GameObjectDataTrait for LocatorEntityData {
}

impl super::core::DataBusPeerTrait for LocatorEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for LocatorEntityData {
}

impl super::core::DataContainerTrait for LocatorEntityData {
}

pub static LOCATORENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocatorEntityData",
    name_hash: 2361973798,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SPATIALENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(LocatorEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LocatorEntityData as Default>::default())),
            create_boxed: || Box::new(<LocatorEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(LocatorEntityData, realm),
            },
        ],
    }),
    array_type: Some(LOCATORENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for LocatorEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        LOCATORENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LOCATORENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocatorEntityData-Array",
    name_hash: 1102317714,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("LocatorEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CountDownEntityData {
    pub _glacier_base: EntityData,
    pub start_value: i32,
    pub run_once: bool,
    pub realm: super::core::Realm,
}

pub trait CountDownEntityDataTrait: EntityDataTrait {
    fn start_value(&self) -> &i32;
    fn start_value_mut(&mut self) -> &mut i32;
    fn run_once(&self) -> &bool;
    fn run_once_mut(&mut self) -> &mut bool;
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
}

impl CountDownEntityDataTrait for CountDownEntityData {
    fn start_value(&self) -> &i32 {
        &self.start_value
    }
    fn start_value_mut(&mut self) -> &mut i32 {
        &mut self.start_value
    }
    fn run_once(&self) -> &bool {
        &self.run_once
    }
    fn run_once_mut(&mut self) -> &mut bool {
        &mut self.run_once
    }
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
}

impl EntityDataTrait for CountDownEntityData {
}

impl GameObjectDataTrait for CountDownEntityData {
}

impl super::core::DataBusPeerTrait for CountDownEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CountDownEntityData {
}

impl super::core::DataContainerTrait for CountDownEntityData {
}

pub static COUNTDOWNENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CountDownEntityData",
    name_hash: 3093780031,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(CountDownEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CountDownEntityData as Default>::default())),
            create_boxed: || Box::new(<CountDownEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "StartValue",
                name_hash: 2748522638,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CountDownEntityData, start_value),
            },
            FieldInfoData {
                name: "RunOnce",
                name_hash: 709901739,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CountDownEntityData, run_once),
            },
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(CountDownEntityData, realm),
            },
        ],
    }),
    array_type: Some(COUNTDOWNENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CountDownEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        COUNTDOWNENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COUNTDOWNENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CountDownEntityData-Array",
    name_hash: 1404005259,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CountDownEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct MathEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub evaluate_on_event: bool,
    pub assembly: MathEntityAssembly,
}

pub trait MathEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn evaluate_on_event(&self) -> &bool;
    fn evaluate_on_event_mut(&mut self) -> &mut bool;
    fn assembly(&self) -> &MathEntityAssembly;
    fn assembly_mut(&mut self) -> &mut MathEntityAssembly;
}

impl MathEntityDataTrait for MathEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn evaluate_on_event(&self) -> &bool {
        &self.evaluate_on_event
    }
    fn evaluate_on_event_mut(&mut self) -> &mut bool {
        &mut self.evaluate_on_event
    }
    fn assembly(&self) -> &MathEntityAssembly {
        &self.assembly
    }
    fn assembly_mut(&mut self) -> &mut MathEntityAssembly {
        &mut self.assembly
    }
}

impl EntityDataTrait for MathEntityData {
}

impl GameObjectDataTrait for MathEntityData {
}

impl super::core::DataBusPeerTrait for MathEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for MathEntityData {
}

impl super::core::DataContainerTrait for MathEntityData {
}

pub static MATHENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MathEntityData",
    name_hash: 3445723838,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(MathEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MathEntityData as Default>::default())),
            create_boxed: || Box::new(<MathEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(MathEntityData, realm),
            },
            FieldInfoData {
                name: "EvaluateOnEvent",
                name_hash: 3873438067,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MathEntityData, evaluate_on_event),
            },
            FieldInfoData {
                name: "Assembly",
                name_hash: 1932338331,
                flags: MemberInfoFlags::new(0),
                field_type: "MathEntityAssembly",
                rust_offset: offset_of!(MathEntityData, assembly),
            },
        ],
    }),
    array_type: Some(MATHENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MathEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        MATHENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MATHENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MathEntityData-Array",
    name_hash: 179159818,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("MathEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct MathEntityAssembly {
    pub function_calls: Vec<BoxedTypeObject /* MathEntityFunctionCall */>,
    pub instructions: Vec<BoxedTypeObject /* MathEntityInstruction */>,
}

pub trait MathEntityAssemblyTrait: TypeObject {
    fn function_calls(&self) -> &Vec<BoxedTypeObject /* MathEntityFunctionCall */>;
    fn function_calls_mut(&mut self) -> &mut Vec<BoxedTypeObject /* MathEntityFunctionCall */>;
    fn instructions(&self) -> &Vec<BoxedTypeObject /* MathEntityInstruction */>;
    fn instructions_mut(&mut self) -> &mut Vec<BoxedTypeObject /* MathEntityInstruction */>;
}

impl MathEntityAssemblyTrait for MathEntityAssembly {
    fn function_calls(&self) -> &Vec<BoxedTypeObject /* MathEntityFunctionCall */> {
        &self.function_calls
    }
    fn function_calls_mut(&mut self) -> &mut Vec<BoxedTypeObject /* MathEntityFunctionCall */> {
        &mut self.function_calls
    }
    fn instructions(&self) -> &Vec<BoxedTypeObject /* MathEntityInstruction */> {
        &self.instructions
    }
    fn instructions_mut(&mut self) -> &mut Vec<BoxedTypeObject /* MathEntityInstruction */> {
        &mut self.instructions
    }
}

pub static MATHENTITYASSEMBLY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MathEntityAssembly",
    name_hash: 2722303504,
    flags: MemberInfoFlags::new(73),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MathEntityAssembly as Default>::default())),
            create_boxed: || Box::new(<MathEntityAssembly as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "FunctionCalls",
                name_hash: 2744929814,
                flags: MemberInfoFlags::new(144),
                field_type: "MathEntityFunctionCall-Array",
                rust_offset: offset_of!(MathEntityAssembly, function_calls),
            },
            FieldInfoData {
                name: "Instructions",
                name_hash: 1315118574,
                flags: MemberInfoFlags::new(144),
                field_type: "MathEntityInstruction-Array",
                rust_offset: offset_of!(MathEntityAssembly, instructions),
            },
        ],
    }),
    array_type: Some(MATHENTITYASSEMBLY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MathEntityAssembly {
    fn type_info(&self) -> &'static TypeInfo {
        MATHENTITYASSEMBLY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MATHENTITYASSEMBLY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MathEntityAssembly-Array",
    name_hash: 3959880740,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("MathEntityAssembly"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum MathEntityType {
    #[default]
    MathEntityType_Bool = 1,
    MathEntityType_Int = 2,
    MathEntityType_Float = 4,
    MathEntityType_Vec2 = 8,
    MathEntityType_Vec3 = 16,
    MathEntityType_Vec4 = 32,
    MathEntityType_Transform = 64,
}

pub static MATHENTITYTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MathEntityType",
    name_hash: 3446272566,
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(MATHENTITYTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for MathEntityType {
    fn type_info(&self) -> &'static TypeInfo {
        MATHENTITYTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MATHENTITYTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MathEntityType-Array",
    name_hash: 132146818,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("MathEntityType"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct MathEntityFunctionCall {
    pub parameters: Vec<u32>,
}

pub trait MathEntityFunctionCallTrait: TypeObject {
    fn parameters(&self) -> &Vec<u32>;
    fn parameters_mut(&mut self) -> &mut Vec<u32>;
}

impl MathEntityFunctionCallTrait for MathEntityFunctionCall {
    fn parameters(&self) -> &Vec<u32> {
        &self.parameters
    }
    fn parameters_mut(&mut self) -> &mut Vec<u32> {
        &mut self.parameters
    }
}

pub static MATHENTITYFUNCTIONCALL_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MathEntityFunctionCall",
    name_hash: 2165835214,
    flags: MemberInfoFlags::new(73),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MathEntityFunctionCall as Default>::default())),
            create_boxed: || Box::new(<MathEntityFunctionCall as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Parameters",
                name_hash: 3325515039,
                flags: MemberInfoFlags::new(144),
                field_type: "Uint32-Array",
                rust_offset: offset_of!(MathEntityFunctionCall, parameters),
            },
        ],
    }),
    array_type: Some(MATHENTITYFUNCTIONCALL_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MathEntityFunctionCall {
    fn type_info(&self) -> &'static TypeInfo {
        MATHENTITYFUNCTIONCALL_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MATHENTITYFUNCTIONCALL_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MathEntityFunctionCall-Array",
    name_hash: 4249845626,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("MathEntityFunctionCall"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct MathEntityInstruction {
    pub code: MathOpCode,
    pub result: i32,
    pub param1: i32,
    pub param2: i32,
}

pub trait MathEntityInstructionTrait: TypeObject {
    fn code(&self) -> &MathOpCode;
    fn code_mut(&mut self) -> &mut MathOpCode;
    fn result(&self) -> &i32;
    fn result_mut(&mut self) -> &mut i32;
    fn param1(&self) -> &i32;
    fn param1_mut(&mut self) -> &mut i32;
    fn param2(&self) -> &i32;
    fn param2_mut(&mut self) -> &mut i32;
}

impl MathEntityInstructionTrait for MathEntityInstruction {
    fn code(&self) -> &MathOpCode {
        &self.code
    }
    fn code_mut(&mut self) -> &mut MathOpCode {
        &mut self.code
    }
    fn result(&self) -> &i32 {
        &self.result
    }
    fn result_mut(&mut self) -> &mut i32 {
        &mut self.result
    }
    fn param1(&self) -> &i32 {
        &self.param1
    }
    fn param1_mut(&mut self) -> &mut i32 {
        &mut self.param1
    }
    fn param2(&self) -> &i32 {
        &self.param2
    }
    fn param2_mut(&mut self) -> &mut i32 {
        &mut self.param2
    }
}

pub static MATHENTITYINSTRUCTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MathEntityInstruction",
    name_hash: 83805718,
    flags: MemberInfoFlags::new(36937),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MathEntityInstruction as Default>::default())),
            create_boxed: || Box::new(<MathEntityInstruction as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Code",
                name_hash: 2088844616,
                flags: MemberInfoFlags::new(0),
                field_type: "MathOpCode",
                rust_offset: offset_of!(MathEntityInstruction, code),
            },
            FieldInfoData {
                name: "Result",
                name_hash: 3293273164,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MathEntityInstruction, result),
            },
            FieldInfoData {
                name: "Param1",
                name_hash: 3371566619,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MathEntityInstruction, param1),
            },
            FieldInfoData {
                name: "Param2",
                name_hash: 3371566616,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MathEntityInstruction, param2),
            },
        ],
    }),
    array_type: Some(MATHENTITYINSTRUCTION_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for MathEntityInstruction {
    fn type_info(&self) -> &'static TypeInfo {
        MATHENTITYINSTRUCTION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MATHENTITYINSTRUCTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MathEntityInstruction-Array",
    name_hash: 3315112738,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("MathEntityInstruction"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum MathOpCode {
    #[default]
    MathOpCode_ConstB = 0,
    MathOpCode_ConstI = 1,
    MathOpCode_ConstF = 2,
    MathOpCode_InputB = 3,
    MathOpCode_InputI = 4,
    MathOpCode_InputF = 5,
    MathOpCode_InputV2 = 6,
    MathOpCode_InputV3 = 7,
    MathOpCode_InputV4 = 8,
    MathOpCode_InputT = 9,
    MathOpCode_OrB = 10,
    MathOpCode_AndB = 11,
    MathOpCode_GreaterI = 12,
    MathOpCode_GreaterF = 13,
    MathOpCode_GreaterEqI = 14,
    MathOpCode_GreaterEqF = 15,
    MathOpCode_LessI = 16,
    MathOpCode_LessF = 17,
    MathOpCode_LessEqI = 18,
    MathOpCode_LessEqF = 19,
    MathOpCode_NotEqI = 20,
    MathOpCode_NotEqF = 21,
    MathOpCode_NotEqB = 22,
    MathOpCode_EqI = 23,
    MathOpCode_EqF = 24,
    MathOpCode_EqB = 25,
    MathOpCode_AddI = 26,
    MathOpCode_AddF = 27,
    MathOpCode_AddV2 = 28,
    MathOpCode_AddV3 = 29,
    MathOpCode_AddV4 = 30,
    MathOpCode_SubI = 31,
    MathOpCode_SubF = 32,
    MathOpCode_SubV2 = 33,
    MathOpCode_SubV3 = 34,
    MathOpCode_SubV4 = 35,
    MathOpCode_MulF = 36,
    MathOpCode_MulI = 37,
    MathOpCode_MulV2F = 38,
    MathOpCode_MulV3F = 39,
    MathOpCode_MulV4F = 40,
    MathOpCode_MulV2I = 41,
    MathOpCode_MulV3I = 42,
    MathOpCode_MulV4I = 43,
    MathOpCode_MulT = 44,
    MathOpCode_DivI = 45,
    MathOpCode_DivF = 46,
    MathOpCode_DivV2F = 47,
    MathOpCode_DivV3F = 48,
    MathOpCode_DivV4F = 49,
    MathOpCode_DivV2I = 50,
    MathOpCode_DivV3I = 51,
    MathOpCode_DivV4I = 52,
    MathOpCode_ModI = 53,
    MathOpCode_ModF = 54,
    MathOpCode_NegI = 55,
    MathOpCode_NegF = 56,
    MathOpCode_NegV2 = 57,
    MathOpCode_NegV3 = 58,
    MathOpCode_NegV4 = 59,
    MathOpCode_NotB = 60,
    MathOpCode_PowI = 61,
    MathOpCode_PowF = 62,
    MathOpCode_FieldV2 = 63,
    MathOpCode_FieldV3 = 64,
    MathOpCode_FieldV4 = 65,
    MathOpCode_FieldT = 66,
    MathOpCode_Func = 67,
    MathOpCode_Return = 68,
}

pub static MATHOPCODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MathOpCode",
    name_hash: 1680922631,
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(MATHOPCODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for MathOpCode {
    fn type_info(&self) -> &'static TypeInfo {
        MATHOPCODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MATHOPCODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MathOpCode-Array",
    name_hash: 3344201907,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("MathOpCode"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct Or4EntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub in1: bool,
    pub in2: bool,
    pub in3: bool,
    pub in4: bool,
}

pub trait Or4EntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn in1(&self) -> &bool;
    fn in1_mut(&mut self) -> &mut bool;
    fn in2(&self) -> &bool;
    fn in2_mut(&mut self) -> &mut bool;
    fn in3(&self) -> &bool;
    fn in3_mut(&mut self) -> &mut bool;
    fn in4(&self) -> &bool;
    fn in4_mut(&mut self) -> &mut bool;
}

impl Or4EntityDataTrait for Or4EntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn in1(&self) -> &bool {
        &self.in1
    }
    fn in1_mut(&mut self) -> &mut bool {
        &mut self.in1
    }
    fn in2(&self) -> &bool {
        &self.in2
    }
    fn in2_mut(&mut self) -> &mut bool {
        &mut self.in2
    }
    fn in3(&self) -> &bool {
        &self.in3
    }
    fn in3_mut(&mut self) -> &mut bool {
        &mut self.in3
    }
    fn in4(&self) -> &bool {
        &self.in4
    }
    fn in4_mut(&mut self) -> &mut bool {
        &mut self.in4
    }
}

impl EntityDataTrait for Or4EntityData {
}

impl GameObjectDataTrait for Or4EntityData {
}

impl super::core::DataBusPeerTrait for Or4EntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for Or4EntityData {
}

impl super::core::DataContainerTrait for Or4EntityData {
}

pub static OR4ENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Or4EntityData",
    name_hash: 2872104391,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(Or4EntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Or4EntityData as Default>::default())),
            create_boxed: || Box::new(<Or4EntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(Or4EntityData, realm),
            },
            FieldInfoData {
                name: "In1",
                name_hash: 193450867,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(Or4EntityData, in1),
            },
            FieldInfoData {
                name: "In2",
                name_hash: 193450864,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(Or4EntityData, in2),
            },
            FieldInfoData {
                name: "In3",
                name_hash: 193450865,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(Or4EntityData, in3),
            },
            FieldInfoData {
                name: "In4",
                name_hash: 193450870,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(Or4EntityData, in4),
            },
        ],
    }),
    array_type: Some(OR4ENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for Or4EntityData {
    fn type_info(&self) -> &'static TypeInfo {
        OR4ENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static OR4ENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Or4EntityData-Array",
    name_hash: 301696755,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Or4EntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct XorEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub in1: bool,
    pub in2: bool,
}

pub trait XorEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn in1(&self) -> &bool;
    fn in1_mut(&mut self) -> &mut bool;
    fn in2(&self) -> &bool;
    fn in2_mut(&mut self) -> &mut bool;
}

impl XorEntityDataTrait for XorEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn in1(&self) -> &bool {
        &self.in1
    }
    fn in1_mut(&mut self) -> &mut bool {
        &mut self.in1
    }
    fn in2(&self) -> &bool {
        &self.in2
    }
    fn in2_mut(&mut self) -> &mut bool {
        &mut self.in2
    }
}

impl EntityDataTrait for XorEntityData {
}

impl GameObjectDataTrait for XorEntityData {
}

impl super::core::DataBusPeerTrait for XorEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for XorEntityData {
}

impl super::core::DataContainerTrait for XorEntityData {
}

pub static XORENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "XorEntityData",
    name_hash: 987676075,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(XorEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<XorEntityData as Default>::default())),
            create_boxed: || Box::new(<XorEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(XorEntityData, realm),
            },
            FieldInfoData {
                name: "In1",
                name_hash: 193450867,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(XorEntityData, in1),
            },
            FieldInfoData {
                name: "In2",
                name_hash: 193450864,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(XorEntityData, in2),
            },
        ],
    }),
    array_type: Some(XORENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for XorEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        XORENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static XORENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "XorEntityData-Array",
    name_hash: 3458465055,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("XorEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct OrEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub input_count: u32,
}

pub trait OrEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn input_count(&self) -> &u32;
    fn input_count_mut(&mut self) -> &mut u32;
}

impl OrEntityDataTrait for OrEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn input_count(&self) -> &u32 {
        &self.input_count
    }
    fn input_count_mut(&mut self) -> &mut u32 {
        &mut self.input_count
    }
}

impl EntityDataTrait for OrEntityData {
}

impl GameObjectDataTrait for OrEntityData {
}

impl super::core::DataBusPeerTrait for OrEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for OrEntityData {
}

impl super::core::DataContainerTrait for OrEntityData {
}

pub static ORENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OrEntityData",
    name_hash: 3239991987,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(OrEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<OrEntityData as Default>::default())),
            create_boxed: || Box::new(<OrEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(OrEntityData, realm),
            },
            FieldInfoData {
                name: "InputCount",
                name_hash: 1607263120,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(OrEntityData, input_count),
            },
        ],
    }),
    array_type: Some(ORENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for OrEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        ORENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ORENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OrEntityData-Array",
    name_hash: 3422078471,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("OrEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct BitwiseAndEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub value: i32,
    pub bit_shift_value: bool,
    pub and_value: i32,
    pub bit_shift_and_value: bool,
}

pub trait BitwiseAndEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn value(&self) -> &i32;
    fn value_mut(&mut self) -> &mut i32;
    fn bit_shift_value(&self) -> &bool;
    fn bit_shift_value_mut(&mut self) -> &mut bool;
    fn and_value(&self) -> &i32;
    fn and_value_mut(&mut self) -> &mut i32;
    fn bit_shift_and_value(&self) -> &bool;
    fn bit_shift_and_value_mut(&mut self) -> &mut bool;
}

impl BitwiseAndEntityDataTrait for BitwiseAndEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn value(&self) -> &i32 {
        &self.value
    }
    fn value_mut(&mut self) -> &mut i32 {
        &mut self.value
    }
    fn bit_shift_value(&self) -> &bool {
        &self.bit_shift_value
    }
    fn bit_shift_value_mut(&mut self) -> &mut bool {
        &mut self.bit_shift_value
    }
    fn and_value(&self) -> &i32 {
        &self.and_value
    }
    fn and_value_mut(&mut self) -> &mut i32 {
        &mut self.and_value
    }
    fn bit_shift_and_value(&self) -> &bool {
        &self.bit_shift_and_value
    }
    fn bit_shift_and_value_mut(&mut self) -> &mut bool {
        &mut self.bit_shift_and_value
    }
}

impl EntityDataTrait for BitwiseAndEntityData {
}

impl GameObjectDataTrait for BitwiseAndEntityData {
}

impl super::core::DataBusPeerTrait for BitwiseAndEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for BitwiseAndEntityData {
}

impl super::core::DataContainerTrait for BitwiseAndEntityData {
}

pub static BITWISEANDENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BitwiseAndEntityData",
    name_hash: 1050346034,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(BitwiseAndEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BitwiseAndEntityData as Default>::default())),
            create_boxed: || Box::new(<BitwiseAndEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(BitwiseAndEntityData, realm),
            },
            FieldInfoData {
                name: "Value",
                name_hash: 225375086,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(BitwiseAndEntityData, value),
            },
            FieldInfoData {
                name: "BitShiftValue",
                name_hash: 4035582033,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BitwiseAndEntityData, bit_shift_value),
            },
            FieldInfoData {
                name: "AndValue",
                name_hash: 1255941413,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(BitwiseAndEntityData, and_value),
            },
            FieldInfoData {
                name: "BitShiftAndValue",
                name_hash: 657097082,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BitwiseAndEntityData, bit_shift_and_value),
            },
        ],
    }),
    array_type: Some(BITWISEANDENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BitwiseAndEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        BITWISEANDENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BITWISEANDENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BitwiseAndEntityData-Array",
    name_hash: 1549650054,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("BitwiseAndEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct AndEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub input_count: u32,
}

pub trait AndEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn input_count(&self) -> &u32;
    fn input_count_mut(&mut self) -> &mut u32;
}

impl AndEntityDataTrait for AndEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn input_count(&self) -> &u32 {
        &self.input_count
    }
    fn input_count_mut(&mut self) -> &mut u32 {
        &mut self.input_count
    }
}

impl EntityDataTrait for AndEntityData {
}

impl GameObjectDataTrait for AndEntityData {
}

impl super::core::DataBusPeerTrait for AndEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AndEntityData {
}

impl super::core::DataContainerTrait for AndEntityData {
}

pub static ANDENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AndEntityData",
    name_hash: 3199877509,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(AndEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AndEntityData as Default>::default())),
            create_boxed: || Box::new(<AndEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(AndEntityData, realm),
            },
            FieldInfoData {
                name: "InputCount",
                name_hash: 1607263120,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(AndEntityData, input_count),
            },
        ],
    }),
    array_type: Some(ANDENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AndEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        ANDENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANDENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AndEntityData-Array",
    name_hash: 2859370801,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("AndEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct NotEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub r#in: bool,
}

pub trait NotEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn r#in(&self) -> &bool;
    fn r#in_mut(&mut self) -> &mut bool;
}

impl NotEntityDataTrait for NotEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn r#in(&self) -> &bool {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut bool {
        &mut self.r#in
    }
}

impl EntityDataTrait for NotEntityData {
}

impl GameObjectDataTrait for NotEntityData {
}

impl super::core::DataBusPeerTrait for NotEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for NotEntityData {
}

impl super::core::DataContainerTrait for NotEntityData {
}

pub static NOTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NotEntityData",
    name_hash: 1364427067,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(NotEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<NotEntityData as Default>::default())),
            create_boxed: || Box::new(<NotEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(NotEntityData, realm),
            },
            FieldInfoData {
                name: "In",
                name_hash: 5862146,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(NotEntityData, r#in),
            },
        ],
    }),
    array_type: Some(NOTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for NotEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        NOTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static NOTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NotEntityData-Array",
    name_hash: 3566217359,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("NotEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CreateSchematicsInstanceEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub asset: Option<LockedTypeObject /* super::schematics::SchematicsBaseAsset */>,
}

pub trait CreateSchematicsInstanceEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn asset(&self) -> &Option<LockedTypeObject /* super::schematics::SchematicsBaseAsset */>;
    fn asset_mut(&mut self) -> &mut Option<LockedTypeObject /* super::schematics::SchematicsBaseAsset */>;
}

impl CreateSchematicsInstanceEntityDataTrait for CreateSchematicsInstanceEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn asset(&self) -> &Option<LockedTypeObject /* super::schematics::SchematicsBaseAsset */> {
        &self.asset
    }
    fn asset_mut(&mut self) -> &mut Option<LockedTypeObject /* super::schematics::SchematicsBaseAsset */> {
        &mut self.asset
    }
}

impl EntityDataTrait for CreateSchematicsInstanceEntityData {
}

impl GameObjectDataTrait for CreateSchematicsInstanceEntityData {
}

impl super::core::DataBusPeerTrait for CreateSchematicsInstanceEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CreateSchematicsInstanceEntityData {
}

impl super::core::DataContainerTrait for CreateSchematicsInstanceEntityData {
}

pub static CREATESCHEMATICSINSTANCEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CreateSchematicsInstanceEntityData",
    name_hash: 384705151,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(CreateSchematicsInstanceEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CreateSchematicsInstanceEntityData as Default>::default())),
            create_boxed: || Box::new(<CreateSchematicsInstanceEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(CreateSchematicsInstanceEntityData, realm),
            },
            FieldInfoData {
                name: "Asset",
                name_hash: 205976053,
                flags: MemberInfoFlags::new(0),
                field_type: "SchematicsBaseAsset",
                rust_offset: offset_of!(CreateSchematicsInstanceEntityData, asset),
            },
        ],
    }),
    array_type: Some(CREATESCHEMATICSINSTANCEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CreateSchematicsInstanceEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CREATESCHEMATICSINSTANCEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CREATESCHEMATICSINSTANCEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CreateSchematicsInstanceEntityData-Array",
    name_hash: 2926733387,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CreateSchematicsInstanceEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct GetEntityBusEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
}

pub trait GetEntityBusEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
}

impl GetEntityBusEntityDataTrait for GetEntityBusEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
}

impl EntityDataTrait for GetEntityBusEntityData {
}

impl GameObjectDataTrait for GetEntityBusEntityData {
}

impl super::core::DataBusPeerTrait for GetEntityBusEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for GetEntityBusEntityData {
}

impl super::core::DataContainerTrait for GetEntityBusEntityData {
}

pub static GETENTITYBUSENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GetEntityBusEntityData",
    name_hash: 1995467079,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(GetEntityBusEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GetEntityBusEntityData as Default>::default())),
            create_boxed: || Box::new(<GetEntityBusEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(GetEntityBusEntityData, realm),
            },
        ],
    }),
    array_type: Some(GETENTITYBUSENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for GetEntityBusEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        GETENTITYBUSENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static GETENTITYBUSENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GetEntityBusEntityData-Array",
    name_hash: 2667297395,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("GetEntityBusEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct GetEntityEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub runtime_type: glacier_reflect::builtin::TypeRef,
}

pub trait GetEntityEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn runtime_type(&self) -> &glacier_reflect::builtin::TypeRef;
    fn runtime_type_mut(&mut self) -> &mut glacier_reflect::builtin::TypeRef;
}

impl GetEntityEntityDataTrait for GetEntityEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn runtime_type(&self) -> &glacier_reflect::builtin::TypeRef {
        &self.runtime_type
    }
    fn runtime_type_mut(&mut self) -> &mut glacier_reflect::builtin::TypeRef {
        &mut self.runtime_type
    }
}

impl EntityDataTrait for GetEntityEntityData {
}

impl GameObjectDataTrait for GetEntityEntityData {
}

impl super::core::DataBusPeerTrait for GetEntityEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for GetEntityEntityData {
}

impl super::core::DataContainerTrait for GetEntityEntityData {
}

pub static GETENTITYENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GetEntityEntityData",
    name_hash: 3698497315,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(GetEntityEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GetEntityEntityData as Default>::default())),
            create_boxed: || Box::new(<GetEntityEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(GetEntityEntityData, realm),
            },
            FieldInfoData {
                name: "RuntimeType",
                name_hash: 3219168833,
                flags: MemberInfoFlags::new(0),
                field_type: "TypeRef",
                rust_offset: offset_of!(GetEntityEntityData, runtime_type),
            },
        ],
    }),
    array_type: Some(GETENTITYENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for GetEntityEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        GETENTITYENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static GETENTITYENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GetEntityEntityData-Array",
    name_hash: 1779800727,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("GetEntityEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CallFunctionEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub function_type: glacier_reflect::builtin::TypeRef,
}

pub trait CallFunctionEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn function_type(&self) -> &glacier_reflect::builtin::TypeRef;
    fn function_type_mut(&mut self) -> &mut glacier_reflect::builtin::TypeRef;
}

impl CallFunctionEntityDataTrait for CallFunctionEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn function_type(&self) -> &glacier_reflect::builtin::TypeRef {
        &self.function_type
    }
    fn function_type_mut(&mut self) -> &mut glacier_reflect::builtin::TypeRef {
        &mut self.function_type
    }
}

impl EntityDataTrait for CallFunctionEntityData {
}

impl GameObjectDataTrait for CallFunctionEntityData {
}

impl super::core::DataBusPeerTrait for CallFunctionEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CallFunctionEntityData {
}

impl super::core::DataContainerTrait for CallFunctionEntityData {
}

pub static CALLFUNCTIONENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CallFunctionEntityData",
    name_hash: 3565403502,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(CallFunctionEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CallFunctionEntityData as Default>::default())),
            create_boxed: || Box::new(<CallFunctionEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(CallFunctionEntityData, realm),
            },
            FieldInfoData {
                name: "FunctionType",
                name_hash: 3597846399,
                flags: MemberInfoFlags::new(0),
                field_type: "TypeRef",
                rust_offset: offset_of!(CallFunctionEntityData, function_type),
            },
        ],
    }),
    array_type: Some(CALLFUNCTIONENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CallFunctionEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CALLFUNCTIONENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CALLFUNCTIONENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CallFunctionEntityData-Array",
    name_hash: 1410463322,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CallFunctionEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct EntityOwnerUid {
    pub id: u32,
}

pub trait EntityOwnerUidTrait: TypeObject {
    fn id(&self) -> &u32;
    fn id_mut(&mut self) -> &mut u32;
}

impl EntityOwnerUidTrait for EntityOwnerUid {
    fn id(&self) -> &u32 {
        &self.id
    }
    fn id_mut(&mut self) -> &mut u32 {
        &mut self.id
    }
}

pub static ENTITYOWNERUID_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityOwnerUid",
    name_hash: 4286675911,
    flags: MemberInfoFlags::new(36937),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EntityOwnerUid as Default>::default())),
            create_boxed: || Box::new(<EntityOwnerUid as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Id",
                name_hash: 5862152,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(EntityOwnerUid, id),
            },
        ],
    }),
    array_type: Some(ENTITYOWNERUID_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for EntityOwnerUid {
    fn type_info(&self) -> &'static TypeInfo {
        ENTITYOWNERUID_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ENTITYOWNERUID_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityOwnerUid-Array",
    name_hash: 2779819251,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EntityOwnerUid"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct EntityUid {
    pub id: u32,
}

pub trait EntityUidTrait: TypeObject {
    fn id(&self) -> &u32;
    fn id_mut(&mut self) -> &mut u32;
}

impl EntityUidTrait for EntityUid {
    fn id(&self) -> &u32 {
        &self.id
    }
    fn id_mut(&mut self) -> &mut u32 {
        &mut self.id
    }
}

pub static ENTITYUID_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityUid",
    name_hash: 572031270,
    flags: MemberInfoFlags::new(36937),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EntityUid as Default>::default())),
            create_boxed: || Box::new(<EntityUid as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Id",
                name_hash: 5862152,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(EntityUid, id),
            },
        ],
    }),
    array_type: Some(ENTITYUID_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for EntityUid {
    fn type_info(&self) -> &'static TypeInfo {
        ENTITYUID_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ENTITYUID_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityUid-Array",
    name_hash: 2674617746,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EntityUid"),
    array_type: None,
    alignment: 8,
};



pub static SETTRANSFORMSPACELOCALTRANSFORM_ENTITYTRANSFORMSPACE_LINEARTRANSFORM__TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SetTransformSpaceLocalTransform(EntityTransformSpace,LinearTransform)",
    name_hash: 2141132385,
    flags: MemberInfoFlags::new(793),
    module: "Entity",
    data: TypeInfoData::Unknown,
    array_type: None,
    alignment: 8,
};



pub static GETTRANSFORMSPACE_ENTITYTRANSFORMSPACE_ENTITY__TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GetTransformSpace(EntityTransformSpace,Entity)",
    name_hash: 2671631038,
    flags: MemberInfoFlags::new(793),
    module: "Entity",
    data: TypeInfoData::Unknown,
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum TransformSpaceChildControlSetting {
    #[default]
    TransformSpaceChildControlSetting_NoChildControl = 0,
    TransformSpaceChildControlSetting_ControlChildren = 1,
    TransformSpaceChildControlSetting_ControlChildrenAndLockTransforms = 2,
    TransformSpaceChildControlSetting_ControlDescendents = 3,
}

pub static TRANSFORMSPACECHILDCONTROLSETTING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformSpaceChildControlSetting",
    name_hash: 2062613078,
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(TRANSFORMSPACECHILDCONTROLSETTING_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for TransformSpaceChildControlSetting {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMSPACECHILDCONTROLSETTING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static TRANSFORMSPACECHILDCONTROLSETTING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformSpaceChildControlSetting-Array",
    name_hash: 2235645922,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TransformSpaceChildControlSetting"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum TransformSpaceSimulationSetting {
    #[default]
    TransformSpaceSimulationSetting_Default = 0,
    TransformSpaceSimulationSetting_Keyframed = 1,
}

pub static TRANSFORMSPACESIMULATIONSETTING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformSpaceSimulationSetting",
    name_hash: 101247112,
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(TRANSFORMSPACESIMULATIONSETTING_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for TransformSpaceSimulationSetting {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMSPACESIMULATIONSETTING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static TRANSFORMSPACESIMULATIONSETTING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformSpaceSimulationSetting-Array",
    name_hash: 1465076412,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TransformSpaceSimulationSetting"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct EntitySettings {
    pub _glacier_base: super::core::SystemSettings,
    pub editor_game_view_enable: bool,
    pub spawn_sub_levels_from_logic: bool,
    pub execution_mode: ExecutionModeType,
    pub out_of_entity_bus_network_id_threshold: u32,
    pub world_limit: f32,
    pub destroy_queued_entities_time: f32,
    pub sub_level_manager_create_sublevels_time: f32,
    pub sub_level_manager_destroy_sublevels_time: f32,
}

pub trait EntitySettingsTrait: super::core::SystemSettingsTrait {
    fn editor_game_view_enable(&self) -> &bool;
    fn editor_game_view_enable_mut(&mut self) -> &mut bool;
    fn spawn_sub_levels_from_logic(&self) -> &bool;
    fn spawn_sub_levels_from_logic_mut(&mut self) -> &mut bool;
    fn execution_mode(&self) -> &ExecutionModeType;
    fn execution_mode_mut(&mut self) -> &mut ExecutionModeType;
    fn out_of_entity_bus_network_id_threshold(&self) -> &u32;
    fn out_of_entity_bus_network_id_threshold_mut(&mut self) -> &mut u32;
    fn world_limit(&self) -> &f32;
    fn world_limit_mut(&mut self) -> &mut f32;
    fn destroy_queued_entities_time(&self) -> &f32;
    fn destroy_queued_entities_time_mut(&mut self) -> &mut f32;
    fn sub_level_manager_create_sublevels_time(&self) -> &f32;
    fn sub_level_manager_create_sublevels_time_mut(&mut self) -> &mut f32;
    fn sub_level_manager_destroy_sublevels_time(&self) -> &f32;
    fn sub_level_manager_destroy_sublevels_time_mut(&mut self) -> &mut f32;
}

impl EntitySettingsTrait for EntitySettings {
    fn editor_game_view_enable(&self) -> &bool {
        &self.editor_game_view_enable
    }
    fn editor_game_view_enable_mut(&mut self) -> &mut bool {
        &mut self.editor_game_view_enable
    }
    fn spawn_sub_levels_from_logic(&self) -> &bool {
        &self.spawn_sub_levels_from_logic
    }
    fn spawn_sub_levels_from_logic_mut(&mut self) -> &mut bool {
        &mut self.spawn_sub_levels_from_logic
    }
    fn execution_mode(&self) -> &ExecutionModeType {
        &self.execution_mode
    }
    fn execution_mode_mut(&mut self) -> &mut ExecutionModeType {
        &mut self.execution_mode
    }
    fn out_of_entity_bus_network_id_threshold(&self) -> &u32 {
        &self.out_of_entity_bus_network_id_threshold
    }
    fn out_of_entity_bus_network_id_threshold_mut(&mut self) -> &mut u32 {
        &mut self.out_of_entity_bus_network_id_threshold
    }
    fn world_limit(&self) -> &f32 {
        &self.world_limit
    }
    fn world_limit_mut(&mut self) -> &mut f32 {
        &mut self.world_limit
    }
    fn destroy_queued_entities_time(&self) -> &f32 {
        &self.destroy_queued_entities_time
    }
    fn destroy_queued_entities_time_mut(&mut self) -> &mut f32 {
        &mut self.destroy_queued_entities_time
    }
    fn sub_level_manager_create_sublevels_time(&self) -> &f32 {
        &self.sub_level_manager_create_sublevels_time
    }
    fn sub_level_manager_create_sublevels_time_mut(&mut self) -> &mut f32 {
        &mut self.sub_level_manager_create_sublevels_time
    }
    fn sub_level_manager_destroy_sublevels_time(&self) -> &f32 {
        &self.sub_level_manager_destroy_sublevels_time
    }
    fn sub_level_manager_destroy_sublevels_time_mut(&mut self) -> &mut f32 {
        &mut self.sub_level_manager_destroy_sublevels_time
    }
}

impl super::core::SystemSettingsTrait for EntitySettings {
    fn platform(&self) -> &super::core::GamePlatform {
        self._glacier_base.platform()
    }
    fn platform_mut(&mut self) -> &mut super::core::GamePlatform {
        self._glacier_base.platform_mut()
    }
}

impl super::core::DataContainerTrait for EntitySettings {
}

pub static ENTITYSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntitySettings",
    name_hash: 584462875,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::SYSTEMSETTINGS_TYPE_INFO),
        super_class_offset: offset_of!(EntitySettings, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EntitySettings as Default>::default())),
            create_boxed: || Box::new(<EntitySettings as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "EditorGameViewEnable",
                name_hash: 1497073094,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EntitySettings, editor_game_view_enable),
            },
            FieldInfoData {
                name: "SpawnSubLevelsFromLogic",
                name_hash: 1806867047,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EntitySettings, spawn_sub_levels_from_logic),
            },
            FieldInfoData {
                name: "ExecutionMode",
                name_hash: 3634549556,
                flags: MemberInfoFlags::new(0),
                field_type: "ExecutionModeType",
                rust_offset: offset_of!(EntitySettings, execution_mode),
            },
            FieldInfoData {
                name: "OutOfEntityBusNetworkIdThreshold",
                name_hash: 2379599769,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(EntitySettings, out_of_entity_bus_network_id_threshold),
            },
            FieldInfoData {
                name: "WorldLimit",
                name_hash: 624920306,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EntitySettings, world_limit),
            },
            FieldInfoData {
                name: "DestroyQueuedEntitiesTime",
                name_hash: 691928986,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EntitySettings, destroy_queued_entities_time),
            },
            FieldInfoData {
                name: "SubLevelManagerCreateSublevelsTime",
                name_hash: 2274244788,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EntitySettings, sub_level_manager_create_sublevels_time),
            },
            FieldInfoData {
                name: "SubLevelManagerDestroySublevelsTime",
                name_hash: 4086484690,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EntitySettings, sub_level_manager_destroy_sublevels_time),
            },
        ],
    }),
    array_type: Some(ENTITYSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EntitySettings {
    fn type_info(&self) -> &'static TypeInfo {
        ENTITYSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ENTITYSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntitySettings-Array",
    name_hash: 401066159,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EntitySettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum ExecutionModeType {
    #[default]
    ExecutionMode_Play = 0,
    ExecutionMode_GameView = 1,
    ExecutionMode_PlayFromHere = 2,
    ExecutionMode_FrostEdPlay = 3,
}

pub static EXECUTIONMODETYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExecutionModeType",
    name_hash: 1201160588,
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(EXECUTIONMODETYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for ExecutionModeType {
    fn type_info(&self) -> &'static TypeInfo {
        EXECUTIONMODETYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static EXECUTIONMODETYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExecutionModeType-Array",
    name_hash: 1753289144,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ExecutionModeType"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SwitchEnumEntity {
    pub _glacier_base: EnumLogicEntityWithSingleInput,
}

pub trait SwitchEnumEntityTrait: EnumLogicEntityWithSingleInputTrait {
}

impl SwitchEnumEntityTrait for SwitchEnumEntity {
}

impl EnumLogicEntityWithSingleInputTrait for SwitchEnumEntity {
}

impl EntityTrait for SwitchEnumEntity {
}

impl EntityBusPeerTrait for SwitchEnumEntity {
}

pub static SWITCHENUMENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SwitchEnumEntity",
    name_hash: 2635896511,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENUMLOGICENTITYWITHSINGLEINPUT_TYPE_INFO),
        super_class_offset: offset_of!(SwitchEnumEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SwitchEnumEntity as Default>::default())),
            create_boxed: || Box::new(<SwitchEnumEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(SWITCHENUMENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SwitchEnumEntity {
    fn type_info(&self) -> &'static TypeInfo {
        SWITCHENUMENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SWITCHENUMENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SwitchEnumEntity-Array",
    name_hash: 947063819,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SwitchEnumEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SetEnumEntity {
    pub _glacier_base: EnumLogicEntityWithSingleInput,
}

pub trait SetEnumEntityTrait: EnumLogicEntityWithSingleInputTrait {
}

impl SetEnumEntityTrait for SetEnumEntity {
}

impl EnumLogicEntityWithSingleInputTrait for SetEnumEntity {
}

impl EntityTrait for SetEnumEntity {
}

impl EntityBusPeerTrait for SetEnumEntity {
}

pub static SETENUMENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SetEnumEntity",
    name_hash: 2023729007,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENUMLOGICENTITYWITHSINGLEINPUT_TYPE_INFO),
        super_class_offset: offset_of!(SetEnumEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SetEnumEntity as Default>::default())),
            create_boxed: || Box::new(<SetEnumEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(SETENUMENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SetEnumEntity {
    fn type_info(&self) -> &'static TypeInfo {
        SETENUMENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SETENUMENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SetEnumEntity-Array",
    name_hash: 48293211,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SetEnumEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct IntToEnumEntity {
    pub _glacier_base: Entity,
}

pub trait IntToEnumEntityTrait: EntityTrait {
}

impl IntToEnumEntityTrait for IntToEnumEntity {
}

impl EntityTrait for IntToEnumEntity {
}

impl EntityBusPeerTrait for IntToEnumEntity {
}

pub static INTTOENUMENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntToEnumEntity",
    name_hash: 3477368229,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(IntToEnumEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<IntToEnumEntity as Default>::default())),
            create_boxed: || Box::new(<IntToEnumEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(INTTOENUMENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for IntToEnumEntity {
    fn type_info(&self) -> &'static TypeInfo {
        INTTOENUMENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static INTTOENUMENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntToEnumEntity-Array",
    name_hash: 2828371473,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("IntToEnumEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct EnumToStringEntity {
    pub _glacier_base: EnumLogicEntityWithSingleInput,
}

pub trait EnumToStringEntityTrait: EnumLogicEntityWithSingleInputTrait {
}

impl EnumToStringEntityTrait for EnumToStringEntity {
}

impl EnumLogicEntityWithSingleInputTrait for EnumToStringEntity {
}

impl EntityTrait for EnumToStringEntity {
}

impl EntityBusPeerTrait for EnumToStringEntity {
}

pub static ENUMTOSTRINGENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnumToStringEntity",
    name_hash: 2056685059,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENUMLOGICENTITYWITHSINGLEINPUT_TYPE_INFO),
        super_class_offset: offset_of!(EnumToStringEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EnumToStringEntity as Default>::default())),
            create_boxed: || Box::new(<EnumToStringEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(ENUMTOSTRINGENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for EnumToStringEntity {
    fn type_info(&self) -> &'static TypeInfo {
        ENUMTOSTRINGENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ENUMTOSTRINGENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnumToStringEntity-Array",
    name_hash: 1233451191,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EnumToStringEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct EnumToIntEntity {
    pub _glacier_base: EnumLogicEntityWithSingleInput,
}

pub trait EnumToIntEntityTrait: EnumLogicEntityWithSingleInputTrait {
}

impl EnumToIntEntityTrait for EnumToIntEntity {
}

impl EnumLogicEntityWithSingleInputTrait for EnumToIntEntity {
}

impl EntityTrait for EnumToIntEntity {
}

impl EntityBusPeerTrait for EnumToIntEntity {
}

pub static ENUMTOINTENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnumToIntEntity",
    name_hash: 2740852773,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENUMLOGICENTITYWITHSINGLEINPUT_TYPE_INFO),
        super_class_offset: offset_of!(EnumToIntEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EnumToIntEntity as Default>::default())),
            create_boxed: || Box::new(<EnumToIntEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(ENUMTOINTENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for EnumToIntEntity {
    fn type_info(&self) -> &'static TypeInfo {
        ENUMTOINTENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ENUMTOINTENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnumToIntEntity-Array",
    name_hash: 350556305,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EnumToIntEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct EnumPropertyGateEntity {
    pub _glacier_base: EnumLogicEntityWithSingleInput,
}

pub trait EnumPropertyGateEntityTrait: EnumLogicEntityWithSingleInputTrait {
}

impl EnumPropertyGateEntityTrait for EnumPropertyGateEntity {
}

impl EnumLogicEntityWithSingleInputTrait for EnumPropertyGateEntity {
}

impl EntityTrait for EnumPropertyGateEntity {
}

impl EntityBusPeerTrait for EnumPropertyGateEntity {
}

pub static ENUMPROPERTYGATEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnumPropertyGateEntity",
    name_hash: 2987584861,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENUMLOGICENTITYWITHSINGLEINPUT_TYPE_INFO),
        super_class_offset: offset_of!(EnumPropertyGateEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EnumPropertyGateEntity as Default>::default())),
            create_boxed: || Box::new(<EnumPropertyGateEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(ENUMPROPERTYGATEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for EnumPropertyGateEntity {
    fn type_info(&self) -> &'static TypeInfo {
        ENUMPROPERTYGATEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ENUMPROPERTYGATEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnumPropertyGateEntity-Array",
    name_hash: 2874616169,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EnumPropertyGateEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct EnumLogicEntityWithSingleInput {
    pub _glacier_base: Entity,
}

pub trait EnumLogicEntityWithSingleInputTrait: EntityTrait {
}

impl EnumLogicEntityWithSingleInputTrait for EnumLogicEntityWithSingleInput {
}

impl EntityTrait for EnumLogicEntityWithSingleInput {
}

impl EntityBusPeerTrait for EnumLogicEntityWithSingleInput {
}

pub static ENUMLOGICENTITYWITHSINGLEINPUT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnumLogicEntityWithSingleInput",
    name_hash: 3743472557,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(EnumLogicEntityWithSingleInput, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EnumLogicEntityWithSingleInput as Default>::default())),
            create_boxed: || Box::new(<EnumLogicEntityWithSingleInput as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(ENUMLOGICENTITYWITHSINGLEINPUT_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for EnumLogicEntityWithSingleInput {
    fn type_info(&self) -> &'static TypeInfo {
        ENUMLOGICENTITYWITHSINGLEINPUT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ENUMLOGICENTITYWITHSINGLEINPUT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnumLogicEntityWithSingleInput-Array",
    name_hash: 4127969305,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EnumLogicEntityWithSingleInput"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct EnumIntSourceEntity {
    pub _glacier_base: Entity,
}

pub trait EnumIntSourceEntityTrait: EntityTrait {
}

impl EnumIntSourceEntityTrait for EnumIntSourceEntity {
}

impl EntityTrait for EnumIntSourceEntity {
}

impl EntityBusPeerTrait for EnumIntSourceEntity {
}

pub static ENUMINTSOURCEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnumIntSourceEntity",
    name_hash: 3628216739,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(EnumIntSourceEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EnumIntSourceEntity as Default>::default())),
            create_boxed: || Box::new(<EnumIntSourceEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(ENUMINTSOURCEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for EnumIntSourceEntity {
    fn type_info(&self) -> &'static TypeInfo {
        ENUMINTSOURCEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ENUMINTSOURCEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnumIntSourceEntity-Array",
    name_hash: 3402568983,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EnumIntSourceEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CompareEnumEntity {
    pub _glacier_base: Entity,
}

pub trait CompareEnumEntityTrait: EntityTrait {
}

impl CompareEnumEntityTrait for CompareEnumEntity {
}

impl EntityTrait for CompareEnumEntity {
}

impl EntityBusPeerTrait for CompareEnumEntity {
}

pub static COMPAREENUMENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareEnumEntity",
    name_hash: 2738657578,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(CompareEnumEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareEnumEntity as Default>::default())),
            create_boxed: || Box::new(<CompareEnumEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(COMPAREENUMENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for CompareEnumEntity {
    fn type_info(&self) -> &'static TypeInfo {
        COMPAREENUMENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COMPAREENUMENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareEnumEntity-Array",
    name_hash: 42021790,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareEnumEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct EntityBusPeer {
}

pub trait EntityBusPeerTrait: TypeObject {
}

impl EntityBusPeerTrait for EntityBusPeer {
}

pub static ENTITYBUSPEER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityBusPeer",
    name_hash: 1583088120,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: None,
        super_class_offset: 0,
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EntityBusPeer as Default>::default())),
            create_boxed: || Box::new(<EntityBusPeer as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(ENTITYBUSPEER_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for EntityBusPeer {
    fn type_info(&self) -> &'static TypeInfo {
        ENTITYBUSPEER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ENTITYBUSPEER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityBusPeer-Array",
    name_hash: 3922885580,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EntityBusPeer"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct EntityEvent {
}

pub trait EntityEventTrait: TypeObject {
}

impl EntityEventTrait for EntityEvent {
}

pub static ENTITYEVENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityEvent",
    name_hash: 190648850,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: None,
        super_class_offset: 0,
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EntityEvent as Default>::default())),
            create_boxed: || Box::new(<EntityEvent as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(ENTITYEVENT_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for EntityEvent {
    fn type_info(&self) -> &'static TypeInfo {
        ENTITYEVENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ENTITYEVENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityEvent-Array",
    name_hash: 3275766054,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EntityEvent"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct EntityBus {
}

pub trait EntityBusTrait: TypeObject {
}

impl EntityBusTrait for EntityBus {
}

pub static ENTITYBUS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityBus",
    name_hash: 572055930,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: None,
        super_class_offset: 0,
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EntityBus as Default>::default())),
            create_boxed: || Box::new(<EntityBus as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(ENTITYBUS_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for EntityBus {
    fn type_info(&self) -> &'static TypeInfo {
        ENTITYBUS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ENTITYBUS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityBus-Array",
    name_hash: 2621781070,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EntityBus"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct DataSourceQueryEntity {
    pub _glacier_base: Entity,
}

pub trait DataSourceQueryEntityTrait: EntityTrait {
}

impl DataSourceQueryEntityTrait for DataSourceQueryEntity {
}

impl EntityTrait for DataSourceQueryEntity {
}

impl EntityBusPeerTrait for DataSourceQueryEntity {
}

pub static DATASOURCEQUERYENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DataSourceQueryEntity",
    name_hash: 2558048217,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(DataSourceQueryEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DataSourceQueryEntity as Default>::default())),
            create_boxed: || Box::new(<DataSourceQueryEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(DATASOURCEQUERYENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for DataSourceQueryEntity {
    fn type_info(&self) -> &'static TypeInfo {
        DATASOURCEQUERYENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DATASOURCEQUERYENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DataSourceQueryEntity-Array",
    name_hash: 3645580781,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("DataSourceQueryEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct EnumToStringData {
    pub _glacier_base: ImpliedEnumTypeLogicEntityData,
}

pub trait EnumToStringDataTrait: ImpliedEnumTypeLogicEntityDataTrait {
}

impl EnumToStringDataTrait for EnumToStringData {
}

impl ImpliedEnumTypeLogicEntityDataTrait for EnumToStringData {
}

impl EnumLogicEntityBaseDataTrait for EnumToStringData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn type_name_hash(&self) -> &u32 {
        self._glacier_base.type_name_hash()
    }
    fn type_name_hash_mut(&mut self) -> &mut u32 {
        self._glacier_base.type_name_hash_mut()
    }
}

impl EntityDataTrait for EnumToStringData {
}

impl GameObjectDataTrait for EnumToStringData {
}

impl super::core::DataBusPeerTrait for EnumToStringData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for EnumToStringData {
}

impl super::core::DataContainerTrait for EnumToStringData {
}

pub static ENUMTOSTRINGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnumToStringData",
    name_hash: 2108008360,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(IMPLIEDENUMTYPELOGICENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(EnumToStringData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EnumToStringData as Default>::default())),
            create_boxed: || Box::new(<EnumToStringData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(ENUMTOSTRINGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EnumToStringData {
    fn type_info(&self) -> &'static TypeInfo {
        ENUMTOSTRINGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ENUMTOSTRINGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnumToStringData-Array",
    name_hash: 3655510300,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EnumToStringData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct EnumToIntData {
    pub _glacier_base: ImpliedEnumTypeLogicEntityData,
}

pub trait EnumToIntDataTrait: ImpliedEnumTypeLogicEntityDataTrait {
}

impl EnumToIntDataTrait for EnumToIntData {
}

impl ImpliedEnumTypeLogicEntityDataTrait for EnumToIntData {
}

impl EnumLogicEntityBaseDataTrait for EnumToIntData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn type_name_hash(&self) -> &u32 {
        self._glacier_base.type_name_hash()
    }
    fn type_name_hash_mut(&mut self) -> &mut u32 {
        self._glacier_base.type_name_hash_mut()
    }
}

impl EntityDataTrait for EnumToIntData {
}

impl GameObjectDataTrait for EnumToIntData {
}

impl super::core::DataBusPeerTrait for EnumToIntData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for EnumToIntData {
}

impl super::core::DataContainerTrait for EnumToIntData {
}

pub static ENUMTOINTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnumToIntData",
    name_hash: 3051238094,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(IMPLIEDENUMTYPELOGICENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(EnumToIntData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EnumToIntData as Default>::default())),
            create_boxed: || Box::new(<EnumToIntData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(ENUMTOINTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EnumToIntData {
    fn type_info(&self) -> &'static TypeInfo {
        ENUMTOINTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ENUMTOINTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnumToIntData-Array",
    name_hash: 725838970,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EnumToIntData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct EnumPropertyGateEntityData {
    pub _glacier_base: ImpliedEnumTypeLogicEntityData,
    pub default: bool,
    pub write_property_on_open_gate: bool,
}

pub trait EnumPropertyGateEntityDataTrait: ImpliedEnumTypeLogicEntityDataTrait {
    fn default(&self) -> &bool;
    fn default_mut(&mut self) -> &mut bool;
    fn write_property_on_open_gate(&self) -> &bool;
    fn write_property_on_open_gate_mut(&mut self) -> &mut bool;
}

impl EnumPropertyGateEntityDataTrait for EnumPropertyGateEntityData {
    fn default(&self) -> &bool {
        &self.default
    }
    fn default_mut(&mut self) -> &mut bool {
        &mut self.default
    }
    fn write_property_on_open_gate(&self) -> &bool {
        &self.write_property_on_open_gate
    }
    fn write_property_on_open_gate_mut(&mut self) -> &mut bool {
        &mut self.write_property_on_open_gate
    }
}

impl ImpliedEnumTypeLogicEntityDataTrait for EnumPropertyGateEntityData {
}

impl EnumLogicEntityBaseDataTrait for EnumPropertyGateEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn type_name_hash(&self) -> &u32 {
        self._glacier_base.type_name_hash()
    }
    fn type_name_hash_mut(&mut self) -> &mut u32 {
        self._glacier_base.type_name_hash_mut()
    }
}

impl EntityDataTrait for EnumPropertyGateEntityData {
}

impl GameObjectDataTrait for EnumPropertyGateEntityData {
}

impl super::core::DataBusPeerTrait for EnumPropertyGateEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for EnumPropertyGateEntityData {
}

impl super::core::DataContainerTrait for EnumPropertyGateEntityData {
}

pub static ENUMPROPERTYGATEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnumPropertyGateEntityData",
    name_hash: 841908269,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(IMPLIEDENUMTYPELOGICENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(EnumPropertyGateEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EnumPropertyGateEntityData as Default>::default())),
            create_boxed: || Box::new(<EnumPropertyGateEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Default",
                name_hash: 3998752238,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EnumPropertyGateEntityData, default),
            },
            FieldInfoData {
                name: "WritePropertyOnOpenGate",
                name_hash: 3761162877,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EnumPropertyGateEntityData, write_property_on_open_gate),
            },
        ],
    }),
    array_type: Some(ENUMPROPERTYGATEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EnumPropertyGateEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        ENUMPROPERTYGATEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ENUMPROPERTYGATEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnumPropertyGateEntityData-Array",
    name_hash: 1793250457,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EnumPropertyGateEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct EnumDebugEntityData {
    pub _glacier_base: ImpliedEnumTypeLogicEntityData,
    pub text_color: super::core::Vec3,
    pub screen_position: super::core::Vec2,
    pub world_position: super::core::Vec3,
    pub value_prefix: String,
    pub multiline: bool,
    pub show_transform_in_world: bool,
    pub show_transform_coordinates: bool,
    pub default_visible: bool,
    pub text_scale: f32,
}

pub trait EnumDebugEntityDataTrait: ImpliedEnumTypeLogicEntityDataTrait {
    fn text_color(&self) -> &super::core::Vec3;
    fn text_color_mut(&mut self) -> &mut super::core::Vec3;
    fn screen_position(&self) -> &super::core::Vec2;
    fn screen_position_mut(&mut self) -> &mut super::core::Vec2;
    fn world_position(&self) -> &super::core::Vec3;
    fn world_position_mut(&mut self) -> &mut super::core::Vec3;
    fn value_prefix(&self) -> &String;
    fn value_prefix_mut(&mut self) -> &mut String;
    fn multiline(&self) -> &bool;
    fn multiline_mut(&mut self) -> &mut bool;
    fn show_transform_in_world(&self) -> &bool;
    fn show_transform_in_world_mut(&mut self) -> &mut bool;
    fn show_transform_coordinates(&self) -> &bool;
    fn show_transform_coordinates_mut(&mut self) -> &mut bool;
    fn default_visible(&self) -> &bool;
    fn default_visible_mut(&mut self) -> &mut bool;
    fn text_scale(&self) -> &f32;
    fn text_scale_mut(&mut self) -> &mut f32;
}

impl EnumDebugEntityDataTrait for EnumDebugEntityData {
    fn text_color(&self) -> &super::core::Vec3 {
        &self.text_color
    }
    fn text_color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.text_color
    }
    fn screen_position(&self) -> &super::core::Vec2 {
        &self.screen_position
    }
    fn screen_position_mut(&mut self) -> &mut super::core::Vec2 {
        &mut self.screen_position
    }
    fn world_position(&self) -> &super::core::Vec3 {
        &self.world_position
    }
    fn world_position_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.world_position
    }
    fn value_prefix(&self) -> &String {
        &self.value_prefix
    }
    fn value_prefix_mut(&mut self) -> &mut String {
        &mut self.value_prefix
    }
    fn multiline(&self) -> &bool {
        &self.multiline
    }
    fn multiline_mut(&mut self) -> &mut bool {
        &mut self.multiline
    }
    fn show_transform_in_world(&self) -> &bool {
        &self.show_transform_in_world
    }
    fn show_transform_in_world_mut(&mut self) -> &mut bool {
        &mut self.show_transform_in_world
    }
    fn show_transform_coordinates(&self) -> &bool {
        &self.show_transform_coordinates
    }
    fn show_transform_coordinates_mut(&mut self) -> &mut bool {
        &mut self.show_transform_coordinates
    }
    fn default_visible(&self) -> &bool {
        &self.default_visible
    }
    fn default_visible_mut(&mut self) -> &mut bool {
        &mut self.default_visible
    }
    fn text_scale(&self) -> &f32 {
        &self.text_scale
    }
    fn text_scale_mut(&mut self) -> &mut f32 {
        &mut self.text_scale
    }
}

impl ImpliedEnumTypeLogicEntityDataTrait for EnumDebugEntityData {
}

impl EnumLogicEntityBaseDataTrait for EnumDebugEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn type_name_hash(&self) -> &u32 {
        self._glacier_base.type_name_hash()
    }
    fn type_name_hash_mut(&mut self) -> &mut u32 {
        self._glacier_base.type_name_hash_mut()
    }
}

impl EntityDataTrait for EnumDebugEntityData {
}

impl GameObjectDataTrait for EnumDebugEntityData {
}

impl super::core::DataBusPeerTrait for EnumDebugEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for EnumDebugEntityData {
}

impl super::core::DataContainerTrait for EnumDebugEntityData {
}

pub static ENUMDEBUGENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnumDebugEntityData",
    name_hash: 4014315660,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(IMPLIEDENUMTYPELOGICENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(EnumDebugEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EnumDebugEntityData as Default>::default())),
            create_boxed: || Box::new(<EnumDebugEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "TextColor",
                name_hash: 2527550245,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(EnumDebugEntityData, text_color),
            },
            FieldInfoData {
                name: "ScreenPosition",
                name_hash: 2288910864,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(EnumDebugEntityData, screen_position),
            },
            FieldInfoData {
                name: "WorldPosition",
                name_hash: 2133906686,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(EnumDebugEntityData, world_position),
            },
            FieldInfoData {
                name: "ValuePrefix",
                name_hash: 1051050718,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(EnumDebugEntityData, value_prefix),
            },
            FieldInfoData {
                name: "Multiline",
                name_hash: 1101961090,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EnumDebugEntityData, multiline),
            },
            FieldInfoData {
                name: "ShowTransformInWorld",
                name_hash: 813393455,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EnumDebugEntityData, show_transform_in_world),
            },
            FieldInfoData {
                name: "ShowTransformCoordinates",
                name_hash: 3087196475,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EnumDebugEntityData, show_transform_coordinates),
            },
            FieldInfoData {
                name: "DefaultVisible",
                name_hash: 3341302816,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EnumDebugEntityData, default_visible),
            },
            FieldInfoData {
                name: "TextScale",
                name_hash: 2508713728,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EnumDebugEntityData, text_scale),
            },
        ],
    }),
    array_type: Some(ENUMDEBUGENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for EnumDebugEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        ENUMDEBUGENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ENUMDEBUGENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnumDebugEntityData-Array",
    name_hash: 1754507448,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EnumDebugEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ImpliedEnumTypeLogicEntityData {
    pub _glacier_base: EnumLogicEntityBaseData,
}

pub trait ImpliedEnumTypeLogicEntityDataTrait: EnumLogicEntityBaseDataTrait {
}

impl ImpliedEnumTypeLogicEntityDataTrait for ImpliedEnumTypeLogicEntityData {
}

impl EnumLogicEntityBaseDataTrait for ImpliedEnumTypeLogicEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn type_name_hash(&self) -> &u32 {
        self._glacier_base.type_name_hash()
    }
    fn type_name_hash_mut(&mut self) -> &mut u32 {
        self._glacier_base.type_name_hash_mut()
    }
}

impl EntityDataTrait for ImpliedEnumTypeLogicEntityData {
}

impl GameObjectDataTrait for ImpliedEnumTypeLogicEntityData {
}

impl super::core::DataBusPeerTrait for ImpliedEnumTypeLogicEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ImpliedEnumTypeLogicEntityData {
}

impl super::core::DataContainerTrait for ImpliedEnumTypeLogicEntityData {
}

pub static IMPLIEDENUMTYPELOGICENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ImpliedEnumTypeLogicEntityData",
    name_hash: 1181247707,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENUMLOGICENTITYBASEDATA_TYPE_INFO),
        super_class_offset: offset_of!(ImpliedEnumTypeLogicEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ImpliedEnumTypeLogicEntityData as Default>::default())),
            create_boxed: || Box::new(<ImpliedEnumTypeLogicEntityData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(IMPLIEDENUMTYPELOGICENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ImpliedEnumTypeLogicEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        IMPLIEDENUMTYPELOGICENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static IMPLIEDENUMTYPELOGICENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ImpliedEnumTypeLogicEntityData-Array",
    name_hash: 2619854831,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ImpliedEnumTypeLogicEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ExplicitEnumTypeLogicEntityData {
    pub _glacier_base: EnumLogicEntityBaseData,
}

pub trait ExplicitEnumTypeLogicEntityDataTrait: EnumLogicEntityBaseDataTrait {
}

impl ExplicitEnumTypeLogicEntityDataTrait for ExplicitEnumTypeLogicEntityData {
}

impl EnumLogicEntityBaseDataTrait for ExplicitEnumTypeLogicEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn type_name_hash(&self) -> &u32 {
        self._glacier_base.type_name_hash()
    }
    fn type_name_hash_mut(&mut self) -> &mut u32 {
        self._glacier_base.type_name_hash_mut()
    }
}

impl EntityDataTrait for ExplicitEnumTypeLogicEntityData {
}

impl GameObjectDataTrait for ExplicitEnumTypeLogicEntityData {
}

impl super::core::DataBusPeerTrait for ExplicitEnumTypeLogicEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ExplicitEnumTypeLogicEntityData {
}

impl super::core::DataContainerTrait for ExplicitEnumTypeLogicEntityData {
}

pub static EXPLICITENUMTYPELOGICENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExplicitEnumTypeLogicEntityData",
    name_hash: 3536586557,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENUMLOGICENTITYBASEDATA_TYPE_INFO),
        super_class_offset: offset_of!(ExplicitEnumTypeLogicEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ExplicitEnumTypeLogicEntityData as Default>::default())),
            create_boxed: || Box::new(<ExplicitEnumTypeLogicEntityData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(EXPLICITENUMTYPELOGICENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ExplicitEnumTypeLogicEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        EXPLICITENUMTYPELOGICENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EXPLICITENUMTYPELOGICENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExplicitEnumTypeLogicEntityData-Array",
    name_hash: 316433289,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ExplicitEnumTypeLogicEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct EnumLogicEntityBaseData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub type_name_hash: u32,
}

pub trait EnumLogicEntityBaseDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn type_name_hash(&self) -> &u32;
    fn type_name_hash_mut(&mut self) -> &mut u32;
}

impl EnumLogicEntityBaseDataTrait for EnumLogicEntityBaseData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn type_name_hash(&self) -> &u32 {
        &self.type_name_hash
    }
    fn type_name_hash_mut(&mut self) -> &mut u32 {
        &mut self.type_name_hash
    }
}

impl EntityDataTrait for EnumLogicEntityBaseData {
}

impl GameObjectDataTrait for EnumLogicEntityBaseData {
}

impl super::core::DataBusPeerTrait for EnumLogicEntityBaseData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for EnumLogicEntityBaseData {
}

impl super::core::DataContainerTrait for EnumLogicEntityBaseData {
}

pub static ENUMLOGICENTITYBASEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnumLogicEntityBaseData",
    name_hash: 3323427206,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(EnumLogicEntityBaseData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EnumLogicEntityBaseData as Default>::default())),
            create_boxed: || Box::new(<EnumLogicEntityBaseData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(EnumLogicEntityBaseData, realm),
            },
            FieldInfoData {
                name: "TypeNameHash",
                name_hash: 148584552,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(EnumLogicEntityBaseData, type_name_hash),
            },
        ],
    }),
    array_type: Some(ENUMLOGICENTITYBASEDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for EnumLogicEntityBaseData {
    fn type_info(&self) -> &'static TypeInfo {
        ENUMLOGICENTITYBASEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ENUMLOGICENTITYBASEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnumLogicEntityBaseData-Array",
    name_hash: 2662803122,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EnumLogicEntityBaseData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct EnumIntSourceEntityData {
    pub _glacier_base: ExplicitEnumTypeLogicEntityData,
    pub enum_int_output_properties: Vec<BoxedTypeObject /* EnumIntSourceProperty */>,
}

pub trait EnumIntSourceEntityDataTrait: ExplicitEnumTypeLogicEntityDataTrait {
    fn enum_int_output_properties(&self) -> &Vec<BoxedTypeObject /* EnumIntSourceProperty */>;
    fn enum_int_output_properties_mut(&mut self) -> &mut Vec<BoxedTypeObject /* EnumIntSourceProperty */>;
}

impl EnumIntSourceEntityDataTrait for EnumIntSourceEntityData {
    fn enum_int_output_properties(&self) -> &Vec<BoxedTypeObject /* EnumIntSourceProperty */> {
        &self.enum_int_output_properties
    }
    fn enum_int_output_properties_mut(&mut self) -> &mut Vec<BoxedTypeObject /* EnumIntSourceProperty */> {
        &mut self.enum_int_output_properties
    }
}

impl ExplicitEnumTypeLogicEntityDataTrait for EnumIntSourceEntityData {
}

impl EnumLogicEntityBaseDataTrait for EnumIntSourceEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn type_name_hash(&self) -> &u32 {
        self._glacier_base.type_name_hash()
    }
    fn type_name_hash_mut(&mut self) -> &mut u32 {
        self._glacier_base.type_name_hash_mut()
    }
}

impl EntityDataTrait for EnumIntSourceEntityData {
}

impl GameObjectDataTrait for EnumIntSourceEntityData {
}

impl super::core::DataBusPeerTrait for EnumIntSourceEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for EnumIntSourceEntityData {
}

impl super::core::DataContainerTrait for EnumIntSourceEntityData {
}

pub static ENUMINTSOURCEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnumIntSourceEntityData",
    name_hash: 2879268563,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(EXPLICITENUMTYPELOGICENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(EnumIntSourceEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EnumIntSourceEntityData as Default>::default())),
            create_boxed: || Box::new(<EnumIntSourceEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "EnumIntOutputProperties",
                name_hash: 3643105371,
                flags: MemberInfoFlags::new(144),
                field_type: "EnumIntSourceProperty-Array",
                rust_offset: offset_of!(EnumIntSourceEntityData, enum_int_output_properties),
            },
        ],
    }),
    array_type: Some(ENUMINTSOURCEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EnumIntSourceEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        ENUMINTSOURCEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ENUMINTSOURCEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnumIntSourceEntityData-Array",
    name_hash: 3417616871,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EnumIntSourceEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct EnumIntSourceProperty {
    pub enum_value: i32,
    pub output_property_hash: u32,
}

pub trait EnumIntSourcePropertyTrait: TypeObject {
    fn enum_value(&self) -> &i32;
    fn enum_value_mut(&mut self) -> &mut i32;
    fn output_property_hash(&self) -> &u32;
    fn output_property_hash_mut(&mut self) -> &mut u32;
}

impl EnumIntSourcePropertyTrait for EnumIntSourceProperty {
    fn enum_value(&self) -> &i32 {
        &self.enum_value
    }
    fn enum_value_mut(&mut self) -> &mut i32 {
        &mut self.enum_value
    }
    fn output_property_hash(&self) -> &u32 {
        &self.output_property_hash
    }
    fn output_property_hash_mut(&mut self) -> &mut u32 {
        &mut self.output_property_hash
    }
}

pub static ENUMINTSOURCEPROPERTY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnumIntSourceProperty",
    name_hash: 1379679519,
    flags: MemberInfoFlags::new(36937),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EnumIntSourceProperty as Default>::default())),
            create_boxed: || Box::new(<EnumIntSourceProperty as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "EnumValue",
                name_hash: 1043067517,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(EnumIntSourceProperty, enum_value),
            },
            FieldInfoData {
                name: "OutputPropertyHash",
                name_hash: 4205522447,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(EnumIntSourceProperty, output_property_hash),
            },
        ],
    }),
    array_type: Some(ENUMINTSOURCEPROPERTY_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for EnumIntSourceProperty {
    fn type_info(&self) -> &'static TypeInfo {
        ENUMINTSOURCEPROPERTY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ENUMINTSOURCEPROPERTY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnumIntSourceProperty-Array",
    name_hash: 2645148075,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EnumIntSourceProperty"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CompareEnumEntityData {
    pub _glacier_base: ImpliedEnumTypeLogicEntityData,
    pub trigger_on_property_change: bool,
    pub trigger_on_start: bool,
    pub always_send: bool,
    pub enum_default_value: i32,
}

pub trait CompareEnumEntityDataTrait: ImpliedEnumTypeLogicEntityDataTrait {
    fn trigger_on_property_change(&self) -> &bool;
    fn trigger_on_property_change_mut(&mut self) -> &mut bool;
    fn trigger_on_start(&self) -> &bool;
    fn trigger_on_start_mut(&mut self) -> &mut bool;
    fn always_send(&self) -> &bool;
    fn always_send_mut(&mut self) -> &mut bool;
    fn enum_default_value(&self) -> &i32;
    fn enum_default_value_mut(&mut self) -> &mut i32;
}

impl CompareEnumEntityDataTrait for CompareEnumEntityData {
    fn trigger_on_property_change(&self) -> &bool {
        &self.trigger_on_property_change
    }
    fn trigger_on_property_change_mut(&mut self) -> &mut bool {
        &mut self.trigger_on_property_change
    }
    fn trigger_on_start(&self) -> &bool {
        &self.trigger_on_start
    }
    fn trigger_on_start_mut(&mut self) -> &mut bool {
        &mut self.trigger_on_start
    }
    fn always_send(&self) -> &bool {
        &self.always_send
    }
    fn always_send_mut(&mut self) -> &mut bool {
        &mut self.always_send
    }
    fn enum_default_value(&self) -> &i32 {
        &self.enum_default_value
    }
    fn enum_default_value_mut(&mut self) -> &mut i32 {
        &mut self.enum_default_value
    }
}

impl ImpliedEnumTypeLogicEntityDataTrait for CompareEnumEntityData {
}

impl EnumLogicEntityBaseDataTrait for CompareEnumEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn type_name_hash(&self) -> &u32 {
        self._glacier_base.type_name_hash()
    }
    fn type_name_hash_mut(&mut self) -> &mut u32 {
        self._glacier_base.type_name_hash_mut()
    }
}

impl EntityDataTrait for CompareEnumEntityData {
}

impl GameObjectDataTrait for CompareEnumEntityData {
}

impl super::core::DataBusPeerTrait for CompareEnumEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CompareEnumEntityData {
}

impl super::core::DataContainerTrait for CompareEnumEntityData {
}

pub static COMPAREENUMENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareEnumEntityData",
    name_hash: 3031865370,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(IMPLIEDENUMTYPELOGICENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(CompareEnumEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareEnumEntityData as Default>::default())),
            create_boxed: || Box::new(<CompareEnumEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "TriggerOnPropertyChange",
                name_hash: 3134109917,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CompareEnumEntityData, trigger_on_property_change),
            },
            FieldInfoData {
                name: "TriggerOnStart",
                name_hash: 3859836348,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CompareEnumEntityData, trigger_on_start),
            },
            FieldInfoData {
                name: "AlwaysSend",
                name_hash: 579845256,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CompareEnumEntityData, always_send),
            },
            FieldInfoData {
                name: "EnumDefaultValue",
                name_hash: 2903438422,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CompareEnumEntityData, enum_default_value),
            },
        ],
    }),
    array_type: Some(COMPAREENUMENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CompareEnumEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        COMPAREENUMENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COMPAREENUMENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareEnumEntityData-Array",
    name_hash: 2309331758,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareEnumEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct DataSourceQueryEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub in_data: Option<LockedTypeObject /* super::core::DataContainer */>,
    pub array_index: i32,
}

pub trait DataSourceQueryEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn in_data(&self) -> &Option<LockedTypeObject /* super::core::DataContainer */>;
    fn in_data_mut(&mut self) -> &mut Option<LockedTypeObject /* super::core::DataContainer */>;
    fn array_index(&self) -> &i32;
    fn array_index_mut(&mut self) -> &mut i32;
}

impl DataSourceQueryEntityDataTrait for DataSourceQueryEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn in_data(&self) -> &Option<LockedTypeObject /* super::core::DataContainer */> {
        &self.in_data
    }
    fn in_data_mut(&mut self) -> &mut Option<LockedTypeObject /* super::core::DataContainer */> {
        &mut self.in_data
    }
    fn array_index(&self) -> &i32 {
        &self.array_index
    }
    fn array_index_mut(&mut self) -> &mut i32 {
        &mut self.array_index
    }
}

impl EntityDataTrait for DataSourceQueryEntityData {
}

impl GameObjectDataTrait for DataSourceQueryEntityData {
}

impl super::core::DataBusPeerTrait for DataSourceQueryEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for DataSourceQueryEntityData {
}

impl super::core::DataContainerTrait for DataSourceQueryEntityData {
}

pub static DATASOURCEQUERYENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DataSourceQueryEntityData",
    name_hash: 322013865,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(DataSourceQueryEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DataSourceQueryEntityData as Default>::default())),
            create_boxed: || Box::new(<DataSourceQueryEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(DataSourceQueryEntityData, realm),
            },
            FieldInfoData {
                name: "InData",
                name_hash: 2782775090,
                flags: MemberInfoFlags::new(0),
                field_type: "DataContainer",
                rust_offset: offset_of!(DataSourceQueryEntityData, in_data),
            },
            FieldInfoData {
                name: "ArrayIndex",
                name_hash: 3612301602,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(DataSourceQueryEntityData, array_index),
            },
        ],
    }),
    array_type: Some(DATASOURCEQUERYENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DataSourceQueryEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        DATASOURCEQUERYENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DATASOURCEQUERYENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DataSourceQueryEntityData-Array",
    name_hash: 3831763229,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("DataSourceQueryEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct DataSourceQueryFieldDefinition {
    pub name: String,
    pub type_name_hash: u32,
    pub is_array: bool,
    pub editor_property_type: String,
}

pub trait DataSourceQueryFieldDefinitionTrait: TypeObject {
    fn name(&self) -> &String;
    fn name_mut(&mut self) -> &mut String;
    fn type_name_hash(&self) -> &u32;
    fn type_name_hash_mut(&mut self) -> &mut u32;
    fn is_array(&self) -> &bool;
    fn is_array_mut(&mut self) -> &mut bool;
    fn editor_property_type(&self) -> &String;
    fn editor_property_type_mut(&mut self) -> &mut String;
}

impl DataSourceQueryFieldDefinitionTrait for DataSourceQueryFieldDefinition {
    fn name(&self) -> &String {
        &self.name
    }
    fn name_mut(&mut self) -> &mut String {
        &mut self.name
    }
    fn type_name_hash(&self) -> &u32 {
        &self.type_name_hash
    }
    fn type_name_hash_mut(&mut self) -> &mut u32 {
        &mut self.type_name_hash
    }
    fn is_array(&self) -> &bool {
        &self.is_array
    }
    fn is_array_mut(&mut self) -> &mut bool {
        &mut self.is_array
    }
    fn editor_property_type(&self) -> &String {
        &self.editor_property_type
    }
    fn editor_property_type_mut(&mut self) -> &mut String {
        &mut self.editor_property_type
    }
}

pub static DATASOURCEQUERYFIELDDEFINITION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DataSourceQueryFieldDefinition",
    name_hash: 2256796981,
    flags: MemberInfoFlags::new(73),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DataSourceQueryFieldDefinition as Default>::default())),
            create_boxed: || Box::new(<DataSourceQueryFieldDefinition as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Name",
                name_hash: 2088949890,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(DataSourceQueryFieldDefinition, name),
            },
            FieldInfoData {
                name: "TypeNameHash",
                name_hash: 148584552,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(DataSourceQueryFieldDefinition, type_name_hash),
            },
            FieldInfoData {
                name: "IsArray",
                name_hash: 2763287494,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DataSourceQueryFieldDefinition, is_array),
            },
            FieldInfoData {
                name: "EditorPropertyType",
                name_hash: 2582409307,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(DataSourceQueryFieldDefinition, editor_property_type),
            },
        ],
    }),
    array_type: Some(DATASOURCEQUERYFIELDDEFINITION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DataSourceQueryFieldDefinition {
    fn type_info(&self) -> &'static TypeInfo {
        DATASOURCEQUERYFIELDDEFINITION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static DATASOURCEQUERYFIELDDEFINITION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DataSourceQueryFieldDefinition-Array",
    name_hash: 2813689217,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("DataSourceQueryFieldDefinition"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct PropertyWrapper {
    pub _glacier_base: super::core::DataContainer,
}

pub trait PropertyWrapperTrait: super::core::DataContainerTrait {
}

impl PropertyWrapperTrait for PropertyWrapper {
}

impl super::core::DataContainerTrait for PropertyWrapper {
}

pub static PROPERTYWRAPPER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PropertyWrapper",
    name_hash: 4259064785,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(PropertyWrapper, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PropertyWrapper as Default>::default())),
            create_boxed: || Box::new(<PropertyWrapper as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(PROPERTYWRAPPER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PropertyWrapper {
    fn type_info(&self) -> &'static TypeInfo {
        PROPERTYWRAPPER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PROPERTYWRAPPER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PropertyWrapper-Array",
    name_hash: 2650160613,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("PropertyWrapper"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct BundleManagerBundleUnloadMessage {
}

pub trait BundleManagerBundleUnloadMessageTrait: TypeObject {
}

impl BundleManagerBundleUnloadMessageTrait for BundleManagerBundleUnloadMessage {
}

pub static BUNDLEMANAGERBUNDLEUNLOADMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BundleManagerBundleUnloadMessage",
    name_hash: 1895756256,
    flags: MemberInfoFlags::new(36937),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BundleManagerBundleUnloadMessage as Default>::default())),
            create_boxed: || Box::new(<BundleManagerBundleUnloadMessage as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for BundleManagerBundleUnloadMessage {
    fn type_info(&self) -> &'static TypeInfo {
        BUNDLEMANAGERBUNDLEUNLOADMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Debug, Default)]
#[repr(C)]
pub struct WriteArrayElementEntity {
    pub _glacier_base: Entity,
}

pub trait WriteArrayElementEntityTrait: EntityTrait {
}

impl WriteArrayElementEntityTrait for WriteArrayElementEntity {
}

impl EntityTrait for WriteArrayElementEntity {
}

impl EntityBusPeerTrait for WriteArrayElementEntity {
}

pub static WRITEARRAYELEMENTENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteArrayElementEntity",
    name_hash: 1719773316,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(WriteArrayElementEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WriteArrayElementEntity as Default>::default())),
            create_boxed: || Box::new(<WriteArrayElementEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(WRITEARRAYELEMENTENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for WriteArrayElementEntity {
    fn type_info(&self) -> &'static TypeInfo {
        WRITEARRAYELEMENTENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WRITEARRAYELEMENTENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteArrayElementEntity-Array",
    name_hash: 3189529776,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("WriteArrayElementEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ReadArraySizeEntity {
    pub _glacier_base: Entity,
}

pub trait ReadArraySizeEntityTrait: EntityTrait {
}

impl ReadArraySizeEntityTrait for ReadArraySizeEntity {
}

impl EntityTrait for ReadArraySizeEntity {
}

impl EntityBusPeerTrait for ReadArraySizeEntity {
}

pub static READARRAYSIZEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadArraySizeEntity",
    name_hash: 921159888,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(ReadArraySizeEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ReadArraySizeEntity as Default>::default())),
            create_boxed: || Box::new(<ReadArraySizeEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(READARRAYSIZEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ReadArraySizeEntity {
    fn type_info(&self) -> &'static TypeInfo {
        READARRAYSIZEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static READARRAYSIZEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadArraySizeEntity-Array",
    name_hash: 4245348,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ReadArraySizeEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ReadArrayElementEntity {
    pub _glacier_base: Entity,
}

pub trait ReadArrayElementEntityTrait: EntityTrait {
}

impl ReadArrayElementEntityTrait for ReadArrayElementEntity {
}

impl EntityTrait for ReadArrayElementEntity {
}

impl EntityBusPeerTrait for ReadArrayElementEntity {
}

pub static READARRAYELEMENTENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadArrayElementEntity",
    name_hash: 4227197227,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(ReadArrayElementEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ReadArrayElementEntity as Default>::default())),
            create_boxed: || Box::new(<ReadArrayElementEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(READARRAYELEMENTENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ReadArrayElementEntity {
    fn type_info(&self) -> &'static TypeInfo {
        READARRAYELEMENTENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static READARRAYELEMENTENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadArrayElementEntity-Array",
    name_hash: 1238223007,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ReadArrayElementEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ForEachVariableEntity {
    pub _glacier_base: Entity,
}

pub trait ForEachVariableEntityTrait: EntityTrait {
}

impl ForEachVariableEntityTrait for ForEachVariableEntity {
}

impl EntityTrait for ForEachVariableEntity {
}

impl EntityBusPeerTrait for ForEachVariableEntity {
}

pub static FOREACHVARIABLEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ForEachVariableEntity",
    name_hash: 3476737900,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(ForEachVariableEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ForEachVariableEntity as Default>::default())),
            create_boxed: || Box::new(<ForEachVariableEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(FOREACHVARIABLEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ForEachVariableEntity {
    fn type_info(&self) -> &'static TypeInfo {
        FOREACHVARIABLEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FOREACHVARIABLEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ForEachVariableEntity-Array",
    name_hash: 983715672,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ForEachVariableEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ClearArrayVariableEntity {
    pub _glacier_base: Entity,
}

pub trait ClearArrayVariableEntityTrait: EntityTrait {
}

impl ClearArrayVariableEntityTrait for ClearArrayVariableEntity {
}

impl EntityTrait for ClearArrayVariableEntity {
}

impl EntityBusPeerTrait for ClearArrayVariableEntity {
}

pub static CLEARARRAYVARIABLEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClearArrayVariableEntity",
    name_hash: 3712697400,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(ClearArrayVariableEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ClearArrayVariableEntity as Default>::default())),
            create_boxed: || Box::new(<ClearArrayVariableEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(CLEARARRAYVARIABLEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ClearArrayVariableEntity {
    fn type_info(&self) -> &'static TypeInfo {
        CLEARARRAYVARIABLEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CLEARARRAYVARIABLEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClearArrayVariableEntity-Array",
    name_hash: 1795059084,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ClearArrayVariableEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct AddToArrayVariableEntity {
    pub _glacier_base: Entity,
}

pub trait AddToArrayVariableEntityTrait: EntityTrait {
}

impl AddToArrayVariableEntityTrait for AddToArrayVariableEntity {
}

impl EntityTrait for AddToArrayVariableEntity {
}

impl EntityBusPeerTrait for AddToArrayVariableEntity {
}

pub static ADDTOARRAYVARIABLEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AddToArrayVariableEntity",
    name_hash: 3873977755,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(AddToArrayVariableEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AddToArrayVariableEntity as Default>::default())),
            create_boxed: || Box::new(<AddToArrayVariableEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(ADDTOARRAYVARIABLEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for AddToArrayVariableEntity {
    fn type_info(&self) -> &'static TypeInfo {
        ADDTOARRAYVARIABLEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ADDTOARRAYVARIABLEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AddToArrayVariableEntity-Array",
    name_hash: 2370726959,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("AddToArrayVariableEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct WriteVariableEntity {
    pub _glacier_base: Entity,
}

pub trait WriteVariableEntityTrait: EntityTrait {
}

impl WriteVariableEntityTrait for WriteVariableEntity {
}

impl EntityTrait for WriteVariableEntity {
}

impl EntityBusPeerTrait for WriteVariableEntity {
}

pub static WRITEVARIABLEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteVariableEntity",
    name_hash: 2034890149,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(WriteVariableEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WriteVariableEntity as Default>::default())),
            create_boxed: || Box::new(<WriteVariableEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(WRITEVARIABLEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for WriteVariableEntity {
    fn type_info(&self) -> &'static TypeInfo {
        WRITEVARIABLEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WRITEVARIABLEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteVariableEntity-Array",
    name_hash: 4070641169,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("WriteVariableEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ReadVariableEntity {
    pub _glacier_base: Entity,
}

pub trait ReadVariableEntityTrait: EntityTrait {
}

impl ReadVariableEntityTrait for ReadVariableEntity {
}

impl EntityTrait for ReadVariableEntity {
}

impl EntityBusPeerTrait for ReadVariableEntity {
}

pub static READVARIABLEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadVariableEntity",
    name_hash: 3998041354,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(ReadVariableEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ReadVariableEntity as Default>::default())),
            create_boxed: || Box::new(<ReadVariableEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(READVARIABLEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ReadVariableEntity {
    fn type_info(&self) -> &'static TypeInfo {
        READVARIABLEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static READVARIABLEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadVariableEntity-Array",
    name_hash: 1731674174,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ReadVariableEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct HighlightEntity {
    pub _glacier_base: Entity,
}

pub trait HighlightEntityTrait: EntityTrait {
}

impl HighlightEntityTrait for HighlightEntity {
}

impl EntityTrait for HighlightEntity {
}

impl EntityBusPeerTrait for HighlightEntity {
}

pub static HIGHLIGHTENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HighlightEntity",
    name_hash: 1281090030,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(HighlightEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<HighlightEntity as Default>::default())),
            create_boxed: || Box::new(<HighlightEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(HIGHLIGHTENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for HighlightEntity {
    fn type_info(&self) -> &'static TypeInfo {
        HIGHLIGHTENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static HIGHLIGHTENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HighlightEntity-Array",
    name_hash: 4220746458,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("HighlightEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TextSequenceEntity {
    pub _glacier_base: Entity,
}

pub trait TextSequenceEntityTrait: EntityTrait {
}

impl TextSequenceEntityTrait for TextSequenceEntity {
}

impl EntityTrait for TextSequenceEntity {
}

impl EntityBusPeerTrait for TextSequenceEntity {
}

pub static TEXTSEQUENCEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TextSequenceEntity",
    name_hash: 3340415388,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(TextSequenceEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TextSequenceEntity as Default>::default())),
            create_boxed: || Box::new(<TextSequenceEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(TEXTSEQUENCEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for TextSequenceEntity {
    fn type_info(&self) -> &'static TypeInfo {
        TEXTSEQUENCEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TEXTSEQUENCEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TextSequenceEntity-Array",
    name_hash: 1269451176,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TextSequenceEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SubLevelEntity {
    pub _glacier_base: Entity,
}

pub trait SubLevelEntityTrait: EntityTrait {
}

impl SubLevelEntityTrait for SubLevelEntity {
}

impl EntityTrait for SubLevelEntity {
}

impl EntityBusPeerTrait for SubLevelEntity {
}

pub static SUBLEVELENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubLevelEntity",
    name_hash: 126806252,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(SubLevelEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SubLevelEntity as Default>::default())),
            create_boxed: || Box::new(<SubLevelEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(SUBLEVELENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SubLevelEntity {
    fn type_info(&self) -> &'static TypeInfo {
        SUBLEVELENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SUBLEVELENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubLevelEntity-Array",
    name_hash: 1325631704,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SubLevelEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ReportInstallationProgressEntity {
    pub _glacier_base: Entity,
}

pub trait ReportInstallationProgressEntityTrait: EntityTrait {
}

impl ReportInstallationProgressEntityTrait for ReportInstallationProgressEntity {
}

impl EntityTrait for ReportInstallationProgressEntity {
}

impl EntityBusPeerTrait for ReportInstallationProgressEntity {
}

pub static REPORTINSTALLATIONPROGRESSENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReportInstallationProgressEntity",
    name_hash: 3368960625,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(ReportInstallationProgressEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ReportInstallationProgressEntity as Default>::default())),
            create_boxed: || Box::new(<ReportInstallationProgressEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(REPORTINSTALLATIONPROGRESSENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ReportInstallationProgressEntity {
    fn type_info(&self) -> &'static TypeInfo {
        REPORTINSTALLATIONPROGRESSENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static REPORTINSTALLATIONPROGRESSENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReportInstallationProgressEntity-Array",
    name_hash: 2457814341,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ReportInstallationProgressEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct LocalPlayerIdEntity {
    pub _glacier_base: Entity,
}

pub trait LocalPlayerIdEntityTrait: EntityTrait {
}

impl LocalPlayerIdEntityTrait for LocalPlayerIdEntity {
}

impl EntityTrait for LocalPlayerIdEntity {
}

impl EntityBusPeerTrait for LocalPlayerIdEntity {
}

pub static LOCALPLAYERIDENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalPlayerIdEntity",
    name_hash: 822719757,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(LocalPlayerIdEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LocalPlayerIdEntity as Default>::default())),
            create_boxed: || Box::new(<LocalPlayerIdEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(LOCALPLAYERIDENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for LocalPlayerIdEntity {
    fn type_info(&self) -> &'static TypeInfo {
        LOCALPLAYERIDENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LOCALPLAYERIDENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalPlayerIdEntity-Array",
    name_hash: 2229663929,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("LocalPlayerIdEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct FloatCacheEntity {
    pub _glacier_base: Entity,
}

pub trait FloatCacheEntityTrait: EntityTrait {
}

impl FloatCacheEntityTrait for FloatCacheEntity {
}

impl EntityTrait for FloatCacheEntity {
}

impl EntityBusPeerTrait for FloatCacheEntity {
}

pub static FLOATCACHEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatCacheEntity",
    name_hash: 2590078722,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(FloatCacheEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FloatCacheEntity as Default>::default())),
            create_boxed: || Box::new(<FloatCacheEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(FLOATCACHEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for FloatCacheEntity {
    fn type_info(&self) -> &'static TypeInfo {
        FLOATCACHEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FLOATCACHEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatCacheEntity-Array",
    name_hash: 1873385014,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("FloatCacheEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct MultilineStringEntity {
    pub _glacier_base: Entity,
}

pub trait MultilineStringEntityTrait: EntityTrait {
}

impl MultilineStringEntityTrait for MultilineStringEntity {
}

impl EntityTrait for MultilineStringEntity {
}

impl EntityBusPeerTrait for MultilineStringEntity {
}

pub static MULTILINESTRINGENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultilineStringEntity",
    name_hash: 3095458508,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(MultilineStringEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MultilineStringEntity as Default>::default())),
            create_boxed: || Box::new(<MultilineStringEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(MULTILINESTRINGENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for MultilineStringEntity {
    fn type_info(&self) -> &'static TypeInfo {
        MULTILINESTRINGENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MULTILINESTRINGENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultilineStringEntity-Array",
    name_hash: 851293048,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("MultilineStringEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct StringEntity {
    pub _glacier_base: Entity,
}

pub trait StringEntityTrait: EntityTrait {
}

impl StringEntityTrait for StringEntity {
}

impl EntityTrait for StringEntity {
}

impl EntityBusPeerTrait for StringEntity {
}

pub static STRINGENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StringEntity",
    name_hash: 3917304523,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(StringEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StringEntity as Default>::default())),
            create_boxed: || Box::new(<StringEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(STRINGENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for StringEntity {
    fn type_info(&self) -> &'static TypeInfo {
        STRINGENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static STRINGENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StringEntity-Array",
    name_hash: 707883519,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("StringEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct AxisAlignedBoxEntity {
    pub _glacier_base: Entity,
}

pub trait AxisAlignedBoxEntityTrait: EntityTrait {
}

impl AxisAlignedBoxEntityTrait for AxisAlignedBoxEntity {
}

impl EntityTrait for AxisAlignedBoxEntity {
}

impl EntityBusPeerTrait for AxisAlignedBoxEntity {
}

pub static AXISALIGNEDBOXENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AxisAlignedBoxEntity",
    name_hash: 1500173636,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(AxisAlignedBoxEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AxisAlignedBoxEntity as Default>::default())),
            create_boxed: || Box::new(<AxisAlignedBoxEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(AXISALIGNEDBOXENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for AxisAlignedBoxEntity {
    fn type_info(&self) -> &'static TypeInfo {
        AXISALIGNEDBOXENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AXISALIGNEDBOXENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AxisAlignedBoxEntity-Array",
    name_hash: 1118312944,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("AxisAlignedBoxEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct Vector4Entity {
    pub _glacier_base: Entity,
}

pub trait Vector4EntityTrait: EntityTrait {
}

impl Vector4EntityTrait for Vector4Entity {
}

impl EntityTrait for Vector4Entity {
}

impl EntityBusPeerTrait for Vector4Entity {
}

pub static VECTOR4ENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vector4Entity",
    name_hash: 1312387987,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(Vector4Entity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vector4Entity as Default>::default())),
            create_boxed: || Box::new(<Vector4Entity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(VECTOR4ENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for Vector4Entity {
    fn type_info(&self) -> &'static TypeInfo {
        VECTOR4ENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VECTOR4ENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vector4Entity-Array",
    name_hash: 3314994727,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vector4Entity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct Vector3Entity {
    pub _glacier_base: Entity,
}

pub trait Vector3EntityTrait: EntityTrait {
}

impl Vector3EntityTrait for Vector3Entity {
}

impl EntityTrait for Vector3Entity {
}

impl EntityBusPeerTrait for Vector3Entity {
}

pub static VECTOR3ENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vector3Entity",
    name_hash: 668372884,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(Vector3Entity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vector3Entity as Default>::default())),
            create_boxed: || Box::new(<Vector3Entity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(VECTOR3ENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for Vector3Entity {
    fn type_info(&self) -> &'static TypeInfo {
        VECTOR3ENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VECTOR3ENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vector3Entity-Array",
    name_hash: 3402976160,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vector3Entity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TransformEntity {
    pub _glacier_base: Entity,
}

pub trait TransformEntityTrait: EntityTrait {
}

impl TransformEntityTrait for TransformEntity {
}

impl EntityTrait for TransformEntity {
}

impl EntityBusPeerTrait for TransformEntity {
}

pub static TRANSFORMENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformEntity",
    name_hash: 2223757106,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(TransformEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformEntity as Default>::default())),
            create_boxed: || Box::new(<TransformEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(TRANSFORMENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for TransformEntity {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TRANSFORMENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformEntity-Array",
    name_hash: 2329566598,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TransformEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct FloatEntity {
    pub _glacier_base: Entity,
}

pub trait FloatEntityTrait: EntityTrait {
}

impl FloatEntityTrait for FloatEntity {
}

impl EntityTrait for FloatEntity {
}

impl EntityBusPeerTrait for FloatEntity {
}

pub static FLOATENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatEntity",
    name_hash: 457638350,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(FloatEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FloatEntity as Default>::default())),
            create_boxed: || Box::new(<FloatEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(FLOATENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for FloatEntity {
    fn type_info(&self) -> &'static TypeInfo {
        FLOATENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FLOATENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatEntity-Array",
    name_hash: 1439398778,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("FloatEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct UIntEntity {
    pub _glacier_base: Entity,
}

pub trait UIntEntityTrait: EntityTrait {
}

impl UIntEntityTrait for UIntEntity {
}

impl EntityTrait for UIntEntity {
}

impl EntityBusPeerTrait for UIntEntity {
}

pub static UINTENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UIntEntity",
    name_hash: 1195911608,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(UIntEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<UIntEntity as Default>::default())),
            create_boxed: || Box::new(<UIntEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(UINTENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for UIntEntity {
    fn type_info(&self) -> &'static TypeInfo {
        UINTENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static UINTENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UIntEntity-Array",
    name_hash: 3077665548,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("UIntEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct IntEntity {
    pub _glacier_base: Entity,
}

pub trait IntEntityTrait: EntityTrait {
}

impl IntEntityTrait for IntEntity {
}

impl EntityTrait for IntEntity {
}

impl EntityBusPeerTrait for IntEntity {
}

pub static INTENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntEntity",
    name_hash: 1023573101,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(IntEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<IntEntity as Default>::default())),
            create_boxed: || Box::new(<IntEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(INTENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for IntEntity {
    fn type_info(&self) -> &'static TypeInfo {
        INTENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static INTENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntEntity-Array",
    name_hash: 2745385305,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("IntEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct BoolEntity {
    pub _glacier_base: Entity,
}

pub trait BoolEntityTrait: EntityTrait {
}

impl BoolEntityTrait for BoolEntity {
}

impl EntityTrait for BoolEntity {
}

impl EntityBusPeerTrait for BoolEntity {
}

pub static BOOLENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolEntity",
    name_hash: 839406416,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(BoolEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BoolEntity as Default>::default())),
            create_boxed: || Box::new(<BoolEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(BOOLENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for BoolEntity {
    fn type_info(&self) -> &'static TypeInfo {
        BOOLENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BOOLENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolEntity-Array",
    name_hash: 893333988,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("BoolEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SpatialEntity {
    pub _glacier_base: Entity,
}

pub trait SpatialEntityTrait: EntityTrait {
}

impl SpatialEntityTrait for SpatialEntity {
}

impl EntityTrait for SpatialEntity {
}

impl EntityBusPeerTrait for SpatialEntity {
}

pub static SPATIALENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpatialEntity",
    name_hash: 452546764,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(SpatialEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SpatialEntity as Default>::default())),
            create_boxed: || Box::new(<SpatialEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(SPATIALENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SpatialEntity {
    fn type_info(&self) -> &'static TypeInfo {
        SPATIALENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SPATIALENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpatialEntity-Array",
    name_hash: 1904513400,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SpatialEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SelectVec4Entity {
    pub _glacier_base: Entity,
}

pub trait SelectVec4EntityTrait: EntityTrait {
}

impl SelectVec4EntityTrait for SelectVec4Entity {
}

impl EntityTrait for SelectVec4Entity {
}

impl EntityBusPeerTrait for SelectVec4Entity {
}

pub static SELECTVEC4ENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectVec4Entity",
    name_hash: 2093694834,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(SelectVec4Entity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SelectVec4Entity as Default>::default())),
            create_boxed: || Box::new(<SelectVec4Entity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(SELECTVEC4ENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SelectVec4Entity {
    fn type_info(&self) -> &'static TypeInfo {
        SELECTVEC4ENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SELECTVEC4ENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectVec4Entity-Array",
    name_hash: 1413920326,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SelectVec4Entity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SelectVec3Entity {
    pub _glacier_base: Entity,
}

pub trait SelectVec3EntityTrait: EntityTrait {
}

impl SelectVec3EntityTrait for SelectVec3Entity {
}

impl EntityTrait for SelectVec3Entity {
}

impl EntityBusPeerTrait for SelectVec3Entity {
}

pub static SELECTVEC3ENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectVec3Entity",
    name_hash: 4028007157,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(SelectVec3Entity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SelectVec3Entity as Default>::default())),
            create_boxed: || Box::new(<SelectVec3Entity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(SELECTVEC3ENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SelectVec3Entity {
    fn type_info(&self) -> &'static TypeInfo {
        SELECTVEC3ENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SELECTVEC3ENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectVec3Entity-Array",
    name_hash: 1029018561,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SelectVec3Entity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SelectVec2Entity {
    pub _glacier_base: Entity,
}

pub trait SelectVec2EntityTrait: EntityTrait {
}

impl SelectVec2EntityTrait for SelectVec2Entity {
}

impl EntityTrait for SelectVec2Entity {
}

impl EntityBusPeerTrait for SelectVec2Entity {
}

pub static SELECTVEC2ENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectVec2Entity",
    name_hash: 1653708660,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(SelectVec2Entity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SelectVec2Entity as Default>::default())),
            create_boxed: || Box::new(<SelectVec2Entity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(SELECTVEC2ENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SelectVec2Entity {
    fn type_info(&self) -> &'static TypeInfo {
        SELECTVEC2ENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SELECTVEC2ENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectVec2Entity-Array",
    name_hash: 2197979968,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SelectVec2Entity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SelectTransformEntity {
    pub _glacier_base: Entity,
}

pub trait SelectTransformEntityTrait: EntityTrait {
}

impl SelectTransformEntityTrait for SelectTransformEntity {
}

impl EntityTrait for SelectTransformEntity {
}

impl EntityBusPeerTrait for SelectTransformEntity {
}

pub static SELECTTRANSFORMENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectTransformEntity",
    name_hash: 2855181658,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(SelectTransformEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SelectTransformEntity as Default>::default())),
            create_boxed: || Box::new(<SelectTransformEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(SELECTTRANSFORMENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SelectTransformEntity {
    fn type_info(&self) -> &'static TypeInfo {
        SELECTTRANSFORMENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SELECTTRANSFORMENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectTransformEntity-Array",
    name_hash: 3828142318,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SelectTransformEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SelectBoolEntity {
    pub _glacier_base: Entity,
}

pub trait SelectBoolEntityTrait: EntityTrait {
}

impl SelectBoolEntityTrait for SelectBoolEntity {
}

impl EntityTrait for SelectBoolEntity {
}

impl EntityBusPeerTrait for SelectBoolEntity {
}

pub static SELECTBOOLENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectBoolEntity",
    name_hash: 1558901816,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(SelectBoolEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SelectBoolEntity as Default>::default())),
            create_boxed: || Box::new(<SelectBoolEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(SELECTBOOLENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SelectBoolEntity {
    fn type_info(&self) -> &'static TypeInfo {
        SELECTBOOLENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SELECTBOOLENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectBoolEntity-Array",
    name_hash: 4020379020,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SelectBoolEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SelectStringEntity {
    pub _glacier_base: Entity,
}

pub trait SelectStringEntityTrait: EntityTrait {
}

impl SelectStringEntityTrait for SelectStringEntity {
}

impl EntityTrait for SelectStringEntity {
}

impl EntityBusPeerTrait for SelectStringEntity {
}

pub static SELECTSTRINGENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectStringEntity",
    name_hash: 1500571939,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(SelectStringEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SelectStringEntity as Default>::default())),
            create_boxed: || Box::new(<SelectStringEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(SELECTSTRINGENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SelectStringEntity {
    fn type_info(&self) -> &'static TypeInfo {
        SELECTSTRINGENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SELECTSTRINGENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectStringEntity-Array",
    name_hash: 1426680983,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SelectStringEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SelectInt64Entity {
    pub _glacier_base: Entity,
}

pub trait SelectInt64EntityTrait: EntityTrait {
}

impl SelectInt64EntityTrait for SelectInt64Entity {
}

impl EntityTrait for SelectInt64Entity {
}

impl EntityBusPeerTrait for SelectInt64Entity {
}

pub static SELECTINT64ENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectInt64Entity",
    name_hash: 3522686407,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(SelectInt64Entity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SelectInt64Entity as Default>::default())),
            create_boxed: || Box::new(<SelectInt64Entity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(SELECTINT64ENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SelectInt64Entity {
    fn type_info(&self) -> &'static TypeInfo {
        SELECTINT64ENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SELECTINT64ENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectInt64Entity-Array",
    name_hash: 1739890419,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SelectInt64Entity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SelectIntEntity {
    pub _glacier_base: Entity,
}

pub trait SelectIntEntityTrait: EntityTrait {
}

impl SelectIntEntityTrait for SelectIntEntity {
}

impl EntityTrait for SelectIntEntity {
}

impl EntityBusPeerTrait for SelectIntEntity {
}

pub static SELECTINTENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectIntEntity",
    name_hash: 573387525,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(SelectIntEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SelectIntEntity as Default>::default())),
            create_boxed: || Box::new(<SelectIntEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(SELECTINTENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SelectIntEntity {
    fn type_info(&self) -> &'static TypeInfo {
        SELECTINTENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SELECTINTENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectIntEntity-Array",
    name_hash: 1806736049,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SelectIntEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SelectFloatEntity {
    pub _glacier_base: Entity,
}

pub trait SelectFloatEntityTrait: EntityTrait {
}

impl SelectFloatEntityTrait for SelectFloatEntity {
}

impl EntityTrait for SelectFloatEntity {
}

impl EntityBusPeerTrait for SelectFloatEntity {
}

pub static SELECTFLOATENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectFloatEntity",
    name_hash: 336157798,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(SelectFloatEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SelectFloatEntity as Default>::default())),
            create_boxed: || Box::new(<SelectFloatEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(SELECTFLOATENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SelectFloatEntity {
    fn type_info(&self) -> &'static TypeInfo {
        SELECTFLOATENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SELECTFLOATENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectFloatEntity-Array",
    name_hash: 2358475090,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SelectFloatEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ScriptEntity {
    pub _glacier_base: Entity,
}

pub trait ScriptEntityTrait: EntityTrait {
}

impl ScriptEntityTrait for ScriptEntity {
}

impl EntityTrait for ScriptEntity {
}

impl EntityBusPeerTrait for ScriptEntity {
}

pub static SCRIPTENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScriptEntity",
    name_hash: 2302866961,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(ScriptEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ScriptEntity as Default>::default())),
            create_boxed: || Box::new(<ScriptEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(SCRIPTENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ScriptEntity {
    fn type_info(&self) -> &'static TypeInfo {
        SCRIPTENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SCRIPTENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScriptEntity-Array",
    name_hash: 1495250853,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ScriptEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SchematicChannelEntity {
    pub _glacier_base: Entity,
}

pub trait SchematicChannelEntityTrait: EntityTrait {
}

impl SchematicChannelEntityTrait for SchematicChannelEntity {
}

impl EntityTrait for SchematicChannelEntity {
}

impl EntityBusPeerTrait for SchematicChannelEntity {
}

pub static SCHEMATICCHANNELENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SchematicChannelEntity",
    name_hash: 2010930130,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(SchematicChannelEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SchematicChannelEntity as Default>::default())),
            create_boxed: || Box::new(<SchematicChannelEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(SCHEMATICCHANNELENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SchematicChannelEntity {
    fn type_info(&self) -> &'static TypeInfo {
        SCHEMATICCHANNELENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SCHEMATICCHANNELENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SchematicChannelEntity-Array",
    name_hash: 1934627686,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SchematicChannelEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct Part {
    pub _glacier_base: Component,
}

pub trait PartTrait: ComponentTrait {
}

impl PartTrait for Part {
}

impl ComponentTrait for Part {
}

impl EntityBusPeerTrait for Part {
}

pub static PART_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Part",
    name_hash: 2089448370,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(COMPONENT_TYPE_INFO),
        super_class_offset: offset_of!(Part, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Part as Default>::default())),
            create_boxed: || Box::new(<Part as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(PART_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for Part {
    fn type_info(&self) -> &'static TypeInfo {
        PART_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PART_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Part-Array",
    name_hash: 58481158,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Part"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ObjectAreaTriggerEntity {
    pub _glacier_base: Entity,
}

pub trait ObjectAreaTriggerEntityTrait: EntityTrait {
}

impl ObjectAreaTriggerEntityTrait for ObjectAreaTriggerEntity {
}

impl EntityTrait for ObjectAreaTriggerEntity {
}

impl EntityBusPeerTrait for ObjectAreaTriggerEntity {
}

pub static OBJECTAREATRIGGERENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectAreaTriggerEntity",
    name_hash: 3845676900,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(ObjectAreaTriggerEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ObjectAreaTriggerEntity as Default>::default())),
            create_boxed: || Box::new(<ObjectAreaTriggerEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(OBJECTAREATRIGGERENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ObjectAreaTriggerEntity {
    fn type_info(&self) -> &'static TypeInfo {
        OBJECTAREATRIGGERENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static OBJECTAREATRIGGERENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectAreaTriggerEntity-Array",
    name_hash: 2584511312,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ObjectAreaTriggerEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ObjectVariationToIntEntity {
    pub _glacier_base: Entity,
}

pub trait ObjectVariationToIntEntityTrait: EntityTrait {
}

impl ObjectVariationToIntEntityTrait for ObjectVariationToIntEntity {
}

impl EntityTrait for ObjectVariationToIntEntity {
}

impl EntityBusPeerTrait for ObjectVariationToIntEntity {
}

pub static OBJECTVARIATIONTOINTENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectVariationToIntEntity",
    name_hash: 516873138,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(ObjectVariationToIntEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ObjectVariationToIntEntity as Default>::default())),
            create_boxed: || Box::new(<ObjectVariationToIntEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(OBJECTVARIATIONTOINTENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ObjectVariationToIntEntity {
    fn type_info(&self) -> &'static TypeInfo {
        OBJECTVARIATIONTOINTENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static OBJECTVARIATIONTOINTENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectVariationToIntEntity-Array",
    name_hash: 4050567686,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ObjectVariationToIntEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TransformSpaceEntity {
    pub _glacier_base: Entity,
}

pub trait TransformSpaceEntityTrait: EntityTrait {
}

impl TransformSpaceEntityTrait for TransformSpaceEntity {
}

impl EntityTrait for TransformSpaceEntity {
}

impl EntityBusPeerTrait for TransformSpaceEntity {
}

pub static TRANSFORMSPACEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformSpaceEntity",
    name_hash: 2198864118,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(TransformSpaceEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformSpaceEntity as Default>::default())),
            create_boxed: || Box::new(<TransformSpaceEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(TRANSFORMSPACEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for TransformSpaceEntity {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMSPACEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TRANSFORMSPACEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformSpaceEntity-Array",
    name_hash: 1136018882,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TransformSpaceEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct FloatSelectEntity {
    pub _glacier_base: Entity,
}

pub trait FloatSelectEntityTrait: EntityTrait {
}

impl FloatSelectEntityTrait for FloatSelectEntity {
}

impl EntityTrait for FloatSelectEntity {
}

impl EntityBusPeerTrait for FloatSelectEntity {
}

pub static FLOATSELECTENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatSelectEntity",
    name_hash: 1055482470,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(FloatSelectEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FloatSelectEntity as Default>::default())),
            create_boxed: || Box::new(<FloatSelectEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(FLOATSELECTENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for FloatSelectEntity {
    fn type_info(&self) -> &'static TypeInfo {
        FLOATSELECTENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FLOATSELECTENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatSelectEntity-Array",
    name_hash: 1021312850,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("FloatSelectEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct FloatCurveEntity {
    pub _glacier_base: Entity,
}

pub trait FloatCurveEntityTrait: EntityTrait {
}

impl FloatCurveEntityTrait for FloatCurveEntity {
}

impl EntityTrait for FloatCurveEntity {
}

impl EntityBusPeerTrait for FloatCurveEntity {
}

pub static FLOATCURVEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatCurveEntity",
    name_hash: 1248156889,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(FloatCurveEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FloatCurveEntity as Default>::default())),
            create_boxed: || Box::new(<FloatCurveEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(FLOATCURVEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for FloatCurveEntity {
    fn type_info(&self) -> &'static TypeInfo {
        FLOATCURVEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FLOATCURVEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatCurveEntity-Array",
    name_hash: 2506066669,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("FloatCurveEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SettingEntity {
    pub _glacier_base: Entity,
}

pub trait SettingEntityTrait: EntityTrait {
}

impl SettingEntityTrait for SettingEntity {
}

impl EntityTrait for SettingEntity {
}

impl EntityBusPeerTrait for SettingEntity {
}

pub static SETTINGENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SettingEntity",
    name_hash: 1093910536,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(SettingEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SettingEntity as Default>::default())),
            create_boxed: || Box::new(<SettingEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(SETTINGENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SettingEntity {
    fn type_info(&self) -> &'static TypeInfo {
        SETTINGENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SETTINGENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SettingEntity-Array",
    name_hash: 1881260604,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SettingEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct IntegratorOrDifferentiatorEntity {
    pub _glacier_base: Entity,
}

pub trait IntegratorOrDifferentiatorEntityTrait: EntityTrait {
}

impl IntegratorOrDifferentiatorEntityTrait for IntegratorOrDifferentiatorEntity {
}

impl EntityTrait for IntegratorOrDifferentiatorEntity {
}

impl EntityBusPeerTrait for IntegratorOrDifferentiatorEntity {
}

pub static INTEGRATORORDIFFERENTIATORENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntegratorOrDifferentiatorEntity",
    name_hash: 3603537356,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(IntegratorOrDifferentiatorEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<IntegratorOrDifferentiatorEntity as Default>::default())),
            create_boxed: || Box::new(<IntegratorOrDifferentiatorEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(INTEGRATORORDIFFERENTIATORENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for IntegratorOrDifferentiatorEntity {
    fn type_info(&self) -> &'static TypeInfo {
        INTEGRATORORDIFFERENTIATORENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static INTEGRATORORDIFFERENTIATORENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntegratorOrDifferentiatorEntity-Array",
    name_hash: 228236920,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("IntegratorOrDifferentiatorEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ProfileEntity {
    pub _glacier_base: Entity,
}

pub trait ProfileEntityTrait: EntityTrait {
}

impl ProfileEntityTrait for ProfileEntity {
}

impl EntityTrait for ProfileEntity {
}

impl EntityBusPeerTrait for ProfileEntity {
}

pub static PROFILEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ProfileEntity",
    name_hash: 1415510453,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(ProfileEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ProfileEntity as Default>::default())),
            create_boxed: || Box::new(<ProfileEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(PROFILEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ProfileEntity {
    fn type_info(&self) -> &'static TypeInfo {
        PROFILEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PROFILEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ProfileEntity-Array",
    name_hash: 3254508033,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ProfileEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CompareEntity {
    pub _glacier_base: Entity,
}

pub trait CompareEntityTrait: EntityTrait {
}

impl CompareEntityTrait for CompareEntity {
}

impl EntityTrait for CompareEntity {
}

impl EntityBusPeerTrait for CompareEntity {
}

pub static COMPAREENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareEntity",
    name_hash: 2423771865,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(CompareEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareEntity as Default>::default())),
            create_boxed: || Box::new(<CompareEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(COMPAREENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for CompareEntity {
    fn type_info(&self) -> &'static TypeInfo {
        COMPAREENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COMPAREENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareEntity-Array",
    name_hash: 4176642285,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct RunningAverageEntity {
    pub _glacier_base: Entity,
}

pub trait RunningAverageEntityTrait: EntityTrait {
}

impl RunningAverageEntityTrait for RunningAverageEntity {
}

impl EntityTrait for RunningAverageEntity {
}

impl EntityBusPeerTrait for RunningAverageEntity {
}

pub static RUNNINGAVERAGEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RunningAverageEntity",
    name_hash: 4122987194,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(RunningAverageEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RunningAverageEntity as Default>::default())),
            create_boxed: || Box::new(<RunningAverageEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(RUNNINGAVERAGEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for RunningAverageEntity {
    fn type_info(&self) -> &'static TypeInfo {
        RUNNINGAVERAGEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RUNNINGAVERAGEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RunningAverageEntity-Array",
    name_hash: 496389390,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("RunningAverageEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct AbsEntity {
    pub _glacier_base: Entity,
}

pub trait AbsEntityTrait: EntityTrait {
}

impl AbsEntityTrait for AbsEntity {
}

impl EntityTrait for AbsEntity {
}

impl EntityBusPeerTrait for AbsEntity {
}

pub static ABSENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AbsEntity",
    name_hash: 650954862,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(AbsEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AbsEntity as Default>::default())),
            create_boxed: || Box::new(<AbsEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(ABSENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for AbsEntity {
    fn type_info(&self) -> &'static TypeInfo {
        ABSENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ABSENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AbsEntity-Array",
    name_hash: 968311130,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("AbsEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct VectorMathOpEntity {
    pub _glacier_base: Entity,
}

pub trait VectorMathOpEntityTrait: EntityTrait {
}

impl VectorMathOpEntityTrait for VectorMathOpEntity {
}

impl EntityTrait for VectorMathOpEntity {
}

impl EntityBusPeerTrait for VectorMathOpEntity {
}

pub static VECTORMATHOPENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VectorMathOpEntity",
    name_hash: 2141419816,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(VectorMathOpEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VectorMathOpEntity as Default>::default())),
            create_boxed: || Box::new(<VectorMathOpEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(VECTORMATHOPENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for VectorMathOpEntity {
    fn type_info(&self) -> &'static TypeInfo {
        VECTORMATHOPENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VECTORMATHOPENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VectorMathOpEntity-Array",
    name_hash: 1851234972,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("VectorMathOpEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct MathOpEntity {
    pub _glacier_base: Entity,
}

pub trait MathOpEntityTrait: EntityTrait {
}

impl MathOpEntityTrait for MathOpEntity {
}

impl EntityTrait for MathOpEntity {
}

impl EntityBusPeerTrait for MathOpEntity {
}

pub static MATHOPENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MathOpEntity",
    name_hash: 1240944593,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(MathOpEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MathOpEntity as Default>::default())),
            create_boxed: || Box::new(<MathOpEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(MATHOPENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for MathOpEntity {
    fn type_info(&self) -> &'static TypeInfo {
        MATHOPENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MATHOPENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MathOpEntity-Array",
    name_hash: 2195481061,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("MathOpEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct PropertyCastEntity {
    pub _glacier_base: Entity,
}

pub trait PropertyCastEntityTrait: EntityTrait {
}

impl PropertyCastEntityTrait for PropertyCastEntity {
}

impl EntityTrait for PropertyCastEntity {
}

impl EntityBusPeerTrait for PropertyCastEntity {
}

pub static PROPERTYCASTENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PropertyCastEntity",
    name_hash: 4210894300,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(PropertyCastEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PropertyCastEntity as Default>::default())),
            create_boxed: || Box::new(<PropertyCastEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(PROPERTYCASTENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for PropertyCastEntity {
    fn type_info(&self) -> &'static TypeInfo {
        PROPERTYCASTENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PROPERTYCASTENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PropertyCastEntity-Array",
    name_hash: 199683688,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("PropertyCastEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct BoolToEventEntity {
    pub _glacier_base: Entity,
}

pub trait BoolToEventEntityTrait: EntityTrait {
}

impl BoolToEventEntityTrait for BoolToEventEntity {
}

impl EntityTrait for BoolToEventEntity {
}

impl EntityBusPeerTrait for BoolToEventEntity {
}

pub static BOOLTOEVENTENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolToEventEntity",
    name_hash: 2146657191,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(BoolToEventEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BoolToEventEntity as Default>::default())),
            create_boxed: || Box::new(<BoolToEventEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(BOOLTOEVENTENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for BoolToEventEntity {
    fn type_info(&self) -> &'static TypeInfo {
        BOOLTOEVENTENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BOOLTOEVENTENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolToEventEntity-Array",
    name_hash: 3026023699,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("BoolToEventEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SwitchPropertyStringEntity {
    pub _glacier_base: Entity,
}

pub trait SwitchPropertyStringEntityTrait: EntityTrait {
}

impl SwitchPropertyStringEntityTrait for SwitchPropertyStringEntity {
}

impl EntityTrait for SwitchPropertyStringEntity {
}

impl EntityBusPeerTrait for SwitchPropertyStringEntity {
}

pub static SWITCHPROPERTYSTRINGENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SwitchPropertyStringEntity",
    name_hash: 568348798,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(SwitchPropertyStringEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SwitchPropertyStringEntity as Default>::default())),
            create_boxed: || Box::new(<SwitchPropertyStringEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(SWITCHPROPERTYSTRINGENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SwitchPropertyStringEntity {
    fn type_info(&self) -> &'static TypeInfo {
        SWITCHPROPERTYSTRINGENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SWITCHPROPERTYSTRINGENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SwitchPropertyStringEntity-Array",
    name_hash: 3068367178,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SwitchPropertyStringEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct PropertyGateEntity {
    pub _glacier_base: Entity,
}

pub trait PropertyGateEntityTrait: EntityTrait {
}

impl PropertyGateEntityTrait for PropertyGateEntity {
}

impl EntityTrait for PropertyGateEntity {
}

impl EntityBusPeerTrait for PropertyGateEntity {
}

pub static PROPERTYGATEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PropertyGateEntity",
    name_hash: 1303792494,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(PropertyGateEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PropertyGateEntity as Default>::default())),
            create_boxed: || Box::new(<PropertyGateEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(PROPERTYGATEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for PropertyGateEntity {
    fn type_info(&self) -> &'static TypeInfo {
        PROPERTYGATEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PROPERTYGATEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PropertyGateEntity-Array",
    name_hash: 947323994,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("PropertyGateEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct EventGateEntity {
    pub _glacier_base: Entity,
}

pub trait EventGateEntityTrait: EntityTrait {
}

impl EventGateEntityTrait for EventGateEntity {
}

impl EntityTrait for EventGateEntity {
}

impl EntityBusPeerTrait for EventGateEntity {
}

pub static EVENTGATEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventGateEntity",
    name_hash: 829813285,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(EventGateEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EventGateEntity as Default>::default())),
            create_boxed: || Box::new(<EventGateEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(EVENTGATEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for EventGateEntity {
    fn type_info(&self) -> &'static TypeInfo {
        EVENTGATEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EVENTGATEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventGateEntity-Array",
    name_hash: 2952293009,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EventGateEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct StopWatchEntity {
    pub _glacier_base: Entity,
}

pub trait StopWatchEntityTrait: EntityTrait {
}

impl StopWatchEntityTrait for StopWatchEntity {
}

impl EntityTrait for StopWatchEntity {
}

impl EntityBusPeerTrait for StopWatchEntity {
}

pub static STOPWATCHENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StopWatchEntity",
    name_hash: 988422415,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(StopWatchEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StopWatchEntity as Default>::default())),
            create_boxed: || Box::new(<StopWatchEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(STOPWATCHENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for StopWatchEntity {
    fn type_info(&self) -> &'static TypeInfo {
        STOPWATCHENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static STOPWATCHENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StopWatchEntity-Array",
    name_hash: 2728385979,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("StopWatchEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TransformToRotationEntity {
    pub _glacier_base: Entity,
}

pub trait TransformToRotationEntityTrait: EntityTrait {
}

impl TransformToRotationEntityTrait for TransformToRotationEntity {
}

impl EntityTrait for TransformToRotationEntity {
}

impl EntityBusPeerTrait for TransformToRotationEntity {
}

pub static TRANSFORMTOROTATIONENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformToRotationEntity",
    name_hash: 1274686685,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(TransformToRotationEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformToRotationEntity as Default>::default())),
            create_boxed: || Box::new(<TransformToRotationEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(TRANSFORMTOROTATIONENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for TransformToRotationEntity {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMTOROTATIONENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TRANSFORMTOROTATIONENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformToRotationEntity-Array",
    name_hash: 3901753577,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TransformToRotationEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TransformModifierEntity {
    pub _glacier_base: Entity,
}

pub trait TransformModifierEntityTrait: EntityTrait {
}

impl TransformModifierEntityTrait for TransformModifierEntity {
}

impl EntityTrait for TransformModifierEntity {
}

impl EntityBusPeerTrait for TransformModifierEntity {
}

pub static TRANSFORMMODIFIERENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformModifierEntity",
    name_hash: 1919893125,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(TransformModifierEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformModifierEntity as Default>::default())),
            create_boxed: || Box::new(<TransformModifierEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(TRANSFORMMODIFIERENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for TransformModifierEntity {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMMODIFIERENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TRANSFORMMODIFIERENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformModifierEntity-Array",
    name_hash: 2737653297,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TransformModifierEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct RotationTransformBuilderEntity {
    pub _glacier_base: Entity,
}

pub trait RotationTransformBuilderEntityTrait: EntityTrait {
}

impl RotationTransformBuilderEntityTrait for RotationTransformBuilderEntity {
}

impl EntityTrait for RotationTransformBuilderEntity {
}

impl EntityBusPeerTrait for RotationTransformBuilderEntity {
}

pub static ROTATIONTRANSFORMBUILDERENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RotationTransformBuilderEntity",
    name_hash: 955878087,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(RotationTransformBuilderEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RotationTransformBuilderEntity as Default>::default())),
            create_boxed: || Box::new(<RotationTransformBuilderEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(ROTATIONTRANSFORMBUILDERENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for RotationTransformBuilderEntity {
    fn type_info(&self) -> &'static TypeInfo {
        ROTATIONTRANSFORMBUILDERENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ROTATIONTRANSFORMBUILDERENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RotationTransformBuilderEntity-Array",
    name_hash: 3266837491,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("RotationTransformBuilderEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ScaleTransformBuilderEntity {
    pub _glacier_base: Entity,
}

pub trait ScaleTransformBuilderEntityTrait: EntityTrait {
}

impl ScaleTransformBuilderEntityTrait for ScaleTransformBuilderEntity {
}

impl EntityTrait for ScaleTransformBuilderEntity {
}

impl EntityBusPeerTrait for ScaleTransformBuilderEntity {
}

pub static SCALETRANSFORMBUILDERENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScaleTransformBuilderEntity",
    name_hash: 4079481227,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(ScaleTransformBuilderEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ScaleTransformBuilderEntity as Default>::default())),
            create_boxed: || Box::new(<ScaleTransformBuilderEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(SCALETRANSFORMBUILDERENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ScaleTransformBuilderEntity {
    fn type_info(&self) -> &'static TypeInfo {
        SCALETRANSFORMBUILDERENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SCALETRANSFORMBUILDERENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScaleTransformBuilderEntity-Array",
    name_hash: 2178441279,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ScaleTransformBuilderEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TransformBuilderEntity {
    pub _glacier_base: Entity,
}

pub trait TransformBuilderEntityTrait: EntityTrait {
}

impl TransformBuilderEntityTrait for TransformBuilderEntity {
}

impl EntityTrait for TransformBuilderEntity {
}

impl EntityBusPeerTrait for TransformBuilderEntity {
}

pub static TRANSFORMBUILDERENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformBuilderEntity",
    name_hash: 2362808851,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(TransformBuilderEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformBuilderEntity as Default>::default())),
            create_boxed: || Box::new(<TransformBuilderEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(TRANSFORMBUILDERENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for TransformBuilderEntity {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMBUILDERENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TRANSFORMBUILDERENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformBuilderEntity-Array",
    name_hash: 727045287,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TransformBuilderEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct VecBuilderEntity {
    pub _glacier_base: Entity,
}

pub trait VecBuilderEntityTrait: EntityTrait {
}

impl VecBuilderEntityTrait for VecBuilderEntity {
}

impl EntityTrait for VecBuilderEntity {
}

impl EntityBusPeerTrait for VecBuilderEntity {
}

pub static VECBUILDERENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VecBuilderEntity",
    name_hash: 3370321007,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(VecBuilderEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VecBuilderEntity as Default>::default())),
            create_boxed: || Box::new(<VecBuilderEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(VECBUILDERENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for VecBuilderEntity {
    fn type_info(&self) -> &'static TypeInfo {
        VECBUILDERENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VECBUILDERENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VecBuilderEntity-Array",
    name_hash: 561381979,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("VecBuilderEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct Vec4BuilderEntity {
    pub _glacier_base: Entity,
}

pub trait Vec4BuilderEntityTrait: EntityTrait {
}

impl Vec4BuilderEntityTrait for Vec4BuilderEntity {
}

impl EntityTrait for Vec4BuilderEntity {
}

impl EntityBusPeerTrait for Vec4BuilderEntity {
}

pub static VEC4BUILDERENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec4BuilderEntity",
    name_hash: 1815980155,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(Vec4BuilderEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec4BuilderEntity as Default>::default())),
            create_boxed: || Box::new(<Vec4BuilderEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(VEC4BUILDERENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for Vec4BuilderEntity {
    fn type_info(&self) -> &'static TypeInfo {
        VEC4BUILDERENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEC4BUILDERENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec4BuilderEntity-Array",
    name_hash: 1569636431,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec4BuilderEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct Vec3BuilderEntity {
    pub _glacier_base: Entity,
}

pub trait Vec3BuilderEntityTrait: EntityTrait {
}

impl Vec3BuilderEntityTrait for Vec3BuilderEntity {
}

impl EntityTrait for Vec3BuilderEntity {
}

impl EntityBusPeerTrait for Vec3BuilderEntity {
}

pub static VEC3BUILDERENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3BuilderEntity",
    name_hash: 1635798876,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(Vec3BuilderEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec3BuilderEntity as Default>::default())),
            create_boxed: || Box::new(<Vec3BuilderEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(VEC3BUILDERENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for Vec3BuilderEntity {
    fn type_info(&self) -> &'static TypeInfo {
        VEC3BUILDERENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEC3BUILDERENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3BuilderEntity-Array",
    name_hash: 2575513576,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec3BuilderEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct Vec2BuilderEntity {
    pub _glacier_base: Entity,
}

pub trait Vec2BuilderEntityTrait: EntityTrait {
}

impl Vec2BuilderEntityTrait for Vec2BuilderEntity {
}

impl EntityTrait for Vec2BuilderEntity {
}

impl EntityBusPeerTrait for Vec2BuilderEntity {
}

pub static VEC2BUILDERENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec2BuilderEntity",
    name_hash: 3150554813,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(Vec2BuilderEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec2BuilderEntity as Default>::default())),
            create_boxed: || Box::new(<Vec2BuilderEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(VEC2BUILDERENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for Vec2BuilderEntity {
    fn type_info(&self) -> &'static TypeInfo {
        VEC2BUILDERENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEC2BUILDERENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec2BuilderEntity-Array",
    name_hash: 4000555785,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec2BuilderEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct VecSplitterEntity {
    pub _glacier_base: Entity,
}

pub trait VecSplitterEntityTrait: EntityTrait {
}

impl VecSplitterEntityTrait for VecSplitterEntity {
}

impl EntityTrait for VecSplitterEntity {
}

impl EntityBusPeerTrait for VecSplitterEntity {
}

pub static VECSPLITTERENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VecSplitterEntity",
    name_hash: 3454261823,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(VecSplitterEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VecSplitterEntity as Default>::default())),
            create_boxed: || Box::new(<VecSplitterEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(VECSPLITTERENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for VecSplitterEntity {
    fn type_info(&self) -> &'static TypeInfo {
        VECSPLITTERENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VECSPLITTERENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VecSplitterEntity-Array",
    name_hash: 2642341771,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("VecSplitterEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct Vec4SplitterEntity {
    pub _glacier_base: Entity,
}

pub trait Vec4SplitterEntityTrait: EntityTrait {
}

impl Vec4SplitterEntityTrait for Vec4SplitterEntity {
}

impl EntityTrait for Vec4SplitterEntity {
}

impl EntityBusPeerTrait for Vec4SplitterEntity {
}

pub static VEC4SPLITTERENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec4SplitterEntity",
    name_hash: 482686891,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(Vec4SplitterEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec4SplitterEntity as Default>::default())),
            create_boxed: || Box::new(<Vec4SplitterEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(VEC4SPLITTERENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for Vec4SplitterEntity {
    fn type_info(&self) -> &'static TypeInfo {
        VEC4SPLITTERENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEC4SPLITTERENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec4SplitterEntity-Array",
    name_hash: 1165883167,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec4SplitterEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct Vec3SplitterEntity {
    pub _glacier_base: Entity,
}

pub trait Vec3SplitterEntityTrait: EntityTrait {
}

impl Vec3SplitterEntityTrait for Vec3SplitterEntity {
}

impl EntityTrait for Vec3SplitterEntity {
}

impl EntityBusPeerTrait for Vec3SplitterEntity {
}

pub static VEC3SPLITTERENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3SplitterEntity",
    name_hash: 1687229036,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(Vec3SplitterEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec3SplitterEntity as Default>::default())),
            create_boxed: || Box::new(<Vec3SplitterEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(VEC3SPLITTERENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for Vec3SplitterEntity {
    fn type_info(&self) -> &'static TypeInfo {
        VEC3SPLITTERENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEC3SPLITTERENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3SplitterEntity-Array",
    name_hash: 1985925720,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec3SplitterEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct Vec2SplitterEntity {
    pub _glacier_base: Entity,
}

pub trait Vec2SplitterEntityTrait: EntityTrait {
}

impl Vec2SplitterEntityTrait for Vec2SplitterEntity {
}

impl EntityTrait for Vec2SplitterEntity {
}

impl EntityBusPeerTrait for Vec2SplitterEntity {
}

pub static VEC2SPLITTERENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec2SplitterEntity",
    name_hash: 1713962285,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(Vec2SplitterEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec2SplitterEntity as Default>::default())),
            create_boxed: || Box::new(<Vec2SplitterEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(VEC2SPLITTERENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for Vec2SplitterEntity {
    fn type_info(&self) -> &'static TypeInfo {
        VEC2SPLITTERENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEC2SPLITTERENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec2SplitterEntity-Array",
    name_hash: 1644630425,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec2SplitterEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct EulerTransformEntity {
    pub _glacier_base: Entity,
}

pub trait EulerTransformEntityTrait: EntityTrait {
}

impl EulerTransformEntityTrait for EulerTransformEntity {
}

impl EntityTrait for EulerTransformEntity {
}

impl EntityBusPeerTrait for EulerTransformEntity {
}

pub static EULERTRANSFORMENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EulerTransformEntity",
    name_hash: 1443616185,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(EulerTransformEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EulerTransformEntity as Default>::default())),
            create_boxed: || Box::new(<EulerTransformEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(EULERTRANSFORMENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for EulerTransformEntity {
    fn type_info(&self) -> &'static TypeInfo {
        EULERTRANSFORMENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EULERTRANSFORMENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EulerTransformEntity-Array",
    name_hash: 2182964237,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EulerTransformEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct EulerTransformSplitterEntity {
    pub _glacier_base: Entity,
}

pub trait EulerTransformSplitterEntityTrait: EntityTrait {
}

impl EulerTransformSplitterEntityTrait for EulerTransformSplitterEntity {
}

impl EntityTrait for EulerTransformSplitterEntity {
}

impl EntityBusPeerTrait for EulerTransformSplitterEntity {
}

pub static EULERTRANSFORMSPLITTERENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EulerTransformSplitterEntity",
    name_hash: 588162632,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(EulerTransformSplitterEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EulerTransformSplitterEntity as Default>::default())),
            create_boxed: || Box::new(<EulerTransformSplitterEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(EULERTRANSFORMSPLITTERENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for EulerTransformSplitterEntity {
    fn type_info(&self) -> &'static TypeInfo {
        EULERTRANSFORMSPLITTERENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EULERTRANSFORMSPLITTERENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EulerTransformSplitterEntity-Array",
    name_hash: 3882113276,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EulerTransformSplitterEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TransformSplitterEntity {
    pub _glacier_base: Entity,
}

pub trait TransformSplitterEntityTrait: EntityTrait {
}

impl TransformSplitterEntityTrait for TransformSplitterEntity {
}

impl EntityTrait for TransformSplitterEntity {
}

impl EntityBusPeerTrait for TransformSplitterEntity {
}

pub static TRANSFORMSPLITTERENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformSplitterEntity",
    name_hash: 2774185347,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(TransformSplitterEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformSplitterEntity as Default>::default())),
            create_boxed: || Box::new(<TransformSplitterEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(TRANSFORMSPLITTERENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for TransformSplitterEntity {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMSPLITTERENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TRANSFORMSPLITTERENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformSplitterEntity-Array",
    name_hash: 3851339831,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TransformSplitterEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TransformSelectorEntity {
    pub _glacier_base: Entity,
}

pub trait TransformSelectorEntityTrait: EntityTrait {
}

impl TransformSelectorEntityTrait for TransformSelectorEntity {
}

impl EntityTrait for TransformSelectorEntity {
}

impl EntityBusPeerTrait for TransformSelectorEntity {
}

pub static TRANSFORMSELECTORENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformSelectorEntity",
    name_hash: 1097701799,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(TransformSelectorEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformSelectorEntity as Default>::default())),
            create_boxed: || Box::new(<TransformSelectorEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(TRANSFORMSELECTORENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for TransformSelectorEntity {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMSELECTORENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TRANSFORMSELECTORENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformSelectorEntity-Array",
    name_hash: 4062718739,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TransformSelectorEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TransformBlendEntity {
    pub _glacier_base: Entity,
}

pub trait TransformBlendEntityTrait: EntityTrait {
}

impl TransformBlendEntityTrait for TransformBlendEntity {
}

impl EntityTrait for TransformBlendEntity {
}

impl EntityBusPeerTrait for TransformBlendEntity {
}

pub static TRANSFORMBLENDENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformBlendEntity",
    name_hash: 1971498899,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(TransformBlendEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformBlendEntity as Default>::default())),
            create_boxed: || Box::new(<TransformBlendEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(TRANSFORMBLENDENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for TransformBlendEntity {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMBLENDENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TRANSFORMBLENDENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformBlendEntity-Array",
    name_hash: 635243047,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TransformBlendEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SimpleDofParamConverterEntity {
    pub _glacier_base: Entity,
}

pub trait SimpleDofParamConverterEntityTrait: EntityTrait {
}

impl SimpleDofParamConverterEntityTrait for SimpleDofParamConverterEntity {
}

impl EntityTrait for SimpleDofParamConverterEntity {
}

impl EntityBusPeerTrait for SimpleDofParamConverterEntity {
}

pub static SIMPLEDOFPARAMCONVERTERENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleDofParamConverterEntity",
    name_hash: 1224479058,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(SimpleDofParamConverterEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SimpleDofParamConverterEntity as Default>::default())),
            create_boxed: || Box::new(<SimpleDofParamConverterEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(SIMPLEDOFPARAMCONVERTERENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SimpleDofParamConverterEntity {
    fn type_info(&self) -> &'static TypeInfo {
        SIMPLEDOFPARAMCONVERTERENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SIMPLEDOFPARAMCONVERTERENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleDofParamConverterEntity-Array",
    name_hash: 3384928486,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SimpleDofParamConverterEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SpriteDofParamConverterEntity {
    pub _glacier_base: Entity,
}

pub trait SpriteDofParamConverterEntityTrait: EntityTrait {
}

impl SpriteDofParamConverterEntityTrait for SpriteDofParamConverterEntity {
}

impl EntityTrait for SpriteDofParamConverterEntity {
}

impl EntityBusPeerTrait for SpriteDofParamConverterEntity {
}

pub static SPRITEDOFPARAMCONVERTERENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpriteDofParamConverterEntity",
    name_hash: 3143253205,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(SpriteDofParamConverterEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SpriteDofParamConverterEntity as Default>::default())),
            create_boxed: || Box::new(<SpriteDofParamConverterEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(SPRITEDOFPARAMCONVERTERENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SpriteDofParamConverterEntity {
    fn type_info(&self) -> &'static TypeInfo {
        SPRITEDOFPARAMCONVERTERENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SPRITEDOFPARAMCONVERTERENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpriteDofParamConverterEntity-Array",
    name_hash: 3241983201,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SpriteDofParamConverterEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TransformMultiplierEntity {
    pub _glacier_base: Entity,
}

pub trait TransformMultiplierEntityTrait: EntityTrait {
}

impl TransformMultiplierEntityTrait for TransformMultiplierEntity {
}

impl EntityTrait for TransformMultiplierEntity {
}

impl EntityBusPeerTrait for TransformMultiplierEntity {
}

pub static TRANSFORMMULTIPLIERENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformMultiplierEntity",
    name_hash: 3778032441,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(TransformMultiplierEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformMultiplierEntity as Default>::default())),
            create_boxed: || Box::new(<TransformMultiplierEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(TRANSFORMMULTIPLIERENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for TransformMultiplierEntity {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMMULTIPLIERENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TRANSFORMMULTIPLIERENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformMultiplierEntity-Array",
    name_hash: 1030873485,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TransformMultiplierEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TransformHubEntity {
    pub _glacier_base: Entity,
}

pub trait TransformHubEntityTrait: EntityTrait {
}

impl TransformHubEntityTrait for TransformHubEntity {
}

impl EntityTrait for TransformHubEntity {
}

impl EntityBusPeerTrait for TransformHubEntity {
}

pub static TRANSFORMHUBENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformHubEntity",
    name_hash: 1935455405,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(TransformHubEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformHubEntity as Default>::default())),
            create_boxed: || Box::new(<TransformHubEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(TRANSFORMHUBENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for TransformHubEntity {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMHUBENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TRANSFORMHUBENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformHubEntity-Array",
    name_hash: 2818992409,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TransformHubEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct StringHubEntity {
    pub _glacier_base: Entity,
}

pub trait StringHubEntityTrait: EntityTrait {
}

impl StringHubEntityTrait for StringHubEntity {
}

impl EntityTrait for StringHubEntity {
}

impl EntityBusPeerTrait for StringHubEntity {
}

pub static STRINGHUBENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StringHubEntity",
    name_hash: 1386921524,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(StringHubEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StringHubEntity as Default>::default())),
            create_boxed: || Box::new(<StringHubEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(STRINGHUBENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for StringHubEntity {
    fn type_info(&self) -> &'static TypeInfo {
        STRINGHUBENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static STRINGHUBENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StringHubEntity-Array",
    name_hash: 1263647104,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("StringHubEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct Vec4HubEntity {
    pub _glacier_base: Entity,
}

pub trait Vec4HubEntityTrait: EntityTrait {
}

impl Vec4HubEntityTrait for Vec4HubEntity {
}

impl EntityTrait for Vec4HubEntity {
}

impl EntityBusPeerTrait for Vec4HubEntity {
}

pub static VEC4HUBENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec4HubEntity",
    name_hash: 3008256901,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(Vec4HubEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec4HubEntity as Default>::default())),
            create_boxed: || Box::new(<Vec4HubEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(VEC4HUBENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for Vec4HubEntity {
    fn type_info(&self) -> &'static TypeInfo {
        VEC4HUBENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEC4HUBENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec4HubEntity-Array",
    name_hash: 674112305,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec4HubEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct Vec3HubEntity {
    pub _glacier_base: Entity,
}

pub trait Vec3HubEntityTrait: EntityTrait {
}

impl Vec3HubEntityTrait for Vec3HubEntity {
}

impl EntityTrait for Vec3HubEntity {
}

impl EntityBusPeerTrait for Vec3HubEntity {
}

pub static VEC3HUBENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3HubEntity",
    name_hash: 2737450402,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(Vec3HubEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec3HubEntity as Default>::default())),
            create_boxed: || Box::new(<Vec3HubEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(VEC3HUBENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for Vec3HubEntity {
    fn type_info(&self) -> &'static TypeInfo {
        VEC3HUBENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEC3HUBENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3HubEntity-Array",
    name_hash: 1710017558,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec3HubEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct Vec2HubEntity {
    pub _glacier_base: Entity,
}

pub trait Vec2HubEntityTrait: EntityTrait {
}

impl Vec2HubEntityTrait for Vec2HubEntity {
}

impl EntityTrait for Vec2HubEntity {
}

impl EntityBusPeerTrait for Vec2HubEntity {
}

pub static VEC2HUBENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec2HubEntity",
    name_hash: 2414849731,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(Vec2HubEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec2HubEntity as Default>::default())),
            create_boxed: || Box::new(<Vec2HubEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(VEC2HUBENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for Vec2HubEntity {
    fn type_info(&self) -> &'static TypeInfo {
        VEC2HUBENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEC2HUBENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec2HubEntity-Array",
    name_hash: 158953975,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec2HubEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct FloatHubEntity {
    pub _glacier_base: Entity,
}

pub trait FloatHubEntityTrait: EntityTrait {
}

impl FloatHubEntityTrait for FloatHubEntity {
}

impl EntityTrait for FloatHubEntity {
}

impl EntityBusPeerTrait for FloatHubEntity {
}

pub static FLOATHUBENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatHubEntity",
    name_hash: 2058934737,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(FloatHubEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FloatHubEntity as Default>::default())),
            create_boxed: || Box::new(<FloatHubEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(FLOATHUBENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for FloatHubEntity {
    fn type_info(&self) -> &'static TypeInfo {
        FLOATHUBENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FLOATHUBENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatHubEntity-Array",
    name_hash: 1696426981,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("FloatHubEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct Int64HubEntity {
    pub _glacier_base: Entity,
}

pub trait Int64HubEntityTrait: EntityTrait {
}

impl Int64HubEntityTrait for Int64HubEntity {
}

impl EntityTrait for Int64HubEntity {
}

impl EntityBusPeerTrait for Int64HubEntity {
}

pub static INT64HUBENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Int64HubEntity",
    name_hash: 2910102032,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(Int64HubEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Int64HubEntity as Default>::default())),
            create_boxed: || Box::new(<Int64HubEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(INT64HUBENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for Int64HubEntity {
    fn type_info(&self) -> &'static TypeInfo {
        INT64HUBENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static INT64HUBENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Int64HubEntity-Array",
    name_hash: 2199359524,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Int64HubEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct IntHubEntity {
    pub _glacier_base: Entity,
}

pub trait IntHubEntityTrait: EntityTrait {
}

impl IntHubEntityTrait for IntHubEntity {
}

impl EntityTrait for IntHubEntity {
}

impl EntityBusPeerTrait for IntHubEntity {
}

pub static INTHUBENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntHubEntity",
    name_hash: 57449362,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(IntHubEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<IntHubEntity as Default>::default())),
            create_boxed: || Box::new(<IntHubEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(INTHUBENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for IntHubEntity {
    fn type_info(&self) -> &'static TypeInfo {
        INTHUBENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static INTHUBENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntHubEntity-Array",
    name_hash: 2989548198,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("IntHubEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct BoolHubEntity {
    pub _glacier_base: Entity,
}

pub trait BoolHubEntityTrait: EntityTrait {
}

impl BoolHubEntityTrait for BoolHubEntity {
}

impl EntityTrait for BoolHubEntity {
}

impl EntityBusPeerTrait for BoolHubEntity {
}

pub static BOOLHUBENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolHubEntity",
    name_hash: 973927567,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(BoolHubEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BoolHubEntity as Default>::default())),
            create_boxed: || Box::new(<BoolHubEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(BOOLHUBENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for BoolHubEntity {
    fn type_info(&self) -> &'static TypeInfo {
        BOOLHUBENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BOOLHUBENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolHubEntity-Array",
    name_hash: 2960347451,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("BoolHubEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ObjectVariationSwitchEntity {
    pub _glacier_base: Entity,
}

pub trait ObjectVariationSwitchEntityTrait: EntityTrait {
}

impl ObjectVariationSwitchEntityTrait for ObjectVariationSwitchEntity {
}

impl EntityTrait for ObjectVariationSwitchEntity {
}

impl EntityBusPeerTrait for ObjectVariationSwitchEntity {
}

pub static OBJECTVARIATIONSWITCHENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectVariationSwitchEntity",
    name_hash: 1456606152,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(ObjectVariationSwitchEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ObjectVariationSwitchEntity as Default>::default())),
            create_boxed: || Box::new(<ObjectVariationSwitchEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(OBJECTVARIATIONSWITCHENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ObjectVariationSwitchEntity {
    fn type_info(&self) -> &'static TypeInfo {
        OBJECTVARIATIONSWITCHENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static OBJECTVARIATIONSWITCHENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectVariationSwitchEntity-Array",
    name_hash: 3632127612,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ObjectVariationSwitchEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ObjectVariationMultiSwitchEntity {
    pub _glacier_base: Entity,
}

pub trait ObjectVariationMultiSwitchEntityTrait: EntityTrait {
}

impl ObjectVariationMultiSwitchEntityTrait for ObjectVariationMultiSwitchEntity {
}

impl EntityTrait for ObjectVariationMultiSwitchEntity {
}

impl EntityBusPeerTrait for ObjectVariationMultiSwitchEntity {
}

pub static OBJECTVARIATIONMULTISWITCHENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectVariationMultiSwitchEntity",
    name_hash: 1908078465,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(ObjectVariationMultiSwitchEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ObjectVariationMultiSwitchEntity as Default>::default())),
            create_boxed: || Box::new(<ObjectVariationMultiSwitchEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(OBJECTVARIATIONMULTISWITCHENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ObjectVariationMultiSwitchEntity {
    fn type_info(&self) -> &'static TypeInfo {
        OBJECTVARIATIONMULTISWITCHENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static OBJECTVARIATIONMULTISWITCHENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectVariationMultiSwitchEntity-Array",
    name_hash: 1667240245,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ObjectVariationMultiSwitchEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct RandomDelayEntity {
    pub _glacier_base: Entity,
}

pub trait RandomDelayEntityTrait: EntityTrait {
}

impl RandomDelayEntityTrait for RandomDelayEntity {
}

impl EntityTrait for RandomDelayEntity {
}

impl EntityBusPeerTrait for RandomDelayEntity {
}

pub static RANDOMDELAYENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RandomDelayEntity",
    name_hash: 2891506704,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(RandomDelayEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RandomDelayEntity as Default>::default())),
            create_boxed: || Box::new(<RandomDelayEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(RANDOMDELAYENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for RandomDelayEntity {
    fn type_info(&self) -> &'static TypeInfo {
        RANDOMDELAYENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RANDOMDELAYENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RandomDelayEntity-Array",
    name_hash: 2695189028,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("RandomDelayEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct DelayEntity {
    pub _glacier_base: Entity,
}

pub trait DelayEntityTrait: EntityTrait {
}

impl DelayEntityTrait for DelayEntity {
}

impl EntityTrait for DelayEntity {
}

impl EntityBusPeerTrait for DelayEntity {
}

pub static DELAYENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DelayEntity",
    name_hash: 3537395115,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(DelayEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DelayEntity as Default>::default())),
            create_boxed: || Box::new(<DelayEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(DELAYENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for DelayEntity {
    fn type_info(&self) -> &'static TypeInfo {
        DELAYENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DELAYENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DelayEntity-Array",
    name_hash: 584424735,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("DelayEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SelectEventEntity {
    pub _glacier_base: Entity,
}

pub trait SelectEventEntityTrait: EntityTrait {
}

impl SelectEventEntityTrait for SelectEventEntity {
}

impl EntityTrait for SelectEventEntity {
}

impl EntityBusPeerTrait for SelectEventEntity {
}

pub static SELECTEVENTENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectEventEntity",
    name_hash: 2589373402,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(SelectEventEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SelectEventEntity as Default>::default())),
            create_boxed: || Box::new(<SelectEventEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(SELECTEVENTENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SelectEventEntity {
    fn type_info(&self) -> &'static TypeInfo {
        SELECTEVENTENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SELECTEVENTENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectEventEntity-Array",
    name_hash: 1353434990,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SelectEventEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct EventOrderGateEntity {
    pub _glacier_base: Entity,
}

pub trait EventOrderGateEntityTrait: EntityTrait {
}

impl EventOrderGateEntityTrait for EventOrderGateEntity {
}

impl EntityTrait for EventOrderGateEntity {
}

impl EntityBusPeerTrait for EventOrderGateEntity {
}

pub static EVENTORDERGATEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventOrderGateEntity",
    name_hash: 3164010923,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(EventOrderGateEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EventOrderGateEntity as Default>::default())),
            create_boxed: || Box::new(<EventOrderGateEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(EVENTORDERGATEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for EventOrderGateEntity {
    fn type_info(&self) -> &'static TypeInfo {
        EVENTORDERGATEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EVENTORDERGATEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventOrderGateEntity-Array",
    name_hash: 1612265759,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EventOrderGateEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct EventAndGateEntity {
    pub _glacier_base: Entity,
}

pub trait EventAndGateEntityTrait: EntityTrait {
}

impl EventAndGateEntityTrait for EventAndGateEntity {
}

impl EntityTrait for EventAndGateEntity {
}

impl EntityBusPeerTrait for EventAndGateEntity {
}

pub static EVENTANDGATEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventAndGateEntity",
    name_hash: 1946825294,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(EventAndGateEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EventAndGateEntity as Default>::default())),
            create_boxed: || Box::new(<EventAndGateEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(EVENTANDGATEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for EventAndGateEntity {
    fn type_info(&self) -> &'static TypeInfo {
        EVENTANDGATEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EVENTANDGATEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventAndGateEntity-Array",
    name_hash: 1565592570,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EventAndGateEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct EventSwitchEntity {
    pub _glacier_base: Entity,
}

pub trait EventSwitchEntityTrait: EntityTrait {
}

impl EventSwitchEntityTrait for EventSwitchEntity {
}

impl EntityTrait for EventSwitchEntity {
}

impl EntityBusPeerTrait for EventSwitchEntity {
}

pub static EVENTSWITCHENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventSwitchEntity",
    name_hash: 919432800,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(EventSwitchEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EventSwitchEntity as Default>::default())),
            create_boxed: || Box::new(<EventSwitchEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(EVENTSWITCHENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for EventSwitchEntity {
    fn type_info(&self) -> &'static TypeInfo {
        EVENTSWITCHENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EVENTSWITCHENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventSwitchEntity-Array",
    name_hash: 2410751060,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EventSwitchEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct UniqueIdEntity {
    pub _glacier_base: Entity,
}

pub trait UniqueIdEntityTrait: EntityTrait {
}

impl UniqueIdEntityTrait for UniqueIdEntity {
}

impl EntityTrait for UniqueIdEntity {
}

impl EntityBusPeerTrait for UniqueIdEntity {
}

pub static UNIQUEIDENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UniqueIdEntity",
    name_hash: 3100226368,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(UniqueIdEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<UniqueIdEntity as Default>::default())),
            create_boxed: || Box::new(<UniqueIdEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(UNIQUEIDENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for UniqueIdEntity {
    fn type_info(&self) -> &'static TypeInfo {
        UNIQUEIDENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static UNIQUEIDENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UniqueIdEntity-Array",
    name_hash: 267766260,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("UniqueIdEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct RandomIntEntity {
    pub _glacier_base: Entity,
}

pub trait RandomIntEntityTrait: EntityTrait {
}

impl RandomIntEntityTrait for RandomIntEntity {
}

impl EntityTrait for RandomIntEntity {
}

impl EntityBusPeerTrait for RandomIntEntity {
}

pub static RANDOMINTENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RandomIntEntity",
    name_hash: 2292544598,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(RandomIntEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RandomIntEntity as Default>::default())),
            create_boxed: || Box::new(<RandomIntEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(RANDOMINTENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for RandomIntEntity {
    fn type_info(&self) -> &'static TypeInfo {
        RANDOMINTENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RANDOMINTENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RandomIntEntity-Array",
    name_hash: 1256798690,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("RandomIntEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct RandomFloatEntity {
    pub _glacier_base: Entity,
}

pub trait RandomFloatEntityTrait: EntityTrait {
}

impl RandomFloatEntityTrait for RandomFloatEntity {
}

impl EntityTrait for RandomFloatEntity {
}

impl EntityBusPeerTrait for RandomFloatEntity {
}

pub static RANDOMFLOATENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RandomFloatEntity",
    name_hash: 2009743861,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(RandomFloatEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RandomFloatEntity as Default>::default())),
            create_boxed: || Box::new(<RandomFloatEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(RANDOMFLOATENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for RandomFloatEntity {
    fn type_info(&self) -> &'static TypeInfo {
        RANDOMFLOATENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RANDOMFLOATENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RandomFloatEntity-Array",
    name_hash: 849121985,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("RandomFloatEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct RandomMultiEventEntity {
    pub _glacier_base: Entity,
}

pub trait RandomMultiEventEntityTrait: EntityTrait {
}

impl RandomMultiEventEntityTrait for RandomMultiEventEntity {
}

impl EntityTrait for RandomMultiEventEntity {
}

impl EntityBusPeerTrait for RandomMultiEventEntity {
}

pub static RANDOMMULTIEVENTENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RandomMultiEventEntity",
    name_hash: 4223229120,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(RandomMultiEventEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RandomMultiEventEntity as Default>::default())),
            create_boxed: || Box::new(<RandomMultiEventEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(RANDOMMULTIEVENTENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for RandomMultiEventEntity {
    fn type_info(&self) -> &'static TypeInfo {
        RANDOMMULTIEVENTENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RANDOMMULTIEVENTENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RandomMultiEventEntity-Array",
    name_hash: 962499444,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("RandomMultiEventEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct RandomEventEntity {
    pub _glacier_base: Entity,
}

pub trait RandomEventEntityTrait: EntityTrait {
}

impl RandomEventEntityTrait for RandomEventEntity {
}

impl EntityTrait for RandomEventEntity {
}

impl EntityBusPeerTrait for RandomEventEntity {
}

pub static RANDOMEVENTENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RandomEventEntity",
    name_hash: 3262841993,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(RandomEventEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RandomEventEntity as Default>::default())),
            create_boxed: || Box::new(<RandomEventEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(RANDOMEVENTENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for RandomEventEntity {
    fn type_info(&self) -> &'static TypeInfo {
        RANDOMEVENTENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RANDOMEVENTENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RandomEventEntity-Array",
    name_hash: 1001732669,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("RandomEventEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct LocatorEntity {
    pub _glacier_base: SpatialEntity,
}

pub trait LocatorEntityTrait: SpatialEntityTrait {
}

impl LocatorEntityTrait for LocatorEntity {
}

impl SpatialEntityTrait for LocatorEntity {
}

impl EntityTrait for LocatorEntity {
}

impl EntityBusPeerTrait for LocatorEntity {
}

pub static LOCATORENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocatorEntity",
    name_hash: 2277409814,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SPATIALENTITY_TYPE_INFO),
        super_class_offset: offset_of!(LocatorEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LocatorEntity as Default>::default())),
            create_boxed: || Box::new(<LocatorEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(LOCATORENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for LocatorEntity {
    fn type_info(&self) -> &'static TypeInfo {
        LOCATORENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LOCATORENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocatorEntity-Array",
    name_hash: 3568228642,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("LocatorEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CountDownEntity {
    pub _glacier_base: Entity,
}

pub trait CountDownEntityTrait: EntityTrait {
}

impl CountDownEntityTrait for CountDownEntity {
}

impl EntityTrait for CountDownEntity {
}

impl EntityBusPeerTrait for CountDownEntity {
}

pub static COUNTDOWNENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CountDownEntity",
    name_hash: 2556851791,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(CountDownEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CountDownEntity as Default>::default())),
            create_boxed: || Box::new(<CountDownEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(COUNTDOWNENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for CountDownEntity {
    fn type_info(&self) -> &'static TypeInfo {
        COUNTDOWNENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COUNTDOWNENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CountDownEntity-Array",
    name_hash: 2022105979,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CountDownEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct MathEntity {
    pub _glacier_base: Entity,
}

pub trait MathEntityTrait: EntityTrait {
}

impl MathEntityTrait for MathEntity {
}

impl EntityTrait for MathEntity {
}

impl EntityBusPeerTrait for MathEntity {
}

pub static MATHENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MathEntity",
    name_hash: 1169209998,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(MathEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MathEntity as Default>::default())),
            create_boxed: || Box::new(<MathEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(MATHENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for MathEntity {
    fn type_info(&self) -> &'static TypeInfo {
        MATHENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MATHENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MathEntity-Array",
    name_hash: 2029814714,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("MathEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct Or4Entity {
    pub _glacier_base: Entity,
}

pub trait Or4EntityTrait: EntityTrait {
}

impl Or4EntityTrait for Or4Entity {
}

impl EntityTrait for Or4Entity {
}

impl EntityBusPeerTrait for Or4Entity {
}

pub static OR4ENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Or4Entity",
    name_hash: 814865591,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(Or4Entity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Or4Entity as Default>::default())),
            create_boxed: || Box::new(<Or4Entity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(OR4ENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for Or4Entity {
    fn type_info(&self) -> &'static TypeInfo {
        OR4ENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static OR4ENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Or4Entity-Array",
    name_hash: 4190467587,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Or4Entity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct XorEntity {
    pub _glacier_base: Entity,
}

pub trait XorEntityTrait: EntityTrait {
}

impl XorEntityTrait for XorEntity {
}

impl EntityTrait for XorEntity {
}

impl EntityBusPeerTrait for XorEntity {
}

pub static XORENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "XorEntity",
    name_hash: 496671195,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(XorEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<XorEntity as Default>::default())),
            create_boxed: || Box::new(<XorEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(XORENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for XorEntity {
    fn type_info(&self) -> &'static TypeInfo {
        XORENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static XORENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "XorEntity-Array",
    name_hash: 1987756271,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("XorEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct OrEntity {
    pub _glacier_base: Entity,
}

pub trait OrEntityTrait: EntityTrait {
}

impl OrEntityTrait for OrEntity {
}

impl EntityTrait for OrEntity {
}

impl EntityBusPeerTrait for OrEntity {
}

pub static ORENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OrEntity",
    name_hash: 1986133699,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(OrEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<OrEntity as Default>::default())),
            create_boxed: || Box::new(<OrEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(ORENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for OrEntity {
    fn type_info(&self) -> &'static TypeInfo {
        ORENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ORENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OrEntity-Array",
    name_hash: 2959589879,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("OrEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct BitwiseAndEntity {
    pub _glacier_base: Entity,
}

pub trait BitwiseAndEntityTrait: EntityTrait {
}

impl BitwiseAndEntityTrait for BitwiseAndEntity {
}

impl EntityTrait for BitwiseAndEntity {
}

impl EntityBusPeerTrait for BitwiseAndEntity {
}

pub static BITWISEANDENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BitwiseAndEntity",
    name_hash: 2377199106,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(BitwiseAndEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BitwiseAndEntity as Default>::default())),
            create_boxed: || Box::new(<BitwiseAndEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(BITWISEANDENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for BitwiseAndEntity {
    fn type_info(&self) -> &'static TypeInfo {
        BITWISEANDENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BITWISEANDENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BitwiseAndEntity-Array",
    name_hash: 1134988598,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("BitwiseAndEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct AndEntity {
    pub _glacier_base: Entity,
}

pub trait AndEntityTrait: EntityTrait {
}

impl AndEntityTrait for AndEntity {
}

impl EntityTrait for AndEntity {
}

impl EntityBusPeerTrait for AndEntity {
}

pub static ANDENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AndEntity",
    name_hash: 2357770869,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(AndEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AndEntity as Default>::default())),
            create_boxed: || Box::new(<AndEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(ANDENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for AndEntity {
    fn type_info(&self) -> &'static TypeInfo {
        ANDENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANDENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AndEntity-Array",
    name_hash: 661875521,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("AndEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct NotEntity {
    pub _glacier_base: Entity,
}

pub trait NotEntityTrait: EntityTrait {
}

impl NotEntityTrait for NotEntity {
}

impl EntityTrait for NotEntity {
}

impl EntityBusPeerTrait for NotEntity {
}

pub static NOTENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NotEntity",
    name_hash: 2184782155,
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        super_class_offset: offset_of!(NotEntity, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<NotEntity as Default>::default())),
            create_boxed: || Box::new(<NotEntity as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(NOTENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for NotEntity {
    fn type_info(&self) -> &'static TypeInfo {
        NOTENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static NOTENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NotEntity-Array",
    name_hash: 4247658623,
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("NotEntity"),
    array_type: None,
    alignment: 8,
};


