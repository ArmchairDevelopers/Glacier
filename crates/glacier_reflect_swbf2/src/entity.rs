use std::{mem::offset_of, any::Any, option::Option, sync::Arc};
use tokio::sync::Mutex;

use glacier_reflect::{
    member::MemberInfoFlags,
    type_info::{
        ClassInfoData, ValueTypeInfoData, FieldInfoData, TypeInfo, TypeInfoData, TypeObject, TypeFunctions,
    }, type_registry::TypeRegistry,
};

pub(crate) fn register_entity_types(registry: &mut TypeRegistry) {
    registry.register_type(WORLDPARTINCLUSION_TYPE_INFO);
    registry.register_type(WORLDPARTINCLUSION_ARRAY_TYPE_INFO);
    registry.register_type(WORLDPARTINCLUSIONCRITERION_TYPE_INFO);
    registry.register_type(WORLDPARTINCLUSIONCRITERION_ARRAY_TYPE_INFO);
    registry.register_type(WORLDPARTINCLUSIONSETTING_TYPE_INFO);
    registry.register_type(WORLDPARTINCLUSIONSETTING_ARRAY_TYPE_INFO);
    registry.register_type(WORLDPARTINCLUSIONSETTINGS_TYPE_INFO);
    registry.register_type(WORLDPARTINCLUSIONSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(ASSEMBLYDESCRIPTORDATA_TYPE_INFO);
    registry.register_type(ASSEMBLYDESCRIPTORDATA_ARRAY_TYPE_INFO);
    registry.register_type(WORLDOBJECTLISTDATA_TYPE_INFO);
    registry.register_type(WORLDOBJECTLISTDATA_ARRAY_TYPE_INFO);
    registry.register_type(WORLDPARTREFERENCEOBJECTDATA_TYPE_INFO);
    registry.register_type(WORLDPARTREFERENCEOBJECTDATA_ARRAY_TYPE_INFO);
    registry.register_type(READONLYLAYERREFERENCEOBJECTDATA_TYPE_INFO);
    registry.register_type(READONLYLAYERREFERENCEOBJECTDATA_ARRAY_TYPE_INFO);
    registry.register_type(LAYERREFERENCEOBJECTDATA_TYPE_INFO);
    registry.register_type(LAYERREFERENCEOBJECTDATA_ARRAY_TYPE_INFO);
    registry.register_type(SUBWORLDREFERENCEOBJECTDATA_TYPE_INFO);
    registry.register_type(SUBWORLDREFERENCEOBJECTDATA_ARRAY_TYPE_INFO);
    registry.register_type(DETACHEDSUBWORLDDATA_TYPE_INFO);
    registry.register_type(DETACHEDSUBWORLDDATA_ARRAY_TYPE_INFO);
    registry.register_type(WORLDDATA_TYPE_INFO);
    registry.register_type(WORLDDATA_ARRAY_TYPE_INFO);
    registry.register_type(SUBWORLDDATA_TYPE_INFO);
    registry.register_type(SUBWORLDDATA_ARRAY_TYPE_INFO);
    registry.register_type(SUBWORLDDATACOMPONENT_TYPE_INFO);
    registry.register_type(SUBWORLDDATACOMPONENT_ARRAY_TYPE_INFO);
    registry.register_type(WORLDPARTDATA_TYPE_INFO);
    registry.register_type(WORLDPARTDATA_ARRAY_TYPE_INFO);
    registry.register_type(LAYERDATA_TYPE_INFO);
    registry.register_type(LAYERDATA_ARRAY_TYPE_INFO);
    registry.register_type(SUBWORLDINCLUSIONSETTINGS_TYPE_INFO);
    registry.register_type(SUBWORLDINCLUSIONSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(SUBWORLDINCLUSIONSETTING_TYPE_INFO);
    registry.register_type(SUBWORLDINCLUSIONSETTING_ARRAY_TYPE_INFO);
    registry.register_type(SUBWORLDINCLUSION_TYPE_INFO);
    registry.register_type(SUBWORLDINCLUSION_ARRAY_TYPE_INFO);
    registry.register_type(SUBWORLDINCLUSIONCRITERION_TYPE_INFO);
    registry.register_type(SUBWORLDINCLUSIONCRITERION_ARRAY_TYPE_INFO);
    registry.register_type(LEVELSETUP_TYPE_INFO);
    registry.register_type(LEVELSETUP_ARRAY_TYPE_INFO);
    registry.register_type(LEVELSETUPOPTION_TYPE_INFO);
    registry.register_type(LEVELSETUPOPTION_ARRAY_TYPE_INFO);
    registry.register_type(CREATESCHEMATICSINSTANCEENTITY_TYPE_INFO);
    registry.register_type(CREATESCHEMATICSINSTANCEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(GETENTITYBUSENTITY_TYPE_INFO);
    registry.register_type(GETENTITYBUSENTITY_ARRAY_TYPE_INFO);
    registry.register_type(GETENTITYENTITY_TYPE_INFO);
    registry.register_type(GETENTITYENTITY_ARRAY_TYPE_INFO);
    registry.register_type(CALLFUNCTIONENTITY_TYPE_INFO);
    registry.register_type(CALLFUNCTIONENTITY_ARRAY_TYPE_INFO);
    registry.register_type(ENTITYTRANSFORMSPACE_TYPE_INFO);
    registry.register_type(ENTITYTRANSFORMSPACE_ARRAY_TYPE_INFO);
    registry.register_type(ENTITY_TYPE_INFO);
    registry.register_type(ENTITY_ARRAY_TYPE_INFO);
    registry.register_type(COMPONENTENTITY_TYPE_INFO);
    registry.register_type(COMPONENTENTITY_ARRAY_TYPE_INFO);
    registry.register_type(COMPONENT_TYPE_INFO);
    registry.register_type(COMPONENT_ARRAY_TYPE_INFO);
    registry.register_type(COMPAREAXISALIGNEDBOXENTITY_TYPE_INFO);
    registry.register_type(COMPAREAXISALIGNEDBOXENTITY_ARRAY_TYPE_INFO);
    registry.register_type(COMPAREUINTRANGEENTITY_TYPE_INFO);
    registry.register_type(COMPAREUINTRANGEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(COMPAREINTRANGEENTITY_TYPE_INFO);
    registry.register_type(COMPAREINTRANGEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(COMPAREVEC4ENTITY_TYPE_INFO);
    registry.register_type(COMPAREVEC4ENTITY_ARRAY_TYPE_INFO);
    registry.register_type(COMPAREVEC3ENTITY_TYPE_INFO);
    registry.register_type(COMPAREVEC3ENTITY_ARRAY_TYPE_INFO);
    registry.register_type(COMPAREFLOATRANGEENTITY_TYPE_INFO);
    registry.register_type(COMPAREFLOATRANGEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(COMPARESTRINGENTITY_TYPE_INFO);
    registry.register_type(COMPARESTRINGENTITY_ARRAY_TYPE_INFO);
    registry.register_type(COMPAREFLOATENTITY_TYPE_INFO);
    registry.register_type(COMPAREFLOATENTITY_ARRAY_TYPE_INFO);
    registry.register_type(COMPAREUINTENTITY_TYPE_INFO);
    registry.register_type(COMPAREUINTENTITY_ARRAY_TYPE_INFO);
    registry.register_type(COMPAREINTENTITY_TYPE_INFO);
    registry.register_type(COMPAREINTENTITY_ARRAY_TYPE_INFO);
    registry.register_type(COMPAREBOOLENTITY_TYPE_INFO);
    registry.register_type(COMPAREBOOLENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SERVERDILATIONENTITY_TYPE_INFO);
    registry.register_type(SERVERDILATIONENTITY_ARRAY_TYPE_INFO);
    registry.register_type(CLIENTBALANCEDDILATIONENTITY_TYPE_INFO);
    registry.register_type(CLIENTBALANCEDDILATIONENTITY_ARRAY_TYPE_INFO);
    registry.register_type(ANIMTRACKDATA_TYPE_INFO);
    registry.register_type(ANIMTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(SEQUENCEENTITY_TYPE_INFO);
    registry.register_type(SEQUENCEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(STRINGBUILDERENTITY_TYPE_INFO);
    registry.register_type(STRINGBUILDERENTITY_ARRAY_TYPE_INFO);
    registry.register_type(VEC4CHANGEDENTITY_TYPE_INFO);
    registry.register_type(VEC4CHANGEDENTITY_ARRAY_TYPE_INFO);
    registry.register_type(VEC3CHANGEDENTITY_TYPE_INFO);
    registry.register_type(VEC3CHANGEDENTITY_ARRAY_TYPE_INFO);
    registry.register_type(VEC2CHANGEDENTITY_TYPE_INFO);
    registry.register_type(VEC2CHANGEDENTITY_ARRAY_TYPE_INFO);
    registry.register_type(INTCHANGEDENTITY_TYPE_INFO);
    registry.register_type(INTCHANGEDENTITY_ARRAY_TYPE_INFO);
    registry.register_type(FLOATCHANGEDENTITY_TYPE_INFO);
    registry.register_type(FLOATCHANGEDENTITY_ARRAY_TYPE_INFO);
    registry.register_type(BOOLCHANGEDENTITY_TYPE_INFO);
    registry.register_type(BOOLCHANGEDENTITY_ARRAY_TYPE_INFO);
    registry.register_type(COMPARETRANSFORMENTITY_TYPE_INFO);
    registry.register_type(COMPARETRANSFORMENTITY_ARRAY_TYPE_INFO);
    registry.register_type(GETSCHEMATICSINSTANCE_SCHEMATICSINSTANCE_ENTITY__TYPE_INFO);
    registry.register_type(GETSCHEMATICSINSTANCE_SCHEMATICSINSTANCE_ENTITYBUS__TYPE_INFO);
    registry.register_type(DESTROYENTITY_ENTITY__TYPE_INFO);
    registry.register_type(CREATEENTITY_ENTITY_ENTITYBUS_OBJECTBLUEPRINT_LINEARTRANSFORM__TYPE_INFO);
    registry.register_type(CASTTOSPATIAL_SPATIALENTITY_ENTITY__TYPE_INFO);
    registry.register_type(GETTRANSFORM_SPATIALENTITY_LINEARTRANSFORM__TYPE_INFO);
    registry.register_type(SETTRANSFORM_SPATIALENTITY_LINEARTRANSFORM__TYPE_INFO);
    registry.register_type(UPDATEPASSMASK_TYPE_INFO);
    registry.register_type(UPDATEPASSMASK_ARRAY_TYPE_INFO);
    registry.register_type(UPDATEPASS_TYPE_INFO);
    registry.register_type(UPDATEPASS_ARRAY_TYPE_INFO);
    registry.register_type(GAMEDATACONTAINERASSET_TYPE_INFO);
    registry.register_type(GAMEDATACONTAINERASSET_ARRAY_TYPE_INFO);
    registry.register_type(DATACONTAINERASSET_TYPE_INFO);
    registry.register_type(DATACONTAINERASSET_ARRAY_TYPE_INFO);
    registry.register_type(STATICINSTANCINGDATA_TYPE_INFO);
    registry.register_type(STATICINSTANCINGDATA_ARRAY_TYPE_INFO);
    registry.register_type(PARTDATA_TYPE_INFO);
    registry.register_type(PARTDATA_ARRAY_TYPE_INFO);
    registry.register_type(PARTSTATE_TYPE_INFO);
    registry.register_type(PARTSTATE_ARRAY_TYPE_INFO);
    registry.register_type(BONECOMPONENTDATA_TYPE_INFO);
    registry.register_type(BONECOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(GAMECOMPONENTDATA_TYPE_INFO);
    registry.register_type(GAMECOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(COMPONENTDATA_TYPE_INFO);
    registry.register_type(COMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(GAMECOMPONENTENTITYDATA_TYPE_INFO);
    registry.register_type(GAMECOMPONENTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COMPONENTENTITYDATA_TYPE_INFO);
    registry.register_type(COMPONENTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SCRIPTENTITYDATA_TYPE_INFO);
    registry.register_type(SCRIPTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SPATIALENTITYDATA_TYPE_INFO);
    registry.register_type(SPATIALENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(ENTITYDATA_TYPE_INFO);
    registry.register_type(ENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(ENTITYCREATORTYPE_TYPE_INFO);
    registry.register_type(ENTITYCREATORTYPE_ARRAY_TYPE_INFO);
    registry.register_type(GAMEOBJECTDATA_TYPE_INFO);
    registry.register_type(GAMEOBJECTDATA_ARRAY_TYPE_INFO);
    registry.register_type(SUBREALM_TYPE_INFO);
    registry.register_type(SUBREALM_ARRAY_TYPE_INFO);
    registry.register_type(TIMESHAPE_TYPE_INFO);
    registry.register_type(TIMESHAPE_ARRAY_TYPE_INFO);
    registry.register_type(DILATIONPRIORITY_TYPE_INFO);
    registry.register_type(DILATIONPRIORITY_ARRAY_TYPE_INFO);
    registry.register_type(TIMEDELTATYPE_TYPE_INFO);
    registry.register_type(TIMEDELTATYPE_ARRAY_TYPE_INFO);
    registry.register_type(SCHEMATICCHANNELENTITYDATA_TYPE_INFO);
    registry.register_type(SCHEMATICCHANNELENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SCHEMATICCHANNELASSET_TYPE_INFO);
    registry.register_type(SCHEMATICCHANNELASSET_ARRAY_TYPE_INFO);
    registry.register_type(PROPERTYCHANNEL_TYPE_INFO);
    registry.register_type(PROPERTYCHANNEL_ARRAY_TYPE_INFO);
    registry.register_type(EVENTCHANNEL_TYPE_INFO);
    registry.register_type(EVENTCHANNEL_ARRAY_TYPE_INFO);
    registry.register_type(LINKCHANNEL_TYPE_INFO);
    registry.register_type(LINKCHANNEL_ARRAY_TYPE_INFO);
    registry.register_type(LOGICPREFABREFERENCEOBJECTDATA_TYPE_INFO);
    registry.register_type(LOGICPREFABREFERENCEOBJECTDATA_ARRAY_TYPE_INFO);
    registry.register_type(SPATIALPREFABREFERENCEOBJECTDATA_TYPE_INFO);
    registry.register_type(SPATIALPREFABREFERENCEOBJECTDATA_ARRAY_TYPE_INFO);
    registry.register_type(OBJECTREFERENCEOBJECTDATA_TYPE_INFO);
    registry.register_type(OBJECTREFERENCEOBJECTDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOGICREFERENCEOBJECTDATA_TYPE_INFO);
    registry.register_type(LOGICREFERENCEOBJECTDATA_ARRAY_TYPE_INFO);
    registry.register_type(SPATIALREFERENCEOBJECTDATA_TYPE_INFO);
    registry.register_type(SPATIALREFERENCEOBJECTDATA_ARRAY_TYPE_INFO);
    registry.register_type(REFERENCEOBJECTDATA_TYPE_INFO);
    registry.register_type(REFERENCEOBJECTDATA_ARRAY_TYPE_INFO);
    registry.register_type(STREAMREALM_TYPE_INFO);
    registry.register_type(STREAMREALM_ARRAY_TYPE_INFO);
    registry.register_type(OBJECTVARIATIONCOLLECTION_TYPE_INFO);
    registry.register_type(OBJECTVARIATIONCOLLECTION_ARRAY_TYPE_INFO);
    registry.register_type(OBJECTVARIATION_TYPE_INFO);
    registry.register_type(OBJECTVARIATION_ARRAY_TYPE_INFO);
    registry.register_type(DATACONTAINERCOLLECTIONBLUEPRINT_TYPE_INFO);
    registry.register_type(DATACONTAINERCOLLECTIONBLUEPRINT_ARRAY_TYPE_INFO);
    registry.register_type(LOGICPREFABBLUEPRINT_TYPE_INFO);
    registry.register_type(LOGICPREFABBLUEPRINT_ARRAY_TYPE_INFO);
    registry.register_type(SPATIALPREFABBLUEPRINT_TYPE_INFO);
    registry.register_type(SPATIALPREFABBLUEPRINT_ARRAY_TYPE_INFO);
    registry.register_type(PREFABBLUEPRINT_TYPE_INFO);
    registry.register_type(PREFABBLUEPRINT_ARRAY_TYPE_INFO);
    registry.register_type(OBJECTBLUEPRINT_TYPE_INFO);
    registry.register_type(OBJECTBLUEPRINT_ARRAY_TYPE_INFO);
    registry.register_type(BLUEPRINT_TYPE_INFO);
    registry.register_type(BLUEPRINT_ARRAY_TYPE_INFO);
    registry.register_type(BLUEPRINTPERSISTENCESETTING_TYPE_INFO);
    registry.register_type(BLUEPRINTPERSISTENCESETTING_ARRAY_TYPE_INFO);
    registry.register_type(ENTITYBUSDATA_TYPE_INFO);
    registry.register_type(ENTITYBUSDATA_ARRAY_TYPE_INFO);
    registry.register_type(INTERFACEDESCRIPTORDATA_TYPE_INFO);
    registry.register_type(INTERFACEDESCRIPTORDATA_ARRAY_TYPE_INFO);
    registry.register_type(DYNAMICLINK_TYPE_INFO);
    registry.register_type(DYNAMICLINK_ARRAY_TYPE_INFO);
    registry.register_type(DYNAMICEVENT_TYPE_INFO);
    registry.register_type(DYNAMICEVENT_ARRAY_TYPE_INFO);
    registry.register_type(EVENTCONNECTION_TYPE_INFO);
    registry.register_type(EVENTCONNECTION_ARRAY_TYPE_INFO);
    registry.register_type(EVENTCONNECTIONTARGETTYPE_TYPE_INFO);
    registry.register_type(EVENTCONNECTIONTARGETTYPE_ARRAY_TYPE_INFO);
    registry.register_type(EVENTSPEC_TYPE_INFO);
    registry.register_type(EVENTSPEC_ARRAY_TYPE_INFO);
    registry.register_type(COMPAREAXISALIGNEDBOXENTITYDATA_TYPE_INFO);
    registry.register_type(COMPAREAXISALIGNEDBOXENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COMPAREUINTRANGEENTITYDATA_TYPE_INFO);
    registry.register_type(COMPAREUINTRANGEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COMPAREINTRANGEENTITYDATA_TYPE_INFO);
    registry.register_type(COMPAREINTRANGEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COMPAREFLOATRANGEENTITYDATA_TYPE_INFO);
    registry.register_type(COMPAREFLOATRANGEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COMPARESTRINGENTITYDATA_TYPE_INFO);
    registry.register_type(COMPARESTRINGENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COMPAREVEC4ENTITYDATA_TYPE_INFO);
    registry.register_type(COMPAREVEC4ENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COMPAREVEC3ENTITYDATA_TYPE_INFO);
    registry.register_type(COMPAREVEC3ENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COMPAREFLOATENTITYDATA_TYPE_INFO);
    registry.register_type(COMPAREFLOATENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COMPAREUINTENTITYDATA_TYPE_INFO);
    registry.register_type(COMPAREUINTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COMPAREINTENTITYDATA_TYPE_INFO);
    registry.register_type(COMPAREINTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COMPAREBOOLENTITYDATA_TYPE_INFO);
    registry.register_type(COMPAREBOOLENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COMPAREENTITYBASEDATA_TYPE_INFO);
    registry.register_type(COMPAREENTITYBASEDATA_ARRAY_TYPE_INFO);
    registry.register_type(CLIENTPROFILERDATA_TYPE_INFO);
    registry.register_type(CLIENTPROFILERDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHILDEFFECTENTITYDATA_TYPE_INFO);
    registry.register_type(CHILDEFFECTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(BUNDLETYPE_TYPE_INFO);
    registry.register_type(BUNDLETYPE_ARRAY_TYPE_INFO);
    registry.register_type(AUTOASSETCOLLECTOR_TYPE_INFO);
    registry.register_type(AUTOASSETCOLLECTOR_ARRAY_TYPE_INFO);
    registry.register_type(NETWORKEDOBJECTSASSET_TYPE_INFO);
    registry.register_type(NETWORKEDOBJECTSASSET_ARRAY_TYPE_INFO);
    registry.register_type(NETWORKREGISTRYASSET_TYPE_INFO);
    registry.register_type(NETWORKREGISTRYASSET_ARRAY_TYPE_INFO);
    registry.register_type(BUNDLEHEAPINFO_TYPE_INFO);
    registry.register_type(BUNDLEHEAPINFO_ARRAY_TYPE_INFO);
    registry.register_type(BUNDLEHEAPTYPE_TYPE_INFO);
    registry.register_type(BUNDLEHEAPTYPE_ARRAY_TYPE_INFO);
    registry.register_type(BUNDLESETTINGSINFO_TYPE_INFO);
    registry.register_type(BUNDLESETTINGSINFO_ARRAY_TYPE_INFO);
    registry.register_type(MESHOPERATIONDATA_TYPE_INFO);
    registry.register_type(MESHOPERATIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(SKELETONBASEASSET_TYPE_INFO);
    registry.register_type(SKELETONBASEASSET_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMPARTPROPERTYTRACKDATA_TYPE_INFO);
    registry.register_type(TRANSFORMPARTPROPERTYTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMPARTPROPERTYKEY_TYPE_INFO);
    registry.register_type(TRANSFORMPARTPROPERTYKEY_ARRAY_TYPE_INFO);
    registry.register_type(ANIMTANGENTTYPE_TYPE_INFO);
    registry.register_type(ANIMTANGENTTYPE_ARRAY_TYPE_INFO);
    registry.register_type(CURVEINFINITYTYPE_TYPE_INFO);
    registry.register_type(CURVEINFINITYTYPE_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMPART_TYPE_INFO);
    registry.register_type(TRANSFORMPART_ARRAY_TYPE_INFO);
    registry.register_type(VEC4PROPERTYTRACKDATA_TYPE_INFO);
    registry.register_type(VEC4PROPERTYTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEC3PROPERTYTRACKDATA_TYPE_INFO);
    registry.register_type(VEC3PROPERTYTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEC2PROPERTYTRACKDATA_TYPE_INFO);
    registry.register_type(VEC2PROPERTYTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMPROPERTYTRACKDATA_TYPE_INFO);
    registry.register_type(TRANSFORMPROPERTYTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(INTPROPERTYTRACKDATA_TYPE_INFO);
    registry.register_type(INTPROPERTYTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(FLOATPROPERTYTRACKDATA_TYPE_INFO);
    registry.register_type(FLOATPROPERTYTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(BOOLPROPERTYTRACKDATA_TYPE_INFO);
    registry.register_type(BOOLPROPERTYTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(SIMPLEPROPERTYTRACKDATA_TYPE_INFO);
    registry.register_type(SIMPLEPROPERTYTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(SEQUENCEENTITYDATA_TYPE_INFO);
    registry.register_type(SEQUENCEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CUSTOMSEQUENCETRACKDATA_TYPE_INFO);
    registry.register_type(CUSTOMSEQUENCETRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(CUSTOMSEQUENCETRACKPROPERTYMAPPING_TYPE_INFO);
    registry.register_type(CUSTOMSEQUENCETRACKPROPERTYMAPPING_ARRAY_TYPE_INFO);
    registry.register_type(CUSTOMSEQUENCETRACKEVENTMAPPING_TYPE_INFO);
    registry.register_type(CUSTOMSEQUENCETRACKEVENTMAPPING_ARRAY_TYPE_INFO);
    registry.register_type(CUSTOMSEQUENCETRACKLINKMAPPING_TYPE_INFO);
    registry.register_type(CUSTOMSEQUENCETRACKLINKMAPPING_ARRAY_TYPE_INFO);
    registry.register_type(PROPERTYTRACKDATA_TYPE_INFO);
    registry.register_type(PROPERTYTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(INTERPOLATIONTYPE_TYPE_INFO);
    registry.register_type(INTERPOLATIONTYPE_ARRAY_TYPE_INFO);
    registry.register_type(SEQUENCEEVENTDATA_TYPE_INFO);
    registry.register_type(SEQUENCEEVENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(ENTITYCLASSINFOASSET_TYPE_INFO);
    registry.register_type(ENTITYCLASSINFOASSET_ARRAY_TYPE_INFO);
    registry.register_type(AUTOPAINTOUTPUTOVERRIDEBASE_TYPE_INFO);
    registry.register_type(AUTOPAINTOUTPUTOVERRIDEBASE_ARRAY_TYPE_INFO);
    registry.register_type(AUTOPAINTOUTPUTBASE_TYPE_INFO);
    registry.register_type(AUTOPAINTOUTPUTBASE_ARRAY_TYPE_INFO);
    registry.register_type(AUTOPAINTOUTPUTSBASE_TYPE_INFO);
    registry.register_type(AUTOPAINTOUTPUTSBASE_ARRAY_TYPE_INFO);
    registry.register_type(RASTERTYPE_TYPE_INFO);
    registry.register_type(RASTERTYPE_ARRAY_TYPE_INFO);
    registry.register_type(RASTERFORMAT_TYPE_INFO);
    registry.register_type(RASTERFORMAT_ARRAY_TYPE_INFO);
    registry.register_type(BASESHAPEDATABASE_TYPE_INFO);
    registry.register_type(BASESHAPEDATABASE_ARRAY_TYPE_INFO);
    registry.register_type(BASEMATERIALDATAPAIR_TYPE_INFO);
    registry.register_type(BASEMATERIALDATAPAIR_ARRAY_TYPE_INFO);
    registry.register_type(MATERIALGRIDDATA_TYPE_INFO);
    registry.register_type(MATERIALGRIDDATA_ARRAY_TYPE_INFO);
    registry.register_type(MATERIALINTERACTIONGRIDROW_TYPE_INFO);
    registry.register_type(MATERIALINTERACTIONGRIDROW_ARRAY_TYPE_INFO);
    registry.register_type(MATERIALRELATIONPROPERTYPAIR_TYPE_INFO);
    registry.register_type(MATERIALRELATIONPROPERTYPAIR_ARRAY_TYPE_INFO);
    registry.register_type(PHYSICSPROPERTYRELATIONPROPERTYDATA_TYPE_INFO);
    registry.register_type(PHYSICSPROPERTYRELATIONPROPERTYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PHYSICSMATERIALRELATIONPROPERTYDATA_TYPE_INFO);
    registry.register_type(PHYSICSMATERIALRELATIONPROPERTYDATA_ARRAY_TYPE_INFO);
    registry.register_type(MATERIALRELATIONPROPERTYDATA_TYPE_INFO);
    registry.register_type(MATERIALRELATIONPROPERTYDATA_ARRAY_TYPE_INFO);
    registry.register_type(MATERIALDECL_TYPE_INFO);
    registry.register_type(MATERIALDECL_ARRAY_TYPE_INFO);
    registry.register_type(STRINGBUILDERENTITYDATA_TYPE_INFO);
    registry.register_type(STRINGBUILDERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEC4CHANGEDENTITYDATA_TYPE_INFO);
    registry.register_type(VEC4CHANGEDENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEC3CHANGEDENTITYDATA_TYPE_INFO);
    registry.register_type(VEC3CHANGEDENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEC2CHANGEDENTITYDATA_TYPE_INFO);
    registry.register_type(VEC2CHANGEDENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(INTCHANGEDENTITYDATA_TYPE_INFO);
    registry.register_type(INTCHANGEDENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(FLOATCHANGEDENTITYDATA_TYPE_INFO);
    registry.register_type(FLOATCHANGEDENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(BOOLCHANGEDENTITYDATA_TYPE_INFO);
    registry.register_type(BOOLCHANGEDENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PROPERTYCHANGEDENTITYDATA_TYPE_INFO);
    registry.register_type(PROPERTYCHANGEDENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COMPARETRANSFORMENTITYDATA_TYPE_INFO);
    registry.register_type(COMPARETRANSFORMENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SWITCHENUMENTITYDATA_TYPE_INFO);
    registry.register_type(SWITCHENUMENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(EVENTNAME_TYPE_INFO);
    registry.register_type(EVENTNAME_ARRAY_TYPE_INFO);
    registry.register_type(SETENUMENTITYDATA_TYPE_INFO);
    registry.register_type(SETENUMENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SETENUMVALUECONTAINER_TYPE_INFO);
    registry.register_type(SETENUMVALUECONTAINER_ARRAY_TYPE_INFO);
    registry.register_type(INTTOENUMENTITYDATA_TYPE_INFO);
    registry.register_type(INTTOENUMENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(WRITEARRAYELEMENTENTITYDATA_TYPE_INFO);
    registry.register_type(WRITEARRAYELEMENTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(READARRAYSIZEENTITYDATA_TYPE_INFO);
    registry.register_type(READARRAYSIZEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(READARRAYELEMENTENTITYDATA_TYPE_INFO);
    registry.register_type(READARRAYELEMENTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(FOREACHVARIABLEENTITYDATA_TYPE_INFO);
    registry.register_type(FOREACHVARIABLEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CLEARARRAYVARIABLEENTITYDATA_TYPE_INFO);
    registry.register_type(CLEARARRAYVARIABLEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(ADDTOARRAYVARIABLEENTITYDATA_TYPE_INFO);
    registry.register_type(ADDTOARRAYVARIABLEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(WRITEVARIABLEENTITYDATA_TYPE_INFO);
    registry.register_type(WRITEVARIABLEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(READVARIABLEENTITYDATA_TYPE_INFO);
    registry.register_type(READVARIABLEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(WRITEVARIABLEBASEENTITYDATA_TYPE_INFO);
    registry.register_type(WRITEVARIABLEBASEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(READVARIABLEBASEENTITYDATA_TYPE_INFO);
    registry.register_type(READVARIABLEBASEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VARIABLEBASEENTITYDATA_TYPE_INFO);
    registry.register_type(VARIABLEBASEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(HIGHLIGHTENTITYDATA_TYPE_INFO);
    registry.register_type(HIGHLIGHTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TEXTSEQUENCEENTITYDATA_TYPE_INFO);
    registry.register_type(TEXTSEQUENCEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TEXTSEQUENCEITEM_TYPE_INFO);
    registry.register_type(TEXTSEQUENCEITEM_ARRAY_TYPE_INFO);
    registry.register_type(TREEBASE_TYPE_INFO);
    registry.register_type(TREEBASE_ARRAY_TYPE_INFO);
    registry.register_type(TREENODEBASE_TYPE_INFO);
    registry.register_type(TREENODEBASE_ARRAY_TYPE_INFO);
    registry.register_type(SUBLEVELDESTROYEDMESSAGE_TYPE_INFO);
    registry.register_type(SUBLEVELENTITIESCREATEDMESSAGE_TYPE_INFO);
    registry.register_type(REPORTINSTALLATIONPROGRESSENTITYDATA_TYPE_INFO);
    registry.register_type(REPORTINSTALLATIONPROGRESSENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOCALPLAYERIDENTITYDATA_TYPE_INFO);
    registry.register_type(LOCALPLAYERIDENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(FLOATCACHEENTITYDATA_TYPE_INFO);
    registry.register_type(FLOATCACHEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(MULTILINESTRINGENTITYDATA_TYPE_INFO);
    registry.register_type(MULTILINESTRINGENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(STRINGENTITYDATA_TYPE_INFO);
    registry.register_type(STRINGENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMENTITYDATA_TYPE_INFO);
    registry.register_type(TRANSFORMENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AXISALIGNEDBOXENTITYDATA_TYPE_INFO);
    registry.register_type(AXISALIGNEDBOXENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VECTOR4ENTITYDATA_TYPE_INFO);
    registry.register_type(VECTOR4ENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VECTOR3ENTITYDATA_TYPE_INFO);
    registry.register_type(VECTOR3ENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(FLOATENTITYDATA_TYPE_INFO);
    registry.register_type(FLOATENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(UINTENTITYDATA_TYPE_INFO);
    registry.register_type(UINTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(INTENTITYDATA_TYPE_INFO);
    registry.register_type(INTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(BOOLENTITYDATA_TYPE_INFO);
    registry.register_type(BOOLENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(MASTERSKELETONASSET_TYPE_INFO);
    registry.register_type(MASTERSKELETONASSET_ARRAY_TYPE_INFO);
    registry.register_type(SUBSKELETON_TYPE_INFO);
    registry.register_type(SUBSKELETON_ARRAY_TYPE_INFO);
    registry.register_type(SKELETONASSET_TYPE_INFO);
    registry.register_type(SKELETONASSET_ARRAY_TYPE_INFO);
    registry.register_type(BONESELECTION_TYPE_INFO);
    registry.register_type(BONESELECTION_ARRAY_TYPE_INFO);
    registry.register_type(GAMEPLAYBONE_TYPE_INFO);
    registry.register_type(GAMEPLAYBONE_ARRAY_TYPE_INFO);
    registry.register_type(GAMEPLAYBONES_TYPE_INFO);
    registry.register_type(GAMEPLAYBONES_ARRAY_TYPE_INFO);
    registry.register_type(SHAREDBUNDLEREFERENCE_TYPE_INFO);
    registry.register_type(SHAREDBUNDLEREFERENCE_ARRAY_TYPE_INFO);
    registry.register_type(SHAREDBUNDLEBASEASSET_TYPE_INFO);
    registry.register_type(SHAREDBUNDLEBASEASSET_ARRAY_TYPE_INFO);
    registry.register_type(SCANLINEVOLUMESHAPEDATA_TYPE_INFO);
    registry.register_type(SCANLINEVOLUMESHAPEDATA_ARRAY_TYPE_INFO);
    registry.register_type(ZONEVECTORSHAPEDATA_TYPE_INFO);
    registry.register_type(ZONEVECTORSHAPEDATA_ARRAY_TYPE_INFO);
    registry.register_type(VOLUMEVECTORSHAPEDATA_TYPE_INFO);
    registry.register_type(VOLUMEVECTORSHAPEDATA_ARRAY_TYPE_INFO);
    registry.register_type(CUSTOMSPLINEDATA_TYPE_INFO);
    registry.register_type(CUSTOMSPLINEDATA_ARRAY_TYPE_INFO);
    registry.register_type(VECTORSHAPEDATA_TYPE_INFO);
    registry.register_type(VECTORSHAPEDATA_ARRAY_TYPE_INFO);
    registry.register_type(OBBDATA_TYPE_INFO);
    registry.register_type(OBBDATA_ARRAY_TYPE_INFO);
    registry.register_type(AABBDATA_TYPE_INFO);
    registry.register_type(AABBDATA_ARRAY_TYPE_INFO);
    registry.register_type(SPHEREDATA_TYPE_INFO);
    registry.register_type(SPHEREDATA_ARRAY_TYPE_INFO);
    registry.register_type(BASESHAPEDATA_TYPE_INFO);
    registry.register_type(BASESHAPEDATA_ARRAY_TYPE_INFO);
    registry.register_type(SELECTVEC4ENTITYDATA_TYPE_INFO);
    registry.register_type(SELECTVEC4ENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SELECTVEC3ENTITYDATA_TYPE_INFO);
    registry.register_type(SELECTVEC3ENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SELECTVEC2ENTITYDATA_TYPE_INFO);
    registry.register_type(SELECTVEC2ENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SELECTTRANSFORMENTITYDATA_TYPE_INFO);
    registry.register_type(SELECTTRANSFORMENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SELECTBOOLENTITYDATA_TYPE_INFO);
    registry.register_type(SELECTBOOLENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SELECTSTRINGENTITYDATA_TYPE_INFO);
    registry.register_type(SELECTSTRINGENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SELECTINT64ENTITYDATA_TYPE_INFO);
    registry.register_type(SELECTINT64ENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SELECTINTENTITYDATA_TYPE_INFO);
    registry.register_type(SELECTINTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SELECTFLOATENTITYDATA_TYPE_INFO);
    registry.register_type(SELECTFLOATENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SELECTPROPERTYENTITYDATA_TYPE_INFO);
    registry.register_type(SELECTPROPERTYENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PATHFINDINGOBJECTCATEGORYASSET_TYPE_INFO);
    registry.register_type(PATHFINDINGOBJECTCATEGORYASSET_ARRAY_TYPE_INFO);
    registry.register_type(OBJECTAREATRIGGERENTITYDATA_TYPE_INFO);
    registry.register_type(OBJECTAREATRIGGERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(OBJECTVARIATIONTOINTENTITYDATA_TYPE_INFO);
    registry.register_type(OBJECTVARIATIONTOINTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMSPACEENTITYDATA_TYPE_INFO);
    registry.register_type(TRANSFORMSPACEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(BALANCEDDILATIONENTITYDATA_TYPE_INFO);
    registry.register_type(BALANCEDDILATIONENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(DILATIONENTITYDATA_TYPE_INFO);
    registry.register_type(DILATIONENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(FLOATSELECTENTITYDATA_TYPE_INFO);
    registry.register_type(FLOATSELECTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(FLOATCURVEENTITYDATA_TYPE_INFO);
    registry.register_type(FLOATCURVEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOCALPLAYERGATEENTITYDATA_TYPE_INFO);
    registry.register_type(LOCALPLAYERGATEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMSELECTORENTITYDATA_TYPE_INFO);
    registry.register_type(TRANSFORMSELECTORENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SETTINGENTITYDATA_TYPE_INFO);
    registry.register_type(SETTINGENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(INTEGRATORORDIFFERENTIATORENTITYDATA_TYPE_INFO);
    registry.register_type(INTEGRATORORDIFFERENTIATORENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PROFILEENTITYDATA_TYPE_INFO);
    registry.register_type(PROFILEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COMPAREENTITYDATA_TYPE_INFO);
    registry.register_type(COMPAREENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COMPAREOP_TYPE_INFO);
    registry.register_type(COMPAREOP_ARRAY_TYPE_INFO);
    registry.register_type(RUNNINGAVERAGEENTITYDATA_TYPE_INFO);
    registry.register_type(RUNNINGAVERAGEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(ABSENTITYDATA_TYPE_INFO);
    registry.register_type(ABSENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VECTORMATHOPENTITYDATA_TYPE_INFO);
    registry.register_type(VECTORMATHOPENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VECTORMATHOP_TYPE_INFO);
    registry.register_type(VECTORMATHOP_ARRAY_TYPE_INFO);
    registry.register_type(MATHOPENTITYDATA_TYPE_INFO);
    registry.register_type(MATHOPENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(MATHOP_TYPE_INFO);
    registry.register_type(MATHOP_ARRAY_TYPE_INFO);
    registry.register_type(PROPERTYCASTENTITYDATA_TYPE_INFO);
    registry.register_type(PROPERTYCASTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(BOOLTOEVENTENTITYDATA_TYPE_INFO);
    registry.register_type(BOOLTOEVENTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SWITCHPROPERTYSTRINGENTITYDATA_TYPE_INFO);
    registry.register_type(SWITCHPROPERTYSTRINGENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PROPERTYGATEENTITYDATA_TYPE_INFO);
    registry.register_type(PROPERTYGATEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(EVENTGATEENTITYDATA_TYPE_INFO);
    registry.register_type(EVENTGATEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(STOPWATCHENTITYDATA_TYPE_INFO);
    registry.register_type(STOPWATCHENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMTOROTATIONENTITYDATA_TYPE_INFO);
    registry.register_type(TRANSFORMTOROTATIONENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMMODIFIERENTITYDATA_TYPE_INFO);
    registry.register_type(TRANSFORMMODIFIERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(MODIFIERAXIS_TYPE_INFO);
    registry.register_type(MODIFIERAXIS_ARRAY_TYPE_INFO);
    registry.register_type(ROTATIONTRANSFORMBUILDERENTITYDATA_TYPE_INFO);
    registry.register_type(ROTATIONTRANSFORMBUILDERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SCALETRANSFORMBUILDERENTITYDATA_TYPE_INFO);
    registry.register_type(SCALETRANSFORMBUILDERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMBUILDERENTITYDATA_TYPE_INFO);
    registry.register_type(TRANSFORMBUILDERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(ORTHONORMALMODE_TYPE_INFO);
    registry.register_type(ORTHONORMALMODE_ARRAY_TYPE_INFO);
    registry.register_type(VECBUILDERENTITYDATA_TYPE_INFO);
    registry.register_type(VECBUILDERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEC4BUILDERENTITYDATA_TYPE_INFO);
    registry.register_type(VEC4BUILDERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEC3BUILDERENTITYDATA_TYPE_INFO);
    registry.register_type(VEC3BUILDERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEC2BUILDERENTITYDATA_TYPE_INFO);
    registry.register_type(VEC2BUILDERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VECSPLITTERENTITYDATA_TYPE_INFO);
    registry.register_type(VECSPLITTERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEC4SPLITTERENTITYDATA_TYPE_INFO);
    registry.register_type(VEC4SPLITTERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEC3SPLITTERENTITYDATA_TYPE_INFO);
    registry.register_type(VEC3SPLITTERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEC2SPLITTERENTITYDATA_TYPE_INFO);
    registry.register_type(VEC2SPLITTERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(EULERTRANSFORMENTITYDATA_TYPE_INFO);
    registry.register_type(EULERTRANSFORMENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(MODIFIEREULER_TYPE_INFO);
    registry.register_type(MODIFIEREULER_ARRAY_TYPE_INFO);
    registry.register_type(EULERTRANSFORMSPLITTERENTITYDATA_TYPE_INFO);
    registry.register_type(EULERTRANSFORMSPLITTERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMSPLITTERENTITYDATA_TYPE_INFO);
    registry.register_type(TRANSFORMSPLITTERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMBLENDENTITYDATA_TYPE_INFO);
    registry.register_type(TRANSFORMBLENDENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMMULTIPLIERENTITYDATA_TYPE_INFO);
    registry.register_type(TRANSFORMMULTIPLIERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMHUBENTITYDATA_TYPE_INFO);
    registry.register_type(TRANSFORMHUBENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(STRINGHUBENTITYDATA_TYPE_INFO);
    registry.register_type(STRINGHUBENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEC4HUBENTITYDATA_TYPE_INFO);
    registry.register_type(VEC4HUBENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEC3HUBENTITYDATA_TYPE_INFO);
    registry.register_type(VEC3HUBENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEC2HUBENTITYDATA_TYPE_INFO);
    registry.register_type(VEC2HUBENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(FLOATHUBENTITYDATA_TYPE_INFO);
    registry.register_type(FLOATHUBENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(INT64HUBENTITYDATA_TYPE_INFO);
    registry.register_type(INT64HUBENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(INTHUBENTITYDATA_TYPE_INFO);
    registry.register_type(INTHUBENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(BOOLHUBENTITYDATA_TYPE_INFO);
    registry.register_type(BOOLHUBENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SIMPLEDOFPARAMCONVERTERENTITYDATA_TYPE_INFO);
    registry.register_type(SIMPLEDOFPARAMCONVERTERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SPRITEDOFPARAMCONVERTERENTITYDATA_TYPE_INFO);
    registry.register_type(SPRITEDOFPARAMCONVERTERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(OBJECTVARIATIONMULTISWITCHENTITYDATA_TYPE_INFO);
    registry.register_type(OBJECTVARIATIONMULTISWITCHENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(OBJECTVARIATIONSWITCHENTITYDATA_TYPE_INFO);
    registry.register_type(OBJECTVARIATIONSWITCHENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(RANDOMDELAYENTITYDATA_TYPE_INFO);
    registry.register_type(RANDOMDELAYENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(DELAYENTITYDATA_TYPE_INFO);
    registry.register_type(DELAYENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(EVENTORDERGATEENTITYDATA_TYPE_INFO);
    registry.register_type(EVENTORDERGATEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(EVENTANDGATEENTITYDATA_TYPE_INFO);
    registry.register_type(EVENTANDGATEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SELECTEVENTENTITYDATA_TYPE_INFO);
    registry.register_type(SELECTEVENTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(EVENTSWITCHENTITYDATA_TYPE_INFO);
    registry.register_type(EVENTSWITCHENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(UNIQUEIDENTITYDATA_TYPE_INFO);
    registry.register_type(UNIQUEIDENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(RANDOMINTENTITYDATA_TYPE_INFO);
    registry.register_type(RANDOMINTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(RANDOMFLOATENTITYDATA_TYPE_INFO);
    registry.register_type(RANDOMFLOATENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(RANDOMMULTIEVENTENTITYDATA_TYPE_INFO);
    registry.register_type(RANDOMMULTIEVENTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(RANDOMEVENTENTITYDATA_TYPE_INFO);
    registry.register_type(RANDOMEVENTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOCATORENTITYDATA_TYPE_INFO);
    registry.register_type(LOCATORENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COUNTDOWNENTITYDATA_TYPE_INFO);
    registry.register_type(COUNTDOWNENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(MATHENTITYDATA_TYPE_INFO);
    registry.register_type(MATHENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(MATHENTITYASSEMBLY_TYPE_INFO);
    registry.register_type(MATHENTITYASSEMBLY_ARRAY_TYPE_INFO);
    registry.register_type(MATHENTITYTYPE_TYPE_INFO);
    registry.register_type(MATHENTITYTYPE_ARRAY_TYPE_INFO);
    registry.register_type(MATHENTITYFUNCTIONCALL_TYPE_INFO);
    registry.register_type(MATHENTITYFUNCTIONCALL_ARRAY_TYPE_INFO);
    registry.register_type(MATHENTITYINSTRUCTION_TYPE_INFO);
    registry.register_type(MATHENTITYINSTRUCTION_ARRAY_TYPE_INFO);
    registry.register_type(MATHOPCODE_TYPE_INFO);
    registry.register_type(MATHOPCODE_ARRAY_TYPE_INFO);
    registry.register_type(OR4ENTITYDATA_TYPE_INFO);
    registry.register_type(OR4ENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(XORENTITYDATA_TYPE_INFO);
    registry.register_type(XORENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(ORENTITYDATA_TYPE_INFO);
    registry.register_type(ORENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(BITWISEANDENTITYDATA_TYPE_INFO);
    registry.register_type(BITWISEANDENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANDENTITYDATA_TYPE_INFO);
    registry.register_type(ANDENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(NOTENTITYDATA_TYPE_INFO);
    registry.register_type(NOTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CREATESCHEMATICSINSTANCEENTITYDATA_TYPE_INFO);
    registry.register_type(CREATESCHEMATICSINSTANCEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(GETENTITYBUSENTITYDATA_TYPE_INFO);
    registry.register_type(GETENTITYBUSENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(GETENTITYENTITYDATA_TYPE_INFO);
    registry.register_type(GETENTITYENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CALLFUNCTIONENTITYDATA_TYPE_INFO);
    registry.register_type(CALLFUNCTIONENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(ENTITYOWNERUID_TYPE_INFO);
    registry.register_type(ENTITYOWNERUID_ARRAY_TYPE_INFO);
    registry.register_type(ENTITYUID_TYPE_INFO);
    registry.register_type(ENTITYUID_ARRAY_TYPE_INFO);
    registry.register_type(SETTRANSFORMSPACELOCALTRANSFORM_ENTITYTRANSFORMSPACE_LINEARTRANSFORM__TYPE_INFO);
    registry.register_type(GETTRANSFORMSPACE_ENTITYTRANSFORMSPACE_ENTITY__TYPE_INFO);
    registry.register_type(TRANSFORMSPACECHILDCONTROLSETTING_TYPE_INFO);
    registry.register_type(TRANSFORMSPACECHILDCONTROLSETTING_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMSPACESIMULATIONSETTING_TYPE_INFO);
    registry.register_type(TRANSFORMSPACESIMULATIONSETTING_ARRAY_TYPE_INFO);
    registry.register_type(ENTITYSETTINGS_TYPE_INFO);
    registry.register_type(ENTITYSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(EXECUTIONMODETYPE_TYPE_INFO);
    registry.register_type(EXECUTIONMODETYPE_ARRAY_TYPE_INFO);
    registry.register_type(SWITCHENUMENTITY_TYPE_INFO);
    registry.register_type(SWITCHENUMENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SETENUMENTITY_TYPE_INFO);
    registry.register_type(SETENUMENTITY_ARRAY_TYPE_INFO);
    registry.register_type(INTTOENUMENTITY_TYPE_INFO);
    registry.register_type(INTTOENUMENTITY_ARRAY_TYPE_INFO);
    registry.register_type(ENUMTOSTRINGENTITY_TYPE_INFO);
    registry.register_type(ENUMTOSTRINGENTITY_ARRAY_TYPE_INFO);
    registry.register_type(ENUMTOINTENTITY_TYPE_INFO);
    registry.register_type(ENUMTOINTENTITY_ARRAY_TYPE_INFO);
    registry.register_type(ENUMPROPERTYGATEENTITY_TYPE_INFO);
    registry.register_type(ENUMPROPERTYGATEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(ENUMLOGICENTITYWITHSINGLEINPUT_TYPE_INFO);
    registry.register_type(ENUMLOGICENTITYWITHSINGLEINPUT_ARRAY_TYPE_INFO);
    registry.register_type(ENUMINTSOURCEENTITY_TYPE_INFO);
    registry.register_type(ENUMINTSOURCEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(COMPAREENUMENTITY_TYPE_INFO);
    registry.register_type(COMPAREENUMENTITY_ARRAY_TYPE_INFO);
    registry.register_type(ENTITYBUSPEER_TYPE_INFO);
    registry.register_type(ENTITYBUSPEER_ARRAY_TYPE_INFO);
    registry.register_type(ENTITYEVENT_TYPE_INFO);
    registry.register_type(ENTITYEVENT_ARRAY_TYPE_INFO);
    registry.register_type(ENTITYBUS_TYPE_INFO);
    registry.register_type(ENTITYBUS_ARRAY_TYPE_INFO);
    registry.register_type(DATASOURCEQUERYENTITY_TYPE_INFO);
    registry.register_type(DATASOURCEQUERYENTITY_ARRAY_TYPE_INFO);
    registry.register_type(ENUMTOSTRINGDATA_TYPE_INFO);
    registry.register_type(ENUMTOSTRINGDATA_ARRAY_TYPE_INFO);
    registry.register_type(ENUMTOINTDATA_TYPE_INFO);
    registry.register_type(ENUMTOINTDATA_ARRAY_TYPE_INFO);
    registry.register_type(ENUMPROPERTYGATEENTITYDATA_TYPE_INFO);
    registry.register_type(ENUMPROPERTYGATEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(ENUMDEBUGENTITYDATA_TYPE_INFO);
    registry.register_type(ENUMDEBUGENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(IMPLIEDENUMTYPELOGICENTITYDATA_TYPE_INFO);
    registry.register_type(IMPLIEDENUMTYPELOGICENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(EXPLICITENUMTYPELOGICENTITYDATA_TYPE_INFO);
    registry.register_type(EXPLICITENUMTYPELOGICENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(ENUMLOGICENTITYBASEDATA_TYPE_INFO);
    registry.register_type(ENUMLOGICENTITYBASEDATA_ARRAY_TYPE_INFO);
    registry.register_type(ENUMINTSOURCEENTITYDATA_TYPE_INFO);
    registry.register_type(ENUMINTSOURCEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(ENUMINTSOURCEPROPERTY_TYPE_INFO);
    registry.register_type(ENUMINTSOURCEPROPERTY_ARRAY_TYPE_INFO);
    registry.register_type(COMPAREENUMENTITYDATA_TYPE_INFO);
    registry.register_type(COMPAREENUMENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(DATASOURCEQUERYENTITYDATA_TYPE_INFO);
    registry.register_type(DATASOURCEQUERYENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(DATASOURCEQUERYFIELDDEFINITION_TYPE_INFO);
    registry.register_type(DATASOURCEQUERYFIELDDEFINITION_ARRAY_TYPE_INFO);
    registry.register_type(PROPERTYWRAPPER_TYPE_INFO);
    registry.register_type(PROPERTYWRAPPER_ARRAY_TYPE_INFO);
    registry.register_type(BUNDLEMANAGERBUNDLEUNLOADMESSAGE_TYPE_INFO);
    registry.register_type(WRITEARRAYELEMENTENTITY_TYPE_INFO);
    registry.register_type(WRITEARRAYELEMENTENTITY_ARRAY_TYPE_INFO);
    registry.register_type(READARRAYSIZEENTITY_TYPE_INFO);
    registry.register_type(READARRAYSIZEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(READARRAYELEMENTENTITY_TYPE_INFO);
    registry.register_type(READARRAYELEMENTENTITY_ARRAY_TYPE_INFO);
    registry.register_type(FOREACHVARIABLEENTITY_TYPE_INFO);
    registry.register_type(FOREACHVARIABLEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(CLEARARRAYVARIABLEENTITY_TYPE_INFO);
    registry.register_type(CLEARARRAYVARIABLEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(ADDTOARRAYVARIABLEENTITY_TYPE_INFO);
    registry.register_type(ADDTOARRAYVARIABLEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(WRITEVARIABLEENTITY_TYPE_INFO);
    registry.register_type(WRITEVARIABLEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(READVARIABLEENTITY_TYPE_INFO);
    registry.register_type(READVARIABLEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(HIGHLIGHTENTITY_TYPE_INFO);
    registry.register_type(HIGHLIGHTENTITY_ARRAY_TYPE_INFO);
    registry.register_type(TEXTSEQUENCEENTITY_TYPE_INFO);
    registry.register_type(TEXTSEQUENCEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SUBLEVELENTITY_TYPE_INFO);
    registry.register_type(SUBLEVELENTITY_ARRAY_TYPE_INFO);
    registry.register_type(REPORTINSTALLATIONPROGRESSENTITY_TYPE_INFO);
    registry.register_type(REPORTINSTALLATIONPROGRESSENTITY_ARRAY_TYPE_INFO);
    registry.register_type(LOCALPLAYERIDENTITY_TYPE_INFO);
    registry.register_type(LOCALPLAYERIDENTITY_ARRAY_TYPE_INFO);
    registry.register_type(FLOATCACHEENTITY_TYPE_INFO);
    registry.register_type(FLOATCACHEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(MULTILINESTRINGENTITY_TYPE_INFO);
    registry.register_type(MULTILINESTRINGENTITY_ARRAY_TYPE_INFO);
    registry.register_type(STRINGENTITY_TYPE_INFO);
    registry.register_type(STRINGENTITY_ARRAY_TYPE_INFO);
    registry.register_type(AXISALIGNEDBOXENTITY_TYPE_INFO);
    registry.register_type(AXISALIGNEDBOXENTITY_ARRAY_TYPE_INFO);
    registry.register_type(VECTOR4ENTITY_TYPE_INFO);
    registry.register_type(VECTOR4ENTITY_ARRAY_TYPE_INFO);
    registry.register_type(VECTOR3ENTITY_TYPE_INFO);
    registry.register_type(VECTOR3ENTITY_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMENTITY_TYPE_INFO);
    registry.register_type(TRANSFORMENTITY_ARRAY_TYPE_INFO);
    registry.register_type(FLOATENTITY_TYPE_INFO);
    registry.register_type(FLOATENTITY_ARRAY_TYPE_INFO);
    registry.register_type(UINTENTITY_TYPE_INFO);
    registry.register_type(UINTENTITY_ARRAY_TYPE_INFO);
    registry.register_type(INTENTITY_TYPE_INFO);
    registry.register_type(INTENTITY_ARRAY_TYPE_INFO);
    registry.register_type(BOOLENTITY_TYPE_INFO);
    registry.register_type(BOOLENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SPATIALENTITY_TYPE_INFO);
    registry.register_type(SPATIALENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SELECTVEC4ENTITY_TYPE_INFO);
    registry.register_type(SELECTVEC4ENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SELECTVEC3ENTITY_TYPE_INFO);
    registry.register_type(SELECTVEC3ENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SELECTVEC2ENTITY_TYPE_INFO);
    registry.register_type(SELECTVEC2ENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SELECTTRANSFORMENTITY_TYPE_INFO);
    registry.register_type(SELECTTRANSFORMENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SELECTBOOLENTITY_TYPE_INFO);
    registry.register_type(SELECTBOOLENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SELECTSTRINGENTITY_TYPE_INFO);
    registry.register_type(SELECTSTRINGENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SELECTINT64ENTITY_TYPE_INFO);
    registry.register_type(SELECTINT64ENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SELECTINTENTITY_TYPE_INFO);
    registry.register_type(SELECTINTENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SELECTFLOATENTITY_TYPE_INFO);
    registry.register_type(SELECTFLOATENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SCRIPTENTITY_TYPE_INFO);
    registry.register_type(SCRIPTENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SCHEMATICCHANNELENTITY_TYPE_INFO);
    registry.register_type(SCHEMATICCHANNELENTITY_ARRAY_TYPE_INFO);
    registry.register_type(PART_TYPE_INFO);
    registry.register_type(PART_ARRAY_TYPE_INFO);
    registry.register_type(OBJECTAREATRIGGERENTITY_TYPE_INFO);
    registry.register_type(OBJECTAREATRIGGERENTITY_ARRAY_TYPE_INFO);
    registry.register_type(OBJECTVARIATIONTOINTENTITY_TYPE_INFO);
    registry.register_type(OBJECTVARIATIONTOINTENTITY_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMSPACEENTITY_TYPE_INFO);
    registry.register_type(TRANSFORMSPACEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(FLOATSELECTENTITY_TYPE_INFO);
    registry.register_type(FLOATSELECTENTITY_ARRAY_TYPE_INFO);
    registry.register_type(FLOATCURVEENTITY_TYPE_INFO);
    registry.register_type(FLOATCURVEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SETTINGENTITY_TYPE_INFO);
    registry.register_type(SETTINGENTITY_ARRAY_TYPE_INFO);
    registry.register_type(INTEGRATORORDIFFERENTIATORENTITY_TYPE_INFO);
    registry.register_type(INTEGRATORORDIFFERENTIATORENTITY_ARRAY_TYPE_INFO);
    registry.register_type(PROFILEENTITY_TYPE_INFO);
    registry.register_type(PROFILEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(COMPAREENTITY_TYPE_INFO);
    registry.register_type(COMPAREENTITY_ARRAY_TYPE_INFO);
    registry.register_type(RUNNINGAVERAGEENTITY_TYPE_INFO);
    registry.register_type(RUNNINGAVERAGEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(ABSENTITY_TYPE_INFO);
    registry.register_type(ABSENTITY_ARRAY_TYPE_INFO);
    registry.register_type(VECTORMATHOPENTITY_TYPE_INFO);
    registry.register_type(VECTORMATHOPENTITY_ARRAY_TYPE_INFO);
    registry.register_type(MATHOPENTITY_TYPE_INFO);
    registry.register_type(MATHOPENTITY_ARRAY_TYPE_INFO);
    registry.register_type(PROPERTYCASTENTITY_TYPE_INFO);
    registry.register_type(PROPERTYCASTENTITY_ARRAY_TYPE_INFO);
    registry.register_type(BOOLTOEVENTENTITY_TYPE_INFO);
    registry.register_type(BOOLTOEVENTENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SWITCHPROPERTYSTRINGENTITY_TYPE_INFO);
    registry.register_type(SWITCHPROPERTYSTRINGENTITY_ARRAY_TYPE_INFO);
    registry.register_type(PROPERTYGATEENTITY_TYPE_INFO);
    registry.register_type(PROPERTYGATEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(EVENTGATEENTITY_TYPE_INFO);
    registry.register_type(EVENTGATEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(STOPWATCHENTITY_TYPE_INFO);
    registry.register_type(STOPWATCHENTITY_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMTOROTATIONENTITY_TYPE_INFO);
    registry.register_type(TRANSFORMTOROTATIONENTITY_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMMODIFIERENTITY_TYPE_INFO);
    registry.register_type(TRANSFORMMODIFIERENTITY_ARRAY_TYPE_INFO);
    registry.register_type(ROTATIONTRANSFORMBUILDERENTITY_TYPE_INFO);
    registry.register_type(ROTATIONTRANSFORMBUILDERENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SCALETRANSFORMBUILDERENTITY_TYPE_INFO);
    registry.register_type(SCALETRANSFORMBUILDERENTITY_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMBUILDERENTITY_TYPE_INFO);
    registry.register_type(TRANSFORMBUILDERENTITY_ARRAY_TYPE_INFO);
    registry.register_type(VECBUILDERENTITY_TYPE_INFO);
    registry.register_type(VECBUILDERENTITY_ARRAY_TYPE_INFO);
    registry.register_type(VEC4BUILDERENTITY_TYPE_INFO);
    registry.register_type(VEC4BUILDERENTITY_ARRAY_TYPE_INFO);
    registry.register_type(VEC3BUILDERENTITY_TYPE_INFO);
    registry.register_type(VEC3BUILDERENTITY_ARRAY_TYPE_INFO);
    registry.register_type(VEC2BUILDERENTITY_TYPE_INFO);
    registry.register_type(VEC2BUILDERENTITY_ARRAY_TYPE_INFO);
    registry.register_type(VECSPLITTERENTITY_TYPE_INFO);
    registry.register_type(VECSPLITTERENTITY_ARRAY_TYPE_INFO);
    registry.register_type(VEC4SPLITTERENTITY_TYPE_INFO);
    registry.register_type(VEC4SPLITTERENTITY_ARRAY_TYPE_INFO);
    registry.register_type(VEC3SPLITTERENTITY_TYPE_INFO);
    registry.register_type(VEC3SPLITTERENTITY_ARRAY_TYPE_INFO);
    registry.register_type(VEC2SPLITTERENTITY_TYPE_INFO);
    registry.register_type(VEC2SPLITTERENTITY_ARRAY_TYPE_INFO);
    registry.register_type(EULERTRANSFORMENTITY_TYPE_INFO);
    registry.register_type(EULERTRANSFORMENTITY_ARRAY_TYPE_INFO);
    registry.register_type(EULERTRANSFORMSPLITTERENTITY_TYPE_INFO);
    registry.register_type(EULERTRANSFORMSPLITTERENTITY_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMSPLITTERENTITY_TYPE_INFO);
    registry.register_type(TRANSFORMSPLITTERENTITY_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMSELECTORENTITY_TYPE_INFO);
    registry.register_type(TRANSFORMSELECTORENTITY_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMBLENDENTITY_TYPE_INFO);
    registry.register_type(TRANSFORMBLENDENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SIMPLEDOFPARAMCONVERTERENTITY_TYPE_INFO);
    registry.register_type(SIMPLEDOFPARAMCONVERTERENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SPRITEDOFPARAMCONVERTERENTITY_TYPE_INFO);
    registry.register_type(SPRITEDOFPARAMCONVERTERENTITY_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMMULTIPLIERENTITY_TYPE_INFO);
    registry.register_type(TRANSFORMMULTIPLIERENTITY_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMHUBENTITY_TYPE_INFO);
    registry.register_type(TRANSFORMHUBENTITY_ARRAY_TYPE_INFO);
    registry.register_type(STRINGHUBENTITY_TYPE_INFO);
    registry.register_type(STRINGHUBENTITY_ARRAY_TYPE_INFO);
    registry.register_type(VEC4HUBENTITY_TYPE_INFO);
    registry.register_type(VEC4HUBENTITY_ARRAY_TYPE_INFO);
    registry.register_type(VEC3HUBENTITY_TYPE_INFO);
    registry.register_type(VEC3HUBENTITY_ARRAY_TYPE_INFO);
    registry.register_type(VEC2HUBENTITY_TYPE_INFO);
    registry.register_type(VEC2HUBENTITY_ARRAY_TYPE_INFO);
    registry.register_type(FLOATHUBENTITY_TYPE_INFO);
    registry.register_type(FLOATHUBENTITY_ARRAY_TYPE_INFO);
    registry.register_type(INT64HUBENTITY_TYPE_INFO);
    registry.register_type(INT64HUBENTITY_ARRAY_TYPE_INFO);
    registry.register_type(INTHUBENTITY_TYPE_INFO);
    registry.register_type(INTHUBENTITY_ARRAY_TYPE_INFO);
    registry.register_type(BOOLHUBENTITY_TYPE_INFO);
    registry.register_type(BOOLHUBENTITY_ARRAY_TYPE_INFO);
    registry.register_type(OBJECTVARIATIONSWITCHENTITY_TYPE_INFO);
    registry.register_type(OBJECTVARIATIONSWITCHENTITY_ARRAY_TYPE_INFO);
    registry.register_type(OBJECTVARIATIONMULTISWITCHENTITY_TYPE_INFO);
    registry.register_type(OBJECTVARIATIONMULTISWITCHENTITY_ARRAY_TYPE_INFO);
    registry.register_type(RANDOMDELAYENTITY_TYPE_INFO);
    registry.register_type(RANDOMDELAYENTITY_ARRAY_TYPE_INFO);
    registry.register_type(DELAYENTITY_TYPE_INFO);
    registry.register_type(DELAYENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SELECTEVENTENTITY_TYPE_INFO);
    registry.register_type(SELECTEVENTENTITY_ARRAY_TYPE_INFO);
    registry.register_type(EVENTORDERGATEENTITY_TYPE_INFO);
    registry.register_type(EVENTORDERGATEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(EVENTANDGATEENTITY_TYPE_INFO);
    registry.register_type(EVENTANDGATEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(EVENTSWITCHENTITY_TYPE_INFO);
    registry.register_type(EVENTSWITCHENTITY_ARRAY_TYPE_INFO);
    registry.register_type(UNIQUEIDENTITY_TYPE_INFO);
    registry.register_type(UNIQUEIDENTITY_ARRAY_TYPE_INFO);
    registry.register_type(RANDOMINTENTITY_TYPE_INFO);
    registry.register_type(RANDOMINTENTITY_ARRAY_TYPE_INFO);
    registry.register_type(RANDOMFLOATENTITY_TYPE_INFO);
    registry.register_type(RANDOMFLOATENTITY_ARRAY_TYPE_INFO);
    registry.register_type(RANDOMMULTIEVENTENTITY_TYPE_INFO);
    registry.register_type(RANDOMMULTIEVENTENTITY_ARRAY_TYPE_INFO);
    registry.register_type(RANDOMEVENTENTITY_TYPE_INFO);
    registry.register_type(RANDOMEVENTENTITY_ARRAY_TYPE_INFO);
    registry.register_type(LOCATORENTITY_TYPE_INFO);
    registry.register_type(LOCATORENTITY_ARRAY_TYPE_INFO);
    registry.register_type(COUNTDOWNENTITY_TYPE_INFO);
    registry.register_type(COUNTDOWNENTITY_ARRAY_TYPE_INFO);
    registry.register_type(MATHENTITY_TYPE_INFO);
    registry.register_type(MATHENTITY_ARRAY_TYPE_INFO);
    registry.register_type(OR4ENTITY_TYPE_INFO);
    registry.register_type(OR4ENTITY_ARRAY_TYPE_INFO);
    registry.register_type(XORENTITY_TYPE_INFO);
    registry.register_type(XORENTITY_ARRAY_TYPE_INFO);
    registry.register_type(ORENTITY_TYPE_INFO);
    registry.register_type(ORENTITY_ARRAY_TYPE_INFO);
    registry.register_type(BITWISEANDENTITY_TYPE_INFO);
    registry.register_type(BITWISEANDENTITY_ARRAY_TYPE_INFO);
    registry.register_type(ANDENTITY_TYPE_INFO);
    registry.register_type(ANDENTITY_ARRAY_TYPE_INFO);
    registry.register_type(NOTENTITY_TYPE_INFO);
    registry.register_type(NOTENTITY_ARRAY_TYPE_INFO);
}

#[derive(Clone, Debug, Default)]
pub struct WorldPartInclusion {
    pub _glacier_base: SubWorldInclusion,
}

pub trait WorldPartInclusionTrait: SubWorldInclusionTrait {
}

impl WorldPartInclusionTrait for WorldPartInclusion {
}

impl SubWorldInclusionTrait for WorldPartInclusion {
    fn criteria(&self) -> &Vec<Option<Arc<Mutex<dyn SubWorldInclusionCriterionTrait>>>> {
        self._glacier_base.criteria()
    }
}

impl super::core::AssetTrait for WorldPartInclusion {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for WorldPartInclusion {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static WORLDPARTINCLUSION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WorldPartInclusion",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SUBWORLDINCLUSION_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WorldPartInclusion as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(WORLDPARTINCLUSION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WorldPartInclusion {
    fn type_info(&self) -> &'static TypeInfo {
        WORLDPARTINCLUSION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static WORLDPARTINCLUSION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WorldPartInclusion-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("WorldPartInclusion"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WorldPartInclusionCriterion {
    pub _glacier_base: SubWorldInclusionCriterion,
}

pub trait WorldPartInclusionCriterionTrait: SubWorldInclusionCriterionTrait {
}

impl WorldPartInclusionCriterionTrait for WorldPartInclusionCriterion {
}

impl SubWorldInclusionCriterionTrait for WorldPartInclusionCriterion {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn options(&self) -> &Vec<String> {
        self._glacier_base.options()
    }
}

impl super::core::DataContainerTrait for WorldPartInclusionCriterion {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static WORLDPARTINCLUSIONCRITERION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WorldPartInclusionCriterion",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SUBWORLDINCLUSIONCRITERION_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WorldPartInclusionCriterion as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(WORLDPARTINCLUSIONCRITERION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WorldPartInclusionCriterion {
    fn type_info(&self) -> &'static TypeInfo {
        WORLDPARTINCLUSIONCRITERION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static WORLDPARTINCLUSIONCRITERION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WorldPartInclusionCriterion-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("WorldPartInclusionCriterion"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WorldPartInclusionSetting {
    pub _glacier_base: SubWorldInclusionSetting,
}

pub trait WorldPartInclusionSettingTrait: SubWorldInclusionSettingTrait {
}

impl WorldPartInclusionSettingTrait for WorldPartInclusionSetting {
}

impl SubWorldInclusionSettingTrait for WorldPartInclusionSetting {
    fn criterion(&self) -> &Option<Arc<Mutex<dyn SubWorldInclusionCriterionTrait>>> {
        self._glacier_base.criterion()
    }
    fn enabled_options(&self) -> &Vec<String> {
        self._glacier_base.enabled_options()
    }
}

impl super::core::DataContainerTrait for WorldPartInclusionSetting {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static WORLDPARTINCLUSIONSETTING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WorldPartInclusionSetting",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SUBWORLDINCLUSIONSETTING_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WorldPartInclusionSetting as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(WORLDPARTINCLUSIONSETTING_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WorldPartInclusionSetting {
    fn type_info(&self) -> &'static TypeInfo {
        WORLDPARTINCLUSIONSETTING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static WORLDPARTINCLUSIONSETTING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WorldPartInclusionSetting-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("WorldPartInclusionSetting"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WorldPartInclusionSettings {
    pub _glacier_base: SubWorldInclusionSettings,
}

pub trait WorldPartInclusionSettingsTrait: SubWorldInclusionSettingsTrait {
}

impl WorldPartInclusionSettingsTrait for WorldPartInclusionSettings {
}

impl SubWorldInclusionSettingsTrait for WorldPartInclusionSettings {
    fn settings(&self) -> &Vec<Option<Arc<Mutex<dyn SubWorldInclusionSettingTrait>>>> {
        self._glacier_base.settings()
    }
}

impl super::core::DataContainerTrait for WorldPartInclusionSettings {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static WORLDPARTINCLUSIONSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WorldPartInclusionSettings",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SUBWORLDINCLUSIONSETTINGS_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WorldPartInclusionSettings as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(WORLDPARTINCLUSIONSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WorldPartInclusionSettings {
    fn type_info(&self) -> &'static TypeInfo {
        WORLDPARTINCLUSIONSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static WORLDPARTINCLUSIONSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WorldPartInclusionSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("WorldPartInclusionSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AssemblyDescriptorData {
    pub _glacier_base: InterfaceDescriptorData,
}

pub trait AssemblyDescriptorDataTrait: InterfaceDescriptorDataTrait {
}

impl AssemblyDescriptorDataTrait for AssemblyDescriptorData {
}

impl InterfaceDescriptorDataTrait for AssemblyDescriptorData {
    fn input_events(&self) -> &Vec<DynamicEvent> {
        self._glacier_base.input_events()
    }
    fn output_events(&self) -> &Vec<DynamicEvent> {
        self._glacier_base.output_events()
    }
    fn input_links(&self) -> &Vec<DynamicLink> {
        self._glacier_base.input_links()
    }
    fn output_links(&self) -> &Vec<DynamicLink> {
        self._glacier_base.output_links()
    }
}

impl super::core::DynamicDataContainerTrait for AssemblyDescriptorData {
    fn fields(&self) -> &Vec<super::core::DataField> {
        self._glacier_base.fields()
    }
}

impl super::core::DataContainerTrait for AssemblyDescriptorData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static ASSEMBLYDESCRIPTORDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AssemblyDescriptorData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(INTERFACEDESCRIPTORDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AssemblyDescriptorData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(ASSEMBLYDESCRIPTORDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AssemblyDescriptorData {
    fn type_info(&self) -> &'static TypeInfo {
        ASSEMBLYDESCRIPTORDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ASSEMBLYDESCRIPTORDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AssemblyDescriptorData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("AssemblyDescriptorData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WorldObjectListData {
    pub _glacier_base: super::core::DataContainer,
}

pub trait WorldObjectListDataTrait: super::core::DataContainerTrait {
}

impl WorldObjectListDataTrait for WorldObjectListData {
}

impl super::core::DataContainerTrait for WorldObjectListData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static WORLDOBJECTLISTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WorldObjectListData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WorldObjectListData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(WORLDOBJECTLISTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WorldObjectListData {
    fn type_info(&self) -> &'static TypeInfo {
        WORLDOBJECTLISTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static WORLDOBJECTLISTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WorldObjectListData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("WorldObjectListData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WorldPartReferenceObjectData {
    pub _glacier_base: LayerReferenceObjectData,
}

pub trait WorldPartReferenceObjectDataTrait: LayerReferenceObjectDataTrait {
}

impl WorldPartReferenceObjectDataTrait for WorldPartReferenceObjectData {
}

impl LayerReferenceObjectDataTrait for WorldPartReferenceObjectData {
}

impl ReferenceObjectDataTrait for WorldPartReferenceObjectData {
    fn blueprint_transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.blueprint_transform()
    }
    fn blueprint(&self) -> &Option<Arc<Mutex<dyn BlueprintTrait>>> {
        self._glacier_base.blueprint()
    }
    fn object_variation(&self) -> &Option<Arc<Mutex<dyn ObjectVariationTrait>>> {
        self._glacier_base.object_variation()
    }
    fn stream_realm(&self) -> &StreamRealm {
        self._glacier_base.stream_realm()
    }
    fn radiosity_type_override(&self) -> &super::core::RadiosityTypeOverride {
        self._glacier_base.radiosity_type_override()
    }
    fn lightmap_resolution_scale(&self) -> &u32 {
        self._glacier_base.lightmap_resolution_scale()
    }
    fn lightmap_scale_with_size(&self) -> &bool {
        self._glacier_base.lightmap_scale_with_size()
    }
    fn rendering_overrides(&self) -> &super::core::RenderingOverrides {
        self._glacier_base.rendering_overrides()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn create_indestructible_entity(&self) -> &bool {
        self._glacier_base.create_indestructible_entity()
    }
}

impl GameObjectDataTrait for WorldPartReferenceObjectData {
}

impl super::core::DataBusPeerTrait for WorldPartReferenceObjectData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for WorldPartReferenceObjectData {
}

impl super::core::DataContainerTrait for WorldPartReferenceObjectData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static WORLDPARTREFERENCEOBJECTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WorldPartReferenceObjectData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(LAYERREFERENCEOBJECTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WorldPartReferenceObjectData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(WORLDPARTREFERENCEOBJECTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for WorldPartReferenceObjectData {
    fn type_info(&self) -> &'static TypeInfo {
        WORLDPARTREFERENCEOBJECTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static WORLDPARTREFERENCEOBJECTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WorldPartReferenceObjectData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("WorldPartReferenceObjectData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ReadOnlyLayerReferenceObjectData {
    pub _glacier_base: LayerReferenceObjectData,
}

pub trait ReadOnlyLayerReferenceObjectDataTrait: LayerReferenceObjectDataTrait {
}

impl ReadOnlyLayerReferenceObjectDataTrait for ReadOnlyLayerReferenceObjectData {
}

impl LayerReferenceObjectDataTrait for ReadOnlyLayerReferenceObjectData {
}

impl ReferenceObjectDataTrait for ReadOnlyLayerReferenceObjectData {
    fn blueprint_transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.blueprint_transform()
    }
    fn blueprint(&self) -> &Option<Arc<Mutex<dyn BlueprintTrait>>> {
        self._glacier_base.blueprint()
    }
    fn object_variation(&self) -> &Option<Arc<Mutex<dyn ObjectVariationTrait>>> {
        self._glacier_base.object_variation()
    }
    fn stream_realm(&self) -> &StreamRealm {
        self._glacier_base.stream_realm()
    }
    fn radiosity_type_override(&self) -> &super::core::RadiosityTypeOverride {
        self._glacier_base.radiosity_type_override()
    }
    fn lightmap_resolution_scale(&self) -> &u32 {
        self._glacier_base.lightmap_resolution_scale()
    }
    fn lightmap_scale_with_size(&self) -> &bool {
        self._glacier_base.lightmap_scale_with_size()
    }
    fn rendering_overrides(&self) -> &super::core::RenderingOverrides {
        self._glacier_base.rendering_overrides()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn create_indestructible_entity(&self) -> &bool {
        self._glacier_base.create_indestructible_entity()
    }
}

impl GameObjectDataTrait for ReadOnlyLayerReferenceObjectData {
}

impl super::core::DataBusPeerTrait for ReadOnlyLayerReferenceObjectData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for ReadOnlyLayerReferenceObjectData {
}

impl super::core::DataContainerTrait for ReadOnlyLayerReferenceObjectData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static READONLYLAYERREFERENCEOBJECTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadOnlyLayerReferenceObjectData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(LAYERREFERENCEOBJECTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ReadOnlyLayerReferenceObjectData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(READONLYLAYERREFERENCEOBJECTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ReadOnlyLayerReferenceObjectData {
    fn type_info(&self) -> &'static TypeInfo {
        READONLYLAYERREFERENCEOBJECTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static READONLYLAYERREFERENCEOBJECTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadOnlyLayerReferenceObjectData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ReadOnlyLayerReferenceObjectData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LayerReferenceObjectData {
    pub _glacier_base: ReferenceObjectData,
}

pub trait LayerReferenceObjectDataTrait: ReferenceObjectDataTrait {
}

impl LayerReferenceObjectDataTrait for LayerReferenceObjectData {
}

impl ReferenceObjectDataTrait for LayerReferenceObjectData {
    fn blueprint_transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.blueprint_transform()
    }
    fn blueprint(&self) -> &Option<Arc<Mutex<dyn BlueprintTrait>>> {
        self._glacier_base.blueprint()
    }
    fn object_variation(&self) -> &Option<Arc<Mutex<dyn ObjectVariationTrait>>> {
        self._glacier_base.object_variation()
    }
    fn stream_realm(&self) -> &StreamRealm {
        self._glacier_base.stream_realm()
    }
    fn radiosity_type_override(&self) -> &super::core::RadiosityTypeOverride {
        self._glacier_base.radiosity_type_override()
    }
    fn lightmap_resolution_scale(&self) -> &u32 {
        self._glacier_base.lightmap_resolution_scale()
    }
    fn lightmap_scale_with_size(&self) -> &bool {
        self._glacier_base.lightmap_scale_with_size()
    }
    fn rendering_overrides(&self) -> &super::core::RenderingOverrides {
        self._glacier_base.rendering_overrides()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn create_indestructible_entity(&self) -> &bool {
        self._glacier_base.create_indestructible_entity()
    }
}

impl GameObjectDataTrait for LayerReferenceObjectData {
}

impl super::core::DataBusPeerTrait for LayerReferenceObjectData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for LayerReferenceObjectData {
}

impl super::core::DataContainerTrait for LayerReferenceObjectData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static LAYERREFERENCEOBJECTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LayerReferenceObjectData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(REFERENCEOBJECTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LayerReferenceObjectData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(LAYERREFERENCEOBJECTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for LayerReferenceObjectData {
    fn type_info(&self) -> &'static TypeInfo {
        LAYERREFERENCEOBJECTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static LAYERREFERENCEOBJECTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LayerReferenceObjectData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("LayerReferenceObjectData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SubWorldReferenceObjectData {
    pub _glacier_base: ReferenceObjectData,
    pub bundle_name: String,
    pub preloaded_bundle_names: Vec<String>,
    pub bundle_heap: BundleHeapInfo,
    pub inclusion_settings: Option<Arc<Mutex<dyn SubWorldInclusionSettingsTrait>>>,
    pub auto_load: bool,
    pub is_detached_sub_level: bool,
    pub is_win32_sub_level: bool,
    pub is_gen4a_sub_level: bool,
    pub is_gen4b_sub_level: bool,
    pub is_i_o_s_sub_level: bool,
    pub is_android_sub_level: bool,
    pub is_o_s_x_sub_level: bool,
    pub is_linux_sub_level: bool,
    pub on_level_load_fire_on_stream_in: bool,
    pub use_peer_filtering: bool,
    pub parents: Vec<SharedBundleReference>,
}

pub trait SubWorldReferenceObjectDataTrait: ReferenceObjectDataTrait {
    fn bundle_name(&self) -> &String;
    fn preloaded_bundle_names(&self) -> &Vec<String>;
    fn bundle_heap(&self) -> &BundleHeapInfo;
    fn inclusion_settings(&self) -> &Option<Arc<Mutex<dyn SubWorldInclusionSettingsTrait>>>;
    fn auto_load(&self) -> &bool;
    fn is_detached_sub_level(&self) -> &bool;
    fn is_win32_sub_level(&self) -> &bool;
    fn is_gen4a_sub_level(&self) -> &bool;
    fn is_gen4b_sub_level(&self) -> &bool;
    fn is_i_o_s_sub_level(&self) -> &bool;
    fn is_android_sub_level(&self) -> &bool;
    fn is_o_s_x_sub_level(&self) -> &bool;
    fn is_linux_sub_level(&self) -> &bool;
    fn on_level_load_fire_on_stream_in(&self) -> &bool;
    fn use_peer_filtering(&self) -> &bool;
    fn parents(&self) -> &Vec<SharedBundleReference>;
}

impl SubWorldReferenceObjectDataTrait for SubWorldReferenceObjectData {
    fn bundle_name(&self) -> &String {
        &self.bundle_name
    }
    fn preloaded_bundle_names(&self) -> &Vec<String> {
        &self.preloaded_bundle_names
    }
    fn bundle_heap(&self) -> &BundleHeapInfo {
        &self.bundle_heap
    }
    fn inclusion_settings(&self) -> &Option<Arc<Mutex<dyn SubWorldInclusionSettingsTrait>>> {
        &self.inclusion_settings
    }
    fn auto_load(&self) -> &bool {
        &self.auto_load
    }
    fn is_detached_sub_level(&self) -> &bool {
        &self.is_detached_sub_level
    }
    fn is_win32_sub_level(&self) -> &bool {
        &self.is_win32_sub_level
    }
    fn is_gen4a_sub_level(&self) -> &bool {
        &self.is_gen4a_sub_level
    }
    fn is_gen4b_sub_level(&self) -> &bool {
        &self.is_gen4b_sub_level
    }
    fn is_i_o_s_sub_level(&self) -> &bool {
        &self.is_i_o_s_sub_level
    }
    fn is_android_sub_level(&self) -> &bool {
        &self.is_android_sub_level
    }
    fn is_o_s_x_sub_level(&self) -> &bool {
        &self.is_o_s_x_sub_level
    }
    fn is_linux_sub_level(&self) -> &bool {
        &self.is_linux_sub_level
    }
    fn on_level_load_fire_on_stream_in(&self) -> &bool {
        &self.on_level_load_fire_on_stream_in
    }
    fn use_peer_filtering(&self) -> &bool {
        &self.use_peer_filtering
    }
    fn parents(&self) -> &Vec<SharedBundleReference> {
        &self.parents
    }
}

impl ReferenceObjectDataTrait for SubWorldReferenceObjectData {
    fn blueprint_transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.blueprint_transform()
    }
    fn blueprint(&self) -> &Option<Arc<Mutex<dyn BlueprintTrait>>> {
        self._glacier_base.blueprint()
    }
    fn object_variation(&self) -> &Option<Arc<Mutex<dyn ObjectVariationTrait>>> {
        self._glacier_base.object_variation()
    }
    fn stream_realm(&self) -> &StreamRealm {
        self._glacier_base.stream_realm()
    }
    fn radiosity_type_override(&self) -> &super::core::RadiosityTypeOverride {
        self._glacier_base.radiosity_type_override()
    }
    fn lightmap_resolution_scale(&self) -> &u32 {
        self._glacier_base.lightmap_resolution_scale()
    }
    fn lightmap_scale_with_size(&self) -> &bool {
        self._glacier_base.lightmap_scale_with_size()
    }
    fn rendering_overrides(&self) -> &super::core::RenderingOverrides {
        self._glacier_base.rendering_overrides()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn create_indestructible_entity(&self) -> &bool {
        self._glacier_base.create_indestructible_entity()
    }
}

impl GameObjectDataTrait for SubWorldReferenceObjectData {
}

impl super::core::DataBusPeerTrait for SubWorldReferenceObjectData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for SubWorldReferenceObjectData {
}

impl super::core::DataContainerTrait for SubWorldReferenceObjectData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SUBWORLDREFERENCEOBJECTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubWorldReferenceObjectData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(REFERENCEOBJECTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SubWorldReferenceObjectData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "BundleName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(SubWorldReferenceObjectData, bundle_name),
            },
            FieldInfoData {
                name: "PreloadedBundleNames",
                flags: MemberInfoFlags::new(144),
                field_type: "CString-Array",
                rust_offset: offset_of!(SubWorldReferenceObjectData, preloaded_bundle_names),
            },
            FieldInfoData {
                name: "BundleHeap",
                flags: MemberInfoFlags::new(0),
                field_type: "BundleHeapInfo",
                rust_offset: offset_of!(SubWorldReferenceObjectData, bundle_heap),
            },
            FieldInfoData {
                name: "InclusionSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "SubWorldInclusionSettings",
                rust_offset: offset_of!(SubWorldReferenceObjectData, inclusion_settings),
            },
            FieldInfoData {
                name: "AutoLoad",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SubWorldReferenceObjectData, auto_load),
            },
            FieldInfoData {
                name: "IsDetachedSubLevel",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SubWorldReferenceObjectData, is_detached_sub_level),
            },
            FieldInfoData {
                name: "IsWin32SubLevel",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SubWorldReferenceObjectData, is_win32_sub_level),
            },
            FieldInfoData {
                name: "IsGen4aSubLevel",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SubWorldReferenceObjectData, is_gen4a_sub_level),
            },
            FieldInfoData {
                name: "IsGen4bSubLevel",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SubWorldReferenceObjectData, is_gen4b_sub_level),
            },
            FieldInfoData {
                name: "IsIOSSubLevel",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SubWorldReferenceObjectData, is_i_o_s_sub_level),
            },
            FieldInfoData {
                name: "IsAndroidSubLevel",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SubWorldReferenceObjectData, is_android_sub_level),
            },
            FieldInfoData {
                name: "IsOSXSubLevel",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SubWorldReferenceObjectData, is_o_s_x_sub_level),
            },
            FieldInfoData {
                name: "IsLinuxSubLevel",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SubWorldReferenceObjectData, is_linux_sub_level),
            },
            FieldInfoData {
                name: "OnLevelLoadFireOnStreamIn",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SubWorldReferenceObjectData, on_level_load_fire_on_stream_in),
            },
            FieldInfoData {
                name: "UsePeerFiltering",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SubWorldReferenceObjectData, use_peer_filtering),
            },
            FieldInfoData {
                name: "Parents",
                flags: MemberInfoFlags::new(144),
                field_type: "SharedBundleReference-Array",
                rust_offset: offset_of!(SubWorldReferenceObjectData, parents),
            },
        ],
    }),
    array_type: Some(SUBWORLDREFERENCEOBJECTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SubWorldReferenceObjectData {
    fn type_info(&self) -> &'static TypeInfo {
        SUBWORLDREFERENCEOBJECTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SUBWORLDREFERENCEOBJECTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubWorldReferenceObjectData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SubWorldReferenceObjectData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DetachedSubWorldData {
    pub _glacier_base: WorldData,
    pub reset_destruction_state: bool,
}

pub trait DetachedSubWorldDataTrait: WorldDataTrait {
    fn reset_destruction_state(&self) -> &bool;
}

impl DetachedSubWorldDataTrait for DetachedSubWorldData {
    fn reset_destruction_state(&self) -> &bool {
        &self.reset_destruction_state
    }
}

impl WorldDataTrait for DetachedSubWorldData {
    fn world_size_x_z(&self) -> &f32 {
        self._glacier_base.world_size_x_z()
    }
    fn world_size_y(&self) -> &f32 {
        self._glacier_base.world_size_y()
    }
    fn is_procedural_level(&self) -> &bool {
        self._glacier_base.is_procedural_level()
    }
    fn is_dedicated_server_level(&self) -> &bool {
        self._glacier_base.is_dedicated_server_level()
    }
}

impl SubWorldDataTrait for DetachedSubWorldData {
    fn runtime_material_grid(&self) -> &Option<Arc<Mutex<dyn MaterialGridDataTrait>>> {
        self._glacier_base.runtime_material_grid()
    }
    fn is_win32_sub_level(&self) -> &bool {
        self._glacier_base.is_win32_sub_level()
    }
    fn is_gen4a_sub_level(&self) -> &bool {
        self._glacier_base.is_gen4a_sub_level()
    }
    fn is_gen4b_sub_level(&self) -> &bool {
        self._glacier_base.is_gen4b_sub_level()
    }
    fn is_android_sub_level(&self) -> &bool {
        self._glacier_base.is_android_sub_level()
    }
    fn is_i_o_s_sub_level(&self) -> &bool {
        self._glacier_base.is_i_o_s_sub_level()
    }
    fn is_o_s_x_sub_level(&self) -> &bool {
        self._glacier_base.is_o_s_x_sub_level()
    }
    fn is_linux_sub_level(&self) -> &bool {
        self._glacier_base.is_linux_sub_level()
    }
    fn persistence_setting(&self) -> &BlueprintPersistenceSetting {
        self._glacier_base.persistence_setting()
    }
    fn auto_asset_collector(&self) -> &Option<Arc<Mutex<dyn AutoAssetCollectorTrait>>> {
        self._glacier_base.auto_asset_collector()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn SubWorldDataComponentTrait>>>> {
        self._glacier_base.components()
    }
}

impl SpatialPrefabBlueprintTrait for DetachedSubWorldData {
}

impl PrefabBlueprintTrait for DetachedSubWorldData {
    fn time_delta_type(&self) -> &TimeDeltaType {
        self._glacier_base.time_delta_type()
    }
}

impl BlueprintTrait for DetachedSubWorldData {
    fn objects(&self) -> &Vec<Option<Arc<Mutex<dyn GameObjectDataTrait>>>> {
        self._glacier_base.objects()
    }
    fn schematics(&self) -> &Option<Arc<Mutex<dyn super::schematics::SchematicsBaseAssetTrait>>> {
        self._glacier_base.schematics()
    }
}

impl EntityBusDataTrait for DetachedSubWorldData {
    fn event_connections(&self) -> &Vec<EventConnection> {
        self._glacier_base.event_connections()
    }
}

impl super::core::DataBusDataTrait for DetachedSubWorldData {
    fn flags(&self) -> &u16 {
        self._glacier_base.flags()
    }
    fn property_connections(&self) -> &Vec<super::core::PropertyConnection> {
        self._glacier_base.property_connections()
    }
    fn link_connections(&self) -> &Vec<super::core::LinkConnection> {
        self._glacier_base.link_connections()
    }
    fn interface(&self) -> &Option<Arc<Mutex<dyn super::core::DynamicDataContainerTrait>>> {
        self._glacier_base.interface()
    }
}

impl super::core::AssetTrait for DetachedSubWorldData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for DetachedSubWorldData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static DETACHEDSUBWORLDDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DetachedSubWorldData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(WORLDDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DetachedSubWorldData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ResetDestructionState",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DetachedSubWorldData, reset_destruction_state),
            },
        ],
    }),
    array_type: Some(DETACHEDSUBWORLDDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DetachedSubWorldData {
    fn type_info(&self) -> &'static TypeInfo {
        DETACHEDSUBWORLDDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static DETACHEDSUBWORLDDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DetachedSubWorldData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("DetachedSubWorldData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WorldData {
    pub _glacier_base: SubWorldData,
    pub world_size_x_z: f32,
    pub world_size_y: f32,
    pub is_procedural_level: bool,
    pub is_dedicated_server_level: bool,
}

pub trait WorldDataTrait: SubWorldDataTrait {
    fn world_size_x_z(&self) -> &f32;
    fn world_size_y(&self) -> &f32;
    fn is_procedural_level(&self) -> &bool;
    fn is_dedicated_server_level(&self) -> &bool;
}

impl WorldDataTrait for WorldData {
    fn world_size_x_z(&self) -> &f32 {
        &self.world_size_x_z
    }
    fn world_size_y(&self) -> &f32 {
        &self.world_size_y
    }
    fn is_procedural_level(&self) -> &bool {
        &self.is_procedural_level
    }
    fn is_dedicated_server_level(&self) -> &bool {
        &self.is_dedicated_server_level
    }
}

impl SubWorldDataTrait for WorldData {
    fn runtime_material_grid(&self) -> &Option<Arc<Mutex<dyn MaterialGridDataTrait>>> {
        self._glacier_base.runtime_material_grid()
    }
    fn is_win32_sub_level(&self) -> &bool {
        self._glacier_base.is_win32_sub_level()
    }
    fn is_gen4a_sub_level(&self) -> &bool {
        self._glacier_base.is_gen4a_sub_level()
    }
    fn is_gen4b_sub_level(&self) -> &bool {
        self._glacier_base.is_gen4b_sub_level()
    }
    fn is_android_sub_level(&self) -> &bool {
        self._glacier_base.is_android_sub_level()
    }
    fn is_i_o_s_sub_level(&self) -> &bool {
        self._glacier_base.is_i_o_s_sub_level()
    }
    fn is_o_s_x_sub_level(&self) -> &bool {
        self._glacier_base.is_o_s_x_sub_level()
    }
    fn is_linux_sub_level(&self) -> &bool {
        self._glacier_base.is_linux_sub_level()
    }
    fn persistence_setting(&self) -> &BlueprintPersistenceSetting {
        self._glacier_base.persistence_setting()
    }
    fn auto_asset_collector(&self) -> &Option<Arc<Mutex<dyn AutoAssetCollectorTrait>>> {
        self._glacier_base.auto_asset_collector()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn SubWorldDataComponentTrait>>>> {
        self._glacier_base.components()
    }
}

impl SpatialPrefabBlueprintTrait for WorldData {
}

impl PrefabBlueprintTrait for WorldData {
    fn time_delta_type(&self) -> &TimeDeltaType {
        self._glacier_base.time_delta_type()
    }
}

impl BlueprintTrait for WorldData {
    fn objects(&self) -> &Vec<Option<Arc<Mutex<dyn GameObjectDataTrait>>>> {
        self._glacier_base.objects()
    }
    fn schematics(&self) -> &Option<Arc<Mutex<dyn super::schematics::SchematicsBaseAssetTrait>>> {
        self._glacier_base.schematics()
    }
}

impl EntityBusDataTrait for WorldData {
    fn event_connections(&self) -> &Vec<EventConnection> {
        self._glacier_base.event_connections()
    }
}

impl super::core::DataBusDataTrait for WorldData {
    fn flags(&self) -> &u16 {
        self._glacier_base.flags()
    }
    fn property_connections(&self) -> &Vec<super::core::PropertyConnection> {
        self._glacier_base.property_connections()
    }
    fn link_connections(&self) -> &Vec<super::core::LinkConnection> {
        self._glacier_base.link_connections()
    }
    fn interface(&self) -> &Option<Arc<Mutex<dyn super::core::DynamicDataContainerTrait>>> {
        self._glacier_base.interface()
    }
}

impl super::core::AssetTrait for WorldData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for WorldData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static WORLDDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WorldData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SUBWORLDDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WorldData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "WorldSizeXZ",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WorldData, world_size_x_z),
            },
            FieldInfoData {
                name: "WorldSizeY",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WorldData, world_size_y),
            },
            FieldInfoData {
                name: "IsProceduralLevel",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WorldData, is_procedural_level),
            },
            FieldInfoData {
                name: "IsDedicatedServerLevel",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WorldData, is_dedicated_server_level),
            },
        ],
    }),
    array_type: Some(WORLDDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WorldData {
    fn type_info(&self) -> &'static TypeInfo {
        WORLDDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static WORLDDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WorldData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("WorldData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SubWorldData {
    pub _glacier_base: SpatialPrefabBlueprint,
    pub runtime_material_grid: Option<Arc<Mutex<dyn MaterialGridDataTrait>>>,
    pub is_win32_sub_level: bool,
    pub is_gen4a_sub_level: bool,
    pub is_gen4b_sub_level: bool,
    pub is_android_sub_level: bool,
    pub is_i_o_s_sub_level: bool,
    pub is_o_s_x_sub_level: bool,
    pub is_linux_sub_level: bool,
    pub persistence_setting: BlueprintPersistenceSetting,
    pub auto_asset_collector: Option<Arc<Mutex<dyn AutoAssetCollectorTrait>>>,
    pub components: Vec<Option<Arc<Mutex<dyn SubWorldDataComponentTrait>>>>,
}

pub trait SubWorldDataTrait: SpatialPrefabBlueprintTrait {
    fn runtime_material_grid(&self) -> &Option<Arc<Mutex<dyn MaterialGridDataTrait>>>;
    fn is_win32_sub_level(&self) -> &bool;
    fn is_gen4a_sub_level(&self) -> &bool;
    fn is_gen4b_sub_level(&self) -> &bool;
    fn is_android_sub_level(&self) -> &bool;
    fn is_i_o_s_sub_level(&self) -> &bool;
    fn is_o_s_x_sub_level(&self) -> &bool;
    fn is_linux_sub_level(&self) -> &bool;
    fn persistence_setting(&self) -> &BlueprintPersistenceSetting;
    fn auto_asset_collector(&self) -> &Option<Arc<Mutex<dyn AutoAssetCollectorTrait>>>;
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn SubWorldDataComponentTrait>>>>;
}

impl SubWorldDataTrait for SubWorldData {
    fn runtime_material_grid(&self) -> &Option<Arc<Mutex<dyn MaterialGridDataTrait>>> {
        &self.runtime_material_grid
    }
    fn is_win32_sub_level(&self) -> &bool {
        &self.is_win32_sub_level
    }
    fn is_gen4a_sub_level(&self) -> &bool {
        &self.is_gen4a_sub_level
    }
    fn is_gen4b_sub_level(&self) -> &bool {
        &self.is_gen4b_sub_level
    }
    fn is_android_sub_level(&self) -> &bool {
        &self.is_android_sub_level
    }
    fn is_i_o_s_sub_level(&self) -> &bool {
        &self.is_i_o_s_sub_level
    }
    fn is_o_s_x_sub_level(&self) -> &bool {
        &self.is_o_s_x_sub_level
    }
    fn is_linux_sub_level(&self) -> &bool {
        &self.is_linux_sub_level
    }
    fn persistence_setting(&self) -> &BlueprintPersistenceSetting {
        &self.persistence_setting
    }
    fn auto_asset_collector(&self) -> &Option<Arc<Mutex<dyn AutoAssetCollectorTrait>>> {
        &self.auto_asset_collector
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn SubWorldDataComponentTrait>>>> {
        &self.components
    }
}

impl SpatialPrefabBlueprintTrait for SubWorldData {
}

impl PrefabBlueprintTrait for SubWorldData {
    fn time_delta_type(&self) -> &TimeDeltaType {
        self._glacier_base.time_delta_type()
    }
}

impl BlueprintTrait for SubWorldData {
    fn objects(&self) -> &Vec<Option<Arc<Mutex<dyn GameObjectDataTrait>>>> {
        self._glacier_base.objects()
    }
    fn schematics(&self) -> &Option<Arc<Mutex<dyn super::schematics::SchematicsBaseAssetTrait>>> {
        self._glacier_base.schematics()
    }
}

impl EntityBusDataTrait for SubWorldData {
    fn event_connections(&self) -> &Vec<EventConnection> {
        self._glacier_base.event_connections()
    }
}

impl super::core::DataBusDataTrait for SubWorldData {
    fn flags(&self) -> &u16 {
        self._glacier_base.flags()
    }
    fn property_connections(&self) -> &Vec<super::core::PropertyConnection> {
        self._glacier_base.property_connections()
    }
    fn link_connections(&self) -> &Vec<super::core::LinkConnection> {
        self._glacier_base.link_connections()
    }
    fn interface(&self) -> &Option<Arc<Mutex<dyn super::core::DynamicDataContainerTrait>>> {
        self._glacier_base.interface()
    }
}

impl super::core::AssetTrait for SubWorldData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for SubWorldData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SUBWORLDDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubWorldData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SPATIALPREFABBLUEPRINT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SubWorldData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "RuntimeMaterialGrid",
                flags: MemberInfoFlags::new(0),
                field_type: "MaterialGridData",
                rust_offset: offset_of!(SubWorldData, runtime_material_grid),
            },
            FieldInfoData {
                name: "IsWin32SubLevel",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SubWorldData, is_win32_sub_level),
            },
            FieldInfoData {
                name: "IsGen4aSubLevel",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SubWorldData, is_gen4a_sub_level),
            },
            FieldInfoData {
                name: "IsGen4bSubLevel",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SubWorldData, is_gen4b_sub_level),
            },
            FieldInfoData {
                name: "IsAndroidSubLevel",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SubWorldData, is_android_sub_level),
            },
            FieldInfoData {
                name: "IsIOSSubLevel",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SubWorldData, is_i_o_s_sub_level),
            },
            FieldInfoData {
                name: "IsOSXSubLevel",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SubWorldData, is_o_s_x_sub_level),
            },
            FieldInfoData {
                name: "IsLinuxSubLevel",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SubWorldData, is_linux_sub_level),
            },
            FieldInfoData {
                name: "PersistenceSetting",
                flags: MemberInfoFlags::new(0),
                field_type: "BlueprintPersistenceSetting",
                rust_offset: offset_of!(SubWorldData, persistence_setting),
            },
            FieldInfoData {
                name: "AutoAssetCollector",
                flags: MemberInfoFlags::new(0),
                field_type: "AutoAssetCollector",
                rust_offset: offset_of!(SubWorldData, auto_asset_collector),
            },
            FieldInfoData {
                name: "Components",
                flags: MemberInfoFlags::new(144),
                field_type: "SubWorldDataComponent-Array",
                rust_offset: offset_of!(SubWorldData, components),
            },
        ],
    }),
    array_type: Some(SUBWORLDDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SubWorldData {
    fn type_info(&self) -> &'static TypeInfo {
        SUBWORLDDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SUBWORLDDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubWorldData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SubWorldData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SubWorldDataComponent {
    pub _glacier_base: super::core::DataContainer,
}

pub trait SubWorldDataComponentTrait: super::core::DataContainerTrait {
}

impl SubWorldDataComponentTrait for SubWorldDataComponent {
}

impl super::core::DataContainerTrait for SubWorldDataComponent {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SUBWORLDDATACOMPONENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubWorldDataComponent",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SubWorldDataComponent as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SUBWORLDDATACOMPONENT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SubWorldDataComponent {
    fn type_info(&self) -> &'static TypeInfo {
        SUBWORLDDATACOMPONENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SUBWORLDDATACOMPONENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubWorldDataComponent-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SubWorldDataComponent"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WorldPartData {
    pub _glacier_base: LayerData,
}

pub trait WorldPartDataTrait: LayerDataTrait {
}

impl WorldPartDataTrait for WorldPartData {
}

impl LayerDataTrait for WorldPartData {
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn hack_to_solve_real_time_tweaking_issue(&self) -> &glacier_util::guid::Guid {
        self._glacier_base.hack_to_solve_real_time_tweaking_issue()
    }
}

impl PrefabBlueprintTrait for WorldPartData {
    fn time_delta_type(&self) -> &TimeDeltaType {
        self._glacier_base.time_delta_type()
    }
}

impl BlueprintTrait for WorldPartData {
    fn objects(&self) -> &Vec<Option<Arc<Mutex<dyn GameObjectDataTrait>>>> {
        self._glacier_base.objects()
    }
    fn schematics(&self) -> &Option<Arc<Mutex<dyn super::schematics::SchematicsBaseAssetTrait>>> {
        self._glacier_base.schematics()
    }
}

impl EntityBusDataTrait for WorldPartData {
    fn event_connections(&self) -> &Vec<EventConnection> {
        self._glacier_base.event_connections()
    }
}

impl super::core::DataBusDataTrait for WorldPartData {
    fn flags(&self) -> &u16 {
        self._glacier_base.flags()
    }
    fn property_connections(&self) -> &Vec<super::core::PropertyConnection> {
        self._glacier_base.property_connections()
    }
    fn link_connections(&self) -> &Vec<super::core::LinkConnection> {
        self._glacier_base.link_connections()
    }
    fn interface(&self) -> &Option<Arc<Mutex<dyn super::core::DynamicDataContainerTrait>>> {
        self._glacier_base.interface()
    }
}

impl super::core::AssetTrait for WorldPartData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for WorldPartData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static WORLDPARTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WorldPartData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(LAYERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WorldPartData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(WORLDPARTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WorldPartData {
    fn type_info(&self) -> &'static TypeInfo {
        WORLDPARTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static WORLDPARTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WorldPartData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("WorldPartData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LayerData {
    pub _glacier_base: PrefabBlueprint,
    pub enabled: bool,
    pub hack_to_solve_real_time_tweaking_issue: glacier_util::guid::Guid,
}

pub trait LayerDataTrait: PrefabBlueprintTrait {
    fn enabled(&self) -> &bool;
    fn hack_to_solve_real_time_tweaking_issue(&self) -> &glacier_util::guid::Guid;
}

impl LayerDataTrait for LayerData {
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn hack_to_solve_real_time_tweaking_issue(&self) -> &glacier_util::guid::Guid {
        &self.hack_to_solve_real_time_tweaking_issue
    }
}

impl PrefabBlueprintTrait for LayerData {
    fn time_delta_type(&self) -> &TimeDeltaType {
        self._glacier_base.time_delta_type()
    }
}

impl BlueprintTrait for LayerData {
    fn objects(&self) -> &Vec<Option<Arc<Mutex<dyn GameObjectDataTrait>>>> {
        self._glacier_base.objects()
    }
    fn schematics(&self) -> &Option<Arc<Mutex<dyn super::schematics::SchematicsBaseAssetTrait>>> {
        self._glacier_base.schematics()
    }
}

impl EntityBusDataTrait for LayerData {
    fn event_connections(&self) -> &Vec<EventConnection> {
        self._glacier_base.event_connections()
    }
}

impl super::core::DataBusDataTrait for LayerData {
    fn flags(&self) -> &u16 {
        self._glacier_base.flags()
    }
    fn property_connections(&self) -> &Vec<super::core::PropertyConnection> {
        self._glacier_base.property_connections()
    }
    fn link_connections(&self) -> &Vec<super::core::LinkConnection> {
        self._glacier_base.link_connections()
    }
    fn interface(&self) -> &Option<Arc<Mutex<dyn super::core::DynamicDataContainerTrait>>> {
        self._glacier_base.interface()
    }
}

impl super::core::AssetTrait for LayerData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for LayerData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static LAYERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LayerData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PREFABBLUEPRINT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LayerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LayerData, enabled),
            },
            FieldInfoData {
                name: "HackToSolveRealTimeTweakingIssue",
                flags: MemberInfoFlags::new(0),
                field_type: "Guid",
                rust_offset: offset_of!(LayerData, hack_to_solve_real_time_tweaking_issue),
            },
        ],
    }),
    array_type: Some(LAYERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LayerData {
    fn type_info(&self) -> &'static TypeInfo {
        LAYERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static LAYERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LayerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("LayerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SubWorldInclusionSettings {
    pub _glacier_base: super::core::DataContainer,
    pub settings: Vec<Option<Arc<Mutex<dyn SubWorldInclusionSettingTrait>>>>,
}

pub trait SubWorldInclusionSettingsTrait: super::core::DataContainerTrait {
    fn settings(&self) -> &Vec<Option<Arc<Mutex<dyn SubWorldInclusionSettingTrait>>>>;
}

impl SubWorldInclusionSettingsTrait for SubWorldInclusionSettings {
    fn settings(&self) -> &Vec<Option<Arc<Mutex<dyn SubWorldInclusionSettingTrait>>>> {
        &self.settings
    }
}

impl super::core::DataContainerTrait for SubWorldInclusionSettings {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SUBWORLDINCLUSIONSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubWorldInclusionSettings",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SubWorldInclusionSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Settings",
                flags: MemberInfoFlags::new(144),
                field_type: "SubWorldInclusionSetting-Array",
                rust_offset: offset_of!(SubWorldInclusionSettings, settings),
            },
        ],
    }),
    array_type: Some(SUBWORLDINCLUSIONSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SubWorldInclusionSettings {
    fn type_info(&self) -> &'static TypeInfo {
        SUBWORLDINCLUSIONSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SUBWORLDINCLUSIONSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubWorldInclusionSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SubWorldInclusionSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SubWorldInclusionSetting {
    pub _glacier_base: super::core::DataContainer,
    pub criterion: Option<Arc<Mutex<dyn SubWorldInclusionCriterionTrait>>>,
    pub enabled_options: Vec<String>,
}

pub trait SubWorldInclusionSettingTrait: super::core::DataContainerTrait {
    fn criterion(&self) -> &Option<Arc<Mutex<dyn SubWorldInclusionCriterionTrait>>>;
    fn enabled_options(&self) -> &Vec<String>;
}

impl SubWorldInclusionSettingTrait for SubWorldInclusionSetting {
    fn criterion(&self) -> &Option<Arc<Mutex<dyn SubWorldInclusionCriterionTrait>>> {
        &self.criterion
    }
    fn enabled_options(&self) -> &Vec<String> {
        &self.enabled_options
    }
}

impl super::core::DataContainerTrait for SubWorldInclusionSetting {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SUBWORLDINCLUSIONSETTING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubWorldInclusionSetting",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SubWorldInclusionSetting as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Criterion",
                flags: MemberInfoFlags::new(0),
                field_type: "SubWorldInclusionCriterion",
                rust_offset: offset_of!(SubWorldInclusionSetting, criterion),
            },
            FieldInfoData {
                name: "EnabledOptions",
                flags: MemberInfoFlags::new(144),
                field_type: "CString-Array",
                rust_offset: offset_of!(SubWorldInclusionSetting, enabled_options),
            },
        ],
    }),
    array_type: Some(SUBWORLDINCLUSIONSETTING_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SubWorldInclusionSetting {
    fn type_info(&self) -> &'static TypeInfo {
        SUBWORLDINCLUSIONSETTING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SUBWORLDINCLUSIONSETTING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubWorldInclusionSetting-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SubWorldInclusionSetting"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SubWorldInclusion {
    pub _glacier_base: super::core::Asset,
    pub criteria: Vec<Option<Arc<Mutex<dyn SubWorldInclusionCriterionTrait>>>>,
}

pub trait SubWorldInclusionTrait: super::core::AssetTrait {
    fn criteria(&self) -> &Vec<Option<Arc<Mutex<dyn SubWorldInclusionCriterionTrait>>>>;
}

impl SubWorldInclusionTrait for SubWorldInclusion {
    fn criteria(&self) -> &Vec<Option<Arc<Mutex<dyn SubWorldInclusionCriterionTrait>>>> {
        &self.criteria
    }
}

impl super::core::AssetTrait for SubWorldInclusion {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for SubWorldInclusion {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SUBWORLDINCLUSION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubWorldInclusion",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SubWorldInclusion as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Criteria",
                flags: MemberInfoFlags::new(144),
                field_type: "SubWorldInclusionCriterion-Array",
                rust_offset: offset_of!(SubWorldInclusion, criteria),
            },
        ],
    }),
    array_type: Some(SUBWORLDINCLUSION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SubWorldInclusion {
    fn type_info(&self) -> &'static TypeInfo {
        SUBWORLDINCLUSION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SUBWORLDINCLUSION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubWorldInclusion-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SubWorldInclusion"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SubWorldInclusionCriterion {
    pub _glacier_base: super::core::DataContainer,
    pub name: String,
    pub options: Vec<String>,
}

pub trait SubWorldInclusionCriterionTrait: super::core::DataContainerTrait {
    fn name(&self) -> &String;
    fn options(&self) -> &Vec<String>;
}

impl SubWorldInclusionCriterionTrait for SubWorldInclusionCriterion {
    fn name(&self) -> &String {
        &self.name
    }
    fn options(&self) -> &Vec<String> {
        &self.options
    }
}

impl super::core::DataContainerTrait for SubWorldInclusionCriterion {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SUBWORLDINCLUSIONCRITERION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubWorldInclusionCriterion",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SubWorldInclusionCriterion as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(SubWorldInclusionCriterion, name),
            },
            FieldInfoData {
                name: "Options",
                flags: MemberInfoFlags::new(144),
                field_type: "CString-Array",
                rust_offset: offset_of!(SubWorldInclusionCriterion, options),
            },
        ],
    }),
    array_type: Some(SUBWORLDINCLUSIONCRITERION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SubWorldInclusionCriterion {
    fn type_info(&self) -> &'static TypeInfo {
        SUBWORLDINCLUSIONCRITERION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SUBWORLDINCLUSIONCRITERION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubWorldInclusionCriterion-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SubWorldInclusionCriterion"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LevelSetup {
    pub name: String,
    pub inclusion_options: Vec<LevelSetupOption>,
    pub difficulty_index: u32,
    pub start_point: String,
    pub is_save_game: bool,
    pub has_persistent_save: bool,
    pub force_reload_resources: bool,
    pub level_manager_initial_level: String,
    pub level_manager_start_point: String,
}

pub trait LevelSetupTrait: TypeObject {
    fn name(&self) -> &String;
    fn inclusion_options(&self) -> &Vec<LevelSetupOption>;
    fn difficulty_index(&self) -> &u32;
    fn start_point(&self) -> &String;
    fn is_save_game(&self) -> &bool;
    fn has_persistent_save(&self) -> &bool;
    fn force_reload_resources(&self) -> &bool;
    fn level_manager_initial_level(&self) -> &String;
    fn level_manager_start_point(&self) -> &String;
}

impl LevelSetupTrait for LevelSetup {
    fn name(&self) -> &String {
        &self.name
    }
    fn inclusion_options(&self) -> &Vec<LevelSetupOption> {
        &self.inclusion_options
    }
    fn difficulty_index(&self) -> &u32 {
        &self.difficulty_index
    }
    fn start_point(&self) -> &String {
        &self.start_point
    }
    fn is_save_game(&self) -> &bool {
        &self.is_save_game
    }
    fn has_persistent_save(&self) -> &bool {
        &self.has_persistent_save
    }
    fn force_reload_resources(&self) -> &bool {
        &self.force_reload_resources
    }
    fn level_manager_initial_level(&self) -> &String {
        &self.level_manager_initial_level
    }
    fn level_manager_start_point(&self) -> &String {
        &self.level_manager_start_point
    }
}

pub static LEVELSETUP_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LevelSetup",
    flags: MemberInfoFlags::new(73),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LevelSetup as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(LevelSetup, name),
            },
            FieldInfoData {
                name: "InclusionOptions",
                flags: MemberInfoFlags::new(144),
                field_type: "LevelSetupOption-Array",
                rust_offset: offset_of!(LevelSetup, inclusion_options),
            },
            FieldInfoData {
                name: "DifficultyIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(LevelSetup, difficulty_index),
            },
            FieldInfoData {
                name: "StartPoint",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(LevelSetup, start_point),
            },
            FieldInfoData {
                name: "IsSaveGame",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LevelSetup, is_save_game),
            },
            FieldInfoData {
                name: "HasPersistentSave",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LevelSetup, has_persistent_save),
            },
            FieldInfoData {
                name: "ForceReloadResources",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LevelSetup, force_reload_resources),
            },
            FieldInfoData {
                name: "LevelManagerInitialLevel",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(LevelSetup, level_manager_initial_level),
            },
            FieldInfoData {
                name: "LevelManagerStartPoint",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(LevelSetup, level_manager_start_point),
            },
        ],
    }),
    array_type: Some(LEVELSETUP_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LevelSetup {
    fn type_info(&self) -> &'static TypeInfo {
        LEVELSETUP_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static LEVELSETUP_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LevelSetup-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("LevelSetup"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LevelSetupOption {
    pub criterion: String,
    pub value: String,
}

pub trait LevelSetupOptionTrait: TypeObject {
    fn criterion(&self) -> &String;
    fn value(&self) -> &String;
}

impl LevelSetupOptionTrait for LevelSetupOption {
    fn criterion(&self) -> &String {
        &self.criterion
    }
    fn value(&self) -> &String {
        &self.value
    }
}

pub static LEVELSETUPOPTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LevelSetupOption",
    flags: MemberInfoFlags::new(73),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LevelSetupOption as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Criterion",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(LevelSetupOption, criterion),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(LevelSetupOption, value),
            },
        ],
    }),
    array_type: Some(LEVELSETUPOPTION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LevelSetupOption {
    fn type_info(&self) -> &'static TypeInfo {
        LEVELSETUPOPTION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static LEVELSETUPOPTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LevelSetupOption-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("LevelSetupOption"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CreateSchematicsInstanceEntity {
    pub _glacier_base: Entity,
}

pub trait CreateSchematicsInstanceEntityTrait: EntityTrait {
}

impl CreateSchematicsInstanceEntityTrait for CreateSchematicsInstanceEntity {
}

impl EntityTrait for CreateSchematicsInstanceEntity {
}

impl EntityBusPeerTrait for CreateSchematicsInstanceEntity {
}

pub static CREATESCHEMATICSINSTANCEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CreateSchematicsInstanceEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CreateSchematicsInstanceEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(CREATESCHEMATICSINSTANCEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for CreateSchematicsInstanceEntity {
    fn type_info(&self) -> &'static TypeInfo {
        CREATESCHEMATICSINSTANCEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CREATESCHEMATICSINSTANCEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CreateSchematicsInstanceEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CreateSchematicsInstanceEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GetEntityBusEntity {
    pub _glacier_base: Entity,
}

pub trait GetEntityBusEntityTrait: EntityTrait {
}

impl GetEntityBusEntityTrait for GetEntityBusEntity {
}

impl EntityTrait for GetEntityBusEntity {
}

impl EntityBusPeerTrait for GetEntityBusEntity {
}

pub static GETENTITYBUSENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GetEntityBusEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GetEntityBusEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(GETENTITYBUSENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for GetEntityBusEntity {
    fn type_info(&self) -> &'static TypeInfo {
        GETENTITYBUSENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static GETENTITYBUSENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GetEntityBusEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("GetEntityBusEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GetEntityEntity {
    pub _glacier_base: Entity,
}

pub trait GetEntityEntityTrait: EntityTrait {
}

impl GetEntityEntityTrait for GetEntityEntity {
}

impl EntityTrait for GetEntityEntity {
}

impl EntityBusPeerTrait for GetEntityEntity {
}

pub static GETENTITYENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GetEntityEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GetEntityEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(GETENTITYENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for GetEntityEntity {
    fn type_info(&self) -> &'static TypeInfo {
        GETENTITYENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static GETENTITYENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GetEntityEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("GetEntityEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CallFunctionEntity {
    pub _glacier_base: Entity,
}

pub trait CallFunctionEntityTrait: EntityTrait {
}

impl CallFunctionEntityTrait for CallFunctionEntity {
}

impl EntityTrait for CallFunctionEntity {
}

impl EntityBusPeerTrait for CallFunctionEntity {
}

pub static CALLFUNCTIONENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CallFunctionEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CallFunctionEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(CALLFUNCTIONENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for CallFunctionEntity {
    fn type_info(&self) -> &'static TypeInfo {
        CALLFUNCTIONENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CALLFUNCTIONENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CallFunctionEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CallFunctionEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EntityTransformSpace {
}

pub trait EntityTransformSpaceTrait: TypeObject {
}

impl EntityTransformSpaceTrait for EntityTransformSpace {
}

pub static ENTITYTRANSFORMSPACE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityTransformSpace",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: None,
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EntityTransformSpace as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(ENTITYTRANSFORMSPACE_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for EntityTransformSpace {
    fn type_info(&self) -> &'static TypeInfo {
        ENTITYTRANSFORMSPACE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ENTITYTRANSFORMSPACE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityTransformSpace-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EntityTransformSpace"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Entity {
    pub _glacier_base: EntityBusPeer,
}

pub trait EntityTrait: EntityBusPeerTrait {
}

impl EntityTrait for Entity {
}

impl EntityBusPeerTrait for Entity {
}

pub static ENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Entity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYBUSPEER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Entity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(ENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for Entity {
    fn type_info(&self) -> &'static TypeInfo {
        ENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Entity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Entity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ComponentEntity {
    pub _glacier_base: SpatialEntity,
}

pub trait ComponentEntityTrait: SpatialEntityTrait {
}

impl ComponentEntityTrait for ComponentEntity {
}

impl SpatialEntityTrait for ComponentEntity {
}

impl EntityTrait for ComponentEntity {
}

impl EntityBusPeerTrait for ComponentEntity {
}

pub static COMPONENTENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ComponentEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SPATIALENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ComponentEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(COMPONENTENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ComponentEntity {
    fn type_info(&self) -> &'static TypeInfo {
        COMPONENTENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static COMPONENTENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ComponentEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ComponentEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Component {
    pub _glacier_base: EntityBusPeer,
}

pub trait ComponentTrait: EntityBusPeerTrait {
}

impl ComponentTrait for Component {
}

impl EntityBusPeerTrait for Component {
}

pub static COMPONENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Component",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYBUSPEER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Component as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(COMPONENT_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for Component {
    fn type_info(&self) -> &'static TypeInfo {
        COMPONENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static COMPONENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Component-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Component"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CompareAxisAlignedBoxEntity {
    pub _glacier_base: Entity,
}

pub trait CompareAxisAlignedBoxEntityTrait: EntityTrait {
}

impl CompareAxisAlignedBoxEntityTrait for CompareAxisAlignedBoxEntity {
}

impl EntityTrait for CompareAxisAlignedBoxEntity {
}

impl EntityBusPeerTrait for CompareAxisAlignedBoxEntity {
}

pub static COMPAREAXISALIGNEDBOXENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareAxisAlignedBoxEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareAxisAlignedBoxEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(COMPAREAXISALIGNEDBOXENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for CompareAxisAlignedBoxEntity {
    fn type_info(&self) -> &'static TypeInfo {
        COMPAREAXISALIGNEDBOXENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static COMPAREAXISALIGNEDBOXENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareAxisAlignedBoxEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareAxisAlignedBoxEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CompareUintRangeEntity {
    pub _glacier_base: Entity,
}

pub trait CompareUintRangeEntityTrait: EntityTrait {
}

impl CompareUintRangeEntityTrait for CompareUintRangeEntity {
}

impl EntityTrait for CompareUintRangeEntity {
}

impl EntityBusPeerTrait for CompareUintRangeEntity {
}

pub static COMPAREUINTRANGEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareUintRangeEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareUintRangeEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(COMPAREUINTRANGEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for CompareUintRangeEntity {
    fn type_info(&self) -> &'static TypeInfo {
        COMPAREUINTRANGEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static COMPAREUINTRANGEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareUintRangeEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareUintRangeEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CompareIntRangeEntity {
    pub _glacier_base: Entity,
}

pub trait CompareIntRangeEntityTrait: EntityTrait {
}

impl CompareIntRangeEntityTrait for CompareIntRangeEntity {
}

impl EntityTrait for CompareIntRangeEntity {
}

impl EntityBusPeerTrait for CompareIntRangeEntity {
}

pub static COMPAREINTRANGEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareIntRangeEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareIntRangeEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(COMPAREINTRANGEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for CompareIntRangeEntity {
    fn type_info(&self) -> &'static TypeInfo {
        COMPAREINTRANGEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static COMPAREINTRANGEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareIntRangeEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareIntRangeEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CompareVec4Entity {
    pub _glacier_base: Entity,
}

pub trait CompareVec4EntityTrait: EntityTrait {
}

impl CompareVec4EntityTrait for CompareVec4Entity {
}

impl EntityTrait for CompareVec4Entity {
}

impl EntityBusPeerTrait for CompareVec4Entity {
}

pub static COMPAREVEC4ENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareVec4Entity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareVec4Entity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(COMPAREVEC4ENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for CompareVec4Entity {
    fn type_info(&self) -> &'static TypeInfo {
        COMPAREVEC4ENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static COMPAREVEC4ENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareVec4Entity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareVec4Entity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CompareVec3Entity {
    pub _glacier_base: Entity,
}

pub trait CompareVec3EntityTrait: EntityTrait {
}

impl CompareVec3EntityTrait for CompareVec3Entity {
}

impl EntityTrait for CompareVec3Entity {
}

impl EntityBusPeerTrait for CompareVec3Entity {
}

pub static COMPAREVEC3ENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareVec3Entity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareVec3Entity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(COMPAREVEC3ENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for CompareVec3Entity {
    fn type_info(&self) -> &'static TypeInfo {
        COMPAREVEC3ENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static COMPAREVEC3ENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareVec3Entity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareVec3Entity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CompareFloatRangeEntity {
    pub _glacier_base: Entity,
}

pub trait CompareFloatRangeEntityTrait: EntityTrait {
}

impl CompareFloatRangeEntityTrait for CompareFloatRangeEntity {
}

impl EntityTrait for CompareFloatRangeEntity {
}

impl EntityBusPeerTrait for CompareFloatRangeEntity {
}

pub static COMPAREFLOATRANGEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareFloatRangeEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareFloatRangeEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(COMPAREFLOATRANGEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for CompareFloatRangeEntity {
    fn type_info(&self) -> &'static TypeInfo {
        COMPAREFLOATRANGEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static COMPAREFLOATRANGEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareFloatRangeEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareFloatRangeEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CompareStringEntity {
    pub _glacier_base: Entity,
}

pub trait CompareStringEntityTrait: EntityTrait {
}

impl CompareStringEntityTrait for CompareStringEntity {
}

impl EntityTrait for CompareStringEntity {
}

impl EntityBusPeerTrait for CompareStringEntity {
}

pub static COMPARESTRINGENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareStringEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareStringEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(COMPARESTRINGENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for CompareStringEntity {
    fn type_info(&self) -> &'static TypeInfo {
        COMPARESTRINGENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static COMPARESTRINGENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareStringEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareStringEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CompareFloatEntity {
    pub _glacier_base: Entity,
}

pub trait CompareFloatEntityTrait: EntityTrait {
}

impl CompareFloatEntityTrait for CompareFloatEntity {
}

impl EntityTrait for CompareFloatEntity {
}

impl EntityBusPeerTrait for CompareFloatEntity {
}

pub static COMPAREFLOATENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareFloatEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareFloatEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(COMPAREFLOATENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for CompareFloatEntity {
    fn type_info(&self) -> &'static TypeInfo {
        COMPAREFLOATENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static COMPAREFLOATENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareFloatEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareFloatEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CompareUintEntity {
    pub _glacier_base: Entity,
}

pub trait CompareUintEntityTrait: EntityTrait {
}

impl CompareUintEntityTrait for CompareUintEntity {
}

impl EntityTrait for CompareUintEntity {
}

impl EntityBusPeerTrait for CompareUintEntity {
}

pub static COMPAREUINTENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareUintEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareUintEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(COMPAREUINTENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for CompareUintEntity {
    fn type_info(&self) -> &'static TypeInfo {
        COMPAREUINTENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static COMPAREUINTENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareUintEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareUintEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CompareIntEntity {
    pub _glacier_base: Entity,
}

pub trait CompareIntEntityTrait: EntityTrait {
}

impl CompareIntEntityTrait for CompareIntEntity {
}

impl EntityTrait for CompareIntEntity {
}

impl EntityBusPeerTrait for CompareIntEntity {
}

pub static COMPAREINTENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareIntEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareIntEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(COMPAREINTENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for CompareIntEntity {
    fn type_info(&self) -> &'static TypeInfo {
        COMPAREINTENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static COMPAREINTENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareIntEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareIntEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CompareBoolEntity {
    pub _glacier_base: Entity,
}

pub trait CompareBoolEntityTrait: EntityTrait {
}

impl CompareBoolEntityTrait for CompareBoolEntity {
}

impl EntityTrait for CompareBoolEntity {
}

impl EntityBusPeerTrait for CompareBoolEntity {
}

pub static COMPAREBOOLENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareBoolEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareBoolEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(COMPAREBOOLENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for CompareBoolEntity {
    fn type_info(&self) -> &'static TypeInfo {
        COMPAREBOOLENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static COMPAREBOOLENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareBoolEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareBoolEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ServerDilationEntity {
    pub _glacier_base: Entity,
}

pub trait ServerDilationEntityTrait: EntityTrait {
}

impl ServerDilationEntityTrait for ServerDilationEntity {
}

impl EntityTrait for ServerDilationEntity {
}

impl EntityBusPeerTrait for ServerDilationEntity {
}

pub static SERVERDILATIONENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ServerDilationEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ServerDilationEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SERVERDILATIONENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ServerDilationEntity {
    fn type_info(&self) -> &'static TypeInfo {
        SERVERDILATIONENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SERVERDILATIONENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ServerDilationEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ServerDilationEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ClientBalancedDilationEntity {
    pub _glacier_base: Entity,
}

pub trait ClientBalancedDilationEntityTrait: EntityTrait {
}

impl ClientBalancedDilationEntityTrait for ClientBalancedDilationEntity {
}

impl EntityTrait for ClientBalancedDilationEntity {
}

impl EntityBusPeerTrait for ClientBalancedDilationEntity {
}

pub static CLIENTBALANCEDDILATIONENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClientBalancedDilationEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ClientBalancedDilationEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(CLIENTBALANCEDDILATIONENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ClientBalancedDilationEntity {
    fn type_info(&self) -> &'static TypeInfo {
        CLIENTBALANCEDDILATIONENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CLIENTBALANCEDDILATIONENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClientBalancedDilationEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ClientBalancedDilationEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AnimTrackData {
}

pub trait AnimTrackDataTrait: TypeObject {
}

impl AnimTrackDataTrait for AnimTrackData {
}

pub static ANIMTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimTrackData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: None,
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AnimTrackData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(ANIMTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for AnimTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        ANIMTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ANIMTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("AnimTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SequenceEntity {
    pub _glacier_base: Entity,
}

pub trait SequenceEntityTrait: EntityTrait {
}

impl SequenceEntityTrait for SequenceEntity {
}

impl EntityTrait for SequenceEntity {
}

impl EntityBusPeerTrait for SequenceEntity {
}

pub static SEQUENCEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SequenceEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SequenceEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SEQUENCEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SequenceEntity {
    fn type_info(&self) -> &'static TypeInfo {
        SEQUENCEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SEQUENCEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SequenceEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SequenceEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct StringBuilderEntity {
    pub _glacier_base: Entity,
}

pub trait StringBuilderEntityTrait: EntityTrait {
}

impl StringBuilderEntityTrait for StringBuilderEntity {
}

impl EntityTrait for StringBuilderEntity {
}

impl EntityBusPeerTrait for StringBuilderEntity {
}

pub static STRINGBUILDERENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StringBuilderEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StringBuilderEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(STRINGBUILDERENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for StringBuilderEntity {
    fn type_info(&self) -> &'static TypeInfo {
        STRINGBUILDERENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static STRINGBUILDERENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StringBuilderEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("StringBuilderEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Vec4ChangedEntity {
    pub _glacier_base: Entity,
}

pub trait Vec4ChangedEntityTrait: EntityTrait {
}

impl Vec4ChangedEntityTrait for Vec4ChangedEntity {
}

impl EntityTrait for Vec4ChangedEntity {
}

impl EntityBusPeerTrait for Vec4ChangedEntity {
}

pub static VEC4CHANGEDENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec4ChangedEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec4ChangedEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(VEC4CHANGEDENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for Vec4ChangedEntity {
    fn type_info(&self) -> &'static TypeInfo {
        VEC4CHANGEDENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VEC4CHANGEDENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec4ChangedEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec4ChangedEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Vec3ChangedEntity {
    pub _glacier_base: Entity,
}

pub trait Vec3ChangedEntityTrait: EntityTrait {
}

impl Vec3ChangedEntityTrait for Vec3ChangedEntity {
}

impl EntityTrait for Vec3ChangedEntity {
}

impl EntityBusPeerTrait for Vec3ChangedEntity {
}

pub static VEC3CHANGEDENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3ChangedEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec3ChangedEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(VEC3CHANGEDENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for Vec3ChangedEntity {
    fn type_info(&self) -> &'static TypeInfo {
        VEC3CHANGEDENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VEC3CHANGEDENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3ChangedEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec3ChangedEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Vec2ChangedEntity {
    pub _glacier_base: Entity,
}

pub trait Vec2ChangedEntityTrait: EntityTrait {
}

impl Vec2ChangedEntityTrait for Vec2ChangedEntity {
}

impl EntityTrait for Vec2ChangedEntity {
}

impl EntityBusPeerTrait for Vec2ChangedEntity {
}

pub static VEC2CHANGEDENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec2ChangedEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec2ChangedEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(VEC2CHANGEDENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for Vec2ChangedEntity {
    fn type_info(&self) -> &'static TypeInfo {
        VEC2CHANGEDENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VEC2CHANGEDENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec2ChangedEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec2ChangedEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct IntChangedEntity {
    pub _glacier_base: Entity,
}

pub trait IntChangedEntityTrait: EntityTrait {
}

impl IntChangedEntityTrait for IntChangedEntity {
}

impl EntityTrait for IntChangedEntity {
}

impl EntityBusPeerTrait for IntChangedEntity {
}

pub static INTCHANGEDENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntChangedEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<IntChangedEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(INTCHANGEDENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for IntChangedEntity {
    fn type_info(&self) -> &'static TypeInfo {
        INTCHANGEDENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static INTCHANGEDENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntChangedEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("IntChangedEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FloatChangedEntity {
    pub _glacier_base: Entity,
}

pub trait FloatChangedEntityTrait: EntityTrait {
}

impl FloatChangedEntityTrait for FloatChangedEntity {
}

impl EntityTrait for FloatChangedEntity {
}

impl EntityBusPeerTrait for FloatChangedEntity {
}

pub static FLOATCHANGEDENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatChangedEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FloatChangedEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(FLOATCHANGEDENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for FloatChangedEntity {
    fn type_info(&self) -> &'static TypeInfo {
        FLOATCHANGEDENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static FLOATCHANGEDENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatChangedEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("FloatChangedEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BoolChangedEntity {
    pub _glacier_base: Entity,
}

pub trait BoolChangedEntityTrait: EntityTrait {
}

impl BoolChangedEntityTrait for BoolChangedEntity {
}

impl EntityTrait for BoolChangedEntity {
}

impl EntityBusPeerTrait for BoolChangedEntity {
}

pub static BOOLCHANGEDENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolChangedEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BoolChangedEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(BOOLCHANGEDENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for BoolChangedEntity {
    fn type_info(&self) -> &'static TypeInfo {
        BOOLCHANGEDENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static BOOLCHANGEDENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolChangedEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("BoolChangedEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CompareTransformEntity {
    pub _glacier_base: Entity,
}

pub trait CompareTransformEntityTrait: EntityTrait {
}

impl CompareTransformEntityTrait for CompareTransformEntity {
}

impl EntityTrait for CompareTransformEntity {
}

impl EntityBusPeerTrait for CompareTransformEntity {
}

pub static COMPARETRANSFORMENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareTransformEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareTransformEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(COMPARETRANSFORMENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for CompareTransformEntity {
    fn type_info(&self) -> &'static TypeInfo {
        COMPARETRANSFORMENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static COMPARETRANSFORMENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareTransformEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareTransformEntity"),
    array_type: None,
    alignment: 8,
};



pub static GETSCHEMATICSINSTANCE_SCHEMATICSINSTANCE_ENTITY__TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GetSchematicsInstance(SchematicsInstance,Entity)",
    flags: MemberInfoFlags::new(793),
    module: "Entity",
    data: TypeInfoData::Unknown,
    array_type: None,
    alignment: 8,
};



pub static GETSCHEMATICSINSTANCE_SCHEMATICSINSTANCE_ENTITYBUS__TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GetSchematicsInstance(SchematicsInstance,EntityBus)",
    flags: MemberInfoFlags::new(793),
    module: "Entity",
    data: TypeInfoData::Unknown,
    array_type: None,
    alignment: 8,
};



pub static DESTROYENTITY_ENTITY__TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DestroyEntity(Entity)",
    flags: MemberInfoFlags::new(793),
    module: "Entity",
    data: TypeInfoData::Unknown,
    array_type: None,
    alignment: 8,
};



pub static CREATEENTITY_ENTITY_ENTITYBUS_OBJECTBLUEPRINT_LINEARTRANSFORM__TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CreateEntity(Entity,EntityBus,ObjectBlueprint,LinearTransform)",
    flags: MemberInfoFlags::new(793),
    module: "Entity",
    data: TypeInfoData::Unknown,
    array_type: None,
    alignment: 8,
};



pub static CASTTOSPATIAL_SPATIALENTITY_ENTITY__TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CastToSpatial(SpatialEntity,Entity)",
    flags: MemberInfoFlags::new(793),
    module: "Entity",
    data: TypeInfoData::Unknown,
    array_type: None,
    alignment: 8,
};



pub static GETTRANSFORM_SPATIALENTITY_LINEARTRANSFORM__TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GetTransform(SpatialEntity,LinearTransform)",
    flags: MemberInfoFlags::new(793),
    module: "Entity",
    data: TypeInfoData::Unknown,
    array_type: None,
    alignment: 8,
};



pub static SETTRANSFORM_SPATIALENTITY_LINEARTRANSFORM__TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SetTransform(SpatialEntity,LinearTransform)",
    flags: MemberInfoFlags::new(793),
    module: "Entity",
    data: TypeInfoData::Unknown,
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum UpdatePassMask {
    #[default]
    EmptyUpdateMask = 0,
    PrePhysicsUpdateMask = 1,
    PostPhysicsUpdateMask = 2,
    PreAnimationUpdateMask = 4,
    PostAnimationUpdateMask = 8,
    PostFrameUpdateMask = 16,
    UpdatePassMaskCount = 5,
}

pub static UPDATEPASSMASK_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UpdatePassMask",
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(UPDATEPASSMASK_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for UpdatePassMask {
    fn type_info(&self) -> &'static TypeInfo {
        UPDATEPASSMASK_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static UPDATEPASSMASK_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UpdatePassMask-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("UpdatePassMask"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum UpdatePass {
    #[default]
    UpdatePass_PreSim = 0,
    UpdatePass_PostSim = 1,
    UpdatePass_PostFrame = 2,
    UpdatePass_PreInput = 3,
    UpdatePass_PreFrame = 4,
    UpdatePass_PreAnimation = 5,
    UpdatePass_PostAnimation = 6,
    UpdatePass_Count = 9,
}

pub static UPDATEPASS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UpdatePass",
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(UPDATEPASS_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for UpdatePass {
    fn type_info(&self) -> &'static TypeInfo {
        UPDATEPASS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static UPDATEPASS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UpdatePass-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("UpdatePass"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GameDataContainerAsset {
    pub _glacier_base: super::core::Asset,
    pub data: Option<Arc<Mutex<dyn super::core::GameDataContainerTrait>>>,
}

pub trait GameDataContainerAssetTrait: super::core::AssetTrait {
    fn data(&self) -> &Option<Arc<Mutex<dyn super::core::GameDataContainerTrait>>>;
}

impl GameDataContainerAssetTrait for GameDataContainerAsset {
    fn data(&self) -> &Option<Arc<Mutex<dyn super::core::GameDataContainerTrait>>> {
        &self.data
    }
}

impl super::core::AssetTrait for GameDataContainerAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for GameDataContainerAsset {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static GAMEDATACONTAINERASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameDataContainerAsset",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GameDataContainerAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Data",
                flags: MemberInfoFlags::new(0),
                field_type: "GameDataContainer",
                rust_offset: offset_of!(GameDataContainerAsset, data),
            },
        ],
    }),
    array_type: Some(GAMEDATACONTAINERASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for GameDataContainerAsset {
    fn type_info(&self) -> &'static TypeInfo {
        GAMEDATACONTAINERASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static GAMEDATACONTAINERASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameDataContainerAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("GameDataContainerAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DataContainerAsset {
    pub _glacier_base: super::core::Asset,
    pub data: Option<Arc<Mutex<dyn super::core::DataContainerTrait>>>,
}

pub trait DataContainerAssetTrait: super::core::AssetTrait {
    fn data(&self) -> &Option<Arc<Mutex<dyn super::core::DataContainerTrait>>>;
}

impl DataContainerAssetTrait for DataContainerAsset {
    fn data(&self) -> &Option<Arc<Mutex<dyn super::core::DataContainerTrait>>> {
        &self.data
    }
}

impl super::core::AssetTrait for DataContainerAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for DataContainerAsset {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static DATACONTAINERASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DataContainerAsset",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DataContainerAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Data",
                flags: MemberInfoFlags::new(0),
                field_type: "DataContainer",
                rust_offset: offset_of!(DataContainerAsset, data),
            },
        ],
    }),
    array_type: Some(DATACONTAINERASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DataContainerAsset {
    fn type_info(&self) -> &'static TypeInfo {
        DATACONTAINERASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static DATACONTAINERASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DataContainerAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("DataContainerAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct StaticInstancingData {
    pub transforms: Vec<super::core::LinearTransform>,
    pub mesh_ids: Vec<i32>,
}

pub trait StaticInstancingDataTrait: TypeObject {
    fn transforms(&self) -> &Vec<super::core::LinearTransform>;
    fn mesh_ids(&self) -> &Vec<i32>;
}

impl StaticInstancingDataTrait for StaticInstancingData {
    fn transforms(&self) -> &Vec<super::core::LinearTransform> {
        &self.transforms
    }
    fn mesh_ids(&self) -> &Vec<i32> {
        &self.mesh_ids
    }
}

pub static STATICINSTANCINGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StaticInstancingData",
    flags: MemberInfoFlags::new(73),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StaticInstancingData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Transforms",
                flags: MemberInfoFlags::new(144),
                field_type: "LinearTransform-Array",
                rust_offset: offset_of!(StaticInstancingData, transforms),
            },
            FieldInfoData {
                name: "MeshIds",
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(StaticInstancingData, mesh_ids),
            },
        ],
    }),
    array_type: Some(STATICINSTANCINGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for StaticInstancingData {
    fn type_info(&self) -> &'static TypeInfo {
        STATICINSTANCINGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static STATICINSTANCINGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StaticInstancingData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("StaticInstancingData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PartData {
    pub _glacier_base: ComponentData,
    pub part_states: Vec<Option<Arc<Mutex<dyn PartStateTrait>>>>,
}

pub trait PartDataTrait: ComponentDataTrait {
    fn part_states(&self) -> &Vec<Option<Arc<Mutex<dyn PartStateTrait>>>>;
}

impl PartDataTrait for PartData {
    fn part_states(&self) -> &Vec<Option<Arc<Mutex<dyn PartStateTrait>>>> {
        &self.part_states
    }
}

impl ComponentDataTrait for PartData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
}

impl GameObjectDataTrait for PartData {
}

impl super::core::DataBusPeerTrait for PartData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for PartData {
}

impl super::core::DataContainerTrait for PartData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PARTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PartData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(COMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PartData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PartStates",
                flags: MemberInfoFlags::new(144),
                field_type: "PartState-Array",
                rust_offset: offset_of!(PartData, part_states),
            },
        ],
    }),
    array_type: Some(PARTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PartData {
    fn type_info(&self) -> &'static TypeInfo {
        PARTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PARTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PartData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("PartData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PartState {
    pub _glacier_base: GameObjectData,
    pub part_index: u32,
    pub objects: Vec<Option<Arc<Mutex<dyn GameObjectDataTrait>>>>,
}

pub trait PartStateTrait: GameObjectDataTrait {
    fn part_index(&self) -> &u32;
    fn objects(&self) -> &Vec<Option<Arc<Mutex<dyn GameObjectDataTrait>>>>;
}

impl PartStateTrait for PartState {
    fn part_index(&self) -> &u32 {
        &self.part_index
    }
    fn objects(&self) -> &Vec<Option<Arc<Mutex<dyn GameObjectDataTrait>>>> {
        &self.objects
    }
}

impl GameObjectDataTrait for PartState {
}

impl super::core::DataBusPeerTrait for PartState {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for PartState {
}

impl super::core::DataContainerTrait for PartState {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PARTSTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PartState",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(GAMEOBJECTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PartState as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PartIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(PartState, part_index),
            },
            FieldInfoData {
                name: "Objects",
                flags: MemberInfoFlags::new(144),
                field_type: "GameObjectData-Array",
                rust_offset: offset_of!(PartState, objects),
            },
        ],
    }),
    array_type: Some(PARTSTATE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PartState {
    fn type_info(&self) -> &'static TypeInfo {
        PARTSTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PARTSTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PartState-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("PartState"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BoneComponentData {
    pub _glacier_base: GameComponentData,
}

pub trait BoneComponentDataTrait: GameComponentDataTrait {
}

impl BoneComponentDataTrait for BoneComponentData {
}

impl GameComponentDataTrait for BoneComponentData {
}

impl ComponentDataTrait for BoneComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
}

impl GameObjectDataTrait for BoneComponentData {
}

impl super::core::DataBusPeerTrait for BoneComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for BoneComponentData {
}

impl super::core::DataContainerTrait for BoneComponentData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static BONECOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoneComponentData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BoneComponentData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(BONECOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for BoneComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        BONECOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static BONECOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoneComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("BoneComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GameComponentData {
    pub _glacier_base: ComponentData,
}

pub trait GameComponentDataTrait: ComponentDataTrait {
}

impl GameComponentDataTrait for GameComponentData {
}

impl ComponentDataTrait for GameComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
}

impl GameObjectDataTrait for GameComponentData {
}

impl super::core::DataBusPeerTrait for GameComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for GameComponentData {
}

impl super::core::DataContainerTrait for GameComponentData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static GAMECOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameComponentData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(COMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GameComponentData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(GAMECOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for GameComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        GAMECOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static GAMECOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("GameComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ComponentData {
    pub _glacier_base: GameObjectData,
    pub transform: super::core::LinearTransform,
    pub components: Vec<Option<Arc<Mutex<dyn GameObjectDataTrait>>>>,
    pub client_index: u8,
    pub server_index: u8,
    pub excluded: bool,
}

pub trait ComponentDataTrait: GameObjectDataTrait {
    fn transform(&self) -> &super::core::LinearTransform;
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn GameObjectDataTrait>>>>;
    fn client_index(&self) -> &u8;
    fn server_index(&self) -> &u8;
    fn excluded(&self) -> &bool;
}

impl ComponentDataTrait for ComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        &self.transform
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn GameObjectDataTrait>>>> {
        &self.components
    }
    fn client_index(&self) -> &u8 {
        &self.client_index
    }
    fn server_index(&self) -> &u8 {
        &self.server_index
    }
    fn excluded(&self) -> &bool {
        &self.excluded
    }
}

impl GameObjectDataTrait for ComponentData {
}

impl super::core::DataBusPeerTrait for ComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for ComponentData {
}

impl super::core::DataContainerTrait for ComponentData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static COMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ComponentData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(GAMEOBJECTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Transform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(ComponentData, transform),
            },
            FieldInfoData {
                name: "Components",
                flags: MemberInfoFlags::new(144),
                field_type: "GameObjectData-Array",
                rust_offset: offset_of!(ComponentData, components),
            },
            FieldInfoData {
                name: "ClientIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(ComponentData, client_index),
            },
            FieldInfoData {
                name: "ServerIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(ComponentData, server_index),
            },
            FieldInfoData {
                name: "Excluded",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ComponentData, excluded),
            },
        ],
    }),
    array_type: Some(COMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        COMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static COMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GameComponentEntityData {
    pub _glacier_base: ComponentEntityData,
    pub enabled: bool,
}

pub trait GameComponentEntityDataTrait: ComponentEntityDataTrait {
    fn enabled(&self) -> &bool;
}

impl GameComponentEntityDataTrait for GameComponentEntityData {
    fn enabled(&self) -> &bool {
        &self.enabled
    }
}

impl ComponentEntityDataTrait for GameComponentEntityData {
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn part_bounding_boxes(&self) -> &Vec<super::core::AxisAlignedBox> {
        self._glacier_base.part_bounding_boxes()
    }
    fn client_runtime_component_count(&self) -> &u8 {
        self._glacier_base.client_runtime_component_count()
    }
    fn server_runtime_component_count(&self) -> &u8 {
        self._glacier_base.server_runtime_component_count()
    }
    fn client_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.client_runtime_transformation_count()
    }
    fn server_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.server_runtime_transformation_count()
    }
}

impl SpatialEntityDataTrait for GameComponentEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
}

impl EntityDataTrait for GameComponentEntityData {
}

impl GameObjectDataTrait for GameComponentEntityData {
}

impl super::core::DataBusPeerTrait for GameComponentEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for GameComponentEntityData {
}

impl super::core::DataContainerTrait for GameComponentEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static GAMECOMPONENTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameComponentEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(COMPONENTENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GameComponentEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(GameComponentEntityData, enabled),
            },
        ],
    }),
    array_type: Some(GAMECOMPONENTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for GameComponentEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        GAMECOMPONENTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static GAMECOMPONENTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameComponentEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("GameComponentEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ComponentEntityData {
    pub _glacier_base: SpatialEntityData,
    pub components: Vec<Option<Arc<Mutex<dyn GameObjectDataTrait>>>>,
    pub part_bounding_boxes: Vec<super::core::AxisAlignedBox>,
    pub client_runtime_component_count: u8,
    pub server_runtime_component_count: u8,
    pub client_runtime_transformation_count: u8,
    pub server_runtime_transformation_count: u8,
}

pub trait ComponentEntityDataTrait: SpatialEntityDataTrait {
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn GameObjectDataTrait>>>>;
    fn part_bounding_boxes(&self) -> &Vec<super::core::AxisAlignedBox>;
    fn client_runtime_component_count(&self) -> &u8;
    fn server_runtime_component_count(&self) -> &u8;
    fn client_runtime_transformation_count(&self) -> &u8;
    fn server_runtime_transformation_count(&self) -> &u8;
}

impl ComponentEntityDataTrait for ComponentEntityData {
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn GameObjectDataTrait>>>> {
        &self.components
    }
    fn part_bounding_boxes(&self) -> &Vec<super::core::AxisAlignedBox> {
        &self.part_bounding_boxes
    }
    fn client_runtime_component_count(&self) -> &u8 {
        &self.client_runtime_component_count
    }
    fn server_runtime_component_count(&self) -> &u8 {
        &self.server_runtime_component_count
    }
    fn client_runtime_transformation_count(&self) -> &u8 {
        &self.client_runtime_transformation_count
    }
    fn server_runtime_transformation_count(&self) -> &u8 {
        &self.server_runtime_transformation_count
    }
}

impl SpatialEntityDataTrait for ComponentEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
}

impl EntityDataTrait for ComponentEntityData {
}

impl GameObjectDataTrait for ComponentEntityData {
}

impl super::core::DataBusPeerTrait for ComponentEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for ComponentEntityData {
}

impl super::core::DataContainerTrait for ComponentEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static COMPONENTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ComponentEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SPATIALENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ComponentEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Components",
                flags: MemberInfoFlags::new(144),
                field_type: "GameObjectData-Array",
                rust_offset: offset_of!(ComponentEntityData, components),
            },
            FieldInfoData {
                name: "PartBoundingBoxes",
                flags: MemberInfoFlags::new(144),
                field_type: "AxisAlignedBox-Array",
                rust_offset: offset_of!(ComponentEntityData, part_bounding_boxes),
            },
            FieldInfoData {
                name: "ClientRuntimeComponentCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(ComponentEntityData, client_runtime_component_count),
            },
            FieldInfoData {
                name: "ServerRuntimeComponentCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(ComponentEntityData, server_runtime_component_count),
            },
            FieldInfoData {
                name: "ClientRuntimeTransformationCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(ComponentEntityData, client_runtime_transformation_count),
            },
            FieldInfoData {
                name: "ServerRuntimeTransformationCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(ComponentEntityData, server_runtime_transformation_count),
            },
        ],
    }),
    array_type: Some(COMPONENTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ComponentEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        COMPONENTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static COMPONENTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ComponentEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ComponentEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ScriptEntityData {
    pub _glacier_base: EntityData,
    pub code: String,
    pub realm: super::core::Realm,
}

pub trait ScriptEntityDataTrait: EntityDataTrait {
    fn code(&self) -> &String;
    fn realm(&self) -> &super::core::Realm;
}

impl ScriptEntityDataTrait for ScriptEntityData {
    fn code(&self) -> &String {
        &self.code
    }
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
}

impl EntityDataTrait for ScriptEntityData {
}

impl GameObjectDataTrait for ScriptEntityData {
}

impl super::core::DataBusPeerTrait for ScriptEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for ScriptEntityData {
}

impl super::core::DataContainerTrait for ScriptEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SCRIPTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScriptEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ScriptEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Code",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ScriptEntityData, code),
            },
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(ScriptEntityData, realm),
            },
        ],
    }),
    array_type: Some(SCRIPTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ScriptEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SCRIPTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SCRIPTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScriptEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ScriptEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SpatialEntityData {
    pub _glacier_base: EntityData,
    pub transform: super::core::LinearTransform,
}

pub trait SpatialEntityDataTrait: EntityDataTrait {
    fn transform(&self) -> &super::core::LinearTransform;
}

impl SpatialEntityDataTrait for SpatialEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        &self.transform
    }
}

impl EntityDataTrait for SpatialEntityData {
}

impl GameObjectDataTrait for SpatialEntityData {
}

impl super::core::DataBusPeerTrait for SpatialEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for SpatialEntityData {
}

impl super::core::DataContainerTrait for SpatialEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SPATIALENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpatialEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SpatialEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Transform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(SpatialEntityData, transform),
            },
        ],
    }),
    array_type: Some(SPATIALENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SpatialEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SPATIALENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SPATIALENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpatialEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SpatialEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EntityData {
    pub _glacier_base: GameObjectData,
}

pub trait EntityDataTrait: GameObjectDataTrait {
}

impl EntityDataTrait for EntityData {
}

impl GameObjectDataTrait for EntityData {
}

impl super::core::DataBusPeerTrait for EntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for EntityData {
}

impl super::core::DataContainerTrait for EntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static ENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(GAMEOBJECTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(ENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EntityData {
    fn type_info(&self) -> &'static TypeInfo {
        ENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum EntityCreatorType {
    #[default]
    EntityCreatorType_Unknown = 0,
    EntityCreatorType_Level = 1,
    EntityCreatorType_Spawner = 2,
    EntityCreatorType_Owner = 3,
    EntityCreatorType_Ghost = 4,
}

pub static ENTITYCREATORTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityCreatorType",
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(ENTITYCREATORTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for EntityCreatorType {
    fn type_info(&self) -> &'static TypeInfo {
        ENTITYCREATORTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ENTITYCREATORTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityCreatorType-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EntityCreatorType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GameObjectData {
    pub _glacier_base: super::core::DataBusPeer,
}

pub trait GameObjectDataTrait: super::core::DataBusPeerTrait {
}

impl GameObjectDataTrait for GameObjectData {
}

impl super::core::DataBusPeerTrait for GameObjectData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for GameObjectData {
}

impl super::core::DataContainerTrait for GameObjectData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static GAMEOBJECTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameObjectData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATABUSPEER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GameObjectData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(GAMEOBJECTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for GameObjectData {
    fn type_info(&self) -> &'static TypeInfo {
        GAMEOBJECTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static GAMEOBJECTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameObjectData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("GameObjectData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum SubRealm {
    #[default]
    SubRealm_All = 0,
    SubRealm_LocalPlayer = 1,
    SubRealm_RemotePlayer = 2,
}

pub static SUBREALM_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubRealm",
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(SUBREALM_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SubRealm {
    fn type_info(&self) -> &'static TypeInfo {
        SUBREALM_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SUBREALM_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubRealm-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SubRealm"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum TimeShape {
    #[default]
    TimeShape_Step = 0,
    TimeShape_Sine = 1,
    TimeShape_SemiCircle = 2,
    TimeShape_Triangle = 3,
    TimeShape_Ramps = 4,
}

pub static TIMESHAPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TimeShape",
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(TIMESHAPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for TimeShape {
    fn type_info(&self) -> &'static TypeInfo {
        TIMESHAPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static TIMESHAPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TimeShape-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TimeShape"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum DilationPriority {
    #[default]
    DilationPriority_Highest = 0,
    DilationPriority_High = 1,
    DilationPriority_Normal = 2,
    DilationPriority_Low = 3,
    DilationPriority_Lowest = 4,
}

pub static DILATIONPRIORITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DilationPriority",
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(DILATIONPRIORITY_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for DilationPriority {
    fn type_info(&self) -> &'static TypeInfo {
        DILATIONPRIORITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static DILATIONPRIORITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DilationPriority-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("DilationPriority"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum TimeDeltaType {
    #[default]
    TimeDeltaType_None = 0,
    TimeDeltaType_Player = 1,
    TimeDeltaType_World = 2,
    TimeDeltaType_Extra1 = 3,
    TimeDeltaType_Extra2 = 4,
    TimeDeltaType_Extra3 = 5,
    TimeDeltaType_Extra4 = 6,
    TimeDeltaType_Extra5 = 7,
    TimeDeltaType_Count = 8,
}

pub static TIMEDELTATYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TimeDeltaType",
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(TIMEDELTATYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for TimeDeltaType {
    fn type_info(&self) -> &'static TypeInfo {
        TIMEDELTATYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static TIMEDELTATYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TimeDeltaType-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TimeDeltaType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SchematicChannelEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub channel: Option<Arc<Mutex<dyn SchematicChannelAssetTrait>>>,
    pub input_properties: Vec<i32>,
    pub input_ref_properties: Vec<i32>,
    pub output_properties: Vec<i32>,
    pub output_ref_properties: Vec<i32>,
}

pub trait SchematicChannelEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn channel(&self) -> &Option<Arc<Mutex<dyn SchematicChannelAssetTrait>>>;
    fn input_properties(&self) -> &Vec<i32>;
    fn input_ref_properties(&self) -> &Vec<i32>;
    fn output_properties(&self) -> &Vec<i32>;
    fn output_ref_properties(&self) -> &Vec<i32>;
}

impl SchematicChannelEntityDataTrait for SchematicChannelEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn channel(&self) -> &Option<Arc<Mutex<dyn SchematicChannelAssetTrait>>> {
        &self.channel
    }
    fn input_properties(&self) -> &Vec<i32> {
        &self.input_properties
    }
    fn input_ref_properties(&self) -> &Vec<i32> {
        &self.input_ref_properties
    }
    fn output_properties(&self) -> &Vec<i32> {
        &self.output_properties
    }
    fn output_ref_properties(&self) -> &Vec<i32> {
        &self.output_ref_properties
    }
}

impl EntityDataTrait for SchematicChannelEntityData {
}

impl GameObjectDataTrait for SchematicChannelEntityData {
}

impl super::core::DataBusPeerTrait for SchematicChannelEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for SchematicChannelEntityData {
}

impl super::core::DataContainerTrait for SchematicChannelEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SCHEMATICCHANNELENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SchematicChannelEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SchematicChannelEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(SchematicChannelEntityData, realm),
            },
            FieldInfoData {
                name: "Channel",
                flags: MemberInfoFlags::new(0),
                field_type: "SchematicChannelAsset",
                rust_offset: offset_of!(SchematicChannelEntityData, channel),
            },
            FieldInfoData {
                name: "InputProperties",
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(SchematicChannelEntityData, input_properties),
            },
            FieldInfoData {
                name: "InputRefProperties",
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(SchematicChannelEntityData, input_ref_properties),
            },
            FieldInfoData {
                name: "OutputProperties",
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(SchematicChannelEntityData, output_properties),
            },
            FieldInfoData {
                name: "OutputRefProperties",
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(SchematicChannelEntityData, output_ref_properties),
            },
        ],
    }),
    array_type: Some(SCHEMATICCHANNELENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SchematicChannelEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SCHEMATICCHANNELENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SCHEMATICCHANNELENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SchematicChannelEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SchematicChannelEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SchematicChannelAsset {
    pub _glacier_base: super::core::Asset,
    pub events: Vec<EventChannel>,
    pub links: Vec<LinkChannel>,
    pub properties: Vec<PropertyChannel>,
}

pub trait SchematicChannelAssetTrait: super::core::AssetTrait {
    fn events(&self) -> &Vec<EventChannel>;
    fn links(&self) -> &Vec<LinkChannel>;
    fn properties(&self) -> &Vec<PropertyChannel>;
}

impl SchematicChannelAssetTrait for SchematicChannelAsset {
    fn events(&self) -> &Vec<EventChannel> {
        &self.events
    }
    fn links(&self) -> &Vec<LinkChannel> {
        &self.links
    }
    fn properties(&self) -> &Vec<PropertyChannel> {
        &self.properties
    }
}

impl super::core::AssetTrait for SchematicChannelAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for SchematicChannelAsset {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SCHEMATICCHANNELASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SchematicChannelAsset",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SchematicChannelAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Events",
                flags: MemberInfoFlags::new(144),
                field_type: "EventChannel-Array",
                rust_offset: offset_of!(SchematicChannelAsset, events),
            },
            FieldInfoData {
                name: "Links",
                flags: MemberInfoFlags::new(144),
                field_type: "LinkChannel-Array",
                rust_offset: offset_of!(SchematicChannelAsset, links),
            },
            FieldInfoData {
                name: "Properties",
                flags: MemberInfoFlags::new(144),
                field_type: "PropertyChannel-Array",
                rust_offset: offset_of!(SchematicChannelAsset, properties),
            },
        ],
    }),
    array_type: Some(SCHEMATICCHANNELASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SchematicChannelAsset {
    fn type_info(&self) -> &'static TypeInfo {
        SCHEMATICCHANNELASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SCHEMATICCHANNELASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SchematicChannelAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SchematicChannelAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PropertyChannel {
    pub realm: super::core::Realm,
    pub id: i32,
    pub field_type_hash: i32,
}

pub trait PropertyChannelTrait: TypeObject {
    fn realm(&self) -> &super::core::Realm;
    fn id(&self) -> &i32;
    fn field_type_hash(&self) -> &i32;
}

impl PropertyChannelTrait for PropertyChannel {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn id(&self) -> &i32 {
        &self.id
    }
    fn field_type_hash(&self) -> &i32 {
        &self.field_type_hash
    }
}

pub static PROPERTYCHANNEL_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PropertyChannel",
    flags: MemberInfoFlags::new(32841),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PropertyChannel as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(PropertyChannel, realm),
            },
            FieldInfoData {
                name: "Id",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(PropertyChannel, id),
            },
            FieldInfoData {
                name: "FieldTypeHash",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(PropertyChannel, field_type_hash),
            },
        ],
    }),
    array_type: Some(PROPERTYCHANNEL_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for PropertyChannel {
    fn type_info(&self) -> &'static TypeInfo {
        PROPERTYCHANNEL_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PROPERTYCHANNEL_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PropertyChannel-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("PropertyChannel"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EventChannel {
    pub realm: super::core::Realm,
}

pub trait EventChannelTrait: TypeObject {
    fn realm(&self) -> &super::core::Realm;
}

impl EventChannelTrait for EventChannel {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
}

pub static EVENTCHANNEL_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventChannel",
    flags: MemberInfoFlags::new(32841),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EventChannel as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(EventChannel, realm),
            },
        ],
    }),
    array_type: Some(EVENTCHANNEL_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for EventChannel {
    fn type_info(&self) -> &'static TypeInfo {
        EVENTCHANNEL_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static EVENTCHANNEL_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventChannel-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EventChannel"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LinkChannel {
    pub realm: super::core::Realm,
    pub id: i32,
    pub link_type_hash: i32,
}

pub trait LinkChannelTrait: TypeObject {
    fn realm(&self) -> &super::core::Realm;
    fn id(&self) -> &i32;
    fn link_type_hash(&self) -> &i32;
}

impl LinkChannelTrait for LinkChannel {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn id(&self) -> &i32 {
        &self.id
    }
    fn link_type_hash(&self) -> &i32 {
        &self.link_type_hash
    }
}

pub static LINKCHANNEL_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkChannel",
    flags: MemberInfoFlags::new(32841),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LinkChannel as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(LinkChannel, realm),
            },
            FieldInfoData {
                name: "Id",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(LinkChannel, id),
            },
            FieldInfoData {
                name: "LinkTypeHash",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(LinkChannel, link_type_hash),
            },
        ],
    }),
    array_type: Some(LINKCHANNEL_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for LinkChannel {
    fn type_info(&self) -> &'static TypeInfo {
        LINKCHANNEL_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static LINKCHANNEL_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkChannel-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("LinkChannel"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LogicPrefabReferenceObjectData {
    pub _glacier_base: LogicReferenceObjectData,
}

pub trait LogicPrefabReferenceObjectDataTrait: LogicReferenceObjectDataTrait {
}

impl LogicPrefabReferenceObjectDataTrait for LogicPrefabReferenceObjectData {
}

impl LogicReferenceObjectDataTrait for LogicPrefabReferenceObjectData {
    fn local_player_id(&self) -> &super::core::LocalPlayerId {
        self._glacier_base.local_player_id()
    }
    fn sub_realm(&self) -> &SubRealm {
        self._glacier_base.sub_realm()
    }
}

impl ReferenceObjectDataTrait for LogicPrefabReferenceObjectData {
    fn blueprint_transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.blueprint_transform()
    }
    fn blueprint(&self) -> &Option<Arc<Mutex<dyn BlueprintTrait>>> {
        self._glacier_base.blueprint()
    }
    fn object_variation(&self) -> &Option<Arc<Mutex<dyn ObjectVariationTrait>>> {
        self._glacier_base.object_variation()
    }
    fn stream_realm(&self) -> &StreamRealm {
        self._glacier_base.stream_realm()
    }
    fn radiosity_type_override(&self) -> &super::core::RadiosityTypeOverride {
        self._glacier_base.radiosity_type_override()
    }
    fn lightmap_resolution_scale(&self) -> &u32 {
        self._glacier_base.lightmap_resolution_scale()
    }
    fn lightmap_scale_with_size(&self) -> &bool {
        self._glacier_base.lightmap_scale_with_size()
    }
    fn rendering_overrides(&self) -> &super::core::RenderingOverrides {
        self._glacier_base.rendering_overrides()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn create_indestructible_entity(&self) -> &bool {
        self._glacier_base.create_indestructible_entity()
    }
}

impl GameObjectDataTrait for LogicPrefabReferenceObjectData {
}

impl super::core::DataBusPeerTrait for LogicPrefabReferenceObjectData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for LogicPrefabReferenceObjectData {
}

impl super::core::DataContainerTrait for LogicPrefabReferenceObjectData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static LOGICPREFABREFERENCEOBJECTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LogicPrefabReferenceObjectData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(LOGICREFERENCEOBJECTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LogicPrefabReferenceObjectData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(LOGICPREFABREFERENCEOBJECTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for LogicPrefabReferenceObjectData {
    fn type_info(&self) -> &'static TypeInfo {
        LOGICPREFABREFERENCEOBJECTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static LOGICPREFABREFERENCEOBJECTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LogicPrefabReferenceObjectData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("LogicPrefabReferenceObjectData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SpatialPrefabReferenceObjectData {
    pub _glacier_base: SpatialReferenceObjectData,
    pub persistence_setting: BlueprintPersistenceSetting,
}

pub trait SpatialPrefabReferenceObjectDataTrait: SpatialReferenceObjectDataTrait {
    fn persistence_setting(&self) -> &BlueprintPersistenceSetting;
}

impl SpatialPrefabReferenceObjectDataTrait for SpatialPrefabReferenceObjectData {
    fn persistence_setting(&self) -> &BlueprintPersistenceSetting {
        &self.persistence_setting
    }
}

impl SpatialReferenceObjectDataTrait for SpatialPrefabReferenceObjectData {
    fn local_player_id(&self) -> &super::core::LocalPlayerId {
        self._glacier_base.local_player_id()
    }
}

impl ReferenceObjectDataTrait for SpatialPrefabReferenceObjectData {
    fn blueprint_transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.blueprint_transform()
    }
    fn blueprint(&self) -> &Option<Arc<Mutex<dyn BlueprintTrait>>> {
        self._glacier_base.blueprint()
    }
    fn object_variation(&self) -> &Option<Arc<Mutex<dyn ObjectVariationTrait>>> {
        self._glacier_base.object_variation()
    }
    fn stream_realm(&self) -> &StreamRealm {
        self._glacier_base.stream_realm()
    }
    fn radiosity_type_override(&self) -> &super::core::RadiosityTypeOverride {
        self._glacier_base.radiosity_type_override()
    }
    fn lightmap_resolution_scale(&self) -> &u32 {
        self._glacier_base.lightmap_resolution_scale()
    }
    fn lightmap_scale_with_size(&self) -> &bool {
        self._glacier_base.lightmap_scale_with_size()
    }
    fn rendering_overrides(&self) -> &super::core::RenderingOverrides {
        self._glacier_base.rendering_overrides()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn create_indestructible_entity(&self) -> &bool {
        self._glacier_base.create_indestructible_entity()
    }
}

impl GameObjectDataTrait for SpatialPrefabReferenceObjectData {
}

impl super::core::DataBusPeerTrait for SpatialPrefabReferenceObjectData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for SpatialPrefabReferenceObjectData {
}

impl super::core::DataContainerTrait for SpatialPrefabReferenceObjectData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SPATIALPREFABREFERENCEOBJECTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpatialPrefabReferenceObjectData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SPATIALREFERENCEOBJECTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SpatialPrefabReferenceObjectData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PersistenceSetting",
                flags: MemberInfoFlags::new(0),
                field_type: "BlueprintPersistenceSetting",
                rust_offset: offset_of!(SpatialPrefabReferenceObjectData, persistence_setting),
            },
        ],
    }),
    array_type: Some(SPATIALPREFABREFERENCEOBJECTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SpatialPrefabReferenceObjectData {
    fn type_info(&self) -> &'static TypeInfo {
        SPATIALPREFABREFERENCEOBJECTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SPATIALPREFABREFERENCEOBJECTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpatialPrefabReferenceObjectData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SpatialPrefabReferenceObjectData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ObjectReferenceObjectData {
    pub _glacier_base: SpatialReferenceObjectData,
}

pub trait ObjectReferenceObjectDataTrait: SpatialReferenceObjectDataTrait {
}

impl ObjectReferenceObjectDataTrait for ObjectReferenceObjectData {
}

impl SpatialReferenceObjectDataTrait for ObjectReferenceObjectData {
    fn local_player_id(&self) -> &super::core::LocalPlayerId {
        self._glacier_base.local_player_id()
    }
}

impl ReferenceObjectDataTrait for ObjectReferenceObjectData {
    fn blueprint_transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.blueprint_transform()
    }
    fn blueprint(&self) -> &Option<Arc<Mutex<dyn BlueprintTrait>>> {
        self._glacier_base.blueprint()
    }
    fn object_variation(&self) -> &Option<Arc<Mutex<dyn ObjectVariationTrait>>> {
        self._glacier_base.object_variation()
    }
    fn stream_realm(&self) -> &StreamRealm {
        self._glacier_base.stream_realm()
    }
    fn radiosity_type_override(&self) -> &super::core::RadiosityTypeOverride {
        self._glacier_base.radiosity_type_override()
    }
    fn lightmap_resolution_scale(&self) -> &u32 {
        self._glacier_base.lightmap_resolution_scale()
    }
    fn lightmap_scale_with_size(&self) -> &bool {
        self._glacier_base.lightmap_scale_with_size()
    }
    fn rendering_overrides(&self) -> &super::core::RenderingOverrides {
        self._glacier_base.rendering_overrides()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn create_indestructible_entity(&self) -> &bool {
        self._glacier_base.create_indestructible_entity()
    }
}

impl GameObjectDataTrait for ObjectReferenceObjectData {
}

impl super::core::DataBusPeerTrait for ObjectReferenceObjectData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for ObjectReferenceObjectData {
}

impl super::core::DataContainerTrait for ObjectReferenceObjectData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static OBJECTREFERENCEOBJECTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectReferenceObjectData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SPATIALREFERENCEOBJECTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ObjectReferenceObjectData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(OBJECTREFERENCEOBJECTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ObjectReferenceObjectData {
    fn type_info(&self) -> &'static TypeInfo {
        OBJECTREFERENCEOBJECTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static OBJECTREFERENCEOBJECTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectReferenceObjectData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ObjectReferenceObjectData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LogicReferenceObjectData {
    pub _glacier_base: ReferenceObjectData,
    pub local_player_id: super::core::LocalPlayerId,
    pub sub_realm: SubRealm,
}

pub trait LogicReferenceObjectDataTrait: ReferenceObjectDataTrait {
    fn local_player_id(&self) -> &super::core::LocalPlayerId;
    fn sub_realm(&self) -> &SubRealm;
}

impl LogicReferenceObjectDataTrait for LogicReferenceObjectData {
    fn local_player_id(&self) -> &super::core::LocalPlayerId {
        &self.local_player_id
    }
    fn sub_realm(&self) -> &SubRealm {
        &self.sub_realm
    }
}

impl ReferenceObjectDataTrait for LogicReferenceObjectData {
    fn blueprint_transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.blueprint_transform()
    }
    fn blueprint(&self) -> &Option<Arc<Mutex<dyn BlueprintTrait>>> {
        self._glacier_base.blueprint()
    }
    fn object_variation(&self) -> &Option<Arc<Mutex<dyn ObjectVariationTrait>>> {
        self._glacier_base.object_variation()
    }
    fn stream_realm(&self) -> &StreamRealm {
        self._glacier_base.stream_realm()
    }
    fn radiosity_type_override(&self) -> &super::core::RadiosityTypeOverride {
        self._glacier_base.radiosity_type_override()
    }
    fn lightmap_resolution_scale(&self) -> &u32 {
        self._glacier_base.lightmap_resolution_scale()
    }
    fn lightmap_scale_with_size(&self) -> &bool {
        self._glacier_base.lightmap_scale_with_size()
    }
    fn rendering_overrides(&self) -> &super::core::RenderingOverrides {
        self._glacier_base.rendering_overrides()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn create_indestructible_entity(&self) -> &bool {
        self._glacier_base.create_indestructible_entity()
    }
}

impl GameObjectDataTrait for LogicReferenceObjectData {
}

impl super::core::DataBusPeerTrait for LogicReferenceObjectData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for LogicReferenceObjectData {
}

impl super::core::DataContainerTrait for LogicReferenceObjectData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static LOGICREFERENCEOBJECTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LogicReferenceObjectData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(REFERENCEOBJECTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LogicReferenceObjectData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "LocalPlayerId",
                flags: MemberInfoFlags::new(0),
                field_type: "LocalPlayerId",
                rust_offset: offset_of!(LogicReferenceObjectData, local_player_id),
            },
            FieldInfoData {
                name: "SubRealm",
                flags: MemberInfoFlags::new(0),
                field_type: "SubRealm",
                rust_offset: offset_of!(LogicReferenceObjectData, sub_realm),
            },
        ],
    }),
    array_type: Some(LOGICREFERENCEOBJECTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for LogicReferenceObjectData {
    fn type_info(&self) -> &'static TypeInfo {
        LOGICREFERENCEOBJECTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static LOGICREFERENCEOBJECTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LogicReferenceObjectData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("LogicReferenceObjectData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SpatialReferenceObjectData {
    pub _glacier_base: ReferenceObjectData,
    pub local_player_id: super::core::LocalPlayerId,
}

pub trait SpatialReferenceObjectDataTrait: ReferenceObjectDataTrait {
    fn local_player_id(&self) -> &super::core::LocalPlayerId;
}

impl SpatialReferenceObjectDataTrait for SpatialReferenceObjectData {
    fn local_player_id(&self) -> &super::core::LocalPlayerId {
        &self.local_player_id
    }
}

impl ReferenceObjectDataTrait for SpatialReferenceObjectData {
    fn blueprint_transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.blueprint_transform()
    }
    fn blueprint(&self) -> &Option<Arc<Mutex<dyn BlueprintTrait>>> {
        self._glacier_base.blueprint()
    }
    fn object_variation(&self) -> &Option<Arc<Mutex<dyn ObjectVariationTrait>>> {
        self._glacier_base.object_variation()
    }
    fn stream_realm(&self) -> &StreamRealm {
        self._glacier_base.stream_realm()
    }
    fn radiosity_type_override(&self) -> &super::core::RadiosityTypeOverride {
        self._glacier_base.radiosity_type_override()
    }
    fn lightmap_resolution_scale(&self) -> &u32 {
        self._glacier_base.lightmap_resolution_scale()
    }
    fn lightmap_scale_with_size(&self) -> &bool {
        self._glacier_base.lightmap_scale_with_size()
    }
    fn rendering_overrides(&self) -> &super::core::RenderingOverrides {
        self._glacier_base.rendering_overrides()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn create_indestructible_entity(&self) -> &bool {
        self._glacier_base.create_indestructible_entity()
    }
}

impl GameObjectDataTrait for SpatialReferenceObjectData {
}

impl super::core::DataBusPeerTrait for SpatialReferenceObjectData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for SpatialReferenceObjectData {
}

impl super::core::DataContainerTrait for SpatialReferenceObjectData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SPATIALREFERENCEOBJECTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpatialReferenceObjectData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(REFERENCEOBJECTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SpatialReferenceObjectData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "LocalPlayerId",
                flags: MemberInfoFlags::new(0),
                field_type: "LocalPlayerId",
                rust_offset: offset_of!(SpatialReferenceObjectData, local_player_id),
            },
        ],
    }),
    array_type: Some(SPATIALREFERENCEOBJECTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SpatialReferenceObjectData {
    fn type_info(&self) -> &'static TypeInfo {
        SPATIALREFERENCEOBJECTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SPATIALREFERENCEOBJECTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpatialReferenceObjectData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SpatialReferenceObjectData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ReferenceObjectData {
    pub _glacier_base: GameObjectData,
    pub blueprint_transform: super::core::LinearTransform,
    pub blueprint: Option<Arc<Mutex<dyn BlueprintTrait>>>,
    pub object_variation: Option<Arc<Mutex<dyn ObjectVariationTrait>>>,
    pub stream_realm: StreamRealm,
    pub radiosity_type_override: super::core::RadiosityTypeOverride,
    pub lightmap_resolution_scale: u32,
    pub lightmap_scale_with_size: bool,
    pub rendering_overrides: super::core::RenderingOverrides,
    pub excluded: bool,
    pub create_indestructible_entity: bool,
}

pub trait ReferenceObjectDataTrait: GameObjectDataTrait {
    fn blueprint_transform(&self) -> &super::core::LinearTransform;
    fn blueprint(&self) -> &Option<Arc<Mutex<dyn BlueprintTrait>>>;
    fn object_variation(&self) -> &Option<Arc<Mutex<dyn ObjectVariationTrait>>>;
    fn stream_realm(&self) -> &StreamRealm;
    fn radiosity_type_override(&self) -> &super::core::RadiosityTypeOverride;
    fn lightmap_resolution_scale(&self) -> &u32;
    fn lightmap_scale_with_size(&self) -> &bool;
    fn rendering_overrides(&self) -> &super::core::RenderingOverrides;
    fn excluded(&self) -> &bool;
    fn create_indestructible_entity(&self) -> &bool;
}

impl ReferenceObjectDataTrait for ReferenceObjectData {
    fn blueprint_transform(&self) -> &super::core::LinearTransform {
        &self.blueprint_transform
    }
    fn blueprint(&self) -> &Option<Arc<Mutex<dyn BlueprintTrait>>> {
        &self.blueprint
    }
    fn object_variation(&self) -> &Option<Arc<Mutex<dyn ObjectVariationTrait>>> {
        &self.object_variation
    }
    fn stream_realm(&self) -> &StreamRealm {
        &self.stream_realm
    }
    fn radiosity_type_override(&self) -> &super::core::RadiosityTypeOverride {
        &self.radiosity_type_override
    }
    fn lightmap_resolution_scale(&self) -> &u32 {
        &self.lightmap_resolution_scale
    }
    fn lightmap_scale_with_size(&self) -> &bool {
        &self.lightmap_scale_with_size
    }
    fn rendering_overrides(&self) -> &super::core::RenderingOverrides {
        &self.rendering_overrides
    }
    fn excluded(&self) -> &bool {
        &self.excluded
    }
    fn create_indestructible_entity(&self) -> &bool {
        &self.create_indestructible_entity
    }
}

impl GameObjectDataTrait for ReferenceObjectData {
}

impl super::core::DataBusPeerTrait for ReferenceObjectData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for ReferenceObjectData {
}

impl super::core::DataContainerTrait for ReferenceObjectData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static REFERENCEOBJECTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReferenceObjectData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(GAMEOBJECTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ReferenceObjectData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "BlueprintTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(ReferenceObjectData, blueprint_transform),
            },
            FieldInfoData {
                name: "Blueprint",
                flags: MemberInfoFlags::new(0),
                field_type: "Blueprint",
                rust_offset: offset_of!(ReferenceObjectData, blueprint),
            },
            FieldInfoData {
                name: "ObjectVariation",
                flags: MemberInfoFlags::new(0),
                field_type: "ObjectVariation",
                rust_offset: offset_of!(ReferenceObjectData, object_variation),
            },
            FieldInfoData {
                name: "StreamRealm",
                flags: MemberInfoFlags::new(0),
                field_type: "StreamRealm",
                rust_offset: offset_of!(ReferenceObjectData, stream_realm),
            },
            FieldInfoData {
                name: "RadiosityTypeOverride",
                flags: MemberInfoFlags::new(0),
                field_type: "RadiosityTypeOverride",
                rust_offset: offset_of!(ReferenceObjectData, radiosity_type_override),
            },
            FieldInfoData {
                name: "LightmapResolutionScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(ReferenceObjectData, lightmap_resolution_scale),
            },
            FieldInfoData {
                name: "LightmapScaleWithSize",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ReferenceObjectData, lightmap_scale_with_size),
            },
            FieldInfoData {
                name: "RenderingOverrides",
                flags: MemberInfoFlags::new(0),
                field_type: "RenderingOverrides",
                rust_offset: offset_of!(ReferenceObjectData, rendering_overrides),
            },
            FieldInfoData {
                name: "Excluded",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ReferenceObjectData, excluded),
            },
            FieldInfoData {
                name: "CreateIndestructibleEntity",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ReferenceObjectData, create_indestructible_entity),
            },
        ],
    }),
    array_type: Some(REFERENCEOBJECTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ReferenceObjectData {
    fn type_info(&self) -> &'static TypeInfo {
        REFERENCEOBJECTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static REFERENCEOBJECTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReferenceObjectData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ReferenceObjectData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum StreamRealm {
    #[default]
    StreamRealm_None = 0,
    StreamRealm_Client = 1,
    StreamRealm_Both = 2,
}

pub static STREAMREALM_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StreamRealm",
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(STREAMREALM_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for StreamRealm {
    fn type_info(&self) -> &'static TypeInfo {
        STREAMREALM_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static STREAMREALM_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StreamRealm-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("StreamRealm"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ObjectVariationCollection {
    pub _glacier_base: super::core::DataContainer,
    pub variations: Vec<Option<Arc<Mutex<dyn ObjectVariationTrait>>>>,
}

pub trait ObjectVariationCollectionTrait: super::core::DataContainerTrait {
    fn variations(&self) -> &Vec<Option<Arc<Mutex<dyn ObjectVariationTrait>>>>;
}

impl ObjectVariationCollectionTrait for ObjectVariationCollection {
    fn variations(&self) -> &Vec<Option<Arc<Mutex<dyn ObjectVariationTrait>>>> {
        &self.variations
    }
}

impl super::core::DataContainerTrait for ObjectVariationCollection {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static OBJECTVARIATIONCOLLECTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectVariationCollection",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ObjectVariationCollection as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Variations",
                flags: MemberInfoFlags::new(144),
                field_type: "ObjectVariation-Array",
                rust_offset: offset_of!(ObjectVariationCollection, variations),
            },
        ],
    }),
    array_type: Some(OBJECTVARIATIONCOLLECTION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ObjectVariationCollection {
    fn type_info(&self) -> &'static TypeInfo {
        OBJECTVARIATIONCOLLECTION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static OBJECTVARIATIONCOLLECTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectVariationCollection-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ObjectVariationCollection"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ObjectVariation {
    pub _glacier_base: super::core::Asset,
    pub name_hash: u32,
}

pub trait ObjectVariationTrait: super::core::AssetTrait {
    fn name_hash(&self) -> &u32;
}

impl ObjectVariationTrait for ObjectVariation {
    fn name_hash(&self) -> &u32 {
        &self.name_hash
    }
}

impl super::core::AssetTrait for ObjectVariation {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for ObjectVariation {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static OBJECTVARIATION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectVariation",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ObjectVariation as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "NameHash",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(ObjectVariation, name_hash),
            },
        ],
    }),
    array_type: Some(OBJECTVARIATION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ObjectVariation {
    fn type_info(&self) -> &'static TypeInfo {
        OBJECTVARIATION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static OBJECTVARIATION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectVariation-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ObjectVariation"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DataContainerCollectionBlueprint {
    pub _glacier_base: Blueprint,
    pub data_containers: Vec<Option<Arc<Mutex<dyn super::core::DataContainerTrait>>>>,
}

pub trait DataContainerCollectionBlueprintTrait: BlueprintTrait {
    fn data_containers(&self) -> &Vec<Option<Arc<Mutex<dyn super::core::DataContainerTrait>>>>;
}

impl DataContainerCollectionBlueprintTrait for DataContainerCollectionBlueprint {
    fn data_containers(&self) -> &Vec<Option<Arc<Mutex<dyn super::core::DataContainerTrait>>>> {
        &self.data_containers
    }
}

impl BlueprintTrait for DataContainerCollectionBlueprint {
    fn objects(&self) -> &Vec<Option<Arc<Mutex<dyn GameObjectDataTrait>>>> {
        self._glacier_base.objects()
    }
    fn schematics(&self) -> &Option<Arc<Mutex<dyn super::schematics::SchematicsBaseAssetTrait>>> {
        self._glacier_base.schematics()
    }
}

impl EntityBusDataTrait for DataContainerCollectionBlueprint {
    fn event_connections(&self) -> &Vec<EventConnection> {
        self._glacier_base.event_connections()
    }
}

impl super::core::DataBusDataTrait for DataContainerCollectionBlueprint {
    fn flags(&self) -> &u16 {
        self._glacier_base.flags()
    }
    fn property_connections(&self) -> &Vec<super::core::PropertyConnection> {
        self._glacier_base.property_connections()
    }
    fn link_connections(&self) -> &Vec<super::core::LinkConnection> {
        self._glacier_base.link_connections()
    }
    fn interface(&self) -> &Option<Arc<Mutex<dyn super::core::DynamicDataContainerTrait>>> {
        self._glacier_base.interface()
    }
}

impl super::core::AssetTrait for DataContainerCollectionBlueprint {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for DataContainerCollectionBlueprint {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static DATACONTAINERCOLLECTIONBLUEPRINT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DataContainerCollectionBlueprint",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(BLUEPRINT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DataContainerCollectionBlueprint as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DataContainers",
                flags: MemberInfoFlags::new(144),
                field_type: "DataContainer-Array",
                rust_offset: offset_of!(DataContainerCollectionBlueprint, data_containers),
            },
        ],
    }),
    array_type: Some(DATACONTAINERCOLLECTIONBLUEPRINT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DataContainerCollectionBlueprint {
    fn type_info(&self) -> &'static TypeInfo {
        DATACONTAINERCOLLECTIONBLUEPRINT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static DATACONTAINERCOLLECTIONBLUEPRINT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DataContainerCollectionBlueprint-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("DataContainerCollectionBlueprint"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LogicPrefabBlueprint {
    pub _glacier_base: PrefabBlueprint,
}

pub trait LogicPrefabBlueprintTrait: PrefabBlueprintTrait {
}

impl LogicPrefabBlueprintTrait for LogicPrefabBlueprint {
}

impl PrefabBlueprintTrait for LogicPrefabBlueprint {
    fn time_delta_type(&self) -> &TimeDeltaType {
        self._glacier_base.time_delta_type()
    }
}

impl BlueprintTrait for LogicPrefabBlueprint {
    fn objects(&self) -> &Vec<Option<Arc<Mutex<dyn GameObjectDataTrait>>>> {
        self._glacier_base.objects()
    }
    fn schematics(&self) -> &Option<Arc<Mutex<dyn super::schematics::SchematicsBaseAssetTrait>>> {
        self._glacier_base.schematics()
    }
}

impl EntityBusDataTrait for LogicPrefabBlueprint {
    fn event_connections(&self) -> &Vec<EventConnection> {
        self._glacier_base.event_connections()
    }
}

impl super::core::DataBusDataTrait for LogicPrefabBlueprint {
    fn flags(&self) -> &u16 {
        self._glacier_base.flags()
    }
    fn property_connections(&self) -> &Vec<super::core::PropertyConnection> {
        self._glacier_base.property_connections()
    }
    fn link_connections(&self) -> &Vec<super::core::LinkConnection> {
        self._glacier_base.link_connections()
    }
    fn interface(&self) -> &Option<Arc<Mutex<dyn super::core::DynamicDataContainerTrait>>> {
        self._glacier_base.interface()
    }
}

impl super::core::AssetTrait for LogicPrefabBlueprint {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for LogicPrefabBlueprint {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static LOGICPREFABBLUEPRINT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LogicPrefabBlueprint",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PREFABBLUEPRINT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LogicPrefabBlueprint as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(LOGICPREFABBLUEPRINT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LogicPrefabBlueprint {
    fn type_info(&self) -> &'static TypeInfo {
        LOGICPREFABBLUEPRINT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static LOGICPREFABBLUEPRINT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LogicPrefabBlueprint-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("LogicPrefabBlueprint"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SpatialPrefabBlueprint {
    pub _glacier_base: PrefabBlueprint,
}

pub trait SpatialPrefabBlueprintTrait: PrefabBlueprintTrait {
}

impl SpatialPrefabBlueprintTrait for SpatialPrefabBlueprint {
}

impl PrefabBlueprintTrait for SpatialPrefabBlueprint {
    fn time_delta_type(&self) -> &TimeDeltaType {
        self._glacier_base.time_delta_type()
    }
}

impl BlueprintTrait for SpatialPrefabBlueprint {
    fn objects(&self) -> &Vec<Option<Arc<Mutex<dyn GameObjectDataTrait>>>> {
        self._glacier_base.objects()
    }
    fn schematics(&self) -> &Option<Arc<Mutex<dyn super::schematics::SchematicsBaseAssetTrait>>> {
        self._glacier_base.schematics()
    }
}

impl EntityBusDataTrait for SpatialPrefabBlueprint {
    fn event_connections(&self) -> &Vec<EventConnection> {
        self._glacier_base.event_connections()
    }
}

impl super::core::DataBusDataTrait for SpatialPrefabBlueprint {
    fn flags(&self) -> &u16 {
        self._glacier_base.flags()
    }
    fn property_connections(&self) -> &Vec<super::core::PropertyConnection> {
        self._glacier_base.property_connections()
    }
    fn link_connections(&self) -> &Vec<super::core::LinkConnection> {
        self._glacier_base.link_connections()
    }
    fn interface(&self) -> &Option<Arc<Mutex<dyn super::core::DynamicDataContainerTrait>>> {
        self._glacier_base.interface()
    }
}

impl super::core::AssetTrait for SpatialPrefabBlueprint {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for SpatialPrefabBlueprint {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SPATIALPREFABBLUEPRINT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpatialPrefabBlueprint",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PREFABBLUEPRINT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SpatialPrefabBlueprint as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SPATIALPREFABBLUEPRINT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SpatialPrefabBlueprint {
    fn type_info(&self) -> &'static TypeInfo {
        SPATIALPREFABBLUEPRINT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SPATIALPREFABBLUEPRINT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpatialPrefabBlueprint-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SpatialPrefabBlueprint"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PrefabBlueprint {
    pub _glacier_base: Blueprint,
    pub time_delta_type: TimeDeltaType,
}

pub trait PrefabBlueprintTrait: BlueprintTrait {
    fn time_delta_type(&self) -> &TimeDeltaType;
}

impl PrefabBlueprintTrait for PrefabBlueprint {
    fn time_delta_type(&self) -> &TimeDeltaType {
        &self.time_delta_type
    }
}

impl BlueprintTrait for PrefabBlueprint {
    fn objects(&self) -> &Vec<Option<Arc<Mutex<dyn GameObjectDataTrait>>>> {
        self._glacier_base.objects()
    }
    fn schematics(&self) -> &Option<Arc<Mutex<dyn super::schematics::SchematicsBaseAssetTrait>>> {
        self._glacier_base.schematics()
    }
}

impl EntityBusDataTrait for PrefabBlueprint {
    fn event_connections(&self) -> &Vec<EventConnection> {
        self._glacier_base.event_connections()
    }
}

impl super::core::DataBusDataTrait for PrefabBlueprint {
    fn flags(&self) -> &u16 {
        self._glacier_base.flags()
    }
    fn property_connections(&self) -> &Vec<super::core::PropertyConnection> {
        self._glacier_base.property_connections()
    }
    fn link_connections(&self) -> &Vec<super::core::LinkConnection> {
        self._glacier_base.link_connections()
    }
    fn interface(&self) -> &Option<Arc<Mutex<dyn super::core::DynamicDataContainerTrait>>> {
        self._glacier_base.interface()
    }
}

impl super::core::AssetTrait for PrefabBlueprint {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for PrefabBlueprint {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PREFABBLUEPRINT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PrefabBlueprint",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(BLUEPRINT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PrefabBlueprint as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "TimeDeltaType",
                flags: MemberInfoFlags::new(0),
                field_type: "TimeDeltaType",
                rust_offset: offset_of!(PrefabBlueprint, time_delta_type),
            },
        ],
    }),
    array_type: Some(PREFABBLUEPRINT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PrefabBlueprint {
    fn type_info(&self) -> &'static TypeInfo {
        PREFABBLUEPRINT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PREFABBLUEPRINT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PrefabBlueprint-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("PrefabBlueprint"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ObjectBlueprint {
    pub _glacier_base: Blueprint,
    pub object: Option<Arc<Mutex<dyn EntityDataTrait>>>,
}

pub trait ObjectBlueprintTrait: BlueprintTrait {
    fn object(&self) -> &Option<Arc<Mutex<dyn EntityDataTrait>>>;
}

impl ObjectBlueprintTrait for ObjectBlueprint {
    fn object(&self) -> &Option<Arc<Mutex<dyn EntityDataTrait>>> {
        &self.object
    }
}

impl BlueprintTrait for ObjectBlueprint {
    fn objects(&self) -> &Vec<Option<Arc<Mutex<dyn GameObjectDataTrait>>>> {
        self._glacier_base.objects()
    }
    fn schematics(&self) -> &Option<Arc<Mutex<dyn super::schematics::SchematicsBaseAssetTrait>>> {
        self._glacier_base.schematics()
    }
}

impl EntityBusDataTrait for ObjectBlueprint {
    fn event_connections(&self) -> &Vec<EventConnection> {
        self._glacier_base.event_connections()
    }
}

impl super::core::DataBusDataTrait for ObjectBlueprint {
    fn flags(&self) -> &u16 {
        self._glacier_base.flags()
    }
    fn property_connections(&self) -> &Vec<super::core::PropertyConnection> {
        self._glacier_base.property_connections()
    }
    fn link_connections(&self) -> &Vec<super::core::LinkConnection> {
        self._glacier_base.link_connections()
    }
    fn interface(&self) -> &Option<Arc<Mutex<dyn super::core::DynamicDataContainerTrait>>> {
        self._glacier_base.interface()
    }
}

impl super::core::AssetTrait for ObjectBlueprint {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for ObjectBlueprint {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static OBJECTBLUEPRINT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectBlueprint",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(BLUEPRINT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ObjectBlueprint as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Object",
                flags: MemberInfoFlags::new(0),
                field_type: "EntityData",
                rust_offset: offset_of!(ObjectBlueprint, object),
            },
        ],
    }),
    array_type: Some(OBJECTBLUEPRINT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ObjectBlueprint {
    fn type_info(&self) -> &'static TypeInfo {
        OBJECTBLUEPRINT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static OBJECTBLUEPRINT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectBlueprint-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ObjectBlueprint"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Blueprint {
    pub _glacier_base: EntityBusData,
    pub objects: Vec<Option<Arc<Mutex<dyn GameObjectDataTrait>>>>,
    pub schematics: Option<Arc<Mutex<dyn super::schematics::SchematicsBaseAssetTrait>>>,
}

pub trait BlueprintTrait: EntityBusDataTrait {
    fn objects(&self) -> &Vec<Option<Arc<Mutex<dyn GameObjectDataTrait>>>>;
    fn schematics(&self) -> &Option<Arc<Mutex<dyn super::schematics::SchematicsBaseAssetTrait>>>;
}

impl BlueprintTrait for Blueprint {
    fn objects(&self) -> &Vec<Option<Arc<Mutex<dyn GameObjectDataTrait>>>> {
        &self.objects
    }
    fn schematics(&self) -> &Option<Arc<Mutex<dyn super::schematics::SchematicsBaseAssetTrait>>> {
        &self.schematics
    }
}

impl EntityBusDataTrait for Blueprint {
    fn event_connections(&self) -> &Vec<EventConnection> {
        self._glacier_base.event_connections()
    }
}

impl super::core::DataBusDataTrait for Blueprint {
    fn flags(&self) -> &u16 {
        self._glacier_base.flags()
    }
    fn property_connections(&self) -> &Vec<super::core::PropertyConnection> {
        self._glacier_base.property_connections()
    }
    fn link_connections(&self) -> &Vec<super::core::LinkConnection> {
        self._glacier_base.link_connections()
    }
    fn interface(&self) -> &Option<Arc<Mutex<dyn super::core::DynamicDataContainerTrait>>> {
        self._glacier_base.interface()
    }
}

impl super::core::AssetTrait for Blueprint {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for Blueprint {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static BLUEPRINT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Blueprint",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYBUSDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Blueprint as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Objects",
                flags: MemberInfoFlags::new(144),
                field_type: "GameObjectData-Array",
                rust_offset: offset_of!(Blueprint, objects),
            },
            FieldInfoData {
                name: "Schematics",
                flags: MemberInfoFlags::new(0),
                field_type: "SchematicsBaseAsset",
                rust_offset: offset_of!(Blueprint, schematics),
            },
        ],
    }),
    array_type: Some(BLUEPRINT_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for Blueprint {
    fn type_info(&self) -> &'static TypeInfo {
        BLUEPRINT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static BLUEPRINT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Blueprint-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Blueprint"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum BlueprintPersistenceSetting {
    #[default]
    BlueprintPersistenceSetting_InheritFromParent = 0,
    BlueprintPersistenceSetting_SavedWhenInMemory = 1,
    BlueprintPersistenceSetting_AlwaysSaved = 2,
    BlueprintPersistenceSetting_NeverSaved = 3,
}

pub static BLUEPRINTPERSISTENCESETTING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BlueprintPersistenceSetting",
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(BLUEPRINTPERSISTENCESETTING_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for BlueprintPersistenceSetting {
    fn type_info(&self) -> &'static TypeInfo {
        BLUEPRINTPERSISTENCESETTING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static BLUEPRINTPERSISTENCESETTING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BlueprintPersistenceSetting-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("BlueprintPersistenceSetting"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EntityBusData {
    pub _glacier_base: super::core::DataBusData,
    pub event_connections: Vec<EventConnection>,
}

pub trait EntityBusDataTrait: super::core::DataBusDataTrait {
    fn event_connections(&self) -> &Vec<EventConnection>;
}

impl EntityBusDataTrait for EntityBusData {
    fn event_connections(&self) -> &Vec<EventConnection> {
        &self.event_connections
    }
}

impl super::core::DataBusDataTrait for EntityBusData {
    fn flags(&self) -> &u16 {
        self._glacier_base.flags()
    }
    fn property_connections(&self) -> &Vec<super::core::PropertyConnection> {
        self._glacier_base.property_connections()
    }
    fn link_connections(&self) -> &Vec<super::core::LinkConnection> {
        self._glacier_base.link_connections()
    }
    fn interface(&self) -> &Option<Arc<Mutex<dyn super::core::DynamicDataContainerTrait>>> {
        self._glacier_base.interface()
    }
}

impl super::core::AssetTrait for EntityBusData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for EntityBusData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static ENTITYBUSDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityBusData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATABUSDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EntityBusData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "EventConnections",
                flags: MemberInfoFlags::new(144),
                field_type: "EventConnection-Array",
                rust_offset: offset_of!(EntityBusData, event_connections),
            },
        ],
    }),
    array_type: Some(ENTITYBUSDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for EntityBusData {
    fn type_info(&self) -> &'static TypeInfo {
        ENTITYBUSDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ENTITYBUSDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityBusData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EntityBusData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct InterfaceDescriptorData {
    pub _glacier_base: super::core::DynamicDataContainer,
    pub input_events: Vec<DynamicEvent>,
    pub output_events: Vec<DynamicEvent>,
    pub input_links: Vec<DynamicLink>,
    pub output_links: Vec<DynamicLink>,
}

pub trait InterfaceDescriptorDataTrait: super::core::DynamicDataContainerTrait {
    fn input_events(&self) -> &Vec<DynamicEvent>;
    fn output_events(&self) -> &Vec<DynamicEvent>;
    fn input_links(&self) -> &Vec<DynamicLink>;
    fn output_links(&self) -> &Vec<DynamicLink>;
}

impl InterfaceDescriptorDataTrait for InterfaceDescriptorData {
    fn input_events(&self) -> &Vec<DynamicEvent> {
        &self.input_events
    }
    fn output_events(&self) -> &Vec<DynamicEvent> {
        &self.output_events
    }
    fn input_links(&self) -> &Vec<DynamicLink> {
        &self.input_links
    }
    fn output_links(&self) -> &Vec<DynamicLink> {
        &self.output_links
    }
}

impl super::core::DynamicDataContainerTrait for InterfaceDescriptorData {
    fn fields(&self) -> &Vec<super::core::DataField> {
        self._glacier_base.fields()
    }
}

impl super::core::DataContainerTrait for InterfaceDescriptorData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static INTERFACEDESCRIPTORDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InterfaceDescriptorData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DYNAMICDATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<InterfaceDescriptorData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "InputEvents",
                flags: MemberInfoFlags::new(144),
                field_type: "DynamicEvent-Array",
                rust_offset: offset_of!(InterfaceDescriptorData, input_events),
            },
            FieldInfoData {
                name: "OutputEvents",
                flags: MemberInfoFlags::new(144),
                field_type: "DynamicEvent-Array",
                rust_offset: offset_of!(InterfaceDescriptorData, output_events),
            },
            FieldInfoData {
                name: "InputLinks",
                flags: MemberInfoFlags::new(144),
                field_type: "DynamicLink-Array",
                rust_offset: offset_of!(InterfaceDescriptorData, input_links),
            },
            FieldInfoData {
                name: "OutputLinks",
                flags: MemberInfoFlags::new(144),
                field_type: "DynamicLink-Array",
                rust_offset: offset_of!(InterfaceDescriptorData, output_links),
            },
        ],
    }),
    array_type: Some(INTERFACEDESCRIPTORDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for InterfaceDescriptorData {
    fn type_info(&self) -> &'static TypeInfo {
        INTERFACEDESCRIPTORDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static INTERFACEDESCRIPTORDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InterfaceDescriptorData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("InterfaceDescriptorData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DynamicLink {
    pub id: i32,
}

pub trait DynamicLinkTrait: TypeObject {
    fn id(&self) -> &i32;
}

impl DynamicLinkTrait for DynamicLink {
    fn id(&self) -> &i32 {
        &self.id
    }
}

pub static DYNAMICLINK_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicLink",
    flags: MemberInfoFlags::new(32841),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DynamicLink as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Id",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(DynamicLink, id),
            },
        ],
    }),
    array_type: Some(DYNAMICLINK_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for DynamicLink {
    fn type_info(&self) -> &'static TypeInfo {
        DYNAMICLINK_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static DYNAMICLINK_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicLink-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("DynamicLink"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DynamicEvent {
    pub id: i32,
}

pub trait DynamicEventTrait: TypeObject {
    fn id(&self) -> &i32;
}

impl DynamicEventTrait for DynamicEvent {
    fn id(&self) -> &i32 {
        &self.id
    }
}

pub static DYNAMICEVENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicEvent",
    flags: MemberInfoFlags::new(32841),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DynamicEvent as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Id",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(DynamicEvent, id),
            },
        ],
    }),
    array_type: Some(DYNAMICEVENT_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for DynamicEvent {
    fn type_info(&self) -> &'static TypeInfo {
        DYNAMICEVENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static DYNAMICEVENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicEvent-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("DynamicEvent"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EventConnection {
    pub source: Option<Arc<Mutex<dyn super::core::DataContainerTrait>>>,
    pub target: Option<Arc<Mutex<dyn super::core::DataContainerTrait>>>,
    pub source_event: EventSpec,
    pub target_event: EventSpec,
    pub target_type: EventConnectionTargetType,
}

pub trait EventConnectionTrait: TypeObject {
    fn source(&self) -> &Option<Arc<Mutex<dyn super::core::DataContainerTrait>>>;
    fn target(&self) -> &Option<Arc<Mutex<dyn super::core::DataContainerTrait>>>;
    fn source_event(&self) -> &EventSpec;
    fn target_event(&self) -> &EventSpec;
    fn target_type(&self) -> &EventConnectionTargetType;
}

impl EventConnectionTrait for EventConnection {
    fn source(&self) -> &Option<Arc<Mutex<dyn super::core::DataContainerTrait>>> {
        &self.source
    }
    fn target(&self) -> &Option<Arc<Mutex<dyn super::core::DataContainerTrait>>> {
        &self.target
    }
    fn source_event(&self) -> &EventSpec {
        &self.source_event
    }
    fn target_event(&self) -> &EventSpec {
        &self.target_event
    }
    fn target_type(&self) -> &EventConnectionTargetType {
        &self.target_type
    }
}

pub static EVENTCONNECTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventConnection",
    flags: MemberInfoFlags::new(73),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EventConnection as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Source",
                flags: MemberInfoFlags::new(0),
                field_type: "DataContainer",
                rust_offset: offset_of!(EventConnection, source),
            },
            FieldInfoData {
                name: "Target",
                flags: MemberInfoFlags::new(0),
                field_type: "DataContainer",
                rust_offset: offset_of!(EventConnection, target),
            },
            FieldInfoData {
                name: "SourceEvent",
                flags: MemberInfoFlags::new(0),
                field_type: "EventSpec",
                rust_offset: offset_of!(EventConnection, source_event),
            },
            FieldInfoData {
                name: "TargetEvent",
                flags: MemberInfoFlags::new(0),
                field_type: "EventSpec",
                rust_offset: offset_of!(EventConnection, target_event),
            },
            FieldInfoData {
                name: "TargetType",
                flags: MemberInfoFlags::new(0),
                field_type: "EventConnectionTargetType",
                rust_offset: offset_of!(EventConnection, target_type),
            },
        ],
    }),
    array_type: Some(EVENTCONNECTION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EventConnection {
    fn type_info(&self) -> &'static TypeInfo {
        EVENTCONNECTION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static EVENTCONNECTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventConnection-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EventConnection"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum EventConnectionTargetType {
    #[default]
    EventConnectionTargetType_Invalid = 0,
    EventConnectionTargetType_ClientAndServer = 1,
    EventConnectionTargetType_Client = 2,
    EventConnectionTargetType_Server = 3,
    EventConnectionTargetType_NetworkedClient = 4,
    EventConnectionTargetType_NetworkedClientAndServer = 5,
}

pub static EVENTCONNECTIONTARGETTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventConnectionTargetType",
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(EVENTCONNECTIONTARGETTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for EventConnectionTargetType {
    fn type_info(&self) -> &'static TypeInfo {
        EVENTCONNECTIONTARGETTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static EVENTCONNECTIONTARGETTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventConnectionTargetType-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EventConnectionTargetType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EventSpec {
    pub id: i32,
}

pub trait EventSpecTrait: TypeObject {
    fn id(&self) -> &i32;
}

impl EventSpecTrait for EventSpec {
    fn id(&self) -> &i32 {
        &self.id
    }
}

pub static EVENTSPEC_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventSpec",
    flags: MemberInfoFlags::new(32841),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EventSpec as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Id",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(EventSpec, id),
            },
        ],
    }),
    array_type: Some(EVENTSPEC_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for EventSpec {
    fn type_info(&self) -> &'static TypeInfo {
        EVENTSPEC_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static EVENTSPEC_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventSpec-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EventSpec"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CompareAxisAlignedBoxEntityData {
    pub _glacier_base: CompareEntityBaseData,
    pub a: super::core::AxisAlignedBox,
    pub b: super::core::AxisAlignedBox,
}

pub trait CompareAxisAlignedBoxEntityDataTrait: CompareEntityBaseDataTrait {
    fn a(&self) -> &super::core::AxisAlignedBox;
    fn b(&self) -> &super::core::AxisAlignedBox;
}

impl CompareAxisAlignedBoxEntityDataTrait for CompareAxisAlignedBoxEntityData {
    fn a(&self) -> &super::core::AxisAlignedBox {
        &self.a
    }
    fn b(&self) -> &super::core::AxisAlignedBox {
        &self.b
    }
}

impl CompareEntityBaseDataTrait for CompareAxisAlignedBoxEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn trigger_on_property_change(&self) -> &bool {
        self._glacier_base.trigger_on_property_change()
    }
    fn trigger_on_start(&self) -> &bool {
        self._glacier_base.trigger_on_start()
    }
    fn always_send(&self) -> &bool {
        self._glacier_base.always_send()
    }
}

impl EntityDataTrait for CompareAxisAlignedBoxEntityData {
}

impl GameObjectDataTrait for CompareAxisAlignedBoxEntityData {
}

impl super::core::DataBusPeerTrait for CompareAxisAlignedBoxEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for CompareAxisAlignedBoxEntityData {
}

impl super::core::DataContainerTrait for CompareAxisAlignedBoxEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static COMPAREAXISALIGNEDBOXENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareAxisAlignedBoxEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(COMPAREENTITYBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareAxisAlignedBoxEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "A",
                flags: MemberInfoFlags::new(0),
                field_type: "AxisAlignedBox",
                rust_offset: offset_of!(CompareAxisAlignedBoxEntityData, a),
            },
            FieldInfoData {
                name: "B",
                flags: MemberInfoFlags::new(0),
                field_type: "AxisAlignedBox",
                rust_offset: offset_of!(CompareAxisAlignedBoxEntityData, b),
            },
        ],
    }),
    array_type: Some(COMPAREAXISALIGNEDBOXENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CompareAxisAlignedBoxEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        COMPAREAXISALIGNEDBOXENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static COMPAREAXISALIGNEDBOXENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareAxisAlignedBoxEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareAxisAlignedBoxEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CompareUintRangeEntityData {
    pub _glacier_base: CompareEntityBaseData,
    pub value: u32,
    pub min: u32,
    pub max: u32,
}

pub trait CompareUintRangeEntityDataTrait: CompareEntityBaseDataTrait {
    fn value(&self) -> &u32;
    fn min(&self) -> &u32;
    fn max(&self) -> &u32;
}

impl CompareUintRangeEntityDataTrait for CompareUintRangeEntityData {
    fn value(&self) -> &u32 {
        &self.value
    }
    fn min(&self) -> &u32 {
        &self.min
    }
    fn max(&self) -> &u32 {
        &self.max
    }
}

impl CompareEntityBaseDataTrait for CompareUintRangeEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn trigger_on_property_change(&self) -> &bool {
        self._glacier_base.trigger_on_property_change()
    }
    fn trigger_on_start(&self) -> &bool {
        self._glacier_base.trigger_on_start()
    }
    fn always_send(&self) -> &bool {
        self._glacier_base.always_send()
    }
}

impl EntityDataTrait for CompareUintRangeEntityData {
}

impl GameObjectDataTrait for CompareUintRangeEntityData {
}

impl super::core::DataBusPeerTrait for CompareUintRangeEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for CompareUintRangeEntityData {
}

impl super::core::DataContainerTrait for CompareUintRangeEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static COMPAREUINTRANGEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareUintRangeEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(COMPAREENTITYBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareUintRangeEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(CompareUintRangeEntityData, value),
            },
            FieldInfoData {
                name: "Min",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(CompareUintRangeEntityData, min),
            },
            FieldInfoData {
                name: "Max",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(CompareUintRangeEntityData, max),
            },
        ],
    }),
    array_type: Some(COMPAREUINTRANGEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CompareUintRangeEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        COMPAREUINTRANGEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static COMPAREUINTRANGEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareUintRangeEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareUintRangeEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CompareIntRangeEntityData {
    pub _glacier_base: CompareEntityBaseData,
    pub value: i32,
    pub min: i32,
    pub max: i32,
}

pub trait CompareIntRangeEntityDataTrait: CompareEntityBaseDataTrait {
    fn value(&self) -> &i32;
    fn min(&self) -> &i32;
    fn max(&self) -> &i32;
}

impl CompareIntRangeEntityDataTrait for CompareIntRangeEntityData {
    fn value(&self) -> &i32 {
        &self.value
    }
    fn min(&self) -> &i32 {
        &self.min
    }
    fn max(&self) -> &i32 {
        &self.max
    }
}

impl CompareEntityBaseDataTrait for CompareIntRangeEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn trigger_on_property_change(&self) -> &bool {
        self._glacier_base.trigger_on_property_change()
    }
    fn trigger_on_start(&self) -> &bool {
        self._glacier_base.trigger_on_start()
    }
    fn always_send(&self) -> &bool {
        self._glacier_base.always_send()
    }
}

impl EntityDataTrait for CompareIntRangeEntityData {
}

impl GameObjectDataTrait for CompareIntRangeEntityData {
}

impl super::core::DataBusPeerTrait for CompareIntRangeEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for CompareIntRangeEntityData {
}

impl super::core::DataContainerTrait for CompareIntRangeEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static COMPAREINTRANGEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareIntRangeEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(COMPAREENTITYBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareIntRangeEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CompareIntRangeEntityData, value),
            },
            FieldInfoData {
                name: "Min",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CompareIntRangeEntityData, min),
            },
            FieldInfoData {
                name: "Max",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CompareIntRangeEntityData, max),
            },
        ],
    }),
    array_type: Some(COMPAREINTRANGEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CompareIntRangeEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        COMPAREINTRANGEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static COMPAREINTRANGEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareIntRangeEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareIntRangeEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CompareFloatRangeEntityData {
    pub _glacier_base: CompareEntityBaseData,
    pub value: f32,
    pub min: f32,
    pub max: f32,
}

pub trait CompareFloatRangeEntityDataTrait: CompareEntityBaseDataTrait {
    fn value(&self) -> &f32;
    fn min(&self) -> &f32;
    fn max(&self) -> &f32;
}

impl CompareFloatRangeEntityDataTrait for CompareFloatRangeEntityData {
    fn value(&self) -> &f32 {
        &self.value
    }
    fn min(&self) -> &f32 {
        &self.min
    }
    fn max(&self) -> &f32 {
        &self.max
    }
}

impl CompareEntityBaseDataTrait for CompareFloatRangeEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn trigger_on_property_change(&self) -> &bool {
        self._glacier_base.trigger_on_property_change()
    }
    fn trigger_on_start(&self) -> &bool {
        self._glacier_base.trigger_on_start()
    }
    fn always_send(&self) -> &bool {
        self._glacier_base.always_send()
    }
}

impl EntityDataTrait for CompareFloatRangeEntityData {
}

impl GameObjectDataTrait for CompareFloatRangeEntityData {
}

impl super::core::DataBusPeerTrait for CompareFloatRangeEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for CompareFloatRangeEntityData {
}

impl super::core::DataContainerTrait for CompareFloatRangeEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static COMPAREFLOATRANGEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareFloatRangeEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(COMPAREENTITYBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareFloatRangeEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CompareFloatRangeEntityData, value),
            },
            FieldInfoData {
                name: "Min",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CompareFloatRangeEntityData, min),
            },
            FieldInfoData {
                name: "Max",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CompareFloatRangeEntityData, max),
            },
        ],
    }),
    array_type: Some(COMPAREFLOATRANGEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CompareFloatRangeEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        COMPAREFLOATRANGEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static COMPAREFLOATRANGEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareFloatRangeEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareFloatRangeEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CompareStringEntityData {
    pub _glacier_base: CompareEntityBaseData,
    pub a: String,
    pub b: String,
}

pub trait CompareStringEntityDataTrait: CompareEntityBaseDataTrait {
    fn a(&self) -> &String;
    fn b(&self) -> &String;
}

impl CompareStringEntityDataTrait for CompareStringEntityData {
    fn a(&self) -> &String {
        &self.a
    }
    fn b(&self) -> &String {
        &self.b
    }
}

impl CompareEntityBaseDataTrait for CompareStringEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn trigger_on_property_change(&self) -> &bool {
        self._glacier_base.trigger_on_property_change()
    }
    fn trigger_on_start(&self) -> &bool {
        self._glacier_base.trigger_on_start()
    }
    fn always_send(&self) -> &bool {
        self._glacier_base.always_send()
    }
}

impl EntityDataTrait for CompareStringEntityData {
}

impl GameObjectDataTrait for CompareStringEntityData {
}

impl super::core::DataBusPeerTrait for CompareStringEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for CompareStringEntityData {
}

impl super::core::DataContainerTrait for CompareStringEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static COMPARESTRINGENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareStringEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(COMPAREENTITYBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareStringEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "A",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(CompareStringEntityData, a),
            },
            FieldInfoData {
                name: "B",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(CompareStringEntityData, b),
            },
        ],
    }),
    array_type: Some(COMPARESTRINGENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CompareStringEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        COMPARESTRINGENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static COMPARESTRINGENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareStringEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareStringEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CompareVec4EntityData {
    pub _glacier_base: CompareEntityBaseData,
    pub value_a: super::core::Vec4,
    pub value_b: super::core::Vec4,
    pub tolerance: f32,
}

pub trait CompareVec4EntityDataTrait: CompareEntityBaseDataTrait {
    fn value_a(&self) -> &super::core::Vec4;
    fn value_b(&self) -> &super::core::Vec4;
    fn tolerance(&self) -> &f32;
}

impl CompareVec4EntityDataTrait for CompareVec4EntityData {
    fn value_a(&self) -> &super::core::Vec4 {
        &self.value_a
    }
    fn value_b(&self) -> &super::core::Vec4 {
        &self.value_b
    }
    fn tolerance(&self) -> &f32 {
        &self.tolerance
    }
}

impl CompareEntityBaseDataTrait for CompareVec4EntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn trigger_on_property_change(&self) -> &bool {
        self._glacier_base.trigger_on_property_change()
    }
    fn trigger_on_start(&self) -> &bool {
        self._glacier_base.trigger_on_start()
    }
    fn always_send(&self) -> &bool {
        self._glacier_base.always_send()
    }
}

impl EntityDataTrait for CompareVec4EntityData {
}

impl GameObjectDataTrait for CompareVec4EntityData {
}

impl super::core::DataBusPeerTrait for CompareVec4EntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for CompareVec4EntityData {
}

impl super::core::DataContainerTrait for CompareVec4EntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static COMPAREVEC4ENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareVec4EntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(COMPAREENTITYBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareVec4EntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ValueA",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(CompareVec4EntityData, value_a),
            },
            FieldInfoData {
                name: "ValueB",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(CompareVec4EntityData, value_b),
            },
            FieldInfoData {
                name: "Tolerance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CompareVec4EntityData, tolerance),
            },
        ],
    }),
    array_type: Some(COMPAREVEC4ENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CompareVec4EntityData {
    fn type_info(&self) -> &'static TypeInfo {
        COMPAREVEC4ENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static COMPAREVEC4ENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareVec4EntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareVec4EntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CompareVec3EntityData {
    pub _glacier_base: CompareEntityBaseData,
    pub value_a: super::core::Vec3,
    pub value_b: super::core::Vec3,
    pub tolerance: f32,
}

pub trait CompareVec3EntityDataTrait: CompareEntityBaseDataTrait {
    fn value_a(&self) -> &super::core::Vec3;
    fn value_b(&self) -> &super::core::Vec3;
    fn tolerance(&self) -> &f32;
}

impl CompareVec3EntityDataTrait for CompareVec3EntityData {
    fn value_a(&self) -> &super::core::Vec3 {
        &self.value_a
    }
    fn value_b(&self) -> &super::core::Vec3 {
        &self.value_b
    }
    fn tolerance(&self) -> &f32 {
        &self.tolerance
    }
}

impl CompareEntityBaseDataTrait for CompareVec3EntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn trigger_on_property_change(&self) -> &bool {
        self._glacier_base.trigger_on_property_change()
    }
    fn trigger_on_start(&self) -> &bool {
        self._glacier_base.trigger_on_start()
    }
    fn always_send(&self) -> &bool {
        self._glacier_base.always_send()
    }
}

impl EntityDataTrait for CompareVec3EntityData {
}

impl GameObjectDataTrait for CompareVec3EntityData {
}

impl super::core::DataBusPeerTrait for CompareVec3EntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for CompareVec3EntityData {
}

impl super::core::DataContainerTrait for CompareVec3EntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static COMPAREVEC3ENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareVec3EntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(COMPAREENTITYBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareVec3EntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ValueA",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(CompareVec3EntityData, value_a),
            },
            FieldInfoData {
                name: "ValueB",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(CompareVec3EntityData, value_b),
            },
            FieldInfoData {
                name: "Tolerance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CompareVec3EntityData, tolerance),
            },
        ],
    }),
    array_type: Some(COMPAREVEC3ENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CompareVec3EntityData {
    fn type_info(&self) -> &'static TypeInfo {
        COMPAREVEC3ENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static COMPAREVEC3ENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareVec3EntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareVec3EntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CompareFloatEntityData {
    pub _glacier_base: CompareEntityBaseData,
    pub a: f32,
    pub b: f32,
}

pub trait CompareFloatEntityDataTrait: CompareEntityBaseDataTrait {
    fn a(&self) -> &f32;
    fn b(&self) -> &f32;
}

impl CompareFloatEntityDataTrait for CompareFloatEntityData {
    fn a(&self) -> &f32 {
        &self.a
    }
    fn b(&self) -> &f32 {
        &self.b
    }
}

impl CompareEntityBaseDataTrait for CompareFloatEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn trigger_on_property_change(&self) -> &bool {
        self._glacier_base.trigger_on_property_change()
    }
    fn trigger_on_start(&self) -> &bool {
        self._glacier_base.trigger_on_start()
    }
    fn always_send(&self) -> &bool {
        self._glacier_base.always_send()
    }
}

impl EntityDataTrait for CompareFloatEntityData {
}

impl GameObjectDataTrait for CompareFloatEntityData {
}

impl super::core::DataBusPeerTrait for CompareFloatEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for CompareFloatEntityData {
}

impl super::core::DataContainerTrait for CompareFloatEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static COMPAREFLOATENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareFloatEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(COMPAREENTITYBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareFloatEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "A",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CompareFloatEntityData, a),
            },
            FieldInfoData {
                name: "B",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CompareFloatEntityData, b),
            },
        ],
    }),
    array_type: Some(COMPAREFLOATENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CompareFloatEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        COMPAREFLOATENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static COMPAREFLOATENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareFloatEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareFloatEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CompareUintEntityData {
    pub _glacier_base: CompareEntityBaseData,
    pub a: u32,
    pub b: u32,
}

pub trait CompareUintEntityDataTrait: CompareEntityBaseDataTrait {
    fn a(&self) -> &u32;
    fn b(&self) -> &u32;
}

impl CompareUintEntityDataTrait for CompareUintEntityData {
    fn a(&self) -> &u32 {
        &self.a
    }
    fn b(&self) -> &u32 {
        &self.b
    }
}

impl CompareEntityBaseDataTrait for CompareUintEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn trigger_on_property_change(&self) -> &bool {
        self._glacier_base.trigger_on_property_change()
    }
    fn trigger_on_start(&self) -> &bool {
        self._glacier_base.trigger_on_start()
    }
    fn always_send(&self) -> &bool {
        self._glacier_base.always_send()
    }
}

impl EntityDataTrait for CompareUintEntityData {
}

impl GameObjectDataTrait for CompareUintEntityData {
}

impl super::core::DataBusPeerTrait for CompareUintEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for CompareUintEntityData {
}

impl super::core::DataContainerTrait for CompareUintEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static COMPAREUINTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareUintEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(COMPAREENTITYBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareUintEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "A",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(CompareUintEntityData, a),
            },
            FieldInfoData {
                name: "B",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(CompareUintEntityData, b),
            },
        ],
    }),
    array_type: Some(COMPAREUINTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CompareUintEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        COMPAREUINTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static COMPAREUINTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareUintEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareUintEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CompareIntEntityData {
    pub _glacier_base: CompareEntityBaseData,
    pub a: i32,
    pub b: i32,
}

pub trait CompareIntEntityDataTrait: CompareEntityBaseDataTrait {
    fn a(&self) -> &i32;
    fn b(&self) -> &i32;
}

impl CompareIntEntityDataTrait for CompareIntEntityData {
    fn a(&self) -> &i32 {
        &self.a
    }
    fn b(&self) -> &i32 {
        &self.b
    }
}

impl CompareEntityBaseDataTrait for CompareIntEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn trigger_on_property_change(&self) -> &bool {
        self._glacier_base.trigger_on_property_change()
    }
    fn trigger_on_start(&self) -> &bool {
        self._glacier_base.trigger_on_start()
    }
    fn always_send(&self) -> &bool {
        self._glacier_base.always_send()
    }
}

impl EntityDataTrait for CompareIntEntityData {
}

impl GameObjectDataTrait for CompareIntEntityData {
}

impl super::core::DataBusPeerTrait for CompareIntEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for CompareIntEntityData {
}

impl super::core::DataContainerTrait for CompareIntEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static COMPAREINTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareIntEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(COMPAREENTITYBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareIntEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "A",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CompareIntEntityData, a),
            },
            FieldInfoData {
                name: "B",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CompareIntEntityData, b),
            },
        ],
    }),
    array_type: Some(COMPAREINTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CompareIntEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        COMPAREINTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static COMPAREINTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareIntEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareIntEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CompareBoolEntityData {
    pub _glacier_base: CompareEntityBaseData,
    pub bool: bool,
}

pub trait CompareBoolEntityDataTrait: CompareEntityBaseDataTrait {
    fn bool(&self) -> &bool;
}

impl CompareBoolEntityDataTrait for CompareBoolEntityData {
    fn bool(&self) -> &bool {
        &self.bool
    }
}

impl CompareEntityBaseDataTrait for CompareBoolEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn trigger_on_property_change(&self) -> &bool {
        self._glacier_base.trigger_on_property_change()
    }
    fn trigger_on_start(&self) -> &bool {
        self._glacier_base.trigger_on_start()
    }
    fn always_send(&self) -> &bool {
        self._glacier_base.always_send()
    }
}

impl EntityDataTrait for CompareBoolEntityData {
}

impl GameObjectDataTrait for CompareBoolEntityData {
}

impl super::core::DataBusPeerTrait for CompareBoolEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for CompareBoolEntityData {
}

impl super::core::DataContainerTrait for CompareBoolEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static COMPAREBOOLENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareBoolEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(COMPAREENTITYBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareBoolEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Bool",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CompareBoolEntityData, bool),
            },
        ],
    }),
    array_type: Some(COMPAREBOOLENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CompareBoolEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        COMPAREBOOLENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static COMPAREBOOLENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareBoolEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareBoolEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CompareEntityBaseData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub trigger_on_property_change: bool,
    pub trigger_on_start: bool,
    pub always_send: bool,
}

pub trait CompareEntityBaseDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn trigger_on_property_change(&self) -> &bool;
    fn trigger_on_start(&self) -> &bool;
    fn always_send(&self) -> &bool;
}

impl CompareEntityBaseDataTrait for CompareEntityBaseData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn trigger_on_property_change(&self) -> &bool {
        &self.trigger_on_property_change
    }
    fn trigger_on_start(&self) -> &bool {
        &self.trigger_on_start
    }
    fn always_send(&self) -> &bool {
        &self.always_send
    }
}

impl EntityDataTrait for CompareEntityBaseData {
}

impl GameObjectDataTrait for CompareEntityBaseData {
}

impl super::core::DataBusPeerTrait for CompareEntityBaseData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for CompareEntityBaseData {
}

impl super::core::DataContainerTrait for CompareEntityBaseData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static COMPAREENTITYBASEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareEntityBaseData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareEntityBaseData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(CompareEntityBaseData, realm),
            },
            FieldInfoData {
                name: "TriggerOnPropertyChange",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CompareEntityBaseData, trigger_on_property_change),
            },
            FieldInfoData {
                name: "TriggerOnStart",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CompareEntityBaseData, trigger_on_start),
            },
            FieldInfoData {
                name: "AlwaysSend",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CompareEntityBaseData, always_send),
            },
        ],
    }),
    array_type: Some(COMPAREENTITYBASEDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for CompareEntityBaseData {
    fn type_info(&self) -> &'static TypeInfo {
        COMPAREENTITYBASEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static COMPAREENTITYBASEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareEntityBaseData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareEntityBaseData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ClientProfilerData {
    pub _glacier_base: EntityData,
    pub profiler_name: String,
}

pub trait ClientProfilerDataTrait: EntityDataTrait {
    fn profiler_name(&self) -> &String;
}

impl ClientProfilerDataTrait for ClientProfilerData {
    fn profiler_name(&self) -> &String {
        &self.profiler_name
    }
}

impl EntityDataTrait for ClientProfilerData {
}

impl GameObjectDataTrait for ClientProfilerData {
}

impl super::core::DataBusPeerTrait for ClientProfilerData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for ClientProfilerData {
}

impl super::core::DataContainerTrait for ClientProfilerData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CLIENTPROFILERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClientProfilerData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ClientProfilerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ProfilerName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ClientProfilerData, profiler_name),
            },
        ],
    }),
    array_type: Some(CLIENTPROFILERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ClientProfilerData {
    fn type_info(&self) -> &'static TypeInfo {
        CLIENTPROFILERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CLIENTPROFILERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClientProfilerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ClientProfilerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ChildEffectEntityData {
    pub _glacier_base: SpatialEntityData,
    pub components: Vec<Option<Arc<Mutex<dyn GameObjectDataTrait>>>>,
    pub start_delay: f32,
    pub attach_to_spawn_surface: bool,
    pub enable: super::core::QualityScalableBool,
    pub override_draw_order: bool,
    pub keep_alive: bool,
}

pub trait ChildEffectEntityDataTrait: SpatialEntityDataTrait {
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn GameObjectDataTrait>>>>;
    fn start_delay(&self) -> &f32;
    fn attach_to_spawn_surface(&self) -> &bool;
    fn enable(&self) -> &super::core::QualityScalableBool;
    fn override_draw_order(&self) -> &bool;
    fn keep_alive(&self) -> &bool;
}

impl ChildEffectEntityDataTrait for ChildEffectEntityData {
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn GameObjectDataTrait>>>> {
        &self.components
    }
    fn start_delay(&self) -> &f32 {
        &self.start_delay
    }
    fn attach_to_spawn_surface(&self) -> &bool {
        &self.attach_to_spawn_surface
    }
    fn enable(&self) -> &super::core::QualityScalableBool {
        &self.enable
    }
    fn override_draw_order(&self) -> &bool {
        &self.override_draw_order
    }
    fn keep_alive(&self) -> &bool {
        &self.keep_alive
    }
}

impl SpatialEntityDataTrait for ChildEffectEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
}

impl EntityDataTrait for ChildEffectEntityData {
}

impl GameObjectDataTrait for ChildEffectEntityData {
}

impl super::core::DataBusPeerTrait for ChildEffectEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for ChildEffectEntityData {
}

impl super::core::DataContainerTrait for ChildEffectEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CHILDEFFECTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ChildEffectEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SPATIALENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ChildEffectEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Components",
                flags: MemberInfoFlags::new(144),
                field_type: "GameObjectData-Array",
                rust_offset: offset_of!(ChildEffectEntityData, components),
            },
            FieldInfoData {
                name: "StartDelay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChildEffectEntityData, start_delay),
            },
            FieldInfoData {
                name: "AttachToSpawnSurface",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ChildEffectEntityData, attach_to_spawn_surface),
            },
            FieldInfoData {
                name: "Enable",
                flags: MemberInfoFlags::new(0),
                field_type: "QualityScalableBool",
                rust_offset: offset_of!(ChildEffectEntityData, enable),
            },
            FieldInfoData {
                name: "OverrideDrawOrder",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ChildEffectEntityData, override_draw_order),
            },
            FieldInfoData {
                name: "KeepAlive",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ChildEffectEntityData, keep_alive),
            },
        ],
    }),
    array_type: Some(CHILDEFFECTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ChildEffectEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CHILDEFFECTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CHILDEFFECTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ChildEffectEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ChildEffectEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum BundleType {
    #[default]
    BundleType_SubLevel = 0,
    BundleType_BlueprintBundle = 1,
    BundleType_SharedBundle = 2,
}

pub static BUNDLETYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BundleType",
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(BUNDLETYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for BundleType {
    fn type_info(&self) -> &'static TypeInfo {
        BUNDLETYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static BUNDLETYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BundleType-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("BundleType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AutoAssetCollector {
    pub _glacier_base: super::core::DataContainer,
    pub assets: Vec<Option<Arc<Mutex<dyn super::core::AssetTrait>>>>,
    pub auto_collect_minimum_usage_percentage: f32,
}

pub trait AutoAssetCollectorTrait: super::core::DataContainerTrait {
    fn assets(&self) -> &Vec<Option<Arc<Mutex<dyn super::core::AssetTrait>>>>;
    fn auto_collect_minimum_usage_percentage(&self) -> &f32;
}

impl AutoAssetCollectorTrait for AutoAssetCollector {
    fn assets(&self) -> &Vec<Option<Arc<Mutex<dyn super::core::AssetTrait>>>> {
        &self.assets
    }
    fn auto_collect_minimum_usage_percentage(&self) -> &f32 {
        &self.auto_collect_minimum_usage_percentage
    }
}

impl super::core::DataContainerTrait for AutoAssetCollector {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static AUTOASSETCOLLECTOR_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AutoAssetCollector",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AutoAssetCollector as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Assets",
                flags: MemberInfoFlags::new(144),
                field_type: "Asset-Array",
                rust_offset: offset_of!(AutoAssetCollector, assets),
            },
            FieldInfoData {
                name: "AutoCollectMinimumUsagePercentage",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AutoAssetCollector, auto_collect_minimum_usage_percentage),
            },
        ],
    }),
    array_type: Some(AUTOASSETCOLLECTOR_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AutoAssetCollector {
    fn type_info(&self) -> &'static TypeInfo {
        AUTOASSETCOLLECTOR_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static AUTOASSETCOLLECTOR_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AutoAssetCollector-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("AutoAssetCollector"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct NetworkedObjectsAsset {
    pub _glacier_base: super::core::Asset,
    pub objects: Vec<Option<Arc<Mutex<dyn super::core::DataContainerTrait>>>>,
}

pub trait NetworkedObjectsAssetTrait: super::core::AssetTrait {
    fn objects(&self) -> &Vec<Option<Arc<Mutex<dyn super::core::DataContainerTrait>>>>;
}

impl NetworkedObjectsAssetTrait for NetworkedObjectsAsset {
    fn objects(&self) -> &Vec<Option<Arc<Mutex<dyn super::core::DataContainerTrait>>>> {
        &self.objects
    }
}

impl super::core::AssetTrait for NetworkedObjectsAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for NetworkedObjectsAsset {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static NETWORKEDOBJECTSASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NetworkedObjectsAsset",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<NetworkedObjectsAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Objects",
                flags: MemberInfoFlags::new(144),
                field_type: "DataContainer-Array",
                rust_offset: offset_of!(NetworkedObjectsAsset, objects),
            },
        ],
    }),
    array_type: Some(NETWORKEDOBJECTSASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for NetworkedObjectsAsset {
    fn type_info(&self) -> &'static TypeInfo {
        NETWORKEDOBJECTSASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static NETWORKEDOBJECTSASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NetworkedObjectsAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("NetworkedObjectsAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct NetworkRegistryAsset {
    pub _glacier_base: super::core::Asset,
    pub objects: Vec<Option<Arc<Mutex<dyn super::core::DataContainerTrait>>>>,
    pub checksum: u32,
}

pub trait NetworkRegistryAssetTrait: super::core::AssetTrait {
    fn objects(&self) -> &Vec<Option<Arc<Mutex<dyn super::core::DataContainerTrait>>>>;
    fn checksum(&self) -> &u32;
}

impl NetworkRegistryAssetTrait for NetworkRegistryAsset {
    fn objects(&self) -> &Vec<Option<Arc<Mutex<dyn super::core::DataContainerTrait>>>> {
        &self.objects
    }
    fn checksum(&self) -> &u32 {
        &self.checksum
    }
}

impl super::core::AssetTrait for NetworkRegistryAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for NetworkRegistryAsset {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static NETWORKREGISTRYASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NetworkRegistryAsset",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<NetworkRegistryAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Objects",
                flags: MemberInfoFlags::new(144),
                field_type: "DataContainer-Array",
                rust_offset: offset_of!(NetworkRegistryAsset, objects),
            },
            FieldInfoData {
                name: "Checksum",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(NetworkRegistryAsset, checksum),
            },
        ],
    }),
    array_type: Some(NETWORKREGISTRYASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for NetworkRegistryAsset {
    fn type_info(&self) -> &'static TypeInfo {
        NETWORKREGISTRYASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static NETWORKREGISTRYASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NetworkRegistryAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("NetworkRegistryAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BundleHeapInfo {
    pub heap_type: BundleHeapType,
    pub initial_size: u32,
    pub allow_grow: bool,
}

pub trait BundleHeapInfoTrait: TypeObject {
    fn heap_type(&self) -> &BundleHeapType;
    fn initial_size(&self) -> &u32;
    fn allow_grow(&self) -> &bool;
}

impl BundleHeapInfoTrait for BundleHeapInfo {
    fn heap_type(&self) -> &BundleHeapType {
        &self.heap_type
    }
    fn initial_size(&self) -> &u32 {
        &self.initial_size
    }
    fn allow_grow(&self) -> &bool {
        &self.allow_grow
    }
}

pub static BUNDLEHEAPINFO_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BundleHeapInfo",
    flags: MemberInfoFlags::new(36937),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BundleHeapInfo as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "HeapType",
                flags: MemberInfoFlags::new(0),
                field_type: "BundleHeapType",
                rust_offset: offset_of!(BundleHeapInfo, heap_type),
            },
            FieldInfoData {
                name: "InitialSize",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(BundleHeapInfo, initial_size),
            },
            FieldInfoData {
                name: "AllowGrow",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BundleHeapInfo, allow_grow),
            },
        ],
    }),
    array_type: Some(BUNDLEHEAPINFO_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for BundleHeapInfo {
    fn type_info(&self) -> &'static TypeInfo {
        BUNDLEHEAPINFO_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static BUNDLEHEAPINFO_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BundleHeapInfo-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("BundleHeapInfo"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum BundleHeapType {
    #[default]
    BundleHeapType_OwnWithParentSmallblock = 0,
    BundleHeapType_OwnWithSmallblock = 1,
    BundleHeapType_OwnWithoutSmallblock = 2,
    BundleHeapType_Parent = 3,
    BundleHeapType_Level = 4,
    BundleHeapType_Global = 5,
    BundleHeapType_Null = 6,
}

pub static BUNDLEHEAPTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BundleHeapType",
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(BUNDLEHEAPTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for BundleHeapType {
    fn type_info(&self) -> &'static TypeInfo {
        BUNDLEHEAPTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static BUNDLEHEAPTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BundleHeapType-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("BundleHeapType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BundleSettingsInfo {
    pub group_identifier: u32,
    pub group_name: String,
}

pub trait BundleSettingsInfoTrait: TypeObject {
    fn group_identifier(&self) -> &u32;
    fn group_name(&self) -> &String;
}

impl BundleSettingsInfoTrait for BundleSettingsInfo {
    fn group_identifier(&self) -> &u32 {
        &self.group_identifier
    }
    fn group_name(&self) -> &String {
        &self.group_name
    }
}

pub static BUNDLESETTINGSINFO_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BundleSettingsInfo",
    flags: MemberInfoFlags::new(73),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BundleSettingsInfo as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "GroupIdentifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(BundleSettingsInfo, group_identifier),
            },
            FieldInfoData {
                name: "GroupName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(BundleSettingsInfo, group_name),
            },
        ],
    }),
    array_type: Some(BUNDLESETTINGSINFO_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BundleSettingsInfo {
    fn type_info(&self) -> &'static TypeInfo {
        BUNDLESETTINGSINFO_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static BUNDLESETTINGSINFO_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BundleSettingsInfo-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("BundleSettingsInfo"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MeshOperationData {
    pub _glacier_base: super::core::DataContainer,
}

pub trait MeshOperationDataTrait: super::core::DataContainerTrait {
}

impl MeshOperationDataTrait for MeshOperationData {
}

impl super::core::DataContainerTrait for MeshOperationData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static MESHOPERATIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MeshOperationData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MeshOperationData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(MESHOPERATIONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MeshOperationData {
    fn type_info(&self) -> &'static TypeInfo {
        MESHOPERATIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static MESHOPERATIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MeshOperationData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("MeshOperationData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SkeletonBaseAsset {
    pub _glacier_base: super::core::Asset,
}

pub trait SkeletonBaseAssetTrait: super::core::AssetTrait {
}

impl SkeletonBaseAssetTrait for SkeletonBaseAsset {
}

impl super::core::AssetTrait for SkeletonBaseAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for SkeletonBaseAsset {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SKELETONBASEASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SkeletonBaseAsset",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SkeletonBaseAsset as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SKELETONBASEASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SkeletonBaseAsset {
    fn type_info(&self) -> &'static TypeInfo {
        SKELETONBASEASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SKELETONBASEASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SkeletonBaseAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SkeletonBaseAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TransformPartPropertyTrackData {
    pub _glacier_base: PropertyTrackData,
    pub transform_part: TransformPart,
    pub pre_infinity: CurveInfinityType,
    pub post_infinity: CurveInfinityType,
    pub values: Vec<TransformPartPropertyKey>,
    pub evaluator_fps: f32,
    pub weighted: bool,
    pub key_start_index: u32,
    pub key_count: u32,
    pub is_static: bool,
    pub resource: glacier_reflect::builtin::ResourceRef,
}

pub trait TransformPartPropertyTrackDataTrait: PropertyTrackDataTrait {
    fn transform_part(&self) -> &TransformPart;
    fn pre_infinity(&self) -> &CurveInfinityType;
    fn post_infinity(&self) -> &CurveInfinityType;
    fn values(&self) -> &Vec<TransformPartPropertyKey>;
    fn evaluator_fps(&self) -> &f32;
    fn weighted(&self) -> &bool;
    fn key_start_index(&self) -> &u32;
    fn key_count(&self) -> &u32;
    fn is_static(&self) -> &bool;
    fn resource(&self) -> &glacier_reflect::builtin::ResourceRef;
}

impl TransformPartPropertyTrackDataTrait for TransformPartPropertyTrackData {
    fn transform_part(&self) -> &TransformPart {
        &self.transform_part
    }
    fn pre_infinity(&self) -> &CurveInfinityType {
        &self.pre_infinity
    }
    fn post_infinity(&self) -> &CurveInfinityType {
        &self.post_infinity
    }
    fn values(&self) -> &Vec<TransformPartPropertyKey> {
        &self.values
    }
    fn evaluator_fps(&self) -> &f32 {
        &self.evaluator_fps
    }
    fn weighted(&self) -> &bool {
        &self.weighted
    }
    fn key_start_index(&self) -> &u32 {
        &self.key_start_index
    }
    fn key_count(&self) -> &u32 {
        &self.key_count
    }
    fn is_static(&self) -> &bool {
        &self.is_static
    }
    fn resource(&self) -> &glacier_reflect::builtin::ResourceRef {
        &self.resource
    }
}

impl PropertyTrackDataTrait for TransformPartPropertyTrackData {
    fn id(&self) -> &i32 {
        self._glacier_base.id()
    }
    fn times(&self) -> &Vec<i32> {
        self._glacier_base.times()
    }
}

impl super::core::DataContainerTrait for TransformPartPropertyTrackData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static TRANSFORMPARTPROPERTYTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformPartPropertyTrackData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PROPERTYTRACKDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformPartPropertyTrackData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "TransformPart",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformPart",
                rust_offset: offset_of!(TransformPartPropertyTrackData, transform_part),
            },
            FieldInfoData {
                name: "PreInfinity",
                flags: MemberInfoFlags::new(0),
                field_type: "CurveInfinityType",
                rust_offset: offset_of!(TransformPartPropertyTrackData, pre_infinity),
            },
            FieldInfoData {
                name: "PostInfinity",
                flags: MemberInfoFlags::new(0),
                field_type: "CurveInfinityType",
                rust_offset: offset_of!(TransformPartPropertyTrackData, post_infinity),
            },
            FieldInfoData {
                name: "Values",
                flags: MemberInfoFlags::new(144),
                field_type: "TransformPartPropertyKey-Array",
                rust_offset: offset_of!(TransformPartPropertyTrackData, values),
            },
            FieldInfoData {
                name: "EvaluatorFps",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TransformPartPropertyTrackData, evaluator_fps),
            },
            FieldInfoData {
                name: "Weighted",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TransformPartPropertyTrackData, weighted),
            },
            FieldInfoData {
                name: "KeyStartIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(TransformPartPropertyTrackData, key_start_index),
            },
            FieldInfoData {
                name: "KeyCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(TransformPartPropertyTrackData, key_count),
            },
            FieldInfoData {
                name: "IsStatic",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TransformPartPropertyTrackData, is_static),
            },
            FieldInfoData {
                name: "Resource",
                flags: MemberInfoFlags::new(0),
                field_type: "ResourceRef",
                rust_offset: offset_of!(TransformPartPropertyTrackData, resource),
            },
        ],
    }),
    array_type: Some(TRANSFORMPARTPROPERTYTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TransformPartPropertyTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMPARTPROPERTYTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static TRANSFORMPARTPROPERTYTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformPartPropertyTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TransformPartPropertyTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TransformPartPropertyKey {
    pub value: f32,
    pub in_anim_tangent_type: AnimTangentType,
    pub in_angle: f32,
    pub in_weight: f32,
    pub out_anim_tangent_type: AnimTangentType,
    pub out_angle: f32,
    pub out_weight: f32,
}

pub trait TransformPartPropertyKeyTrait: TypeObject {
    fn value(&self) -> &f32;
    fn in_anim_tangent_type(&self) -> &AnimTangentType;
    fn in_angle(&self) -> &f32;
    fn in_weight(&self) -> &f32;
    fn out_anim_tangent_type(&self) -> &AnimTangentType;
    fn out_angle(&self) -> &f32;
    fn out_weight(&self) -> &f32;
}

impl TransformPartPropertyKeyTrait for TransformPartPropertyKey {
    fn value(&self) -> &f32 {
        &self.value
    }
    fn in_anim_tangent_type(&self) -> &AnimTangentType {
        &self.in_anim_tangent_type
    }
    fn in_angle(&self) -> &f32 {
        &self.in_angle
    }
    fn in_weight(&self) -> &f32 {
        &self.in_weight
    }
    fn out_anim_tangent_type(&self) -> &AnimTangentType {
        &self.out_anim_tangent_type
    }
    fn out_angle(&self) -> &f32 {
        &self.out_angle
    }
    fn out_weight(&self) -> &f32 {
        &self.out_weight
    }
}

pub static TRANSFORMPARTPROPERTYKEY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformPartPropertyKey",
    flags: MemberInfoFlags::new(36937),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformPartPropertyKey as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TransformPartPropertyKey, value),
            },
            FieldInfoData {
                name: "InAnimTangentType",
                flags: MemberInfoFlags::new(0),
                field_type: "AnimTangentType",
                rust_offset: offset_of!(TransformPartPropertyKey, in_anim_tangent_type),
            },
            FieldInfoData {
                name: "InAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TransformPartPropertyKey, in_angle),
            },
            FieldInfoData {
                name: "InWeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TransformPartPropertyKey, in_weight),
            },
            FieldInfoData {
                name: "OutAnimTangentType",
                flags: MemberInfoFlags::new(0),
                field_type: "AnimTangentType",
                rust_offset: offset_of!(TransformPartPropertyKey, out_anim_tangent_type),
            },
            FieldInfoData {
                name: "OutAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TransformPartPropertyKey, out_angle),
            },
            FieldInfoData {
                name: "OutWeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TransformPartPropertyKey, out_weight),
            },
        ],
    }),
    array_type: Some(TRANSFORMPARTPROPERTYKEY_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for TransformPartPropertyKey {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMPARTPROPERTYKEY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static TRANSFORMPARTPROPERTYKEY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformPartPropertyKey-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TransformPartPropertyKey"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum AnimTangentType {
    #[default]
    kTangentFixed = 0,
    kTangentLinear = 1,
    kTangentFlat = 2,
    kTangentStep = 3,
    kTangentStepNext = 4,
    kTangentSlow = 5,
    kTangentFast = 6,
    kTangentSmooth = 7,
    kTangentClamped = 8,
}

pub static ANIMTANGENTTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimTangentType",
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(ANIMTANGENTTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AnimTangentType {
    fn type_info(&self) -> &'static TypeInfo {
        ANIMTANGENTTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ANIMTANGENTTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimTangentType-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("AnimTangentType"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CurveInfinityType {
    #[default]
    CurveInfinityType_Constant = 0,
    CurveInfinityType_Linear = 1,
    CurveInfinityType_Cycle = 2,
    CurveInfinityType_CycleWithOffset = 3,
    CurveInfinityType_Oscillate = 4,
}

pub static CURVEINFINITYTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CurveInfinityType",
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(CURVEINFINITYTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CurveInfinityType {
    fn type_info(&self) -> &'static TypeInfo {
        CURVEINFINITYTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CURVEINFINITYTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CurveInfinityType-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CurveInfinityType"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum TransformPart {
    #[default]
    TransformPart_TranslationX = 0,
    TransformPart_TranslationY = 1,
    TransformPart_TranslationZ = 2,
    TransformPart_RotationX = 3,
    TransformPart_RotationY = 4,
    TransformPart_RotationZ = 5,
}

pub static TRANSFORMPART_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformPart",
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(TRANSFORMPART_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for TransformPart {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMPART_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static TRANSFORMPART_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformPart-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TransformPart"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Vec4PropertyTrackData {
    pub _glacier_base: SimplePropertyTrackData,
    pub values: Vec<super::core::Vec4>,
}

pub trait Vec4PropertyTrackDataTrait: SimplePropertyTrackDataTrait {
    fn values(&self) -> &Vec<super::core::Vec4>;
}

impl Vec4PropertyTrackDataTrait for Vec4PropertyTrackData {
    fn values(&self) -> &Vec<super::core::Vec4> {
        &self.values
    }
}

impl SimplePropertyTrackDataTrait for Vec4PropertyTrackData {
    fn interpolation_type(&self) -> &InterpolationType {
        self._glacier_base.interpolation_type()
    }
}

impl PropertyTrackDataTrait for Vec4PropertyTrackData {
    fn id(&self) -> &i32 {
        self._glacier_base.id()
    }
    fn times(&self) -> &Vec<i32> {
        self._glacier_base.times()
    }
}

impl super::core::DataContainerTrait for Vec4PropertyTrackData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static VEC4PROPERTYTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec4PropertyTrackData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SIMPLEPROPERTYTRACKDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec4PropertyTrackData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Values",
                flags: MemberInfoFlags::new(144),
                field_type: "Vec4-Array",
                rust_offset: offset_of!(Vec4PropertyTrackData, values),
            },
        ],
    }),
    array_type: Some(VEC4PROPERTYTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for Vec4PropertyTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        VEC4PROPERTYTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VEC4PROPERTYTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec4PropertyTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec4PropertyTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Vec3PropertyTrackData {
    pub _glacier_base: SimplePropertyTrackData,
    pub values: Vec<super::core::Vec3>,
}

pub trait Vec3PropertyTrackDataTrait: SimplePropertyTrackDataTrait {
    fn values(&self) -> &Vec<super::core::Vec3>;
}

impl Vec3PropertyTrackDataTrait for Vec3PropertyTrackData {
    fn values(&self) -> &Vec<super::core::Vec3> {
        &self.values
    }
}

impl SimplePropertyTrackDataTrait for Vec3PropertyTrackData {
    fn interpolation_type(&self) -> &InterpolationType {
        self._glacier_base.interpolation_type()
    }
}

impl PropertyTrackDataTrait for Vec3PropertyTrackData {
    fn id(&self) -> &i32 {
        self._glacier_base.id()
    }
    fn times(&self) -> &Vec<i32> {
        self._glacier_base.times()
    }
}

impl super::core::DataContainerTrait for Vec3PropertyTrackData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static VEC3PROPERTYTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3PropertyTrackData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SIMPLEPROPERTYTRACKDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec3PropertyTrackData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Values",
                flags: MemberInfoFlags::new(144),
                field_type: "Vec3-Array",
                rust_offset: offset_of!(Vec3PropertyTrackData, values),
            },
        ],
    }),
    array_type: Some(VEC3PROPERTYTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for Vec3PropertyTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        VEC3PROPERTYTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VEC3PROPERTYTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3PropertyTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec3PropertyTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Vec2PropertyTrackData {
    pub _glacier_base: SimplePropertyTrackData,
    pub values: Vec<super::core::Vec2>,
}

pub trait Vec2PropertyTrackDataTrait: SimplePropertyTrackDataTrait {
    fn values(&self) -> &Vec<super::core::Vec2>;
}

impl Vec2PropertyTrackDataTrait for Vec2PropertyTrackData {
    fn values(&self) -> &Vec<super::core::Vec2> {
        &self.values
    }
}

impl SimplePropertyTrackDataTrait for Vec2PropertyTrackData {
    fn interpolation_type(&self) -> &InterpolationType {
        self._glacier_base.interpolation_type()
    }
}

impl PropertyTrackDataTrait for Vec2PropertyTrackData {
    fn id(&self) -> &i32 {
        self._glacier_base.id()
    }
    fn times(&self) -> &Vec<i32> {
        self._glacier_base.times()
    }
}

impl super::core::DataContainerTrait for Vec2PropertyTrackData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static VEC2PROPERTYTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec2PropertyTrackData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SIMPLEPROPERTYTRACKDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec2PropertyTrackData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Values",
                flags: MemberInfoFlags::new(144),
                field_type: "Vec2-Array",
                rust_offset: offset_of!(Vec2PropertyTrackData, values),
            },
        ],
    }),
    array_type: Some(VEC2PROPERTYTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for Vec2PropertyTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        VEC2PROPERTYTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VEC2PROPERTYTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec2PropertyTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec2PropertyTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TransformPropertyTrackData {
    pub _glacier_base: SimplePropertyTrackData,
    pub values: Vec<super::core::LinearTransform>,
}

pub trait TransformPropertyTrackDataTrait: SimplePropertyTrackDataTrait {
    fn values(&self) -> &Vec<super::core::LinearTransform>;
}

impl TransformPropertyTrackDataTrait for TransformPropertyTrackData {
    fn values(&self) -> &Vec<super::core::LinearTransform> {
        &self.values
    }
}

impl SimplePropertyTrackDataTrait for TransformPropertyTrackData {
    fn interpolation_type(&self) -> &InterpolationType {
        self._glacier_base.interpolation_type()
    }
}

impl PropertyTrackDataTrait for TransformPropertyTrackData {
    fn id(&self) -> &i32 {
        self._glacier_base.id()
    }
    fn times(&self) -> &Vec<i32> {
        self._glacier_base.times()
    }
}

impl super::core::DataContainerTrait for TransformPropertyTrackData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static TRANSFORMPROPERTYTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformPropertyTrackData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SIMPLEPROPERTYTRACKDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformPropertyTrackData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Values",
                flags: MemberInfoFlags::new(144),
                field_type: "LinearTransform-Array",
                rust_offset: offset_of!(TransformPropertyTrackData, values),
            },
        ],
    }),
    array_type: Some(TRANSFORMPROPERTYTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TransformPropertyTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMPROPERTYTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static TRANSFORMPROPERTYTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformPropertyTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TransformPropertyTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct IntPropertyTrackData {
    pub _glacier_base: SimplePropertyTrackData,
    pub values: Vec<i32>,
}

pub trait IntPropertyTrackDataTrait: SimplePropertyTrackDataTrait {
    fn values(&self) -> &Vec<i32>;
}

impl IntPropertyTrackDataTrait for IntPropertyTrackData {
    fn values(&self) -> &Vec<i32> {
        &self.values
    }
}

impl SimplePropertyTrackDataTrait for IntPropertyTrackData {
    fn interpolation_type(&self) -> &InterpolationType {
        self._glacier_base.interpolation_type()
    }
}

impl PropertyTrackDataTrait for IntPropertyTrackData {
    fn id(&self) -> &i32 {
        self._glacier_base.id()
    }
    fn times(&self) -> &Vec<i32> {
        self._glacier_base.times()
    }
}

impl super::core::DataContainerTrait for IntPropertyTrackData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static INTPROPERTYTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntPropertyTrackData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SIMPLEPROPERTYTRACKDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<IntPropertyTrackData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Values",
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(IntPropertyTrackData, values),
            },
        ],
    }),
    array_type: Some(INTPROPERTYTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for IntPropertyTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        INTPROPERTYTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static INTPROPERTYTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntPropertyTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("IntPropertyTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FloatPropertyTrackData {
    pub _glacier_base: SimplePropertyTrackData,
    pub values: Vec<f32>,
}

pub trait FloatPropertyTrackDataTrait: SimplePropertyTrackDataTrait {
    fn values(&self) -> &Vec<f32>;
}

impl FloatPropertyTrackDataTrait for FloatPropertyTrackData {
    fn values(&self) -> &Vec<f32> {
        &self.values
    }
}

impl SimplePropertyTrackDataTrait for FloatPropertyTrackData {
    fn interpolation_type(&self) -> &InterpolationType {
        self._glacier_base.interpolation_type()
    }
}

impl PropertyTrackDataTrait for FloatPropertyTrackData {
    fn id(&self) -> &i32 {
        self._glacier_base.id()
    }
    fn times(&self) -> &Vec<i32> {
        self._glacier_base.times()
    }
}

impl super::core::DataContainerTrait for FloatPropertyTrackData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static FLOATPROPERTYTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatPropertyTrackData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SIMPLEPROPERTYTRACKDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FloatPropertyTrackData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Values",
                flags: MemberInfoFlags::new(144),
                field_type: "Float32-Array",
                rust_offset: offset_of!(FloatPropertyTrackData, values),
            },
        ],
    }),
    array_type: Some(FLOATPROPERTYTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FloatPropertyTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        FLOATPROPERTYTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static FLOATPROPERTYTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatPropertyTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("FloatPropertyTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BoolPropertyTrackData {
    pub _glacier_base: SimplePropertyTrackData,
    pub values: Vec<bool>,
}

pub trait BoolPropertyTrackDataTrait: SimplePropertyTrackDataTrait {
    fn values(&self) -> &Vec<bool>;
}

impl BoolPropertyTrackDataTrait for BoolPropertyTrackData {
    fn values(&self) -> &Vec<bool> {
        &self.values
    }
}

impl SimplePropertyTrackDataTrait for BoolPropertyTrackData {
    fn interpolation_type(&self) -> &InterpolationType {
        self._glacier_base.interpolation_type()
    }
}

impl PropertyTrackDataTrait for BoolPropertyTrackData {
    fn id(&self) -> &i32 {
        self._glacier_base.id()
    }
    fn times(&self) -> &Vec<i32> {
        self._glacier_base.times()
    }
}

impl super::core::DataContainerTrait for BoolPropertyTrackData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static BOOLPROPERTYTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolPropertyTrackData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SIMPLEPROPERTYTRACKDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BoolPropertyTrackData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Values",
                flags: MemberInfoFlags::new(144),
                field_type: "Boolean-Array",
                rust_offset: offset_of!(BoolPropertyTrackData, values),
            },
        ],
    }),
    array_type: Some(BOOLPROPERTYTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BoolPropertyTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        BOOLPROPERTYTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static BOOLPROPERTYTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolPropertyTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("BoolPropertyTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SimplePropertyTrackData {
    pub _glacier_base: PropertyTrackData,
    pub interpolation_type: InterpolationType,
}

pub trait SimplePropertyTrackDataTrait: PropertyTrackDataTrait {
    fn interpolation_type(&self) -> &InterpolationType;
}

impl SimplePropertyTrackDataTrait for SimplePropertyTrackData {
    fn interpolation_type(&self) -> &InterpolationType {
        &self.interpolation_type
    }
}

impl PropertyTrackDataTrait for SimplePropertyTrackData {
    fn id(&self) -> &i32 {
        self._glacier_base.id()
    }
    fn times(&self) -> &Vec<i32> {
        self._glacier_base.times()
    }
}

impl super::core::DataContainerTrait for SimplePropertyTrackData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SIMPLEPROPERTYTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimplePropertyTrackData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PROPERTYTRACKDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SimplePropertyTrackData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "InterpolationType",
                flags: MemberInfoFlags::new(0),
                field_type: "InterpolationType",
                rust_offset: offset_of!(SimplePropertyTrackData, interpolation_type),
            },
        ],
    }),
    array_type: Some(SIMPLEPROPERTYTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SimplePropertyTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        SIMPLEPROPERTYTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SIMPLEPROPERTYTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimplePropertyTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SimplePropertyTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SequenceEntityData {
    pub _glacier_base: EntityData,
    pub events: Vec<SequenceEventData>,
    pub sequence_start_time: i32,
    pub sequence_length: i32,
    pub looping: bool,
    pub auto_start: bool,
    pub auto_play_first_frame: bool,
    pub play_in_reverse: bool,
    pub realm: super::core::Realm,
    pub property_tracks: Vec<Option<Arc<Mutex<dyn PropertyTrackDataTrait>>>>,
    pub custom_sequence_tracks: Vec<Option<Arc<Mutex<dyn CustomSequenceTrackDataTrait>>>>,
    pub client_update_pass: UpdatePass,
    pub server_update_pass: UpdatePass,
    pub external_time: f32,
    pub playback_speed: f32,
}

pub trait SequenceEntityDataTrait: EntityDataTrait {
    fn events(&self) -> &Vec<SequenceEventData>;
    fn sequence_start_time(&self) -> &i32;
    fn sequence_length(&self) -> &i32;
    fn looping(&self) -> &bool;
    fn auto_start(&self) -> &bool;
    fn auto_play_first_frame(&self) -> &bool;
    fn play_in_reverse(&self) -> &bool;
    fn realm(&self) -> &super::core::Realm;
    fn property_tracks(&self) -> &Vec<Option<Arc<Mutex<dyn PropertyTrackDataTrait>>>>;
    fn custom_sequence_tracks(&self) -> &Vec<Option<Arc<Mutex<dyn CustomSequenceTrackDataTrait>>>>;
    fn client_update_pass(&self) -> &UpdatePass;
    fn server_update_pass(&self) -> &UpdatePass;
    fn external_time(&self) -> &f32;
    fn playback_speed(&self) -> &f32;
}

impl SequenceEntityDataTrait for SequenceEntityData {
    fn events(&self) -> &Vec<SequenceEventData> {
        &self.events
    }
    fn sequence_start_time(&self) -> &i32 {
        &self.sequence_start_time
    }
    fn sequence_length(&self) -> &i32 {
        &self.sequence_length
    }
    fn looping(&self) -> &bool {
        &self.looping
    }
    fn auto_start(&self) -> &bool {
        &self.auto_start
    }
    fn auto_play_first_frame(&self) -> &bool {
        &self.auto_play_first_frame
    }
    fn play_in_reverse(&self) -> &bool {
        &self.play_in_reverse
    }
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn property_tracks(&self) -> &Vec<Option<Arc<Mutex<dyn PropertyTrackDataTrait>>>> {
        &self.property_tracks
    }
    fn custom_sequence_tracks(&self) -> &Vec<Option<Arc<Mutex<dyn CustomSequenceTrackDataTrait>>>> {
        &self.custom_sequence_tracks
    }
    fn client_update_pass(&self) -> &UpdatePass {
        &self.client_update_pass
    }
    fn server_update_pass(&self) -> &UpdatePass {
        &self.server_update_pass
    }
    fn external_time(&self) -> &f32 {
        &self.external_time
    }
    fn playback_speed(&self) -> &f32 {
        &self.playback_speed
    }
}

impl EntityDataTrait for SequenceEntityData {
}

impl GameObjectDataTrait for SequenceEntityData {
}

impl super::core::DataBusPeerTrait for SequenceEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for SequenceEntityData {
}

impl super::core::DataContainerTrait for SequenceEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SEQUENCEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SequenceEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SequenceEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Events",
                flags: MemberInfoFlags::new(144),
                field_type: "SequenceEventData-Array",
                rust_offset: offset_of!(SequenceEntityData, events),
            },
            FieldInfoData {
                name: "SequenceStartTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SequenceEntityData, sequence_start_time),
            },
            FieldInfoData {
                name: "SequenceLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SequenceEntityData, sequence_length),
            },
            FieldInfoData {
                name: "Looping",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SequenceEntityData, looping),
            },
            FieldInfoData {
                name: "AutoStart",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SequenceEntityData, auto_start),
            },
            FieldInfoData {
                name: "AutoPlayFirstFrame",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SequenceEntityData, auto_play_first_frame),
            },
            FieldInfoData {
                name: "PlayInReverse",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SequenceEntityData, play_in_reverse),
            },
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(SequenceEntityData, realm),
            },
            FieldInfoData {
                name: "PropertyTracks",
                flags: MemberInfoFlags::new(144),
                field_type: "PropertyTrackData-Array",
                rust_offset: offset_of!(SequenceEntityData, property_tracks),
            },
            FieldInfoData {
                name: "CustomSequenceTracks",
                flags: MemberInfoFlags::new(144),
                field_type: "CustomSequenceTrackData-Array",
                rust_offset: offset_of!(SequenceEntityData, custom_sequence_tracks),
            },
            FieldInfoData {
                name: "ClientUpdatePass",
                flags: MemberInfoFlags::new(0),
                field_type: "UpdatePass",
                rust_offset: offset_of!(SequenceEntityData, client_update_pass),
            },
            FieldInfoData {
                name: "ServerUpdatePass",
                flags: MemberInfoFlags::new(0),
                field_type: "UpdatePass",
                rust_offset: offset_of!(SequenceEntityData, server_update_pass),
            },
            FieldInfoData {
                name: "ExternalTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SequenceEntityData, external_time),
            },
            FieldInfoData {
                name: "PlaybackSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SequenceEntityData, playback_speed),
            },
        ],
    }),
    array_type: Some(SEQUENCEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SequenceEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SEQUENCEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SEQUENCEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SequenceEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SequenceEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CustomSequenceTrackData {
    pub _glacier_base: EntityData,
    pub track_name: String,
    pub input_link_map: Vec<Option<Arc<Mutex<dyn CustomSequenceTrackLinkMappingTrait>>>>,
    pub output_link_map: Vec<Option<Arc<Mutex<dyn CustomSequenceTrackLinkMappingTrait>>>>,
    pub event_map: Vec<Option<Arc<Mutex<dyn CustomSequenceTrackEventMappingTrait>>>>,
    pub source_property_map: Vec<Option<Arc<Mutex<dyn CustomSequenceTrackPropertyMappingTrait>>>>,
    pub target_property_map: Vec<Option<Arc<Mutex<dyn CustomSequenceTrackPropertyMappingTrait>>>>,
    pub source_and_target_property_map: Vec<Option<Arc<Mutex<dyn CustomSequenceTrackPropertyMappingTrait>>>>,
}

pub trait CustomSequenceTrackDataTrait: EntityDataTrait {
    fn track_name(&self) -> &String;
    fn input_link_map(&self) -> &Vec<Option<Arc<Mutex<dyn CustomSequenceTrackLinkMappingTrait>>>>;
    fn output_link_map(&self) -> &Vec<Option<Arc<Mutex<dyn CustomSequenceTrackLinkMappingTrait>>>>;
    fn event_map(&self) -> &Vec<Option<Arc<Mutex<dyn CustomSequenceTrackEventMappingTrait>>>>;
    fn source_property_map(&self) -> &Vec<Option<Arc<Mutex<dyn CustomSequenceTrackPropertyMappingTrait>>>>;
    fn target_property_map(&self) -> &Vec<Option<Arc<Mutex<dyn CustomSequenceTrackPropertyMappingTrait>>>>;
    fn source_and_target_property_map(&self) -> &Vec<Option<Arc<Mutex<dyn CustomSequenceTrackPropertyMappingTrait>>>>;
}

impl CustomSequenceTrackDataTrait for CustomSequenceTrackData {
    fn track_name(&self) -> &String {
        &self.track_name
    }
    fn input_link_map(&self) -> &Vec<Option<Arc<Mutex<dyn CustomSequenceTrackLinkMappingTrait>>>> {
        &self.input_link_map
    }
    fn output_link_map(&self) -> &Vec<Option<Arc<Mutex<dyn CustomSequenceTrackLinkMappingTrait>>>> {
        &self.output_link_map
    }
    fn event_map(&self) -> &Vec<Option<Arc<Mutex<dyn CustomSequenceTrackEventMappingTrait>>>> {
        &self.event_map
    }
    fn source_property_map(&self) -> &Vec<Option<Arc<Mutex<dyn CustomSequenceTrackPropertyMappingTrait>>>> {
        &self.source_property_map
    }
    fn target_property_map(&self) -> &Vec<Option<Arc<Mutex<dyn CustomSequenceTrackPropertyMappingTrait>>>> {
        &self.target_property_map
    }
    fn source_and_target_property_map(&self) -> &Vec<Option<Arc<Mutex<dyn CustomSequenceTrackPropertyMappingTrait>>>> {
        &self.source_and_target_property_map
    }
}

impl EntityDataTrait for CustomSequenceTrackData {
}

impl GameObjectDataTrait for CustomSequenceTrackData {
}

impl super::core::DataBusPeerTrait for CustomSequenceTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for CustomSequenceTrackData {
}

impl super::core::DataContainerTrait for CustomSequenceTrackData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CUSTOMSEQUENCETRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomSequenceTrackData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CustomSequenceTrackData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "TrackName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(CustomSequenceTrackData, track_name),
            },
            FieldInfoData {
                name: "InputLinkMap",
                flags: MemberInfoFlags::new(144),
                field_type: "CustomSequenceTrackLinkMapping-Array",
                rust_offset: offset_of!(CustomSequenceTrackData, input_link_map),
            },
            FieldInfoData {
                name: "OutputLinkMap",
                flags: MemberInfoFlags::new(144),
                field_type: "CustomSequenceTrackLinkMapping-Array",
                rust_offset: offset_of!(CustomSequenceTrackData, output_link_map),
            },
            FieldInfoData {
                name: "EventMap",
                flags: MemberInfoFlags::new(144),
                field_type: "CustomSequenceTrackEventMapping-Array",
                rust_offset: offset_of!(CustomSequenceTrackData, event_map),
            },
            FieldInfoData {
                name: "SourcePropertyMap",
                flags: MemberInfoFlags::new(144),
                field_type: "CustomSequenceTrackPropertyMapping-Array",
                rust_offset: offset_of!(CustomSequenceTrackData, source_property_map),
            },
            FieldInfoData {
                name: "TargetPropertyMap",
                flags: MemberInfoFlags::new(144),
                field_type: "CustomSequenceTrackPropertyMapping-Array",
                rust_offset: offset_of!(CustomSequenceTrackData, target_property_map),
            },
            FieldInfoData {
                name: "SourceAndTargetPropertyMap",
                flags: MemberInfoFlags::new(144),
                field_type: "CustomSequenceTrackPropertyMapping-Array",
                rust_offset: offset_of!(CustomSequenceTrackData, source_and_target_property_map),
            },
        ],
    }),
    array_type: Some(CUSTOMSEQUENCETRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CustomSequenceTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        CUSTOMSEQUENCETRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CUSTOMSEQUENCETRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomSequenceTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CustomSequenceTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CustomSequenceTrackPropertyMapping {
    pub _glacier_base: super::core::DataContainer,
    pub track_property_i_d: i32,
    pub sequence_property_i_d: i32,
}

pub trait CustomSequenceTrackPropertyMappingTrait: super::core::DataContainerTrait {
    fn track_property_i_d(&self) -> &i32;
    fn sequence_property_i_d(&self) -> &i32;
}

impl CustomSequenceTrackPropertyMappingTrait for CustomSequenceTrackPropertyMapping {
    fn track_property_i_d(&self) -> &i32 {
        &self.track_property_i_d
    }
    fn sequence_property_i_d(&self) -> &i32 {
        &self.sequence_property_i_d
    }
}

impl super::core::DataContainerTrait for CustomSequenceTrackPropertyMapping {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CUSTOMSEQUENCETRACKPROPERTYMAPPING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomSequenceTrackPropertyMapping",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CustomSequenceTrackPropertyMapping as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "TrackPropertyID",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CustomSequenceTrackPropertyMapping, track_property_i_d),
            },
            FieldInfoData {
                name: "SequencePropertyID",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CustomSequenceTrackPropertyMapping, sequence_property_i_d),
            },
        ],
    }),
    array_type: Some(CUSTOMSEQUENCETRACKPROPERTYMAPPING_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CustomSequenceTrackPropertyMapping {
    fn type_info(&self) -> &'static TypeInfo {
        CUSTOMSEQUENCETRACKPROPERTYMAPPING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CUSTOMSEQUENCETRACKPROPERTYMAPPING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomSequenceTrackPropertyMapping-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CustomSequenceTrackPropertyMapping"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CustomSequenceTrackEventMapping {
    pub _glacier_base: super::core::DataContainer,
    pub track_event_i_d: i32,
    pub sequence_event_i_d: i32,
}

pub trait CustomSequenceTrackEventMappingTrait: super::core::DataContainerTrait {
    fn track_event_i_d(&self) -> &i32;
    fn sequence_event_i_d(&self) -> &i32;
}

impl CustomSequenceTrackEventMappingTrait for CustomSequenceTrackEventMapping {
    fn track_event_i_d(&self) -> &i32 {
        &self.track_event_i_d
    }
    fn sequence_event_i_d(&self) -> &i32 {
        &self.sequence_event_i_d
    }
}

impl super::core::DataContainerTrait for CustomSequenceTrackEventMapping {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CUSTOMSEQUENCETRACKEVENTMAPPING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomSequenceTrackEventMapping",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CustomSequenceTrackEventMapping as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "TrackEventID",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CustomSequenceTrackEventMapping, track_event_i_d),
            },
            FieldInfoData {
                name: "SequenceEventID",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CustomSequenceTrackEventMapping, sequence_event_i_d),
            },
        ],
    }),
    array_type: Some(CUSTOMSEQUENCETRACKEVENTMAPPING_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CustomSequenceTrackEventMapping {
    fn type_info(&self) -> &'static TypeInfo {
        CUSTOMSEQUENCETRACKEVENTMAPPING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CUSTOMSEQUENCETRACKEVENTMAPPING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomSequenceTrackEventMapping-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CustomSequenceTrackEventMapping"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CustomSequenceTrackLinkMapping {
    pub _glacier_base: super::core::DataContainer,
    pub track_link_i_d: i32,
    pub sequence_link_i_d: i32,
}

pub trait CustomSequenceTrackLinkMappingTrait: super::core::DataContainerTrait {
    fn track_link_i_d(&self) -> &i32;
    fn sequence_link_i_d(&self) -> &i32;
}

impl CustomSequenceTrackLinkMappingTrait for CustomSequenceTrackLinkMapping {
    fn track_link_i_d(&self) -> &i32 {
        &self.track_link_i_d
    }
    fn sequence_link_i_d(&self) -> &i32 {
        &self.sequence_link_i_d
    }
}

impl super::core::DataContainerTrait for CustomSequenceTrackLinkMapping {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CUSTOMSEQUENCETRACKLINKMAPPING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomSequenceTrackLinkMapping",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CustomSequenceTrackLinkMapping as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "TrackLinkID",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CustomSequenceTrackLinkMapping, track_link_i_d),
            },
            FieldInfoData {
                name: "SequenceLinkID",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CustomSequenceTrackLinkMapping, sequence_link_i_d),
            },
        ],
    }),
    array_type: Some(CUSTOMSEQUENCETRACKLINKMAPPING_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CustomSequenceTrackLinkMapping {
    fn type_info(&self) -> &'static TypeInfo {
        CUSTOMSEQUENCETRACKLINKMAPPING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CUSTOMSEQUENCETRACKLINKMAPPING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomSequenceTrackLinkMapping-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CustomSequenceTrackLinkMapping"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PropertyTrackData {
    pub _glacier_base: super::core::DataContainer,
    pub id: i32,
    pub times: Vec<i32>,
}

pub trait PropertyTrackDataTrait: super::core::DataContainerTrait {
    fn id(&self) -> &i32;
    fn times(&self) -> &Vec<i32>;
}

impl PropertyTrackDataTrait for PropertyTrackData {
    fn id(&self) -> &i32 {
        &self.id
    }
    fn times(&self) -> &Vec<i32> {
        &self.times
    }
}

impl super::core::DataContainerTrait for PropertyTrackData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PROPERTYTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PropertyTrackData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PropertyTrackData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Id",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(PropertyTrackData, id),
            },
            FieldInfoData {
                name: "Times",
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(PropertyTrackData, times),
            },
        ],
    }),
    array_type: Some(PROPERTYTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PropertyTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        PROPERTYTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PROPERTYTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PropertyTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("PropertyTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum InterpolationType {
    #[default]
    InterpolationType_None = 0,
    InterpolationType_Linear = 1,
    InterpolationType_CatmullRom = 2,
    InterpolationType_Curves = 3,
}

pub static INTERPOLATIONTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InterpolationType",
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(INTERPOLATIONTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for InterpolationType {
    fn type_info(&self) -> &'static TypeInfo {
        INTERPOLATIONTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static INTERPOLATIONTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InterpolationType-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("InterpolationType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SequenceEventData {
    pub event: EventSpec,
    pub time: i32,
}

pub trait SequenceEventDataTrait: TypeObject {
    fn event(&self) -> &EventSpec;
    fn time(&self) -> &i32;
}

impl SequenceEventDataTrait for SequenceEventData {
    fn event(&self) -> &EventSpec {
        &self.event
    }
    fn time(&self) -> &i32 {
        &self.time
    }
}

pub static SEQUENCEEVENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SequenceEventData",
    flags: MemberInfoFlags::new(32841),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SequenceEventData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Event",
                flags: MemberInfoFlags::new(0),
                field_type: "EventSpec",
                rust_offset: offset_of!(SequenceEventData, event),
            },
            FieldInfoData {
                name: "Time",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SequenceEventData, time),
            },
        ],
    }),
    array_type: Some(SEQUENCEEVENTDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for SequenceEventData {
    fn type_info(&self) -> &'static TypeInfo {
        SEQUENCEEVENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SEQUENCEEVENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SequenceEventData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SequenceEventData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EntityClassInfoAsset {
    pub _glacier_base: super::core::ClassInfoAsset,
}

pub trait EntityClassInfoAssetTrait: super::core::ClassInfoAssetTrait {
}

impl EntityClassInfoAssetTrait for EntityClassInfoAsset {
}

impl super::core::ClassInfoAssetTrait for EntityClassInfoAsset {
    fn super_class_ref(&self) -> &super::core::ClassInfoRef {
        self._glacier_base.super_class_ref()
    }
    fn is_abstract(&self) -> &bool {
        self._glacier_base.is_abstract()
    }
    fn is_sealed(&self) -> &bool {
        self._glacier_base.is_sealed()
    }
}

impl super::core::ComplexTypeInfoAssetTrait for EntityClassInfoAsset {
    fn field_collections(&self) -> &Vec<super::core::TypeInfoFieldCollectionRef> {
        self._glacier_base.field_collections()
    }
    fn alignment(&self) -> &u32 {
        self._glacier_base.alignment()
    }
}

impl super::core::TypeInfoAssetTrait for EntityClassInfoAsset {
    fn module_name(&self) -> &String {
        self._glacier_base.module_name()
    }
    fn type_name(&self) -> &String {
        self._glacier_base.type_name()
    }
    fn is_meta(&self) -> &bool {
        self._glacier_base.is_meta()
    }
    fn attributes(&self) -> &Vec<Option<Arc<Mutex<dyn super::core::TypeInfoAttributeTrait>>>> {
        self._glacier_base.attributes()
    }
    fn is_native(&self) -> &bool {
        self._glacier_base.is_native()
    }
}

impl super::core::AssetTrait for EntityClassInfoAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for EntityClassInfoAsset {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static ENTITYCLASSINFOASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityClassInfoAsset",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::CLASSINFOASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EntityClassInfoAsset as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(ENTITYCLASSINFOASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EntityClassInfoAsset {
    fn type_info(&self) -> &'static TypeInfo {
        ENTITYCLASSINFOASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ENTITYCLASSINFOASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityClassInfoAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EntityClassInfoAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AutopaintOutputOverrideBase {
    pub _glacier_base: super::core::DataContainer,
}

pub trait AutopaintOutputOverrideBaseTrait: super::core::DataContainerTrait {
}

impl AutopaintOutputOverrideBaseTrait for AutopaintOutputOverrideBase {
}

impl super::core::DataContainerTrait for AutopaintOutputOverrideBase {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static AUTOPAINTOUTPUTOVERRIDEBASE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AutopaintOutputOverrideBase",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AutopaintOutputOverrideBase as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(AUTOPAINTOUTPUTOVERRIDEBASE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AutopaintOutputOverrideBase {
    fn type_info(&self) -> &'static TypeInfo {
        AUTOPAINTOUTPUTOVERRIDEBASE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static AUTOPAINTOUTPUTOVERRIDEBASE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AutopaintOutputOverrideBase-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("AutopaintOutputOverrideBase"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AutopaintOutputBase {
    pub _glacier_base: super::core::Asset,
}

pub trait AutopaintOutputBaseTrait: super::core::AssetTrait {
}

impl AutopaintOutputBaseTrait for AutopaintOutputBase {
}

impl super::core::AssetTrait for AutopaintOutputBase {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for AutopaintOutputBase {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static AUTOPAINTOUTPUTBASE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AutopaintOutputBase",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AutopaintOutputBase as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(AUTOPAINTOUTPUTBASE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AutopaintOutputBase {
    fn type_info(&self) -> &'static TypeInfo {
        AUTOPAINTOUTPUTBASE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static AUTOPAINTOUTPUTBASE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AutopaintOutputBase-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("AutopaintOutputBase"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AutopaintOutputsBase {
    pub _glacier_base: super::core::Asset,
    pub outputs: Vec<Option<Arc<Mutex<dyn AutopaintOutputBaseTrait>>>>,
}

pub trait AutopaintOutputsBaseTrait: super::core::AssetTrait {
    fn outputs(&self) -> &Vec<Option<Arc<Mutex<dyn AutopaintOutputBaseTrait>>>>;
}

impl AutopaintOutputsBaseTrait for AutopaintOutputsBase {
    fn outputs(&self) -> &Vec<Option<Arc<Mutex<dyn AutopaintOutputBaseTrait>>>> {
        &self.outputs
    }
}

impl super::core::AssetTrait for AutopaintOutputsBase {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for AutopaintOutputsBase {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static AUTOPAINTOUTPUTSBASE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AutopaintOutputsBase",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AutopaintOutputsBase as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Outputs",
                flags: MemberInfoFlags::new(144),
                field_type: "AutopaintOutputBase-Array",
                rust_offset: offset_of!(AutopaintOutputsBase, outputs),
            },
        ],
    }),
    array_type: Some(AUTOPAINTOUTPUTSBASE_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for AutopaintOutputsBase {
    fn type_info(&self) -> &'static TypeInfo {
        AUTOPAINTOUTPUTSBASE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static AUTOPAINTOUTPUTSBASE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AutopaintOutputsBase-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("AutopaintOutputsBase"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum RasterType {
    #[default]
    RasterType_Null = 0,
    RasterType_ColorMap = 1,
    RasterType_DestructionDepth = 2,
    RasterType_Density = 3,
    RasterType_EnlightenAlbedo = 4,
    RasterType_Heightfield = 5,
    RasterType_NonPhysic = 6,
    RasterType_PhysicsMaterials = 7,
    RasterType_ResolutionLayout = 8,
    RasterType_LayerMask = 9,
    RasterType_FlowMap = 10,
    RasterType_Biome = 11,
    RasterType_Count = 12,
}

pub static RASTERTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RasterType",
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(RASTERTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for RasterType {
    fn type_info(&self) -> &'static TypeInfo {
        RASTERTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static RASTERTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RasterType-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("RasterType"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum RasterFormat {
    #[default]
    RasterFormat_Null = 0,
    RasterFormat_R8_UNORM = 1,
    RasterFormat_R8_UINT = 2,
    RasterFormat_R8G8B8A8_UNORM = 3,
    RasterFormat_R32_FLOAT = 4,
    RasterFormat_Count = 5,
}

pub static RASTERFORMAT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RasterFormat",
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(RASTERFORMAT_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for RasterFormat {
    fn type_info(&self) -> &'static TypeInfo {
        RASTERFORMAT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static RASTERFORMAT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RasterFormat-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("RasterFormat"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BaseShapeDataBase {
    pub _glacier_base: GameObjectData,
}

pub trait BaseShapeDataBaseTrait: GameObjectDataTrait {
}

impl BaseShapeDataBaseTrait for BaseShapeDataBase {
}

impl GameObjectDataTrait for BaseShapeDataBase {
}

impl super::core::DataBusPeerTrait for BaseShapeDataBase {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for BaseShapeDataBase {
}

impl super::core::DataContainerTrait for BaseShapeDataBase {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static BASESHAPEDATABASE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BaseShapeDataBase",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(GAMEOBJECTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BaseShapeDataBase as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(BASESHAPEDATABASE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BaseShapeDataBase {
    fn type_info(&self) -> &'static TypeInfo {
        BASESHAPEDATABASE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static BASESHAPEDATABASE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BaseShapeDataBase-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("BaseShapeDataBase"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BaseMaterialDataPair {
    pub _glacier_base: super::core::DataContainer,
}

pub trait BaseMaterialDataPairTrait: super::core::DataContainerTrait {
}

impl BaseMaterialDataPairTrait for BaseMaterialDataPair {
}

impl super::core::DataContainerTrait for BaseMaterialDataPair {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static BASEMATERIALDATAPAIR_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BaseMaterialDataPair",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BaseMaterialDataPair as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(BASEMATERIALDATAPAIR_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BaseMaterialDataPair {
    fn type_info(&self) -> &'static TypeInfo {
        BASEMATERIALDATAPAIR_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static BASEMATERIALDATAPAIR_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BaseMaterialDataPair-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("BaseMaterialDataPair"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MaterialGridData {
    pub _glacier_base: super::core::Asset,
    pub default_material: MaterialDecl,
    pub material_pairs: Vec<MaterialDecl>,
    pub material_index_map: Vec<u32>,
    pub default_material_index: u32,
    pub material_properties: Vec<MaterialRelationPropertyPair>,
    pub interaction_grid: Vec<MaterialInteractionGridRow>,
}

pub trait MaterialGridDataTrait: super::core::AssetTrait {
    fn default_material(&self) -> &MaterialDecl;
    fn material_pairs(&self) -> &Vec<MaterialDecl>;
    fn material_index_map(&self) -> &Vec<u32>;
    fn default_material_index(&self) -> &u32;
    fn material_properties(&self) -> &Vec<MaterialRelationPropertyPair>;
    fn interaction_grid(&self) -> &Vec<MaterialInteractionGridRow>;
}

impl MaterialGridDataTrait for MaterialGridData {
    fn default_material(&self) -> &MaterialDecl {
        &self.default_material
    }
    fn material_pairs(&self) -> &Vec<MaterialDecl> {
        &self.material_pairs
    }
    fn material_index_map(&self) -> &Vec<u32> {
        &self.material_index_map
    }
    fn default_material_index(&self) -> &u32 {
        &self.default_material_index
    }
    fn material_properties(&self) -> &Vec<MaterialRelationPropertyPair> {
        &self.material_properties
    }
    fn interaction_grid(&self) -> &Vec<MaterialInteractionGridRow> {
        &self.interaction_grid
    }
}

impl super::core::AssetTrait for MaterialGridData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for MaterialGridData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static MATERIALGRIDDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MaterialGridData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MaterialGridData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DefaultMaterial",
                flags: MemberInfoFlags::new(0),
                field_type: "MaterialDecl",
                rust_offset: offset_of!(MaterialGridData, default_material),
            },
            FieldInfoData {
                name: "MaterialPairs",
                flags: MemberInfoFlags::new(144),
                field_type: "MaterialDecl-Array",
                rust_offset: offset_of!(MaterialGridData, material_pairs),
            },
            FieldInfoData {
                name: "MaterialIndexMap",
                flags: MemberInfoFlags::new(144),
                field_type: "Uint32-Array",
                rust_offset: offset_of!(MaterialGridData, material_index_map),
            },
            FieldInfoData {
                name: "DefaultMaterialIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(MaterialGridData, default_material_index),
            },
            FieldInfoData {
                name: "MaterialProperties",
                flags: MemberInfoFlags::new(144),
                field_type: "MaterialRelationPropertyPair-Array",
                rust_offset: offset_of!(MaterialGridData, material_properties),
            },
            FieldInfoData {
                name: "InteractionGrid",
                flags: MemberInfoFlags::new(144),
                field_type: "MaterialInteractionGridRow-Array",
                rust_offset: offset_of!(MaterialGridData, interaction_grid),
            },
        ],
    }),
    array_type: Some(MATERIALGRIDDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MaterialGridData {
    fn type_info(&self) -> &'static TypeInfo {
        MATERIALGRIDDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static MATERIALGRIDDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MaterialGridData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("MaterialGridData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MaterialInteractionGridRow {
    pub items: Vec<MaterialRelationPropertyPair>,
}

pub trait MaterialInteractionGridRowTrait: TypeObject {
    fn items(&self) -> &Vec<MaterialRelationPropertyPair>;
}

impl MaterialInteractionGridRowTrait for MaterialInteractionGridRow {
    fn items(&self) -> &Vec<MaterialRelationPropertyPair> {
        &self.items
    }
}

pub static MATERIALINTERACTIONGRIDROW_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MaterialInteractionGridRow",
    flags: MemberInfoFlags::new(73),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MaterialInteractionGridRow as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Items",
                flags: MemberInfoFlags::new(144),
                field_type: "MaterialRelationPropertyPair-Array",
                rust_offset: offset_of!(MaterialInteractionGridRow, items),
            },
        ],
    }),
    array_type: Some(MATERIALINTERACTIONGRIDROW_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MaterialInteractionGridRow {
    fn type_info(&self) -> &'static TypeInfo {
        MATERIALINTERACTIONGRIDROW_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static MATERIALINTERACTIONGRIDROW_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MaterialInteractionGridRow-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("MaterialInteractionGridRow"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MaterialRelationPropertyPair {
    pub physics_material_properties: Vec<Option<Arc<Mutex<dyn PhysicsMaterialRelationPropertyDataTrait>>>>,
    pub physics_property_properties: Vec<Option<Arc<Mutex<dyn PhysicsPropertyRelationPropertyDataTrait>>>>,
}

pub trait MaterialRelationPropertyPairTrait: TypeObject {
    fn physics_material_properties(&self) -> &Vec<Option<Arc<Mutex<dyn PhysicsMaterialRelationPropertyDataTrait>>>>;
    fn physics_property_properties(&self) -> &Vec<Option<Arc<Mutex<dyn PhysicsPropertyRelationPropertyDataTrait>>>>;
}

impl MaterialRelationPropertyPairTrait for MaterialRelationPropertyPair {
    fn physics_material_properties(&self) -> &Vec<Option<Arc<Mutex<dyn PhysicsMaterialRelationPropertyDataTrait>>>> {
        &self.physics_material_properties
    }
    fn physics_property_properties(&self) -> &Vec<Option<Arc<Mutex<dyn PhysicsPropertyRelationPropertyDataTrait>>>> {
        &self.physics_property_properties
    }
}

pub static MATERIALRELATIONPROPERTYPAIR_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MaterialRelationPropertyPair",
    flags: MemberInfoFlags::new(73),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MaterialRelationPropertyPair as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PhysicsMaterialProperties",
                flags: MemberInfoFlags::new(144),
                field_type: "PhysicsMaterialRelationPropertyData-Array",
                rust_offset: offset_of!(MaterialRelationPropertyPair, physics_material_properties),
            },
            FieldInfoData {
                name: "PhysicsPropertyProperties",
                flags: MemberInfoFlags::new(144),
                field_type: "PhysicsPropertyRelationPropertyData-Array",
                rust_offset: offset_of!(MaterialRelationPropertyPair, physics_property_properties),
            },
        ],
    }),
    array_type: Some(MATERIALRELATIONPROPERTYPAIR_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MaterialRelationPropertyPair {
    fn type_info(&self) -> &'static TypeInfo {
        MATERIALRELATIONPROPERTYPAIR_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static MATERIALRELATIONPROPERTYPAIR_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MaterialRelationPropertyPair-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("MaterialRelationPropertyPair"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PhysicsPropertyRelationPropertyData {
    pub _glacier_base: MaterialRelationPropertyData,
}

pub trait PhysicsPropertyRelationPropertyDataTrait: MaterialRelationPropertyDataTrait {
}

impl PhysicsPropertyRelationPropertyDataTrait for PhysicsPropertyRelationPropertyData {
}

impl MaterialRelationPropertyDataTrait for PhysicsPropertyRelationPropertyData {
}

impl super::core::DataContainerTrait for PhysicsPropertyRelationPropertyData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PHYSICSPROPERTYRELATIONPROPERTYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsPropertyRelationPropertyData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(MATERIALRELATIONPROPERTYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PhysicsPropertyRelationPropertyData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(PHYSICSPROPERTYRELATIONPROPERTYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PhysicsPropertyRelationPropertyData {
    fn type_info(&self) -> &'static TypeInfo {
        PHYSICSPROPERTYRELATIONPROPERTYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PHYSICSPROPERTYRELATIONPROPERTYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsPropertyRelationPropertyData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("PhysicsPropertyRelationPropertyData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PhysicsMaterialRelationPropertyData {
    pub _glacier_base: MaterialRelationPropertyData,
}

pub trait PhysicsMaterialRelationPropertyDataTrait: MaterialRelationPropertyDataTrait {
}

impl PhysicsMaterialRelationPropertyDataTrait for PhysicsMaterialRelationPropertyData {
}

impl MaterialRelationPropertyDataTrait for PhysicsMaterialRelationPropertyData {
}

impl super::core::DataContainerTrait for PhysicsMaterialRelationPropertyData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PHYSICSMATERIALRELATIONPROPERTYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsMaterialRelationPropertyData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(MATERIALRELATIONPROPERTYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PhysicsMaterialRelationPropertyData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(PHYSICSMATERIALRELATIONPROPERTYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PhysicsMaterialRelationPropertyData {
    fn type_info(&self) -> &'static TypeInfo {
        PHYSICSMATERIALRELATIONPROPERTYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PHYSICSMATERIALRELATIONPROPERTYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsMaterialRelationPropertyData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("PhysicsMaterialRelationPropertyData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MaterialRelationPropertyData {
    pub _glacier_base: super::core::DataContainer,
}

pub trait MaterialRelationPropertyDataTrait: super::core::DataContainerTrait {
}

impl MaterialRelationPropertyDataTrait for MaterialRelationPropertyData {
}

impl super::core::DataContainerTrait for MaterialRelationPropertyData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static MATERIALRELATIONPROPERTYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MaterialRelationPropertyData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MaterialRelationPropertyData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(MATERIALRELATIONPROPERTYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MaterialRelationPropertyData {
    fn type_info(&self) -> &'static TypeInfo {
        MATERIALRELATIONPROPERTYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static MATERIALRELATIONPROPERTYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MaterialRelationPropertyData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("MaterialRelationPropertyData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MaterialDecl {
    pub packed: u32,
}

pub trait MaterialDeclTrait: TypeObject {
    fn packed(&self) -> &u32;
}

impl MaterialDeclTrait for MaterialDecl {
    fn packed(&self) -> &u32 {
        &self.packed
    }
}

pub static MATERIALDECL_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MaterialDecl",
    flags: MemberInfoFlags::new(32841),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MaterialDecl as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Packed",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(MaterialDecl, packed),
            },
        ],
    }),
    array_type: Some(MATERIALDECL_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for MaterialDecl {
    fn type_info(&self) -> &'static TypeInfo {
        MATERIALDECL_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static MATERIALDECL_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MaterialDecl-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("MaterialDecl"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct StringBuilderEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub num_strings: i32,
}

pub trait StringBuilderEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn num_strings(&self) -> &i32;
}

impl StringBuilderEntityDataTrait for StringBuilderEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn num_strings(&self) -> &i32 {
        &self.num_strings
    }
}

impl EntityDataTrait for StringBuilderEntityData {
}

impl GameObjectDataTrait for StringBuilderEntityData {
}

impl super::core::DataBusPeerTrait for StringBuilderEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for StringBuilderEntityData {
}

impl super::core::DataContainerTrait for StringBuilderEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static STRINGBUILDERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StringBuilderEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StringBuilderEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(StringBuilderEntityData, realm),
            },
            FieldInfoData {
                name: "NumStrings",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(StringBuilderEntityData, num_strings),
            },
        ],
    }),
    array_type: Some(STRINGBUILDERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for StringBuilderEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        STRINGBUILDERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static STRINGBUILDERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StringBuilderEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("StringBuilderEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Vec4ChangedEntityData {
    pub _glacier_base: PropertyChangedEntityData,
    pub realm: super::core::Realm,
    pub value: super::core::Vec4,
    pub always_send: bool,
}

pub trait Vec4ChangedEntityDataTrait: PropertyChangedEntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn value(&self) -> &super::core::Vec4;
    fn always_send(&self) -> &bool;
}

impl Vec4ChangedEntityDataTrait for Vec4ChangedEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn value(&self) -> &super::core::Vec4 {
        &self.value
    }
    fn always_send(&self) -> &bool {
        &self.always_send
    }
}

impl PropertyChangedEntityDataTrait for Vec4ChangedEntityData {
}

impl EntityDataTrait for Vec4ChangedEntityData {
}

impl GameObjectDataTrait for Vec4ChangedEntityData {
}

impl super::core::DataBusPeerTrait for Vec4ChangedEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for Vec4ChangedEntityData {
}

impl super::core::DataContainerTrait for Vec4ChangedEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static VEC4CHANGEDENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec4ChangedEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PROPERTYCHANGEDENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec4ChangedEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(Vec4ChangedEntityData, realm),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(Vec4ChangedEntityData, value),
            },
            FieldInfoData {
                name: "AlwaysSend",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(Vec4ChangedEntityData, always_send),
            },
        ],
    }),
    array_type: Some(VEC4CHANGEDENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for Vec4ChangedEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VEC4CHANGEDENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VEC4CHANGEDENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec4ChangedEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec4ChangedEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Vec3ChangedEntityData {
    pub _glacier_base: PropertyChangedEntityData,
    pub realm: super::core::Realm,
    pub value: super::core::Vec3,
    pub always_send: bool,
}

pub trait Vec3ChangedEntityDataTrait: PropertyChangedEntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn value(&self) -> &super::core::Vec3;
    fn always_send(&self) -> &bool;
}

impl Vec3ChangedEntityDataTrait for Vec3ChangedEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn value(&self) -> &super::core::Vec3 {
        &self.value
    }
    fn always_send(&self) -> &bool {
        &self.always_send
    }
}

impl PropertyChangedEntityDataTrait for Vec3ChangedEntityData {
}

impl EntityDataTrait for Vec3ChangedEntityData {
}

impl GameObjectDataTrait for Vec3ChangedEntityData {
}

impl super::core::DataBusPeerTrait for Vec3ChangedEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for Vec3ChangedEntityData {
}

impl super::core::DataContainerTrait for Vec3ChangedEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static VEC3CHANGEDENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3ChangedEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PROPERTYCHANGEDENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec3ChangedEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(Vec3ChangedEntityData, realm),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(Vec3ChangedEntityData, value),
            },
            FieldInfoData {
                name: "AlwaysSend",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(Vec3ChangedEntityData, always_send),
            },
        ],
    }),
    array_type: Some(VEC3CHANGEDENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for Vec3ChangedEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VEC3CHANGEDENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VEC3CHANGEDENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3ChangedEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec3ChangedEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Vec2ChangedEntityData {
    pub _glacier_base: PropertyChangedEntityData,
    pub realm: super::core::Realm,
    pub value: super::core::Vec2,
    pub always_send: bool,
}

pub trait Vec2ChangedEntityDataTrait: PropertyChangedEntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn value(&self) -> &super::core::Vec2;
    fn always_send(&self) -> &bool;
}

impl Vec2ChangedEntityDataTrait for Vec2ChangedEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn value(&self) -> &super::core::Vec2 {
        &self.value
    }
    fn always_send(&self) -> &bool {
        &self.always_send
    }
}

impl PropertyChangedEntityDataTrait for Vec2ChangedEntityData {
}

impl EntityDataTrait for Vec2ChangedEntityData {
}

impl GameObjectDataTrait for Vec2ChangedEntityData {
}

impl super::core::DataBusPeerTrait for Vec2ChangedEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for Vec2ChangedEntityData {
}

impl super::core::DataContainerTrait for Vec2ChangedEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static VEC2CHANGEDENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec2ChangedEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PROPERTYCHANGEDENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec2ChangedEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(Vec2ChangedEntityData, realm),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(Vec2ChangedEntityData, value),
            },
            FieldInfoData {
                name: "AlwaysSend",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(Vec2ChangedEntityData, always_send),
            },
        ],
    }),
    array_type: Some(VEC2CHANGEDENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for Vec2ChangedEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VEC2CHANGEDENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VEC2CHANGEDENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec2ChangedEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec2ChangedEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct IntChangedEntityData {
    pub _glacier_base: PropertyChangedEntityData,
    pub realm: super::core::Realm,
    pub value: i32,
    pub always_send: bool,
}

pub trait IntChangedEntityDataTrait: PropertyChangedEntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn value(&self) -> &i32;
    fn always_send(&self) -> &bool;
}

impl IntChangedEntityDataTrait for IntChangedEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn value(&self) -> &i32 {
        &self.value
    }
    fn always_send(&self) -> &bool {
        &self.always_send
    }
}

impl PropertyChangedEntityDataTrait for IntChangedEntityData {
}

impl EntityDataTrait for IntChangedEntityData {
}

impl GameObjectDataTrait for IntChangedEntityData {
}

impl super::core::DataBusPeerTrait for IntChangedEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for IntChangedEntityData {
}

impl super::core::DataContainerTrait for IntChangedEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static INTCHANGEDENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntChangedEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PROPERTYCHANGEDENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<IntChangedEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(IntChangedEntityData, realm),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(IntChangedEntityData, value),
            },
            FieldInfoData {
                name: "AlwaysSend",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(IntChangedEntityData, always_send),
            },
        ],
    }),
    array_type: Some(INTCHANGEDENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for IntChangedEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        INTCHANGEDENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static INTCHANGEDENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntChangedEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("IntChangedEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FloatChangedEntityData {
    pub _glacier_base: PropertyChangedEntityData,
    pub realm: super::core::Realm,
    pub value: f32,
    pub always_send: bool,
}

pub trait FloatChangedEntityDataTrait: PropertyChangedEntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn value(&self) -> &f32;
    fn always_send(&self) -> &bool;
}

impl FloatChangedEntityDataTrait for FloatChangedEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn value(&self) -> &f32 {
        &self.value
    }
    fn always_send(&self) -> &bool {
        &self.always_send
    }
}

impl PropertyChangedEntityDataTrait for FloatChangedEntityData {
}

impl EntityDataTrait for FloatChangedEntityData {
}

impl GameObjectDataTrait for FloatChangedEntityData {
}

impl super::core::DataBusPeerTrait for FloatChangedEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for FloatChangedEntityData {
}

impl super::core::DataContainerTrait for FloatChangedEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static FLOATCHANGEDENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatChangedEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PROPERTYCHANGEDENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FloatChangedEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(FloatChangedEntityData, realm),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FloatChangedEntityData, value),
            },
            FieldInfoData {
                name: "AlwaysSend",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FloatChangedEntityData, always_send),
            },
        ],
    }),
    array_type: Some(FLOATCHANGEDENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FloatChangedEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        FLOATCHANGEDENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static FLOATCHANGEDENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatChangedEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("FloatChangedEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BoolChangedEntityData {
    pub _glacier_base: PropertyChangedEntityData,
    pub realm: super::core::Realm,
    pub value: bool,
    pub always_send: bool,
}

pub trait BoolChangedEntityDataTrait: PropertyChangedEntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn value(&self) -> &bool;
    fn always_send(&self) -> &bool;
}

impl BoolChangedEntityDataTrait for BoolChangedEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn value(&self) -> &bool {
        &self.value
    }
    fn always_send(&self) -> &bool {
        &self.always_send
    }
}

impl PropertyChangedEntityDataTrait for BoolChangedEntityData {
}

impl EntityDataTrait for BoolChangedEntityData {
}

impl GameObjectDataTrait for BoolChangedEntityData {
}

impl super::core::DataBusPeerTrait for BoolChangedEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for BoolChangedEntityData {
}

impl super::core::DataContainerTrait for BoolChangedEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static BOOLCHANGEDENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolChangedEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PROPERTYCHANGEDENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BoolChangedEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(BoolChangedEntityData, realm),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BoolChangedEntityData, value),
            },
            FieldInfoData {
                name: "AlwaysSend",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BoolChangedEntityData, always_send),
            },
        ],
    }),
    array_type: Some(BOOLCHANGEDENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BoolChangedEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        BOOLCHANGEDENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static BOOLCHANGEDENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolChangedEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("BoolChangedEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PropertyChangedEntityData {
    pub _glacier_base: EntityData,
}

pub trait PropertyChangedEntityDataTrait: EntityDataTrait {
}

impl PropertyChangedEntityDataTrait for PropertyChangedEntityData {
}

impl EntityDataTrait for PropertyChangedEntityData {
}

impl GameObjectDataTrait for PropertyChangedEntityData {
}

impl super::core::DataBusPeerTrait for PropertyChangedEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for PropertyChangedEntityData {
}

impl super::core::DataContainerTrait for PropertyChangedEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PROPERTYCHANGEDENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PropertyChangedEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PropertyChangedEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(PROPERTYCHANGEDENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PropertyChangedEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PROPERTYCHANGEDENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PROPERTYCHANGEDENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PropertyChangedEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("PropertyChangedEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CompareTransformEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub a: super::core::LinearTransform,
    pub b: super::core::LinearTransform,
    pub trigger_on_property_change: bool,
    pub trigger_on_start: bool,
}

pub trait CompareTransformEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn a(&self) -> &super::core::LinearTransform;
    fn b(&self) -> &super::core::LinearTransform;
    fn trigger_on_property_change(&self) -> &bool;
    fn trigger_on_start(&self) -> &bool;
}

impl CompareTransformEntityDataTrait for CompareTransformEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn a(&self) -> &super::core::LinearTransform {
        &self.a
    }
    fn b(&self) -> &super::core::LinearTransform {
        &self.b
    }
    fn trigger_on_property_change(&self) -> &bool {
        &self.trigger_on_property_change
    }
    fn trigger_on_start(&self) -> &bool {
        &self.trigger_on_start
    }
}

impl EntityDataTrait for CompareTransformEntityData {
}

impl GameObjectDataTrait for CompareTransformEntityData {
}

impl super::core::DataBusPeerTrait for CompareTransformEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for CompareTransformEntityData {
}

impl super::core::DataContainerTrait for CompareTransformEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static COMPARETRANSFORMENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareTransformEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareTransformEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(CompareTransformEntityData, realm),
            },
            FieldInfoData {
                name: "A",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(CompareTransformEntityData, a),
            },
            FieldInfoData {
                name: "B",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(CompareTransformEntityData, b),
            },
            FieldInfoData {
                name: "TriggerOnPropertyChange",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CompareTransformEntityData, trigger_on_property_change),
            },
            FieldInfoData {
                name: "TriggerOnStart",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CompareTransformEntityData, trigger_on_start),
            },
        ],
    }),
    array_type: Some(COMPARETRANSFORMENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CompareTransformEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        COMPARETRANSFORMENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static COMPARETRANSFORMENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareTransformEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareTransformEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SwitchEnumEntityData {
    pub _glacier_base: ImpliedEnumTypeLogicEntityData,
    pub fire_on_property_changed: bool,
    pub output_events: Vec<EventName>,
}

pub trait SwitchEnumEntityDataTrait: ImpliedEnumTypeLogicEntityDataTrait {
    fn fire_on_property_changed(&self) -> &bool;
    fn output_events(&self) -> &Vec<EventName>;
}

impl SwitchEnumEntityDataTrait for SwitchEnumEntityData {
    fn fire_on_property_changed(&self) -> &bool {
        &self.fire_on_property_changed
    }
    fn output_events(&self) -> &Vec<EventName> {
        &self.output_events
    }
}

impl ImpliedEnumTypeLogicEntityDataTrait for SwitchEnumEntityData {
}

impl EnumLogicEntityBaseDataTrait for SwitchEnumEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn type_name_hash(&self) -> &u32 {
        self._glacier_base.type_name_hash()
    }
}

impl EntityDataTrait for SwitchEnumEntityData {
}

impl GameObjectDataTrait for SwitchEnumEntityData {
}

impl super::core::DataBusPeerTrait for SwitchEnumEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for SwitchEnumEntityData {
}

impl super::core::DataContainerTrait for SwitchEnumEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SWITCHENUMENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SwitchEnumEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(IMPLIEDENUMTYPELOGICENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SwitchEnumEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "FireOnPropertyChanged",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SwitchEnumEntityData, fire_on_property_changed),
            },
            FieldInfoData {
                name: "OutputEvents",
                flags: MemberInfoFlags::new(144),
                field_type: "EventName-Array",
                rust_offset: offset_of!(SwitchEnumEntityData, output_events),
            },
        ],
    }),
    array_type: Some(SWITCHENUMENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SwitchEnumEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SWITCHENUMENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SWITCHENUMENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SwitchEnumEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SwitchEnumEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EventName {
    pub enum_value: i32,
    pub hash: u32,
    pub is_connected: bool,
}

pub trait EventNameTrait: TypeObject {
    fn enum_value(&self) -> &i32;
    fn hash(&self) -> &u32;
    fn is_connected(&self) -> &bool;
}

impl EventNameTrait for EventName {
    fn enum_value(&self) -> &i32 {
        &self.enum_value
    }
    fn hash(&self) -> &u32 {
        &self.hash
    }
    fn is_connected(&self) -> &bool {
        &self.is_connected
    }
}

pub static EVENTNAME_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventName",
    flags: MemberInfoFlags::new(36937),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EventName as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "EnumValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(EventName, enum_value),
            },
            FieldInfoData {
                name: "Hash",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(EventName, hash),
            },
            FieldInfoData {
                name: "IsConnected",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EventName, is_connected),
            },
        ],
    }),
    array_type: Some(EVENTNAME_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for EventName {
    fn type_info(&self) -> &'static TypeInfo {
        EVENTNAME_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static EVENTNAME_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventName-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EventName"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SetEnumEntityData {
    pub _glacier_base: ExplicitEnumTypeLogicEntityData,
    pub input_events: Vec<SetEnumValueContainer>,
}

pub trait SetEnumEntityDataTrait: ExplicitEnumTypeLogicEntityDataTrait {
    fn input_events(&self) -> &Vec<SetEnumValueContainer>;
}

impl SetEnumEntityDataTrait for SetEnumEntityData {
    fn input_events(&self) -> &Vec<SetEnumValueContainer> {
        &self.input_events
    }
}

impl ExplicitEnumTypeLogicEntityDataTrait for SetEnumEntityData {
}

impl EnumLogicEntityBaseDataTrait for SetEnumEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn type_name_hash(&self) -> &u32 {
        self._glacier_base.type_name_hash()
    }
}

impl EntityDataTrait for SetEnumEntityData {
}

impl GameObjectDataTrait for SetEnumEntityData {
}

impl super::core::DataBusPeerTrait for SetEnumEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for SetEnumEntityData {
}

impl super::core::DataContainerTrait for SetEnumEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SETENUMENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SetEnumEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(EXPLICITENUMTYPELOGICENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SetEnumEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "InputEvents",
                flags: MemberInfoFlags::new(144),
                field_type: "SetEnumValueContainer-Array",
                rust_offset: offset_of!(SetEnumEntityData, input_events),
            },
        ],
    }),
    array_type: Some(SETENUMENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SetEnumEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SETENUMENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SETENUMENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SetEnumEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SetEnumEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SetEnumValueContainer {
    pub value: i32,
    pub input_event_hash: u32,
}

pub trait SetEnumValueContainerTrait: TypeObject {
    fn value(&self) -> &i32;
    fn input_event_hash(&self) -> &u32;
}

impl SetEnumValueContainerTrait for SetEnumValueContainer {
    fn value(&self) -> &i32 {
        &self.value
    }
    fn input_event_hash(&self) -> &u32 {
        &self.input_event_hash
    }
}

pub static SETENUMVALUECONTAINER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SetEnumValueContainer",
    flags: MemberInfoFlags::new(36937),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SetEnumValueContainer as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SetEnumValueContainer, value),
            },
            FieldInfoData {
                name: "InputEventHash",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(SetEnumValueContainer, input_event_hash),
            },
        ],
    }),
    array_type: Some(SETENUMVALUECONTAINER_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for SetEnumValueContainer {
    fn type_info(&self) -> &'static TypeInfo {
        SETENUMVALUECONTAINER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SETENUMVALUECONTAINER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SetEnumValueContainer-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SetEnumValueContainer"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct IntToEnumEntityData {
    pub _glacier_base: ExplicitEnumTypeLogicEntityData,
    pub r#in: i32,
}

pub trait IntToEnumEntityDataTrait: ExplicitEnumTypeLogicEntityDataTrait {
    fn r#in(&self) -> &i32;
}

impl IntToEnumEntityDataTrait for IntToEnumEntityData {
    fn r#in(&self) -> &i32 {
        &self.r#in
    }
}

impl ExplicitEnumTypeLogicEntityDataTrait for IntToEnumEntityData {
}

impl EnumLogicEntityBaseDataTrait for IntToEnumEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn type_name_hash(&self) -> &u32 {
        self._glacier_base.type_name_hash()
    }
}

impl EntityDataTrait for IntToEnumEntityData {
}

impl GameObjectDataTrait for IntToEnumEntityData {
}

impl super::core::DataBusPeerTrait for IntToEnumEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for IntToEnumEntityData {
}

impl super::core::DataContainerTrait for IntToEnumEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static INTTOENUMENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntToEnumEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(EXPLICITENUMTYPELOGICENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<IntToEnumEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(IntToEnumEntityData, r#in),
            },
        ],
    }),
    array_type: Some(INTTOENUMENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for IntToEnumEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        INTTOENUMENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static INTTOENUMENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntToEnumEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("IntToEnumEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WriteArrayElementEntityData {
    pub _glacier_base: WriteVariableBaseEntityData,
    pub element_index: i32,
}

pub trait WriteArrayElementEntityDataTrait: WriteVariableBaseEntityDataTrait {
    fn element_index(&self) -> &i32;
}

impl WriteArrayElementEntityDataTrait for WriteArrayElementEntityData {
    fn element_index(&self) -> &i32 {
        &self.element_index
    }
}

impl WriteVariableBaseEntityDataTrait for WriteArrayElementEntityData {
}

impl VariableBaseEntityDataTrait for WriteArrayElementEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn field_name_hash(&self) -> &u32 {
        self._glacier_base.field_name_hash()
    }
    fn field_type(&self) -> &glacier_reflect::builtin::TypeRef {
        self._glacier_base.field_type()
    }
    fn field_offset(&self) -> &u32 {
        self._glacier_base.field_offset()
    }
    fn use_data(&self) -> &bool {
        self._glacier_base.use_data()
    }
}

impl EntityDataTrait for WriteArrayElementEntityData {
}

impl GameObjectDataTrait for WriteArrayElementEntityData {
}

impl super::core::DataBusPeerTrait for WriteArrayElementEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for WriteArrayElementEntityData {
}

impl super::core::DataContainerTrait for WriteArrayElementEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static WRITEARRAYELEMENTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteArrayElementEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(WRITEVARIABLEBASEENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WriteArrayElementEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ElementIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(WriteArrayElementEntityData, element_index),
            },
        ],
    }),
    array_type: Some(WRITEARRAYELEMENTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WriteArrayElementEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        WRITEARRAYELEMENTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static WRITEARRAYELEMENTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteArrayElementEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("WriteArrayElementEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ReadArraySizeEntityData {
    pub _glacier_base: ReadVariableBaseEntityData,
}

pub trait ReadArraySizeEntityDataTrait: ReadVariableBaseEntityDataTrait {
}

impl ReadArraySizeEntityDataTrait for ReadArraySizeEntityData {
}

impl ReadVariableBaseEntityDataTrait for ReadArraySizeEntityData {
}

impl VariableBaseEntityDataTrait for ReadArraySizeEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn field_name_hash(&self) -> &u32 {
        self._glacier_base.field_name_hash()
    }
    fn field_type(&self) -> &glacier_reflect::builtin::TypeRef {
        self._glacier_base.field_type()
    }
    fn field_offset(&self) -> &u32 {
        self._glacier_base.field_offset()
    }
    fn use_data(&self) -> &bool {
        self._glacier_base.use_data()
    }
}

impl EntityDataTrait for ReadArraySizeEntityData {
}

impl GameObjectDataTrait for ReadArraySizeEntityData {
}

impl super::core::DataBusPeerTrait for ReadArraySizeEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for ReadArraySizeEntityData {
}

impl super::core::DataContainerTrait for ReadArraySizeEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static READARRAYSIZEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadArraySizeEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(READVARIABLEBASEENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ReadArraySizeEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(READARRAYSIZEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ReadArraySizeEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        READARRAYSIZEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static READARRAYSIZEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadArraySizeEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ReadArraySizeEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ReadArrayElementEntityData {
    pub _glacier_base: ReadVariableBaseEntityData,
    pub element_index: i32,
}

pub trait ReadArrayElementEntityDataTrait: ReadVariableBaseEntityDataTrait {
    fn element_index(&self) -> &i32;
}

impl ReadArrayElementEntityDataTrait for ReadArrayElementEntityData {
    fn element_index(&self) -> &i32 {
        &self.element_index
    }
}

impl ReadVariableBaseEntityDataTrait for ReadArrayElementEntityData {
}

impl VariableBaseEntityDataTrait for ReadArrayElementEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn field_name_hash(&self) -> &u32 {
        self._glacier_base.field_name_hash()
    }
    fn field_type(&self) -> &glacier_reflect::builtin::TypeRef {
        self._glacier_base.field_type()
    }
    fn field_offset(&self) -> &u32 {
        self._glacier_base.field_offset()
    }
    fn use_data(&self) -> &bool {
        self._glacier_base.use_data()
    }
}

impl EntityDataTrait for ReadArrayElementEntityData {
}

impl GameObjectDataTrait for ReadArrayElementEntityData {
}

impl super::core::DataBusPeerTrait for ReadArrayElementEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for ReadArrayElementEntityData {
}

impl super::core::DataContainerTrait for ReadArrayElementEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static READARRAYELEMENTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadArrayElementEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(READVARIABLEBASEENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ReadArrayElementEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ElementIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ReadArrayElementEntityData, element_index),
            },
        ],
    }),
    array_type: Some(READARRAYELEMENTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ReadArrayElementEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        READARRAYELEMENTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static READARRAYELEMENTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadArrayElementEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ReadArrayElementEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ForEachVariableEntityData {
    pub _glacier_base: ReadVariableBaseEntityData,
}

pub trait ForEachVariableEntityDataTrait: ReadVariableBaseEntityDataTrait {
}

impl ForEachVariableEntityDataTrait for ForEachVariableEntityData {
}

impl ReadVariableBaseEntityDataTrait for ForEachVariableEntityData {
}

impl VariableBaseEntityDataTrait for ForEachVariableEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn field_name_hash(&self) -> &u32 {
        self._glacier_base.field_name_hash()
    }
    fn field_type(&self) -> &glacier_reflect::builtin::TypeRef {
        self._glacier_base.field_type()
    }
    fn field_offset(&self) -> &u32 {
        self._glacier_base.field_offset()
    }
    fn use_data(&self) -> &bool {
        self._glacier_base.use_data()
    }
}

impl EntityDataTrait for ForEachVariableEntityData {
}

impl GameObjectDataTrait for ForEachVariableEntityData {
}

impl super::core::DataBusPeerTrait for ForEachVariableEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for ForEachVariableEntityData {
}

impl super::core::DataContainerTrait for ForEachVariableEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static FOREACHVARIABLEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ForEachVariableEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(READVARIABLEBASEENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ForEachVariableEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(FOREACHVARIABLEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ForEachVariableEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        FOREACHVARIABLEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static FOREACHVARIABLEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ForEachVariableEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ForEachVariableEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ClearArrayVariableEntityData {
    pub _glacier_base: WriteVariableBaseEntityData,
}

pub trait ClearArrayVariableEntityDataTrait: WriteVariableBaseEntityDataTrait {
}

impl ClearArrayVariableEntityDataTrait for ClearArrayVariableEntityData {
}

impl WriteVariableBaseEntityDataTrait for ClearArrayVariableEntityData {
}

impl VariableBaseEntityDataTrait for ClearArrayVariableEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn field_name_hash(&self) -> &u32 {
        self._glacier_base.field_name_hash()
    }
    fn field_type(&self) -> &glacier_reflect::builtin::TypeRef {
        self._glacier_base.field_type()
    }
    fn field_offset(&self) -> &u32 {
        self._glacier_base.field_offset()
    }
    fn use_data(&self) -> &bool {
        self._glacier_base.use_data()
    }
}

impl EntityDataTrait for ClearArrayVariableEntityData {
}

impl GameObjectDataTrait for ClearArrayVariableEntityData {
}

impl super::core::DataBusPeerTrait for ClearArrayVariableEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for ClearArrayVariableEntityData {
}

impl super::core::DataContainerTrait for ClearArrayVariableEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CLEARARRAYVARIABLEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClearArrayVariableEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(WRITEVARIABLEBASEENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ClearArrayVariableEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(CLEARARRAYVARIABLEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ClearArrayVariableEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CLEARARRAYVARIABLEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CLEARARRAYVARIABLEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClearArrayVariableEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ClearArrayVariableEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AddToArrayVariableEntityData {
    pub _glacier_base: WriteVariableBaseEntityData,
}

pub trait AddToArrayVariableEntityDataTrait: WriteVariableBaseEntityDataTrait {
}

impl AddToArrayVariableEntityDataTrait for AddToArrayVariableEntityData {
}

impl WriteVariableBaseEntityDataTrait for AddToArrayVariableEntityData {
}

impl VariableBaseEntityDataTrait for AddToArrayVariableEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn field_name_hash(&self) -> &u32 {
        self._glacier_base.field_name_hash()
    }
    fn field_type(&self) -> &glacier_reflect::builtin::TypeRef {
        self._glacier_base.field_type()
    }
    fn field_offset(&self) -> &u32 {
        self._glacier_base.field_offset()
    }
    fn use_data(&self) -> &bool {
        self._glacier_base.use_data()
    }
}

impl EntityDataTrait for AddToArrayVariableEntityData {
}

impl GameObjectDataTrait for AddToArrayVariableEntityData {
}

impl super::core::DataBusPeerTrait for AddToArrayVariableEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for AddToArrayVariableEntityData {
}

impl super::core::DataContainerTrait for AddToArrayVariableEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static ADDTOARRAYVARIABLEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AddToArrayVariableEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(WRITEVARIABLEBASEENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AddToArrayVariableEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(ADDTOARRAYVARIABLEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AddToArrayVariableEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        ADDTOARRAYVARIABLEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ADDTOARRAYVARIABLEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AddToArrayVariableEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("AddToArrayVariableEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WriteVariableEntityData {
    pub _glacier_base: WriteVariableBaseEntityData,
}

pub trait WriteVariableEntityDataTrait: WriteVariableBaseEntityDataTrait {
}

impl WriteVariableEntityDataTrait for WriteVariableEntityData {
}

impl WriteVariableBaseEntityDataTrait for WriteVariableEntityData {
}

impl VariableBaseEntityDataTrait for WriteVariableEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn field_name_hash(&self) -> &u32 {
        self._glacier_base.field_name_hash()
    }
    fn field_type(&self) -> &glacier_reflect::builtin::TypeRef {
        self._glacier_base.field_type()
    }
    fn field_offset(&self) -> &u32 {
        self._glacier_base.field_offset()
    }
    fn use_data(&self) -> &bool {
        self._glacier_base.use_data()
    }
}

impl EntityDataTrait for WriteVariableEntityData {
}

impl GameObjectDataTrait for WriteVariableEntityData {
}

impl super::core::DataBusPeerTrait for WriteVariableEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for WriteVariableEntityData {
}

impl super::core::DataContainerTrait for WriteVariableEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static WRITEVARIABLEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteVariableEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(WRITEVARIABLEBASEENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WriteVariableEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(WRITEVARIABLEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WriteVariableEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        WRITEVARIABLEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static WRITEVARIABLEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteVariableEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("WriteVariableEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ReadVariableEntityData {
    pub _glacier_base: ReadVariableBaseEntityData,
}

pub trait ReadVariableEntityDataTrait: ReadVariableBaseEntityDataTrait {
}

impl ReadVariableEntityDataTrait for ReadVariableEntityData {
}

impl ReadVariableBaseEntityDataTrait for ReadVariableEntityData {
}

impl VariableBaseEntityDataTrait for ReadVariableEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn field_name_hash(&self) -> &u32 {
        self._glacier_base.field_name_hash()
    }
    fn field_type(&self) -> &glacier_reflect::builtin::TypeRef {
        self._glacier_base.field_type()
    }
    fn field_offset(&self) -> &u32 {
        self._glacier_base.field_offset()
    }
    fn use_data(&self) -> &bool {
        self._glacier_base.use_data()
    }
}

impl EntityDataTrait for ReadVariableEntityData {
}

impl GameObjectDataTrait for ReadVariableEntityData {
}

impl super::core::DataBusPeerTrait for ReadVariableEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for ReadVariableEntityData {
}

impl super::core::DataContainerTrait for ReadVariableEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static READVARIABLEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadVariableEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(READVARIABLEBASEENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ReadVariableEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(READVARIABLEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ReadVariableEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        READVARIABLEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static READVARIABLEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadVariableEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ReadVariableEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WriteVariableBaseEntityData {
    pub _glacier_base: VariableBaseEntityData,
}

pub trait WriteVariableBaseEntityDataTrait: VariableBaseEntityDataTrait {
}

impl WriteVariableBaseEntityDataTrait for WriteVariableBaseEntityData {
}

impl VariableBaseEntityDataTrait for WriteVariableBaseEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn field_name_hash(&self) -> &u32 {
        self._glacier_base.field_name_hash()
    }
    fn field_type(&self) -> &glacier_reflect::builtin::TypeRef {
        self._glacier_base.field_type()
    }
    fn field_offset(&self) -> &u32 {
        self._glacier_base.field_offset()
    }
    fn use_data(&self) -> &bool {
        self._glacier_base.use_data()
    }
}

impl EntityDataTrait for WriteVariableBaseEntityData {
}

impl GameObjectDataTrait for WriteVariableBaseEntityData {
}

impl super::core::DataBusPeerTrait for WriteVariableBaseEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for WriteVariableBaseEntityData {
}

impl super::core::DataContainerTrait for WriteVariableBaseEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static WRITEVARIABLEBASEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteVariableBaseEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VARIABLEBASEENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WriteVariableBaseEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(WRITEVARIABLEBASEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WriteVariableBaseEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        WRITEVARIABLEBASEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static WRITEVARIABLEBASEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteVariableBaseEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("WriteVariableBaseEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ReadVariableBaseEntityData {
    pub _glacier_base: VariableBaseEntityData,
}

pub trait ReadVariableBaseEntityDataTrait: VariableBaseEntityDataTrait {
}

impl ReadVariableBaseEntityDataTrait for ReadVariableBaseEntityData {
}

impl VariableBaseEntityDataTrait for ReadVariableBaseEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn field_name_hash(&self) -> &u32 {
        self._glacier_base.field_name_hash()
    }
    fn field_type(&self) -> &glacier_reflect::builtin::TypeRef {
        self._glacier_base.field_type()
    }
    fn field_offset(&self) -> &u32 {
        self._glacier_base.field_offset()
    }
    fn use_data(&self) -> &bool {
        self._glacier_base.use_data()
    }
}

impl EntityDataTrait for ReadVariableBaseEntityData {
}

impl GameObjectDataTrait for ReadVariableBaseEntityData {
}

impl super::core::DataBusPeerTrait for ReadVariableBaseEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for ReadVariableBaseEntityData {
}

impl super::core::DataContainerTrait for ReadVariableBaseEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static READVARIABLEBASEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadVariableBaseEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VARIABLEBASEENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ReadVariableBaseEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(READVARIABLEBASEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ReadVariableBaseEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        READVARIABLEBASEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static READVARIABLEBASEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadVariableBaseEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ReadVariableBaseEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VariableBaseEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub field_name_hash: u32,
    pub field_type: glacier_reflect::builtin::TypeRef,
    pub field_offset: u32,
    pub use_data: bool,
}

pub trait VariableBaseEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn field_name_hash(&self) -> &u32;
    fn field_type(&self) -> &glacier_reflect::builtin::TypeRef;
    fn field_offset(&self) -> &u32;
    fn use_data(&self) -> &bool;
}

impl VariableBaseEntityDataTrait for VariableBaseEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn field_name_hash(&self) -> &u32 {
        &self.field_name_hash
    }
    fn field_type(&self) -> &glacier_reflect::builtin::TypeRef {
        &self.field_type
    }
    fn field_offset(&self) -> &u32 {
        &self.field_offset
    }
    fn use_data(&self) -> &bool {
        &self.use_data
    }
}

impl EntityDataTrait for VariableBaseEntityData {
}

impl GameObjectDataTrait for VariableBaseEntityData {
}

impl super::core::DataBusPeerTrait for VariableBaseEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for VariableBaseEntityData {
}

impl super::core::DataContainerTrait for VariableBaseEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static VARIABLEBASEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VariableBaseEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VariableBaseEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(VariableBaseEntityData, realm),
            },
            FieldInfoData {
                name: "FieldNameHash",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(VariableBaseEntityData, field_name_hash),
            },
            FieldInfoData {
                name: "FieldType",
                flags: MemberInfoFlags::new(0),
                field_type: "TypeRef",
                rust_offset: offset_of!(VariableBaseEntityData, field_type),
            },
            FieldInfoData {
                name: "FieldOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(VariableBaseEntityData, field_offset),
            },
            FieldInfoData {
                name: "UseData",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VariableBaseEntityData, use_data),
            },
        ],
    }),
    array_type: Some(VARIABLEBASEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for VariableBaseEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VARIABLEBASEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VARIABLEBASEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VariableBaseEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("VariableBaseEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct HighlightEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub color: super::core::Vec3,
    pub alpha: u8,
    pub top_left: super::core::Vec2,
    pub bottom_right: super::core::Vec2,
}

pub trait HighlightEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn color(&self) -> &super::core::Vec3;
    fn alpha(&self) -> &u8;
    fn top_left(&self) -> &super::core::Vec2;
    fn bottom_right(&self) -> &super::core::Vec2;
}

impl HighlightEntityDataTrait for HighlightEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn color(&self) -> &super::core::Vec3 {
        &self.color
    }
    fn alpha(&self) -> &u8 {
        &self.alpha
    }
    fn top_left(&self) -> &super::core::Vec2 {
        &self.top_left
    }
    fn bottom_right(&self) -> &super::core::Vec2 {
        &self.bottom_right
    }
}

impl EntityDataTrait for HighlightEntityData {
}

impl GameObjectDataTrait for HighlightEntityData {
}

impl super::core::DataBusPeerTrait for HighlightEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for HighlightEntityData {
}

impl super::core::DataContainerTrait for HighlightEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static HIGHLIGHTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HighlightEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<HighlightEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(HighlightEntityData, realm),
            },
            FieldInfoData {
                name: "Color",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(HighlightEntityData, color),
            },
            FieldInfoData {
                name: "Alpha",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(HighlightEntityData, alpha),
            },
            FieldInfoData {
                name: "TopLeft",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(HighlightEntityData, top_left),
            },
            FieldInfoData {
                name: "BottomRight",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(HighlightEntityData, bottom_right),
            },
        ],
    }),
    array_type: Some(HIGHLIGHTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for HighlightEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        HIGHLIGHTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static HIGHLIGHTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HighlightEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("HighlightEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TextSequenceEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub events: Vec<String>,
    pub items: Vec<Option<Arc<Mutex<dyn TextSequenceItemTrait>>>>,
    pub screen_position: super::core::Vec2,
}

pub trait TextSequenceEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn events(&self) -> &Vec<String>;
    fn items(&self) -> &Vec<Option<Arc<Mutex<dyn TextSequenceItemTrait>>>>;
    fn screen_position(&self) -> &super::core::Vec2;
}

impl TextSequenceEntityDataTrait for TextSequenceEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn events(&self) -> &Vec<String> {
        &self.events
    }
    fn items(&self) -> &Vec<Option<Arc<Mutex<dyn TextSequenceItemTrait>>>> {
        &self.items
    }
    fn screen_position(&self) -> &super::core::Vec2 {
        &self.screen_position
    }
}

impl EntityDataTrait for TextSequenceEntityData {
}

impl GameObjectDataTrait for TextSequenceEntityData {
}

impl super::core::DataBusPeerTrait for TextSequenceEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for TextSequenceEntityData {
}

impl super::core::DataContainerTrait for TextSequenceEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static TEXTSEQUENCEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TextSequenceEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TextSequenceEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(TextSequenceEntityData, realm),
            },
            FieldInfoData {
                name: "Events",
                flags: MemberInfoFlags::new(144),
                field_type: "CString-Array",
                rust_offset: offset_of!(TextSequenceEntityData, events),
            },
            FieldInfoData {
                name: "Items",
                flags: MemberInfoFlags::new(144),
                field_type: "TextSequenceItem-Array",
                rust_offset: offset_of!(TextSequenceEntityData, items),
            },
            FieldInfoData {
                name: "ScreenPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(TextSequenceEntityData, screen_position),
            },
        ],
    }),
    array_type: Some(TEXTSEQUENCEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TextSequenceEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TEXTSEQUENCEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static TEXTSEQUENCEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TextSequenceEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TextSequenceEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TextSequenceItem {
    pub _glacier_base: super::core::DataContainer,
    pub text: String,
    pub text_color: super::core::Vec3,
    pub screen_position: super::core::Vec2,
    pub use_entity_screen_position: bool,
    pub time_to_show: f32,
    pub trigger_event: String,
}

pub trait TextSequenceItemTrait: super::core::DataContainerTrait {
    fn text(&self) -> &String;
    fn text_color(&self) -> &super::core::Vec3;
    fn screen_position(&self) -> &super::core::Vec2;
    fn use_entity_screen_position(&self) -> &bool;
    fn time_to_show(&self) -> &f32;
    fn trigger_event(&self) -> &String;
}

impl TextSequenceItemTrait for TextSequenceItem {
    fn text(&self) -> &String {
        &self.text
    }
    fn text_color(&self) -> &super::core::Vec3 {
        &self.text_color
    }
    fn screen_position(&self) -> &super::core::Vec2 {
        &self.screen_position
    }
    fn use_entity_screen_position(&self) -> &bool {
        &self.use_entity_screen_position
    }
    fn time_to_show(&self) -> &f32 {
        &self.time_to_show
    }
    fn trigger_event(&self) -> &String {
        &self.trigger_event
    }
}

impl super::core::DataContainerTrait for TextSequenceItem {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static TEXTSEQUENCEITEM_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TextSequenceItem",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TextSequenceItem as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Text",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(TextSequenceItem, text),
            },
            FieldInfoData {
                name: "TextColor",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(TextSequenceItem, text_color),
            },
            FieldInfoData {
                name: "ScreenPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(TextSequenceItem, screen_position),
            },
            FieldInfoData {
                name: "UseEntityScreenPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TextSequenceItem, use_entity_screen_position),
            },
            FieldInfoData {
                name: "TimeToShow",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TextSequenceItem, time_to_show),
            },
            FieldInfoData {
                name: "TriggerEvent",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(TextSequenceItem, trigger_event),
            },
        ],
    }),
    array_type: Some(TEXTSEQUENCEITEM_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for TextSequenceItem {
    fn type_info(&self) -> &'static TypeInfo {
        TEXTSEQUENCEITEM_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static TEXTSEQUENCEITEM_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TextSequenceItem-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TextSequenceItem"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TreeBase {
    pub _glacier_base: super::core::Asset,
}

pub trait TreeBaseTrait: super::core::AssetTrait {
}

impl TreeBaseTrait for TreeBase {
}

impl super::core::AssetTrait for TreeBase {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for TreeBase {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static TREEBASE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TreeBase",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TreeBase as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(TREEBASE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TreeBase {
    fn type_info(&self) -> &'static TypeInfo {
        TREEBASE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static TREEBASE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TreeBase-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TreeBase"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TreeNodeBase {
    pub _glacier_base: super::core::DataContainer,
}

pub trait TreeNodeBaseTrait: super::core::DataContainerTrait {
}

impl TreeNodeBaseTrait for TreeNodeBase {
}

impl super::core::DataContainerTrait for TreeNodeBase {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static TREENODEBASE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TreeNodeBase",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TreeNodeBase as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(TREENODEBASE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TreeNodeBase {
    fn type_info(&self) -> &'static TypeInfo {
        TREENODEBASE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static TREENODEBASE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TreeNodeBase-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TreeNodeBase"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SubLevelDestroyedMessage {
}

pub trait SubLevelDestroyedMessageTrait: TypeObject {
}

impl SubLevelDestroyedMessageTrait for SubLevelDestroyedMessage {
}

pub static SUBLEVELDESTROYEDMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubLevelDestroyedMessage",
    flags: MemberInfoFlags::new(36937),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SubLevelDestroyedMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for SubLevelDestroyedMessage {
    fn type_info(&self) -> &'static TypeInfo {
        SUBLEVELDESTROYEDMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}

#[derive(Clone, Debug, Default)]
pub struct SubLevelEntitiesCreatedMessage {
}

pub trait SubLevelEntitiesCreatedMessageTrait: TypeObject {
}

impl SubLevelEntitiesCreatedMessageTrait for SubLevelEntitiesCreatedMessage {
}

pub static SUBLEVELENTITIESCREATEDMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubLevelEntitiesCreatedMessage",
    flags: MemberInfoFlags::new(36937),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SubLevelEntitiesCreatedMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for SubLevelEntitiesCreatedMessage {
    fn type_info(&self) -> &'static TypeInfo {
        SUBLEVELENTITIESCREATEDMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}

#[derive(Clone, Debug, Default)]
pub struct ReportInstallationProgressEntityData {
    pub _glacier_base: EntityData,
    pub install_group_name: String,
}

pub trait ReportInstallationProgressEntityDataTrait: EntityDataTrait {
    fn install_group_name(&self) -> &String;
}

impl ReportInstallationProgressEntityDataTrait for ReportInstallationProgressEntityData {
    fn install_group_name(&self) -> &String {
        &self.install_group_name
    }
}

impl EntityDataTrait for ReportInstallationProgressEntityData {
}

impl GameObjectDataTrait for ReportInstallationProgressEntityData {
}

impl super::core::DataBusPeerTrait for ReportInstallationProgressEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for ReportInstallationProgressEntityData {
}

impl super::core::DataContainerTrait for ReportInstallationProgressEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static REPORTINSTALLATIONPROGRESSENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReportInstallationProgressEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ReportInstallationProgressEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "InstallGroupName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ReportInstallationProgressEntityData, install_group_name),
            },
        ],
    }),
    array_type: Some(REPORTINSTALLATIONPROGRESSENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ReportInstallationProgressEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        REPORTINSTALLATIONPROGRESSENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static REPORTINSTALLATIONPROGRESSENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReportInstallationProgressEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ReportInstallationProgressEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LocalPlayerIdEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub default_value: super::core::LocalPlayerId,
    pub r#in: super::core::LocalPlayerId,
}

pub trait LocalPlayerIdEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn default_value(&self) -> &super::core::LocalPlayerId;
    fn r#in(&self) -> &super::core::LocalPlayerId;
}

impl LocalPlayerIdEntityDataTrait for LocalPlayerIdEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn default_value(&self) -> &super::core::LocalPlayerId {
        &self.default_value
    }
    fn r#in(&self) -> &super::core::LocalPlayerId {
        &self.r#in
    }
}

impl EntityDataTrait for LocalPlayerIdEntityData {
}

impl GameObjectDataTrait for LocalPlayerIdEntityData {
}

impl super::core::DataBusPeerTrait for LocalPlayerIdEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for LocalPlayerIdEntityData {
}

impl super::core::DataContainerTrait for LocalPlayerIdEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static LOCALPLAYERIDENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalPlayerIdEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LocalPlayerIdEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(LocalPlayerIdEntityData, realm),
            },
            FieldInfoData {
                name: "DefaultValue",
                flags: MemberInfoFlags::new(0),
                field_type: "LocalPlayerId",
                rust_offset: offset_of!(LocalPlayerIdEntityData, default_value),
            },
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "LocalPlayerId",
                rust_offset: offset_of!(LocalPlayerIdEntityData, r#in),
            },
        ],
    }),
    array_type: Some(LOCALPLAYERIDENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LocalPlayerIdEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        LOCALPLAYERIDENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static LOCALPLAYERIDENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalPlayerIdEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("LocalPlayerIdEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FloatCacheEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub load_on_create: bool,
    pub in_value: f32,
}

pub trait FloatCacheEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn load_on_create(&self) -> &bool;
    fn in_value(&self) -> &f32;
}

impl FloatCacheEntityDataTrait for FloatCacheEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn load_on_create(&self) -> &bool {
        &self.load_on_create
    }
    fn in_value(&self) -> &f32 {
        &self.in_value
    }
}

impl EntityDataTrait for FloatCacheEntityData {
}

impl GameObjectDataTrait for FloatCacheEntityData {
}

impl super::core::DataBusPeerTrait for FloatCacheEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for FloatCacheEntityData {
}

impl super::core::DataContainerTrait for FloatCacheEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static FLOATCACHEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatCacheEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FloatCacheEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(FloatCacheEntityData, realm),
            },
            FieldInfoData {
                name: "LoadOnCreate",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FloatCacheEntityData, load_on_create),
            },
            FieldInfoData {
                name: "InValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FloatCacheEntityData, in_value),
            },
        ],
    }),
    array_type: Some(FLOATCACHEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FloatCacheEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        FLOATCACHEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static FLOATCACHEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatCacheEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("FloatCacheEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MultilineStringEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub value: String,
}

pub trait MultilineStringEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn value(&self) -> &String;
}

impl MultilineStringEntityDataTrait for MultilineStringEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn value(&self) -> &String {
        &self.value
    }
}

impl EntityDataTrait for MultilineStringEntityData {
}

impl GameObjectDataTrait for MultilineStringEntityData {
}

impl super::core::DataBusPeerTrait for MultilineStringEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for MultilineStringEntityData {
}

impl super::core::DataContainerTrait for MultilineStringEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static MULTILINESTRINGENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultilineStringEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MultilineStringEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(MultilineStringEntityData, realm),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(MultilineStringEntityData, value),
            },
        ],
    }),
    array_type: Some(MULTILINESTRINGENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MultilineStringEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        MULTILINESTRINGENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static MULTILINESTRINGENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultilineStringEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("MultilineStringEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct StringEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub default_string: String,
}

pub trait StringEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn default_string(&self) -> &String;
}

impl StringEntityDataTrait for StringEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn default_string(&self) -> &String {
        &self.default_string
    }
}

impl EntityDataTrait for StringEntityData {
}

impl GameObjectDataTrait for StringEntityData {
}

impl super::core::DataBusPeerTrait for StringEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for StringEntityData {
}

impl super::core::DataContainerTrait for StringEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static STRINGENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StringEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StringEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(StringEntityData, realm),
            },
            FieldInfoData {
                name: "DefaultString",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(StringEntityData, default_string),
            },
        ],
    }),
    array_type: Some(STRINGENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for StringEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        STRINGENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static STRINGENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StringEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("StringEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TransformEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub default_transform: super::core::LinearTransform,
}

pub trait TransformEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn default_transform(&self) -> &super::core::LinearTransform;
}

impl TransformEntityDataTrait for TransformEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn default_transform(&self) -> &super::core::LinearTransform {
        &self.default_transform
    }
}

impl EntityDataTrait for TransformEntityData {
}

impl GameObjectDataTrait for TransformEntityData {
}

impl super::core::DataBusPeerTrait for TransformEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for TransformEntityData {
}

impl super::core::DataContainerTrait for TransformEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static TRANSFORMENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(TransformEntityData, realm),
            },
            FieldInfoData {
                name: "DefaultTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(TransformEntityData, default_transform),
            },
        ],
    }),
    array_type: Some(TRANSFORMENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for TransformEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static TRANSFORMENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TransformEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AxisAlignedBoxEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub aabb_min: super::core::Vec3,
    pub aabb_max: super::core::Vec3,
}

pub trait AxisAlignedBoxEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn aabb_min(&self) -> &super::core::Vec3;
    fn aabb_max(&self) -> &super::core::Vec3;
}

impl AxisAlignedBoxEntityDataTrait for AxisAlignedBoxEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn aabb_min(&self) -> &super::core::Vec3 {
        &self.aabb_min
    }
    fn aabb_max(&self) -> &super::core::Vec3 {
        &self.aabb_max
    }
}

impl EntityDataTrait for AxisAlignedBoxEntityData {
}

impl GameObjectDataTrait for AxisAlignedBoxEntityData {
}

impl super::core::DataBusPeerTrait for AxisAlignedBoxEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for AxisAlignedBoxEntityData {
}

impl super::core::DataContainerTrait for AxisAlignedBoxEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static AXISALIGNEDBOXENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AxisAlignedBoxEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AxisAlignedBoxEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(AxisAlignedBoxEntityData, realm),
            },
            FieldInfoData {
                name: "AabbMin",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(AxisAlignedBoxEntityData, aabb_min),
            },
            FieldInfoData {
                name: "AabbMax",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(AxisAlignedBoxEntityData, aabb_max),
            },
        ],
    }),
    array_type: Some(AXISALIGNEDBOXENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AxisAlignedBoxEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AXISALIGNEDBOXENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static AXISALIGNEDBOXENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AxisAlignedBoxEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("AxisAlignedBoxEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Vector4EntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub default_vec4: super::core::Vec4,
}

pub trait Vector4EntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn default_vec4(&self) -> &super::core::Vec4;
}

impl Vector4EntityDataTrait for Vector4EntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn default_vec4(&self) -> &super::core::Vec4 {
        &self.default_vec4
    }
}

impl EntityDataTrait for Vector4EntityData {
}

impl GameObjectDataTrait for Vector4EntityData {
}

impl super::core::DataBusPeerTrait for Vector4EntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for Vector4EntityData {
}

impl super::core::DataContainerTrait for Vector4EntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static VECTOR4ENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vector4EntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vector4EntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(Vector4EntityData, realm),
            },
            FieldInfoData {
                name: "DefaultVec4",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(Vector4EntityData, default_vec4),
            },
        ],
    }),
    array_type: Some(VECTOR4ENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for Vector4EntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VECTOR4ENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VECTOR4ENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vector4EntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vector4EntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Vector3EntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub default_vec3: super::core::Vec3,
}

pub trait Vector3EntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn default_vec3(&self) -> &super::core::Vec3;
}

impl Vector3EntityDataTrait for Vector3EntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn default_vec3(&self) -> &super::core::Vec3 {
        &self.default_vec3
    }
}

impl EntityDataTrait for Vector3EntityData {
}

impl GameObjectDataTrait for Vector3EntityData {
}

impl super::core::DataBusPeerTrait for Vector3EntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for Vector3EntityData {
}

impl super::core::DataContainerTrait for Vector3EntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static VECTOR3ENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vector3EntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vector3EntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(Vector3EntityData, realm),
            },
            FieldInfoData {
                name: "DefaultVec3",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(Vector3EntityData, default_vec3),
            },
        ],
    }),
    array_type: Some(VECTOR3ENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for Vector3EntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VECTOR3ENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VECTOR3ENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vector3EntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vector3EntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FloatEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub default_value: f32,
    pub inc_dec_value: f32,
}

pub trait FloatEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn default_value(&self) -> &f32;
    fn inc_dec_value(&self) -> &f32;
}

impl FloatEntityDataTrait for FloatEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn default_value(&self) -> &f32 {
        &self.default_value
    }
    fn inc_dec_value(&self) -> &f32 {
        &self.inc_dec_value
    }
}

impl EntityDataTrait for FloatEntityData {
}

impl GameObjectDataTrait for FloatEntityData {
}

impl super::core::DataBusPeerTrait for FloatEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for FloatEntityData {
}

impl super::core::DataContainerTrait for FloatEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static FLOATENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FloatEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(FloatEntityData, realm),
            },
            FieldInfoData {
                name: "DefaultValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FloatEntityData, default_value),
            },
            FieldInfoData {
                name: "IncDecValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FloatEntityData, inc_dec_value),
            },
        ],
    }),
    array_type: Some(FLOATENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FloatEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        FLOATENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static FLOATENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("FloatEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct UIntEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub default_value: u32,
    pub inc_dec_value: u32,
}

pub trait UIntEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn default_value(&self) -> &u32;
    fn inc_dec_value(&self) -> &u32;
}

impl UIntEntityDataTrait for UIntEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn default_value(&self) -> &u32 {
        &self.default_value
    }
    fn inc_dec_value(&self) -> &u32 {
        &self.inc_dec_value
    }
}

impl EntityDataTrait for UIntEntityData {
}

impl GameObjectDataTrait for UIntEntityData {
}

impl super::core::DataBusPeerTrait for UIntEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for UIntEntityData {
}

impl super::core::DataContainerTrait for UIntEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static UINTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UIntEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<UIntEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(UIntEntityData, realm),
            },
            FieldInfoData {
                name: "DefaultValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(UIntEntityData, default_value),
            },
            FieldInfoData {
                name: "IncDecValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(UIntEntityData, inc_dec_value),
            },
        ],
    }),
    array_type: Some(UINTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for UIntEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        UINTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static UINTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UIntEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("UIntEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct IntEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub default_value: i32,
    pub inc_dec_value: i32,
}

pub trait IntEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn default_value(&self) -> &i32;
    fn inc_dec_value(&self) -> &i32;
}

impl IntEntityDataTrait for IntEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn default_value(&self) -> &i32 {
        &self.default_value
    }
    fn inc_dec_value(&self) -> &i32 {
        &self.inc_dec_value
    }
}

impl EntityDataTrait for IntEntityData {
}

impl GameObjectDataTrait for IntEntityData {
}

impl super::core::DataBusPeerTrait for IntEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for IntEntityData {
}

impl super::core::DataContainerTrait for IntEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static INTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<IntEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(IntEntityData, realm),
            },
            FieldInfoData {
                name: "DefaultValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(IntEntityData, default_value),
            },
            FieldInfoData {
                name: "IncDecValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(IntEntityData, inc_dec_value),
            },
        ],
    }),
    array_type: Some(INTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for IntEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        INTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static INTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("IntEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BoolEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub default_value: bool,
}

pub trait BoolEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn default_value(&self) -> &bool;
}

impl BoolEntityDataTrait for BoolEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn default_value(&self) -> &bool {
        &self.default_value
    }
}

impl EntityDataTrait for BoolEntityData {
}

impl GameObjectDataTrait for BoolEntityData {
}

impl super::core::DataBusPeerTrait for BoolEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for BoolEntityData {
}

impl super::core::DataContainerTrait for BoolEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static BOOLENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BoolEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(BoolEntityData, realm),
            },
            FieldInfoData {
                name: "DefaultValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BoolEntityData, default_value),
            },
        ],
    }),
    array_type: Some(BOOLENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BoolEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        BOOLENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static BOOLENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("BoolEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MasterSkeletonAsset {
    pub _glacier_base: super::core::Asset,
    pub master_skeleton: Option<Arc<Mutex<dyn SkeletonAssetTrait>>>,
    pub sub_skeletons: Vec<SubSkeleton>,
}

pub trait MasterSkeletonAssetTrait: super::core::AssetTrait {
    fn master_skeleton(&self) -> &Option<Arc<Mutex<dyn SkeletonAssetTrait>>>;
    fn sub_skeletons(&self) -> &Vec<SubSkeleton>;
}

impl MasterSkeletonAssetTrait for MasterSkeletonAsset {
    fn master_skeleton(&self) -> &Option<Arc<Mutex<dyn SkeletonAssetTrait>>> {
        &self.master_skeleton
    }
    fn sub_skeletons(&self) -> &Vec<SubSkeleton> {
        &self.sub_skeletons
    }
}

impl super::core::AssetTrait for MasterSkeletonAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for MasterSkeletonAsset {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static MASTERSKELETONASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MasterSkeletonAsset",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MasterSkeletonAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MasterSkeleton",
                flags: MemberInfoFlags::new(0),
                field_type: "SkeletonAsset",
                rust_offset: offset_of!(MasterSkeletonAsset, master_skeleton),
            },
            FieldInfoData {
                name: "SubSkeletons",
                flags: MemberInfoFlags::new(144),
                field_type: "SubSkeleton-Array",
                rust_offset: offset_of!(MasterSkeletonAsset, sub_skeletons),
            },
        ],
    }),
    array_type: Some(MASTERSKELETONASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MasterSkeletonAsset {
    fn type_info(&self) -> &'static TypeInfo {
        MASTERSKELETONASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static MASTERSKELETONASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MasterSkeletonAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("MasterSkeletonAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SubSkeleton {
    pub skeleton: Option<Arc<Mutex<dyn SkeletonAssetTrait>>>,
    pub bone_map: Vec<i32>,
    pub transform_map: Vec<super::core::LinearTransform>,
}

pub trait SubSkeletonTrait: TypeObject {
    fn skeleton(&self) -> &Option<Arc<Mutex<dyn SkeletonAssetTrait>>>;
    fn bone_map(&self) -> &Vec<i32>;
    fn transform_map(&self) -> &Vec<super::core::LinearTransform>;
}

impl SubSkeletonTrait for SubSkeleton {
    fn skeleton(&self) -> &Option<Arc<Mutex<dyn SkeletonAssetTrait>>> {
        &self.skeleton
    }
    fn bone_map(&self) -> &Vec<i32> {
        &self.bone_map
    }
    fn transform_map(&self) -> &Vec<super::core::LinearTransform> {
        &self.transform_map
    }
}

pub static SUBSKELETON_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubSkeleton",
    flags: MemberInfoFlags::new(73),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SubSkeleton as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Skeleton",
                flags: MemberInfoFlags::new(0),
                field_type: "SkeletonAsset",
                rust_offset: offset_of!(SubSkeleton, skeleton),
            },
            FieldInfoData {
                name: "BoneMap",
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(SubSkeleton, bone_map),
            },
            FieldInfoData {
                name: "TransformMap",
                flags: MemberInfoFlags::new(144),
                field_type: "LinearTransform-Array",
                rust_offset: offset_of!(SubSkeleton, transform_map),
            },
        ],
    }),
    array_type: Some(SUBSKELETON_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SubSkeleton {
    fn type_info(&self) -> &'static TypeInfo {
        SUBSKELETON_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SUBSKELETON_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubSkeleton-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SubSkeleton"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SkeletonAsset {
    pub _glacier_base: SkeletonBaseAsset,
    pub bone_names: Vec<String>,
    pub bone_name_hashes: Vec<u32>,
    pub hierarchy: Vec<i32>,
    pub local_pose: Vec<super::core::LinearTransform>,
    pub model_pose: Vec<super::core::LinearTransform>,
    pub inverse_model_pose: Vec<super::core::LinearTransform>,
    pub server_skeleton_to_skeleton_map: Vec<i32>,
    pub skeleton_to_server_skeleton_map: Vec<i32>,
    pub server_hierarchy: Vec<i32>,
    pub gameplay_bones_to_skeleton: Vec<i32>,
    pub gameplay_bones_to_server_skeleton: Vec<i32>,
}

pub trait SkeletonAssetTrait: SkeletonBaseAssetTrait {
    fn bone_names(&self) -> &Vec<String>;
    fn bone_name_hashes(&self) -> &Vec<u32>;
    fn hierarchy(&self) -> &Vec<i32>;
    fn local_pose(&self) -> &Vec<super::core::LinearTransform>;
    fn model_pose(&self) -> &Vec<super::core::LinearTransform>;
    fn inverse_model_pose(&self) -> &Vec<super::core::LinearTransform>;
    fn server_skeleton_to_skeleton_map(&self) -> &Vec<i32>;
    fn skeleton_to_server_skeleton_map(&self) -> &Vec<i32>;
    fn server_hierarchy(&self) -> &Vec<i32>;
    fn gameplay_bones_to_skeleton(&self) -> &Vec<i32>;
    fn gameplay_bones_to_server_skeleton(&self) -> &Vec<i32>;
}

impl SkeletonAssetTrait for SkeletonAsset {
    fn bone_names(&self) -> &Vec<String> {
        &self.bone_names
    }
    fn bone_name_hashes(&self) -> &Vec<u32> {
        &self.bone_name_hashes
    }
    fn hierarchy(&self) -> &Vec<i32> {
        &self.hierarchy
    }
    fn local_pose(&self) -> &Vec<super::core::LinearTransform> {
        &self.local_pose
    }
    fn model_pose(&self) -> &Vec<super::core::LinearTransform> {
        &self.model_pose
    }
    fn inverse_model_pose(&self) -> &Vec<super::core::LinearTransform> {
        &self.inverse_model_pose
    }
    fn server_skeleton_to_skeleton_map(&self) -> &Vec<i32> {
        &self.server_skeleton_to_skeleton_map
    }
    fn skeleton_to_server_skeleton_map(&self) -> &Vec<i32> {
        &self.skeleton_to_server_skeleton_map
    }
    fn server_hierarchy(&self) -> &Vec<i32> {
        &self.server_hierarchy
    }
    fn gameplay_bones_to_skeleton(&self) -> &Vec<i32> {
        &self.gameplay_bones_to_skeleton
    }
    fn gameplay_bones_to_server_skeleton(&self) -> &Vec<i32> {
        &self.gameplay_bones_to_server_skeleton
    }
}

impl SkeletonBaseAssetTrait for SkeletonAsset {
}

impl super::core::AssetTrait for SkeletonAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for SkeletonAsset {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SKELETONASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SkeletonAsset",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SKELETONBASEASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SkeletonAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "BoneNames",
                flags: MemberInfoFlags::new(144),
                field_type: "CString-Array",
                rust_offset: offset_of!(SkeletonAsset, bone_names),
            },
            FieldInfoData {
                name: "BoneNameHashes",
                flags: MemberInfoFlags::new(144),
                field_type: "Uint32-Array",
                rust_offset: offset_of!(SkeletonAsset, bone_name_hashes),
            },
            FieldInfoData {
                name: "Hierarchy",
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(SkeletonAsset, hierarchy),
            },
            FieldInfoData {
                name: "LocalPose",
                flags: MemberInfoFlags::new(144),
                field_type: "LinearTransform-Array",
                rust_offset: offset_of!(SkeletonAsset, local_pose),
            },
            FieldInfoData {
                name: "ModelPose",
                flags: MemberInfoFlags::new(144),
                field_type: "LinearTransform-Array",
                rust_offset: offset_of!(SkeletonAsset, model_pose),
            },
            FieldInfoData {
                name: "InverseModelPose",
                flags: MemberInfoFlags::new(144),
                field_type: "LinearTransform-Array",
                rust_offset: offset_of!(SkeletonAsset, inverse_model_pose),
            },
            FieldInfoData {
                name: "ServerSkeletonToSkeletonMap",
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(SkeletonAsset, server_skeleton_to_skeleton_map),
            },
            FieldInfoData {
                name: "SkeletonToServerSkeletonMap",
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(SkeletonAsset, skeleton_to_server_skeleton_map),
            },
            FieldInfoData {
                name: "ServerHierarchy",
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(SkeletonAsset, server_hierarchy),
            },
            FieldInfoData {
                name: "GameplayBonesToSkeleton",
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(SkeletonAsset, gameplay_bones_to_skeleton),
            },
            FieldInfoData {
                name: "GameplayBonesToServerSkeleton",
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(SkeletonAsset, gameplay_bones_to_server_skeleton),
            },
        ],
    }),
    array_type: Some(SKELETONASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SkeletonAsset {
    fn type_info(&self) -> &'static TypeInfo {
        SKELETONASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SKELETONASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SkeletonAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SkeletonAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BoneSelection {
    pub bone_name_hashes: Vec<u32>,
}

pub trait BoneSelectionTrait: TypeObject {
    fn bone_name_hashes(&self) -> &Vec<u32>;
}

impl BoneSelectionTrait for BoneSelection {
    fn bone_name_hashes(&self) -> &Vec<u32> {
        &self.bone_name_hashes
    }
}

pub static BONESELECTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoneSelection",
    flags: MemberInfoFlags::new(73),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BoneSelection as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "BoneNameHashes",
                flags: MemberInfoFlags::new(144),
                field_type: "Uint32-Array",
                rust_offset: offset_of!(BoneSelection, bone_name_hashes),
            },
        ],
    }),
    array_type: Some(BONESELECTION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BoneSelection {
    fn type_info(&self) -> &'static TypeInfo {
        BONESELECTION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static BONESELECTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoneSelection-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("BoneSelection"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GameplayBone {
    pub name: String,
    pub bone: GameplayBones,
}

pub trait GameplayBoneTrait: TypeObject {
    fn name(&self) -> &String;
    fn bone(&self) -> &GameplayBones;
}

impl GameplayBoneTrait for GameplayBone {
    fn name(&self) -> &String {
        &self.name
    }
    fn bone(&self) -> &GameplayBones {
        &self.bone
    }
}

pub static GAMEPLAYBONE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameplayBone",
    flags: MemberInfoFlags::new(73),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GameplayBone as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(GameplayBone, name),
            },
            FieldInfoData {
                name: "Bone",
                flags: MemberInfoFlags::new(0),
                field_type: "GameplayBones",
                rust_offset: offset_of!(GameplayBone, bone),
            },
        ],
    }),
    array_type: Some(GAMEPLAYBONE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for GameplayBone {
    fn type_info(&self) -> &'static TypeInfo {
        GAMEPLAYBONE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static GAMEPLAYBONE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameplayBone-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("GameplayBone"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum GameplayBones {
    #[default]
    GameplayBones_UndefinedBone = 4294967295,
    GameplayBones_RootBone = 0,
    GameplayBones_RootMeshBone = 1,
    GameplayBones_ConnectBone = 2,
    GameplayBones_HeadBone = 3,
    GameplayBones_CameraBone = 4,
    GameplayBones_AimBone = 5,
    GameplayBones_WeaponBone = 6,
    GameplayBones_WeaponBone2 = 7,
    GameplayBones_WeaponAux1Bone = 8,
    GameplayBones_LeftArmBone = 9,
    GameplayBones_RightArmBone = 10,
    GameplayBones_SpineBone = 11,
    GameplayBones_WeaponMuzzleBone = 12,
    GameplayBones_WeaponShellEjectBone = 13,
    GameplayBones_LeftHandBone = 14,
    GameplayBones_RightHandBone = 15,
    GameplayBones_LeftFootBone = 16,
    GameplayBones_RightFootBone = 17,
    GameplayBones_BackPack = 18,
    GameplayBones_PleaseDeleteMeHackDroidBone = 19,
    GameplayBones_WeaponMuzzleBone2 = 20,
    GameplayBones_WeaponMuzzleBone3 = 21,
    GameplayBones_WeaponMuzzleBone4 = 22,
    GameplayBones_WeaponMuzzleBone5 = 23,
    GameplayBones_Count = 24,
}

pub static GAMEPLAYBONES_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameplayBones",
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(GAMEPLAYBONES_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for GameplayBones {
    fn type_info(&self) -> &'static TypeInfo {
        GAMEPLAYBONES_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static GAMEPLAYBONES_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameplayBones-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("GameplayBones"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SharedBundleReference {
    pub name: String,
    pub heap: BundleHeapInfo,
}

pub trait SharedBundleReferenceTrait: TypeObject {
    fn name(&self) -> &String;
    fn heap(&self) -> &BundleHeapInfo;
}

impl SharedBundleReferenceTrait for SharedBundleReference {
    fn name(&self) -> &String {
        &self.name
    }
    fn heap(&self) -> &BundleHeapInfo {
        &self.heap
    }
}

pub static SHAREDBUNDLEREFERENCE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SharedBundleReference",
    flags: MemberInfoFlags::new(73),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SharedBundleReference as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(SharedBundleReference, name),
            },
            FieldInfoData {
                name: "Heap",
                flags: MemberInfoFlags::new(0),
                field_type: "BundleHeapInfo",
                rust_offset: offset_of!(SharedBundleReference, heap),
            },
        ],
    }),
    array_type: Some(SHAREDBUNDLEREFERENCE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SharedBundleReference {
    fn type_info(&self) -> &'static TypeInfo {
        SHAREDBUNDLEREFERENCE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SHAREDBUNDLEREFERENCE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SharedBundleReference-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SharedBundleReference"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SharedBundleBaseAsset {
    pub _glacier_base: super::core::Asset,
}

pub trait SharedBundleBaseAssetTrait: super::core::AssetTrait {
}

impl SharedBundleBaseAssetTrait for SharedBundleBaseAsset {
}

impl super::core::AssetTrait for SharedBundleBaseAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for SharedBundleBaseAsset {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SHAREDBUNDLEBASEASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SharedBundleBaseAsset",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SharedBundleBaseAsset as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SHAREDBUNDLEBASEASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SharedBundleBaseAsset {
    fn type_info(&self) -> &'static TypeInfo {
        SHAREDBUNDLEBASEASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SHAREDBUNDLEBASEASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SharedBundleBaseAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SharedBundleBaseAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ScanlineVolumeShapeData {
    pub _glacier_base: VolumeVectorShapeData,
    pub x_step: f32,
    pub y_step: f32,
    pub z_step: f32,
}

pub trait ScanlineVolumeShapeDataTrait: VolumeVectorShapeDataTrait {
    fn x_step(&self) -> &f32;
    fn y_step(&self) -> &f32;
    fn z_step(&self) -> &f32;
}

impl ScanlineVolumeShapeDataTrait for ScanlineVolumeShapeData {
    fn x_step(&self) -> &f32 {
        &self.x_step
    }
    fn y_step(&self) -> &f32 {
        &self.y_step
    }
    fn z_step(&self) -> &f32 {
        &self.z_step
    }
}

impl VolumeVectorShapeDataTrait for ScanlineVolumeShapeData {
    fn height(&self) -> &f32 {
        self._glacier_base.height()
    }
}

impl VectorShapeDataTrait for ScanlineVolumeShapeData {
    fn points(&self) -> &Vec<super::core::Vec3> {
        self._glacier_base.points()
    }
    fn tension(&self) -> &f32 {
        self._glacier_base.tension()
    }
    fn is_closed(&self) -> &bool {
        self._glacier_base.is_closed()
    }
    fn allow_roll(&self) -> &bool {
        self._glacier_base.allow_roll()
    }
    fn allow_yaw_pitch(&self) -> &bool {
        self._glacier_base.allow_yaw_pitch()
    }
}

impl BaseShapeDataTrait for ScanlineVolumeShapeData {
}

impl BaseShapeDataBaseTrait for ScanlineVolumeShapeData {
}

impl GameObjectDataTrait for ScanlineVolumeShapeData {
}

impl super::core::DataBusPeerTrait for ScanlineVolumeShapeData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for ScanlineVolumeShapeData {
}

impl super::core::DataContainerTrait for ScanlineVolumeShapeData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SCANLINEVOLUMESHAPEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScanlineVolumeShapeData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOLUMEVECTORSHAPEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ScanlineVolumeShapeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "xStep",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ScanlineVolumeShapeData, x_step),
            },
            FieldInfoData {
                name: "yStep",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ScanlineVolumeShapeData, y_step),
            },
            FieldInfoData {
                name: "zStep",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ScanlineVolumeShapeData, z_step),
            },
        ],
    }),
    array_type: Some(SCANLINEVOLUMESHAPEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ScanlineVolumeShapeData {
    fn type_info(&self) -> &'static TypeInfo {
        SCANLINEVOLUMESHAPEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SCANLINEVOLUMESHAPEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScanlineVolumeShapeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ScanlineVolumeShapeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ZoneVectorShapeData {
    pub _glacier_base: VectorShapeData,
}

pub trait ZoneVectorShapeDataTrait: VectorShapeDataTrait {
}

impl ZoneVectorShapeDataTrait for ZoneVectorShapeData {
}

impl VectorShapeDataTrait for ZoneVectorShapeData {
    fn points(&self) -> &Vec<super::core::Vec3> {
        self._glacier_base.points()
    }
    fn tension(&self) -> &f32 {
        self._glacier_base.tension()
    }
    fn is_closed(&self) -> &bool {
        self._glacier_base.is_closed()
    }
    fn allow_roll(&self) -> &bool {
        self._glacier_base.allow_roll()
    }
    fn allow_yaw_pitch(&self) -> &bool {
        self._glacier_base.allow_yaw_pitch()
    }
}

impl BaseShapeDataTrait for ZoneVectorShapeData {
}

impl BaseShapeDataBaseTrait for ZoneVectorShapeData {
}

impl GameObjectDataTrait for ZoneVectorShapeData {
}

impl super::core::DataBusPeerTrait for ZoneVectorShapeData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for ZoneVectorShapeData {
}

impl super::core::DataContainerTrait for ZoneVectorShapeData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static ZONEVECTORSHAPEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ZoneVectorShapeData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VECTORSHAPEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ZoneVectorShapeData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(ZONEVECTORSHAPEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ZoneVectorShapeData {
    fn type_info(&self) -> &'static TypeInfo {
        ZONEVECTORSHAPEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ZONEVECTORSHAPEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ZoneVectorShapeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ZoneVectorShapeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VolumeVectorShapeData {
    pub _glacier_base: VectorShapeData,
    pub height: f32,
}

pub trait VolumeVectorShapeDataTrait: VectorShapeDataTrait {
    fn height(&self) -> &f32;
}

impl VolumeVectorShapeDataTrait for VolumeVectorShapeData {
    fn height(&self) -> &f32 {
        &self.height
    }
}

impl VectorShapeDataTrait for VolumeVectorShapeData {
    fn points(&self) -> &Vec<super::core::Vec3> {
        self._glacier_base.points()
    }
    fn tension(&self) -> &f32 {
        self._glacier_base.tension()
    }
    fn is_closed(&self) -> &bool {
        self._glacier_base.is_closed()
    }
    fn allow_roll(&self) -> &bool {
        self._glacier_base.allow_roll()
    }
    fn allow_yaw_pitch(&self) -> &bool {
        self._glacier_base.allow_yaw_pitch()
    }
}

impl BaseShapeDataTrait for VolumeVectorShapeData {
}

impl BaseShapeDataBaseTrait for VolumeVectorShapeData {
}

impl GameObjectDataTrait for VolumeVectorShapeData {
}

impl super::core::DataBusPeerTrait for VolumeVectorShapeData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for VolumeVectorShapeData {
}

impl super::core::DataContainerTrait for VolumeVectorShapeData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static VOLUMEVECTORSHAPEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VolumeVectorShapeData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VECTORSHAPEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VolumeVectorShapeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Height",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VolumeVectorShapeData, height),
            },
        ],
    }),
    array_type: Some(VOLUMEVECTORSHAPEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VolumeVectorShapeData {
    fn type_info(&self) -> &'static TypeInfo {
        VOLUMEVECTORSHAPEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VOLUMEVECTORSHAPEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VolumeVectorShapeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("VolumeVectorShapeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CustomSplineData {
    pub _glacier_base: VectorShapeData,
}

pub trait CustomSplineDataTrait: VectorShapeDataTrait {
}

impl CustomSplineDataTrait for CustomSplineData {
}

impl VectorShapeDataTrait for CustomSplineData {
    fn points(&self) -> &Vec<super::core::Vec3> {
        self._glacier_base.points()
    }
    fn tension(&self) -> &f32 {
        self._glacier_base.tension()
    }
    fn is_closed(&self) -> &bool {
        self._glacier_base.is_closed()
    }
    fn allow_roll(&self) -> &bool {
        self._glacier_base.allow_roll()
    }
    fn allow_yaw_pitch(&self) -> &bool {
        self._glacier_base.allow_yaw_pitch()
    }
}

impl BaseShapeDataTrait for CustomSplineData {
}

impl BaseShapeDataBaseTrait for CustomSplineData {
}

impl GameObjectDataTrait for CustomSplineData {
}

impl super::core::DataBusPeerTrait for CustomSplineData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for CustomSplineData {
}

impl super::core::DataContainerTrait for CustomSplineData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CUSTOMSPLINEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomSplineData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VECTORSHAPEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CustomSplineData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(CUSTOMSPLINEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CustomSplineData {
    fn type_info(&self) -> &'static TypeInfo {
        CUSTOMSPLINEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CUSTOMSPLINEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomSplineData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CustomSplineData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VectorShapeData {
    pub _glacier_base: BaseShapeData,
    pub points: Vec<super::core::Vec3>,
    pub tension: f32,
    pub is_closed: bool,
    pub allow_roll: bool,
    pub allow_yaw_pitch: bool,
}

pub trait VectorShapeDataTrait: BaseShapeDataTrait {
    fn points(&self) -> &Vec<super::core::Vec3>;
    fn tension(&self) -> &f32;
    fn is_closed(&self) -> &bool;
    fn allow_roll(&self) -> &bool;
    fn allow_yaw_pitch(&self) -> &bool;
}

impl VectorShapeDataTrait for VectorShapeData {
    fn points(&self) -> &Vec<super::core::Vec3> {
        &self.points
    }
    fn tension(&self) -> &f32 {
        &self.tension
    }
    fn is_closed(&self) -> &bool {
        &self.is_closed
    }
    fn allow_roll(&self) -> &bool {
        &self.allow_roll
    }
    fn allow_yaw_pitch(&self) -> &bool {
        &self.allow_yaw_pitch
    }
}

impl BaseShapeDataTrait for VectorShapeData {
}

impl BaseShapeDataBaseTrait for VectorShapeData {
}

impl GameObjectDataTrait for VectorShapeData {
}

impl super::core::DataBusPeerTrait for VectorShapeData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for VectorShapeData {
}

impl super::core::DataContainerTrait for VectorShapeData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static VECTORSHAPEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VectorShapeData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(BASESHAPEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VectorShapeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Points",
                flags: MemberInfoFlags::new(144),
                field_type: "Vec3-Array",
                rust_offset: offset_of!(VectorShapeData, points),
            },
            FieldInfoData {
                name: "Tension",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VectorShapeData, tension),
            },
            FieldInfoData {
                name: "IsClosed",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VectorShapeData, is_closed),
            },
            FieldInfoData {
                name: "AllowRoll",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VectorShapeData, allow_roll),
            },
            FieldInfoData {
                name: "AllowYawPitch",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VectorShapeData, allow_yaw_pitch),
            },
        ],
    }),
    array_type: Some(VECTORSHAPEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VectorShapeData {
    fn type_info(&self) -> &'static TypeInfo {
        VECTORSHAPEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VECTORSHAPEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VectorShapeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("VectorShapeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct OBBData {
    pub _glacier_base: BaseShapeData,
    pub transform: super::core::LinearTransform,
    pub half_extents: super::core::Vec3,
}

pub trait OBBDataTrait: BaseShapeDataTrait {
    fn transform(&self) -> &super::core::LinearTransform;
    fn half_extents(&self) -> &super::core::Vec3;
}

impl OBBDataTrait for OBBData {
    fn transform(&self) -> &super::core::LinearTransform {
        &self.transform
    }
    fn half_extents(&self) -> &super::core::Vec3 {
        &self.half_extents
    }
}

impl BaseShapeDataTrait for OBBData {
}

impl BaseShapeDataBaseTrait for OBBData {
}

impl GameObjectDataTrait for OBBData {
}

impl super::core::DataBusPeerTrait for OBBData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for OBBData {
}

impl super::core::DataContainerTrait for OBBData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static OBBDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OBBData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(BASESHAPEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<OBBData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Transform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(OBBData, transform),
            },
            FieldInfoData {
                name: "HalfExtents",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(OBBData, half_extents),
            },
        ],
    }),
    array_type: Some(OBBDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for OBBData {
    fn type_info(&self) -> &'static TypeInfo {
        OBBDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static OBBDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OBBData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("OBBData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AABBData {
    pub _glacier_base: BaseShapeData,
    pub position: super::core::Vec3,
    pub half_extents: super::core::Vec3,
}

pub trait AABBDataTrait: BaseShapeDataTrait {
    fn position(&self) -> &super::core::Vec3;
    fn half_extents(&self) -> &super::core::Vec3;
}

impl AABBDataTrait for AABBData {
    fn position(&self) -> &super::core::Vec3 {
        &self.position
    }
    fn half_extents(&self) -> &super::core::Vec3 {
        &self.half_extents
    }
}

impl BaseShapeDataTrait for AABBData {
}

impl BaseShapeDataBaseTrait for AABBData {
}

impl GameObjectDataTrait for AABBData {
}

impl super::core::DataBusPeerTrait for AABBData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for AABBData {
}

impl super::core::DataContainerTrait for AABBData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static AABBDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AABBData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(BASESHAPEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AABBData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Position",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(AABBData, position),
            },
            FieldInfoData {
                name: "HalfExtents",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(AABBData, half_extents),
            },
        ],
    }),
    array_type: Some(AABBDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AABBData {
    fn type_info(&self) -> &'static TypeInfo {
        AABBDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static AABBDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AABBData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("AABBData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SphereData {
    pub _glacier_base: BaseShapeData,
    pub position: super::core::Vec3,
    pub radius: f32,
}

pub trait SphereDataTrait: BaseShapeDataTrait {
    fn position(&self) -> &super::core::Vec3;
    fn radius(&self) -> &f32;
}

impl SphereDataTrait for SphereData {
    fn position(&self) -> &super::core::Vec3 {
        &self.position
    }
    fn radius(&self) -> &f32 {
        &self.radius
    }
}

impl BaseShapeDataTrait for SphereData {
}

impl BaseShapeDataBaseTrait for SphereData {
}

impl GameObjectDataTrait for SphereData {
}

impl super::core::DataBusPeerTrait for SphereData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for SphereData {
}

impl super::core::DataContainerTrait for SphereData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SPHEREDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SphereData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(BASESHAPEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SphereData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Position",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SphereData, position),
            },
            FieldInfoData {
                name: "Radius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SphereData, radius),
            },
        ],
    }),
    array_type: Some(SPHEREDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SphereData {
    fn type_info(&self) -> &'static TypeInfo {
        SPHEREDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SPHEREDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SphereData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SphereData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BaseShapeData {
    pub _glacier_base: BaseShapeDataBase,
}

pub trait BaseShapeDataTrait: BaseShapeDataBaseTrait {
}

impl BaseShapeDataTrait for BaseShapeData {
}

impl BaseShapeDataBaseTrait for BaseShapeData {
}

impl GameObjectDataTrait for BaseShapeData {
}

impl super::core::DataBusPeerTrait for BaseShapeData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for BaseShapeData {
}

impl super::core::DataContainerTrait for BaseShapeData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static BASESHAPEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BaseShapeData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(BASESHAPEDATABASE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BaseShapeData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(BASESHAPEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BaseShapeData {
    fn type_info(&self) -> &'static TypeInfo {
        BASESHAPEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static BASESHAPEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BaseShapeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("BaseShapeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SelectVec4EntityData {
    pub _glacier_base: SelectPropertyEntityData,
}

pub trait SelectVec4EntityDataTrait: SelectPropertyEntityDataTrait {
}

impl SelectVec4EntityDataTrait for SelectVec4EntityData {
}

impl SelectPropertyEntityDataTrait for SelectVec4EntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn inputs(&self) -> &Vec<String> {
        self._glacier_base.inputs()
    }
    fn input_select(&self) -> &i32 {
        self._glacier_base.input_select()
    }
}

impl EntityDataTrait for SelectVec4EntityData {
}

impl GameObjectDataTrait for SelectVec4EntityData {
}

impl super::core::DataBusPeerTrait for SelectVec4EntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for SelectVec4EntityData {
}

impl super::core::DataContainerTrait for SelectVec4EntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SELECTVEC4ENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectVec4EntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SELECTPROPERTYENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SelectVec4EntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SELECTVEC4ENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SelectVec4EntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SELECTVEC4ENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SELECTVEC4ENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectVec4EntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SelectVec4EntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SelectVec3EntityData {
    pub _glacier_base: SelectPropertyEntityData,
}

pub trait SelectVec3EntityDataTrait: SelectPropertyEntityDataTrait {
}

impl SelectVec3EntityDataTrait for SelectVec3EntityData {
}

impl SelectPropertyEntityDataTrait for SelectVec3EntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn inputs(&self) -> &Vec<String> {
        self._glacier_base.inputs()
    }
    fn input_select(&self) -> &i32 {
        self._glacier_base.input_select()
    }
}

impl EntityDataTrait for SelectVec3EntityData {
}

impl GameObjectDataTrait for SelectVec3EntityData {
}

impl super::core::DataBusPeerTrait for SelectVec3EntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for SelectVec3EntityData {
}

impl super::core::DataContainerTrait for SelectVec3EntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SELECTVEC3ENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectVec3EntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SELECTPROPERTYENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SelectVec3EntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SELECTVEC3ENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SelectVec3EntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SELECTVEC3ENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SELECTVEC3ENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectVec3EntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SelectVec3EntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SelectVec2EntityData {
    pub _glacier_base: SelectPropertyEntityData,
}

pub trait SelectVec2EntityDataTrait: SelectPropertyEntityDataTrait {
}

impl SelectVec2EntityDataTrait for SelectVec2EntityData {
}

impl SelectPropertyEntityDataTrait for SelectVec2EntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn inputs(&self) -> &Vec<String> {
        self._glacier_base.inputs()
    }
    fn input_select(&self) -> &i32 {
        self._glacier_base.input_select()
    }
}

impl EntityDataTrait for SelectVec2EntityData {
}

impl GameObjectDataTrait for SelectVec2EntityData {
}

impl super::core::DataBusPeerTrait for SelectVec2EntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for SelectVec2EntityData {
}

impl super::core::DataContainerTrait for SelectVec2EntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SELECTVEC2ENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectVec2EntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SELECTPROPERTYENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SelectVec2EntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SELECTVEC2ENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SelectVec2EntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SELECTVEC2ENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SELECTVEC2ENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectVec2EntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SelectVec2EntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SelectTransformEntityData {
    pub _glacier_base: SelectPropertyEntityData,
}

pub trait SelectTransformEntityDataTrait: SelectPropertyEntityDataTrait {
}

impl SelectTransformEntityDataTrait for SelectTransformEntityData {
}

impl SelectPropertyEntityDataTrait for SelectTransformEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn inputs(&self) -> &Vec<String> {
        self._glacier_base.inputs()
    }
    fn input_select(&self) -> &i32 {
        self._glacier_base.input_select()
    }
}

impl EntityDataTrait for SelectTransformEntityData {
}

impl GameObjectDataTrait for SelectTransformEntityData {
}

impl super::core::DataBusPeerTrait for SelectTransformEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for SelectTransformEntityData {
}

impl super::core::DataContainerTrait for SelectTransformEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SELECTTRANSFORMENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectTransformEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SELECTPROPERTYENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SelectTransformEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SELECTTRANSFORMENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SelectTransformEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SELECTTRANSFORMENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SELECTTRANSFORMENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectTransformEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SelectTransformEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SelectBoolEntityData {
    pub _glacier_base: SelectPropertyEntityData,
}

pub trait SelectBoolEntityDataTrait: SelectPropertyEntityDataTrait {
}

impl SelectBoolEntityDataTrait for SelectBoolEntityData {
}

impl SelectPropertyEntityDataTrait for SelectBoolEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn inputs(&self) -> &Vec<String> {
        self._glacier_base.inputs()
    }
    fn input_select(&self) -> &i32 {
        self._glacier_base.input_select()
    }
}

impl EntityDataTrait for SelectBoolEntityData {
}

impl GameObjectDataTrait for SelectBoolEntityData {
}

impl super::core::DataBusPeerTrait for SelectBoolEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for SelectBoolEntityData {
}

impl super::core::DataContainerTrait for SelectBoolEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SELECTBOOLENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectBoolEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SELECTPROPERTYENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SelectBoolEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SELECTBOOLENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SelectBoolEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SELECTBOOLENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SELECTBOOLENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectBoolEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SelectBoolEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SelectStringEntityData {
    pub _glacier_base: SelectPropertyEntityData,
}

pub trait SelectStringEntityDataTrait: SelectPropertyEntityDataTrait {
}

impl SelectStringEntityDataTrait for SelectStringEntityData {
}

impl SelectPropertyEntityDataTrait for SelectStringEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn inputs(&self) -> &Vec<String> {
        self._glacier_base.inputs()
    }
    fn input_select(&self) -> &i32 {
        self._glacier_base.input_select()
    }
}

impl EntityDataTrait for SelectStringEntityData {
}

impl GameObjectDataTrait for SelectStringEntityData {
}

impl super::core::DataBusPeerTrait for SelectStringEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for SelectStringEntityData {
}

impl super::core::DataContainerTrait for SelectStringEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SELECTSTRINGENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectStringEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SELECTPROPERTYENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SelectStringEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SELECTSTRINGENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SelectStringEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SELECTSTRINGENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SELECTSTRINGENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectStringEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SelectStringEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SelectInt64EntityData {
    pub _glacier_base: SelectPropertyEntityData,
}

pub trait SelectInt64EntityDataTrait: SelectPropertyEntityDataTrait {
}

impl SelectInt64EntityDataTrait for SelectInt64EntityData {
}

impl SelectPropertyEntityDataTrait for SelectInt64EntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn inputs(&self) -> &Vec<String> {
        self._glacier_base.inputs()
    }
    fn input_select(&self) -> &i32 {
        self._glacier_base.input_select()
    }
}

impl EntityDataTrait for SelectInt64EntityData {
}

impl GameObjectDataTrait for SelectInt64EntityData {
}

impl super::core::DataBusPeerTrait for SelectInt64EntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for SelectInt64EntityData {
}

impl super::core::DataContainerTrait for SelectInt64EntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SELECTINT64ENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectInt64EntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SELECTPROPERTYENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SelectInt64EntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SELECTINT64ENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SelectInt64EntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SELECTINT64ENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SELECTINT64ENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectInt64EntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SelectInt64EntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SelectIntEntityData {
    pub _glacier_base: SelectPropertyEntityData,
}

pub trait SelectIntEntityDataTrait: SelectPropertyEntityDataTrait {
}

impl SelectIntEntityDataTrait for SelectIntEntityData {
}

impl SelectPropertyEntityDataTrait for SelectIntEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn inputs(&self) -> &Vec<String> {
        self._glacier_base.inputs()
    }
    fn input_select(&self) -> &i32 {
        self._glacier_base.input_select()
    }
}

impl EntityDataTrait for SelectIntEntityData {
}

impl GameObjectDataTrait for SelectIntEntityData {
}

impl super::core::DataBusPeerTrait for SelectIntEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for SelectIntEntityData {
}

impl super::core::DataContainerTrait for SelectIntEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SELECTINTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectIntEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SELECTPROPERTYENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SelectIntEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SELECTINTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SelectIntEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SELECTINTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SELECTINTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectIntEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SelectIntEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SelectFloatEntityData {
    pub _glacier_base: SelectPropertyEntityData,
}

pub trait SelectFloatEntityDataTrait: SelectPropertyEntityDataTrait {
}

impl SelectFloatEntityDataTrait for SelectFloatEntityData {
}

impl SelectPropertyEntityDataTrait for SelectFloatEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn inputs(&self) -> &Vec<String> {
        self._glacier_base.inputs()
    }
    fn input_select(&self) -> &i32 {
        self._glacier_base.input_select()
    }
}

impl EntityDataTrait for SelectFloatEntityData {
}

impl GameObjectDataTrait for SelectFloatEntityData {
}

impl super::core::DataBusPeerTrait for SelectFloatEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for SelectFloatEntityData {
}

impl super::core::DataContainerTrait for SelectFloatEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SELECTFLOATENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectFloatEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SELECTPROPERTYENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SelectFloatEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SELECTFLOATENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SelectFloatEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SELECTFLOATENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SELECTFLOATENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectFloatEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SelectFloatEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SelectPropertyEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub inputs: Vec<String>,
    pub input_select: i32,
}

pub trait SelectPropertyEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn inputs(&self) -> &Vec<String>;
    fn input_select(&self) -> &i32;
}

impl SelectPropertyEntityDataTrait for SelectPropertyEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn inputs(&self) -> &Vec<String> {
        &self.inputs
    }
    fn input_select(&self) -> &i32 {
        &self.input_select
    }
}

impl EntityDataTrait for SelectPropertyEntityData {
}

impl GameObjectDataTrait for SelectPropertyEntityData {
}

impl super::core::DataBusPeerTrait for SelectPropertyEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for SelectPropertyEntityData {
}

impl super::core::DataContainerTrait for SelectPropertyEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SELECTPROPERTYENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectPropertyEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SelectPropertyEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(SelectPropertyEntityData, realm),
            },
            FieldInfoData {
                name: "Inputs",
                flags: MemberInfoFlags::new(144),
                field_type: "CString-Array",
                rust_offset: offset_of!(SelectPropertyEntityData, inputs),
            },
            FieldInfoData {
                name: "InputSelect",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SelectPropertyEntityData, input_select),
            },
        ],
    }),
    array_type: Some(SELECTPROPERTYENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SelectPropertyEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SELECTPROPERTYENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SELECTPROPERTYENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectPropertyEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SelectPropertyEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PathfindingObjectCategoryAsset {
    pub _glacier_base: super::core::Asset,
}

pub trait PathfindingObjectCategoryAssetTrait: super::core::AssetTrait {
}

impl PathfindingObjectCategoryAssetTrait for PathfindingObjectCategoryAsset {
}

impl super::core::AssetTrait for PathfindingObjectCategoryAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
}

impl super::core::DataContainerTrait for PathfindingObjectCategoryAsset {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PATHFINDINGOBJECTCATEGORYASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PathfindingObjectCategoryAsset",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PathfindingObjectCategoryAsset as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(PATHFINDINGOBJECTCATEGORYASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PathfindingObjectCategoryAsset {
    fn type_info(&self) -> &'static TypeInfo {
        PATHFINDINGOBJECTCATEGORYASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PATHFINDINGOBJECTCATEGORYASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PathfindingObjectCategoryAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("PathfindingObjectCategoryAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ObjectAreaTriggerEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub time_out: f32,
}

pub trait ObjectAreaTriggerEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn time_out(&self) -> &f32;
}

impl ObjectAreaTriggerEntityDataTrait for ObjectAreaTriggerEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn time_out(&self) -> &f32 {
        &self.time_out
    }
}

impl EntityDataTrait for ObjectAreaTriggerEntityData {
}

impl GameObjectDataTrait for ObjectAreaTriggerEntityData {
}

impl super::core::DataBusPeerTrait for ObjectAreaTriggerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for ObjectAreaTriggerEntityData {
}

impl super::core::DataContainerTrait for ObjectAreaTriggerEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static OBJECTAREATRIGGERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectAreaTriggerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ObjectAreaTriggerEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(ObjectAreaTriggerEntityData, realm),
            },
            FieldInfoData {
                name: "TimeOut",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ObjectAreaTriggerEntityData, time_out),
            },
        ],
    }),
    array_type: Some(OBJECTAREATRIGGERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ObjectAreaTriggerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        OBJECTAREATRIGGERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static OBJECTAREATRIGGERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectAreaTriggerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ObjectAreaTriggerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ObjectVariationToIntEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
}

pub trait ObjectVariationToIntEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
}

impl ObjectVariationToIntEntityDataTrait for ObjectVariationToIntEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
}

impl EntityDataTrait for ObjectVariationToIntEntityData {
}

impl GameObjectDataTrait for ObjectVariationToIntEntityData {
}

impl super::core::DataBusPeerTrait for ObjectVariationToIntEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for ObjectVariationToIntEntityData {
}

impl super::core::DataContainerTrait for ObjectVariationToIntEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static OBJECTVARIATIONTOINTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectVariationToIntEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ObjectVariationToIntEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(ObjectVariationToIntEntityData, realm),
            },
        ],
    }),
    array_type: Some(OBJECTVARIATIONTOINTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ObjectVariationToIntEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        OBJECTVARIATIONTOINTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static OBJECTVARIATIONTOINTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectVariationToIntEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ObjectVariationToIntEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TransformSpaceEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
}

pub trait TransformSpaceEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
}

impl TransformSpaceEntityDataTrait for TransformSpaceEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
}

impl EntityDataTrait for TransformSpaceEntityData {
}

impl GameObjectDataTrait for TransformSpaceEntityData {
}

impl super::core::DataBusPeerTrait for TransformSpaceEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for TransformSpaceEntityData {
}

impl super::core::DataContainerTrait for TransformSpaceEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static TRANSFORMSPACEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformSpaceEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformSpaceEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(TransformSpaceEntityData, realm),
            },
        ],
    }),
    array_type: Some(TRANSFORMSPACEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TransformSpaceEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMSPACEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static TRANSFORMSPACEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformSpaceEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TransformSpaceEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BalancedDilationEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub dilation_value: f32,
    pub real_time_duration: f32,
    pub recovery_time: f32,
    pub dilation_shape: TimeShape,
    pub recovery_shape: TimeShape,
}

pub trait BalancedDilationEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn dilation_value(&self) -> &f32;
    fn real_time_duration(&self) -> &f32;
    fn recovery_time(&self) -> &f32;
    fn dilation_shape(&self) -> &TimeShape;
    fn recovery_shape(&self) -> &TimeShape;
}

impl BalancedDilationEntityDataTrait for BalancedDilationEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn dilation_value(&self) -> &f32 {
        &self.dilation_value
    }
    fn real_time_duration(&self) -> &f32 {
        &self.real_time_duration
    }
    fn recovery_time(&self) -> &f32 {
        &self.recovery_time
    }
    fn dilation_shape(&self) -> &TimeShape {
        &self.dilation_shape
    }
    fn recovery_shape(&self) -> &TimeShape {
        &self.recovery_shape
    }
}

impl EntityDataTrait for BalancedDilationEntityData {
}

impl GameObjectDataTrait for BalancedDilationEntityData {
}

impl super::core::DataBusPeerTrait for BalancedDilationEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for BalancedDilationEntityData {
}

impl super::core::DataContainerTrait for BalancedDilationEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static BALANCEDDILATIONENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BalancedDilationEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BalancedDilationEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(BalancedDilationEntityData, realm),
            },
            FieldInfoData {
                name: "DilationValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BalancedDilationEntityData, dilation_value),
            },
            FieldInfoData {
                name: "RealTimeDuration",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BalancedDilationEntityData, real_time_duration),
            },
            FieldInfoData {
                name: "RecoveryTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BalancedDilationEntityData, recovery_time),
            },
            FieldInfoData {
                name: "DilationShape",
                flags: MemberInfoFlags::new(0),
                field_type: "TimeShape",
                rust_offset: offset_of!(BalancedDilationEntityData, dilation_shape),
            },
            FieldInfoData {
                name: "RecoveryShape",
                flags: MemberInfoFlags::new(0),
                field_type: "TimeShape",
                rust_offset: offset_of!(BalancedDilationEntityData, recovery_shape),
            },
        ],
    }),
    array_type: Some(BALANCEDDILATIONENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BalancedDilationEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        BALANCEDDILATIONENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static BALANCEDDILATIONENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BalancedDilationEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("BalancedDilationEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DilationEntityData {
    pub _glacier_base: EntityData,
    pub fade_in_time: f32,
    pub fade_out_time: f32,
    pub real_time_duration: f32,
    pub priority: DilationPriority,
    pub dilation_value: f32,
    pub time_delta_type: TimeDeltaType,
}

pub trait DilationEntityDataTrait: EntityDataTrait {
    fn fade_in_time(&self) -> &f32;
    fn fade_out_time(&self) -> &f32;
    fn real_time_duration(&self) -> &f32;
    fn priority(&self) -> &DilationPriority;
    fn dilation_value(&self) -> &f32;
    fn time_delta_type(&self) -> &TimeDeltaType;
}

impl DilationEntityDataTrait for DilationEntityData {
    fn fade_in_time(&self) -> &f32 {
        &self.fade_in_time
    }
    fn fade_out_time(&self) -> &f32 {
        &self.fade_out_time
    }
    fn real_time_duration(&self) -> &f32 {
        &self.real_time_duration
    }
    fn priority(&self) -> &DilationPriority {
        &self.priority
    }
    fn dilation_value(&self) -> &f32 {
        &self.dilation_value
    }
    fn time_delta_type(&self) -> &TimeDeltaType {
        &self.time_delta_type
    }
}

impl EntityDataTrait for DilationEntityData {
}

impl GameObjectDataTrait for DilationEntityData {
}

impl super::core::DataBusPeerTrait for DilationEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for DilationEntityData {
}

impl super::core::DataContainerTrait for DilationEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static DILATIONENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DilationEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DilationEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "FadeInTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DilationEntityData, fade_in_time),
            },
            FieldInfoData {
                name: "FadeOutTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DilationEntityData, fade_out_time),
            },
            FieldInfoData {
                name: "RealTimeDuration",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DilationEntityData, real_time_duration),
            },
            FieldInfoData {
                name: "Priority",
                flags: MemberInfoFlags::new(0),
                field_type: "DilationPriority",
                rust_offset: offset_of!(DilationEntityData, priority),
            },
            FieldInfoData {
                name: "DilationValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DilationEntityData, dilation_value),
            },
            FieldInfoData {
                name: "TimeDeltaType",
                flags: MemberInfoFlags::new(0),
                field_type: "TimeDeltaType",
                rust_offset: offset_of!(DilationEntityData, time_delta_type),
            },
        ],
    }),
    array_type: Some(DILATIONENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DilationEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        DILATIONENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static DILATIONENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DilationEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("DilationEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FloatSelectEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub in_pos_or_zero: f32,
    pub in_neg: f32,
    pub select: f32,
}

pub trait FloatSelectEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn in_pos_or_zero(&self) -> &f32;
    fn in_neg(&self) -> &f32;
    fn select(&self) -> &f32;
}

impl FloatSelectEntityDataTrait for FloatSelectEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn in_pos_or_zero(&self) -> &f32 {
        &self.in_pos_or_zero
    }
    fn in_neg(&self) -> &f32 {
        &self.in_neg
    }
    fn select(&self) -> &f32 {
        &self.select
    }
}

impl EntityDataTrait for FloatSelectEntityData {
}

impl GameObjectDataTrait for FloatSelectEntityData {
}

impl super::core::DataBusPeerTrait for FloatSelectEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for FloatSelectEntityData {
}

impl super::core::DataContainerTrait for FloatSelectEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static FLOATSELECTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatSelectEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FloatSelectEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(FloatSelectEntityData, realm),
            },
            FieldInfoData {
                name: "InPosOrZero",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FloatSelectEntityData, in_pos_or_zero),
            },
            FieldInfoData {
                name: "InNeg",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FloatSelectEntityData, in_neg),
            },
            FieldInfoData {
                name: "Select",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FloatSelectEntityData, select),
            },
        ],
    }),
    array_type: Some(FLOATSELECTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FloatSelectEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        FLOATSELECTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static FLOATSELECTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatSelectEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("FloatSelectEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FloatCurveEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub r#in: f32,
    pub output_integral: bool,
    pub curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
}

pub trait FloatCurveEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn r#in(&self) -> &f32;
    fn output_integral(&self) -> &bool;
    fn curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
}

impl FloatCurveEntityDataTrait for FloatCurveEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn r#in(&self) -> &f32 {
        &self.r#in
    }
    fn output_integral(&self) -> &bool {
        &self.output_integral
    }
    fn curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.curve
    }
}

impl EntityDataTrait for FloatCurveEntityData {
}

impl GameObjectDataTrait for FloatCurveEntityData {
}

impl super::core::DataBusPeerTrait for FloatCurveEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for FloatCurveEntityData {
}

impl super::core::DataContainerTrait for FloatCurveEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static FLOATCURVEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatCurveEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FloatCurveEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(FloatCurveEntityData, realm),
            },
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FloatCurveEntityData, r#in),
            },
            FieldInfoData {
                name: "OutputIntegral",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FloatCurveEntityData, output_integral),
            },
            FieldInfoData {
                name: "Curve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(FloatCurveEntityData, curve),
            },
        ],
    }),
    array_type: Some(FLOATCURVEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FloatCurveEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        FLOATCURVEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static FLOATCURVEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatCurveEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("FloatCurveEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LocalPlayerGateEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
}

pub trait LocalPlayerGateEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
}

impl LocalPlayerGateEntityDataTrait for LocalPlayerGateEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
}

impl EntityDataTrait for LocalPlayerGateEntityData {
}

impl GameObjectDataTrait for LocalPlayerGateEntityData {
}

impl super::core::DataBusPeerTrait for LocalPlayerGateEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for LocalPlayerGateEntityData {
}

impl super::core::DataContainerTrait for LocalPlayerGateEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static LOCALPLAYERGATEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalPlayerGateEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LocalPlayerGateEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(LocalPlayerGateEntityData, realm),
            },
        ],
    }),
    array_type: Some(LOCALPLAYERGATEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LocalPlayerGateEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        LOCALPLAYERGATEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static LOCALPLAYERGATEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalPlayerGateEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("LocalPlayerGateEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TransformSelectorEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub in1: super::core::LinearTransform,
    pub in2: super::core::LinearTransform,
    pub selection: bool,
}

pub trait TransformSelectorEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn in1(&self) -> &super::core::LinearTransform;
    fn in2(&self) -> &super::core::LinearTransform;
    fn selection(&self) -> &bool;
}

impl TransformSelectorEntityDataTrait for TransformSelectorEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn in1(&self) -> &super::core::LinearTransform {
        &self.in1
    }
    fn in2(&self) -> &super::core::LinearTransform {
        &self.in2
    }
    fn selection(&self) -> &bool {
        &self.selection
    }
}

impl EntityDataTrait for TransformSelectorEntityData {
}

impl GameObjectDataTrait for TransformSelectorEntityData {
}

impl super::core::DataBusPeerTrait for TransformSelectorEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for TransformSelectorEntityData {
}

impl super::core::DataContainerTrait for TransformSelectorEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static TRANSFORMSELECTORENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformSelectorEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformSelectorEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(TransformSelectorEntityData, realm),
            },
            FieldInfoData {
                name: "In1",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(TransformSelectorEntityData, in1),
            },
            FieldInfoData {
                name: "In2",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(TransformSelectorEntityData, in2),
            },
            FieldInfoData {
                name: "Selection",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TransformSelectorEntityData, selection),
            },
        ],
    }),
    array_type: Some(TRANSFORMSELECTORENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for TransformSelectorEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMSELECTORENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static TRANSFORMSELECTORENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformSelectorEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TransformSelectorEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SettingEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub bool_setting_name: String,
    pub int_setting_name: String,
    pub float_setting_name: String,
    pub uint_setting_name: String,
}

pub trait SettingEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn bool_setting_name(&self) -> &String;
    fn int_setting_name(&self) -> &String;
    fn float_setting_name(&self) -> &String;
    fn uint_setting_name(&self) -> &String;
}

impl SettingEntityDataTrait for SettingEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn bool_setting_name(&self) -> &String {
        &self.bool_setting_name
    }
    fn int_setting_name(&self) -> &String {
        &self.int_setting_name
    }
    fn float_setting_name(&self) -> &String {
        &self.float_setting_name
    }
    fn uint_setting_name(&self) -> &String {
        &self.uint_setting_name
    }
}

impl EntityDataTrait for SettingEntityData {
}

impl GameObjectDataTrait for SettingEntityData {
}

impl super::core::DataBusPeerTrait for SettingEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for SettingEntityData {
}

impl super::core::DataContainerTrait for SettingEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SETTINGENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SettingEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SettingEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(SettingEntityData, realm),
            },
            FieldInfoData {
                name: "BoolSettingName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(SettingEntityData, bool_setting_name),
            },
            FieldInfoData {
                name: "IntSettingName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(SettingEntityData, int_setting_name),
            },
            FieldInfoData {
                name: "FloatSettingName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(SettingEntityData, float_setting_name),
            },
            FieldInfoData {
                name: "UintSettingName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(SettingEntityData, uint_setting_name),
            },
        ],
    }),
    array_type: Some(SETTINGENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SettingEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SETTINGENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SETTINGENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SettingEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SettingEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct IntegratorOrDifferentiatorEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub start_value: f32,
    pub input: f32,
    pub bounded: bool,
    pub max_value: f32,
    pub min_value: f32,
}

pub trait IntegratorOrDifferentiatorEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn start_value(&self) -> &f32;
    fn input(&self) -> &f32;
    fn bounded(&self) -> &bool;
    fn max_value(&self) -> &f32;
    fn min_value(&self) -> &f32;
}

impl IntegratorOrDifferentiatorEntityDataTrait for IntegratorOrDifferentiatorEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn start_value(&self) -> &f32 {
        &self.start_value
    }
    fn input(&self) -> &f32 {
        &self.input
    }
    fn bounded(&self) -> &bool {
        &self.bounded
    }
    fn max_value(&self) -> &f32 {
        &self.max_value
    }
    fn min_value(&self) -> &f32 {
        &self.min_value
    }
}

impl EntityDataTrait for IntegratorOrDifferentiatorEntityData {
}

impl GameObjectDataTrait for IntegratorOrDifferentiatorEntityData {
}

impl super::core::DataBusPeerTrait for IntegratorOrDifferentiatorEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for IntegratorOrDifferentiatorEntityData {
}

impl super::core::DataContainerTrait for IntegratorOrDifferentiatorEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static INTEGRATORORDIFFERENTIATORENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntegratorOrDifferentiatorEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<IntegratorOrDifferentiatorEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(IntegratorOrDifferentiatorEntityData, realm),
            },
            FieldInfoData {
                name: "StartValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(IntegratorOrDifferentiatorEntityData, start_value),
            },
            FieldInfoData {
                name: "Input",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(IntegratorOrDifferentiatorEntityData, input),
            },
            FieldInfoData {
                name: "Bounded",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(IntegratorOrDifferentiatorEntityData, bounded),
            },
            FieldInfoData {
                name: "MaxValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(IntegratorOrDifferentiatorEntityData, max_value),
            },
            FieldInfoData {
                name: "MinValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(IntegratorOrDifferentiatorEntityData, min_value),
            },
        ],
    }),
    array_type: Some(INTEGRATORORDIFFERENTIATORENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for IntegratorOrDifferentiatorEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        INTEGRATORORDIFFERENTIATORENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static INTEGRATORORDIFFERENTIATORENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntegratorOrDifferentiatorEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("IntegratorOrDifferentiatorEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ProfileEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub profile_name: String,
}

pub trait ProfileEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn profile_name(&self) -> &String;
}

impl ProfileEntityDataTrait for ProfileEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn profile_name(&self) -> &String {
        &self.profile_name
    }
}

impl EntityDataTrait for ProfileEntityData {
}

impl GameObjectDataTrait for ProfileEntityData {
}

impl super::core::DataBusPeerTrait for ProfileEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for ProfileEntityData {
}

impl super::core::DataContainerTrait for ProfileEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PROFILEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ProfileEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ProfileEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(ProfileEntityData, realm),
            },
            FieldInfoData {
                name: "ProfileName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ProfileEntityData, profile_name),
            },
        ],
    }),
    array_type: Some(PROFILEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ProfileEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PROFILEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PROFILEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ProfileEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ProfileEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CompareEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub operator: CompareOp,
    pub float_in0: f32,
    pub float_in1: f32,
    pub int_in0: i32,
    pub int_in1: i32,
}

pub trait CompareEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn operator(&self) -> &CompareOp;
    fn float_in0(&self) -> &f32;
    fn float_in1(&self) -> &f32;
    fn int_in0(&self) -> &i32;
    fn int_in1(&self) -> &i32;
}

impl CompareEntityDataTrait for CompareEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn operator(&self) -> &CompareOp {
        &self.operator
    }
    fn float_in0(&self) -> &f32 {
        &self.float_in0
    }
    fn float_in1(&self) -> &f32 {
        &self.float_in1
    }
    fn int_in0(&self) -> &i32 {
        &self.int_in0
    }
    fn int_in1(&self) -> &i32 {
        &self.int_in1
    }
}

impl EntityDataTrait for CompareEntityData {
}

impl GameObjectDataTrait for CompareEntityData {
}

impl super::core::DataBusPeerTrait for CompareEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for CompareEntityData {
}

impl super::core::DataContainerTrait for CompareEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static COMPAREENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(CompareEntityData, realm),
            },
            FieldInfoData {
                name: "Operator",
                flags: MemberInfoFlags::new(0),
                field_type: "CompareOp",
                rust_offset: offset_of!(CompareEntityData, operator),
            },
            FieldInfoData {
                name: "FloatIn0",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CompareEntityData, float_in0),
            },
            FieldInfoData {
                name: "FloatIn1",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CompareEntityData, float_in1),
            },
            FieldInfoData {
                name: "IntIn0",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CompareEntityData, int_in0),
            },
            FieldInfoData {
                name: "IntIn1",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CompareEntityData, int_in1),
            },
        ],
    }),
    array_type: Some(COMPAREENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CompareEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        COMPAREENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static COMPAREENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CompareOp {
    #[default]
    CompareOp_Equal = 0,
    CompareOp_NotEqual = 1,
    CompareOp_Greater = 2,
    CompareOp_Less = 3,
    CompareOp_GreaterOrEqual = 4,
    CompareOp_LessOrEqual = 5,
}

pub static COMPAREOP_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareOp",
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(COMPAREOP_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CompareOp {
    fn type_info(&self) -> &'static TypeInfo {
        COMPAREOP_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static COMPAREOP_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareOp-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareOp"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RunningAverageEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub number_of_values: u32,
    pub r#in: f32,
}

pub trait RunningAverageEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn number_of_values(&self) -> &u32;
    fn r#in(&self) -> &f32;
}

impl RunningAverageEntityDataTrait for RunningAverageEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn number_of_values(&self) -> &u32 {
        &self.number_of_values
    }
    fn r#in(&self) -> &f32 {
        &self.r#in
    }
}

impl EntityDataTrait for RunningAverageEntityData {
}

impl GameObjectDataTrait for RunningAverageEntityData {
}

impl super::core::DataBusPeerTrait for RunningAverageEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for RunningAverageEntityData {
}

impl super::core::DataContainerTrait for RunningAverageEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static RUNNINGAVERAGEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RunningAverageEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RunningAverageEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(RunningAverageEntityData, realm),
            },
            FieldInfoData {
                name: "NumberOfValues",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(RunningAverageEntityData, number_of_values),
            },
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RunningAverageEntityData, r#in),
            },
        ],
    }),
    array_type: Some(RUNNINGAVERAGEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RunningAverageEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        RUNNINGAVERAGEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static RUNNINGAVERAGEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RunningAverageEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("RunningAverageEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AbsEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub r#in: f32,
}

pub trait AbsEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn r#in(&self) -> &f32;
}

impl AbsEntityDataTrait for AbsEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn r#in(&self) -> &f32 {
        &self.r#in
    }
}

impl EntityDataTrait for AbsEntityData {
}

impl GameObjectDataTrait for AbsEntityData {
}

impl super::core::DataBusPeerTrait for AbsEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for AbsEntityData {
}

impl super::core::DataContainerTrait for AbsEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static ABSENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AbsEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AbsEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(AbsEntityData, realm),
            },
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AbsEntityData, r#in),
            },
        ],
    }),
    array_type: Some(ABSENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AbsEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        ABSENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ABSENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AbsEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("AbsEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VectorMathOpEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub math_operator: VectorMathOp,
}

pub trait VectorMathOpEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn math_operator(&self) -> &VectorMathOp;
}

impl VectorMathOpEntityDataTrait for VectorMathOpEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn math_operator(&self) -> &VectorMathOp {
        &self.math_operator
    }
}

impl EntityDataTrait for VectorMathOpEntityData {
}

impl GameObjectDataTrait for VectorMathOpEntityData {
}

impl super::core::DataBusPeerTrait for VectorMathOpEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for VectorMathOpEntityData {
}

impl super::core::DataContainerTrait for VectorMathOpEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static VECTORMATHOPENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VectorMathOpEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VectorMathOpEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(VectorMathOpEntityData, realm),
            },
            FieldInfoData {
                name: "MathOperator",
                flags: MemberInfoFlags::new(0),
                field_type: "VectorMathOp",
                rust_offset: offset_of!(VectorMathOpEntityData, math_operator),
            },
        ],
    }),
    array_type: Some(VECTORMATHOPENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VectorMathOpEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VECTORMATHOPENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VECTORMATHOPENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VectorMathOpEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("VectorMathOpEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum VectorMathOp {
    #[default]
    VectorMathOp_Add = 0,
    VectorMathOp_Subtract = 1,
    VectorMathOp_MultiplyByFloat = 2,
    VectorMathOp_DivideByFloat = 3,
    VectorMathOp_Cross = 4,
    VectorMathOp_Dot = 5,
    VectorMathOp_Length = 6,
}

pub static VECTORMATHOP_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VectorMathOp",
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(VECTORMATHOP_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for VectorMathOp {
    fn type_info(&self) -> &'static TypeInfo {
        VECTORMATHOP_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VECTORMATHOP_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VectorMathOp-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("VectorMathOp"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MathOpEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub operators: Vec<MathOp>,
}

pub trait MathOpEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn operators(&self) -> &Vec<MathOp>;
}

impl MathOpEntityDataTrait for MathOpEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn operators(&self) -> &Vec<MathOp> {
        &self.operators
    }
}

impl EntityDataTrait for MathOpEntityData {
}

impl GameObjectDataTrait for MathOpEntityData {
}

impl super::core::DataBusPeerTrait for MathOpEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for MathOpEntityData {
}

impl super::core::DataContainerTrait for MathOpEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static MATHOPENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MathOpEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MathOpEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(MathOpEntityData, realm),
            },
            FieldInfoData {
                name: "Operators",
                flags: MemberInfoFlags::new(144),
                field_type: "MathOp-Array",
                rust_offset: offset_of!(MathOpEntityData, operators),
            },
        ],
    }),
    array_type: Some(MATHOPENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MathOpEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        MATHOPENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static MATHOPENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MathOpEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("MathOpEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum MathOp {
    #[default]
    MathOp_Add = 0,
    MathOp_Subtract = 1,
    MathOp_Multiply = 2,
    MathOp_Divide = 3,
    MathOp_Min = 4,
    MathOp_Max = 5,
    MathOp_Modulo = 6,
    MathOp_Exponent = 7,
}

pub static MATHOP_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MathOp",
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(MATHOP_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for MathOp {
    fn type_info(&self) -> &'static TypeInfo {
        MATHOP_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static MATHOP_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MathOp-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("MathOp"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PropertyCastEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub precision: i32,
    pub bool_value: bool,
    pub float_value: f32,
    pub int_value: i32,
    pub uint_value: u32,
    pub string_value: String,
}

pub trait PropertyCastEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn precision(&self) -> &i32;
    fn bool_value(&self) -> &bool;
    fn float_value(&self) -> &f32;
    fn int_value(&self) -> &i32;
    fn uint_value(&self) -> &u32;
    fn string_value(&self) -> &String;
}

impl PropertyCastEntityDataTrait for PropertyCastEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn precision(&self) -> &i32 {
        &self.precision
    }
    fn bool_value(&self) -> &bool {
        &self.bool_value
    }
    fn float_value(&self) -> &f32 {
        &self.float_value
    }
    fn int_value(&self) -> &i32 {
        &self.int_value
    }
    fn uint_value(&self) -> &u32 {
        &self.uint_value
    }
    fn string_value(&self) -> &String {
        &self.string_value
    }
}

impl EntityDataTrait for PropertyCastEntityData {
}

impl GameObjectDataTrait for PropertyCastEntityData {
}

impl super::core::DataBusPeerTrait for PropertyCastEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for PropertyCastEntityData {
}

impl super::core::DataContainerTrait for PropertyCastEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PROPERTYCASTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PropertyCastEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PropertyCastEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(PropertyCastEntityData, realm),
            },
            FieldInfoData {
                name: "Precision",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(PropertyCastEntityData, precision),
            },
            FieldInfoData {
                name: "BoolValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PropertyCastEntityData, bool_value),
            },
            FieldInfoData {
                name: "FloatValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PropertyCastEntityData, float_value),
            },
            FieldInfoData {
                name: "IntValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(PropertyCastEntityData, int_value),
            },
            FieldInfoData {
                name: "UintValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(PropertyCastEntityData, uint_value),
            },
            FieldInfoData {
                name: "StringValue",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(PropertyCastEntityData, string_value),
            },
        ],
    }),
    array_type: Some(PROPERTYCASTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PropertyCastEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PROPERTYCASTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PROPERTYCASTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PropertyCastEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("PropertyCastEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BoolToEventEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub value: bool,
    pub inital_event: bool,
}

pub trait BoolToEventEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn value(&self) -> &bool;
    fn inital_event(&self) -> &bool;
}

impl BoolToEventEntityDataTrait for BoolToEventEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn value(&self) -> &bool {
        &self.value
    }
    fn inital_event(&self) -> &bool {
        &self.inital_event
    }
}

impl EntityDataTrait for BoolToEventEntityData {
}

impl GameObjectDataTrait for BoolToEventEntityData {
}

impl super::core::DataBusPeerTrait for BoolToEventEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for BoolToEventEntityData {
}

impl super::core::DataContainerTrait for BoolToEventEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static BOOLTOEVENTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolToEventEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BoolToEventEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(BoolToEventEntityData, realm),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BoolToEventEntityData, value),
            },
            FieldInfoData {
                name: "InitalEvent",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BoolToEventEntityData, inital_event),
            },
        ],
    }),
    array_type: Some(BOOLTOEVENTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BoolToEventEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        BOOLTOEVENTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static BOOLTOEVENTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolToEventEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("BoolToEventEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SwitchPropertyStringEntityData {
    pub _glacier_base: EntityData,
    pub string_properties: Vec<String>,
    pub realm: super::core::Realm,
}

pub trait SwitchPropertyStringEntityDataTrait: EntityDataTrait {
    fn string_properties(&self) -> &Vec<String>;
    fn realm(&self) -> &super::core::Realm;
}

impl SwitchPropertyStringEntityDataTrait for SwitchPropertyStringEntityData {
    fn string_properties(&self) -> &Vec<String> {
        &self.string_properties
    }
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
}

impl EntityDataTrait for SwitchPropertyStringEntityData {
}

impl GameObjectDataTrait for SwitchPropertyStringEntityData {
}

impl super::core::DataBusPeerTrait for SwitchPropertyStringEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for SwitchPropertyStringEntityData {
}

impl super::core::DataContainerTrait for SwitchPropertyStringEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SWITCHPROPERTYSTRINGENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SwitchPropertyStringEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SwitchPropertyStringEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "StringProperties",
                flags: MemberInfoFlags::new(144),
                field_type: "CString-Array",
                rust_offset: offset_of!(SwitchPropertyStringEntityData, string_properties),
            },
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(SwitchPropertyStringEntityData, realm),
            },
        ],
    }),
    array_type: Some(SWITCHPROPERTYSTRINGENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SwitchPropertyStringEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SWITCHPROPERTYSTRINGENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SWITCHPROPERTYSTRINGENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SwitchPropertyStringEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SwitchPropertyStringEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PropertyGateEntityData {
    pub _glacier_base: EntityData,
    pub default: bool,
    pub write_property_on_open_gate: bool,
    pub realm: super::core::Realm,
    pub bool_in: bool,
    pub int_in: i32,
    pub float_in: f32,
    pub vec3_in: super::core::Vec3,
    pub vec4_in: super::core::Vec4,
    pub transform_in: super::core::LinearTransform,
}

pub trait PropertyGateEntityDataTrait: EntityDataTrait {
    fn default(&self) -> &bool;
    fn write_property_on_open_gate(&self) -> &bool;
    fn realm(&self) -> &super::core::Realm;
    fn bool_in(&self) -> &bool;
    fn int_in(&self) -> &i32;
    fn float_in(&self) -> &f32;
    fn vec3_in(&self) -> &super::core::Vec3;
    fn vec4_in(&self) -> &super::core::Vec4;
    fn transform_in(&self) -> &super::core::LinearTransform;
}

impl PropertyGateEntityDataTrait for PropertyGateEntityData {
    fn default(&self) -> &bool {
        &self.default
    }
    fn write_property_on_open_gate(&self) -> &bool {
        &self.write_property_on_open_gate
    }
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn bool_in(&self) -> &bool {
        &self.bool_in
    }
    fn int_in(&self) -> &i32 {
        &self.int_in
    }
    fn float_in(&self) -> &f32 {
        &self.float_in
    }
    fn vec3_in(&self) -> &super::core::Vec3 {
        &self.vec3_in
    }
    fn vec4_in(&self) -> &super::core::Vec4 {
        &self.vec4_in
    }
    fn transform_in(&self) -> &super::core::LinearTransform {
        &self.transform_in
    }
}

impl EntityDataTrait for PropertyGateEntityData {
}

impl GameObjectDataTrait for PropertyGateEntityData {
}

impl super::core::DataBusPeerTrait for PropertyGateEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for PropertyGateEntityData {
}

impl super::core::DataContainerTrait for PropertyGateEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PROPERTYGATEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PropertyGateEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PropertyGateEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Default",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PropertyGateEntityData, default),
            },
            FieldInfoData {
                name: "WritePropertyOnOpenGate",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PropertyGateEntityData, write_property_on_open_gate),
            },
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(PropertyGateEntityData, realm),
            },
            FieldInfoData {
                name: "BoolIn",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PropertyGateEntityData, bool_in),
            },
            FieldInfoData {
                name: "IntIn",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(PropertyGateEntityData, int_in),
            },
            FieldInfoData {
                name: "FloatIn",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PropertyGateEntityData, float_in),
            },
            FieldInfoData {
                name: "Vec3In",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(PropertyGateEntityData, vec3_in),
            },
            FieldInfoData {
                name: "Vec4In",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(PropertyGateEntityData, vec4_in),
            },
            FieldInfoData {
                name: "TransformIn",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(PropertyGateEntityData, transform_in),
            },
        ],
    }),
    array_type: Some(PROPERTYGATEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PropertyGateEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PROPERTYGATEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PROPERTYGATEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PropertyGateEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("PropertyGateEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EventGateEntityData {
    pub _glacier_base: EntityData,
    pub default: bool,
    pub realm: super::core::Realm,
}

pub trait EventGateEntityDataTrait: EntityDataTrait {
    fn default(&self) -> &bool;
    fn realm(&self) -> &super::core::Realm;
}

impl EventGateEntityDataTrait for EventGateEntityData {
    fn default(&self) -> &bool {
        &self.default
    }
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
}

impl EntityDataTrait for EventGateEntityData {
}

impl GameObjectDataTrait for EventGateEntityData {
}

impl super::core::DataBusPeerTrait for EventGateEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for EventGateEntityData {
}

impl super::core::DataContainerTrait for EventGateEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static EVENTGATEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventGateEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EventGateEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Default",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EventGateEntityData, default),
            },
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(EventGateEntityData, realm),
            },
        ],
    }),
    array_type: Some(EVENTGATEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EventGateEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        EVENTGATEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static EVENTGATEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventGateEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EventGateEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct StopWatchEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub update_pass: UpdatePass,
    pub multiplier: f32,
    pub trigger_on_time: f32,
    pub use_real_delta_time: bool,
}

pub trait StopWatchEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn update_pass(&self) -> &UpdatePass;
    fn multiplier(&self) -> &f32;
    fn trigger_on_time(&self) -> &f32;
    fn use_real_delta_time(&self) -> &bool;
}

impl StopWatchEntityDataTrait for StopWatchEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn update_pass(&self) -> &UpdatePass {
        &self.update_pass
    }
    fn multiplier(&self) -> &f32 {
        &self.multiplier
    }
    fn trigger_on_time(&self) -> &f32 {
        &self.trigger_on_time
    }
    fn use_real_delta_time(&self) -> &bool {
        &self.use_real_delta_time
    }
}

impl EntityDataTrait for StopWatchEntityData {
}

impl GameObjectDataTrait for StopWatchEntityData {
}

impl super::core::DataBusPeerTrait for StopWatchEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for StopWatchEntityData {
}

impl super::core::DataContainerTrait for StopWatchEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static STOPWATCHENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StopWatchEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StopWatchEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(StopWatchEntityData, realm),
            },
            FieldInfoData {
                name: "UpdatePass",
                flags: MemberInfoFlags::new(0),
                field_type: "UpdatePass",
                rust_offset: offset_of!(StopWatchEntityData, update_pass),
            },
            FieldInfoData {
                name: "Multiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StopWatchEntityData, multiplier),
            },
            FieldInfoData {
                name: "TriggerOnTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StopWatchEntityData, trigger_on_time),
            },
            FieldInfoData {
                name: "UseRealDeltaTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(StopWatchEntityData, use_real_delta_time),
            },
        ],
    }),
    array_type: Some(STOPWATCHENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for StopWatchEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        STOPWATCHENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static STOPWATCHENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StopWatchEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("StopWatchEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TransformToRotationEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub r#in: super::core::LinearTransform,
    pub degrees: bool,
}

pub trait TransformToRotationEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn r#in(&self) -> &super::core::LinearTransform;
    fn degrees(&self) -> &bool;
}

impl TransformToRotationEntityDataTrait for TransformToRotationEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn r#in(&self) -> &super::core::LinearTransform {
        &self.r#in
    }
    fn degrees(&self) -> &bool {
        &self.degrees
    }
}

impl EntityDataTrait for TransformToRotationEntityData {
}

impl GameObjectDataTrait for TransformToRotationEntityData {
}

impl super::core::DataBusPeerTrait for TransformToRotationEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for TransformToRotationEntityData {
}

impl super::core::DataContainerTrait for TransformToRotationEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static TRANSFORMTOROTATIONENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformToRotationEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformToRotationEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(TransformToRotationEntityData, realm),
            },
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(TransformToRotationEntityData, r#in),
            },
            FieldInfoData {
                name: "Degrees",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TransformToRotationEntityData, degrees),
            },
        ],
    }),
    array_type: Some(TRANSFORMTOROTATIONENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for TransformToRotationEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMTOROTATIONENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static TRANSFORMTOROTATIONENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformToRotationEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TransformToRotationEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TransformModifierEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub r#in: super::core::LinearTransform,
    pub left: ModifierAxis,
    pub up: ModifierAxis,
    pub forward: ModifierAxis,
    pub invert_full_transform: bool,
    pub invert_left: bool,
    pub invert_up: bool,
    pub invert_forward: bool,
    pub invert_translation: bool,
}

pub trait TransformModifierEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn r#in(&self) -> &super::core::LinearTransform;
    fn left(&self) -> &ModifierAxis;
    fn up(&self) -> &ModifierAxis;
    fn forward(&self) -> &ModifierAxis;
    fn invert_full_transform(&self) -> &bool;
    fn invert_left(&self) -> &bool;
    fn invert_up(&self) -> &bool;
    fn invert_forward(&self) -> &bool;
    fn invert_translation(&self) -> &bool;
}

impl TransformModifierEntityDataTrait for TransformModifierEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn r#in(&self) -> &super::core::LinearTransform {
        &self.r#in
    }
    fn left(&self) -> &ModifierAxis {
        &self.left
    }
    fn up(&self) -> &ModifierAxis {
        &self.up
    }
    fn forward(&self) -> &ModifierAxis {
        &self.forward
    }
    fn invert_full_transform(&self) -> &bool {
        &self.invert_full_transform
    }
    fn invert_left(&self) -> &bool {
        &self.invert_left
    }
    fn invert_up(&self) -> &bool {
        &self.invert_up
    }
    fn invert_forward(&self) -> &bool {
        &self.invert_forward
    }
    fn invert_translation(&self) -> &bool {
        &self.invert_translation
    }
}

impl EntityDataTrait for TransformModifierEntityData {
}

impl GameObjectDataTrait for TransformModifierEntityData {
}

impl super::core::DataBusPeerTrait for TransformModifierEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for TransformModifierEntityData {
}

impl super::core::DataContainerTrait for TransformModifierEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static TRANSFORMMODIFIERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformModifierEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformModifierEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(TransformModifierEntityData, realm),
            },
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(TransformModifierEntityData, r#in),
            },
            FieldInfoData {
                name: "Left",
                flags: MemberInfoFlags::new(0),
                field_type: "ModifierAxis",
                rust_offset: offset_of!(TransformModifierEntityData, left),
            },
            FieldInfoData {
                name: "Up",
                flags: MemberInfoFlags::new(0),
                field_type: "ModifierAxis",
                rust_offset: offset_of!(TransformModifierEntityData, up),
            },
            FieldInfoData {
                name: "Forward",
                flags: MemberInfoFlags::new(0),
                field_type: "ModifierAxis",
                rust_offset: offset_of!(TransformModifierEntityData, forward),
            },
            FieldInfoData {
                name: "InvertFullTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TransformModifierEntityData, invert_full_transform),
            },
            FieldInfoData {
                name: "InvertLeft",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TransformModifierEntityData, invert_left),
            },
            FieldInfoData {
                name: "InvertUp",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TransformModifierEntityData, invert_up),
            },
            FieldInfoData {
                name: "InvertForward",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TransformModifierEntityData, invert_forward),
            },
            FieldInfoData {
                name: "InvertTranslation",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TransformModifierEntityData, invert_translation),
            },
        ],
    }),
    array_type: Some(TRANSFORMMODIFIERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for TransformModifierEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMMODIFIERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static TRANSFORMMODIFIERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformModifierEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TransformModifierEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum ModifierAxis {
    #[default]
    maLeft = 0,
    maUp = 1,
    maForward = 2,
}

pub static MODIFIERAXIS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ModifierAxis",
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(MODIFIERAXIS_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for ModifierAxis {
    fn type_info(&self) -> &'static TypeInfo {
        MODIFIERAXIS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static MODIFIERAXIS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ModifierAxis-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ModifierAxis"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RotationTransformBuilderEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub rotation: super::core::Vec3,
}

pub trait RotationTransformBuilderEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn rotation(&self) -> &super::core::Vec3;
}

impl RotationTransformBuilderEntityDataTrait for RotationTransformBuilderEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn rotation(&self) -> &super::core::Vec3 {
        &self.rotation
    }
}

impl EntityDataTrait for RotationTransformBuilderEntityData {
}

impl GameObjectDataTrait for RotationTransformBuilderEntityData {
}

impl super::core::DataBusPeerTrait for RotationTransformBuilderEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for RotationTransformBuilderEntityData {
}

impl super::core::DataContainerTrait for RotationTransformBuilderEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static ROTATIONTRANSFORMBUILDERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RotationTransformBuilderEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RotationTransformBuilderEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(RotationTransformBuilderEntityData, realm),
            },
            FieldInfoData {
                name: "Rotation",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(RotationTransformBuilderEntityData, rotation),
            },
        ],
    }),
    array_type: Some(ROTATIONTRANSFORMBUILDERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for RotationTransformBuilderEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        ROTATIONTRANSFORMBUILDERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ROTATIONTRANSFORMBUILDERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RotationTransformBuilderEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("RotationTransformBuilderEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ScaleTransformBuilderEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub scale: super::core::Vec3,
}

pub trait ScaleTransformBuilderEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn scale(&self) -> &super::core::Vec3;
}

impl ScaleTransformBuilderEntityDataTrait for ScaleTransformBuilderEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn scale(&self) -> &super::core::Vec3 {
        &self.scale
    }
}

impl EntityDataTrait for ScaleTransformBuilderEntityData {
}

impl GameObjectDataTrait for ScaleTransformBuilderEntityData {
}

impl super::core::DataBusPeerTrait for ScaleTransformBuilderEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for ScaleTransformBuilderEntityData {
}

impl super::core::DataContainerTrait for ScaleTransformBuilderEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SCALETRANSFORMBUILDERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScaleTransformBuilderEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ScaleTransformBuilderEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(ScaleTransformBuilderEntityData, realm),
            },
            FieldInfoData {
                name: "Scale",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(ScaleTransformBuilderEntityData, scale),
            },
        ],
    }),
    array_type: Some(SCALETRANSFORMBUILDERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ScaleTransformBuilderEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SCALETRANSFORMBUILDERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SCALETRANSFORMBUILDERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScaleTransformBuilderEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ScaleTransformBuilderEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TransformBuilderEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub ortho_normal_mode: OrthoNormalMode,
    pub left: super::core::Vec3,
    pub up: super::core::Vec3,
    pub forward: super::core::Vec3,
    pub trans: super::core::Vec3,
    pub is_world_space: bool,
}

pub trait TransformBuilderEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn ortho_normal_mode(&self) -> &OrthoNormalMode;
    fn left(&self) -> &super::core::Vec3;
    fn up(&self) -> &super::core::Vec3;
    fn forward(&self) -> &super::core::Vec3;
    fn trans(&self) -> &super::core::Vec3;
    fn is_world_space(&self) -> &bool;
}

impl TransformBuilderEntityDataTrait for TransformBuilderEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn ortho_normal_mode(&self) -> &OrthoNormalMode {
        &self.ortho_normal_mode
    }
    fn left(&self) -> &super::core::Vec3 {
        &self.left
    }
    fn up(&self) -> &super::core::Vec3 {
        &self.up
    }
    fn forward(&self) -> &super::core::Vec3 {
        &self.forward
    }
    fn trans(&self) -> &super::core::Vec3 {
        &self.trans
    }
    fn is_world_space(&self) -> &bool {
        &self.is_world_space
    }
}

impl EntityDataTrait for TransformBuilderEntityData {
}

impl GameObjectDataTrait for TransformBuilderEntityData {
}

impl super::core::DataBusPeerTrait for TransformBuilderEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for TransformBuilderEntityData {
}

impl super::core::DataContainerTrait for TransformBuilderEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static TRANSFORMBUILDERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformBuilderEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformBuilderEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(TransformBuilderEntityData, realm),
            },
            FieldInfoData {
                name: "OrthoNormalMode",
                flags: MemberInfoFlags::new(0),
                field_type: "OrthoNormalMode",
                rust_offset: offset_of!(TransformBuilderEntityData, ortho_normal_mode),
            },
            FieldInfoData {
                name: "Left",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(TransformBuilderEntityData, left),
            },
            FieldInfoData {
                name: "Up",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(TransformBuilderEntityData, up),
            },
            FieldInfoData {
                name: "Forward",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(TransformBuilderEntityData, forward),
            },
            FieldInfoData {
                name: "Trans",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(TransformBuilderEntityData, trans),
            },
            FieldInfoData {
                name: "IsWorldSpace",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TransformBuilderEntityData, is_world_space),
            },
        ],
    }),
    array_type: Some(TRANSFORMBUILDERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for TransformBuilderEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMBUILDERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static TRANSFORMBUILDERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformBuilderEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TransformBuilderEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum OrthoNormalMode {
    #[default]
    OrthoNormalMode_LeftHanded = 0,
    OrthoNormalMode_RightHanded = 1,
    OrthoNormalMode_None = 2,
}

pub static ORTHONORMALMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OrthoNormalMode",
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(ORTHONORMALMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for OrthoNormalMode {
    fn type_info(&self) -> &'static TypeInfo {
        ORTHONORMALMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ORTHONORMALMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OrthoNormalMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("OrthoNormalMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VecBuilderEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}

pub trait VecBuilderEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn x(&self) -> &f32;
    fn y(&self) -> &f32;
    fn z(&self) -> &f32;
    fn w(&self) -> &f32;
}

impl VecBuilderEntityDataTrait for VecBuilderEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn x(&self) -> &f32 {
        &self.x
    }
    fn y(&self) -> &f32 {
        &self.y
    }
    fn z(&self) -> &f32 {
        &self.z
    }
    fn w(&self) -> &f32 {
        &self.w
    }
}

impl EntityDataTrait for VecBuilderEntityData {
}

impl GameObjectDataTrait for VecBuilderEntityData {
}

impl super::core::DataBusPeerTrait for VecBuilderEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for VecBuilderEntityData {
}

impl super::core::DataContainerTrait for VecBuilderEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static VECBUILDERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VecBuilderEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VecBuilderEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(VecBuilderEntityData, realm),
            },
            FieldInfoData {
                name: "X",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VecBuilderEntityData, x),
            },
            FieldInfoData {
                name: "Y",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VecBuilderEntityData, y),
            },
            FieldInfoData {
                name: "Z",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VecBuilderEntityData, z),
            },
            FieldInfoData {
                name: "W",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VecBuilderEntityData, w),
            },
        ],
    }),
    array_type: Some(VECBUILDERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VecBuilderEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VECBUILDERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VECBUILDERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VecBuilderEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("VecBuilderEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Vec4BuilderEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
}

pub trait Vec4BuilderEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
}

impl Vec4BuilderEntityDataTrait for Vec4BuilderEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
}

impl EntityDataTrait for Vec4BuilderEntityData {
}

impl GameObjectDataTrait for Vec4BuilderEntityData {
}

impl super::core::DataBusPeerTrait for Vec4BuilderEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for Vec4BuilderEntityData {
}

impl super::core::DataContainerTrait for Vec4BuilderEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static VEC4BUILDERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec4BuilderEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec4BuilderEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(Vec4BuilderEntityData, realm),
            },
        ],
    }),
    array_type: Some(VEC4BUILDERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for Vec4BuilderEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VEC4BUILDERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VEC4BUILDERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec4BuilderEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec4BuilderEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Vec3BuilderEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
}

pub trait Vec3BuilderEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
}

impl Vec3BuilderEntityDataTrait for Vec3BuilderEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
}

impl EntityDataTrait for Vec3BuilderEntityData {
}

impl GameObjectDataTrait for Vec3BuilderEntityData {
}

impl super::core::DataBusPeerTrait for Vec3BuilderEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for Vec3BuilderEntityData {
}

impl super::core::DataContainerTrait for Vec3BuilderEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static VEC3BUILDERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3BuilderEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec3BuilderEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(Vec3BuilderEntityData, realm),
            },
        ],
    }),
    array_type: Some(VEC3BUILDERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for Vec3BuilderEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VEC3BUILDERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VEC3BUILDERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3BuilderEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec3BuilderEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Vec2BuilderEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
}

pub trait Vec2BuilderEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
}

impl Vec2BuilderEntityDataTrait for Vec2BuilderEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
}

impl EntityDataTrait for Vec2BuilderEntityData {
}

impl GameObjectDataTrait for Vec2BuilderEntityData {
}

impl super::core::DataBusPeerTrait for Vec2BuilderEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for Vec2BuilderEntityData {
}

impl super::core::DataContainerTrait for Vec2BuilderEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static VEC2BUILDERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec2BuilderEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec2BuilderEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(Vec2BuilderEntityData, realm),
            },
        ],
    }),
    array_type: Some(VEC2BUILDERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for Vec2BuilderEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VEC2BUILDERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VEC2BUILDERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec2BuilderEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec2BuilderEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VecSplitterEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub vec2: super::core::Vec2,
    pub vec3: super::core::Vec3,
    pub vec4: super::core::Vec4,
}

pub trait VecSplitterEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn vec2(&self) -> &super::core::Vec2;
    fn vec3(&self) -> &super::core::Vec3;
    fn vec4(&self) -> &super::core::Vec4;
}

impl VecSplitterEntityDataTrait for VecSplitterEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn vec2(&self) -> &super::core::Vec2 {
        &self.vec2
    }
    fn vec3(&self) -> &super::core::Vec3 {
        &self.vec3
    }
    fn vec4(&self) -> &super::core::Vec4 {
        &self.vec4
    }
}

impl EntityDataTrait for VecSplitterEntityData {
}

impl GameObjectDataTrait for VecSplitterEntityData {
}

impl super::core::DataBusPeerTrait for VecSplitterEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for VecSplitterEntityData {
}

impl super::core::DataContainerTrait for VecSplitterEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static VECSPLITTERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VecSplitterEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VecSplitterEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(VecSplitterEntityData, realm),
            },
            FieldInfoData {
                name: "Vec2",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(VecSplitterEntityData, vec2),
            },
            FieldInfoData {
                name: "Vec3",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(VecSplitterEntityData, vec3),
            },
            FieldInfoData {
                name: "Vec4",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(VecSplitterEntityData, vec4),
            },
        ],
    }),
    array_type: Some(VECSPLITTERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VecSplitterEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VECSPLITTERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VECSPLITTERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VecSplitterEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("VecSplitterEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Vec4SplitterEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
}

pub trait Vec4SplitterEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
}

impl Vec4SplitterEntityDataTrait for Vec4SplitterEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
}

impl EntityDataTrait for Vec4SplitterEntityData {
}

impl GameObjectDataTrait for Vec4SplitterEntityData {
}

impl super::core::DataBusPeerTrait for Vec4SplitterEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for Vec4SplitterEntityData {
}

impl super::core::DataContainerTrait for Vec4SplitterEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static VEC4SPLITTERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec4SplitterEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec4SplitterEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(Vec4SplitterEntityData, realm),
            },
        ],
    }),
    array_type: Some(VEC4SPLITTERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for Vec4SplitterEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VEC4SPLITTERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VEC4SPLITTERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec4SplitterEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec4SplitterEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Vec3SplitterEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
}

pub trait Vec3SplitterEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
}

impl Vec3SplitterEntityDataTrait for Vec3SplitterEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
}

impl EntityDataTrait for Vec3SplitterEntityData {
}

impl GameObjectDataTrait for Vec3SplitterEntityData {
}

impl super::core::DataBusPeerTrait for Vec3SplitterEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for Vec3SplitterEntityData {
}

impl super::core::DataContainerTrait for Vec3SplitterEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static VEC3SPLITTERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3SplitterEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec3SplitterEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(Vec3SplitterEntityData, realm),
            },
        ],
    }),
    array_type: Some(VEC3SPLITTERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for Vec3SplitterEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VEC3SPLITTERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VEC3SPLITTERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3SplitterEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec3SplitterEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Vec2SplitterEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
}

pub trait Vec2SplitterEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
}

impl Vec2SplitterEntityDataTrait for Vec2SplitterEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
}

impl EntityDataTrait for Vec2SplitterEntityData {
}

impl GameObjectDataTrait for Vec2SplitterEntityData {
}

impl super::core::DataBusPeerTrait for Vec2SplitterEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for Vec2SplitterEntityData {
}

impl super::core::DataContainerTrait for Vec2SplitterEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static VEC2SPLITTERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec2SplitterEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec2SplitterEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(Vec2SplitterEntityData, realm),
            },
        ],
    }),
    array_type: Some(VEC2SPLITTERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for Vec2SplitterEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VEC2SPLITTERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VEC2SPLITTERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec2SplitterEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec2SplitterEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EulerTransformEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub rotation: f32,
    pub trans: super::core::Vec3,
    pub euler: ModifierEuler,
}

pub trait EulerTransformEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn rotation(&self) -> &f32;
    fn trans(&self) -> &super::core::Vec3;
    fn euler(&self) -> &ModifierEuler;
}

impl EulerTransformEntityDataTrait for EulerTransformEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn rotation(&self) -> &f32 {
        &self.rotation
    }
    fn trans(&self) -> &super::core::Vec3 {
        &self.trans
    }
    fn euler(&self) -> &ModifierEuler {
        &self.euler
    }
}

impl EntityDataTrait for EulerTransformEntityData {
}

impl GameObjectDataTrait for EulerTransformEntityData {
}

impl super::core::DataBusPeerTrait for EulerTransformEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for EulerTransformEntityData {
}

impl super::core::DataContainerTrait for EulerTransformEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static EULERTRANSFORMENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EulerTransformEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EulerTransformEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(EulerTransformEntityData, realm),
            },
            FieldInfoData {
                name: "Rotation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EulerTransformEntityData, rotation),
            },
            FieldInfoData {
                name: "Trans",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(EulerTransformEntityData, trans),
            },
            FieldInfoData {
                name: "Euler",
                flags: MemberInfoFlags::new(0),
                field_type: "ModifierEuler",
                rust_offset: offset_of!(EulerTransformEntityData, euler),
            },
        ],
    }),
    array_type: Some(EULERTRANSFORMENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for EulerTransformEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        EULERTRANSFORMENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static EULERTRANSFORMENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EulerTransformEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EulerTransformEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum ModifierEuler {
    #[default]
    Roll = 0,
    Pitch = 1,
    Yaw = 2,
    Trans = 3,
}

pub static MODIFIEREULER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ModifierEuler",
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(MODIFIEREULER_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for ModifierEuler {
    fn type_info(&self) -> &'static TypeInfo {
        MODIFIEREULER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static MODIFIEREULER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ModifierEuler-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ModifierEuler"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EulerTransformSplitterEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub transform: super::core::LinearTransform,
}

pub trait EulerTransformSplitterEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn transform(&self) -> &super::core::LinearTransform;
}

impl EulerTransformSplitterEntityDataTrait for EulerTransformSplitterEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn transform(&self) -> &super::core::LinearTransform {
        &self.transform
    }
}

impl EntityDataTrait for EulerTransformSplitterEntityData {
}

impl GameObjectDataTrait for EulerTransformSplitterEntityData {
}

impl super::core::DataBusPeerTrait for EulerTransformSplitterEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for EulerTransformSplitterEntityData {
}

impl super::core::DataContainerTrait for EulerTransformSplitterEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static EULERTRANSFORMSPLITTERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EulerTransformSplitterEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EulerTransformSplitterEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(EulerTransformSplitterEntityData, realm),
            },
            FieldInfoData {
                name: "Transform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(EulerTransformSplitterEntityData, transform),
            },
        ],
    }),
    array_type: Some(EULERTRANSFORMSPLITTERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for EulerTransformSplitterEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        EULERTRANSFORMSPLITTERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static EULERTRANSFORMSPLITTERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EulerTransformSplitterEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EulerTransformSplitterEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TransformSplitterEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub transform: super::core::LinearTransform,
}

pub trait TransformSplitterEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn transform(&self) -> &super::core::LinearTransform;
}

impl TransformSplitterEntityDataTrait for TransformSplitterEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn transform(&self) -> &super::core::LinearTransform {
        &self.transform
    }
}

impl EntityDataTrait for TransformSplitterEntityData {
}

impl GameObjectDataTrait for TransformSplitterEntityData {
}

impl super::core::DataBusPeerTrait for TransformSplitterEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for TransformSplitterEntityData {
}

impl super::core::DataContainerTrait for TransformSplitterEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static TRANSFORMSPLITTERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformSplitterEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformSplitterEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(TransformSplitterEntityData, realm),
            },
            FieldInfoData {
                name: "Transform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(TransformSplitterEntityData, transform),
            },
        ],
    }),
    array_type: Some(TRANSFORMSPLITTERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for TransformSplitterEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMSPLITTERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static TRANSFORMSPLITTERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformSplitterEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TransformSplitterEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TransformBlendEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub blend_value: f32,
    pub blend_value2: f32,
    pub in1: super::core::LinearTransform,
    pub in2: super::core::LinearTransform,
}

pub trait TransformBlendEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn blend_value(&self) -> &f32;
    fn blend_value2(&self) -> &f32;
    fn in1(&self) -> &super::core::LinearTransform;
    fn in2(&self) -> &super::core::LinearTransform;
}

impl TransformBlendEntityDataTrait for TransformBlendEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn blend_value(&self) -> &f32 {
        &self.blend_value
    }
    fn blend_value2(&self) -> &f32 {
        &self.blend_value2
    }
    fn in1(&self) -> &super::core::LinearTransform {
        &self.in1
    }
    fn in2(&self) -> &super::core::LinearTransform {
        &self.in2
    }
}

impl EntityDataTrait for TransformBlendEntityData {
}

impl GameObjectDataTrait for TransformBlendEntityData {
}

impl super::core::DataBusPeerTrait for TransformBlendEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for TransformBlendEntityData {
}

impl super::core::DataContainerTrait for TransformBlendEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static TRANSFORMBLENDENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformBlendEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformBlendEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(TransformBlendEntityData, realm),
            },
            FieldInfoData {
                name: "BlendValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TransformBlendEntityData, blend_value),
            },
            FieldInfoData {
                name: "BlendValue2",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TransformBlendEntityData, blend_value2),
            },
            FieldInfoData {
                name: "In1",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(TransformBlendEntityData, in1),
            },
            FieldInfoData {
                name: "In2",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(TransformBlendEntityData, in2),
            },
        ],
    }),
    array_type: Some(TRANSFORMBLENDENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for TransformBlendEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMBLENDENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static TRANSFORMBLENDENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformBlendEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TransformBlendEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TransformMultiplierEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub in1: super::core::LinearTransform,
    pub in2: super::core::LinearTransform,
}

pub trait TransformMultiplierEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn in1(&self) -> &super::core::LinearTransform;
    fn in2(&self) -> &super::core::LinearTransform;
}

impl TransformMultiplierEntityDataTrait for TransformMultiplierEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn in1(&self) -> &super::core::LinearTransform {
        &self.in1
    }
    fn in2(&self) -> &super::core::LinearTransform {
        &self.in2
    }
}

impl EntityDataTrait for TransformMultiplierEntityData {
}

impl GameObjectDataTrait for TransformMultiplierEntityData {
}

impl super::core::DataBusPeerTrait for TransformMultiplierEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for TransformMultiplierEntityData {
}

impl super::core::DataContainerTrait for TransformMultiplierEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static TRANSFORMMULTIPLIERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformMultiplierEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformMultiplierEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(TransformMultiplierEntityData, realm),
            },
            FieldInfoData {
                name: "In1",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(TransformMultiplierEntityData, in1),
            },
            FieldInfoData {
                name: "In2",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(TransformMultiplierEntityData, in2),
            },
        ],
    }),
    array_type: Some(TRANSFORMMULTIPLIERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for TransformMultiplierEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMMULTIPLIERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static TRANSFORMMULTIPLIERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformMultiplierEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TransformMultiplierEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TransformHubEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub input_count: i32,
    pub input_select: i32,
    pub hashed_input: Vec<u32>,
}

pub trait TransformHubEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn input_count(&self) -> &i32;
    fn input_select(&self) -> &i32;
    fn hashed_input(&self) -> &Vec<u32>;
}

impl TransformHubEntityDataTrait for TransformHubEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn input_count(&self) -> &i32 {
        &self.input_count
    }
    fn input_select(&self) -> &i32 {
        &self.input_select
    }
    fn hashed_input(&self) -> &Vec<u32> {
        &self.hashed_input
    }
}

impl EntityDataTrait for TransformHubEntityData {
}

impl GameObjectDataTrait for TransformHubEntityData {
}

impl super::core::DataBusPeerTrait for TransformHubEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for TransformHubEntityData {
}

impl super::core::DataContainerTrait for TransformHubEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static TRANSFORMHUBENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformHubEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformHubEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(TransformHubEntityData, realm),
            },
            FieldInfoData {
                name: "InputCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(TransformHubEntityData, input_count),
            },
            FieldInfoData {
                name: "InputSelect",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(TransformHubEntityData, input_select),
            },
            FieldInfoData {
                name: "HashedInput",
                flags: MemberInfoFlags::new(144),
                field_type: "Uint32-Array",
                rust_offset: offset_of!(TransformHubEntityData, hashed_input),
            },
        ],
    }),
    array_type: Some(TRANSFORMHUBENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TransformHubEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMHUBENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static TRANSFORMHUBENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformHubEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TransformHubEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct StringHubEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub input_count: i32,
    pub input_select: i32,
    pub hashed_input: Vec<u32>,
}

pub trait StringHubEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn input_count(&self) -> &i32;
    fn input_select(&self) -> &i32;
    fn hashed_input(&self) -> &Vec<u32>;
}

impl StringHubEntityDataTrait for StringHubEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn input_count(&self) -> &i32 {
        &self.input_count
    }
    fn input_select(&self) -> &i32 {
        &self.input_select
    }
    fn hashed_input(&self) -> &Vec<u32> {
        &self.hashed_input
    }
}

impl EntityDataTrait for StringHubEntityData {
}

impl GameObjectDataTrait for StringHubEntityData {
}

impl super::core::DataBusPeerTrait for StringHubEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for StringHubEntityData {
}

impl super::core::DataContainerTrait for StringHubEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static STRINGHUBENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StringHubEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StringHubEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(StringHubEntityData, realm),
            },
            FieldInfoData {
                name: "InputCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(StringHubEntityData, input_count),
            },
            FieldInfoData {
                name: "InputSelect",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(StringHubEntityData, input_select),
            },
            FieldInfoData {
                name: "HashedInput",
                flags: MemberInfoFlags::new(144),
                field_type: "Uint32-Array",
                rust_offset: offset_of!(StringHubEntityData, hashed_input),
            },
        ],
    }),
    array_type: Some(STRINGHUBENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for StringHubEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        STRINGHUBENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static STRINGHUBENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StringHubEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("StringHubEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Vec4HubEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub input_count: i32,
    pub input_select: i32,
    pub hashed_input: Vec<u32>,
}

pub trait Vec4HubEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn input_count(&self) -> &i32;
    fn input_select(&self) -> &i32;
    fn hashed_input(&self) -> &Vec<u32>;
}

impl Vec4HubEntityDataTrait for Vec4HubEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn input_count(&self) -> &i32 {
        &self.input_count
    }
    fn input_select(&self) -> &i32 {
        &self.input_select
    }
    fn hashed_input(&self) -> &Vec<u32> {
        &self.hashed_input
    }
}

impl EntityDataTrait for Vec4HubEntityData {
}

impl GameObjectDataTrait for Vec4HubEntityData {
}

impl super::core::DataBusPeerTrait for Vec4HubEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for Vec4HubEntityData {
}

impl super::core::DataContainerTrait for Vec4HubEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static VEC4HUBENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec4HubEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec4HubEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(Vec4HubEntityData, realm),
            },
            FieldInfoData {
                name: "InputCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(Vec4HubEntityData, input_count),
            },
            FieldInfoData {
                name: "InputSelect",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(Vec4HubEntityData, input_select),
            },
            FieldInfoData {
                name: "HashedInput",
                flags: MemberInfoFlags::new(144),
                field_type: "Uint32-Array",
                rust_offset: offset_of!(Vec4HubEntityData, hashed_input),
            },
        ],
    }),
    array_type: Some(VEC4HUBENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for Vec4HubEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VEC4HUBENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VEC4HUBENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec4HubEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec4HubEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Vec3HubEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub input_count: i32,
    pub input_select: i32,
    pub hashed_input: Vec<u32>,
}

pub trait Vec3HubEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn input_count(&self) -> &i32;
    fn input_select(&self) -> &i32;
    fn hashed_input(&self) -> &Vec<u32>;
}

impl Vec3HubEntityDataTrait for Vec3HubEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn input_count(&self) -> &i32 {
        &self.input_count
    }
    fn input_select(&self) -> &i32 {
        &self.input_select
    }
    fn hashed_input(&self) -> &Vec<u32> {
        &self.hashed_input
    }
}

impl EntityDataTrait for Vec3HubEntityData {
}

impl GameObjectDataTrait for Vec3HubEntityData {
}

impl super::core::DataBusPeerTrait for Vec3HubEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for Vec3HubEntityData {
}

impl super::core::DataContainerTrait for Vec3HubEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static VEC3HUBENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3HubEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec3HubEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(Vec3HubEntityData, realm),
            },
            FieldInfoData {
                name: "InputCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(Vec3HubEntityData, input_count),
            },
            FieldInfoData {
                name: "InputSelect",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(Vec3HubEntityData, input_select),
            },
            FieldInfoData {
                name: "HashedInput",
                flags: MemberInfoFlags::new(144),
                field_type: "Uint32-Array",
                rust_offset: offset_of!(Vec3HubEntityData, hashed_input),
            },
        ],
    }),
    array_type: Some(VEC3HUBENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for Vec3HubEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VEC3HUBENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VEC3HUBENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3HubEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec3HubEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Vec2HubEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub input_count: i32,
    pub input_select: i32,
    pub hashed_input: Vec<u32>,
}

pub trait Vec2HubEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn input_count(&self) -> &i32;
    fn input_select(&self) -> &i32;
    fn hashed_input(&self) -> &Vec<u32>;
}

impl Vec2HubEntityDataTrait for Vec2HubEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn input_count(&self) -> &i32 {
        &self.input_count
    }
    fn input_select(&self) -> &i32 {
        &self.input_select
    }
    fn hashed_input(&self) -> &Vec<u32> {
        &self.hashed_input
    }
}

impl EntityDataTrait for Vec2HubEntityData {
}

impl GameObjectDataTrait for Vec2HubEntityData {
}

impl super::core::DataBusPeerTrait for Vec2HubEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for Vec2HubEntityData {
}

impl super::core::DataContainerTrait for Vec2HubEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static VEC2HUBENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec2HubEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec2HubEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(Vec2HubEntityData, realm),
            },
            FieldInfoData {
                name: "InputCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(Vec2HubEntityData, input_count),
            },
            FieldInfoData {
                name: "InputSelect",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(Vec2HubEntityData, input_select),
            },
            FieldInfoData {
                name: "HashedInput",
                flags: MemberInfoFlags::new(144),
                field_type: "Uint32-Array",
                rust_offset: offset_of!(Vec2HubEntityData, hashed_input),
            },
        ],
    }),
    array_type: Some(VEC2HUBENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for Vec2HubEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VEC2HUBENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VEC2HUBENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec2HubEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec2HubEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FloatHubEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub input_count: i32,
    pub input_select: i32,
    pub hashed_input: Vec<u32>,
}

pub trait FloatHubEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn input_count(&self) -> &i32;
    fn input_select(&self) -> &i32;
    fn hashed_input(&self) -> &Vec<u32>;
}

impl FloatHubEntityDataTrait for FloatHubEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn input_count(&self) -> &i32 {
        &self.input_count
    }
    fn input_select(&self) -> &i32 {
        &self.input_select
    }
    fn hashed_input(&self) -> &Vec<u32> {
        &self.hashed_input
    }
}

impl EntityDataTrait for FloatHubEntityData {
}

impl GameObjectDataTrait for FloatHubEntityData {
}

impl super::core::DataBusPeerTrait for FloatHubEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for FloatHubEntityData {
}

impl super::core::DataContainerTrait for FloatHubEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static FLOATHUBENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatHubEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FloatHubEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(FloatHubEntityData, realm),
            },
            FieldInfoData {
                name: "InputCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(FloatHubEntityData, input_count),
            },
            FieldInfoData {
                name: "InputSelect",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(FloatHubEntityData, input_select),
            },
            FieldInfoData {
                name: "HashedInput",
                flags: MemberInfoFlags::new(144),
                field_type: "Uint32-Array",
                rust_offset: offset_of!(FloatHubEntityData, hashed_input),
            },
        ],
    }),
    array_type: Some(FLOATHUBENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FloatHubEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        FLOATHUBENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static FLOATHUBENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatHubEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("FloatHubEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Int64HubEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub input_count: i32,
    pub input_select: i32,
    pub hashed_input: Vec<u32>,
}

pub trait Int64HubEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn input_count(&self) -> &i32;
    fn input_select(&self) -> &i32;
    fn hashed_input(&self) -> &Vec<u32>;
}

impl Int64HubEntityDataTrait for Int64HubEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn input_count(&self) -> &i32 {
        &self.input_count
    }
    fn input_select(&self) -> &i32 {
        &self.input_select
    }
    fn hashed_input(&self) -> &Vec<u32> {
        &self.hashed_input
    }
}

impl EntityDataTrait for Int64HubEntityData {
}

impl GameObjectDataTrait for Int64HubEntityData {
}

impl super::core::DataBusPeerTrait for Int64HubEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for Int64HubEntityData {
}

impl super::core::DataContainerTrait for Int64HubEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static INT64HUBENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Int64HubEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Int64HubEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(Int64HubEntityData, realm),
            },
            FieldInfoData {
                name: "InputCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(Int64HubEntityData, input_count),
            },
            FieldInfoData {
                name: "InputSelect",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(Int64HubEntityData, input_select),
            },
            FieldInfoData {
                name: "HashedInput",
                flags: MemberInfoFlags::new(144),
                field_type: "Uint32-Array",
                rust_offset: offset_of!(Int64HubEntityData, hashed_input),
            },
        ],
    }),
    array_type: Some(INT64HUBENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for Int64HubEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        INT64HUBENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static INT64HUBENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Int64HubEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Int64HubEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct IntHubEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub input_count: i32,
    pub input_select: i32,
    pub hashed_input: Vec<u32>,
}

pub trait IntHubEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn input_count(&self) -> &i32;
    fn input_select(&self) -> &i32;
    fn hashed_input(&self) -> &Vec<u32>;
}

impl IntHubEntityDataTrait for IntHubEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn input_count(&self) -> &i32 {
        &self.input_count
    }
    fn input_select(&self) -> &i32 {
        &self.input_select
    }
    fn hashed_input(&self) -> &Vec<u32> {
        &self.hashed_input
    }
}

impl EntityDataTrait for IntHubEntityData {
}

impl GameObjectDataTrait for IntHubEntityData {
}

impl super::core::DataBusPeerTrait for IntHubEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for IntHubEntityData {
}

impl super::core::DataContainerTrait for IntHubEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static INTHUBENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntHubEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<IntHubEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(IntHubEntityData, realm),
            },
            FieldInfoData {
                name: "InputCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(IntHubEntityData, input_count),
            },
            FieldInfoData {
                name: "InputSelect",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(IntHubEntityData, input_select),
            },
            FieldInfoData {
                name: "HashedInput",
                flags: MemberInfoFlags::new(144),
                field_type: "Uint32-Array",
                rust_offset: offset_of!(IntHubEntityData, hashed_input),
            },
        ],
    }),
    array_type: Some(INTHUBENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for IntHubEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        INTHUBENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static INTHUBENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntHubEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("IntHubEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BoolHubEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub input_select: i32,
    pub hashed_input: Vec<u32>,
}

pub trait BoolHubEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn input_select(&self) -> &i32;
    fn hashed_input(&self) -> &Vec<u32>;
}

impl BoolHubEntityDataTrait for BoolHubEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn input_select(&self) -> &i32 {
        &self.input_select
    }
    fn hashed_input(&self) -> &Vec<u32> {
        &self.hashed_input
    }
}

impl EntityDataTrait for BoolHubEntityData {
}

impl GameObjectDataTrait for BoolHubEntityData {
}

impl super::core::DataBusPeerTrait for BoolHubEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for BoolHubEntityData {
}

impl super::core::DataContainerTrait for BoolHubEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static BOOLHUBENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolHubEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BoolHubEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(BoolHubEntityData, realm),
            },
            FieldInfoData {
                name: "InputSelect",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(BoolHubEntityData, input_select),
            },
            FieldInfoData {
                name: "HashedInput",
                flags: MemberInfoFlags::new(144),
                field_type: "Uint32-Array",
                rust_offset: offset_of!(BoolHubEntityData, hashed_input),
            },
        ],
    }),
    array_type: Some(BOOLHUBENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BoolHubEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        BOOLHUBENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static BOOLHUBENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolHubEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("BoolHubEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SimpleDofParamConverterEntityData {
    pub _glacier_base: EntityData,
    pub focus_distance: f32,
    pub blur_filter_deviation: f32,
    pub near_distance_scale: f32,
    pub far_distance_scale: f32,
    pub scale: f32,
}

pub trait SimpleDofParamConverterEntityDataTrait: EntityDataTrait {
    fn focus_distance(&self) -> &f32;
    fn blur_filter_deviation(&self) -> &f32;
    fn near_distance_scale(&self) -> &f32;
    fn far_distance_scale(&self) -> &f32;
    fn scale(&self) -> &f32;
}

impl SimpleDofParamConverterEntityDataTrait for SimpleDofParamConverterEntityData {
    fn focus_distance(&self) -> &f32 {
        &self.focus_distance
    }
    fn blur_filter_deviation(&self) -> &f32 {
        &self.blur_filter_deviation
    }
    fn near_distance_scale(&self) -> &f32 {
        &self.near_distance_scale
    }
    fn far_distance_scale(&self) -> &f32 {
        &self.far_distance_scale
    }
    fn scale(&self) -> &f32 {
        &self.scale
    }
}

impl EntityDataTrait for SimpleDofParamConverterEntityData {
}

impl GameObjectDataTrait for SimpleDofParamConverterEntityData {
}

impl super::core::DataBusPeerTrait for SimpleDofParamConverterEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for SimpleDofParamConverterEntityData {
}

impl super::core::DataContainerTrait for SimpleDofParamConverterEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SIMPLEDOFPARAMCONVERTERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleDofParamConverterEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SimpleDofParamConverterEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "FocusDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SimpleDofParamConverterEntityData, focus_distance),
            },
            FieldInfoData {
                name: "BlurFilterDeviation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SimpleDofParamConverterEntityData, blur_filter_deviation),
            },
            FieldInfoData {
                name: "NearDistanceScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SimpleDofParamConverterEntityData, near_distance_scale),
            },
            FieldInfoData {
                name: "FarDistanceScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SimpleDofParamConverterEntityData, far_distance_scale),
            },
            FieldInfoData {
                name: "Scale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SimpleDofParamConverterEntityData, scale),
            },
        ],
    }),
    array_type: Some(SIMPLEDOFPARAMCONVERTERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SimpleDofParamConverterEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SIMPLEDOFPARAMCONVERTERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SIMPLEDOFPARAMCONVERTERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleDofParamConverterEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SimpleDofParamConverterEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SpriteDofParamConverterEntityData {
    pub _glacier_base: EntityData,
    pub sprite_dof_out_focus_start: f32,
    pub sprite_dof_out_focus_end: f32,
    pub sprite_dof_max_blur_factor: f32,
}

pub trait SpriteDofParamConverterEntityDataTrait: EntityDataTrait {
    fn sprite_dof_out_focus_start(&self) -> &f32;
    fn sprite_dof_out_focus_end(&self) -> &f32;
    fn sprite_dof_max_blur_factor(&self) -> &f32;
}

impl SpriteDofParamConverterEntityDataTrait for SpriteDofParamConverterEntityData {
    fn sprite_dof_out_focus_start(&self) -> &f32 {
        &self.sprite_dof_out_focus_start
    }
    fn sprite_dof_out_focus_end(&self) -> &f32 {
        &self.sprite_dof_out_focus_end
    }
    fn sprite_dof_max_blur_factor(&self) -> &f32 {
        &self.sprite_dof_max_blur_factor
    }
}

impl EntityDataTrait for SpriteDofParamConverterEntityData {
}

impl GameObjectDataTrait for SpriteDofParamConverterEntityData {
}

impl super::core::DataBusPeerTrait for SpriteDofParamConverterEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for SpriteDofParamConverterEntityData {
}

impl super::core::DataContainerTrait for SpriteDofParamConverterEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SPRITEDOFPARAMCONVERTERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpriteDofParamConverterEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SpriteDofParamConverterEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SpriteDofOutFocusStart",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpriteDofParamConverterEntityData, sprite_dof_out_focus_start),
            },
            FieldInfoData {
                name: "SpriteDofOutFocusEnd",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpriteDofParamConverterEntityData, sprite_dof_out_focus_end),
            },
            FieldInfoData {
                name: "SpriteDofMaxBlurFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpriteDofParamConverterEntityData, sprite_dof_max_blur_factor),
            },
        ],
    }),
    array_type: Some(SPRITEDOFPARAMCONVERTERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SpriteDofParamConverterEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SPRITEDOFPARAMCONVERTERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SPRITEDOFPARAMCONVERTERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpriteDofParamConverterEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SpriteDofParamConverterEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ObjectVariationMultiSwitchEntityData {
    pub _glacier_base: EntityData,
    pub variations: Vec<Option<Arc<Mutex<dyn ObjectVariationTrait>>>>,
    pub current_index: i32,
    pub set_on_init: bool,
}

pub trait ObjectVariationMultiSwitchEntityDataTrait: EntityDataTrait {
    fn variations(&self) -> &Vec<Option<Arc<Mutex<dyn ObjectVariationTrait>>>>;
    fn current_index(&self) -> &i32;
    fn set_on_init(&self) -> &bool;
}

impl ObjectVariationMultiSwitchEntityDataTrait for ObjectVariationMultiSwitchEntityData {
    fn variations(&self) -> &Vec<Option<Arc<Mutex<dyn ObjectVariationTrait>>>> {
        &self.variations
    }
    fn current_index(&self) -> &i32 {
        &self.current_index
    }
    fn set_on_init(&self) -> &bool {
        &self.set_on_init
    }
}

impl EntityDataTrait for ObjectVariationMultiSwitchEntityData {
}

impl GameObjectDataTrait for ObjectVariationMultiSwitchEntityData {
}

impl super::core::DataBusPeerTrait for ObjectVariationMultiSwitchEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for ObjectVariationMultiSwitchEntityData {
}

impl super::core::DataContainerTrait for ObjectVariationMultiSwitchEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static OBJECTVARIATIONMULTISWITCHENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectVariationMultiSwitchEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ObjectVariationMultiSwitchEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Variations",
                flags: MemberInfoFlags::new(144),
                field_type: "ObjectVariation-Array",
                rust_offset: offset_of!(ObjectVariationMultiSwitchEntityData, variations),
            },
            FieldInfoData {
                name: "CurrentIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ObjectVariationMultiSwitchEntityData, current_index),
            },
            FieldInfoData {
                name: "SetOnInit",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ObjectVariationMultiSwitchEntityData, set_on_init),
            },
        ],
    }),
    array_type: Some(OBJECTVARIATIONMULTISWITCHENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ObjectVariationMultiSwitchEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        OBJECTVARIATIONMULTISWITCHENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static OBJECTVARIATIONMULTISWITCHENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectVariationMultiSwitchEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ObjectVariationMultiSwitchEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ObjectVariationSwitchEntityData {
    pub _glacier_base: EntityData,
    pub variation1: Option<Arc<Mutex<dyn ObjectVariationTrait>>>,
    pub variation2: Option<Arc<Mutex<dyn ObjectVariationTrait>>>,
}

pub trait ObjectVariationSwitchEntityDataTrait: EntityDataTrait {
    fn variation1(&self) -> &Option<Arc<Mutex<dyn ObjectVariationTrait>>>;
    fn variation2(&self) -> &Option<Arc<Mutex<dyn ObjectVariationTrait>>>;
}

impl ObjectVariationSwitchEntityDataTrait for ObjectVariationSwitchEntityData {
    fn variation1(&self) -> &Option<Arc<Mutex<dyn ObjectVariationTrait>>> {
        &self.variation1
    }
    fn variation2(&self) -> &Option<Arc<Mutex<dyn ObjectVariationTrait>>> {
        &self.variation2
    }
}

impl EntityDataTrait for ObjectVariationSwitchEntityData {
}

impl GameObjectDataTrait for ObjectVariationSwitchEntityData {
}

impl super::core::DataBusPeerTrait for ObjectVariationSwitchEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for ObjectVariationSwitchEntityData {
}

impl super::core::DataContainerTrait for ObjectVariationSwitchEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static OBJECTVARIATIONSWITCHENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectVariationSwitchEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ObjectVariationSwitchEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Variation1",
                flags: MemberInfoFlags::new(0),
                field_type: "ObjectVariation",
                rust_offset: offset_of!(ObjectVariationSwitchEntityData, variation1),
            },
            FieldInfoData {
                name: "Variation2",
                flags: MemberInfoFlags::new(0),
                field_type: "ObjectVariation",
                rust_offset: offset_of!(ObjectVariationSwitchEntityData, variation2),
            },
        ],
    }),
    array_type: Some(OBJECTVARIATIONSWITCHENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ObjectVariationSwitchEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        OBJECTVARIATIONSWITCHENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static OBJECTVARIATIONSWITCHENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectVariationSwitchEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ObjectVariationSwitchEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RandomDelayEntityData {
    pub _glacier_base: EntityData,
    pub min_delay: f32,
    pub max_delay: f32,
    pub realm: super::core::Realm,
    pub auto_start: bool,
    pub run_once: bool,
    pub true_random: bool,
    pub time_delta_type: TimeDeltaType,
}

pub trait RandomDelayEntityDataTrait: EntityDataTrait {
    fn min_delay(&self) -> &f32;
    fn max_delay(&self) -> &f32;
    fn realm(&self) -> &super::core::Realm;
    fn auto_start(&self) -> &bool;
    fn run_once(&self) -> &bool;
    fn true_random(&self) -> &bool;
    fn time_delta_type(&self) -> &TimeDeltaType;
}

impl RandomDelayEntityDataTrait for RandomDelayEntityData {
    fn min_delay(&self) -> &f32 {
        &self.min_delay
    }
    fn max_delay(&self) -> &f32 {
        &self.max_delay
    }
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn auto_start(&self) -> &bool {
        &self.auto_start
    }
    fn run_once(&self) -> &bool {
        &self.run_once
    }
    fn true_random(&self) -> &bool {
        &self.true_random
    }
    fn time_delta_type(&self) -> &TimeDeltaType {
        &self.time_delta_type
    }
}

impl EntityDataTrait for RandomDelayEntityData {
}

impl GameObjectDataTrait for RandomDelayEntityData {
}

impl super::core::DataBusPeerTrait for RandomDelayEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for RandomDelayEntityData {
}

impl super::core::DataContainerTrait for RandomDelayEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static RANDOMDELAYENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RandomDelayEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RandomDelayEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MinDelay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RandomDelayEntityData, min_delay),
            },
            FieldInfoData {
                name: "MaxDelay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RandomDelayEntityData, max_delay),
            },
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(RandomDelayEntityData, realm),
            },
            FieldInfoData {
                name: "AutoStart",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RandomDelayEntityData, auto_start),
            },
            FieldInfoData {
                name: "RunOnce",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RandomDelayEntityData, run_once),
            },
            FieldInfoData {
                name: "TrueRandom",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RandomDelayEntityData, true_random),
            },
            FieldInfoData {
                name: "TimeDeltaType",
                flags: MemberInfoFlags::new(0),
                field_type: "TimeDeltaType",
                rust_offset: offset_of!(RandomDelayEntityData, time_delta_type),
            },
        ],
    }),
    array_type: Some(RANDOMDELAYENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RandomDelayEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        RANDOMDELAYENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static RANDOMDELAYENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RandomDelayEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("RandomDelayEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DelayEntityData {
    pub _glacier_base: EntityData,
    pub delay: f32,
    pub realm: super::core::Realm,
    pub auto_start: bool,
    pub run_once: bool,
    pub remove_duplicate_events: bool,
    pub time_delta_type: TimeDeltaType,
}

pub trait DelayEntityDataTrait: EntityDataTrait {
    fn delay(&self) -> &f32;
    fn realm(&self) -> &super::core::Realm;
    fn auto_start(&self) -> &bool;
    fn run_once(&self) -> &bool;
    fn remove_duplicate_events(&self) -> &bool;
    fn time_delta_type(&self) -> &TimeDeltaType;
}

impl DelayEntityDataTrait for DelayEntityData {
    fn delay(&self) -> &f32 {
        &self.delay
    }
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn auto_start(&self) -> &bool {
        &self.auto_start
    }
    fn run_once(&self) -> &bool {
        &self.run_once
    }
    fn remove_duplicate_events(&self) -> &bool {
        &self.remove_duplicate_events
    }
    fn time_delta_type(&self) -> &TimeDeltaType {
        &self.time_delta_type
    }
}

impl EntityDataTrait for DelayEntityData {
}

impl GameObjectDataTrait for DelayEntityData {
}

impl super::core::DataBusPeerTrait for DelayEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for DelayEntityData {
}

impl super::core::DataContainerTrait for DelayEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static DELAYENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DelayEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DelayEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Delay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DelayEntityData, delay),
            },
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(DelayEntityData, realm),
            },
            FieldInfoData {
                name: "AutoStart",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DelayEntityData, auto_start),
            },
            FieldInfoData {
                name: "RunOnce",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DelayEntityData, run_once),
            },
            FieldInfoData {
                name: "RemoveDuplicateEvents",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DelayEntityData, remove_duplicate_events),
            },
            FieldInfoData {
                name: "TimeDeltaType",
                flags: MemberInfoFlags::new(0),
                field_type: "TimeDeltaType",
                rust_offset: offset_of!(DelayEntityData, time_delta_type),
            },
        ],
    }),
    array_type: Some(DELAYENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DelayEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        DELAYENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static DELAYENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DelayEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("DelayEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EventOrderGateEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub event_count: u32,
    pub enabled: bool,
    pub disable_on_open: bool,
    pub event_countdowns: Vec<u32>,
    pub source_hashes: Vec<i32>,
}

pub trait EventOrderGateEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn event_count(&self) -> &u32;
    fn enabled(&self) -> &bool;
    fn disable_on_open(&self) -> &bool;
    fn event_countdowns(&self) -> &Vec<u32>;
    fn source_hashes(&self) -> &Vec<i32>;
}

impl EventOrderGateEntityDataTrait for EventOrderGateEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn event_count(&self) -> &u32 {
        &self.event_count
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn disable_on_open(&self) -> &bool {
        &self.disable_on_open
    }
    fn event_countdowns(&self) -> &Vec<u32> {
        &self.event_countdowns
    }
    fn source_hashes(&self) -> &Vec<i32> {
        &self.source_hashes
    }
}

impl EntityDataTrait for EventOrderGateEntityData {
}

impl GameObjectDataTrait for EventOrderGateEntityData {
}

impl super::core::DataBusPeerTrait for EventOrderGateEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for EventOrderGateEntityData {
}

impl super::core::DataContainerTrait for EventOrderGateEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static EVENTORDERGATEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventOrderGateEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EventOrderGateEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(EventOrderGateEntityData, realm),
            },
            FieldInfoData {
                name: "EventCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(EventOrderGateEntityData, event_count),
            },
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EventOrderGateEntityData, enabled),
            },
            FieldInfoData {
                name: "DisableOnOpen",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EventOrderGateEntityData, disable_on_open),
            },
            FieldInfoData {
                name: "EventCountdowns",
                flags: MemberInfoFlags::new(144),
                field_type: "Uint32-Array",
                rust_offset: offset_of!(EventOrderGateEntityData, event_countdowns),
            },
            FieldInfoData {
                name: "SourceHashes",
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(EventOrderGateEntityData, source_hashes),
            },
        ],
    }),
    array_type: Some(EVENTORDERGATEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EventOrderGateEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        EVENTORDERGATEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static EVENTORDERGATEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventOrderGateEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EventOrderGateEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EventAndGateEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub event_count: u32,
}

pub trait EventAndGateEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn event_count(&self) -> &u32;
}

impl EventAndGateEntityDataTrait for EventAndGateEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn event_count(&self) -> &u32 {
        &self.event_count
    }
}

impl EntityDataTrait for EventAndGateEntityData {
}

impl GameObjectDataTrait for EventAndGateEntityData {
}

impl super::core::DataBusPeerTrait for EventAndGateEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for EventAndGateEntityData {
}

impl super::core::DataContainerTrait for EventAndGateEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static EVENTANDGATEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventAndGateEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EventAndGateEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(EventAndGateEntityData, realm),
            },
            FieldInfoData {
                name: "EventCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(EventAndGateEntityData, event_count),
            },
        ],
    }),
    array_type: Some(EVENTANDGATEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EventAndGateEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        EVENTANDGATEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static EVENTANDGATEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventAndGateEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EventAndGateEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SelectEventEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub selected: i32,
    pub events: Vec<String>,
}

pub trait SelectEventEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn selected(&self) -> &i32;
    fn events(&self) -> &Vec<String>;
}

impl SelectEventEntityDataTrait for SelectEventEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn selected(&self) -> &i32 {
        &self.selected
    }
    fn events(&self) -> &Vec<String> {
        &self.events
    }
}

impl EntityDataTrait for SelectEventEntityData {
}

impl GameObjectDataTrait for SelectEventEntityData {
}

impl super::core::DataBusPeerTrait for SelectEventEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for SelectEventEntityData {
}

impl super::core::DataContainerTrait for SelectEventEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static SELECTEVENTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectEventEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SelectEventEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(SelectEventEntityData, realm),
            },
            FieldInfoData {
                name: "Selected",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SelectEventEntityData, selected),
            },
            FieldInfoData {
                name: "Events",
                flags: MemberInfoFlags::new(144),
                field_type: "CString-Array",
                rust_offset: offset_of!(SelectEventEntityData, events),
            },
        ],
    }),
    array_type: Some(SELECTEVENTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SelectEventEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SELECTEVENTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SELECTEVENTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectEventEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SelectEventEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EventSwitchEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub out_events: u32,
    pub auto_increment: bool,
}

pub trait EventSwitchEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn out_events(&self) -> &u32;
    fn auto_increment(&self) -> &bool;
}

impl EventSwitchEntityDataTrait for EventSwitchEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn out_events(&self) -> &u32 {
        &self.out_events
    }
    fn auto_increment(&self) -> &bool {
        &self.auto_increment
    }
}

impl EntityDataTrait for EventSwitchEntityData {
}

impl GameObjectDataTrait for EventSwitchEntityData {
}

impl super::core::DataBusPeerTrait for EventSwitchEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for EventSwitchEntityData {
}

impl super::core::DataContainerTrait for EventSwitchEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static EVENTSWITCHENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventSwitchEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EventSwitchEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(EventSwitchEntityData, realm),
            },
            FieldInfoData {
                name: "OutEvents",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(EventSwitchEntityData, out_events),
            },
            FieldInfoData {
                name: "AutoIncrement",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EventSwitchEntityData, auto_increment),
            },
        ],
    }),
    array_type: Some(EVENTSWITCHENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EventSwitchEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        EVENTSWITCHENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static EVENTSWITCHENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventSwitchEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EventSwitchEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct UniqueIdEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
}

pub trait UniqueIdEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
}

impl UniqueIdEntityDataTrait for UniqueIdEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
}

impl EntityDataTrait for UniqueIdEntityData {
}

impl GameObjectDataTrait for UniqueIdEntityData {
}

impl super::core::DataBusPeerTrait for UniqueIdEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for UniqueIdEntityData {
}

impl super::core::DataContainerTrait for UniqueIdEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static UNIQUEIDENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UniqueIdEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<UniqueIdEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(UniqueIdEntityData, realm),
            },
        ],
    }),
    array_type: Some(UNIQUEIDENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for UniqueIdEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        UNIQUEIDENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static UNIQUEIDENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UniqueIdEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("UniqueIdEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RandomIntEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub start: i32,
    pub count: i32,
    pub true_random: bool,
}

pub trait RandomIntEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn start(&self) -> &i32;
    fn count(&self) -> &i32;
    fn true_random(&self) -> &bool;
}

impl RandomIntEntityDataTrait for RandomIntEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn start(&self) -> &i32 {
        &self.start
    }
    fn count(&self) -> &i32 {
        &self.count
    }
    fn true_random(&self) -> &bool {
        &self.true_random
    }
}

impl EntityDataTrait for RandomIntEntityData {
}

impl GameObjectDataTrait for RandomIntEntityData {
}

impl super::core::DataBusPeerTrait for RandomIntEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for RandomIntEntityData {
}

impl super::core::DataContainerTrait for RandomIntEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static RANDOMINTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RandomIntEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RandomIntEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(RandomIntEntityData, realm),
            },
            FieldInfoData {
                name: "Start",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(RandomIntEntityData, start),
            },
            FieldInfoData {
                name: "Count",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(RandomIntEntityData, count),
            },
            FieldInfoData {
                name: "TrueRandom",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RandomIntEntityData, true_random),
            },
        ],
    }),
    array_type: Some(RANDOMINTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RandomIntEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        RANDOMINTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static RANDOMINTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RandomIntEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("RandomIntEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RandomFloatEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub min: f32,
    pub max: f32,
    pub true_random: bool,
}

pub trait RandomFloatEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn min(&self) -> &f32;
    fn max(&self) -> &f32;
    fn true_random(&self) -> &bool;
}

impl RandomFloatEntityDataTrait for RandomFloatEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn min(&self) -> &f32 {
        &self.min
    }
    fn max(&self) -> &f32 {
        &self.max
    }
    fn true_random(&self) -> &bool {
        &self.true_random
    }
}

impl EntityDataTrait for RandomFloatEntityData {
}

impl GameObjectDataTrait for RandomFloatEntityData {
}

impl super::core::DataBusPeerTrait for RandomFloatEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for RandomFloatEntityData {
}

impl super::core::DataContainerTrait for RandomFloatEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static RANDOMFLOATENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RandomFloatEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RandomFloatEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(RandomFloatEntityData, realm),
            },
            FieldInfoData {
                name: "Min",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RandomFloatEntityData, min),
            },
            FieldInfoData {
                name: "Max",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RandomFloatEntityData, max),
            },
            FieldInfoData {
                name: "TrueRandom",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RandomFloatEntityData, true_random),
            },
        ],
    }),
    array_type: Some(RANDOMFLOATENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RandomFloatEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        RANDOMFLOATENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static RANDOMFLOATENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RandomFloatEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("RandomFloatEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RandomMultiEventEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub uniform_distribution: bool,
    pub disable_output_on_trigger: bool,
    pub reset_outputs_when_all_has_triggered: bool,
    pub random_event_weight: Vec<f32>,
    pub true_random: bool,
}

pub trait RandomMultiEventEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn uniform_distribution(&self) -> &bool;
    fn disable_output_on_trigger(&self) -> &bool;
    fn reset_outputs_when_all_has_triggered(&self) -> &bool;
    fn random_event_weight(&self) -> &Vec<f32>;
    fn true_random(&self) -> &bool;
}

impl RandomMultiEventEntityDataTrait for RandomMultiEventEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn uniform_distribution(&self) -> &bool {
        &self.uniform_distribution
    }
    fn disable_output_on_trigger(&self) -> &bool {
        &self.disable_output_on_trigger
    }
    fn reset_outputs_when_all_has_triggered(&self) -> &bool {
        &self.reset_outputs_when_all_has_triggered
    }
    fn random_event_weight(&self) -> &Vec<f32> {
        &self.random_event_weight
    }
    fn true_random(&self) -> &bool {
        &self.true_random
    }
}

impl EntityDataTrait for RandomMultiEventEntityData {
}

impl GameObjectDataTrait for RandomMultiEventEntityData {
}

impl super::core::DataBusPeerTrait for RandomMultiEventEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for RandomMultiEventEntityData {
}

impl super::core::DataContainerTrait for RandomMultiEventEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static RANDOMMULTIEVENTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RandomMultiEventEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RandomMultiEventEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(RandomMultiEventEntityData, realm),
            },
            FieldInfoData {
                name: "UniformDistribution",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RandomMultiEventEntityData, uniform_distribution),
            },
            FieldInfoData {
                name: "DisableOutputOnTrigger",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RandomMultiEventEntityData, disable_output_on_trigger),
            },
            FieldInfoData {
                name: "ResetOutputsWhenAllHasTriggered",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RandomMultiEventEntityData, reset_outputs_when_all_has_triggered),
            },
            FieldInfoData {
                name: "RandomEventWeight",
                flags: MemberInfoFlags::new(144),
                field_type: "Float32-Array",
                rust_offset: offset_of!(RandomMultiEventEntityData, random_event_weight),
            },
            FieldInfoData {
                name: "TrueRandom",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RandomMultiEventEntityData, true_random),
            },
        ],
    }),
    array_type: Some(RANDOMMULTIEVENTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RandomMultiEventEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        RANDOMMULTIEVENTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static RANDOMMULTIEVENTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RandomMultiEventEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("RandomMultiEventEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RandomEventEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub probability: i32,
    pub randomize_first_only: bool,
    pub auto_start: bool,
}

pub trait RandomEventEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn probability(&self) -> &i32;
    fn randomize_first_only(&self) -> &bool;
    fn auto_start(&self) -> &bool;
}

impl RandomEventEntityDataTrait for RandomEventEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn probability(&self) -> &i32 {
        &self.probability
    }
    fn randomize_first_only(&self) -> &bool {
        &self.randomize_first_only
    }
    fn auto_start(&self) -> &bool {
        &self.auto_start
    }
}

impl EntityDataTrait for RandomEventEntityData {
}

impl GameObjectDataTrait for RandomEventEntityData {
}

impl super::core::DataBusPeerTrait for RandomEventEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for RandomEventEntityData {
}

impl super::core::DataContainerTrait for RandomEventEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static RANDOMEVENTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RandomEventEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RandomEventEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(RandomEventEntityData, realm),
            },
            FieldInfoData {
                name: "Probability",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(RandomEventEntityData, probability),
            },
            FieldInfoData {
                name: "RandomizeFirstOnly",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RandomEventEntityData, randomize_first_only),
            },
            FieldInfoData {
                name: "AutoStart",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RandomEventEntityData, auto_start),
            },
        ],
    }),
    array_type: Some(RANDOMEVENTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RandomEventEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        RANDOMEVENTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static RANDOMEVENTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RandomEventEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("RandomEventEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LocatorEntityData {
    pub _glacier_base: SpatialEntityData,
    pub realm: super::core::Realm,
}

pub trait LocatorEntityDataTrait: SpatialEntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
}

impl LocatorEntityDataTrait for LocatorEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
}

impl SpatialEntityDataTrait for LocatorEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
}

impl EntityDataTrait for LocatorEntityData {
}

impl GameObjectDataTrait for LocatorEntityData {
}

impl super::core::DataBusPeerTrait for LocatorEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for LocatorEntityData {
}

impl super::core::DataContainerTrait for LocatorEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static LOCATORENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocatorEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SPATIALENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LocatorEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(LocatorEntityData, realm),
            },
        ],
    }),
    array_type: Some(LOCATORENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for LocatorEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        LOCATORENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static LOCATORENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocatorEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("LocatorEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CountDownEntityData {
    pub _glacier_base: EntityData,
    pub start_value: i32,
    pub run_once: bool,
    pub realm: super::core::Realm,
}

pub trait CountDownEntityDataTrait: EntityDataTrait {
    fn start_value(&self) -> &i32;
    fn run_once(&self) -> &bool;
    fn realm(&self) -> &super::core::Realm;
}

impl CountDownEntityDataTrait for CountDownEntityData {
    fn start_value(&self) -> &i32 {
        &self.start_value
    }
    fn run_once(&self) -> &bool {
        &self.run_once
    }
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
}

impl EntityDataTrait for CountDownEntityData {
}

impl GameObjectDataTrait for CountDownEntityData {
}

impl super::core::DataBusPeerTrait for CountDownEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for CountDownEntityData {
}

impl super::core::DataContainerTrait for CountDownEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static COUNTDOWNENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CountDownEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CountDownEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "StartValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CountDownEntityData, start_value),
            },
            FieldInfoData {
                name: "RunOnce",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CountDownEntityData, run_once),
            },
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(CountDownEntityData, realm),
            },
        ],
    }),
    array_type: Some(COUNTDOWNENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CountDownEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        COUNTDOWNENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static COUNTDOWNENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CountDownEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CountDownEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MathEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub evaluate_on_event: bool,
    pub assembly: MathEntityAssembly,
}

pub trait MathEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn evaluate_on_event(&self) -> &bool;
    fn assembly(&self) -> &MathEntityAssembly;
}

impl MathEntityDataTrait for MathEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn evaluate_on_event(&self) -> &bool {
        &self.evaluate_on_event
    }
    fn assembly(&self) -> &MathEntityAssembly {
        &self.assembly
    }
}

impl EntityDataTrait for MathEntityData {
}

impl GameObjectDataTrait for MathEntityData {
}

impl super::core::DataBusPeerTrait for MathEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for MathEntityData {
}

impl super::core::DataContainerTrait for MathEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static MATHENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MathEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MathEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(MathEntityData, realm),
            },
            FieldInfoData {
                name: "EvaluateOnEvent",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MathEntityData, evaluate_on_event),
            },
            FieldInfoData {
                name: "Assembly",
                flags: MemberInfoFlags::new(0),
                field_type: "MathEntityAssembly",
                rust_offset: offset_of!(MathEntityData, assembly),
            },
        ],
    }),
    array_type: Some(MATHENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MathEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        MATHENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static MATHENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MathEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("MathEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MathEntityAssembly {
    pub function_calls: Vec<MathEntityFunctionCall>,
    pub instructions: Vec<MathEntityInstruction>,
}

pub trait MathEntityAssemblyTrait: TypeObject {
    fn function_calls(&self) -> &Vec<MathEntityFunctionCall>;
    fn instructions(&self) -> &Vec<MathEntityInstruction>;
}

impl MathEntityAssemblyTrait for MathEntityAssembly {
    fn function_calls(&self) -> &Vec<MathEntityFunctionCall> {
        &self.function_calls
    }
    fn instructions(&self) -> &Vec<MathEntityInstruction> {
        &self.instructions
    }
}

pub static MATHENTITYASSEMBLY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MathEntityAssembly",
    flags: MemberInfoFlags::new(73),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MathEntityAssembly as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "FunctionCalls",
                flags: MemberInfoFlags::new(144),
                field_type: "MathEntityFunctionCall-Array",
                rust_offset: offset_of!(MathEntityAssembly, function_calls),
            },
            FieldInfoData {
                name: "Instructions",
                flags: MemberInfoFlags::new(144),
                field_type: "MathEntityInstruction-Array",
                rust_offset: offset_of!(MathEntityAssembly, instructions),
            },
        ],
    }),
    array_type: Some(MATHENTITYASSEMBLY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MathEntityAssembly {
    fn type_info(&self) -> &'static TypeInfo {
        MATHENTITYASSEMBLY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static MATHENTITYASSEMBLY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MathEntityAssembly-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("MathEntityAssembly"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum MathEntityType {
    #[default]
    MathEntityType_Bool = 1,
    MathEntityType_Int = 2,
    MathEntityType_Float = 4,
    MathEntityType_Vec2 = 8,
    MathEntityType_Vec3 = 16,
    MathEntityType_Vec4 = 32,
    MathEntityType_Transform = 64,
}

pub static MATHENTITYTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MathEntityType",
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(MATHENTITYTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for MathEntityType {
    fn type_info(&self) -> &'static TypeInfo {
        MATHENTITYTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static MATHENTITYTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MathEntityType-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("MathEntityType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MathEntityFunctionCall {
    pub parameters: Vec<u32>,
}

pub trait MathEntityFunctionCallTrait: TypeObject {
    fn parameters(&self) -> &Vec<u32>;
}

impl MathEntityFunctionCallTrait for MathEntityFunctionCall {
    fn parameters(&self) -> &Vec<u32> {
        &self.parameters
    }
}

pub static MATHENTITYFUNCTIONCALL_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MathEntityFunctionCall",
    flags: MemberInfoFlags::new(73),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MathEntityFunctionCall as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Parameters",
                flags: MemberInfoFlags::new(144),
                field_type: "Uint32-Array",
                rust_offset: offset_of!(MathEntityFunctionCall, parameters),
            },
        ],
    }),
    array_type: Some(MATHENTITYFUNCTIONCALL_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MathEntityFunctionCall {
    fn type_info(&self) -> &'static TypeInfo {
        MATHENTITYFUNCTIONCALL_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static MATHENTITYFUNCTIONCALL_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MathEntityFunctionCall-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("MathEntityFunctionCall"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MathEntityInstruction {
    pub code: MathOpCode,
    pub result: i32,
    pub param1: i32,
    pub param2: i32,
}

pub trait MathEntityInstructionTrait: TypeObject {
    fn code(&self) -> &MathOpCode;
    fn result(&self) -> &i32;
    fn param1(&self) -> &i32;
    fn param2(&self) -> &i32;
}

impl MathEntityInstructionTrait for MathEntityInstruction {
    fn code(&self) -> &MathOpCode {
        &self.code
    }
    fn result(&self) -> &i32 {
        &self.result
    }
    fn param1(&self) -> &i32 {
        &self.param1
    }
    fn param2(&self) -> &i32 {
        &self.param2
    }
}

pub static MATHENTITYINSTRUCTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MathEntityInstruction",
    flags: MemberInfoFlags::new(36937),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MathEntityInstruction as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Code",
                flags: MemberInfoFlags::new(0),
                field_type: "MathOpCode",
                rust_offset: offset_of!(MathEntityInstruction, code),
            },
            FieldInfoData {
                name: "Result",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MathEntityInstruction, result),
            },
            FieldInfoData {
                name: "Param1",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MathEntityInstruction, param1),
            },
            FieldInfoData {
                name: "Param2",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MathEntityInstruction, param2),
            },
        ],
    }),
    array_type: Some(MATHENTITYINSTRUCTION_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for MathEntityInstruction {
    fn type_info(&self) -> &'static TypeInfo {
        MATHENTITYINSTRUCTION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static MATHENTITYINSTRUCTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MathEntityInstruction-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("MathEntityInstruction"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum MathOpCode {
    #[default]
    MathOpCode_ConstB = 0,
    MathOpCode_ConstI = 1,
    MathOpCode_ConstF = 2,
    MathOpCode_InputB = 3,
    MathOpCode_InputI = 4,
    MathOpCode_InputF = 5,
    MathOpCode_InputV2 = 6,
    MathOpCode_InputV3 = 7,
    MathOpCode_InputV4 = 8,
    MathOpCode_InputT = 9,
    MathOpCode_OrB = 10,
    MathOpCode_AndB = 11,
    MathOpCode_GreaterI = 12,
    MathOpCode_GreaterF = 13,
    MathOpCode_GreaterEqI = 14,
    MathOpCode_GreaterEqF = 15,
    MathOpCode_LessI = 16,
    MathOpCode_LessF = 17,
    MathOpCode_LessEqI = 18,
    MathOpCode_LessEqF = 19,
    MathOpCode_NotEqI = 20,
    MathOpCode_NotEqF = 21,
    MathOpCode_NotEqB = 22,
    MathOpCode_EqI = 23,
    MathOpCode_EqF = 24,
    MathOpCode_EqB = 25,
    MathOpCode_AddI = 26,
    MathOpCode_AddF = 27,
    MathOpCode_AddV2 = 28,
    MathOpCode_AddV3 = 29,
    MathOpCode_AddV4 = 30,
    MathOpCode_SubI = 31,
    MathOpCode_SubF = 32,
    MathOpCode_SubV2 = 33,
    MathOpCode_SubV3 = 34,
    MathOpCode_SubV4 = 35,
    MathOpCode_MulF = 36,
    MathOpCode_MulI = 37,
    MathOpCode_MulV2F = 38,
    MathOpCode_MulV3F = 39,
    MathOpCode_MulV4F = 40,
    MathOpCode_MulV2I = 41,
    MathOpCode_MulV3I = 42,
    MathOpCode_MulV4I = 43,
    MathOpCode_MulT = 44,
    MathOpCode_DivI = 45,
    MathOpCode_DivF = 46,
    MathOpCode_DivV2F = 47,
    MathOpCode_DivV3F = 48,
    MathOpCode_DivV4F = 49,
    MathOpCode_DivV2I = 50,
    MathOpCode_DivV3I = 51,
    MathOpCode_DivV4I = 52,
    MathOpCode_ModI = 53,
    MathOpCode_ModF = 54,
    MathOpCode_NegI = 55,
    MathOpCode_NegF = 56,
    MathOpCode_NegV2 = 57,
    MathOpCode_NegV3 = 58,
    MathOpCode_NegV4 = 59,
    MathOpCode_NotB = 60,
    MathOpCode_PowI = 61,
    MathOpCode_PowF = 62,
    MathOpCode_FieldV2 = 63,
    MathOpCode_FieldV3 = 64,
    MathOpCode_FieldV4 = 65,
    MathOpCode_FieldT = 66,
    MathOpCode_Func = 67,
    MathOpCode_Return = 68,
}

pub static MATHOPCODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MathOpCode",
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(MATHOPCODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for MathOpCode {
    fn type_info(&self) -> &'static TypeInfo {
        MATHOPCODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static MATHOPCODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MathOpCode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("MathOpCode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Or4EntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub in1: bool,
    pub in2: bool,
    pub in3: bool,
    pub in4: bool,
}

pub trait Or4EntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn in1(&self) -> &bool;
    fn in2(&self) -> &bool;
    fn in3(&self) -> &bool;
    fn in4(&self) -> &bool;
}

impl Or4EntityDataTrait for Or4EntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn in1(&self) -> &bool {
        &self.in1
    }
    fn in2(&self) -> &bool {
        &self.in2
    }
    fn in3(&self) -> &bool {
        &self.in3
    }
    fn in4(&self) -> &bool {
        &self.in4
    }
}

impl EntityDataTrait for Or4EntityData {
}

impl GameObjectDataTrait for Or4EntityData {
}

impl super::core::DataBusPeerTrait for Or4EntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for Or4EntityData {
}

impl super::core::DataContainerTrait for Or4EntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static OR4ENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Or4EntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Or4EntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(Or4EntityData, realm),
            },
            FieldInfoData {
                name: "In1",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(Or4EntityData, in1),
            },
            FieldInfoData {
                name: "In2",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(Or4EntityData, in2),
            },
            FieldInfoData {
                name: "In3",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(Or4EntityData, in3),
            },
            FieldInfoData {
                name: "In4",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(Or4EntityData, in4),
            },
        ],
    }),
    array_type: Some(OR4ENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for Or4EntityData {
    fn type_info(&self) -> &'static TypeInfo {
        OR4ENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static OR4ENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Or4EntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Or4EntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct XorEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub in1: bool,
    pub in2: bool,
}

pub trait XorEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn in1(&self) -> &bool;
    fn in2(&self) -> &bool;
}

impl XorEntityDataTrait for XorEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn in1(&self) -> &bool {
        &self.in1
    }
    fn in2(&self) -> &bool {
        &self.in2
    }
}

impl EntityDataTrait for XorEntityData {
}

impl GameObjectDataTrait for XorEntityData {
}

impl super::core::DataBusPeerTrait for XorEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for XorEntityData {
}

impl super::core::DataContainerTrait for XorEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static XORENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "XorEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<XorEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(XorEntityData, realm),
            },
            FieldInfoData {
                name: "In1",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(XorEntityData, in1),
            },
            FieldInfoData {
                name: "In2",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(XorEntityData, in2),
            },
        ],
    }),
    array_type: Some(XORENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for XorEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        XORENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static XORENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "XorEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("XorEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct OrEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub input_count: u32,
}

pub trait OrEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn input_count(&self) -> &u32;
}

impl OrEntityDataTrait for OrEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn input_count(&self) -> &u32 {
        &self.input_count
    }
}

impl EntityDataTrait for OrEntityData {
}

impl GameObjectDataTrait for OrEntityData {
}

impl super::core::DataBusPeerTrait for OrEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for OrEntityData {
}

impl super::core::DataContainerTrait for OrEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static ORENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OrEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<OrEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(OrEntityData, realm),
            },
            FieldInfoData {
                name: "InputCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(OrEntityData, input_count),
            },
        ],
    }),
    array_type: Some(ORENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for OrEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        ORENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ORENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OrEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("OrEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BitwiseAndEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub value: i32,
    pub bit_shift_value: bool,
    pub and_value: i32,
    pub bit_shift_and_value: bool,
}

pub trait BitwiseAndEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn value(&self) -> &i32;
    fn bit_shift_value(&self) -> &bool;
    fn and_value(&self) -> &i32;
    fn bit_shift_and_value(&self) -> &bool;
}

impl BitwiseAndEntityDataTrait for BitwiseAndEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn value(&self) -> &i32 {
        &self.value
    }
    fn bit_shift_value(&self) -> &bool {
        &self.bit_shift_value
    }
    fn and_value(&self) -> &i32 {
        &self.and_value
    }
    fn bit_shift_and_value(&self) -> &bool {
        &self.bit_shift_and_value
    }
}

impl EntityDataTrait for BitwiseAndEntityData {
}

impl GameObjectDataTrait for BitwiseAndEntityData {
}

impl super::core::DataBusPeerTrait for BitwiseAndEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for BitwiseAndEntityData {
}

impl super::core::DataContainerTrait for BitwiseAndEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static BITWISEANDENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BitwiseAndEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BitwiseAndEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(BitwiseAndEntityData, realm),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(BitwiseAndEntityData, value),
            },
            FieldInfoData {
                name: "BitShiftValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BitwiseAndEntityData, bit_shift_value),
            },
            FieldInfoData {
                name: "AndValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(BitwiseAndEntityData, and_value),
            },
            FieldInfoData {
                name: "BitShiftAndValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BitwiseAndEntityData, bit_shift_and_value),
            },
        ],
    }),
    array_type: Some(BITWISEANDENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BitwiseAndEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        BITWISEANDENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static BITWISEANDENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BitwiseAndEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("BitwiseAndEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AndEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub input_count: u32,
}

pub trait AndEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn input_count(&self) -> &u32;
}

impl AndEntityDataTrait for AndEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn input_count(&self) -> &u32 {
        &self.input_count
    }
}

impl EntityDataTrait for AndEntityData {
}

impl GameObjectDataTrait for AndEntityData {
}

impl super::core::DataBusPeerTrait for AndEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for AndEntityData {
}

impl super::core::DataContainerTrait for AndEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static ANDENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AndEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AndEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(AndEntityData, realm),
            },
            FieldInfoData {
                name: "InputCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(AndEntityData, input_count),
            },
        ],
    }),
    array_type: Some(ANDENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AndEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        ANDENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ANDENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AndEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("AndEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct NotEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub r#in: bool,
}

pub trait NotEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn r#in(&self) -> &bool;
}

impl NotEntityDataTrait for NotEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn r#in(&self) -> &bool {
        &self.r#in
    }
}

impl EntityDataTrait for NotEntityData {
}

impl GameObjectDataTrait for NotEntityData {
}

impl super::core::DataBusPeerTrait for NotEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for NotEntityData {
}

impl super::core::DataContainerTrait for NotEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static NOTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NotEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<NotEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(NotEntityData, realm),
            },
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(NotEntityData, r#in),
            },
        ],
    }),
    array_type: Some(NOTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for NotEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        NOTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static NOTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NotEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("NotEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CreateSchematicsInstanceEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub asset: Option<Arc<Mutex<dyn super::schematics::SchematicsBaseAssetTrait>>>,
}

pub trait CreateSchematicsInstanceEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn asset(&self) -> &Option<Arc<Mutex<dyn super::schematics::SchematicsBaseAssetTrait>>>;
}

impl CreateSchematicsInstanceEntityDataTrait for CreateSchematicsInstanceEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn asset(&self) -> &Option<Arc<Mutex<dyn super::schematics::SchematicsBaseAssetTrait>>> {
        &self.asset
    }
}

impl EntityDataTrait for CreateSchematicsInstanceEntityData {
}

impl GameObjectDataTrait for CreateSchematicsInstanceEntityData {
}

impl super::core::DataBusPeerTrait for CreateSchematicsInstanceEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for CreateSchematicsInstanceEntityData {
}

impl super::core::DataContainerTrait for CreateSchematicsInstanceEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CREATESCHEMATICSINSTANCEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CreateSchematicsInstanceEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CreateSchematicsInstanceEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(CreateSchematicsInstanceEntityData, realm),
            },
            FieldInfoData {
                name: "Asset",
                flags: MemberInfoFlags::new(0),
                field_type: "SchematicsBaseAsset",
                rust_offset: offset_of!(CreateSchematicsInstanceEntityData, asset),
            },
        ],
    }),
    array_type: Some(CREATESCHEMATICSINSTANCEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CreateSchematicsInstanceEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CREATESCHEMATICSINSTANCEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CREATESCHEMATICSINSTANCEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CreateSchematicsInstanceEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CreateSchematicsInstanceEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GetEntityBusEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
}

pub trait GetEntityBusEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
}

impl GetEntityBusEntityDataTrait for GetEntityBusEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
}

impl EntityDataTrait for GetEntityBusEntityData {
}

impl GameObjectDataTrait for GetEntityBusEntityData {
}

impl super::core::DataBusPeerTrait for GetEntityBusEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for GetEntityBusEntityData {
}

impl super::core::DataContainerTrait for GetEntityBusEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static GETENTITYBUSENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GetEntityBusEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GetEntityBusEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(GetEntityBusEntityData, realm),
            },
        ],
    }),
    array_type: Some(GETENTITYBUSENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for GetEntityBusEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        GETENTITYBUSENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static GETENTITYBUSENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GetEntityBusEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("GetEntityBusEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GetEntityEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub runtime_type: glacier_reflect::builtin::TypeRef,
}

pub trait GetEntityEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn runtime_type(&self) -> &glacier_reflect::builtin::TypeRef;
}

impl GetEntityEntityDataTrait for GetEntityEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn runtime_type(&self) -> &glacier_reflect::builtin::TypeRef {
        &self.runtime_type
    }
}

impl EntityDataTrait for GetEntityEntityData {
}

impl GameObjectDataTrait for GetEntityEntityData {
}

impl super::core::DataBusPeerTrait for GetEntityEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for GetEntityEntityData {
}

impl super::core::DataContainerTrait for GetEntityEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static GETENTITYENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GetEntityEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GetEntityEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(GetEntityEntityData, realm),
            },
            FieldInfoData {
                name: "RuntimeType",
                flags: MemberInfoFlags::new(0),
                field_type: "TypeRef",
                rust_offset: offset_of!(GetEntityEntityData, runtime_type),
            },
        ],
    }),
    array_type: Some(GETENTITYENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for GetEntityEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        GETENTITYENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static GETENTITYENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GetEntityEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("GetEntityEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CallFunctionEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub function_type: glacier_reflect::builtin::TypeRef,
}

pub trait CallFunctionEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn function_type(&self) -> &glacier_reflect::builtin::TypeRef;
}

impl CallFunctionEntityDataTrait for CallFunctionEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn function_type(&self) -> &glacier_reflect::builtin::TypeRef {
        &self.function_type
    }
}

impl EntityDataTrait for CallFunctionEntityData {
}

impl GameObjectDataTrait for CallFunctionEntityData {
}

impl super::core::DataBusPeerTrait for CallFunctionEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for CallFunctionEntityData {
}

impl super::core::DataContainerTrait for CallFunctionEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static CALLFUNCTIONENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CallFunctionEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CallFunctionEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(CallFunctionEntityData, realm),
            },
            FieldInfoData {
                name: "FunctionType",
                flags: MemberInfoFlags::new(0),
                field_type: "TypeRef",
                rust_offset: offset_of!(CallFunctionEntityData, function_type),
            },
        ],
    }),
    array_type: Some(CALLFUNCTIONENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CallFunctionEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CALLFUNCTIONENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CALLFUNCTIONENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CallFunctionEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CallFunctionEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EntityOwnerUid {
    pub id: u32,
}

pub trait EntityOwnerUidTrait: TypeObject {
    fn id(&self) -> &u32;
}

impl EntityOwnerUidTrait for EntityOwnerUid {
    fn id(&self) -> &u32 {
        &self.id
    }
}

pub static ENTITYOWNERUID_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityOwnerUid",
    flags: MemberInfoFlags::new(36937),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EntityOwnerUid as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Id",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(EntityOwnerUid, id),
            },
        ],
    }),
    array_type: Some(ENTITYOWNERUID_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for EntityOwnerUid {
    fn type_info(&self) -> &'static TypeInfo {
        ENTITYOWNERUID_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ENTITYOWNERUID_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityOwnerUid-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EntityOwnerUid"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EntityUid {
    pub id: u32,
}

pub trait EntityUidTrait: TypeObject {
    fn id(&self) -> &u32;
}

impl EntityUidTrait for EntityUid {
    fn id(&self) -> &u32 {
        &self.id
    }
}

pub static ENTITYUID_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityUid",
    flags: MemberInfoFlags::new(36937),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EntityUid as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Id",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(EntityUid, id),
            },
        ],
    }),
    array_type: Some(ENTITYUID_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for EntityUid {
    fn type_info(&self) -> &'static TypeInfo {
        ENTITYUID_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ENTITYUID_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityUid-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EntityUid"),
    array_type: None,
    alignment: 8,
};



pub static SETTRANSFORMSPACELOCALTRANSFORM_ENTITYTRANSFORMSPACE_LINEARTRANSFORM__TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SetTransformSpaceLocalTransform(EntityTransformSpace,LinearTransform)",
    flags: MemberInfoFlags::new(793),
    module: "Entity",
    data: TypeInfoData::Unknown,
    array_type: None,
    alignment: 8,
};



pub static GETTRANSFORMSPACE_ENTITYTRANSFORMSPACE_ENTITY__TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GetTransformSpace(EntityTransformSpace,Entity)",
    flags: MemberInfoFlags::new(793),
    module: "Entity",
    data: TypeInfoData::Unknown,
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum TransformSpaceChildControlSetting {
    #[default]
    TransformSpaceChildControlSetting_NoChildControl = 0,
    TransformSpaceChildControlSetting_ControlChildren = 1,
    TransformSpaceChildControlSetting_ControlChildrenAndLockTransforms = 2,
    TransformSpaceChildControlSetting_ControlDescendents = 3,
}

pub static TRANSFORMSPACECHILDCONTROLSETTING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformSpaceChildControlSetting",
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(TRANSFORMSPACECHILDCONTROLSETTING_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for TransformSpaceChildControlSetting {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMSPACECHILDCONTROLSETTING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static TRANSFORMSPACECHILDCONTROLSETTING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformSpaceChildControlSetting-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TransformSpaceChildControlSetting"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum TransformSpaceSimulationSetting {
    #[default]
    TransformSpaceSimulationSetting_Default = 0,
    TransformSpaceSimulationSetting_Keyframed = 1,
}

pub static TRANSFORMSPACESIMULATIONSETTING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformSpaceSimulationSetting",
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(TRANSFORMSPACESIMULATIONSETTING_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for TransformSpaceSimulationSetting {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMSPACESIMULATIONSETTING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static TRANSFORMSPACESIMULATIONSETTING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformSpaceSimulationSetting-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TransformSpaceSimulationSetting"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EntitySettings {
    pub _glacier_base: super::core::SystemSettings,
    pub editor_game_view_enable: bool,
    pub spawn_sub_levels_from_logic: bool,
    pub execution_mode: ExecutionModeType,
    pub out_of_entity_bus_network_id_threshold: u32,
    pub world_limit: f32,
    pub destroy_queued_entities_time: f32,
    pub sub_level_manager_create_sublevels_time: f32,
    pub sub_level_manager_destroy_sublevels_time: f32,
}

pub trait EntitySettingsTrait: super::core::SystemSettingsTrait {
    fn editor_game_view_enable(&self) -> &bool;
    fn spawn_sub_levels_from_logic(&self) -> &bool;
    fn execution_mode(&self) -> &ExecutionModeType;
    fn out_of_entity_bus_network_id_threshold(&self) -> &u32;
    fn world_limit(&self) -> &f32;
    fn destroy_queued_entities_time(&self) -> &f32;
    fn sub_level_manager_create_sublevels_time(&self) -> &f32;
    fn sub_level_manager_destroy_sublevels_time(&self) -> &f32;
}

impl EntitySettingsTrait for EntitySettings {
    fn editor_game_view_enable(&self) -> &bool {
        &self.editor_game_view_enable
    }
    fn spawn_sub_levels_from_logic(&self) -> &bool {
        &self.spawn_sub_levels_from_logic
    }
    fn execution_mode(&self) -> &ExecutionModeType {
        &self.execution_mode
    }
    fn out_of_entity_bus_network_id_threshold(&self) -> &u32 {
        &self.out_of_entity_bus_network_id_threshold
    }
    fn world_limit(&self) -> &f32 {
        &self.world_limit
    }
    fn destroy_queued_entities_time(&self) -> &f32 {
        &self.destroy_queued_entities_time
    }
    fn sub_level_manager_create_sublevels_time(&self) -> &f32 {
        &self.sub_level_manager_create_sublevels_time
    }
    fn sub_level_manager_destroy_sublevels_time(&self) -> &f32 {
        &self.sub_level_manager_destroy_sublevels_time
    }
}

impl super::core::SystemSettingsTrait for EntitySettings {
    fn platform(&self) -> &super::core::GamePlatform {
        self._glacier_base.platform()
    }
}

impl super::core::DataContainerTrait for EntitySettings {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static ENTITYSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntitySettings",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::SYSTEMSETTINGS_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EntitySettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "EditorGameViewEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EntitySettings, editor_game_view_enable),
            },
            FieldInfoData {
                name: "SpawnSubLevelsFromLogic",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EntitySettings, spawn_sub_levels_from_logic),
            },
            FieldInfoData {
                name: "ExecutionMode",
                flags: MemberInfoFlags::new(0),
                field_type: "ExecutionModeType",
                rust_offset: offset_of!(EntitySettings, execution_mode),
            },
            FieldInfoData {
                name: "OutOfEntityBusNetworkIdThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(EntitySettings, out_of_entity_bus_network_id_threshold),
            },
            FieldInfoData {
                name: "WorldLimit",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EntitySettings, world_limit),
            },
            FieldInfoData {
                name: "DestroyQueuedEntitiesTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EntitySettings, destroy_queued_entities_time),
            },
            FieldInfoData {
                name: "SubLevelManagerCreateSublevelsTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EntitySettings, sub_level_manager_create_sublevels_time),
            },
            FieldInfoData {
                name: "SubLevelManagerDestroySublevelsTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EntitySettings, sub_level_manager_destroy_sublevels_time),
            },
        ],
    }),
    array_type: Some(ENTITYSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EntitySettings {
    fn type_info(&self) -> &'static TypeInfo {
        ENTITYSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ENTITYSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntitySettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EntitySettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum ExecutionModeType {
    #[default]
    ExecutionMode_Play = 0,
    ExecutionMode_GameView = 1,
    ExecutionMode_PlayFromHere = 2,
    ExecutionMode_FrostEdPlay = 3,
}

pub static EXECUTIONMODETYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExecutionModeType",
    flags: MemberInfoFlags::new(49429),
    module: "Entity",
    data: TypeInfoData::Enum,
    array_type: Some(EXECUTIONMODETYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for ExecutionModeType {
    fn type_info(&self) -> &'static TypeInfo {
        EXECUTIONMODETYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static EXECUTIONMODETYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExecutionModeType-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ExecutionModeType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SwitchEnumEntity {
    pub _glacier_base: EnumLogicEntityWithSingleInput,
}

pub trait SwitchEnumEntityTrait: EnumLogicEntityWithSingleInputTrait {
}

impl SwitchEnumEntityTrait for SwitchEnumEntity {
}

impl EnumLogicEntityWithSingleInputTrait for SwitchEnumEntity {
}

impl EntityTrait for SwitchEnumEntity {
}

impl EntityBusPeerTrait for SwitchEnumEntity {
}

pub static SWITCHENUMENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SwitchEnumEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENUMLOGICENTITYWITHSINGLEINPUT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SwitchEnumEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SWITCHENUMENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SwitchEnumEntity {
    fn type_info(&self) -> &'static TypeInfo {
        SWITCHENUMENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SWITCHENUMENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SwitchEnumEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SwitchEnumEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SetEnumEntity {
    pub _glacier_base: EnumLogicEntityWithSingleInput,
}

pub trait SetEnumEntityTrait: EnumLogicEntityWithSingleInputTrait {
}

impl SetEnumEntityTrait for SetEnumEntity {
}

impl EnumLogicEntityWithSingleInputTrait for SetEnumEntity {
}

impl EntityTrait for SetEnumEntity {
}

impl EntityBusPeerTrait for SetEnumEntity {
}

pub static SETENUMENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SetEnumEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENUMLOGICENTITYWITHSINGLEINPUT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SetEnumEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SETENUMENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SetEnumEntity {
    fn type_info(&self) -> &'static TypeInfo {
        SETENUMENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SETENUMENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SetEnumEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SetEnumEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct IntToEnumEntity {
    pub _glacier_base: Entity,
}

pub trait IntToEnumEntityTrait: EntityTrait {
}

impl IntToEnumEntityTrait for IntToEnumEntity {
}

impl EntityTrait for IntToEnumEntity {
}

impl EntityBusPeerTrait for IntToEnumEntity {
}

pub static INTTOENUMENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntToEnumEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<IntToEnumEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(INTTOENUMENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for IntToEnumEntity {
    fn type_info(&self) -> &'static TypeInfo {
        INTTOENUMENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static INTTOENUMENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntToEnumEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("IntToEnumEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EnumToStringEntity {
    pub _glacier_base: EnumLogicEntityWithSingleInput,
}

pub trait EnumToStringEntityTrait: EnumLogicEntityWithSingleInputTrait {
}

impl EnumToStringEntityTrait for EnumToStringEntity {
}

impl EnumLogicEntityWithSingleInputTrait for EnumToStringEntity {
}

impl EntityTrait for EnumToStringEntity {
}

impl EntityBusPeerTrait for EnumToStringEntity {
}

pub static ENUMTOSTRINGENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnumToStringEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENUMLOGICENTITYWITHSINGLEINPUT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EnumToStringEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(ENUMTOSTRINGENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for EnumToStringEntity {
    fn type_info(&self) -> &'static TypeInfo {
        ENUMTOSTRINGENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ENUMTOSTRINGENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnumToStringEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EnumToStringEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EnumToIntEntity {
    pub _glacier_base: EnumLogicEntityWithSingleInput,
}

pub trait EnumToIntEntityTrait: EnumLogicEntityWithSingleInputTrait {
}

impl EnumToIntEntityTrait for EnumToIntEntity {
}

impl EnumLogicEntityWithSingleInputTrait for EnumToIntEntity {
}

impl EntityTrait for EnumToIntEntity {
}

impl EntityBusPeerTrait for EnumToIntEntity {
}

pub static ENUMTOINTENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnumToIntEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENUMLOGICENTITYWITHSINGLEINPUT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EnumToIntEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(ENUMTOINTENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for EnumToIntEntity {
    fn type_info(&self) -> &'static TypeInfo {
        ENUMTOINTENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ENUMTOINTENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnumToIntEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EnumToIntEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EnumPropertyGateEntity {
    pub _glacier_base: EnumLogicEntityWithSingleInput,
}

pub trait EnumPropertyGateEntityTrait: EnumLogicEntityWithSingleInputTrait {
}

impl EnumPropertyGateEntityTrait for EnumPropertyGateEntity {
}

impl EnumLogicEntityWithSingleInputTrait for EnumPropertyGateEntity {
}

impl EntityTrait for EnumPropertyGateEntity {
}

impl EntityBusPeerTrait for EnumPropertyGateEntity {
}

pub static ENUMPROPERTYGATEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnumPropertyGateEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENUMLOGICENTITYWITHSINGLEINPUT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EnumPropertyGateEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(ENUMPROPERTYGATEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for EnumPropertyGateEntity {
    fn type_info(&self) -> &'static TypeInfo {
        ENUMPROPERTYGATEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ENUMPROPERTYGATEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnumPropertyGateEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EnumPropertyGateEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EnumLogicEntityWithSingleInput {
    pub _glacier_base: Entity,
}

pub trait EnumLogicEntityWithSingleInputTrait: EntityTrait {
}

impl EnumLogicEntityWithSingleInputTrait for EnumLogicEntityWithSingleInput {
}

impl EntityTrait for EnumLogicEntityWithSingleInput {
}

impl EntityBusPeerTrait for EnumLogicEntityWithSingleInput {
}

pub static ENUMLOGICENTITYWITHSINGLEINPUT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnumLogicEntityWithSingleInput",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EnumLogicEntityWithSingleInput as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(ENUMLOGICENTITYWITHSINGLEINPUT_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for EnumLogicEntityWithSingleInput {
    fn type_info(&self) -> &'static TypeInfo {
        ENUMLOGICENTITYWITHSINGLEINPUT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ENUMLOGICENTITYWITHSINGLEINPUT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnumLogicEntityWithSingleInput-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EnumLogicEntityWithSingleInput"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EnumIntSourceEntity {
    pub _glacier_base: Entity,
}

pub trait EnumIntSourceEntityTrait: EntityTrait {
}

impl EnumIntSourceEntityTrait for EnumIntSourceEntity {
}

impl EntityTrait for EnumIntSourceEntity {
}

impl EntityBusPeerTrait for EnumIntSourceEntity {
}

pub static ENUMINTSOURCEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnumIntSourceEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EnumIntSourceEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(ENUMINTSOURCEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for EnumIntSourceEntity {
    fn type_info(&self) -> &'static TypeInfo {
        ENUMINTSOURCEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ENUMINTSOURCEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnumIntSourceEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EnumIntSourceEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CompareEnumEntity {
    pub _glacier_base: Entity,
}

pub trait CompareEnumEntityTrait: EntityTrait {
}

impl CompareEnumEntityTrait for CompareEnumEntity {
}

impl EntityTrait for CompareEnumEntity {
}

impl EntityBusPeerTrait for CompareEnumEntity {
}

pub static COMPAREENUMENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareEnumEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareEnumEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(COMPAREENUMENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for CompareEnumEntity {
    fn type_info(&self) -> &'static TypeInfo {
        COMPAREENUMENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static COMPAREENUMENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareEnumEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareEnumEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EntityBusPeer {
}

pub trait EntityBusPeerTrait: TypeObject {
}

impl EntityBusPeerTrait for EntityBusPeer {
}

pub static ENTITYBUSPEER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityBusPeer",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: None,
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EntityBusPeer as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(ENTITYBUSPEER_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for EntityBusPeer {
    fn type_info(&self) -> &'static TypeInfo {
        ENTITYBUSPEER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ENTITYBUSPEER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityBusPeer-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EntityBusPeer"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EntityEvent {
}

pub trait EntityEventTrait: TypeObject {
}

impl EntityEventTrait for EntityEvent {
}

pub static ENTITYEVENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityEvent",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: None,
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EntityEvent as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(ENTITYEVENT_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for EntityEvent {
    fn type_info(&self) -> &'static TypeInfo {
        ENTITYEVENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ENTITYEVENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityEvent-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EntityEvent"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EntityBus {
}

pub trait EntityBusTrait: TypeObject {
}

impl EntityBusTrait for EntityBus {
}

pub static ENTITYBUS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityBus",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: None,
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EntityBus as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(ENTITYBUS_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for EntityBus {
    fn type_info(&self) -> &'static TypeInfo {
        ENTITYBUS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ENTITYBUS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityBus-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EntityBus"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DataSourceQueryEntity {
    pub _glacier_base: Entity,
}

pub trait DataSourceQueryEntityTrait: EntityTrait {
}

impl DataSourceQueryEntityTrait for DataSourceQueryEntity {
}

impl EntityTrait for DataSourceQueryEntity {
}

impl EntityBusPeerTrait for DataSourceQueryEntity {
}

pub static DATASOURCEQUERYENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DataSourceQueryEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DataSourceQueryEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(DATASOURCEQUERYENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for DataSourceQueryEntity {
    fn type_info(&self) -> &'static TypeInfo {
        DATASOURCEQUERYENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static DATASOURCEQUERYENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DataSourceQueryEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("DataSourceQueryEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EnumToStringData {
    pub _glacier_base: ImpliedEnumTypeLogicEntityData,
}

pub trait EnumToStringDataTrait: ImpliedEnumTypeLogicEntityDataTrait {
}

impl EnumToStringDataTrait for EnumToStringData {
}

impl ImpliedEnumTypeLogicEntityDataTrait for EnumToStringData {
}

impl EnumLogicEntityBaseDataTrait for EnumToStringData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn type_name_hash(&self) -> &u32 {
        self._glacier_base.type_name_hash()
    }
}

impl EntityDataTrait for EnumToStringData {
}

impl GameObjectDataTrait for EnumToStringData {
}

impl super::core::DataBusPeerTrait for EnumToStringData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for EnumToStringData {
}

impl super::core::DataContainerTrait for EnumToStringData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static ENUMTOSTRINGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnumToStringData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(IMPLIEDENUMTYPELOGICENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EnumToStringData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(ENUMTOSTRINGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EnumToStringData {
    fn type_info(&self) -> &'static TypeInfo {
        ENUMTOSTRINGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ENUMTOSTRINGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnumToStringData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EnumToStringData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EnumToIntData {
    pub _glacier_base: ImpliedEnumTypeLogicEntityData,
}

pub trait EnumToIntDataTrait: ImpliedEnumTypeLogicEntityDataTrait {
}

impl EnumToIntDataTrait for EnumToIntData {
}

impl ImpliedEnumTypeLogicEntityDataTrait for EnumToIntData {
}

impl EnumLogicEntityBaseDataTrait for EnumToIntData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn type_name_hash(&self) -> &u32 {
        self._glacier_base.type_name_hash()
    }
}

impl EntityDataTrait for EnumToIntData {
}

impl GameObjectDataTrait for EnumToIntData {
}

impl super::core::DataBusPeerTrait for EnumToIntData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for EnumToIntData {
}

impl super::core::DataContainerTrait for EnumToIntData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static ENUMTOINTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnumToIntData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(IMPLIEDENUMTYPELOGICENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EnumToIntData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(ENUMTOINTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EnumToIntData {
    fn type_info(&self) -> &'static TypeInfo {
        ENUMTOINTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ENUMTOINTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnumToIntData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EnumToIntData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EnumPropertyGateEntityData {
    pub _glacier_base: ImpliedEnumTypeLogicEntityData,
    pub default: bool,
    pub write_property_on_open_gate: bool,
}

pub trait EnumPropertyGateEntityDataTrait: ImpliedEnumTypeLogicEntityDataTrait {
    fn default(&self) -> &bool;
    fn write_property_on_open_gate(&self) -> &bool;
}

impl EnumPropertyGateEntityDataTrait for EnumPropertyGateEntityData {
    fn default(&self) -> &bool {
        &self.default
    }
    fn write_property_on_open_gate(&self) -> &bool {
        &self.write_property_on_open_gate
    }
}

impl ImpliedEnumTypeLogicEntityDataTrait for EnumPropertyGateEntityData {
}

impl EnumLogicEntityBaseDataTrait for EnumPropertyGateEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn type_name_hash(&self) -> &u32 {
        self._glacier_base.type_name_hash()
    }
}

impl EntityDataTrait for EnumPropertyGateEntityData {
}

impl GameObjectDataTrait for EnumPropertyGateEntityData {
}

impl super::core::DataBusPeerTrait for EnumPropertyGateEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for EnumPropertyGateEntityData {
}

impl super::core::DataContainerTrait for EnumPropertyGateEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static ENUMPROPERTYGATEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnumPropertyGateEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(IMPLIEDENUMTYPELOGICENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EnumPropertyGateEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Default",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EnumPropertyGateEntityData, default),
            },
            FieldInfoData {
                name: "WritePropertyOnOpenGate",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EnumPropertyGateEntityData, write_property_on_open_gate),
            },
        ],
    }),
    array_type: Some(ENUMPROPERTYGATEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EnumPropertyGateEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        ENUMPROPERTYGATEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ENUMPROPERTYGATEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnumPropertyGateEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EnumPropertyGateEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EnumDebugEntityData {
    pub _glacier_base: ImpliedEnumTypeLogicEntityData,
    pub text_color: super::core::Vec3,
    pub screen_position: super::core::Vec2,
    pub world_position: super::core::Vec3,
    pub value_prefix: String,
    pub multiline: bool,
    pub show_transform_in_world: bool,
    pub show_transform_coordinates: bool,
    pub default_visible: bool,
    pub text_scale: f32,
}

pub trait EnumDebugEntityDataTrait: ImpliedEnumTypeLogicEntityDataTrait {
    fn text_color(&self) -> &super::core::Vec3;
    fn screen_position(&self) -> &super::core::Vec2;
    fn world_position(&self) -> &super::core::Vec3;
    fn value_prefix(&self) -> &String;
    fn multiline(&self) -> &bool;
    fn show_transform_in_world(&self) -> &bool;
    fn show_transform_coordinates(&self) -> &bool;
    fn default_visible(&self) -> &bool;
    fn text_scale(&self) -> &f32;
}

impl EnumDebugEntityDataTrait for EnumDebugEntityData {
    fn text_color(&self) -> &super::core::Vec3 {
        &self.text_color
    }
    fn screen_position(&self) -> &super::core::Vec2 {
        &self.screen_position
    }
    fn world_position(&self) -> &super::core::Vec3 {
        &self.world_position
    }
    fn value_prefix(&self) -> &String {
        &self.value_prefix
    }
    fn multiline(&self) -> &bool {
        &self.multiline
    }
    fn show_transform_in_world(&self) -> &bool {
        &self.show_transform_in_world
    }
    fn show_transform_coordinates(&self) -> &bool {
        &self.show_transform_coordinates
    }
    fn default_visible(&self) -> &bool {
        &self.default_visible
    }
    fn text_scale(&self) -> &f32 {
        &self.text_scale
    }
}

impl ImpliedEnumTypeLogicEntityDataTrait for EnumDebugEntityData {
}

impl EnumLogicEntityBaseDataTrait for EnumDebugEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn type_name_hash(&self) -> &u32 {
        self._glacier_base.type_name_hash()
    }
}

impl EntityDataTrait for EnumDebugEntityData {
}

impl GameObjectDataTrait for EnumDebugEntityData {
}

impl super::core::DataBusPeerTrait for EnumDebugEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for EnumDebugEntityData {
}

impl super::core::DataContainerTrait for EnumDebugEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static ENUMDEBUGENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnumDebugEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(IMPLIEDENUMTYPELOGICENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EnumDebugEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "TextColor",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(EnumDebugEntityData, text_color),
            },
            FieldInfoData {
                name: "ScreenPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(EnumDebugEntityData, screen_position),
            },
            FieldInfoData {
                name: "WorldPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(EnumDebugEntityData, world_position),
            },
            FieldInfoData {
                name: "ValuePrefix",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(EnumDebugEntityData, value_prefix),
            },
            FieldInfoData {
                name: "Multiline",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EnumDebugEntityData, multiline),
            },
            FieldInfoData {
                name: "ShowTransformInWorld",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EnumDebugEntityData, show_transform_in_world),
            },
            FieldInfoData {
                name: "ShowTransformCoordinates",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EnumDebugEntityData, show_transform_coordinates),
            },
            FieldInfoData {
                name: "DefaultVisible",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EnumDebugEntityData, default_visible),
            },
            FieldInfoData {
                name: "TextScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EnumDebugEntityData, text_scale),
            },
        ],
    }),
    array_type: Some(ENUMDEBUGENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for EnumDebugEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        ENUMDEBUGENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ENUMDEBUGENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnumDebugEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EnumDebugEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ImpliedEnumTypeLogicEntityData {
    pub _glacier_base: EnumLogicEntityBaseData,
}

pub trait ImpliedEnumTypeLogicEntityDataTrait: EnumLogicEntityBaseDataTrait {
}

impl ImpliedEnumTypeLogicEntityDataTrait for ImpliedEnumTypeLogicEntityData {
}

impl EnumLogicEntityBaseDataTrait for ImpliedEnumTypeLogicEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn type_name_hash(&self) -> &u32 {
        self._glacier_base.type_name_hash()
    }
}

impl EntityDataTrait for ImpliedEnumTypeLogicEntityData {
}

impl GameObjectDataTrait for ImpliedEnumTypeLogicEntityData {
}

impl super::core::DataBusPeerTrait for ImpliedEnumTypeLogicEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for ImpliedEnumTypeLogicEntityData {
}

impl super::core::DataContainerTrait for ImpliedEnumTypeLogicEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static IMPLIEDENUMTYPELOGICENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ImpliedEnumTypeLogicEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENUMLOGICENTITYBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ImpliedEnumTypeLogicEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(IMPLIEDENUMTYPELOGICENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ImpliedEnumTypeLogicEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        IMPLIEDENUMTYPELOGICENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static IMPLIEDENUMTYPELOGICENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ImpliedEnumTypeLogicEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ImpliedEnumTypeLogicEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ExplicitEnumTypeLogicEntityData {
    pub _glacier_base: EnumLogicEntityBaseData,
}

pub trait ExplicitEnumTypeLogicEntityDataTrait: EnumLogicEntityBaseDataTrait {
}

impl ExplicitEnumTypeLogicEntityDataTrait for ExplicitEnumTypeLogicEntityData {
}

impl EnumLogicEntityBaseDataTrait for ExplicitEnumTypeLogicEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn type_name_hash(&self) -> &u32 {
        self._glacier_base.type_name_hash()
    }
}

impl EntityDataTrait for ExplicitEnumTypeLogicEntityData {
}

impl GameObjectDataTrait for ExplicitEnumTypeLogicEntityData {
}

impl super::core::DataBusPeerTrait for ExplicitEnumTypeLogicEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for ExplicitEnumTypeLogicEntityData {
}

impl super::core::DataContainerTrait for ExplicitEnumTypeLogicEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static EXPLICITENUMTYPELOGICENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExplicitEnumTypeLogicEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENUMLOGICENTITYBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ExplicitEnumTypeLogicEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(EXPLICITENUMTYPELOGICENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ExplicitEnumTypeLogicEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        EXPLICITENUMTYPELOGICENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static EXPLICITENUMTYPELOGICENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExplicitEnumTypeLogicEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ExplicitEnumTypeLogicEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EnumLogicEntityBaseData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub type_name_hash: u32,
}

pub trait EnumLogicEntityBaseDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn type_name_hash(&self) -> &u32;
}

impl EnumLogicEntityBaseDataTrait for EnumLogicEntityBaseData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn type_name_hash(&self) -> &u32 {
        &self.type_name_hash
    }
}

impl EntityDataTrait for EnumLogicEntityBaseData {
}

impl GameObjectDataTrait for EnumLogicEntityBaseData {
}

impl super::core::DataBusPeerTrait for EnumLogicEntityBaseData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for EnumLogicEntityBaseData {
}

impl super::core::DataContainerTrait for EnumLogicEntityBaseData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static ENUMLOGICENTITYBASEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnumLogicEntityBaseData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EnumLogicEntityBaseData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(EnumLogicEntityBaseData, realm),
            },
            FieldInfoData {
                name: "TypeNameHash",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(EnumLogicEntityBaseData, type_name_hash),
            },
        ],
    }),
    array_type: Some(ENUMLOGICENTITYBASEDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for EnumLogicEntityBaseData {
    fn type_info(&self) -> &'static TypeInfo {
        ENUMLOGICENTITYBASEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ENUMLOGICENTITYBASEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnumLogicEntityBaseData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EnumLogicEntityBaseData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EnumIntSourceEntityData {
    pub _glacier_base: ExplicitEnumTypeLogicEntityData,
    pub enum_int_output_properties: Vec<EnumIntSourceProperty>,
}

pub trait EnumIntSourceEntityDataTrait: ExplicitEnumTypeLogicEntityDataTrait {
    fn enum_int_output_properties(&self) -> &Vec<EnumIntSourceProperty>;
}

impl EnumIntSourceEntityDataTrait for EnumIntSourceEntityData {
    fn enum_int_output_properties(&self) -> &Vec<EnumIntSourceProperty> {
        &self.enum_int_output_properties
    }
}

impl ExplicitEnumTypeLogicEntityDataTrait for EnumIntSourceEntityData {
}

impl EnumLogicEntityBaseDataTrait for EnumIntSourceEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn type_name_hash(&self) -> &u32 {
        self._glacier_base.type_name_hash()
    }
}

impl EntityDataTrait for EnumIntSourceEntityData {
}

impl GameObjectDataTrait for EnumIntSourceEntityData {
}

impl super::core::DataBusPeerTrait for EnumIntSourceEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for EnumIntSourceEntityData {
}

impl super::core::DataContainerTrait for EnumIntSourceEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static ENUMINTSOURCEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnumIntSourceEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(EXPLICITENUMTYPELOGICENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EnumIntSourceEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "EnumIntOutputProperties",
                flags: MemberInfoFlags::new(144),
                field_type: "EnumIntSourceProperty-Array",
                rust_offset: offset_of!(EnumIntSourceEntityData, enum_int_output_properties),
            },
        ],
    }),
    array_type: Some(ENUMINTSOURCEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EnumIntSourceEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        ENUMINTSOURCEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ENUMINTSOURCEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnumIntSourceEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EnumIntSourceEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EnumIntSourceProperty {
    pub enum_value: i32,
    pub output_property_hash: u32,
}

pub trait EnumIntSourcePropertyTrait: TypeObject {
    fn enum_value(&self) -> &i32;
    fn output_property_hash(&self) -> &u32;
}

impl EnumIntSourcePropertyTrait for EnumIntSourceProperty {
    fn enum_value(&self) -> &i32 {
        &self.enum_value
    }
    fn output_property_hash(&self) -> &u32 {
        &self.output_property_hash
    }
}

pub static ENUMINTSOURCEPROPERTY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnumIntSourceProperty",
    flags: MemberInfoFlags::new(36937),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EnumIntSourceProperty as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "EnumValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(EnumIntSourceProperty, enum_value),
            },
            FieldInfoData {
                name: "OutputPropertyHash",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(EnumIntSourceProperty, output_property_hash),
            },
        ],
    }),
    array_type: Some(ENUMINTSOURCEPROPERTY_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for EnumIntSourceProperty {
    fn type_info(&self) -> &'static TypeInfo {
        ENUMINTSOURCEPROPERTY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ENUMINTSOURCEPROPERTY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnumIntSourceProperty-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EnumIntSourceProperty"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CompareEnumEntityData {
    pub _glacier_base: ImpliedEnumTypeLogicEntityData,
    pub trigger_on_property_change: bool,
    pub trigger_on_start: bool,
    pub always_send: bool,
    pub enum_default_value: i32,
}

pub trait CompareEnumEntityDataTrait: ImpliedEnumTypeLogicEntityDataTrait {
    fn trigger_on_property_change(&self) -> &bool;
    fn trigger_on_start(&self) -> &bool;
    fn always_send(&self) -> &bool;
    fn enum_default_value(&self) -> &i32;
}

impl CompareEnumEntityDataTrait for CompareEnumEntityData {
    fn trigger_on_property_change(&self) -> &bool {
        &self.trigger_on_property_change
    }
    fn trigger_on_start(&self) -> &bool {
        &self.trigger_on_start
    }
    fn always_send(&self) -> &bool {
        &self.always_send
    }
    fn enum_default_value(&self) -> &i32 {
        &self.enum_default_value
    }
}

impl ImpliedEnumTypeLogicEntityDataTrait for CompareEnumEntityData {
}

impl EnumLogicEntityBaseDataTrait for CompareEnumEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn type_name_hash(&self) -> &u32 {
        self._glacier_base.type_name_hash()
    }
}

impl EntityDataTrait for CompareEnumEntityData {
}

impl GameObjectDataTrait for CompareEnumEntityData {
}

impl super::core::DataBusPeerTrait for CompareEnumEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for CompareEnumEntityData {
}

impl super::core::DataContainerTrait for CompareEnumEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static COMPAREENUMENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareEnumEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(IMPLIEDENUMTYPELOGICENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareEnumEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "TriggerOnPropertyChange",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CompareEnumEntityData, trigger_on_property_change),
            },
            FieldInfoData {
                name: "TriggerOnStart",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CompareEnumEntityData, trigger_on_start),
            },
            FieldInfoData {
                name: "AlwaysSend",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CompareEnumEntityData, always_send),
            },
            FieldInfoData {
                name: "EnumDefaultValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CompareEnumEntityData, enum_default_value),
            },
        ],
    }),
    array_type: Some(COMPAREENUMENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CompareEnumEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        COMPAREENUMENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static COMPAREENUMENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareEnumEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareEnumEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DataSourceQueryEntityData {
    pub _glacier_base: EntityData,
    pub realm: super::core::Realm,
    pub in_data: Option<Arc<Mutex<dyn super::core::DataContainerTrait>>>,
    pub array_index: i32,
}

pub trait DataSourceQueryEntityDataTrait: EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn in_data(&self) -> &Option<Arc<Mutex<dyn super::core::DataContainerTrait>>>;
    fn array_index(&self) -> &i32;
}

impl DataSourceQueryEntityDataTrait for DataSourceQueryEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn in_data(&self) -> &Option<Arc<Mutex<dyn super::core::DataContainerTrait>>> {
        &self.in_data
    }
    fn array_index(&self) -> &i32 {
        &self.array_index
    }
}

impl EntityDataTrait for DataSourceQueryEntityData {
}

impl GameObjectDataTrait for DataSourceQueryEntityData {
}

impl super::core::DataBusPeerTrait for DataSourceQueryEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
}

impl super::core::GameDataContainerTrait for DataSourceQueryEntityData {
}

impl super::core::DataContainerTrait for DataSourceQueryEntityData {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static DATASOURCEQUERYENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DataSourceQueryEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DataSourceQueryEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(DataSourceQueryEntityData, realm),
            },
            FieldInfoData {
                name: "InData",
                flags: MemberInfoFlags::new(0),
                field_type: "DataContainer",
                rust_offset: offset_of!(DataSourceQueryEntityData, in_data),
            },
            FieldInfoData {
                name: "ArrayIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(DataSourceQueryEntityData, array_index),
            },
        ],
    }),
    array_type: Some(DATASOURCEQUERYENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DataSourceQueryEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        DATASOURCEQUERYENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static DATASOURCEQUERYENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DataSourceQueryEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("DataSourceQueryEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DataSourceQueryFieldDefinition {
    pub name: String,
    pub type_name_hash: u32,
    pub is_array: bool,
    pub editor_property_type: String,
}

pub trait DataSourceQueryFieldDefinitionTrait: TypeObject {
    fn name(&self) -> &String;
    fn type_name_hash(&self) -> &u32;
    fn is_array(&self) -> &bool;
    fn editor_property_type(&self) -> &String;
}

impl DataSourceQueryFieldDefinitionTrait for DataSourceQueryFieldDefinition {
    fn name(&self) -> &String {
        &self.name
    }
    fn type_name_hash(&self) -> &u32 {
        &self.type_name_hash
    }
    fn is_array(&self) -> &bool {
        &self.is_array
    }
    fn editor_property_type(&self) -> &String {
        &self.editor_property_type
    }
}

pub static DATASOURCEQUERYFIELDDEFINITION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DataSourceQueryFieldDefinition",
    flags: MemberInfoFlags::new(73),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DataSourceQueryFieldDefinition as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(DataSourceQueryFieldDefinition, name),
            },
            FieldInfoData {
                name: "TypeNameHash",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(DataSourceQueryFieldDefinition, type_name_hash),
            },
            FieldInfoData {
                name: "IsArray",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DataSourceQueryFieldDefinition, is_array),
            },
            FieldInfoData {
                name: "EditorPropertyType",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(DataSourceQueryFieldDefinition, editor_property_type),
            },
        ],
    }),
    array_type: Some(DATASOURCEQUERYFIELDDEFINITION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DataSourceQueryFieldDefinition {
    fn type_info(&self) -> &'static TypeInfo {
        DATASOURCEQUERYFIELDDEFINITION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static DATASOURCEQUERYFIELDDEFINITION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DataSourceQueryFieldDefinition-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("DataSourceQueryFieldDefinition"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PropertyWrapper {
    pub _glacier_base: super::core::DataContainer,
}

pub trait PropertyWrapperTrait: super::core::DataContainerTrait {
}

impl PropertyWrapperTrait for PropertyWrapper {
}

impl super::core::DataContainerTrait for PropertyWrapper {
    fn dc_core(&self) -> &glacier_reflect::data_container::DataContainerCore {
        self._glacier_base.dc_core()
    }
}

pub static PROPERTYWRAPPER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PropertyWrapper",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PropertyWrapper as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(PROPERTYWRAPPER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PropertyWrapper {
    fn type_info(&self) -> &'static TypeInfo {
        PROPERTYWRAPPER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PROPERTYWRAPPER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PropertyWrapper-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("PropertyWrapper"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BundleManagerBundleUnloadMessage {
}

pub trait BundleManagerBundleUnloadMessageTrait: TypeObject {
}

impl BundleManagerBundleUnloadMessageTrait for BundleManagerBundleUnloadMessage {
}

pub static BUNDLEMANAGERBUNDLEUNLOADMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BundleManagerBundleUnloadMessage",
    flags: MemberInfoFlags::new(36937),
    module: "Entity",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BundleManagerBundleUnloadMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for BundleManagerBundleUnloadMessage {
    fn type_info(&self) -> &'static TypeInfo {
        BUNDLEMANAGERBUNDLEUNLOADMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}

#[derive(Clone, Debug, Default)]
pub struct WriteArrayElementEntity {
    pub _glacier_base: Entity,
}

pub trait WriteArrayElementEntityTrait: EntityTrait {
}

impl WriteArrayElementEntityTrait for WriteArrayElementEntity {
}

impl EntityTrait for WriteArrayElementEntity {
}

impl EntityBusPeerTrait for WriteArrayElementEntity {
}

pub static WRITEARRAYELEMENTENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteArrayElementEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WriteArrayElementEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(WRITEARRAYELEMENTENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for WriteArrayElementEntity {
    fn type_info(&self) -> &'static TypeInfo {
        WRITEARRAYELEMENTENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static WRITEARRAYELEMENTENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteArrayElementEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("WriteArrayElementEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ReadArraySizeEntity {
    pub _glacier_base: Entity,
}

pub trait ReadArraySizeEntityTrait: EntityTrait {
}

impl ReadArraySizeEntityTrait for ReadArraySizeEntity {
}

impl EntityTrait for ReadArraySizeEntity {
}

impl EntityBusPeerTrait for ReadArraySizeEntity {
}

pub static READARRAYSIZEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadArraySizeEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ReadArraySizeEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(READARRAYSIZEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ReadArraySizeEntity {
    fn type_info(&self) -> &'static TypeInfo {
        READARRAYSIZEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static READARRAYSIZEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadArraySizeEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ReadArraySizeEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ReadArrayElementEntity {
    pub _glacier_base: Entity,
}

pub trait ReadArrayElementEntityTrait: EntityTrait {
}

impl ReadArrayElementEntityTrait for ReadArrayElementEntity {
}

impl EntityTrait for ReadArrayElementEntity {
}

impl EntityBusPeerTrait for ReadArrayElementEntity {
}

pub static READARRAYELEMENTENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadArrayElementEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ReadArrayElementEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(READARRAYELEMENTENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ReadArrayElementEntity {
    fn type_info(&self) -> &'static TypeInfo {
        READARRAYELEMENTENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static READARRAYELEMENTENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadArrayElementEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ReadArrayElementEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ForEachVariableEntity {
    pub _glacier_base: Entity,
}

pub trait ForEachVariableEntityTrait: EntityTrait {
}

impl ForEachVariableEntityTrait for ForEachVariableEntity {
}

impl EntityTrait for ForEachVariableEntity {
}

impl EntityBusPeerTrait for ForEachVariableEntity {
}

pub static FOREACHVARIABLEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ForEachVariableEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ForEachVariableEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(FOREACHVARIABLEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ForEachVariableEntity {
    fn type_info(&self) -> &'static TypeInfo {
        FOREACHVARIABLEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static FOREACHVARIABLEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ForEachVariableEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ForEachVariableEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ClearArrayVariableEntity {
    pub _glacier_base: Entity,
}

pub trait ClearArrayVariableEntityTrait: EntityTrait {
}

impl ClearArrayVariableEntityTrait for ClearArrayVariableEntity {
}

impl EntityTrait for ClearArrayVariableEntity {
}

impl EntityBusPeerTrait for ClearArrayVariableEntity {
}

pub static CLEARARRAYVARIABLEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClearArrayVariableEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ClearArrayVariableEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(CLEARARRAYVARIABLEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ClearArrayVariableEntity {
    fn type_info(&self) -> &'static TypeInfo {
        CLEARARRAYVARIABLEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static CLEARARRAYVARIABLEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClearArrayVariableEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ClearArrayVariableEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AddToArrayVariableEntity {
    pub _glacier_base: Entity,
}

pub trait AddToArrayVariableEntityTrait: EntityTrait {
}

impl AddToArrayVariableEntityTrait for AddToArrayVariableEntity {
}

impl EntityTrait for AddToArrayVariableEntity {
}

impl EntityBusPeerTrait for AddToArrayVariableEntity {
}

pub static ADDTOARRAYVARIABLEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AddToArrayVariableEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AddToArrayVariableEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(ADDTOARRAYVARIABLEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for AddToArrayVariableEntity {
    fn type_info(&self) -> &'static TypeInfo {
        ADDTOARRAYVARIABLEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ADDTOARRAYVARIABLEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AddToArrayVariableEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("AddToArrayVariableEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WriteVariableEntity {
    pub _glacier_base: Entity,
}

pub trait WriteVariableEntityTrait: EntityTrait {
}

impl WriteVariableEntityTrait for WriteVariableEntity {
}

impl EntityTrait for WriteVariableEntity {
}

impl EntityBusPeerTrait for WriteVariableEntity {
}

pub static WRITEVARIABLEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteVariableEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WriteVariableEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(WRITEVARIABLEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for WriteVariableEntity {
    fn type_info(&self) -> &'static TypeInfo {
        WRITEVARIABLEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static WRITEVARIABLEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteVariableEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("WriteVariableEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ReadVariableEntity {
    pub _glacier_base: Entity,
}

pub trait ReadVariableEntityTrait: EntityTrait {
}

impl ReadVariableEntityTrait for ReadVariableEntity {
}

impl EntityTrait for ReadVariableEntity {
}

impl EntityBusPeerTrait for ReadVariableEntity {
}

pub static READVARIABLEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadVariableEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ReadVariableEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(READVARIABLEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ReadVariableEntity {
    fn type_info(&self) -> &'static TypeInfo {
        READVARIABLEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static READVARIABLEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadVariableEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ReadVariableEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct HighlightEntity {
    pub _glacier_base: Entity,
}

pub trait HighlightEntityTrait: EntityTrait {
}

impl HighlightEntityTrait for HighlightEntity {
}

impl EntityTrait for HighlightEntity {
}

impl EntityBusPeerTrait for HighlightEntity {
}

pub static HIGHLIGHTENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HighlightEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<HighlightEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(HIGHLIGHTENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for HighlightEntity {
    fn type_info(&self) -> &'static TypeInfo {
        HIGHLIGHTENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static HIGHLIGHTENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HighlightEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("HighlightEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TextSequenceEntity {
    pub _glacier_base: Entity,
}

pub trait TextSequenceEntityTrait: EntityTrait {
}

impl TextSequenceEntityTrait for TextSequenceEntity {
}

impl EntityTrait for TextSequenceEntity {
}

impl EntityBusPeerTrait for TextSequenceEntity {
}

pub static TEXTSEQUENCEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TextSequenceEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TextSequenceEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(TEXTSEQUENCEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for TextSequenceEntity {
    fn type_info(&self) -> &'static TypeInfo {
        TEXTSEQUENCEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static TEXTSEQUENCEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TextSequenceEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TextSequenceEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SubLevelEntity {
    pub _glacier_base: Entity,
}

pub trait SubLevelEntityTrait: EntityTrait {
}

impl SubLevelEntityTrait for SubLevelEntity {
}

impl EntityTrait for SubLevelEntity {
}

impl EntityBusPeerTrait for SubLevelEntity {
}

pub static SUBLEVELENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubLevelEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SubLevelEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SUBLEVELENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SubLevelEntity {
    fn type_info(&self) -> &'static TypeInfo {
        SUBLEVELENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SUBLEVELENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubLevelEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SubLevelEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ReportInstallationProgressEntity {
    pub _glacier_base: Entity,
}

pub trait ReportInstallationProgressEntityTrait: EntityTrait {
}

impl ReportInstallationProgressEntityTrait for ReportInstallationProgressEntity {
}

impl EntityTrait for ReportInstallationProgressEntity {
}

impl EntityBusPeerTrait for ReportInstallationProgressEntity {
}

pub static REPORTINSTALLATIONPROGRESSENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReportInstallationProgressEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ReportInstallationProgressEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(REPORTINSTALLATIONPROGRESSENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ReportInstallationProgressEntity {
    fn type_info(&self) -> &'static TypeInfo {
        REPORTINSTALLATIONPROGRESSENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static REPORTINSTALLATIONPROGRESSENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReportInstallationProgressEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ReportInstallationProgressEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LocalPlayerIdEntity {
    pub _glacier_base: Entity,
}

pub trait LocalPlayerIdEntityTrait: EntityTrait {
}

impl LocalPlayerIdEntityTrait for LocalPlayerIdEntity {
}

impl EntityTrait for LocalPlayerIdEntity {
}

impl EntityBusPeerTrait for LocalPlayerIdEntity {
}

pub static LOCALPLAYERIDENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalPlayerIdEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LocalPlayerIdEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(LOCALPLAYERIDENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for LocalPlayerIdEntity {
    fn type_info(&self) -> &'static TypeInfo {
        LOCALPLAYERIDENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static LOCALPLAYERIDENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalPlayerIdEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("LocalPlayerIdEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FloatCacheEntity {
    pub _glacier_base: Entity,
}

pub trait FloatCacheEntityTrait: EntityTrait {
}

impl FloatCacheEntityTrait for FloatCacheEntity {
}

impl EntityTrait for FloatCacheEntity {
}

impl EntityBusPeerTrait for FloatCacheEntity {
}

pub static FLOATCACHEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatCacheEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FloatCacheEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(FLOATCACHEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for FloatCacheEntity {
    fn type_info(&self) -> &'static TypeInfo {
        FLOATCACHEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static FLOATCACHEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatCacheEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("FloatCacheEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MultilineStringEntity {
    pub _glacier_base: Entity,
}

pub trait MultilineStringEntityTrait: EntityTrait {
}

impl MultilineStringEntityTrait for MultilineStringEntity {
}

impl EntityTrait for MultilineStringEntity {
}

impl EntityBusPeerTrait for MultilineStringEntity {
}

pub static MULTILINESTRINGENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultilineStringEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MultilineStringEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(MULTILINESTRINGENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for MultilineStringEntity {
    fn type_info(&self) -> &'static TypeInfo {
        MULTILINESTRINGENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static MULTILINESTRINGENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultilineStringEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("MultilineStringEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct StringEntity {
    pub _glacier_base: Entity,
}

pub trait StringEntityTrait: EntityTrait {
}

impl StringEntityTrait for StringEntity {
}

impl EntityTrait for StringEntity {
}

impl EntityBusPeerTrait for StringEntity {
}

pub static STRINGENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StringEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StringEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(STRINGENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for StringEntity {
    fn type_info(&self) -> &'static TypeInfo {
        STRINGENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static STRINGENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StringEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("StringEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AxisAlignedBoxEntity {
    pub _glacier_base: Entity,
}

pub trait AxisAlignedBoxEntityTrait: EntityTrait {
}

impl AxisAlignedBoxEntityTrait for AxisAlignedBoxEntity {
}

impl EntityTrait for AxisAlignedBoxEntity {
}

impl EntityBusPeerTrait for AxisAlignedBoxEntity {
}

pub static AXISALIGNEDBOXENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AxisAlignedBoxEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AxisAlignedBoxEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(AXISALIGNEDBOXENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for AxisAlignedBoxEntity {
    fn type_info(&self) -> &'static TypeInfo {
        AXISALIGNEDBOXENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static AXISALIGNEDBOXENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AxisAlignedBoxEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("AxisAlignedBoxEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Vector4Entity {
    pub _glacier_base: Entity,
}

pub trait Vector4EntityTrait: EntityTrait {
}

impl Vector4EntityTrait for Vector4Entity {
}

impl EntityTrait for Vector4Entity {
}

impl EntityBusPeerTrait for Vector4Entity {
}

pub static VECTOR4ENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vector4Entity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vector4Entity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(VECTOR4ENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for Vector4Entity {
    fn type_info(&self) -> &'static TypeInfo {
        VECTOR4ENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VECTOR4ENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vector4Entity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vector4Entity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Vector3Entity {
    pub _glacier_base: Entity,
}

pub trait Vector3EntityTrait: EntityTrait {
}

impl Vector3EntityTrait for Vector3Entity {
}

impl EntityTrait for Vector3Entity {
}

impl EntityBusPeerTrait for Vector3Entity {
}

pub static VECTOR3ENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vector3Entity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vector3Entity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(VECTOR3ENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for Vector3Entity {
    fn type_info(&self) -> &'static TypeInfo {
        VECTOR3ENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VECTOR3ENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vector3Entity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vector3Entity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TransformEntity {
    pub _glacier_base: Entity,
}

pub trait TransformEntityTrait: EntityTrait {
}

impl TransformEntityTrait for TransformEntity {
}

impl EntityTrait for TransformEntity {
}

impl EntityBusPeerTrait for TransformEntity {
}

pub static TRANSFORMENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(TRANSFORMENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for TransformEntity {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static TRANSFORMENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TransformEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FloatEntity {
    pub _glacier_base: Entity,
}

pub trait FloatEntityTrait: EntityTrait {
}

impl FloatEntityTrait for FloatEntity {
}

impl EntityTrait for FloatEntity {
}

impl EntityBusPeerTrait for FloatEntity {
}

pub static FLOATENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FloatEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(FLOATENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for FloatEntity {
    fn type_info(&self) -> &'static TypeInfo {
        FLOATENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static FLOATENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("FloatEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct UIntEntity {
    pub _glacier_base: Entity,
}

pub trait UIntEntityTrait: EntityTrait {
}

impl UIntEntityTrait for UIntEntity {
}

impl EntityTrait for UIntEntity {
}

impl EntityBusPeerTrait for UIntEntity {
}

pub static UINTENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UIntEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<UIntEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(UINTENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for UIntEntity {
    fn type_info(&self) -> &'static TypeInfo {
        UINTENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static UINTENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UIntEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("UIntEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct IntEntity {
    pub _glacier_base: Entity,
}

pub trait IntEntityTrait: EntityTrait {
}

impl IntEntityTrait for IntEntity {
}

impl EntityTrait for IntEntity {
}

impl EntityBusPeerTrait for IntEntity {
}

pub static INTENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<IntEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(INTENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for IntEntity {
    fn type_info(&self) -> &'static TypeInfo {
        INTENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static INTENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("IntEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BoolEntity {
    pub _glacier_base: Entity,
}

pub trait BoolEntityTrait: EntityTrait {
}

impl BoolEntityTrait for BoolEntity {
}

impl EntityTrait for BoolEntity {
}

impl EntityBusPeerTrait for BoolEntity {
}

pub static BOOLENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BoolEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(BOOLENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for BoolEntity {
    fn type_info(&self) -> &'static TypeInfo {
        BOOLENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static BOOLENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("BoolEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SpatialEntity {
    pub _glacier_base: Entity,
}

pub trait SpatialEntityTrait: EntityTrait {
}

impl SpatialEntityTrait for SpatialEntity {
}

impl EntityTrait for SpatialEntity {
}

impl EntityBusPeerTrait for SpatialEntity {
}

pub static SPATIALENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpatialEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SpatialEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SPATIALENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SpatialEntity {
    fn type_info(&self) -> &'static TypeInfo {
        SPATIALENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SPATIALENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpatialEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SpatialEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SelectVec4Entity {
    pub _glacier_base: Entity,
}

pub trait SelectVec4EntityTrait: EntityTrait {
}

impl SelectVec4EntityTrait for SelectVec4Entity {
}

impl EntityTrait for SelectVec4Entity {
}

impl EntityBusPeerTrait for SelectVec4Entity {
}

pub static SELECTVEC4ENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectVec4Entity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SelectVec4Entity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SELECTVEC4ENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SelectVec4Entity {
    fn type_info(&self) -> &'static TypeInfo {
        SELECTVEC4ENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SELECTVEC4ENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectVec4Entity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SelectVec4Entity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SelectVec3Entity {
    pub _glacier_base: Entity,
}

pub trait SelectVec3EntityTrait: EntityTrait {
}

impl SelectVec3EntityTrait for SelectVec3Entity {
}

impl EntityTrait for SelectVec3Entity {
}

impl EntityBusPeerTrait for SelectVec3Entity {
}

pub static SELECTVEC3ENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectVec3Entity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SelectVec3Entity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SELECTVEC3ENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SelectVec3Entity {
    fn type_info(&self) -> &'static TypeInfo {
        SELECTVEC3ENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SELECTVEC3ENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectVec3Entity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SelectVec3Entity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SelectVec2Entity {
    pub _glacier_base: Entity,
}

pub trait SelectVec2EntityTrait: EntityTrait {
}

impl SelectVec2EntityTrait for SelectVec2Entity {
}

impl EntityTrait for SelectVec2Entity {
}

impl EntityBusPeerTrait for SelectVec2Entity {
}

pub static SELECTVEC2ENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectVec2Entity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SelectVec2Entity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SELECTVEC2ENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SelectVec2Entity {
    fn type_info(&self) -> &'static TypeInfo {
        SELECTVEC2ENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SELECTVEC2ENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectVec2Entity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SelectVec2Entity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SelectTransformEntity {
    pub _glacier_base: Entity,
}

pub trait SelectTransformEntityTrait: EntityTrait {
}

impl SelectTransformEntityTrait for SelectTransformEntity {
}

impl EntityTrait for SelectTransformEntity {
}

impl EntityBusPeerTrait for SelectTransformEntity {
}

pub static SELECTTRANSFORMENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectTransformEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SelectTransformEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SELECTTRANSFORMENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SelectTransformEntity {
    fn type_info(&self) -> &'static TypeInfo {
        SELECTTRANSFORMENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SELECTTRANSFORMENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectTransformEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SelectTransformEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SelectBoolEntity {
    pub _glacier_base: Entity,
}

pub trait SelectBoolEntityTrait: EntityTrait {
}

impl SelectBoolEntityTrait for SelectBoolEntity {
}

impl EntityTrait for SelectBoolEntity {
}

impl EntityBusPeerTrait for SelectBoolEntity {
}

pub static SELECTBOOLENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectBoolEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SelectBoolEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SELECTBOOLENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SelectBoolEntity {
    fn type_info(&self) -> &'static TypeInfo {
        SELECTBOOLENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SELECTBOOLENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectBoolEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SelectBoolEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SelectStringEntity {
    pub _glacier_base: Entity,
}

pub trait SelectStringEntityTrait: EntityTrait {
}

impl SelectStringEntityTrait for SelectStringEntity {
}

impl EntityTrait for SelectStringEntity {
}

impl EntityBusPeerTrait for SelectStringEntity {
}

pub static SELECTSTRINGENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectStringEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SelectStringEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SELECTSTRINGENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SelectStringEntity {
    fn type_info(&self) -> &'static TypeInfo {
        SELECTSTRINGENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SELECTSTRINGENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectStringEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SelectStringEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SelectInt64Entity {
    pub _glacier_base: Entity,
}

pub trait SelectInt64EntityTrait: EntityTrait {
}

impl SelectInt64EntityTrait for SelectInt64Entity {
}

impl EntityTrait for SelectInt64Entity {
}

impl EntityBusPeerTrait for SelectInt64Entity {
}

pub static SELECTINT64ENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectInt64Entity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SelectInt64Entity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SELECTINT64ENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SelectInt64Entity {
    fn type_info(&self) -> &'static TypeInfo {
        SELECTINT64ENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SELECTINT64ENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectInt64Entity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SelectInt64Entity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SelectIntEntity {
    pub _glacier_base: Entity,
}

pub trait SelectIntEntityTrait: EntityTrait {
}

impl SelectIntEntityTrait for SelectIntEntity {
}

impl EntityTrait for SelectIntEntity {
}

impl EntityBusPeerTrait for SelectIntEntity {
}

pub static SELECTINTENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectIntEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SelectIntEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SELECTINTENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SelectIntEntity {
    fn type_info(&self) -> &'static TypeInfo {
        SELECTINTENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SELECTINTENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectIntEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SelectIntEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SelectFloatEntity {
    pub _glacier_base: Entity,
}

pub trait SelectFloatEntityTrait: EntityTrait {
}

impl SelectFloatEntityTrait for SelectFloatEntity {
}

impl EntityTrait for SelectFloatEntity {
}

impl EntityBusPeerTrait for SelectFloatEntity {
}

pub static SELECTFLOATENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectFloatEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SelectFloatEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SELECTFLOATENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SelectFloatEntity {
    fn type_info(&self) -> &'static TypeInfo {
        SELECTFLOATENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SELECTFLOATENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectFloatEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SelectFloatEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ScriptEntity {
    pub _glacier_base: Entity,
}

pub trait ScriptEntityTrait: EntityTrait {
}

impl ScriptEntityTrait for ScriptEntity {
}

impl EntityTrait for ScriptEntity {
}

impl EntityBusPeerTrait for ScriptEntity {
}

pub static SCRIPTENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScriptEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ScriptEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SCRIPTENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ScriptEntity {
    fn type_info(&self) -> &'static TypeInfo {
        SCRIPTENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SCRIPTENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScriptEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ScriptEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SchematicChannelEntity {
    pub _glacier_base: Entity,
}

pub trait SchematicChannelEntityTrait: EntityTrait {
}

impl SchematicChannelEntityTrait for SchematicChannelEntity {
}

impl EntityTrait for SchematicChannelEntity {
}

impl EntityBusPeerTrait for SchematicChannelEntity {
}

pub static SCHEMATICCHANNELENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SchematicChannelEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SchematicChannelEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SCHEMATICCHANNELENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SchematicChannelEntity {
    fn type_info(&self) -> &'static TypeInfo {
        SCHEMATICCHANNELENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SCHEMATICCHANNELENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SchematicChannelEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SchematicChannelEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Part {
    pub _glacier_base: Component,
}

pub trait PartTrait: ComponentTrait {
}

impl PartTrait for Part {
}

impl ComponentTrait for Part {
}

impl EntityBusPeerTrait for Part {
}

pub static PART_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Part",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(COMPONENT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Part as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(PART_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for Part {
    fn type_info(&self) -> &'static TypeInfo {
        PART_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PART_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Part-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Part"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ObjectAreaTriggerEntity {
    pub _glacier_base: Entity,
}

pub trait ObjectAreaTriggerEntityTrait: EntityTrait {
}

impl ObjectAreaTriggerEntityTrait for ObjectAreaTriggerEntity {
}

impl EntityTrait for ObjectAreaTriggerEntity {
}

impl EntityBusPeerTrait for ObjectAreaTriggerEntity {
}

pub static OBJECTAREATRIGGERENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectAreaTriggerEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ObjectAreaTriggerEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(OBJECTAREATRIGGERENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ObjectAreaTriggerEntity {
    fn type_info(&self) -> &'static TypeInfo {
        OBJECTAREATRIGGERENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static OBJECTAREATRIGGERENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectAreaTriggerEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ObjectAreaTriggerEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ObjectVariationToIntEntity {
    pub _glacier_base: Entity,
}

pub trait ObjectVariationToIntEntityTrait: EntityTrait {
}

impl ObjectVariationToIntEntityTrait for ObjectVariationToIntEntity {
}

impl EntityTrait for ObjectVariationToIntEntity {
}

impl EntityBusPeerTrait for ObjectVariationToIntEntity {
}

pub static OBJECTVARIATIONTOINTENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectVariationToIntEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ObjectVariationToIntEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(OBJECTVARIATIONTOINTENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ObjectVariationToIntEntity {
    fn type_info(&self) -> &'static TypeInfo {
        OBJECTVARIATIONTOINTENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static OBJECTVARIATIONTOINTENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectVariationToIntEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ObjectVariationToIntEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TransformSpaceEntity {
    pub _glacier_base: Entity,
}

pub trait TransformSpaceEntityTrait: EntityTrait {
}

impl TransformSpaceEntityTrait for TransformSpaceEntity {
}

impl EntityTrait for TransformSpaceEntity {
}

impl EntityBusPeerTrait for TransformSpaceEntity {
}

pub static TRANSFORMSPACEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformSpaceEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformSpaceEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(TRANSFORMSPACEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for TransformSpaceEntity {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMSPACEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static TRANSFORMSPACEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformSpaceEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TransformSpaceEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FloatSelectEntity {
    pub _glacier_base: Entity,
}

pub trait FloatSelectEntityTrait: EntityTrait {
}

impl FloatSelectEntityTrait for FloatSelectEntity {
}

impl EntityTrait for FloatSelectEntity {
}

impl EntityBusPeerTrait for FloatSelectEntity {
}

pub static FLOATSELECTENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatSelectEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FloatSelectEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(FLOATSELECTENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for FloatSelectEntity {
    fn type_info(&self) -> &'static TypeInfo {
        FLOATSELECTENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static FLOATSELECTENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatSelectEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("FloatSelectEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FloatCurveEntity {
    pub _glacier_base: Entity,
}

pub trait FloatCurveEntityTrait: EntityTrait {
}

impl FloatCurveEntityTrait for FloatCurveEntity {
}

impl EntityTrait for FloatCurveEntity {
}

impl EntityBusPeerTrait for FloatCurveEntity {
}

pub static FLOATCURVEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatCurveEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FloatCurveEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(FLOATCURVEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for FloatCurveEntity {
    fn type_info(&self) -> &'static TypeInfo {
        FLOATCURVEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static FLOATCURVEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatCurveEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("FloatCurveEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SettingEntity {
    pub _glacier_base: Entity,
}

pub trait SettingEntityTrait: EntityTrait {
}

impl SettingEntityTrait for SettingEntity {
}

impl EntityTrait for SettingEntity {
}

impl EntityBusPeerTrait for SettingEntity {
}

pub static SETTINGENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SettingEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SettingEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SETTINGENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SettingEntity {
    fn type_info(&self) -> &'static TypeInfo {
        SETTINGENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SETTINGENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SettingEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SettingEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct IntegratorOrDifferentiatorEntity {
    pub _glacier_base: Entity,
}

pub trait IntegratorOrDifferentiatorEntityTrait: EntityTrait {
}

impl IntegratorOrDifferentiatorEntityTrait for IntegratorOrDifferentiatorEntity {
}

impl EntityTrait for IntegratorOrDifferentiatorEntity {
}

impl EntityBusPeerTrait for IntegratorOrDifferentiatorEntity {
}

pub static INTEGRATORORDIFFERENTIATORENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntegratorOrDifferentiatorEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<IntegratorOrDifferentiatorEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(INTEGRATORORDIFFERENTIATORENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for IntegratorOrDifferentiatorEntity {
    fn type_info(&self) -> &'static TypeInfo {
        INTEGRATORORDIFFERENTIATORENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static INTEGRATORORDIFFERENTIATORENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntegratorOrDifferentiatorEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("IntegratorOrDifferentiatorEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ProfileEntity {
    pub _glacier_base: Entity,
}

pub trait ProfileEntityTrait: EntityTrait {
}

impl ProfileEntityTrait for ProfileEntity {
}

impl EntityTrait for ProfileEntity {
}

impl EntityBusPeerTrait for ProfileEntity {
}

pub static PROFILEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ProfileEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ProfileEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(PROFILEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ProfileEntity {
    fn type_info(&self) -> &'static TypeInfo {
        PROFILEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PROFILEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ProfileEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ProfileEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CompareEntity {
    pub _glacier_base: Entity,
}

pub trait CompareEntityTrait: EntityTrait {
}

impl CompareEntityTrait for CompareEntity {
}

impl EntityTrait for CompareEntity {
}

impl EntityBusPeerTrait for CompareEntity {
}

pub static COMPAREENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompareEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(COMPAREENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for CompareEntity {
    fn type_info(&self) -> &'static TypeInfo {
        COMPAREENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static COMPAREENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompareEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CompareEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RunningAverageEntity {
    pub _glacier_base: Entity,
}

pub trait RunningAverageEntityTrait: EntityTrait {
}

impl RunningAverageEntityTrait for RunningAverageEntity {
}

impl EntityTrait for RunningAverageEntity {
}

impl EntityBusPeerTrait for RunningAverageEntity {
}

pub static RUNNINGAVERAGEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RunningAverageEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RunningAverageEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(RUNNINGAVERAGEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for RunningAverageEntity {
    fn type_info(&self) -> &'static TypeInfo {
        RUNNINGAVERAGEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static RUNNINGAVERAGEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RunningAverageEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("RunningAverageEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AbsEntity {
    pub _glacier_base: Entity,
}

pub trait AbsEntityTrait: EntityTrait {
}

impl AbsEntityTrait for AbsEntity {
}

impl EntityTrait for AbsEntity {
}

impl EntityBusPeerTrait for AbsEntity {
}

pub static ABSENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AbsEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AbsEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(ABSENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for AbsEntity {
    fn type_info(&self) -> &'static TypeInfo {
        ABSENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ABSENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AbsEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("AbsEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VectorMathOpEntity {
    pub _glacier_base: Entity,
}

pub trait VectorMathOpEntityTrait: EntityTrait {
}

impl VectorMathOpEntityTrait for VectorMathOpEntity {
}

impl EntityTrait for VectorMathOpEntity {
}

impl EntityBusPeerTrait for VectorMathOpEntity {
}

pub static VECTORMATHOPENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VectorMathOpEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VectorMathOpEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(VECTORMATHOPENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for VectorMathOpEntity {
    fn type_info(&self) -> &'static TypeInfo {
        VECTORMATHOPENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VECTORMATHOPENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VectorMathOpEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("VectorMathOpEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MathOpEntity {
    pub _glacier_base: Entity,
}

pub trait MathOpEntityTrait: EntityTrait {
}

impl MathOpEntityTrait for MathOpEntity {
}

impl EntityTrait for MathOpEntity {
}

impl EntityBusPeerTrait for MathOpEntity {
}

pub static MATHOPENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MathOpEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MathOpEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(MATHOPENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for MathOpEntity {
    fn type_info(&self) -> &'static TypeInfo {
        MATHOPENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static MATHOPENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MathOpEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("MathOpEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PropertyCastEntity {
    pub _glacier_base: Entity,
}

pub trait PropertyCastEntityTrait: EntityTrait {
}

impl PropertyCastEntityTrait for PropertyCastEntity {
}

impl EntityTrait for PropertyCastEntity {
}

impl EntityBusPeerTrait for PropertyCastEntity {
}

pub static PROPERTYCASTENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PropertyCastEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PropertyCastEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(PROPERTYCASTENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for PropertyCastEntity {
    fn type_info(&self) -> &'static TypeInfo {
        PROPERTYCASTENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PROPERTYCASTENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PropertyCastEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("PropertyCastEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BoolToEventEntity {
    pub _glacier_base: Entity,
}

pub trait BoolToEventEntityTrait: EntityTrait {
}

impl BoolToEventEntityTrait for BoolToEventEntity {
}

impl EntityTrait for BoolToEventEntity {
}

impl EntityBusPeerTrait for BoolToEventEntity {
}

pub static BOOLTOEVENTENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolToEventEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BoolToEventEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(BOOLTOEVENTENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for BoolToEventEntity {
    fn type_info(&self) -> &'static TypeInfo {
        BOOLTOEVENTENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static BOOLTOEVENTENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolToEventEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("BoolToEventEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SwitchPropertyStringEntity {
    pub _glacier_base: Entity,
}

pub trait SwitchPropertyStringEntityTrait: EntityTrait {
}

impl SwitchPropertyStringEntityTrait for SwitchPropertyStringEntity {
}

impl EntityTrait for SwitchPropertyStringEntity {
}

impl EntityBusPeerTrait for SwitchPropertyStringEntity {
}

pub static SWITCHPROPERTYSTRINGENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SwitchPropertyStringEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SwitchPropertyStringEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SWITCHPROPERTYSTRINGENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SwitchPropertyStringEntity {
    fn type_info(&self) -> &'static TypeInfo {
        SWITCHPROPERTYSTRINGENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SWITCHPROPERTYSTRINGENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SwitchPropertyStringEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SwitchPropertyStringEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PropertyGateEntity {
    pub _glacier_base: Entity,
}

pub trait PropertyGateEntityTrait: EntityTrait {
}

impl PropertyGateEntityTrait for PropertyGateEntity {
}

impl EntityTrait for PropertyGateEntity {
}

impl EntityBusPeerTrait for PropertyGateEntity {
}

pub static PROPERTYGATEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PropertyGateEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PropertyGateEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(PROPERTYGATEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for PropertyGateEntity {
    fn type_info(&self) -> &'static TypeInfo {
        PROPERTYGATEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static PROPERTYGATEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PropertyGateEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("PropertyGateEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EventGateEntity {
    pub _glacier_base: Entity,
}

pub trait EventGateEntityTrait: EntityTrait {
}

impl EventGateEntityTrait for EventGateEntity {
}

impl EntityTrait for EventGateEntity {
}

impl EntityBusPeerTrait for EventGateEntity {
}

pub static EVENTGATEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventGateEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EventGateEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(EVENTGATEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for EventGateEntity {
    fn type_info(&self) -> &'static TypeInfo {
        EVENTGATEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static EVENTGATEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventGateEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EventGateEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct StopWatchEntity {
    pub _glacier_base: Entity,
}

pub trait StopWatchEntityTrait: EntityTrait {
}

impl StopWatchEntityTrait for StopWatchEntity {
}

impl EntityTrait for StopWatchEntity {
}

impl EntityBusPeerTrait for StopWatchEntity {
}

pub static STOPWATCHENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StopWatchEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StopWatchEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(STOPWATCHENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for StopWatchEntity {
    fn type_info(&self) -> &'static TypeInfo {
        STOPWATCHENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static STOPWATCHENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StopWatchEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("StopWatchEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TransformToRotationEntity {
    pub _glacier_base: Entity,
}

pub trait TransformToRotationEntityTrait: EntityTrait {
}

impl TransformToRotationEntityTrait for TransformToRotationEntity {
}

impl EntityTrait for TransformToRotationEntity {
}

impl EntityBusPeerTrait for TransformToRotationEntity {
}

pub static TRANSFORMTOROTATIONENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformToRotationEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformToRotationEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(TRANSFORMTOROTATIONENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for TransformToRotationEntity {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMTOROTATIONENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static TRANSFORMTOROTATIONENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformToRotationEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TransformToRotationEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TransformModifierEntity {
    pub _glacier_base: Entity,
}

pub trait TransformModifierEntityTrait: EntityTrait {
}

impl TransformModifierEntityTrait for TransformModifierEntity {
}

impl EntityTrait for TransformModifierEntity {
}

impl EntityBusPeerTrait for TransformModifierEntity {
}

pub static TRANSFORMMODIFIERENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformModifierEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformModifierEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(TRANSFORMMODIFIERENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for TransformModifierEntity {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMMODIFIERENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static TRANSFORMMODIFIERENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformModifierEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TransformModifierEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RotationTransformBuilderEntity {
    pub _glacier_base: Entity,
}

pub trait RotationTransformBuilderEntityTrait: EntityTrait {
}

impl RotationTransformBuilderEntityTrait for RotationTransformBuilderEntity {
}

impl EntityTrait for RotationTransformBuilderEntity {
}

impl EntityBusPeerTrait for RotationTransformBuilderEntity {
}

pub static ROTATIONTRANSFORMBUILDERENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RotationTransformBuilderEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RotationTransformBuilderEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(ROTATIONTRANSFORMBUILDERENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for RotationTransformBuilderEntity {
    fn type_info(&self) -> &'static TypeInfo {
        ROTATIONTRANSFORMBUILDERENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ROTATIONTRANSFORMBUILDERENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RotationTransformBuilderEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("RotationTransformBuilderEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ScaleTransformBuilderEntity {
    pub _glacier_base: Entity,
}

pub trait ScaleTransformBuilderEntityTrait: EntityTrait {
}

impl ScaleTransformBuilderEntityTrait for ScaleTransformBuilderEntity {
}

impl EntityTrait for ScaleTransformBuilderEntity {
}

impl EntityBusPeerTrait for ScaleTransformBuilderEntity {
}

pub static SCALETRANSFORMBUILDERENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScaleTransformBuilderEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ScaleTransformBuilderEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SCALETRANSFORMBUILDERENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ScaleTransformBuilderEntity {
    fn type_info(&self) -> &'static TypeInfo {
        SCALETRANSFORMBUILDERENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SCALETRANSFORMBUILDERENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScaleTransformBuilderEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ScaleTransformBuilderEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TransformBuilderEntity {
    pub _glacier_base: Entity,
}

pub trait TransformBuilderEntityTrait: EntityTrait {
}

impl TransformBuilderEntityTrait for TransformBuilderEntity {
}

impl EntityTrait for TransformBuilderEntity {
}

impl EntityBusPeerTrait for TransformBuilderEntity {
}

pub static TRANSFORMBUILDERENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformBuilderEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformBuilderEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(TRANSFORMBUILDERENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for TransformBuilderEntity {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMBUILDERENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static TRANSFORMBUILDERENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformBuilderEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TransformBuilderEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VecBuilderEntity {
    pub _glacier_base: Entity,
}

pub trait VecBuilderEntityTrait: EntityTrait {
}

impl VecBuilderEntityTrait for VecBuilderEntity {
}

impl EntityTrait for VecBuilderEntity {
}

impl EntityBusPeerTrait for VecBuilderEntity {
}

pub static VECBUILDERENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VecBuilderEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VecBuilderEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(VECBUILDERENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for VecBuilderEntity {
    fn type_info(&self) -> &'static TypeInfo {
        VECBUILDERENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VECBUILDERENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VecBuilderEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("VecBuilderEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Vec4BuilderEntity {
    pub _glacier_base: Entity,
}

pub trait Vec4BuilderEntityTrait: EntityTrait {
}

impl Vec4BuilderEntityTrait for Vec4BuilderEntity {
}

impl EntityTrait for Vec4BuilderEntity {
}

impl EntityBusPeerTrait for Vec4BuilderEntity {
}

pub static VEC4BUILDERENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec4BuilderEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec4BuilderEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(VEC4BUILDERENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for Vec4BuilderEntity {
    fn type_info(&self) -> &'static TypeInfo {
        VEC4BUILDERENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VEC4BUILDERENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec4BuilderEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec4BuilderEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Vec3BuilderEntity {
    pub _glacier_base: Entity,
}

pub trait Vec3BuilderEntityTrait: EntityTrait {
}

impl Vec3BuilderEntityTrait for Vec3BuilderEntity {
}

impl EntityTrait for Vec3BuilderEntity {
}

impl EntityBusPeerTrait for Vec3BuilderEntity {
}

pub static VEC3BUILDERENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3BuilderEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec3BuilderEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(VEC3BUILDERENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for Vec3BuilderEntity {
    fn type_info(&self) -> &'static TypeInfo {
        VEC3BUILDERENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VEC3BUILDERENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3BuilderEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec3BuilderEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Vec2BuilderEntity {
    pub _glacier_base: Entity,
}

pub trait Vec2BuilderEntityTrait: EntityTrait {
}

impl Vec2BuilderEntityTrait for Vec2BuilderEntity {
}

impl EntityTrait for Vec2BuilderEntity {
}

impl EntityBusPeerTrait for Vec2BuilderEntity {
}

pub static VEC2BUILDERENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec2BuilderEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec2BuilderEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(VEC2BUILDERENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for Vec2BuilderEntity {
    fn type_info(&self) -> &'static TypeInfo {
        VEC2BUILDERENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VEC2BUILDERENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec2BuilderEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec2BuilderEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VecSplitterEntity {
    pub _glacier_base: Entity,
}

pub trait VecSplitterEntityTrait: EntityTrait {
}

impl VecSplitterEntityTrait for VecSplitterEntity {
}

impl EntityTrait for VecSplitterEntity {
}

impl EntityBusPeerTrait for VecSplitterEntity {
}

pub static VECSPLITTERENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VecSplitterEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VecSplitterEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(VECSPLITTERENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for VecSplitterEntity {
    fn type_info(&self) -> &'static TypeInfo {
        VECSPLITTERENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VECSPLITTERENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VecSplitterEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("VecSplitterEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Vec4SplitterEntity {
    pub _glacier_base: Entity,
}

pub trait Vec4SplitterEntityTrait: EntityTrait {
}

impl Vec4SplitterEntityTrait for Vec4SplitterEntity {
}

impl EntityTrait for Vec4SplitterEntity {
}

impl EntityBusPeerTrait for Vec4SplitterEntity {
}

pub static VEC4SPLITTERENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec4SplitterEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec4SplitterEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(VEC4SPLITTERENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for Vec4SplitterEntity {
    fn type_info(&self) -> &'static TypeInfo {
        VEC4SPLITTERENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VEC4SPLITTERENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec4SplitterEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec4SplitterEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Vec3SplitterEntity {
    pub _glacier_base: Entity,
}

pub trait Vec3SplitterEntityTrait: EntityTrait {
}

impl Vec3SplitterEntityTrait for Vec3SplitterEntity {
}

impl EntityTrait for Vec3SplitterEntity {
}

impl EntityBusPeerTrait for Vec3SplitterEntity {
}

pub static VEC3SPLITTERENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3SplitterEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec3SplitterEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(VEC3SPLITTERENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for Vec3SplitterEntity {
    fn type_info(&self) -> &'static TypeInfo {
        VEC3SPLITTERENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VEC3SPLITTERENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3SplitterEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec3SplitterEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Vec2SplitterEntity {
    pub _glacier_base: Entity,
}

pub trait Vec2SplitterEntityTrait: EntityTrait {
}

impl Vec2SplitterEntityTrait for Vec2SplitterEntity {
}

impl EntityTrait for Vec2SplitterEntity {
}

impl EntityBusPeerTrait for Vec2SplitterEntity {
}

pub static VEC2SPLITTERENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec2SplitterEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec2SplitterEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(VEC2SPLITTERENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for Vec2SplitterEntity {
    fn type_info(&self) -> &'static TypeInfo {
        VEC2SPLITTERENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VEC2SPLITTERENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec2SplitterEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec2SplitterEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EulerTransformEntity {
    pub _glacier_base: Entity,
}

pub trait EulerTransformEntityTrait: EntityTrait {
}

impl EulerTransformEntityTrait for EulerTransformEntity {
}

impl EntityTrait for EulerTransformEntity {
}

impl EntityBusPeerTrait for EulerTransformEntity {
}

pub static EULERTRANSFORMENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EulerTransformEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EulerTransformEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(EULERTRANSFORMENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for EulerTransformEntity {
    fn type_info(&self) -> &'static TypeInfo {
        EULERTRANSFORMENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static EULERTRANSFORMENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EulerTransformEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EulerTransformEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EulerTransformSplitterEntity {
    pub _glacier_base: Entity,
}

pub trait EulerTransformSplitterEntityTrait: EntityTrait {
}

impl EulerTransformSplitterEntityTrait for EulerTransformSplitterEntity {
}

impl EntityTrait for EulerTransformSplitterEntity {
}

impl EntityBusPeerTrait for EulerTransformSplitterEntity {
}

pub static EULERTRANSFORMSPLITTERENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EulerTransformSplitterEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EulerTransformSplitterEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(EULERTRANSFORMSPLITTERENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for EulerTransformSplitterEntity {
    fn type_info(&self) -> &'static TypeInfo {
        EULERTRANSFORMSPLITTERENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static EULERTRANSFORMSPLITTERENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EulerTransformSplitterEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EulerTransformSplitterEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TransformSplitterEntity {
    pub _glacier_base: Entity,
}

pub trait TransformSplitterEntityTrait: EntityTrait {
}

impl TransformSplitterEntityTrait for TransformSplitterEntity {
}

impl EntityTrait for TransformSplitterEntity {
}

impl EntityBusPeerTrait for TransformSplitterEntity {
}

pub static TRANSFORMSPLITTERENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformSplitterEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformSplitterEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(TRANSFORMSPLITTERENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for TransformSplitterEntity {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMSPLITTERENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static TRANSFORMSPLITTERENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformSplitterEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TransformSplitterEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TransformSelectorEntity {
    pub _glacier_base: Entity,
}

pub trait TransformSelectorEntityTrait: EntityTrait {
}

impl TransformSelectorEntityTrait for TransformSelectorEntity {
}

impl EntityTrait for TransformSelectorEntity {
}

impl EntityBusPeerTrait for TransformSelectorEntity {
}

pub static TRANSFORMSELECTORENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformSelectorEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformSelectorEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(TRANSFORMSELECTORENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for TransformSelectorEntity {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMSELECTORENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static TRANSFORMSELECTORENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformSelectorEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TransformSelectorEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TransformBlendEntity {
    pub _glacier_base: Entity,
}

pub trait TransformBlendEntityTrait: EntityTrait {
}

impl TransformBlendEntityTrait for TransformBlendEntity {
}

impl EntityTrait for TransformBlendEntity {
}

impl EntityBusPeerTrait for TransformBlendEntity {
}

pub static TRANSFORMBLENDENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformBlendEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformBlendEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(TRANSFORMBLENDENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for TransformBlendEntity {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMBLENDENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static TRANSFORMBLENDENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformBlendEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TransformBlendEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SimpleDofParamConverterEntity {
    pub _glacier_base: Entity,
}

pub trait SimpleDofParamConverterEntityTrait: EntityTrait {
}

impl SimpleDofParamConverterEntityTrait for SimpleDofParamConverterEntity {
}

impl EntityTrait for SimpleDofParamConverterEntity {
}

impl EntityBusPeerTrait for SimpleDofParamConverterEntity {
}

pub static SIMPLEDOFPARAMCONVERTERENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleDofParamConverterEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SimpleDofParamConverterEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SIMPLEDOFPARAMCONVERTERENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SimpleDofParamConverterEntity {
    fn type_info(&self) -> &'static TypeInfo {
        SIMPLEDOFPARAMCONVERTERENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SIMPLEDOFPARAMCONVERTERENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleDofParamConverterEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SimpleDofParamConverterEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SpriteDofParamConverterEntity {
    pub _glacier_base: Entity,
}

pub trait SpriteDofParamConverterEntityTrait: EntityTrait {
}

impl SpriteDofParamConverterEntityTrait for SpriteDofParamConverterEntity {
}

impl EntityTrait for SpriteDofParamConverterEntity {
}

impl EntityBusPeerTrait for SpriteDofParamConverterEntity {
}

pub static SPRITEDOFPARAMCONVERTERENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpriteDofParamConverterEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SpriteDofParamConverterEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SPRITEDOFPARAMCONVERTERENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SpriteDofParamConverterEntity {
    fn type_info(&self) -> &'static TypeInfo {
        SPRITEDOFPARAMCONVERTERENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SPRITEDOFPARAMCONVERTERENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpriteDofParamConverterEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SpriteDofParamConverterEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TransformMultiplierEntity {
    pub _glacier_base: Entity,
}

pub trait TransformMultiplierEntityTrait: EntityTrait {
}

impl TransformMultiplierEntityTrait for TransformMultiplierEntity {
}

impl EntityTrait for TransformMultiplierEntity {
}

impl EntityBusPeerTrait for TransformMultiplierEntity {
}

pub static TRANSFORMMULTIPLIERENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformMultiplierEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformMultiplierEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(TRANSFORMMULTIPLIERENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for TransformMultiplierEntity {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMMULTIPLIERENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static TRANSFORMMULTIPLIERENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformMultiplierEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TransformMultiplierEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TransformHubEntity {
    pub _glacier_base: Entity,
}

pub trait TransformHubEntityTrait: EntityTrait {
}

impl TransformHubEntityTrait for TransformHubEntity {
}

impl EntityTrait for TransformHubEntity {
}

impl EntityBusPeerTrait for TransformHubEntity {
}

pub static TRANSFORMHUBENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformHubEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformHubEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(TRANSFORMHUBENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for TransformHubEntity {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMHUBENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static TRANSFORMHUBENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformHubEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("TransformHubEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct StringHubEntity {
    pub _glacier_base: Entity,
}

pub trait StringHubEntityTrait: EntityTrait {
}

impl StringHubEntityTrait for StringHubEntity {
}

impl EntityTrait for StringHubEntity {
}

impl EntityBusPeerTrait for StringHubEntity {
}

pub static STRINGHUBENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StringHubEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StringHubEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(STRINGHUBENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for StringHubEntity {
    fn type_info(&self) -> &'static TypeInfo {
        STRINGHUBENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static STRINGHUBENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StringHubEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("StringHubEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Vec4HubEntity {
    pub _glacier_base: Entity,
}

pub trait Vec4HubEntityTrait: EntityTrait {
}

impl Vec4HubEntityTrait for Vec4HubEntity {
}

impl EntityTrait for Vec4HubEntity {
}

impl EntityBusPeerTrait for Vec4HubEntity {
}

pub static VEC4HUBENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec4HubEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec4HubEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(VEC4HUBENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for Vec4HubEntity {
    fn type_info(&self) -> &'static TypeInfo {
        VEC4HUBENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VEC4HUBENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec4HubEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec4HubEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Vec3HubEntity {
    pub _glacier_base: Entity,
}

pub trait Vec3HubEntityTrait: EntityTrait {
}

impl Vec3HubEntityTrait for Vec3HubEntity {
}

impl EntityTrait for Vec3HubEntity {
}

impl EntityBusPeerTrait for Vec3HubEntity {
}

pub static VEC3HUBENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3HubEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec3HubEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(VEC3HUBENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for Vec3HubEntity {
    fn type_info(&self) -> &'static TypeInfo {
        VEC3HUBENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VEC3HUBENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3HubEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec3HubEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Vec2HubEntity {
    pub _glacier_base: Entity,
}

pub trait Vec2HubEntityTrait: EntityTrait {
}

impl Vec2HubEntityTrait for Vec2HubEntity {
}

impl EntityTrait for Vec2HubEntity {
}

impl EntityBusPeerTrait for Vec2HubEntity {
}

pub static VEC2HUBENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec2HubEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec2HubEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(VEC2HUBENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for Vec2HubEntity {
    fn type_info(&self) -> &'static TypeInfo {
        VEC2HUBENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static VEC2HUBENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec2HubEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Vec2HubEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FloatHubEntity {
    pub _glacier_base: Entity,
}

pub trait FloatHubEntityTrait: EntityTrait {
}

impl FloatHubEntityTrait for FloatHubEntity {
}

impl EntityTrait for FloatHubEntity {
}

impl EntityBusPeerTrait for FloatHubEntity {
}

pub static FLOATHUBENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatHubEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FloatHubEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(FLOATHUBENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for FloatHubEntity {
    fn type_info(&self) -> &'static TypeInfo {
        FLOATHUBENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static FLOATHUBENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatHubEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("FloatHubEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Int64HubEntity {
    pub _glacier_base: Entity,
}

pub trait Int64HubEntityTrait: EntityTrait {
}

impl Int64HubEntityTrait for Int64HubEntity {
}

impl EntityTrait for Int64HubEntity {
}

impl EntityBusPeerTrait for Int64HubEntity {
}

pub static INT64HUBENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Int64HubEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Int64HubEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(INT64HUBENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for Int64HubEntity {
    fn type_info(&self) -> &'static TypeInfo {
        INT64HUBENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static INT64HUBENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Int64HubEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Int64HubEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct IntHubEntity {
    pub _glacier_base: Entity,
}

pub trait IntHubEntityTrait: EntityTrait {
}

impl IntHubEntityTrait for IntHubEntity {
}

impl EntityTrait for IntHubEntity {
}

impl EntityBusPeerTrait for IntHubEntity {
}

pub static INTHUBENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntHubEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<IntHubEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(INTHUBENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for IntHubEntity {
    fn type_info(&self) -> &'static TypeInfo {
        INTHUBENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static INTHUBENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntHubEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("IntHubEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BoolHubEntity {
    pub _glacier_base: Entity,
}

pub trait BoolHubEntityTrait: EntityTrait {
}

impl BoolHubEntityTrait for BoolHubEntity {
}

impl EntityTrait for BoolHubEntity {
}

impl EntityBusPeerTrait for BoolHubEntity {
}

pub static BOOLHUBENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolHubEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BoolHubEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(BOOLHUBENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for BoolHubEntity {
    fn type_info(&self) -> &'static TypeInfo {
        BOOLHUBENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static BOOLHUBENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolHubEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("BoolHubEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ObjectVariationSwitchEntity {
    pub _glacier_base: Entity,
}

pub trait ObjectVariationSwitchEntityTrait: EntityTrait {
}

impl ObjectVariationSwitchEntityTrait for ObjectVariationSwitchEntity {
}

impl EntityTrait for ObjectVariationSwitchEntity {
}

impl EntityBusPeerTrait for ObjectVariationSwitchEntity {
}

pub static OBJECTVARIATIONSWITCHENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectVariationSwitchEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ObjectVariationSwitchEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(OBJECTVARIATIONSWITCHENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ObjectVariationSwitchEntity {
    fn type_info(&self) -> &'static TypeInfo {
        OBJECTVARIATIONSWITCHENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static OBJECTVARIATIONSWITCHENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectVariationSwitchEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ObjectVariationSwitchEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ObjectVariationMultiSwitchEntity {
    pub _glacier_base: Entity,
}

pub trait ObjectVariationMultiSwitchEntityTrait: EntityTrait {
}

impl ObjectVariationMultiSwitchEntityTrait for ObjectVariationMultiSwitchEntity {
}

impl EntityTrait for ObjectVariationMultiSwitchEntity {
}

impl EntityBusPeerTrait for ObjectVariationMultiSwitchEntity {
}

pub static OBJECTVARIATIONMULTISWITCHENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectVariationMultiSwitchEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ObjectVariationMultiSwitchEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(OBJECTVARIATIONMULTISWITCHENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ObjectVariationMultiSwitchEntity {
    fn type_info(&self) -> &'static TypeInfo {
        OBJECTVARIATIONMULTISWITCHENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static OBJECTVARIATIONMULTISWITCHENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectVariationMultiSwitchEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("ObjectVariationMultiSwitchEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RandomDelayEntity {
    pub _glacier_base: Entity,
}

pub trait RandomDelayEntityTrait: EntityTrait {
}

impl RandomDelayEntityTrait for RandomDelayEntity {
}

impl EntityTrait for RandomDelayEntity {
}

impl EntityBusPeerTrait for RandomDelayEntity {
}

pub static RANDOMDELAYENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RandomDelayEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RandomDelayEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(RANDOMDELAYENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for RandomDelayEntity {
    fn type_info(&self) -> &'static TypeInfo {
        RANDOMDELAYENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static RANDOMDELAYENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RandomDelayEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("RandomDelayEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DelayEntity {
    pub _glacier_base: Entity,
}

pub trait DelayEntityTrait: EntityTrait {
}

impl DelayEntityTrait for DelayEntity {
}

impl EntityTrait for DelayEntity {
}

impl EntityBusPeerTrait for DelayEntity {
}

pub static DELAYENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DelayEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DelayEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(DELAYENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for DelayEntity {
    fn type_info(&self) -> &'static TypeInfo {
        DELAYENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static DELAYENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DelayEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("DelayEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SelectEventEntity {
    pub _glacier_base: Entity,
}

pub trait SelectEventEntityTrait: EntityTrait {
}

impl SelectEventEntityTrait for SelectEventEntity {
}

impl EntityTrait for SelectEventEntity {
}

impl EntityBusPeerTrait for SelectEventEntity {
}

pub static SELECTEVENTENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectEventEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SelectEventEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SELECTEVENTENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SelectEventEntity {
    fn type_info(&self) -> &'static TypeInfo {
        SELECTEVENTENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static SELECTEVENTENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectEventEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("SelectEventEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EventOrderGateEntity {
    pub _glacier_base: Entity,
}

pub trait EventOrderGateEntityTrait: EntityTrait {
}

impl EventOrderGateEntityTrait for EventOrderGateEntity {
}

impl EntityTrait for EventOrderGateEntity {
}

impl EntityBusPeerTrait for EventOrderGateEntity {
}

pub static EVENTORDERGATEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventOrderGateEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EventOrderGateEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(EVENTORDERGATEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for EventOrderGateEntity {
    fn type_info(&self) -> &'static TypeInfo {
        EVENTORDERGATEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static EVENTORDERGATEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventOrderGateEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EventOrderGateEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EventAndGateEntity {
    pub _glacier_base: Entity,
}

pub trait EventAndGateEntityTrait: EntityTrait {
}

impl EventAndGateEntityTrait for EventAndGateEntity {
}

impl EntityTrait for EventAndGateEntity {
}

impl EntityBusPeerTrait for EventAndGateEntity {
}

pub static EVENTANDGATEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventAndGateEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EventAndGateEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(EVENTANDGATEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for EventAndGateEntity {
    fn type_info(&self) -> &'static TypeInfo {
        EVENTANDGATEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static EVENTANDGATEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventAndGateEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EventAndGateEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EventSwitchEntity {
    pub _glacier_base: Entity,
}

pub trait EventSwitchEntityTrait: EntityTrait {
}

impl EventSwitchEntityTrait for EventSwitchEntity {
}

impl EntityTrait for EventSwitchEntity {
}

impl EntityBusPeerTrait for EventSwitchEntity {
}

pub static EVENTSWITCHENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventSwitchEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EventSwitchEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(EVENTSWITCHENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for EventSwitchEntity {
    fn type_info(&self) -> &'static TypeInfo {
        EVENTSWITCHENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static EVENTSWITCHENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventSwitchEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("EventSwitchEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct UniqueIdEntity {
    pub _glacier_base: Entity,
}

pub trait UniqueIdEntityTrait: EntityTrait {
}

impl UniqueIdEntityTrait for UniqueIdEntity {
}

impl EntityTrait for UniqueIdEntity {
}

impl EntityBusPeerTrait for UniqueIdEntity {
}

pub static UNIQUEIDENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UniqueIdEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<UniqueIdEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(UNIQUEIDENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for UniqueIdEntity {
    fn type_info(&self) -> &'static TypeInfo {
        UNIQUEIDENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static UNIQUEIDENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UniqueIdEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("UniqueIdEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RandomIntEntity {
    pub _glacier_base: Entity,
}

pub trait RandomIntEntityTrait: EntityTrait {
}

impl RandomIntEntityTrait for RandomIntEntity {
}

impl EntityTrait for RandomIntEntity {
}

impl EntityBusPeerTrait for RandomIntEntity {
}

pub static RANDOMINTENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RandomIntEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RandomIntEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(RANDOMINTENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for RandomIntEntity {
    fn type_info(&self) -> &'static TypeInfo {
        RANDOMINTENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static RANDOMINTENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RandomIntEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("RandomIntEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RandomFloatEntity {
    pub _glacier_base: Entity,
}

pub trait RandomFloatEntityTrait: EntityTrait {
}

impl RandomFloatEntityTrait for RandomFloatEntity {
}

impl EntityTrait for RandomFloatEntity {
}

impl EntityBusPeerTrait for RandomFloatEntity {
}

pub static RANDOMFLOATENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RandomFloatEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RandomFloatEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(RANDOMFLOATENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for RandomFloatEntity {
    fn type_info(&self) -> &'static TypeInfo {
        RANDOMFLOATENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static RANDOMFLOATENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RandomFloatEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("RandomFloatEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RandomMultiEventEntity {
    pub _glacier_base: Entity,
}

pub trait RandomMultiEventEntityTrait: EntityTrait {
}

impl RandomMultiEventEntityTrait for RandomMultiEventEntity {
}

impl EntityTrait for RandomMultiEventEntity {
}

impl EntityBusPeerTrait for RandomMultiEventEntity {
}

pub static RANDOMMULTIEVENTENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RandomMultiEventEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RandomMultiEventEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(RANDOMMULTIEVENTENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for RandomMultiEventEntity {
    fn type_info(&self) -> &'static TypeInfo {
        RANDOMMULTIEVENTENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static RANDOMMULTIEVENTENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RandomMultiEventEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("RandomMultiEventEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RandomEventEntity {
    pub _glacier_base: Entity,
}

pub trait RandomEventEntityTrait: EntityTrait {
}

impl RandomEventEntityTrait for RandomEventEntity {
}

impl EntityTrait for RandomEventEntity {
}

impl EntityBusPeerTrait for RandomEventEntity {
}

pub static RANDOMEVENTENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RandomEventEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RandomEventEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(RANDOMEVENTENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for RandomEventEntity {
    fn type_info(&self) -> &'static TypeInfo {
        RANDOMEVENTENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static RANDOMEVENTENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RandomEventEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("RandomEventEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LocatorEntity {
    pub _glacier_base: SpatialEntity,
}

pub trait LocatorEntityTrait: SpatialEntityTrait {
}

impl LocatorEntityTrait for LocatorEntity {
}

impl SpatialEntityTrait for LocatorEntity {
}

impl EntityTrait for LocatorEntity {
}

impl EntityBusPeerTrait for LocatorEntity {
}

pub static LOCATORENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocatorEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SPATIALENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LocatorEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(LOCATORENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for LocatorEntity {
    fn type_info(&self) -> &'static TypeInfo {
        LOCATORENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static LOCATORENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocatorEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("LocatorEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CountDownEntity {
    pub _glacier_base: Entity,
}

pub trait CountDownEntityTrait: EntityTrait {
}

impl CountDownEntityTrait for CountDownEntity {
}

impl EntityTrait for CountDownEntity {
}

impl EntityBusPeerTrait for CountDownEntity {
}

pub static COUNTDOWNENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CountDownEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CountDownEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(COUNTDOWNENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for CountDownEntity {
    fn type_info(&self) -> &'static TypeInfo {
        COUNTDOWNENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static COUNTDOWNENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CountDownEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("CountDownEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MathEntity {
    pub _glacier_base: Entity,
}

pub trait MathEntityTrait: EntityTrait {
}

impl MathEntityTrait for MathEntity {
}

impl EntityTrait for MathEntity {
}

impl EntityBusPeerTrait for MathEntity {
}

pub static MATHENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MathEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MathEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(MATHENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for MathEntity {
    fn type_info(&self) -> &'static TypeInfo {
        MATHENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static MATHENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MathEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("MathEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Or4Entity {
    pub _glacier_base: Entity,
}

pub trait Or4EntityTrait: EntityTrait {
}

impl Or4EntityTrait for Or4Entity {
}

impl EntityTrait for Or4Entity {
}

impl EntityBusPeerTrait for Or4Entity {
}

pub static OR4ENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Or4Entity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Or4Entity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(OR4ENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for Or4Entity {
    fn type_info(&self) -> &'static TypeInfo {
        OR4ENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static OR4ENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Or4Entity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("Or4Entity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct XorEntity {
    pub _glacier_base: Entity,
}

pub trait XorEntityTrait: EntityTrait {
}

impl XorEntityTrait for XorEntity {
}

impl EntityTrait for XorEntity {
}

impl EntityBusPeerTrait for XorEntity {
}

pub static XORENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "XorEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<XorEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(XORENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for XorEntity {
    fn type_info(&self) -> &'static TypeInfo {
        XORENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static XORENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "XorEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("XorEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct OrEntity {
    pub _glacier_base: Entity,
}

pub trait OrEntityTrait: EntityTrait {
}

impl OrEntityTrait for OrEntity {
}

impl EntityTrait for OrEntity {
}

impl EntityBusPeerTrait for OrEntity {
}

pub static ORENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OrEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<OrEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(ORENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for OrEntity {
    fn type_info(&self) -> &'static TypeInfo {
        ORENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ORENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OrEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("OrEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BitwiseAndEntity {
    pub _glacier_base: Entity,
}

pub trait BitwiseAndEntityTrait: EntityTrait {
}

impl BitwiseAndEntityTrait for BitwiseAndEntity {
}

impl EntityTrait for BitwiseAndEntity {
}

impl EntityBusPeerTrait for BitwiseAndEntity {
}

pub static BITWISEANDENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BitwiseAndEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BitwiseAndEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(BITWISEANDENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for BitwiseAndEntity {
    fn type_info(&self) -> &'static TypeInfo {
        BITWISEANDENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static BITWISEANDENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BitwiseAndEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("BitwiseAndEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AndEntity {
    pub _glacier_base: Entity,
}

pub trait AndEntityTrait: EntityTrait {
}

impl AndEntityTrait for AndEntity {
}

impl EntityTrait for AndEntity {
}

impl EntityBusPeerTrait for AndEntity {
}

pub static ANDENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AndEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AndEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(ANDENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for AndEntity {
    fn type_info(&self) -> &'static TypeInfo {
        ANDENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static ANDENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AndEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("AndEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct NotEntity {
    pub _glacier_base: Entity,
}

pub trait NotEntityTrait: EntityTrait {
}

impl NotEntityTrait for NotEntity {
}

impl EntityTrait for NotEntity {
}

impl EntityBusPeerTrait for NotEntity {
}

pub static NOTENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NotEntity",
    flags: MemberInfoFlags::new(101),
    module: "Entity",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<NotEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(NOTENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for NotEntity {
    fn type_info(&self) -> &'static TypeInfo {
        NOTENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}


pub static NOTENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NotEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Entity",
    data: TypeInfoData::Array("NotEntity"),
    array_type: None,
    alignment: 8,
};


